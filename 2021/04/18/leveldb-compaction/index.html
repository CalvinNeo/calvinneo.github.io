<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据库,leveldb," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：  Minor Compaction 对应Memtable到SSTable的过程。 Major Compaction 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。 Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek com">
<meta name="keywords" content="数据库,leveldb">
<meta property="og:type" content="article">
<meta property="og:title" content="LevelDB之Compaction实现">
<meta property="og:url" content="http://www.calvinneo.com/2021/04/18/leveldb-compaction/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：  Minor Compaction 对应Memtable到SSTable的过程。 Major Compaction 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。 Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek com">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/arch.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/STCS.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/LCS.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/cm.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/manifest.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/version.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/versionset.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/versionset_link.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/AddBoundaryInputsProblem.png">
<meta property="og:updated_time" content="2021-08-18T07:26:48.196Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LevelDB之Compaction实现">
<meta name="twitter:description" content="本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：  Minor Compaction 对应Memtable到SSTable的过程。 Major Compaction 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。 Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek com">
<meta name="twitter:image" content="http://www.calvinneo.com/img/leveldb/compaction/arch.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/"/>





  <title>LevelDB之Compaction实现 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LevelDB之Compaction实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-18T23:09:06+08:00">
                2021-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：</p>
<ol>
<li>Minor Compaction<br> 对应Memtable到SSTable的过程。</li>
<li>Major Compaction<br> 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。<br> Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。</li>
</ol>
<p>在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。</p>
<p>同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。</p>
<a id="more"></a>


<p>我们首先来回顾一下LevelDB的整体架构<br><img src="/img/leveldb/compaction/arch.png"></p>
<p>之前提到过，当一个Memtable满了之后，会转化为Immutable Memtable。Immutable Memtable会被Dump成SSTable文件，SSTable文件是不可变的。<br>这里<code>GUARDED_BY(m)</code>实际上是<code>__attribute__(guarded_by(m))</code>这个线程安全注解，方便编译器帮助检查有没有遗漏掉加锁的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="LCS和STCS"><a href="#LCS和STCS" class="headerlink" title="LCS和STCS"></a>LCS和STCS</h2><p>有两种Compacton方案：Size-Tiered Compaction Strategy(STCS)和Leveled Compaction Strategy(LCS)。</p>
<h3 id="STCS"><a href="#STCS" class="headerlink" title="STCS"></a>STCS</h3><p>Memtable刷成小sstable。当这些小的sstable达到一定个数时，会被compact成一个稍大些的sstable。当稍大些的sstable又达到一定个数时，又会被一起compact成更大的sstable。当然，如果说某些Key的更新频率比较高，那么在Compact的时候只会取最新的Sequence Number，这种情况下，可能不会增加太多。<br>下图是STCS的一个示意，可以看到，每层的SSTable<strong>数量不变</strong>，但是大小<strong>越来越大</strong>。<br><img src="/img/leveldb/compaction/STCS.png"></p>
<h3 id="LCS-Classic-Leveled"><a href="#LCS-Classic-Leveled" class="headerlink" title="LCS(Classic Leveled)"></a>LCS(Classic Leveled)</h3><p>STCS存在一些问题，是可以被优化的：</p>
<ol>
<li>存储放大1<br> 因为Compaction时，在新SSTable生成前，旧的SSTable不能删除（当然LevelDB中有Version的概念，其实更复杂点），所以可能会造成额外一倍的开销。<br> 于是我们临机一动，我们增加SSTable数量，而控制大小不变，不就能控制这额外一倍开销的绝对数量么？</li>
<li>存储放大2<br> 如果Key更新频繁，可能导致同一个Level以及不同Level中的SSTable中存在相同的Key。这里的Key实际上就是LevelDB里面的user key，而不是带有Sequence Number的InternalKey。<br> 【Q】为什么不同Level会存在呢？</li>
</ol>
<p>为此，我们就得到了LCS：</p>
<ol>
<li>当Level0层数量达到Level0层阈值时，将这些SSTable和L1层的所有SSTable做Compaction。<br> 实际上，具体涉及哪些SSTable，在LevelDB中控制更为精细。并且Compaction的条件也更复杂。</li>
<li>如果Level1层的SSTable数量还是超过L1层的阈值，再把这些超出的SSTable向上做Compaction。</li>
<li><strong>除了Level0，其他层的所有SSTable中的key都是不重叠的。</strong></li>
</ol>
<p>下图是LCS的一个示意<br><img src="/img/leveldb/compaction/LCS.png"></p>
<p>我们注意到，LCS中，SSTable的大小不变，但是数量会增多，Level N+1的<strong>文件数量</strong>是Level N的10倍。【Q】这里看上去和LevelDB的实现还有区别，LevelDB里面的<code>MaxBytesForLevel</code>函数更多的是计算了10倍的大小，Why？这个我们在“Major Compaction流程”章节中讨论过了，每个文件大小是固定的，LevelDB通过限制每层的总大小来间接限制文件数量。这是因为我们dump的时候更方便统计大小而不是文件数量。<br>所以，假如Level1有10个文件，Level2就有100个文件。但是key在两个level中都是均匀分布的，因此我Level1拿出一个文件出来，Level2中估计只会有10个文件和它重叠，所以我们只需要合并重叠的这些文件就行了。<br>当然，Level0彼此重叠，所以还是emmmm。。。</p>
<p>LCS的缺点是写放大会比STCS显著提高。</p>
<p>【Q】既然LCS的写放大高了很多，为什么说基于LSM的写性能很好呢？可能是因为下面几点</p>
<ol>
<li>SSTable是顺序写，性能好【Q】</li>
<li>根据<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">RocksDB</a>的文档，在一些情况下写放大不是很严重<br> 首先是按key顺序的写，对于这种情况RocksDB可以优化。<br> 其次是有skew的写，会导致只有小部分的key被更新。</li>
</ol>
<h3 id="Level-N"><a href="#Level-N" class="headerlink" title="Level-N"></a>Level-N</h3><p>相比LCS(Classic Leveled)有更高的读放大，和更小的写放大。</p>
<h3 id="Tiered-Leveled"><a href="#Tiered-Leveled" class="headerlink" title="Tiered+Leveled"></a>Tiered+Leveled</h3><h1 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h1><p>需要注意的是，LevelDB是一个单机的数据库，所以实际承载的SSTable文件都位于一台机器上。</p>
<p><img src="/img/leveldb/compaction/cm.png"></p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType &#123;</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>kLogFile：WAL日志文件，文件名数字.log</li>
<li>kDBLockFile：db锁文件，文件名LOCK</li>
<li>kTableFile：SSTable文件，文件名数字.sst</li>
<li>kDescriptorFile：Manifest文件，存储VersionEdit信息，文件名为MANIFEST-数字<br> 对应<code>descriptor_file_</code>这个字段。<br> Manifest文件中维护了所有的SSTable的key范围，层级，以及其他的元信息。</li>
<li>kCurrentFile：记录当前的Manifest文件，文件名为CURRENT</li>
<li>kTempFile：临时文件，db在修复【？】过程中会产生临时文件，文件名为数字.dbtmp</li>
<li>kInfoLogFile：日志文件，文件名为LOG</li>
</ol>
<h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>每一个VersionEdit对应Manifest里面的一个Entry，<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">称为Session Record</a>。<br><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">其中第一条Session Record包含当时LevelDB的全量版本信息</a>，这个应该是通过<code>WriteSnapshot</code>来实现的，可以看下面的介绍。</p>
<p>如下所示，每个Entry包含</p>
<ol>
<li>增加的SSTable<br> kNewFile</li>
<li>删除的SSTable<br> kDeletedFile</li>
<li>当前Compaction的下标<br> kCompactPointer</li>
<li>日志文件编号<br> kLogNumber</li>
<li>数据库已经持久化数据项中最大的Sequence Number<br> kLastSequence</li>
</ol>
<p>对应的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/leveldb/compaction/manifest.png"></p>
<p>写Manifest的代码应该是<code>Writer::AddRecord</code>。<br>读Manifest的代码，例如<code>VersionSet::Recover</code>。</p>
<h2 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h2><p>记录当前的Manifest文件名。</p>
<h1 id="MVCC介绍"><a href="#MVCC介绍" class="headerlink" title="MVCC介绍"></a>MVCC介绍</h1><p>参考<a href="/2017/09/20/transaction/">数据库系统中的事务</a></p>
<h1 id="Version机制"><a href="#Version机制" class="headerlink" title="Version机制"></a>Version机制</h1><p>大前提，Compaction过程是通过独立线程异步并发执行的。因此可能出现压缩前后的新老SSTable并存的情况。同时，我们不能立即删除老的SSTable文件，这可能是因为这个SSTable还在被读取，而要等到老SSTable的引用计数为0才行。因此Version机制可以用来辨别这些SSTable的版本。借助于Version机制，也能实现MVCC。</p>
<p>新版本New-Version由<code>Version</code>类和<code>VersionEdit</code>类来描述。即<code>VersionEdit</code>是New-Version相对于Version的改动。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-<span class="keyword">Version</span> = <span class="keyword">Version</span> + VersionEdit</span><br></pre></td></tr></table></figure>

<p><img src="/img/leveldb/compaction/version.png"></p>
<p>LevelDB将所有的Version置于一个双向链表之中，因此所有的Version组成一个名为VersionSet的集合。这个集合也代表了当前DB的状态，包含了最新的Version，以及其他正在服务的Version。<br><img src="/img/leveldb/compaction/versionset.png"></p>
<h2 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h2><p>介绍作为桥梁作用的<code>VersionEdit</code>类。这个类里面的方法大部分是用来读写里面的私有成员的，所以只介绍私有成员。</p>
<ol>
<li><p><code>std::string comparator_;</code></p>
</li>
<li><p><code>uint64_t log_number_;</code><br> 包含</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure>

<p> log文件的file number，也就是<code>000003.log</code>的这个3。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">小于这个值的Log是可以被删除的</a><br> 【Q】这个字段的作用是什么呢？<br> 目前来看，在Recover的时候会用到。<br> 【Q】为什么VersionSet里面也有？<br> 其实VersionSet里面的才是主要的，VersionEdit里面的这个字段，是在LogAndApply的时候，由VersionSet设置过来的。<br> 【Q】这个number，和版本的关系是什么，是一一对应的么？比如一次Compaction之后就要换个log？因为在实现上，可以看到<code>NewFileNumber</code>会产生log(<code>DB::Open</code>)和SSTable(<code>WriteLevel0Table</code>)文件的序列号。</p>
</li>
<li><p><code>uint64_t prev_log_number_;</code>/<code>bool has_prev_log_number_;</code><br> 包括<code>void SetPrevLogNumber(uint64_t num)</code>这个函数。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">这篇文章</a>说<code>prev_log_number_</code>已经废弃了，出于兼容性才保留的。</p>
</li>
<li><p><code>uint64_t next_file_number_;</code>/<code>bool has_next_file_number_;</code><br> 下一个可用的file number。VersionSet里面也有类似字段，详细介绍见VersionSet。<br> 包含</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure></li>
<li><p><code>SequenceNumber last_sequence_;</code>/<code>bool has_last_sequence_;</code><br> SSTable 中的最大的Sequence Number。VersionSet里面也有个平行的。</p>
</li>
<li><p><code>bool has_comparator_;</code></p>
</li>
<li><p><code>bool has_log_number_;</code></p>
</li>
<li><p><code>std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</code><br> 主要用于Major Compaction的时候选择文件。first表示每个level。<br> 【Q】在<code>Compaction</code>类和<code>VersionSet</code>类里面也有一个这个字段。它们的作用是什么呢？</p>
</li>
<li><p><code>DeletedFileSet deleted_files_;</code></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br></pre></td></tr></table></figure>

<p> pair存储了level和file。表示将第level层中的file删除。</p>
</li>
<li><p><code>std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</code><br> <code>FileMetaData</code>存储了文件大小，以及文件中最小的Key和最大的Key。</p>
</li>
</ol>
<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h3 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h3><ol>
<li><p>VersionSet相关<br> 指向这个Version所属的VersionSet，以及双向链表和引用计数。<br> 所以说每个Version只能属于一个VersionSet，这个也是很好理解的，</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"><span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br></pre></td></tr></table></figure></li>
<li><p>SSTable相关<br> <code>files_</code>表示LevelDB中每一层中所有的SSTable的文件信息。<br> <code>file_to_compact(_level)_</code>标记下一个要Compact的文件以及属于的Level。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure>

<p> 根据<code>SaveTo</code>函数的<a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">论述</a>，**<code>files_[level]</code>是有序的**。</p>
</li>
<li><p>其他字段<br> <code>compaction_score_</code><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">计算最迫切需要Compaction的Level</a>，所以可以决定是否需要发起Major Compaction。这个分数取决于某一层所有SSTable的大小。<br> <code>NeedsCompaction</code>会读取这个字段，计算是否需要根据Version的情况来Compaction，并呈递给<code>MaybeScheduleCompaction</code>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"><span class="comment">// Score &lt; 1 means compaction is not strictly needed.</span></span><br><span class="line"><span class="keyword">double</span> compaction_score_;</span><br><span class="line"><span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol>
<li><code>int PickLevelForMemTableOutput(const Slice&amp; smallest_user_key, const Slice&amp; largest_user_key);</code><br> 给定一个Memtable里面的Key的范围，返回这个Memtable被Dump的话要放到第几层。</li>
<li><code>Compaction* PickCompaction();</code><br> 用来处理size compaction和seek compaction。<br> 这个函数，在“Compaction主函数”这个章节介绍。</li>
<li><code>Compaction* CompactRange(int level, const InternalKey* begin, const InternalKey* end);</code></li>
</ol>
<h3 id="Version-PickLevelForMemTableOutput"><a href="#Version-PickLevelForMemTableOutput" class="headerlink" title="Version::PickLevelForMemTableOutput"></a>Version::PickLevelForMemTableOutput</h3><h4 id="OverlapInLevel"><a href="#OverlapInLevel" class="headerlink" title="OverlapInLevel"></a>OverlapInLevel</h4><p>先介绍辅助函数<code>OverlapInLevel</code>，作用是判断范围<code>[smallest_user_key,largest_user_key]</code>和level中的文件有没有Overlap。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Version::OverlapInLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span><br><span class="line">                             <span class="keyword">const</span> Slice* largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                               smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SomeFileOverlapsRange"><a href="#SomeFileOverlapsRange" class="headerlink" title="SomeFileOverlapsRange"></a>SomeFileOverlapsRange</h4><p>SomeFileOverlapsRange返回<code>files</code>中有没有在范围<code>[smallest_user_key,largest_user_key]</code>中的key，是<code>OverlapInLevel</code>的辅助函数。<br><code>disjoint_sorted_files</code>表示传入的<code>files</code>里面的key是不是不相交的，一般除了Level0，其他都是不相交的。<br><code>AfterFile</code>和<code>BeforeFile</code>都比较FileMetaData里面的<code>largest</code>/<code>smallest</code>的<code>user_key()</code>字段。他们的类型是<code>InternalKey</code>，也就是不带Sequence Number和Value Type的。<br>对于普通情况，对于一个文件<code>f</code>，如果<code>smallest_user_key</code>大于该文件中的最大值，或者<code>largest_user_key</code>小于最小值，那么认为是不重叠的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SomeFileOverlapsRange</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> disjoint_sorted_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = icmp.user_comparator();</span><br><span class="line">  <span class="keyword">if</span> (!disjoint_sorted_files) &#123;</span><br><span class="line">    <span class="comment">// Need to check against all files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      <span class="keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||</span><br><span class="line">          BeforeFile(ucmp, largest_user_key, f)) &#123;</span><br><span class="line">        <span class="comment">// No overlap</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Overlap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果是不相交的文件，就可以基于<code>FindFile</code>对<code>files</code>集合二分查找，<strong>所以我们看到，在某一个Level找SSTable的时候是可以二分的</strong>。<br>可以思考一下我们用什么做二分的key呢？答案是每个file的largest。我们要找到第一个largest大于等于<code>smallest_user_key</code>的文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Binary search over file list</span></span><br><span class="line">  <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (smallest_user_key != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Find the earliest possible internal key for smallest_user_key</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">small_key</span><span class="params">(*smallest_user_key, kMaxSequenceNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">                          kValueTypeForSeek)</span></span>;</span><br><span class="line">    index = FindFile(icmp, files, small_key.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= files.size()) &#123;</span><br><span class="line">    <span class="comment">// beginning of range is after all files, so no overlap.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>二分法找到<strong>可能存在</strong>的文件<code>files[index]</code>后，不要忘了在判断下这个文件<strong>实际有没有overlap</strong>。这是二分法的基本规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span><br><span class="line">                                        <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>首先判断我们要加入的文件的<code>[smallest_user_key,largest_user_key]</code>和Level0有没有交叠。如果有交叠，就进不了这个if，直接放到第一层，等后面Major Compaction了。<br>如果没有交叠，我们尝试能否将它下放到<code>config::kMaxMemCompactLevel</code>之前的层。【Q】为什么我们要设置上限<code>kMaxMemCompactLevel</code>呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为什么会有这个？下面讲。</span></span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断level-2层情况的分支详解"><a href="#判断level-2层情况的分支详解" class="headerlink" title="判断level + 2层情况的分支详解"></a>判断level + 2层情况的分支详解</h4><p>这里需要着重讲解一下<code>level + 2 &lt; config::kNumLevels</code>这个分支的含义。</p>
<p>作为普通人呢，我觉得判断完<code>OverlapInLevel(level + 1,...</code>就可以直接<code>level++</code>了啊，但是大佬肯定是不平凡的。<br>大佬觉得现在我们想把文件放到level + 1层，但是要先打住，看看level + 2层是什么情况，也就对应到下面的代码。我们要计算所有重叠的文件的总大小，如果这个大小超过了阈值，那么我们就不把这个SSTable进行下放。<br>这是防止level + 1和level + 2的重叠范围太大，导致这两层进行Compaction时涉及的SSTable过多，耗时过长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickLevelForMemTableOutput中的片段代码</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>于是，先要用<code>GetOverlappingInputs</code>这个函数，计算level + 2层中到底有哪些文件和<code>[smallest_user_key,largest_user_key]</code>有交叠，这些文件会放到<code>overlaps</code>里面。<br>而<code>TotalFileSize</code>这个函数就是对<code>FileMetaData::file_size</code>求和。<br>然后，我们和<code>MaxGrandParentOverlapBytes</code>返回的阈值进行比较。</p>
<h4 id="GetOverlappingInputs-MaxGrandParentOverlapBytes"><a href="#GetOverlappingInputs-MaxGrandParentOverlapBytes" class="headerlink" title="GetOverlappingInputs/MaxGrandParentOverlapBytes"></a>GetOverlappingInputs/MaxGrandParentOverlapBytes</h4><p><code>GetOverlappingInputs</code>的目标是找到level中和<code>[begin,end]</code>重叠的所有文件，并放到<code>inputs</code>里面。这个函数对Level0有特殊的处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="keyword">void</span> Version::GetOverlappingInputs(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span><br><span class="line">                                   <span class="keyword">const</span> InternalKey* end,</span><br><span class="line">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs) &#123;</span><br></pre></td></tr></table></figure>

<p><code>user_begin</code>和<code>user_end</code>是从InternalKey中提取出的user key。如果传入nullptr，表示在比较时<code>begin</code>永远小于任何key。<br>【Q】这里为什么去找的user key而不是InternalKey呢？貌似很多地方都是找user key。在<a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">这篇文章</a>中，作者指出了一个其实我们很容易注意到的性质，就是除了Level0，每一层Level都是有序的。进一步地，由于LevelDB使用leveled策略(LCS)，即强调一个key在每一层至多只有1条记录，不存在冗余记录。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; config::kNumLevels);</span><br><span class="line">  inputs-&gt;clear();</span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (begin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = begin-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = end-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>默认，我们遍历这一层的所有的文件。前面两个if分别处理文件和range完全不重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>否则就是有重叠的，我们把这个文件加入到<code>inputs</code>里面作为结果返回。对于<code>PickLevelForMemTableOutput</code>的逻辑而言，这里就到此为止了。<br>但是<code>GetOverlappingInputs</code>这个函数还会在<code>CompactRange</code>、<code>SetupOtherInputs</code>这些函数中用到。此时，需要处理Level0的逻辑。<strong>【Q】且慢，我们已经逐文件遍历了啊，还会有什么问题呢？</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">这篇文章</a>中，详细解释了原因。这是因为我们认为Level1的文件是比Level0要旧的，所以<strong>如果要把Level0中的某个文件<code>f</code>移动到Level1中，我们要把Level0中所有和<code>f</code>Overlap的文件都放到Level1里面</strong>。这样，实际上保证了如果我有一个Key在Level0里面，那么inputs里面会包含所有包含这个Key的文件。</p>
<p>进一步想，在Level0往Level1归并的时候，其实也应该看到这个过程。事实上观看<code>PickCompaction</code>的代码实现，我们也能看到在最后有个<code>if (level == 0)</code>的判断。</p>
<p>这个应当同样解决我们在<code>IsTrivialMove</code>的一个疑问，也就是为什么Level层有两个的时候，我们不能简单把其中一个文件移动到下层。</p>
<p>所以，当检查到<code>user_begin</code>在文件<code>[file_start,file_limit]</code>中后，需要将<code>user_begin</code>调整为文件的开头<code>file_start</code>。对<code>user_end</code>也是同理的。</p>
<h2 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h2><h3 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h3><ol>
<li><code>Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu)</code><br> 这个函数接受一个VersionEdit。<br> 首先，函数将VersionEdit应用在<code>current_</code>，并借助于<code>VersionSet::Builder</code>生成一个新的Version。Builder类的实现是比较巧妙的，我们会在稍后来讲解。<br> 此后，它会调用<code>Finalize</code>函数更新<code>compaction_level_</code>和<code>compaction_score_</code>。<br> 此后，更新Manifest文件。主要是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。<br> 此后，调用<code>AppendVersion</code>将新版本添加到VersionSet的双向链表中，并且设置新的<code>current_</code>。</li>
<li><code>std::string compact_pointer_[config::kNumLevels];</code><br> 这个字段在Major Compaction过程中被用到。表示每一层上，下一次Compaction需要开始的key的位置。它要么是一个空串，要么是一个InternalKey。<br> 【Q】在什么时候被设置呢？<br> 根据<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">文章</a>，这个<code>compact_pointer_</code>实际上表示这一层上一次Compact时文件的largest。</li>
<li><code>Status Recover(bool* save_manifest);</code><br> 关于Recover机制，我们不在这篇文章中介绍。详见“LevelDB之流程概览”这篇文章。</li>
</ol>
<p>有关Sequence：</p>
<ol>
<li><code>uint64_t LastSequence() const { return last_sequence_; }</code><br> 还有个对应的<code>SetLastSequence</code>方法。<br> 返回最近的Sequence Number。这个是在写入记录的时候会使用并且更新。<br> 【Q】VersionEdit里面也有个平行的，他们之间的关系是什么呢？<br> 首先VersionSet的<code>last_sequence_</code>会随着<code>DBImpl::Write</code>操作更新。<br> 当需要进行Compact的时候，会在<code>LogAndApply</code>中赋给VersionEdit中的对应字段。而VersionEdit的目的，似乎只是持久化这个信息。</li>
</ol>
<p>有关日志：</p>
<ol>
<li><code>prev_log_number_</code>/<code>log_number_</code><br> 【Q】和VersionEdit里面同名字段的关系是什么？见VersionEdit的解释。</li>
</ol>
<p>有关文件编号：</p>
<ol>
<li><p><code>next_file_number_</code><br> 包含</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">    next_file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个字段用来生成系统中下个文件的编号。VersionEdit需要在LogAndApply时传入，以persist。<br> 【Q】这里的file number指的是SSTable的file number么？<a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">看起来并不是的</a>，而是<a href="https://www.wandouip.com/t5i49833/" target="_blank" rel="noopener">Manifest文件、SSTable文件啥的共用一个编号</a>，这也是为什么一开始Log文件是0，Minifest文件是1，SetNextFile是2的原因。</p>
</li>
<li><p><code>manifest_file_number_;</code><br> 表示Manifest文件的编号，主要在Recover时用到</p>
</li>
</ol>
<p>疑问：</p>
<ol>
<li>VersionSet和DBImpl是一一对应的么？<br> 应该是的，DBImpl持有一个<code>VersionSet*</code>。</li>
</ol>
<h3 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h3><p>在前面已经简单介绍过这个函数的功能了。这个函数主要在下面几个地方用到：</p>
<ol>
<li><code>DB::Open</code><br> 当DB启动的时候，可能需要从通过<code>DBImpl::Recover</code>从log中恢复一部分数据。这些数据会以VersionEdit的方式被Apply。</li>
<li><code>DBImpl::CompactMemTable</code><br> Minor Compaction。<br> 一般在下面的地方调用：<ul>
<li>BackgroundCompaction</li>
<li>DoCompactionWork：也就是在Major Compaction的过程中也要有限处理Minor Compaction。</li>
</ul>
</li>
<li><code>BackgroundCompaction</code>的非manual情况（平凡情况）<br> 这种情况只是将某个SSTable移动到别的层。</li>
<li><code>BackgroundCompaction</code>的manual情况（一般情况）<br> 需要归并。</li>
</ol>
<p>下面这里讲解一下源码。<br><code>__attribute__((exclusive_locks_required))</code>表示检查在调用<code>LogAndApply</code>函数之前就要持有锁<code>mu</code>。因此同时只会有一个线程执行<code>LogAndApply</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">  <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br></pre></td></tr></table></figure>

<p>下面是把VersionSet的LogNumber传给VersionEdit。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们要把VersionSet的<code>last_sequence_</code>传给edit，在对<code>VersionSet::Builder</code>的论述中已经推断过这里的作用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">  Finalize(v);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的<code>descriptor_file_</code>就是一个Manifest文件。<br>如果此时<code>descriptor_log_</code>是NULL，根据注释，这个对应到首次打开数据库的状态。我们要新建一个Manifest文件，此时<code>DescriptorFileName</code>产生一个<code>&quot;/MANIFEST-%06llu&quot;</code>格式的文件名字。<br>通过<code>WriteSnapshot</code>把<code>descriptor_log_</code>写到新的Manifest文件里面，这个实际上就是Current Version的快照。<code>WriteSnapshot</code>里面也会调用<code>EncodeTo</code>和<code>AddRecord</code>。<br>【Q】为什么有这个函数？本文之前介绍了Manifest文件的构造，里面提到第一条Session Record记录了当前数据库的全量数据，我认为这里就是实现这个性质的。<br>【Q】注意，<code>VersionSet::ReuseManifest</code>也会修改这个<code>descriptor_log_</code>，有什么影响呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。这里不是写快照了，而是写一条Log。其实Manifest文件的格式就是Log。<br>在这里，将写文件的操作都集中在一起，期间是不要加锁的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>EncodeTo</code>将信息按照下面的Tag分类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>AddRecord</code>将信息编码到文件中，对应的读取函数是<code>Reader::ReadRecord</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们现在得到了一个新的Version即<code>v</code>，调用<code>AppendVersion</code>将它设置为<code>current_</code>。这个函数还会将<code>v</code>添加到VersionSet里面的那个双向链表里面。<br><a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">文章</a>中有疑问这里遇到多线程怎么办，但LevelDB中Compact只有一条后台线程，并且这里是持有锁的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VersionSet-AppendVersion"><a href="#VersionSet-AppendVersion" class="headerlink" title="VersionSet::AppendVersion"></a>VersionSet::AppendVersion</h3><p>这里<code>dummy_versions_</code>是VersionSet维护的环状链表头，<code>dummy_versions_.prev_</code>就是<code>current_</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::AppendVersion(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">下面的图</a>清晰看出<br><img src="/img/leveldb/compaction/versionset_link.png"></p>
<h3 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h3><ol>
<li><code>VersionSet* vset_;</code><br> 在构造时传入的VersionSet。</li>
<li><code>Version* base_;</code><br> 在构造时传入的，一般为<code>current_</code></li>
<li><code>LevelState levels_[config::kNumLevels];</code><br> LevelState里面记录了增加和删除的文件。</li>
<li><code>void Apply(VersionEdit* edit)</code><br> 将<code>edit</code>里面的变动应用到<code>current_</code>。例如要加些什么文件，写到<code>levels_[level].added_files</code>这个列表里面。但是我们不实际加，而是到<code>SaveTo</code>里面再一次性加。<br> 【Q】为什么要这样子呢？原因有2：<ol>
<li><code>v-&gt;files_[level]</code>这个是有序存储的。</li>
</ol>
</li>
<li><code>void SaveTo(Version* v)</code><br> 注意，从<code>VersionSet::Recover</code>可以看出，Applt和SaveTo并不是一对一的关系。例如我们从一个文件中多个记录里面恢复，那么每读取一个记录就要Apply一次，但最后再SaveTo。</li>
</ol>
<h4 id="VersionSet-Builder-Apply"><a href="#VersionSet-Builder-Apply" class="headerlink" title="VersionSet::Builder::Apply"></a>VersionSet::Builder::Apply</h4><p>这个函数设置诸如<code>levels_[level].added_files</code>的字段，表示我们需要做什么改变。<br>首先将VersionEdit记录的<code>compact_pointers_</code>应用到VersionSet。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后把要增加和删除的文件记录到自己的<code>levels_</code>字段里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在增加文件的时候，需要处理<code>allowed_seeks</code>字段。这里的<code>16384U</code>有点奇怪，是啥意思？<br>根据注释，我们假设：</p>
<ol>
<li>一次Seek耗时10ms</li>
<li>读写1MB耗时10ms，也就是我们的IO速度是100MB/s</li>
<li>一次Compaction，假设是1MB，需要消耗25MB的IO<ol>
<li>需要从这一层读取1MB</li>
<li>从下一层读取10-12MB的数据(boundaries may be misaligned)</li>
<li>写10-12MB的数据到下一层</li>
</ol>
</li>
</ol>
<p>这说明25次Seek的开销等于1MB数据的Compaction成本，也就是一次Seek大概摊还下来是40KB数据的压缩成本。我们做一些保留，让16KB对应一次Compaction，也就是允许更多的Seek次数。<br>同时，我们将<code>f-&gt;allowed_seeks</code>最小值设为100，这样也不会一直Compaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// 16*1024</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VersionSet-Builder-SaveTo"><a href="#VersionSet-Builder-SaveTo" class="headerlink" title="VersionSet::Builder::SaveTo"></a>VersionSet::Builder::SaveTo</h4><p><code>SaveTo</code>的最终影响是<code>MaybeAddFile</code>，也就是说将文件添加到Version里面。具体是添加到<code>v-&gt;files_</code>里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  BySmallestKey cmp;</span><br><span class="line">  cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的循环中，我们依次处理每一层的合并。主要内容是：</p>
<ol>
<li>将添加的文件合并到<code>files_</code></li>
<li>删除文件</li>
</ol>
<p>之前介绍过<code>base_</code>在构造时传入，一般为CURRENT，我们就是要对<code>base_</code>去应用这些修改。<br>所以，我们是</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_-&gt;files_<span class="string">[level]</span> + (levels_<span class="string">[level]</span>.added_files - levels_<span class="string">[level]</span>.deleted_files) = v-&gt;files_<span class="string">[level]</span></span><br></pre></td></tr></table></figure>

<p><code>base_iter</code>用来遍历原有的文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">    <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们首先<strong>预留最大空间，避免到时候的频繁动态分配</strong>。但是实际上最终未必用到这个空间，因为<code>MaybeAddFile</code>不一定真的添加文件。<br>下面就是插入操作，这个有点奇怪。我们先初始化了<code>bpos</code>，但是循环中自增的却是<code>base_iter</code>，<code>for(A;B;C)</code>里面A和C的主语不一样，很奇怪。其实<code>bpos</code>标记了我们要遍历的终点。具体解释一下，这个函数其实是一个归并的过程，分两步：</p>
<ol>
<li>插入原有的<code>base_</code>里面的文件，这些文件要小于等于<code>added_file</code><br> <code>std::upper_bound</code>找到第一个大于<code>added_file</code>的位置<code>bpos</code>，也就是我们的<code>base_iter</code>往后遍历，不会超过<code>bpos</code>。<br> 我们用<code>MaybeAddFile</code>插入，因为这些文件可能已经被标记删除。</li>
<li>插入<code>added_file</code></li>
</ol>
<p>**那么这么做的好处在哪里呢？我认为是减少了比较的次数，从O(n)到了O(logn)**。因为我们这里是<code>BytewiseComparator</code>，是两个Slice之间的比较，所以开销还是比较大的，这里是值得学习的一个Best Practice。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">      <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">               <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">           base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MaybeAddFile(v, level, added_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add remaining base files</span></span><br><span class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">      MaybeAddFile(v, level, *base_iter);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在Debug的状态下，会去检查除Level0之外的层有没有重叠。检查方法也很简单，就是看后一个文件的smallest是不是一定<strong>严格</strong>大于前一个文件的largest。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">        <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                       prev_end.DebugString().c_str(),</span><br><span class="line">                       this_begin.DebugString().c_str());</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VersionSet-Builder-MaybeAddFile"><a href="#VersionSet-Builder-MaybeAddFile" class="headerlink" title="VersionSet::Builder::MaybeAddFile"></a>VersionSet::Builder::MaybeAddFile</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;</span><br><span class="line">      <span class="comment">// Must not overlap</span></span><br><span class="line">      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                  f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;refs++;</span><br><span class="line">    files-&gt;push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VersionSet-Finalize"><a href="#VersionSet-Finalize" class="headerlink" title="VersionSet::Finalize"></a>VersionSet::Finalize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是针对第0层的特殊情况。我们知道LevelDB的第0层最多存在4个文件【Q】（我觉得未必，详见<code>kL0_SlowdownWritesTrigger</code>），这就是由<code>kL0_CompactionTrigger</code>控制的。这里使用文件数量，注释里面列了两个原因：</p>
<ol>
<li>允许更大的写buffer，从而减少Level0 Compaction的数量。<br> 这里的写buffer应该是<code>options_.write_buffer_size</code>这个东西。这个阈值控制Memtable何时转换成Immutable Memtable，以及在Recover的时候何时直接dump成SSTable。<br> 佶屈聱牙，实际上的意思是，这个意思是，如果写buffer太大，如果我们用固定的size限制死了的话，可能Level0的文件数量会很少，比如就1个，这样会导致频繁的Level0 Compaction。</li>
<li>Level0的文件每次读取都会被Merge。我们不希望有很多个小文件(perhaps because of a small write-buffer setting, or very high compression ratios, or lots of overwrites/deletions)。<br> 如果写buffer很小，这样会导致更多的Level0文件。因为Level0的文件是overlap的，所以如果数量过多，每次查询需要Seek的文件数量就越多。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      score = v-&gt;files_[level].size() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger); <span class="comment">// ==4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于第1层以下的层，计算文件总大小，而不是文件数量了。<code>MaxBytesForLevel</code>的大概意思就是Level1总大小是10M，下面每一层翻10倍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h3><p>这个函数计算每一层的最大大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>将自己从链表中移除。<br>对于自己管理的所有文件，引用计数减一。【Q】这边不搞个原子操作么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LevelDB对MVCC的实现总结"><a href="#LevelDB对MVCC的实现总结" class="headerlink" title="LevelDB对MVCC的实现总结"></a>LevelDB对MVCC的实现总结</h2><h4 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h4><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">文章</a>中论述了一次版本升级的过程，但我会批注一下具体实现的函数和逻辑</p>
<ol>
<li>新建一个Session Record，记录状态变更信息</li>
<li>讨论版本升级原因<ol>
<li>Minor Compaction或者日志replay<br> 在Session Record中记录新增的文件信息、最新的journal编号、数据库sequence number以及下一个可用的文件编号。</li>
<li>Major Compaction<br> 在Session Record中记录新增、删除的文件信息、下一个可用的文件编号即可。</li>
</ol>
</li>
<li>通过VersionEdit生成新版本<br> 相较于旧的版本信息，新的版本信息更改的内容为：<ol>
<li>每一层的文件信息：在<code>VersionSet::Builder::Apply</code>中。</li>
<li>每一层的计分信息：在<code>VersionSet::Finalize</code>中。</li>
</ol>
</li>
<li>将Session Record持久化<br> 在<code>VersionSet::Builder::SaveTo</code>中。</li>
<li>讨论是否是第一条Session Record<br> 在LogAndApply的Finalize调用之后的部分<ol>
<li>是<br> 新建一个Manifest文件，并将完整的版本信息全部记录进Session Record作为该Manifest的基础状态写入，同时更改Current文件，将其指向新建的Manifest。</li>
<li>不是<br> 将该条Session Record进行序列化后直接作为一条记录写入即可。</li>
</ol>
</li>
<li>将当前的Version设置为刚创建的Version<br> 这个会修改<code>current_</code>的指向。这个操作应该是原子的（不然最新版本岂不是会不一致么）实际上也在<code>mutex_</code>的保护下。<br> 在LogAndApply对<code>AppendVersion</code>的调用中。</li>
</ol>
<h1 id="Snapshot机制"><a href="#Snapshot机制" class="headerlink" title="Snapshot机制"></a>Snapshot机制</h1><p>我们在这里介绍Snapshot机制，主要是为了方便说明它对Compaction的影响：导致同一个user key的不同的Sequence Number版本存在多个。</p>
<p>Snapshot实际上就是某个特定的Sequence Number。<br>【Q】Sequence Number是全局递增的么？应该是这样的，在Put和Get的实现中，看到的都是读取的<code>VersionSet::LastSequence()</code>这个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Compaction主函数"><a href="#Compaction主函数" class="headerlink" title="Compaction主函数"></a>Compaction主函数</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><ol>
<li>BackgroundCompaction<ol>
<li>BackgroundCall<ol>
<li>BGWork<ol>
<li>MaybeScheduleCompaction<br> 会Schedule方法<code>BGWork</code>。<br> 这个函数在BackgroundCall，以及诸如Get等读写方法中都会被调用。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Compaction条件"><a href="#Compaction条件" class="headerlink" title="Compaction条件"></a>Compaction条件</h3><ol>
<li>Minor Compaction<br> 在Recover过程中<code>ApproximateMemoryUsage</code>检测到<strong>Memtable</strong>超限，会直接触发对Memtable的Compaction。但这个Compaction是局部的，因为我们在恢复过程中，所以不需要诸如LogAndApply这种维护Version的工作。<br> 存在Immutable Memtable</li>
<li>Manual Compaction<br> CompactRange调用</li>
<li><code>size_compaction</code><br> 在<code>VersionSet::PickCompaction</code>中检查并启动。<br> 当Level0文件数目过多，或者某个Level的总大小过大。<br> 在函数<code>NeedsCompaction</code>中判断当前Version的<code>compaction_score_ </code>(size compaction)和<code>file_to_compact_</code>(seek compaction)。</li>
<li><code>seek_compaction</code><br> seek次数太多。我们知道，当一个文件找不到时，就需要到高一级的Level中去查找。假如在<code>Level(n)</code>中没找到，但是在<code>Level(n+1)</code>中找到了，就认为<code>Level(n)</code>有一次未命中。容易发现如果未命中次数多了，就说明Level N和Level N+1<br> 的文件overlap很厉害，这就需要通过一次Major Compaction来解决这个问题。</li>
</ol>
<h2 id="DBImpl类"><a href="#DBImpl类" class="headerlink" title="DBImpl类"></a>DBImpl类</h2><p>LevelDB通过<code>class DB</code>对外暴露C++接口，这个<code>DB</code>的实现就是<code>DBImpl</code>。</p>
<h2 id="DBImpl-BackgroundCall"><a href="#DBImpl-BackgroundCall" class="headerlink" title="DBImpl::BackgroundCall"></a>DBImpl::BackgroundCall</h2><p>BackgroundCall是在后台线程中执行的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>MakeRoomForWrite</code>函数会在<code>background_work_finished_signal_</code>等待Compaction结束。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DBImpl-MaybeScheduleCompaction"><a href="#DBImpl-MaybeScheduleCompaction" class="headerlink" title="DBImpl::MaybeScheduleCompaction"></a>DBImpl::MaybeScheduleCompaction</h2><p>函数<code>MaybeScheduleCompaction</code>决定是否进行Compaction。<br>这里需要加锁，不然可能会导致开两个后台进程，而LevelDB只允许一个后台进程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PosixEnv-Schedule"><a href="#PosixEnv-Schedule" class="headerlink" title="PosixEnv::Schedule"></a>PosixEnv::Schedule</h3><p>这里的<code>env_</code>的实现实际上是一个<code>PosixEnv</code>。<br>我们查看源码，原来这个后台进程只有一个<code>started_background_thread_</code>，一开始先检查它是否存在，如果不存在，就创建一个，然后detach掉。<br>接下来就是一个生产者消费者模式。不过有点奇怪，是先Signal，再入队，不应该先修改条件，再Signal么。<br>我在<a href="/2017/12/28/Concurrency-Programming-Compare/">文章</a>中提过<a href="http://www.cppblog.com/Solstice/archive/2015/10/30/203094.html" target="_blank" rel="noopener">陈硕大佬的一篇博客</a>，在CV语境中，<a href="https://gist.github.com/chenshuo/6430925" target="_blank" rel="noopener">先Signal，再设置条件flag(代码里面的Case 6)</a>也是可以的，但只限于单waiter使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::Schedule(</span><br><span class="line">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg) &#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.detach();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面放一下消费者的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::BackgroundThreadMain() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixEnv::PosixEnv()</span><br><span class="line">    : background_work_cv_(&amp;background_work_mutex_),</span><br><span class="line">      started_background_thread_(<span class="literal">false</span>),</span><br><span class="line">      mmap_limiter_(MaxMmaps()),</span><br><span class="line">      fd_limiter_(MaxOpenFiles()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="NeedsCompaction"><a href="#NeedsCompaction" class="headerlink" title="NeedsCompaction"></a>NeedsCompaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Compaction类"><a href="#Compaction类" class="headerlink" title="Compaction类"></a>Compaction类</h2><p>定义在version_set.h文件里面。</p>
<h3 id="主要成员和成员函数"><a href="#主要成员和成员函数" class="headerlink" title="主要成员和成员函数"></a>主要成员和成员函数</h3><ol>
<li><code>std::vector&lt;FileMetaData*&gt; inputs_[2];</code><br> 表示这个Compaction涉及的两个level的文件，也就是输入。<br> 其中level层是<code>inputs_[0]</code>。level + 1层是<code>inputs_[1]</code>，称为parents。</li>
<li><code>std::vector&lt;FileMetaData*&gt; grandparents_;</code><br> level + 2层的文件，通常称为grandparents。</li>
<li><code>int level() const { return level_; }</code><br> 我们将<code>level_</code>和<code>level_+1</code>层进行压缩。</li>
<li><code>int num_input_files(int which) const</code></li>
<li><code>bool IsTrivialMove() const;</code><br> 是否可以直接移动，而不涉及merge或者split操作。</li>
<li><code>bool ShouldStopBefore(const Slice&amp; internal_key);</code></li>
<li><code>VersionEdit* edit() { return &amp;edit_; }</code>/<code>edit_</code><br> 这个应该很好理解，Compaction肯定会有文件增删，即使是移动，也是跨层的。所以这里需要一个<code>VersionEdit</code>来描述。</li>
</ol>
<h3 id="IsTrivialMove"><a href="#IsTrivialMove" class="headerlink" title="IsTrivialMove"></a>IsTrivialMove</h3><p>这个函数用来判断在Major Compaction的时候能不能直接移动老的文件到下面一层，而不归并生成新的文件，条件有三个：</p>
<ol>
<li>level层只有一个<br> 【Q】疑问：如果level层有多个，level+1层没有，那么我直接移动到下面一层也是安全的？那么禁止这么做的目的是什么？<br> 检查对<code>GetOverlappingInputs</code>的分析，发现可能是不安全的。如果说Level0的某个文件<code>f</code>和Level1的文件有Overlap，那么就必须要扫描整个Level0层的所有文件，将与<code>f</code>有Overlap的文件都要移到下一层。</li>
<li>level + 1层没有<br> 这个原因应该好理解，如果level+1层有，那么我们就得比较和这个文件有没有Overlap。</li>
<li>和level + 2层的overlap没有超过阈值(实际上是20M)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Compaction::IsTrivialMove() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DBImpl-BackgroundCompaction"><a href="#DBImpl-BackgroundCompaction" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>这个过程是Compaction的主过程，需要全程持锁。</p>
<h3 id="Minor"><a href="#Minor" class="headerlink" title="Minor"></a>Minor</h3><p>我们首先需要去<code>CompactMemTable</code>，也就是Minor Compaction。这个肯定是优先级更高的，因为我们只有两个Memtable，所以我们肯定想把Immutable Memtable快速腾空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="Major"><a href="#Major" class="headerlink" title="Major"></a>Major</h3><p>详见Major Compaction章节</p>
<h1 id="Minor-Compaction流程"><a href="#Minor-Compaction流程" class="headerlink" title="Minor Compaction流程"></a>Minor Compaction流程</h1><h2 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h2><p>主要流程三部分：</p>
<ol>
<li>WriteLevel0Table<ol>
<li>将Immutable Memtable生成SSTable文件<br> 这个文件的基本信息写到<code>FileMetaData</code>里面，并在最后写入<code>VersionEdit</code>。<br> 注意，在Recover的过程中，这里其实也可以传入Memtable。</li>
<li>计算添加到哪一层<br> 这个文件未必会放到Level0，可能会直接放到Level1甚至Level2，具体由<code>kMaxMemCompactLevel</code>控制。</li>
<li>将上面说的<code>FileMetaData</code>写入VersionEdit<br> 因此这个函数的实际返回是传入的<code>VersionEdit* edit</code>。</li>
</ol>
</li>
<li>LogAndApply<br> 用我们得到的<code>VersionEdit</code>，去更新数据库状态，并记录。</li>
<li>RemoveObsoleteFiles<br> 重置Immutable Memtable。<br> 删除无用文件。主要包括<code>kLogFile</code>/<code>kLogFile</code>/<code>kTableFile</code>等。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::CompactMemTable() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，就是要把<code>edit</code>应用到当前的VersionSet上。<br>【Q】<code>SetPrevLogNumber</code>是啥意思？为啥要设置为0呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h2><p>在前文中，已经介绍过了<code>WriteLevel0Table</code>的作用，下面看实现。</p>
<p>首先，我们计算出一个<code>NewFileNumber</code>，也就是落盘时体现的文件名。关于这个函数，我们之前已经介绍过了，体现在诸如<code>MANIFEST-xxxxx</code>或者<code>yyyyy.log</code>这里的序号。</p>
<p><code>pending_outputs_</code>中保存了所有正在Compact的SSTable文件，这些文件不能被删除。这引发了我两个问题：</p>
<ol>
<li>什么时候会删除？<br> 在<code>RemoveObsoleteFiles</code>里面，马上就能看到了，不急不急</li>
<li>为什么在BuildTable之后就可以删除了？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,</span><br><span class="line">                                Version* base) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接着，<code>BuildTable</code>创建一个<code>TableBuilder</code>写入数据。值得注意的是，这里并没有加锁。我之前认为这是因为<code>BuildTable</code>里面会自带加锁，但是检查代码并没有。这可能是因为Compaction是单独的线程，诸如生成并写SSTable的过程是可以单独提出来处理的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>新生成的文件未必会放到Level0，可能会直接放到Level1。例如，如果新的SSTable文件和Level1中的文件没有重叠，那么就<strong>有可能</strong>被放到Level1，具体还需要查看Level2和新SSTable的重叠情况。因此<code>PickLevelForMemTableOutput</code>会生成一个level，表示放到哪一层。<br>下面的<code>edit-&gt;AddFile</code>就是将这个SSTable加到当前的VersionEdit中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>env_</code>实际上是封装了文件系统等操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RemoveObsoleteFiles"><a href="#RemoveObsoleteFiles" class="headerlink" title="RemoveObsoleteFiles"></a>RemoveObsoleteFiles</h2><p>搞清楚几个问题：</p>
<ol>
<li>清理文件的范围？看<code>env_-&gt;GetChildren</code>的实现，应该是所有这个db下的文件。</li>
<li>清理文件的类型？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::RemoveObsoleteFiles() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don't know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;live);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  env_-&gt;GetChildren(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files_to_delete;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;LogNumber()) ||</span><br><span class="line">                  (number == versions_-&gt;PrevLogNumber()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations'</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;ManifestFileNumber());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into "live"</span></span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.push_back(<span class="built_in">std</span>::move(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;Evict(number);</span><br><span class="line">        &#125;</span><br><span class="line">        Log(options_.info_log, <span class="string">"Delete type=%d #%lld\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;RemoveFile(dbname_ + <span class="string">"/"</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Major-Compaction流程"><a href="#Major-Compaction流程" class="headerlink" title="Major Compaction流程"></a>Major Compaction流程</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><p>在开始研究Major Compaction前，我们主动思考这个问题</p>
<ol>
<li><p>对于Level0里面的文件，是不是可以直接和Level1中的文件Merge？<br> 答案是不行的，见<code>GetOverlappingInputs</code>的论述。</p>
</li>
<li><p>如果level中的某个文件的key的range过大，它可能和level+1层的很多文件有重合，这样的compaction写放大很重，如何解决这个问题？<br> 首先，这也是为什么LevelDB要分成很多层的原因，在Merge的时候，最多和下一层中的所有文件Overlap，写放大是可控的。<br> 其次，在Compact的时候，LevelDB一直关注和level+2层的key的重叠情是否超过一定量，即<code>MaxGrandParentOverlapBytes</code>函数。</p>
<ul>
<li>在<code>ShouldStopBefore</code>判断是否要结束当前SSTable写入，新开文件的时候，考虑当前文件和level+2的Overlap，如果过了，就新开文件。</li>
<li>在<code>IsTrivialMove</code>判断是否可以直接移动文件到下层的时候，考虑要移动的文件和level+2层的Overlap，如果过了，就不能移动。</li>
<li>在<code>PickLevelForMemTableOutput</code>选择Minor Compaction的层时，考虑这个Immutable Memtable的Overlap，如果过了，就不能放在这一层。</li>
</ul>
</li>
<li><p>从level到level+1的Compaction会对level+2产生什么影响？</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">LevelDB</a>中多个不相干的合并是可以并发进行的，这个的实现是怎样的？<br> 需要注意，Level0文件是彼此Overlap的，所以是相干的。<br> 【Q】那么当一个Major Compaction开始的时候，是如何判定是否相干，如果不相干就不Compact的呢？从LevelDB的代码来看，只有一个后台线程进行Compact操作，所以我认为虽然在设计上LSM树是允许并行Compact的，但是LevelDB并没有实现，但RocksDB肯定是实现的。</p>
</li>
<li><p>LevelDB中，每个user key在一层中是不是只会出现一次？<br> 大多数情况是的，有两个例外。<br> 首先，Level0是Overlap的，可能有多个。<br> 其次，如果使用了Snapshot，那么在下层可能也会有user key相同，但是sequence不同的。见<code>AddBoundaryInputs</code>的论述。</p>
</li>
<li><p>我们往Manifest文件里面写了什么？</p>
</li>
<li><p>LevelDB有容量限制么？<br> <a href="https://stackoverflow.com/questions/31742460/is-there-record-number-limit-in-leveldb" target="_blank" rel="noopener">应该是没有的，但是当最下面一层变得特别大之后，Compaction的开销会很大</a>。</p>
</li>
<li><p>LevelDB到底是限制的每一层的文件数量还是大小？<br> 【Q】如果限制的是总大小，如果保证生成的SSTable的大小是大致相同的？<br> 对于Major Compaction来说，是在<code>DoCompactionWork</code>里面通过下面的代码来判断的，也就是说当文件大小达到一定规模后，就会产生新的文件了。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">   compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br></pre></td></tr></table></figure>

<p> 这个调用最后会转到<code>options-&gt;max_file_size</code>上。</p>
</li>
<li><p>LevelDB每一层的文件数量有限制么？<br> 首先Level0肯定有，大家说是4个么？我觉得不是。参考下面的代码，4只是表示有4个文件就开始Level0的Compaction。当文件数达到12个，才是上限，这个时候就要停止写了。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Soft limit on number of level-0 files.  We slow down writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_SlowdownWritesTrigger = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of level-0 files.  We stop writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_StopWritesTrigger = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>LevelDB底层SSTable中的数据永无出头之日么？<br> 怎么可能，只要数据被修改，那么就会先到Memtable里面。</p>
</li>
<li><p>Compaction是如何删除文件的？<br> 注意，即使遍历到有删除标记的，并且这个删除标记的序列号最大。我们也不应该尝试删除，至少要检查下面的层有没有。详见DoCompactionWork</p>
</li>
</ol>
<h2 id="DBImpl-BackgroundCompaction-1"><a href="#DBImpl-BackgroundCompaction-1" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>下面是对Major Compaction的处理。</p>
<h3 id="计算Compaction对象"><a href="#计算Compaction对象" class="headerlink" title="计算Compaction对象"></a>计算Compaction对象</h3><p>首先，我们要处理Manual Compaction的情况。如果<code>manual_compaction_</code>不是null，就触发Manual Compaction。我没看到非测试的代码里面有设置<code>manual_compaction_</code>的，但是<code>leveldb_compact_range</code>这个api会显示调用<code>CompactRange</code>，并且<code>DB</code>这个接口中也有<code>CompactRange</code>方法，也就是说，LevelDB对外暴露这个方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>其次，我们调用<code>PickCompaction</code>处理size compaction和seek compaction的情况。<code>PickCompaction</code>会返回当前要Compact的文件，如果返回null，就啥事都不做。对于<code>PickCompaction</code>而言，如果既没有size compaction，又没有seek compaction，返回null。</p>
<p><strong>这个过程是持锁的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 前面是对Minor Compaction的处理</span></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据Compaction对象进行Compact操作"><a href="#根据Compaction对象进行Compact操作" class="headerlink" title="根据Compaction对象进行Compact操作"></a>根据Compaction对象进行Compact操作</h3><p>经过上面的代码，我们就得到了一个<code>Compaction* c</code>对象。<br>如果之前<code>PickCompaction</code>没给出这个<code>c</code>，那么就说明这一次不要Compact。<br>如果满足<code>IsTrivialMove</code>条件，就可以不生成新的文件，直接将原文件移动到下一层。<br>对于Trivial的情况我们直接更新<code>c-&gt;edit()</code>，不走<code>InstallCompactionResults</code>的逻辑了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Nothing to do</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">  <span class="comment">// Move file to next level</span></span><br><span class="line">  assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">  FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">  c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                     f-&gt;largest);</span><br><span class="line">  status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">      status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>如果不满足<code>IsTrivialMove</code>条件，就是一般情况，由<code>DoCompactionWork</code>处理。<br><code>DBImpl::CompactionState</code>这个类又封装了<code>Compaction</code>，这是因为要处理两个Level之间的合并，所以要加一些额外的字段。<br>然后我们要<code>CleanupCompaction</code>，这个除了清空compact对象，还需要根据<code>compact-&gt;outputs</code>，找到<code>pending_outputs_</code>里面对应的文件，并移除出<code>pending_outputs_</code>。我们知道<code>compact-&gt;outputs</code>记录了每个输出文件的元信息，而<code>pending_outputs_</code>记录了正在compact的文件，我们compact结束，就把这些文件移出去。在Major Compaction中，文件是在<code>DoCompactionWork -&gt; OpenCompactionOutputFile</code>中被加入<code>pending_outputs_</code>的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">  status = DoCompactionWork(compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  CleanupCompaction(compact);</span><br><span class="line">  c-&gt;ReleaseInputs();</span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure>

<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>如果是Manual的，需要清空Manual状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;done) &#123;</span><br><span class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">      <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">      m-&gt;tmp_storage = manual_end;</span><br><span class="line">      m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">    &#125;</span><br><span class="line">    manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Version-PickCompaction"><a href="#Version-PickCompaction" class="headerlink" title="Version::PickCompaction"></a>Version::PickCompaction</h2><p>size compaction的优先级是高于seek compaction的。<br>遍历<code>current_-&gt;compaction_level_</code>这一层的所有文件，找到第一个largest大于<code>compact_pointer_[level]</code>的文件，放到<code>Compaction* c</code>的<code>inputs_[0]</code>中。<br>如果一轮循环下来没找到，说明所有的文件的largest都小于<code>compact_pointer_[level]</code>，也就是这一层所有的key都小于<code>compact_pointer_[level]</code>，那就把第一个文件放进去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Compaction* VersionSet::PickCompaction() &#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于seek compaction，把要Compact的那个文件加到<code>c-&gt;inputs_[0]</code>就行，逻辑很简单。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">  level = current_-&gt;file_to_compact_level_;</span><br><span class="line">  c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">  c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Level0，有个特别的处理，这个参考<code>GetOverlappingInputs</code>函数的说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;input_version_ = current_;</span><br><span class="line">c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们已经得到了<code>c-&gt;inputs_[0]</code>。<strong>除了<code>c-&gt;inputs_[0]</code>的情况，否则<code>c-&gt;inputs_[0]</code>里面都只有一个文件</strong>。<br>通过<code>SetupOtherInputs</code>可以计算<code>c-&gt;inputs_[1]</code>，也就是level+1层涉及哪些文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Version-SetupOtherInputs"><a href="#Version-SetupOtherInputs" class="headerlink" title="Version::SetupOtherInputs"></a>Version::SetupOtherInputs</h2><p><code>SetupOtherInputs</code>计算在Compaction时，level+1层涉及哪些文件。在这个函数之后，我们就得到了正确的<code>c-&gt;inputs_</code>数组、<code>c-&gt;grandparents_</code>字段，以及<code>compact_pointer_</code>字段。在这个函数之后，<code>PickCompaction</code>就结束了，<code>BackgroundCompaction</code>会执行后面的流程，也就是<code>DoCompactionWork</code>。<br>基本的思想是：所有和level层有重叠的level+1层文件都要参与Compact。得到这些文件后，反过来看下，利用这些level+1层的文件，能不能Compact更多level层的文件？<br>这个函数被<code>CompactRange</code>和<code>PickCompaction</code>调用，也就是所有的Major Compaction逻辑都会走到这里。</p>
<h3 id="GetRange和GetRange2"><a href="#GetRange和GetRange2" class="headerlink" title="GetRange和GetRange2"></a>GetRange和GetRange2</h3><p>GetRange计算<code>inputs_[0]</code>/<code>inputs_[1]</code>的区间。<br>GetRange2计算<code>inputs_[0]</code>和<code>inputs_[1]</code>的区间。<br>GetRange很简单，遍历每一个文件，然后更新smallest和largest，这里注意都需要<code>icmp_.Compare</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span><br><span class="line">                          InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  assert(!inputs.empty());</span><br><span class="line">  smallest-&gt;Clear();</span><br><span class="line">  largest-&gt;Clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</span><br><span class="line">    FileMetaData* f = inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      *smallest = f-&gt;smallest;</span><br><span class="line">      *largest = f-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *smallest = f-&gt;smallest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *largest = f-&gt;largest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetRange2很简单，就直接合并<code>inputs_[0]</code>和<code>inputs_[1]</code>的内容到一个vector里面，然后调用GetRange。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span><br><span class="line">                           InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; all = inputs1;</span><br><span class="line">  all.insert(all.end(), inputs2.begin(), inputs2.end());</span><br><span class="line">  GetRange(all, smallest, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AddBoundaryInputs"><a href="#AddBoundaryInputs" class="headerlink" title="AddBoundaryInputs"></a>AddBoundaryInputs</h3><p>AddBoundaryInputs是一个很重要的函数，但只有很少的Blog能讲明白这个函数的来龙去脉。</p>
<p>翻译一下<code>AddBoundaryInputs</code>这个函数的注释。他提取出<code>compaction_files</code>里面最大的文件b1，在这里是<code>c-&gt;inputs_[0]</code>里面最大的文件。<br>然后在<code>level_files</code>里面找到一个b2，满足b1和b2的user key是相等的，这样的b2称为boundary file。我们需要将这个b2加入到<code>compaction_files</code>里面，并且继续找上界。<br>如果有两个块（应该就是SSTable）b1和b2，他们的范围分别是<code>(l1, u1)</code>和<code>(l2, u2)</code>，如果我们只Compact b1，不Compact b2，那么在读取的时候就会出错。因为它只会返回b2的结果，而永远不会返回b1的结果，因为b1在b2上层了。与此同时，我们需要注意到b2的结果可能还是一个较旧的数据，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span></span></span><br></pre></td></tr></table></figure>

<p>【Q】看起来，这个函数做的是和<code>GetOverlappingInputs</code>一样的事情，他们的区别是什么呢？首先，<code>GetOverlappingInputs</code>的初心不是扩展边界而是计算某一层和某个range重合的文件，只是对Level0要特殊处理一下。其次，<a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">这篇文章</a>中进行了解释。</p>
<p>如下图所示，两个sstable中，出现了user key相同（都为key2）但是Sequence Number不同的两个Internal Key。<br><img src="/img/leveldb/compaction/AddBoundaryInputsProblem.png"></p>
<p>所以可以看到<code>GetOverlappingInputs</code>的特殊处理关注的是Level0上某一个要Compact的文件中的所有key是否还会出现在其他的SSTable文件中。而<code>AddBoundaryInputs</code>关注的是某个Key的其他版本是否还会出现在其他的SSTable中。</p>
<p>【Q】这里引发了第二个疑问，为什么同一层中会出现两个相同user key的Key呢？我觉得这个可能是因为这个Key出现在两个SSTable的边界上，所以这个函数叫<code>AddBoundaryInputs</code>吧。</p>
<p>仔细回顾一下<code>DoCompactionWork</code>的实现，似乎是可能没处理完一个Key，就<code>ShouldStopBefore</code>了的，但即使这样，后面的文件里面也不会再写有关这个user key的内容了。那么究竟在什么情况下会发生这种情况呢？根据<a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">这篇文章</a>中指出Snapshot机制会导致“同一层中会出现两个相同user key的Key”这个问题。</p>
<p>【Q】这里引发了第三个疑问，出现了两个user key，会不会影响读取呢？实际上只要位于同一层就不影响，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。我们的查找方式允许我们每一次都找到b1里面的值。</p>
<p>特别值得注意的是，这个问题关系到<a href="https://github.com/google/leveldb/issues/320" target="_blank" rel="noopener">Issue 320</a>和<a href="https://github.com/google/leveldb/pull/339" target="_blank" rel="noopener">PR 339</a>。<code>AddBoundaryInputs</code>函数也是在那个时候引进的。不过值得注意的是，这个patch在2016年就提了，但是2019年才被合进去。</p>
<h3 id="SetupOtherInputs主体"><a href="#SetupOtherInputs主体" class="headerlink" title="SetupOtherInputs主体"></a>SetupOtherInputs主体</h3><p>首先<code>AddBoundaryInputs</code>扩充一下<code>c-&gt;inputs_[0]</code>。<br>然后获得Level N的range。<br>然后计算Level N+1和Level N重叠的SSTable文件，并放入<code>c-&gt;inputs_[1]</code>。<br>最后，计算Level N和Level N+1合并起来的range。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::SetupOtherInputs(Compaction* c) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure>

<p>下面的的代码，就是之前说的优化。<br>如果<code>c-&gt;inputs_[1]</code>不为空，也就是Level N+1层有需要进行Merge的文件。我们将level中和所有和<code>[all_start,all_limit]</code>重叠的文件加到expoand0里面，并调用<code>AddBoundaryInputs</code>处理边界。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">  <span class="keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[<span class="number">0</span>].size() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br><span class="line">    <span class="keyword">if</span> (expanded1.size() == c-&gt;inputs_[<span class="number">1</span>].size()) &#123;</span><br><span class="line">      Log(options_-&gt;info_log,</span><br><span class="line">          <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">          level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].size()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].size()),</span><br><span class="line">          <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.size()),</span><br><span class="line">          <span class="keyword">int</span>(expanded1.size()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">      smallest = new_start;</span><br><span class="line">      largest = new_limit;</span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">      c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">      GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，设置一下<code>c-&gt;grandparents_</code>这个字段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line"><span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line"><span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                 &amp;c-&gt;grandparents_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>记录下一轮的压缩起始文件，也就是设置<code>compact_pointer_</code>。我们在这里立即更新，而不是等到VersionEdit被Apply的时候更新，这样当Compaction失败后，我们能下次能尝试一个不同的key range。</p>
<ol>
<li>【Q】什么是压缩起始文件？<br> 查看<code>PickCompaction</code>函数，它会找到largest大于<code>compact_pointer_[level]</code>后的第一个文件。<br> 可以发现，其实每一次要Compaction的文件就是通过<code>compact_pointer_</code>指定的。</li>
<li>【Q】在这之后，Compaction会因为什么失败？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DBImpl-CompactionState"><a href="#DBImpl-CompactionState" class="headerlink" title="DBImpl::CompactionState"></a>DBImpl::CompactionState</h2><ol>
<li><code>SequenceNumber smallest_snapshot;</code><br> 小于<code>smallest_snapshot</code>的Sequence Number是不重要的，因为我们不会为提供<code>smallest_snapshot</code>的snapshot。<br> 所以，如果我们看到Sequence Number小于等于<code>smallest_snapshot</code>的某个<code>S</code>，就可以丢弃小于<code>S</code>的这个key的其他版本。<br> 【Q】这里是不是在说，如果只有S这个独苗，那还是要写进去的？</li>
<li><code>std::vector&lt;Output&gt; outputs;</code></li>
<li><code>Output* current_output() { return &amp;outputs[outputs.size() - 1]; }</code><br> 保存每个输出文件的元信息。例如smallest和largest。</li>
<li><code>WritableFile* outfile;</code><br> Major Compaction过程中，需要输出到level+1层的文件。注意，可能有多个这样的文件，参考<code>ShouldStopBefore</code>。</li>
<li><code>TableBuilder* builder;</code></li>
<li><code>uint64_t total_bytes;</code></li>
</ol>
<h2 id="DBImpl-DoCompactionWork"><a href="#DBImpl-DoCompactionWork" class="headerlink" title="DBImpl::DoCompactionWork"></a>DBImpl::DoCompactionWork</h2><p>这个对应了一般情况下的Compact过程，来自<code>BackgroundCompaction</code>的调用。<br>那么这个函数做啥呢，不就是个归并排序么？且慢，我们如何处理同一个user key有不同Sequence Number呢？我们的目标肯定是只保留最新的。<br>其中<code>CompactionState</code>封装了<code>Compaction</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::DoCompactionWork(CompactionState* compact) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>这里要assert一下，即要压缩的Level N层是要有文件的。<br>【Q】这个Snapshot啥回事？<br>根据<a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">文章</a>，如果有Snapshot，则保留大于Snapshot SN的所有Record，以及一个小于Snapshot SN的Record中，SN最大的Record。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们执行<code>MakeInputIterator</code>，得到的迭代器可以按照key大小遍历所有冲突文件中的每个KV对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line">Status status;</span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br></pre></td></tr></table></figure>

<p>下面这个while循环遍历刚才得到的迭代器<code>input</code>，进行Major Compaction。<br>但是，且慢，每一次我们都需要先检查有没有Immatable Memtable，如果有的话，就需要先执行Minor Compaction。<strong>这也说明了Minor Compaction的优先级更高</strong>。<br>【Q】我们看到了两个原子量的获取：</p>
<ol>
<li><code>shutting_down_</code>，采用了Release-Acquire内存模型，保证了一定的并行顺序。<br> 如果线程A Release Store，线程B Acquire Load，那么<a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">线程A中所有在Release前的(atomic或者非atomic)写</a>，对线程B都可见。</li>
<li><code>memory_order_relaxed</code>，采用了Relaxed内存模型。<br> 只保证读写的原子性，不保证并发时和其他变量的顺序。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">  <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      CompactMemTable();</span><br><span class="line">      <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">      background_work_finished_signal_.SignalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>检查当前输出文件(应当位于level+1层)是否与level+2层文件有过多冲突，如果是就要完成当前输出文件，并产生新的输出文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Slice key = input-&gt;key();</span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">    compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是判断是不是能<code>drop</code>，也就是和前面计算的<code>compact-&gt;smallest_snapshot</code>比较。<br>正常情况下<code>ParseInternalKey</code>不会失败，我们跳过这个分支</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.clear();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>下面这个if，判断的是<code>current_user_key</code>第一次出现的情况，包括处理完上一个user key，到达下一个user key，或者刚开始处理第一个user key的情况。我们设置<code>last_sequence_for_key</code>为最大，那么就永远不会触发drop。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">    user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// First occurrence of this user key</span></span><br><span class="line">  current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line">  has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们比较Sequence Number，如果<code>last_sequence_for_key</code>都小于<code>compact-&gt;smallest_snapshot</code>了，那么我这个key肯定更小，这是因为<a href="/2021/04/09/leveldb-memtable/">Sequence Number是按照降序排列的</a>。对于这种情况，我们省点事，直接不要了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">  <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">  drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br></pre></td></tr></table></figure>

<p>下一个判断复杂点，表示对于特定情况下，一个删除操作也是可以丢掉的。<br><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">如果某个删除操作的版本小于快照版本，并且在更高层没有相同的user key，那么这个删除操作及其之前更早的插入操作可以同时丢弃了</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">             ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">             compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">    <span class="comment">// For this user key:</span></span><br><span class="line">    <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">    <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">    <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">    <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">    <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">    <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">    drop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_sequence_for_key = ikey.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果drop条件不符合，那么就写入到<code>compact-&gt;current_output()</code>里面，同时更新largest。<br>同时我们关注文件大小，如果超限了，就FinishCompactionOutputFile。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input-&gt;Next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>截至现在，我们已经遍历完迭代器了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">  status = input-&gt;status();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> input;</span><br><span class="line">input = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>更新状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">    stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line">  stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们加锁。所以其实在遍历<code>input</code>这个迭代器的时候，是没有在加锁的。<br><code>InstallCompactionResults</code>是一个关键过程，它将这次Compaction的内容加入到VersionEdit里面，并且最终调用<code>LogAndApply</code>。内容包括什么呢？增加和删除的文件：</p>
<ol>
<li><code>InstallCompactionResults</code>会调用<code>Compaction::AddInputDeletions</code>，需要删除的文件，包括<code>input_[0]</code>和<code>input_[1]</code></li>
<li>向<code>compact-&gt;compaction-&gt;edit()</code>中添加<code>compact-&gt;outputs</code>中的所有文件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-version/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34674504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34674504</a></li>
<li><a href="https://blog.csdn.net/tmshasha/article/details/47703245" target="_blank" rel="noopener">https://blog.csdn.net/tmshasha/article/details/47703245</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51573929" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51573929</a></li>
<li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/basic.html</a></li>
<li><a href="https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/" target="_blank" rel="noopener">https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a></li>
<li><a href="http://blog.jcix.top/2018-05-11/leveldb_paths/" target="_blank" rel="noopener">http://blog.jcix.top/2018-05-11/leveldb_paths/</a></li>
<li><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">http://bean-li.github.io/leveldb-version/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46718964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46718964</a></li>
<li><a href="http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html" target="_blank" rel="noopener">http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a><br> 这是一个DB完整执行过程的表述。</li>
<li><a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">https://www.ravenxrz.ink/archives/1ba074b9.html</a><br> 介绍了Snapshot</li>
<li><a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-PickCompaction</a><br> 解释了GetOverlappingInputs的原理</li>
<li><a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-version</a><br> 解释了Version的实现</li>
<li><a href="http://lerencao.github.io/posts/lsm-tree-compaction-strategy/" target="_blank" rel="noopener">http://lerencao.github.io/posts/lsm-tree-compaction-strategy/</a></li>
<li><a href="http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/" target="_blank" rel="noopener">http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/</a><br> 上面两篇文章介绍STCS和LCS</li>
<li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181498475</a><br> 图解Compact过程</li>
<li><a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction</a><br> RocksDB对Compaction的讲解</li>
<li><a href="https://blog.csdn.net/weixin_36145588/article/details/78064777" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36145588/article/details/78064777</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html</a><br> 这位同学解释了AddBoundaryInputs的来源</li>
<li><a href="http://www.petermao.com/leveldb/leveldb-8-snapshot.html" target="_blank" rel="noopener">http://www.petermao.com/leveldb/leveldb-8-snapshot.html</a><br> 介绍了snapshot机制</li>
<li><a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60188395</a><br> 带Snapshot的Compaction，以及为什么会导致Issue 320的问题</li>
<li><a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360345923</a><br> 也讲解了AddBoundaryInputs的来源，并且指出了快照会导致Issue 320的问题。</li>
<li><a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35343043</a><br> 讲解VersionSet/VersionEdit里面出现的各种文件编号</li>
<li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a><br> 版本控制相关</li>
<li><a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-manifest/</a><br> 有关Manifest文件的深入讨论</li>
<li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li>
<li><a href="https://draveness.me/database-concurrency-control/" target="_blank" rel="noopener">https://draveness.me/database-concurrency-control/</a><br> 同样介绍了MVCC，包括乐观锁和悲观锁机制</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/leveldb/" rel="tag"># leveldb</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/12/leveldb-sstable/" rel="next" title="LevelDB之SSTable实现">
                <i class="fa fa-chevron-left"></i> LevelDB之SSTable实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/24/leveldb-proc/" rel="prev" title="LevelDB之流程概览">
                LevelDB之流程概览 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">169</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">161</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前置知识"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LCS和STCS"><span class="nav-number">1.1.</span> <span class="nav-text">LCS和STCS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STCS"><span class="nav-number">1.1.1.</span> <span class="nav-text">STCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCS-Classic-Leveled"><span class="nav-number">1.1.2.</span> <span class="nav-text">LCS(Classic Leveled)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Level-N"><span class="nav-number">1.1.3.</span> <span class="nav-text">Level-N</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Tiered-Leveled"><span class="nav-number">1.1.4.</span> <span class="nav-text">Tiered+Leveled</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常见文件"><span class="nav-number">2.</span> <span class="nav-text">常见文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">2.1.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Manifest"><span class="nav-number">2.2.</span> <span class="nav-text">Manifest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Current"><span class="nav-number">2.3.</span> <span class="nav-text">Current</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MVCC介绍"><span class="nav-number">3.</span> <span class="nav-text">MVCC介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Version机制"><span class="nav-number">4.</span> <span class="nav-text">Version机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#VersionEdit"><span class="nav-number">4.1.</span> <span class="nav-text">VersionEdit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version"><span class="nav-number">4.2.</span> <span class="nav-text">Version</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关字段"><span class="nav-number">4.2.1.</span> <span class="nav-text">相关字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关函数"><span class="nav-number">4.2.2.</span> <span class="nav-text">相关函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Version-PickLevelForMemTableOutput"><span class="nav-number">4.2.3.</span> <span class="nav-text">Version::PickLevelForMemTableOutput</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#OverlapInLevel"><span class="nav-number">4.2.3.1.</span> <span class="nav-text">OverlapInLevel</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SomeFileOverlapsRange"><span class="nav-number">4.2.3.2.</span> <span class="nav-text">SomeFileOverlapsRange</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主流程"><span class="nav-number">4.2.3.3.</span> <span class="nav-text">主流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判断level-2层情况的分支详解"><span class="nav-number">4.2.3.4.</span> <span class="nav-text">判断level + 2层情况的分支详解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GetOverlappingInputs-MaxGrandParentOverlapBytes"><span class="nav-number">4.2.3.5.</span> <span class="nav-text">GetOverlappingInputs/MaxGrandParentOverlapBytes</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VersionSet"><span class="nav-number">4.3.</span> <span class="nav-text">VersionSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员介绍"><span class="nav-number">4.3.1.</span> <span class="nav-text">成员介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-LogAndApply"><span class="nav-number">4.3.2.</span> <span class="nav-text">VersionSet::LogAndApply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-AppendVersion"><span class="nav-number">4.3.3.</span> <span class="nav-text">VersionSet::AppendVersion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-Builder"><span class="nav-number">4.3.4.</span> <span class="nav-text">VersionSet::Builder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-Apply"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">VersionSet::Builder::Apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-SaveTo"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">VersionSet::Builder::SaveTo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-MaybeAddFile"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">VersionSet::Builder::MaybeAddFile</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-Finalize"><span class="nav-number">4.3.5.</span> <span class="nav-text">VersionSet::Finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MaxBytesForLevel"><span class="nav-number">4.3.6.</span> <span class="nav-text">MaxBytesForLevel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数"><span class="nav-number">4.3.7.</span> <span class="nav-text">析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LevelDB对MVCC的实现总结"><span class="nav-number">4.4.</span> <span class="nav-text">LevelDB对MVCC的实现总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#版本升级"><span class="nav-number">4.4.0.1.</span> <span class="nav-text">版本升级</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Snapshot机制"><span class="nav-number">5.</span> <span class="nav-text">Snapshot机制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Compaction主函数"><span class="nav-number">6.</span> <span class="nav-text">Compaction主函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总览"><span class="nav-number">6.1.</span> <span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用路径"><span class="nav-number">6.1.1.</span> <span class="nav-text">调用路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compaction条件"><span class="nav-number">6.1.2.</span> <span class="nav-text">Compaction条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl类"><span class="nav-number">6.2.</span> <span class="nav-text">DBImpl类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-BackgroundCall"><span class="nav-number">6.3.</span> <span class="nav-text">DBImpl::BackgroundCall</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-MaybeScheduleCompaction"><span class="nav-number">6.4.</span> <span class="nav-text">DBImpl::MaybeScheduleCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PosixEnv-Schedule"><span class="nav-number">6.4.1.</span> <span class="nav-text">PosixEnv::Schedule</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NeedsCompaction"><span class="nav-number">6.4.2.</span> <span class="nav-text">NeedsCompaction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compaction类"><span class="nav-number">6.5.</span> <span class="nav-text">Compaction类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#主要成员和成员函数"><span class="nav-number">6.5.1.</span> <span class="nav-text">主要成员和成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IsTrivialMove"><span class="nav-number">6.5.2.</span> <span class="nav-text">IsTrivialMove</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-BackgroundCompaction"><span class="nav-number">6.6.</span> <span class="nav-text">DBImpl::BackgroundCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor"><span class="nav-number">6.6.1.</span> <span class="nav-text">Minor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Major"><span class="nav-number">6.6.2.</span> <span class="nav-text">Major</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Minor-Compaction流程"><span class="nav-number">7.</span> <span class="nav-text">Minor Compaction流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CompactMemTable"><span class="nav-number">7.1.</span> <span class="nav-text">CompactMemTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WriteLevel0Table"><span class="nav-number">7.2.</span> <span class="nav-text">WriteLevel0Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RemoveObsoleteFiles"><span class="nav-number">7.3.</span> <span class="nav-text">RemoveObsoleteFiles</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Major-Compaction流程"><span class="nav-number">8.</span> <span class="nav-text">Major Compaction流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#【Q】思考"><span class="nav-number">8.1.</span> <span class="nav-text">【Q】思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-BackgroundCompaction-1"><span class="nav-number">8.2.</span> <span class="nav-text">DBImpl::BackgroundCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#计算Compaction对象"><span class="nav-number">8.2.1.</span> <span class="nav-text">计算Compaction对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据Compaction对象进行Compact操作"><span class="nav-number">8.2.2.</span> <span class="nav-text">根据Compaction对象进行Compact操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收尾"><span class="nav-number">8.2.3.</span> <span class="nav-text">收尾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-PickCompaction"><span class="nav-number">8.3.</span> <span class="nav-text">Version::PickCompaction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-SetupOtherInputs"><span class="nav-number">8.4.</span> <span class="nav-text">Version::SetupOtherInputs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GetRange和GetRange2"><span class="nav-number">8.4.1.</span> <span class="nav-text">GetRange和GetRange2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddBoundaryInputs"><span class="nav-number">8.4.2.</span> <span class="nav-text">AddBoundaryInputs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetupOtherInputs主体"><span class="nav-number">8.4.3.</span> <span class="nav-text">SetupOtherInputs主体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-CompactionState"><span class="nav-number">8.5.</span> <span class="nav-text">DBImpl::CompactionState</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-DoCompactionWork"><span class="nav-number">8.6.</span> <span class="nav-text">DBImpl::DoCompactionWork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">9.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2021/04/18/leveldb-compaction/';
          this.page.identifier = '2021/04/18/leveldb-compaction/';
          this.page.title = 'LevelDB之Compaction实现';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
