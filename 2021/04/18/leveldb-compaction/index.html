<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据库,leveldb," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本文介绍 LevelDB 的 SSTable 之间的 Compaction。Compaction 分两种：  Minor Compaction 对应 Memtable 到 SSTable 的过程。 Major Compaction 对应 SSTable 文件之间的归并。涉及到两个 Level 的 SSTable 文件。 Major Compaction 中还可以细分，比如是否 Manual 等。对">
<meta name="keywords" content="数据库,leveldb">
<meta property="og:type" content="article">
<meta property="og:title" content="LevelDB 之 Compaction 实现">
<meta property="og:url" content="http://www.calvinneo.com/2021/04/18/leveldb-compaction/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="本文介绍 LevelDB 的 SSTable 之间的 Compaction。Compaction 分两种：  Minor Compaction 对应 Memtable 到 SSTable 的过程。 Major Compaction 对应 SSTable 文件之间的归并。涉及到两个 Level 的 SSTable 文件。 Major Compaction 中还可以细分，比如是否 Manual 等。对">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/arch.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/STCS.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/LCS.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/AddBoundaryInputsProblem.png">
<meta property="og:updated_time" content="2025-02-09T11:30:48.938Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LevelDB 之 Compaction 实现">
<meta name="twitter:description" content="本文介绍 LevelDB 的 SSTable 之间的 Compaction。Compaction 分两种：  Minor Compaction 对应 Memtable 到 SSTable 的过程。 Major Compaction 对应 SSTable 文件之间的归并。涉及到两个 Level 的 SSTable 文件。 Major Compaction 中还可以细分，比如是否 Manual 等。对">
<meta name="twitter:image" content="http://www.calvinneo.com/img/leveldb/compaction/arch.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>LevelDB 之 Compaction 实现 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LevelDB 之 Compaction 实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-18T23:09:06+08:00">
                2021-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文介绍 LevelDB 的 SSTable 之间的 Compaction。Compaction 分两种：</p>
<ol>
<li>Minor Compaction<br> 对应 Memtable 到 SSTable 的过程。</li>
<li>Major Compaction<br> 对应 SSTable 文件之间的归并。涉及到两个 Level 的 SSTable 文件。<br> Major Compaction 中还可以细分，比如是否 Manual 等。对于非 Manual，还有 seek compaction 和 size compaction。</li>
</ol>
<p>同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。</p>
<a id="more"></a>

<p>目录：</p>
<ol>
<li><a href="/2021/04/09/leveldb-memtable/">LevelDB 之 Memtable实现</a></li>
<li><a href="/2021/04/12/leveldb-sstable/">LevelDB 之 SSTable实现</a></li>
<li><a href="/2021/04/17/leveldb-version/">LevelDB 之 Version</a></li>
<li><a href="/2021/04/18/leveldb-compaction/">LevelDB 之 Compaction</a></li>
<li><a href="/2021/04/23/leveldb-wal/">LevelDB 之 WAL</a></li>
<li><a href="/2021/04/24/leveldb-proc/">LevelDB 之流程概览</a></li>
</ol>
<p>首先来回顾一下 LevelDB 的整体架构<br><img src="/img/leveldb/compaction/arch.png"></p>
<p>之前提到过，当一个 Memtable 满了之后，会转化为 Immutable Memtable。Immutable Memtable 会被 Dump 成 SSTable 文件，SSTable 文件是不可变的。<br>这里 <code>GUARDED_BY(m)</code> 实际上是 <code>__attribute__(guarded_by(m))</code> 这个线程安全注解，方便编译器帮助检查有没有遗漏掉加锁的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="读放大、写放大、空间放大"><a href="#读放大、写放大、空间放大" class="headerlink" title="读放大、写放大、空间放大"></a>读放大、写放大、空间放大</h2><p>读放大表示每次读盘请求带来的实际读盘次数。</p>
<p>写放大是实际写入的数据大小除以期望写入的数据大小。</p>
<p>写放大和系统对数据的 Order 的要求的强烈程度有关。如果系统要求数据更有序，那么就需要花费更多的时间用来整理数据，从而产生更高的写放大。如果降低对数据有序性的要求，就会导致碎片越来越多，读放大和空间放大严重。</p>
<p>为什么 LevelDB 要针对写入优化呢？因为：</p>
<ol>
<li>大多数读取请求可以由 Block Cache 兜住。</li>
<li>对于不存在的 Key，可以由 Bloom Filter 兜住。当然，这里 BloomFilter 的 False Positive 率就很敏感了，会直接影响到读取的性能。</li>
</ol>
<h2 id="LCS-和-STCS"><a href="#LCS-和-STCS" class="headerlink" title="LCS 和 STCS"></a>LCS 和 STCS</h2><p>有两种 Compaction 方案：Size-Tiered Compaction Strategy(STCS) 和 Leveled Compaction Strategy(LCS)。</p>
<p>本段参考了 <a href="https://github.com/facebook/rocksdb/wiki/Compaction%E3%80%82" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction。</a></p>
<h3 id="STCS"><a href="#STCS" class="headerlink" title="STCS"></a>STCS</h3><p>Memtable 刷成小 SSTable。当这些小的 SSTable 达到一定个数时，会被 compact 成一个稍大些的 SSTable。当稍大些的 SSTable 又达到一定个数时，又会被一起 compact 成更大的 SSTable。每一层的 SSTable 之间是 overlap 的，组成了多个 run。<br>下图是 STCS 的一个示意，可以看到，每层的 SSTable <strong>数量不变</strong>，但是大小<strong>越来越大</strong>。<br><img src="/img/leveldb/compaction/STCS.png"></p>
<p>STCS 的写放大比较好，但读放大和空间放大高：</p>
<ol>
<li>空间放大1<br> 因为 Compaction 时，在新 SSTable 生成前，旧的 SSTable 不能删除，所以可能会造成额外一倍的开销。另外，LevelDB 中有 Version 的概念，其实更复杂。<br> 为此，增加 SSTable 数量，而控制大小不变，不就能控制这额外一倍开销的绝对数量么？这是 LCS 的思路。</li>
<li>空间放大2<br> 如果 Key 更新频繁，可能导致同一个 Level 以及不同 Level 中的 SSTable 中存在相同的 User Key，也就是版本太多。这些数据在被 Compact 后只会产生一个 Internal Key 了。<br> 假设相邻 level 的 size 比为 T，每个 level 包含的 run 数达到 T 时即触发整层的合并，空间放大为 O(T)。</li>
<li>读放大<br> 从数据量来说，点读基本上落在最后一层。range 读的可能需要合并多个层的数据，从而带来读放大。</li>
</ol>
<h3 id="LCS"><a href="#LCS" class="headerlink" title="LCS"></a>LCS</h3><p>为此就得到了 LCS：</p>
<ol>
<li>当 Level0 层数量达到 Level0 层阈值时，将 Level0 和 Level1 层的所有 SSTable 做 Compaction。<br> 实际上，具体涉及哪些 SSTable，在 LevelDB 中控制更为精细。并且 Compaction 的条件也更复杂。</li>
<li>如果 Level1 层的 SSTable 数量还是超过 Level1 层的阈值，再把这些超出的 SSTable 更下面的层做 Compaction。</li>
<li><strong>除了Level0，其他层的所有 SSTable 中的 key 都是不重叠的。</strong></li>
</ol>
<p>下图是 LCS 的一个示意<br><img src="/img/leveldb/compaction/LCS.png"></p>
<p>注意到，LCS 中，SSTable 的大小不变，但是数量会增多，Level N+1 的<strong>文件数量</strong>是 Level N 的 10 倍。这里的 10 倍也被称为 fanout。</p>
<p>【Q】这里看上去和 LevelDB 的实现还有区别，LevelDB 里面的 <code>MaxBytesForLevel</code> 函数更多的是计算了10倍的大小，Why？这个在“Major Compaction流程”章节中讨论过了，每个文件大小是固定的，LevelDB 通过限制每层的总大小来间接限制文件数量。这是为了在 dump 的时候更方便统计大小而不是文件数量。</p>
<p>所以，假如 Level1 有 10 个文件，Level2 就有 100 个文件。但是 key 在两个 level 中都是均匀分布的，因此 Level1 拿出一个文件出来，Level2 中估计只会有10个文件和它重叠，所以只需要合并重叠的这些文件就行了。<br>当然，LevelDB 中，Level0 是采用的 STCS 策略，就不讨论。</p>
<p>LCS 的空间放大相比 STCS 小很多。假如 fanout 是 10，因为 LCS 中最下面一层是有序的，也就是只包含一个 run，那么这个 LSM 中至少 10 / (1 + 10) 的数据是不重复的。而上层那个 1，就算都是和最下面一层重复的，也左右不了大局。当然，LCS 的空间放大也许不能始终达到最优，<a href="https://www.scylladb.com/2018/01/31/compaction-series-leveled-compaction/" target="_blank" rel="noopener">最坏情况下有 2-fold space amplification</a>。此时最下面一层并没有被填满，而是大约等于倒数第二层的大小。</p>
<p>LCS 的缺点是写放大会比 STCS 显著提高：</p>
<ol>
<li>Compaction 因为需要 merge 成一个 run，所以涉及更多的文件，导致写放大变大。<br> 在最差的情况下每一层的 Compaction 的写放大等于 fanout。也就是说要和下一层所有的文件进行合并。<br> 但实际上会少一些，因为 Compaction 是 some to some 的，只涉及 overlap 的文件。</li>
</ol>
<p>读放大也会更高：</p>
<ol>
<li>SST 文件变多。特别是对 L0 来说，因为他是会 overlap 的，所以文件变多之后需要读更多的文件，读放大更大。</li>
</ol>
<p>【Q】既然 LCS 的写放大高了很多，为什么说基于 LSM 的写性能很好呢？可能是因为下面几点</p>
<ol>
<li>SSTable 是顺序写，性能好【Q】</li>
<li>根据<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">RocksDB</a>的文档，在一些情况下写放大不是很严重<br> 首先是按 key 顺序的写，对于这种情况 RocksDB 可以优化。<br> 其次是有 skew 的写，会导致只有小部分的 key 被更新。</li>
</ol>
<h4 id="层数和写放大的关系"><a href="#层数和写放大的关系" class="headerlink" title="层数和写放大的关系"></a>层数和写放大的关系</h4><p>考虑极限情况，也就是只有一层。那么 Memtable 在 flush 下来后，就可能需要和整个数据库中的所有 SST 文件进行 Merge，这会产生非常大的写放大。</p>
<p>那么是不是层数越多，写放大越小呢？从另一个方面考虑写放大，一个 Key 从写入，直到一步步被移动到最下层，会经过：</p>
<ol>
<li>WAL +1</li>
<li>Minor Compaction +1</li>
<li>L0-&gt;L1 Major Compaction +2<br> L0 和 L1 基本是全量的 Compaction。</li>
<li>Major Compaction +11 each</li>
</ol>
<p>所以可以看出，总的写放大是 4 + 11 * (n - 1)。如果层数 n 越大，那么总的写放大就越大。但一个 Key 不会在单次 Compaction 中就经历 n 轮的重写。</p>
<h2 id="RocksDB-的实现"><a href="#RocksDB-的实现" class="headerlink" title="RocksDB 的实现"></a>RocksDB 的实现</h2><p>首先基本的 STCS 和 LCS 就不说了。</p>
<h3 id="Tiered-Leveled"><a href="#Tiered-Leveled" class="headerlink" title="Tiered+Leveled"></a>Tiered+Leveled</h3><p>RocksDB 中 L0 是 Tiered，下面的是 Leveled。这也是默认模式。<br>L0 设为 Tiered 的好处是可以快速承接 Flush 下来的 Memtable。</p>
<h3 id="Level-N"><a href="#Level-N" class="headerlink" title="Level-N"></a>Level-N</h3><p>相比 LCS 有更高的读放大，和更小的写放大，实际上是个权衡。也就是从上层来的所有 SST 文件会和下层其中一个 SST 文件合并。</p>
<h2 id="减少写放大"><a href="#减少写放大" class="headerlink" title="减少写放大"></a>减少写放大</h2><h3 id="思路1：KV-分离"><a href="#思路1：KV-分离" class="headerlink" title="思路1：KV 分离"></a>思路1：KV 分离</h3><p>类似于 WiscKey 或者 Titan。这样的优化的特点是：</p>
<ol>
<li>由于 Value 大小显著大于 Key 的大小，它占用了大部分的 Compaction 带宽。Compaction 的目的之一是为了排序，从而减少随机性，提高读取速度。而 Compaction 时，Value 是否参与对有序性的维护并无贡献。</li>
<li>对 Scan 不友好，需要通过 Prefetch 优化。如果需要该优化，那么保存 Value 的结构同样需要遵循 Key 的 Order。</li>
<li>GC 的时候需要反查 Key。</li>
<li>存储 Value 时需要同时存储 Key。</li>
</ol>
<p>WiscKey 收到一个写入请求的时候，先把 Key+Value 写到 vLog 的 head 处。这样可以省掉写 WAL 的一次 IO。相比 Compaction 的写放大来说，这只是小头。但是因为 Value 本身不要先写在内存的 Memtable 中了，所以实际上也减少了 Minor Compaction 的压力，从而减少了写放大。随后，WiscKey 会在 LSM 中写入 Key 和 Key+Value 在 vLog 中的位置。对点查而言，WiscKey 需要先查 LSM 找到 Value 的地址，再到 vLog 中插，多一次 IO。对扫表而言，支持 Prefetch，也就是从 LSM 处拿多个地址，然后从 vLog 中一次性读出。</p>
<p>WiscKey 的 vLog 是一个环形结构。Key+Value 在 head 处写入，而 GC 发生在 tail 处。根据 tail 处的 Key 反查 LSM，如果 Key 在 LSM 中存在，并且记录的位置也等于 vLog 中的位置，则将这个 Key+Value 移动到 head，否则前进 tail，表示删除。容易发现，一轮 GC 后，如果 Key 还存在，那么它的位置也会变更，这导致需要重新在 LSM 中记录新位置。如果存在 Snapshot，这会使得复杂度变高。</p>
<p>针对 WiscKey 的方案还可以进行优化。例如对 Key 进行冷热分离的存储，只有比较冷的 Key 才会被存入 vLog 中。</p>
<h3 id="思路2：Partition"><a href="#思路2：Partition" class="headerlink" title="思路2：Partition"></a>思路2：Partition</h3><p>限制一个 LSM 引擎管理数据的大小。这里就需要进行 Partition。可以通过 Range 或者 Hash 进行 Partition。</p>
<p>Partition 的问题是 Split/Merge 或者 Rehash 同样可能造成写放大或者空间放大。</p>
<h3 id="思路3：容忍一定程度的无序"><a href="#思路3：容忍一定程度的无序" class="headerlink" title="思路3：容忍一定程度的无序"></a>思路3：容忍一定程度的无序</h3><p>PebbleDB 将每一层分为多个 guard，guard 之间不 overlap。guard 中存有多个 overlap 的 SST 文件。</p>
<h1 id="Compaction-主流程"><a href="#Compaction-主流程" class="headerlink" title="Compaction 主流程"></a>Compaction 主流程</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><p>列表中的下层会调用上层</p>
<ol>
<li>BackgroundCompaction 这个函数是 Compaction 的主入口，会区分各种 Compaction 种类进行执行。<ol>
<li>BackgroundCall 主要负责调用 BackgroundCompaction 和调度 BackgroundCompaction<ol>
<li>BGWork 可以理解为就是 BackgroundCall<ol>
<li>MaybeScheduleCompaction<br> 会 Schedule 方法 <code>BGWork</code>。<br> 这个函数在 BackgroundCall，以及诸如 DBImpl::Get 等读写方法中都会被调用。<br> DBImpl::Get 中调用不会导致这个函数被重复调度，因为 BackgroundCall 中会检查如果 background_compaction_scheduled_ 设置了，就不会再调度。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Compaction种类"><a href="#Compaction种类" class="headerlink" title="Compaction种类"></a>Compaction种类</h3><ol>
<li>Minor Compaction<br> 存在 Immutable Memtable 即 <code>imm_</code>。那么会在 <code>BackgroundCompaction</code> 中被调用 <code>CompactMemTable</code>，即 Minor Compaction。<br> 在 Recover 过程中 <code>ApproximateMemoryUsage</code> 检测到 <strong>Memtable</strong> 超限，会直接触发对 Memtable 的 Compaction。但这个 Compaction 是局部的，因为在恢复过程中，所以不需要诸如 LogAndApply 这种维护 Version 的工作。</li>
<li>Manual Compaction<br> CompactRange 调用。</li>
<li><code>size_compaction</code><br> 在 <code>VersionSet::PickCompaction</code> 中检查并启动。<br> 当 Level0 文件数目过多，或者某个 Level 的总大小过大。</li>
<li><code>seek_compaction</code><br> seek 次数太多。当一个 key 在某一层落到 range 里面，但是找又找不到时，就需要到下一层中去查找。假如在 <code>Level(n)</code> 中没找到，但是在 <code>Level(n+1)</code> 中找到了，就认为 <code>Level(n)</code> 有一次未命中。容易发现如果未命中次数多了，就说明 Level N 和 Level N+1<br> 的文件 overlap 很厉害，这就需要通过一次 Major Compaction 来解决这个问题。这就不用再在 <code>Level(n)</code> 中找了。</li>
</ol>
<h3 id="Compaction条件"><a href="#Compaction条件" class="headerlink" title="Compaction条件"></a>Compaction条件</h3><p>在函数 <code>NeedsCompaction</code> 中判断当前 Version 的：</p>
<ol>
<li><code>compaction_score_</code> 导致 size compaction<br> 在 VersionSet::Finalize 更新。也就是当前版本中 Level0 层中文件数量，或者其他层中的文件大小，只要有一层的超过阈值，NeedsCompaction 就是 true。</li>
<li><code>file_to_compact_</code> 导致 seek compaction<br> 在 Version::UpdateStats 中更新。也就是在读的过程中，会不断设置 <code>GetStats::seek_file</code> 表示当前正在读取的文件。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DBImpl类"><a href="#DBImpl类" class="headerlink" title="DBImpl类"></a>DBImpl类</h3><p>LevelDB 通过 <code>class DB</code> 对外暴露 C++ 接口，这个 <code>DB</code> 的实现就是 <code>DBImpl</code>。</p>
<h2 id="Compaction-的触发和调度"><a href="#Compaction-的触发和调度" class="headerlink" title="Compaction 的触发和调度"></a>Compaction 的触发和调度</h2><h3 id="DBImpl-BackgroundCall"><a href="#DBImpl-BackgroundCall" class="headerlink" title="DBImpl::BackgroundCall"></a>DBImpl::BackgroundCall</h3><p>BackgroundCall 是在后台线程中执行的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>MakeRoomForWrite</code> 函数会使用 <code>background_work_finished_signal_</code> 等待 Compaction 结束。所以在可能完成一次 Compaction 之后，会 signal 一下这个 CV。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="DBImpl-MaybeScheduleCompaction"><a href="#DBImpl-MaybeScheduleCompaction" class="headerlink" title="DBImpl::MaybeScheduleCompaction"></a>DBImpl::MaybeScheduleCompaction</h3><p>函数 <code>MaybeScheduleCompaction</code> 用来调度 BGWork，而这个函数主要就是做 Compaction。MaybeScheduleCompaction 在 DBImpl::Get 时也可能被调用。其调度关系上文已经讲了。<br>这里需要加锁，LevelDB 只允许一个后台进程做 Compaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PosixEnv-Schedule"><a href="#PosixEnv-Schedule" class="headerlink" title="PosixEnv::Schedule"></a>PosixEnv::Schedule</h4><p>这里的 <code>env_</code> 的实现实际上是一个 <code>PosixEnv</code>。<br>查看源码，Schedule 中会先判断 <code>started_background_thread_</code> 是否为 true。否则就创建一个 <code>background_thread</code>，然后 detach 掉。<br>接下来就是一个生产者消费者模式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::Schedule(</span><br><span class="line">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg) &#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.detach();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面放一下消费者的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::BackgroundThreadMain() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixEnv::PosixEnv()</span><br><span class="line">    : background_work_cv_(&amp;background_work_mutex_),</span><br><span class="line">      started_background_thread_(<span class="literal">false</span>),</span><br><span class="line">      mmap_limiter_(MaxMmaps()),</span><br><span class="line">      fd_limiter_(MaxOpenFiles()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>有点奇怪，是先 Signal，再入队。这样不会导致消费者从 Wait 中醒过来，发现 background_work_queue_ 还没被入队么？这里其实是通过消费者中 <code>while (background_work_queue_.empty())</code> 来避免的。如果从 Wait 出来后，发现条件不满足，那么就会继续 Wait。而一旦从 Wait 出来，CV 的实现是保证 background_work_mutex_ 是被持有的，所以 background_work_queue_ 不会再被更改。</p>
<p>有关条件变量，可以参考<a href="/2017/12/28/Concurrency-Programming-Compare/">并发编程重要概念及比较</a>。</p>
<h2 id="和Compaction的实际执行"><a href="#和Compaction的实际执行" class="headerlink" title="和Compaction的实际执行"></a>和Compaction的实际执行</h2><h3 id="DBImpl-BackgroundCompaction"><a href="#DBImpl-BackgroundCompaction" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h3><p>这个过程是 Compaction 的主过程，需要全程持锁。</p>
<h3 id="Minor"><a href="#Minor" class="headerlink" title="Minor"></a>Minor</h3><p>在 BackgroundCompaction 中先处理 <code>CompactMemTable</code>，也就是 Minor Compaction。这个肯定是优先级更高的，因为总共只有两个 Memtable，所以肯定想把 Immutable Memtable 快速腾空。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 后面是非 Minor Compaction 的逻辑</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="非Minor-Compaction"><a href="#非Minor-Compaction" class="headerlink" title="非Minor Compaction"></a>非Minor Compaction</h3><p>详见 Major Compaction 章节。</p>
<h1 id="Minor-Compaction-流程"><a href="#Minor-Compaction-流程" class="headerlink" title="Minor Compaction 流程"></a>Minor Compaction 流程</h1><h2 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h2><p>主要流程三部分：</p>
<ol>
<li>WriteLevel0Table<ol>
<li>将 Immutable Memtable 生成 SSTable 文件<br> 这个文件的基本信息写到 <code>FileMetaData</code> 里面，并在最后写入 <code>VersionEdit</code>。<br> 注意，在 Recover 的过程中，这里其实也可以传入 Memtable。</li>
<li>计算添加到哪一层<br> 这个文件未必会放到 Level0，可能会直接放到 Level1 甚至 Level2，具体由 <code>kMaxMemCompactLevel</code> 控制。</li>
<li>将上面说的 <code>FileMetaData</code> 写入 VersionEdit<br> 因此这个函数的实际返回是传入的 <code>VersionEdit* edit</code>。</li>
</ol>
</li>
<li>LogAndApply<br> 用得到的 <code>VersionEdit</code>，去更新数据库状态。</li>
<li>RemoveObsoleteFiles<br> 重置 Immutable Memtable。<br> 删除无用文件。主要包括<code>kLogFile</code>/<code>kLogFile</code>/<code>kTableFile</code>等。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::CompactMemTable() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，就是要把 <code>edit</code> 应用到当前的 VersionSet 上。<br>解释下 <code>edit.SetLogNumber(logfile_number_)</code>：</p>
<ol>
<li>edit 的 <code>log_number_</code> 之前是对应了现在 Immutable Memtable 的 <code>log_number_</code>。 </li>
<li><code>logfile_number_</code> 对应了现在 Memtable 的 <code>log_number_</code>，它在 MakeRoomForWrite 中创建新的 Memtable 的时候就被更新了。</li>
</ol>
<p>我们要做的是用现在 Memtable 的 <code>log_number_</code> 替换掉现在 Immutable Memtable 的 <code>log_number_</code>。 从前，因为 Immutable Memtable 还没落盘，那显然它对应的 log 还是需要的，所以它应该存在在 <code>base</code> 中。现在，新 Version 中它已经落盘了，那么对应的 log file 就不再需要了。所以要在 <code>edit</code> 中记录了当前 Version 对应的日志起始编号。然后通过 LogAndApply 创建一个新的 Version。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// 这里 `SetPrevLogNumber` 是兼容项目，设为 0 可能也是兼容原因吧。</span></span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是清理掉 Immutable Memtable，并且调用 RemoveObsoleteFiles。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h2><p>在前文中，已经介绍过了 <code>WriteLevel0Table</code> 的作用，下面看实现。</p>
<p>首先计算出一个 <code>NewFileNumber</code>，也就是落盘时体现的文件名。这个函数之前已经介绍过了，它会生成诸如 <code>MANIFEST-xxxxx</code> 或者 <code>yyyyy.log</code> 这些 Manifest 和 Log 等等之类文件的序号。</p>
<p><code>pending_outputs_</code> 中保存了所有正在 Compact 的 SSTable 文件，这些文件不能被删除。这引发了我两个问题：</p>
<ol>
<li>什么时候会删除这些文件？<br> 在 <code>RemoveObsoleteFiles</code> 里面，马上就能看到了，不急不急。</li>
<li>为什么在 BuildTable 之后就可以清理掉 <code>pending_outputs_</code> 结构了？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,</span><br><span class="line">                                Version* base) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接着，<code>BuildTable</code> 创建一个 <code>TableBuilder</code> 写入数据。这个函数在 <a href="/2021/04/12/leveldb-sstable/">LevelDB 之 SSTable 实现</a> 中介绍过了。<br>值得注意的是，这里并没有加锁。我之前认为这是因为 <code>BuildTable</code> 里面会自带加锁，但是检查代码并没有。而且 BuildTable 也是要等文件全部写完，然后 fsync 的，所以可能确实是同步写吧。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>新生成的文件未必会放到 Level0，可能会直接放到 Level1。例如，如果新的 SSTable 文件和 Level1 中的文件没有重叠，那么就<strong>有可能</strong>被放到 Level1，具体还需要查看 Level2 和新 SSTable 的重叠情况。这通过 <code>PickLevelForMemTableOutput</code> 来计算，我们在 <a href="/2021/04/17/leveldb-version/">LevelDB之Version</a> 中已经介绍过了。<br>下面的 <code>edit-&gt;AddFile</code> 就是将这个 SSTable 加到当前的 VersionEdit 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>env_</code> 实际上是封装了文件系统等操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RemoveObsoleteFiles"><a href="#RemoveObsoleteFiles" class="headerlink" title="RemoveObsoleteFiles"></a>RemoveObsoleteFiles</h2><p>清理文件的范围？看 <code>env_-&gt;GetChildren</code> 的实现，应该是所有该 db 下的文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::RemoveObsoleteFiles() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don't know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;live);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  env_-&gt;GetChildren(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files_to_delete;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>清理文件的类型？</p>
<ol>
<li>日志：从当前的 LogNumber 开始保留</li>
<li>Manifest 文件：从当前的 ManifestFileNumber 开始保留</li>
<li>TableFile</li>
<li>TempFile</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;LogNumber()) ||</span><br><span class="line">                  (number == versions_-&gt;PrevLogNumber()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations'</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;ManifestFileNumber());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into "live"</span></span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.push_back(<span class="built_in">std</span>::move(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;Evict(number);</span><br><span class="line">        &#125;</span><br><span class="line">        Log(options_.info_log, <span class="string">"Delete type=%d #%lld\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;RemoveFile(dbname_ + <span class="string">"/"</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Major-Compaction流程"><a href="#Major-Compaction流程" class="headerlink" title="Major Compaction流程"></a>Major Compaction流程</h1><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在开始研究 Major Compaction 前，思考下列问题：</p>
<ol>
<li><p>L0 中的 SST 文件是 Overlap 的。可是为什么 Level0 使用 Tiered 策略而不是 Leveled 策略？<br> 如果 Memtable 向 L0 中的 Minor Compaction 使用了 Leveled 策略，那么很可能会导致整个 L0 被重写。而我们只有 Mutable 和 Immutable 两个 Memtable，为了减少 Memtable 的 flush 的开销，所以 Level0 使用 Tiered 策略。</p>
</li>
<li><p>对于 Level0 里面的文件，能不能直接选一个和 Level1 中的文件 Merge？<br> 答案是不行的，可以看下 <code>GetOverlappingInputs</code> 的论述。</p>
</li>
<li><p>如果 level 中的某个文件的 key 的 range 过大，它可能和 level+1 层的很多文件有重合，这样的 compaction 写放大很重，如何解决这个问题？<br> 首先，这也是为什么 LevelDB 要分成很多层的原因，在 Merge 的时候，最多和下一层中的所有文件 Overlap，写放大是被分摊的。<br> 其次，在 Compact 的时候，LevelDB 一直关注和 level+2 层的 key 的重叠情是否超过一定量，即 <code>MaxGrandParentOverlapBytes</code> 函数。</p>
<ul>
<li>在 <code>ShouldStopBefore</code> 判断是否要结束当前 SSTable 写入，新开文件的时候，考虑当前文件和 level+2 的 Overlap，如果过了，就新开文件。</li>
<li>在 <code>IsTrivialMove</code> 判断是否可以直接移动文件到下层的时候，考虑要移动的文件和 level+2 层的 Overlap，如果过了，就不能移动。</li>
<li>在 <code>PickLevelForMemTableOutput</code> 选择 Minor Compaction 的层时，考虑这个 Immutable Memtable 的 Overlap，如果过了，就不能放在这一层。</li>
</ul>
</li>
<li><p>从 level 到 level+1 的 Compaction 会对 level+2 产生什么影响？</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">LevelDB</a>中多个不相干的合并是可以并发进行的，这个的实现是怎样的？<br> 需要注意，Level0 文件是彼此 Overlap 的，所以是相干的。<br> 【Q】那么当一个 Major Compaction 开始的时候，是如何判定是否相干，如果不相干就不 Compact 的呢？从 LevelDB 的代码来看，只有一个后台线程进行 Compact 操作，所以我认为虽然在设计上 LSM 树是允许并行 Compact 的，但是 LevelDB 并没有实现，但 RocksDB 肯定是实现的。</p>
</li>
<li><p>LevelDB 中，每个 user key 在一层中是不是只会出现一次？<br> 大多数情况是的，有两个例外。<br> 首先，Level0 是 Overlap 的，可能有多个。<br> 其次，如果使用了 Snapshot，那么在下层可能也会有 user key 相同，但是 sequence 不同的。见 <code>AddBoundaryInputs</code> 的论述。</p>
</li>
<li><p>我们往 Manifest 文件里面写了什么？<br> 见 <a href="/2021/04/17/leveldb-version/">LevelDB之Version</a>。</p>
</li>
<li><p>LevelDB 有容量限制么？<br> <a href="https://stackoverflow.com/questions/31742460/is-there-record-number-limit-in-leveldb" target="_blank" rel="noopener">应该是没有的，但是当最下面一层变得特别大之后，Compaction 的开销会很大</a>。</p>
</li>
<li><p>LevelDB 到底是限制的每一层的文件数量还是大小？<br> 【Q】如果限制的是总大小，如果保证生成的 SSTable 的大小是大致相同的？<br> 对于 Major Compaction 来说，是在 <code>DoCompactionWork</code> 里面通过下面的代码来判断的，也就是说当文件大小达到一定规模后，就会产生新的文件了。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">   compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br></pre></td></tr></table></figure>

<p> 这个调用最后会转到 <code>options-&gt;max_file_size</code> 上。</p>
</li>
<li><p>LevelDB 每一层的文件数量有限制么？<br> 首先 Level0 肯定有，大家说是4个么？我觉得不是。参考下面的代码，4只是表示有4个文件就开始 Level0 的 Compaction。当文件数达到12个，才是上限，这个时候就要停止写了。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Soft limit on number of level-0 files.  We slow down writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_SlowdownWritesTrigger = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of level-0 files.  We stop writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_StopWritesTrigger = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>LevelDB 底层 SSTable 中的数据永无出头之日么？<br> 怎么可能，只要数据被修改，那么就会先到 Memtable 里面。</p>
</li>
<li><p>Compaction 是如何删除文件的？<br> 详见 DoCompactionWork。</p>
</li>
<li><p>对于一个 Key 有多个 Put 和 Delete 的情况下，有哪些 Put 和 Delete 是可以被删除的呢？<br> 见 DoCompactionWork。可以列出几点：</p>
<ul>
<li>如果只有一个 Delete，并且这个 Delete 是最新的，也不能删除这个 Delete 记录。这是因为可能这个 Key 在没处理到的更下层有记录。这样尽管我们删掉了这最新的 Delete 记录，但查找的时候会在更下层找到对应的 Key。</li>
<li>如果有连续多个 Put，可以干掉较老的 Put。</li>
</ul>
</li>
</ol>
<h2 id="Compaction-类"><a href="#Compaction-类" class="headerlink" title="Compaction 类"></a>Compaction 类</h2><p>Compaction 类定义在 version_set.h 文件里面。它主要用来管理非 Minor Compaction。</p>
<p>成员：</p>
<ol>
<li><code>std::vector&lt;FileMetaData*&gt; inputs_[2];</code><br> 表示这个 Compaction 涉及的两个 level 的文件，也就是输入。<br> 其中 level 层是 <code>inputs_[0]</code>。level + 1层是 <code>inputs_[1]</code>，称为 parents。<br> 【Q】这里面的文件会按照 key 的顺序来排列么？从 PickCompaction 来看是这样的。</li>
<li><code>std::vector&lt;FileMetaData*&gt; grandparents_;</code><br> level + 2 层的文件，通常称为 grandparents。</li>
<li><code>size_t level_ptrs_[config::kNumLevels];</code></li>
<li><code>size_t grandparent_index_;</code></li>
<li><code>bool seen_key_;</code></li>
<li><code>int64_t overlapped_bytes_;</code></li>
<li><code>size_t level_ptrs_[config::kNumLevels];</code></li>
</ol>
<p>函数：</p>
<ol>
<li><code>int level() const { return level_; }</code><br> 我们将 <code>level_</code> 和 <code>level_+1</code> 层进行 Compact。</li>
<li><code>int num_input_files(int which) const</code><br> 表示那两个 inputs_ 中分别有几个文件。</li>
<li><code>bool IsTrivialMove() const;</code><br> 是否可以直接移动，而不涉及 merge 或者 split 操作。</li>
<li><code>bool ShouldStopBefore(const Slice&amp; internal_key);</code></li>
<li><code>VersionEdit* edit() { return &amp;edit_; }</code>/<code>edit_</code><br> Compaction 肯定会有文件增删，即使仅仅是 TrivialMove，也是跨层的，所以会导致变化。这里需要一个 <code>VersionEdit</code> 来描述。</li>
</ol>
<h3 id="IsTrivialMove"><a href="#IsTrivialMove" class="headerlink" title="IsTrivialMove"></a>IsTrivialMove</h3><p>这个函数用来判断在 Major Compaction 的时候能不能直接移动老的文件到下面一层，免去归并生成新文件的开销。需要同时满足三个条件：</p>
<ol>
<li>level 层只有一个 SSTable<br> 【Q】疑问：如果 level 层有多个，level+1 层没有，直接移动到下面一层安全么？禁止这么做的目的是什么？<br> 检查对 <code>GetOverlappingInputs</code> 的分析，可能是不安全的。如果说 Level0 的某个文件 <code>f</code> 和 Level1 的文件有 Overlap，那么就必须要扫描整个 Level0 层的所有文件，将与 <code>f</code> 有 Overlap 的文件都要移到下一层。</li>
<li>level + 1 层没有<br> 这个原因应该好理解，如果 level+1 层有，那就得比较和这个文件有没有 Overlap。</li>
<li>和 level + 2 层的 overlap 没有超过阈值(实际上是20M)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Compaction::IsTrivialMove() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个条件满足，就可以将文件从 level 移动到 level+1。</p>
<h2 id="DBImpl-CompactionState-类"><a href="#DBImpl-CompactionState-类" class="headerlink" title="DBImpl::CompactionState 类"></a>DBImpl::CompactionState 类</h2><p><code>DBImpl::CompactionState</code> 这个类封装了 <code>Compaction</code>，这是因为要处理两个 Level 之间的合并，所以要加一些额外的字段。</p>
<ol>
<li><code>SequenceNumber smallest_snapshot;</code><br> 小于 <code>smallest_snapshot</code> 的 Sequence Number 是不重要的，因为不会提供 <code>smallest_snapshot</code> 的 snapshot。<br> 所以，如果看到 Sequence Number 小于等于 <code>smallest_snapshot</code> 的某个 <code>S</code>，就可以丢弃小于 <code>S</code> 的这个 key 的其他版本。<br> 【Q】这里是不是在说，如果只有 S 这个独苗，那还是要写进去的？</li>
<li><code>std::vector&lt;Output&gt; outputs;</code></li>
<li><code>Output* current_output() { return &amp;outputs[outputs.size() - 1]; }</code><br> 保存每个输出文件的元信息。例如 smallest 和 largest。</li>
<li><code>WritableFile* outfile;</code><br> Major Compaction 过程中，需要输出到 level+1 层的文件。注意，可能有多个这样的文件，参考 <code>ShouldStopBefore</code>。</li>
<li><code>TableBuilder* builder;</code></li>
<li><code>uint64_t total_bytes;</code></li>
</ol>
<h2 id="DBImpl-BackgroundCompaction-1"><a href="#DBImpl-BackgroundCompaction-1" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>下面是对 Major Compaction 的处理。</p>
<h3 id="构造Compaction对象"><a href="#构造Compaction对象" class="headerlink" title="构造Compaction对象"></a>构造Compaction对象</h3><ol>
<li><p>首先处理 Manual Compaction 的情况。<br> 如果 <code>manual_compaction_</code> 不是 null，就触发 Manual Compaction。我没看到非测试的代码里面有设置 <code>manual_compaction_</code> 的，但是 <code>leveldb_compact_range</code> 这个 api 会显式调用 <code>CompactRange</code>，并且 <code>DB</code> 这个接口中也有 <code>CompactRange</code> 方法，也就是说 LevelDB 对外暴露这个方法。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>其次，调用 <code>PickCompaction</code> 处理 size compaction 和 seek compaction 的情况。<br> <code>PickCompaction</code> 会返回当前要 Compact 的文件，如果返回 null，就啥事都不做。对于 <code>PickCompaction</code> 而言，如果既没有 size compaction，又没有 seek compaction，返回 null。</p>
</li>
</ol>
<p><strong>这个过程是持锁的</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 前面是对Minor Compaction的处理</span></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="根据Compaction对象进行Compact操作"><a href="#根据Compaction对象进行Compact操作" class="headerlink" title="根据Compaction对象进行Compact操作"></a>根据Compaction对象进行Compact操作</h3><p>经过上面的代码得到了一个 <code>Compaction* c</code> 对象，下面是两种平凡情况：</p>
<ol>
<li>如果之前 <code>PickCompaction</code> 没给出这 <code>c</code>，那么就说明这一次不要 Compact。</li>
<li>如果满足 <code>IsTrivialMove</code> 条件，就可以不生成新的文件，直接将原文件移动到下一层。<br> 对于 Trivial 的情况直接更新 <code>c-&gt;edit()</code>，不走 <code>InstallCompactionResults</code> 的逻辑了。<br> 主要就是将 level 层的 SSTable 移动到 level+1 层。然后调用 LogAndApply 来得到一个新的 Version。</li>
<li>如果不满足 <code>IsTrivialMove</code> 条件，就是一般情况，由 <code>DoCompactionWork</code> 处理。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status status;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Nothing to do</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">    <span class="comment">// Move file to next level</span></span><br><span class="line">    assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">    FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">    c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                       f-&gt;largest);</span><br><span class="line">    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    &#125;</span><br><span class="line">    VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">        status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>DoCompactionWork</code> 进行 Compaction。</p>
<p>然后要 <code>CleanupCompaction</code>：</p>
<ol>
<li>清空 compact 对象</li>
<li>根据 <code>compact-&gt;outputs</code>，找到 <code>pending_outputs_</code> 里面对应的文件，并移除出 <code>pending_outputs_</code><br> <code>compact-&gt;outputs</code> 记录了每个输出文件的元信息，而 <code>pending_outputs_</code> 记录了正在 compact 的文件，compact 结束后，就把这些文件移出去。<br> 在 Major Compaction 中，文件是在 <code>DoCompactionWork -&gt; OpenCompactionOutputFile</code> 中被加入 <code>pending_outputs_</code> 的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">    status = DoCompactionWork(compact);</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    &#125;</span><br><span class="line">    CleanupCompaction(compact);</span><br><span class="line">    c-&gt;ReleaseInputs();</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> c;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>如果是 Manual 的，需要清空 Manual 状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;done) &#123;</span><br><span class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">      <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">      m-&gt;tmp_storage = manual_end;</span><br><span class="line">      m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">    &#125;</span><br><span class="line">    manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Version-PickCompaction"><a href="#Version-PickCompaction" class="headerlink" title="Version::PickCompaction"></a>Version::PickCompaction</h2><p>PickCompaction 用来生成一个 Compaction 对象。<br>size compaction 的优先级是高于 seek compaction 的，所以 PickCompaction 首先处理 size_compaction。</p>
<p>首先是处理 size compaction，这个 compaction 的缘由是某一层太大了，所以具体 compact 哪个 range 是可以优化的。在 LevelDB 中，size compaction 每次 Compact 的 range 是轮流来的。<code>compact_pointer_[level]</code> 记录了上一次这一层 Compaction 到了哪里，也指定了下一轮 Compaction 从哪里开始。遍历 <code>current_-&gt;compaction_level_</code> 这一层的所有文件，找到第一个 largest 大于 <code>compact_pointer_[level]</code> 的文件，放到 <code>Compaction* c</code> 的 <code>inputs_[0]</code> 中。表示要将这个文件合并到下一层。<br>如果一轮循环下来没找到，说明所有的文件的 largest 都小于 <code>compact_pointer_[level]</code>，也就是这一层所有的 key 都小于 <code>compact_pointer_[level]</code>，那就把第一个文件放进去。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compaction* VersionSet::PickCompaction() &#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于 seek compaction，是某些具体的文件需要被 compact，所以就不用 <code>compact_pointer_[level]</code>，而是把要 Compact 的那个文件加到 <code>c-&gt;inputs_[0]</code> 就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">    level = current_-&gt;file_to_compact_level_;</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">    c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于 Level0，有个特别的处理，因为 Level0 的 sst 是互相重叠的，所以要将所有相互重叠的 sst 都选出来。具体实现参考 <code>GetOverlappingInputs</code> 函数的说明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  c-&gt;input_version_ = current_;</span><br><span class="line">  c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">    InternalKey smallest, largest;</span><br><span class="line">    GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">    <span class="comment">// which will include the picked file.</span></span><br><span class="line">    current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在已经得到了 <code>c-&gt;inputs_[0]</code>。<strong>除了 <code>c-&gt;inputs_[0]</code> 的情况，否则 <code>c-&gt;inputs_[0]</code> 里面都只有一个文件</strong>。<br>通过 <code>SetupOtherInputs</code> 可以计算 <code>c-&gt;inputs_[1]</code>，也就是 level+1 层有哪些 sst 文件和 inputs_[0] 中的文件重叠。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Version-SetupOtherInputs"><a href="#Version-SetupOtherInputs" class="headerlink" title="Version::SetupOtherInputs"></a>Version::SetupOtherInputs</h2><p><code>SetupOtherInputs</code> 计算在 Compaction 时，level+1 层上有哪些文件重叠，从而要放到 <code>c-&gt;inputs_[1]</code> 上。在这个函数之后，就得到了正确的 <code>c-&gt;inputs_</code> 数组、<code>c-&gt;grandparents_</code> 字段，以及 <code>compact_pointer_</code> 字段。在这个函数之后，<code>PickCompaction</code> 就结束了，<code>BackgroundCompaction</code> 会执行后面的流程，也就是 <code>DoCompactionWork</code>。<br>基本的思想是：所有和 level 层有重叠的 level+1 层文件都要参与 Compact。得到这些文件后，再继续看利用这些 level+1 层的文件，能不能 Compact 更多 level 层的文件？<br>这个函数被 <code>CompactRange</code> 和 <code>PickCompaction</code> 调用，也就是所有的 Major Compaction 逻辑都会走到这里。</p>
<h3 id="GetRange和GetRange2"><a href="#GetRange和GetRange2" class="headerlink" title="GetRange和GetRange2"></a>GetRange和GetRange2</h3><p>GetRange 计算 <code>inputs_[0]</code> <strong>或</strong> <code>inputs_[1]</code> 覆盖的区间。通过 smallest 和 largest 返回。<br>GetRange2 计算 <code>inputs_[0]</code> 和 <code>inputs_[1]</code> 覆盖的区间。<br>GetRange 很简单，<strong>顺序遍历</strong>每一个文件，然后更新 smallest 和 largest，这里注意都需要 <code>icmp_.Compare</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span><br><span class="line">                          InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  assert(!inputs.empty());</span><br><span class="line">  smallest-&gt;Clear();</span><br><span class="line">  largest-&gt;Clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</span><br><span class="line">    FileMetaData* f = inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      *smallest = f-&gt;smallest;</span><br><span class="line">      *largest = f-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *smallest = f-&gt;smallest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *largest = f-&gt;largest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GetRange2 也很简单，就直接合并 <code>inputs_[0]</code> 和 <code>inputs_[1]</code> 的内容到一个 vector 里面，然后调用 GetRange。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span><br><span class="line">                           InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; all = inputs1;</span><br><span class="line">  all.insert(all.end(), inputs2.begin(), inputs2.end());</span><br><span class="line">  GetRange(all, smallest, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AddBoundaryInputs"><a href="#AddBoundaryInputs" class="headerlink" title="AddBoundaryInputs"></a>AddBoundaryInputs</h3><p><code>AddBoundaryInputs</code> 是一个很重要的函数，是后来加进去的。它关系到<a href="https://github.com/google/leveldb/issues/320" target="_blank" rel="noopener">Issue 320</a>和<a href="https://github.com/google/leveldb/pull/339" target="_blank" rel="noopener">PR 339</a>。<code>AddBoundaryInputs</code> 函数也是在那个时候引进的。不过值得注意的是，这个 patch 在2016年就提了，但是2019年才被合进去。只有很少的 Blog 能讲明白这个函数的来龙去脉。<br>接受的参数：</p>
<ol>
<li>level_files 表示当前要处理的 level 中的所有文件</li>
<li>compaction_files 一般是 <code>c-&gt;inputs_[0]</code></li>
</ol>
<p>翻译一下 <code>AddBoundaryInputs</code> 这个函数的注释：</p>
<ol>
<li>提取出 <code>compaction_files</code> 里面最大的文件 b1，也就是这个 level 中的最大文件。</li>
<li>然后在 <code>level_files</code> 里面找到一个 b2，满足 b1 和 b2 的 user key 是相等的，这样的 b2 称为 boundary file。<br> 需要将这个 b2 加入到 <code>compaction_files</code>，也就是 <code>c-&gt;inputs_[0]</code> 里面，并且更新 largest_key，<strong>继续找上界</strong>。</li>
</ol>
<p>如果有两个 SSTable 文件，范围分别是 <code>b1=(l1, u1)</code> 和 <code>b2=(l2, u2)</code>，且 user_key(u1) 等于 user_key(l2)。如果只 Compact 文件 b1，不 Compact 文件 b2 到更下面一层的话，在读取 u1 的时候就会出错。因为 b1 在 b2 上层了，所以只会返回 b2 的结果，而永远不会返回 b1 的结果。甚至 b2 的结果可能还是一个较旧的数据，因为根据 Memtable 里面的介绍，Sequence Number 是从新到旧来排序的。<br>这实际上是在说，<strong>user key 跨越多个 SST 文件边界</strong>的问题。Issue 320 上提到这个可能在 Snapshot 场景下发生。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span></span></span><br></pre></td></tr></table></figure>

<p>【Q】看起来，这个函数做的是和 <code>GetOverlappingInputs</code> 一样的事情，他们的区别是什么呢？首先，<code>GetOverlappingInputs</code> 的初心不是扩展边界，而是计算某一层和某个 range 重合的文件，只是对 Level0 要特殊处理一下。其次，<a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">这篇文章</a>中进行了解释：</p>
<p>如下图所示，两个 SSTable 中，出现了 user key 相同（都为 key2）但是 Sequence Number 不同的两个 Internal Key。<br><img src="/img/leveldb/compaction/AddBoundaryInputsProblem.png"></p>
<p>可以看到 <code>GetOverlappingInputs</code> 的特殊处理关注的是 Level0 上某一个要 Compact 的文件中的所有 key 是否还会出现在其他的 SSTable 文件中。而 <code>AddBoundaryInputs</code> 关注的是某个 Key 的其他版本是否还会出现在其他的 SSTable 中。</p>
<p>【Q】这里引发了第二个疑问，为什么同一层中会出现两个相同 user key 的 Key 呢？我觉得可能因为这个 Key 出现在两个 SSTable 的边界上，所以这个函数叫 <code>AddBoundaryInputs</code> 吧。</p>
<p>其实我觉得更好的设计是想办法让 user key 按照 SST 边界切割。但仔细回顾一下 <code>DoCompactionWork</code> 的实现，似乎是可能没处理完一个 Key，就 <code>ShouldStopBefore</code> 了的。但即使这样，后面的文件里面也不会再写有关这个 user key 的内容了。那么究竟在什么情况下会发生这种情况呢？根据<a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">这篇文章</a>中指出 <strong>Snapshot 机制会导致“同一层中会出现两个相同 user key 的 Key”</strong>这个问题。</p>
<p>【Q】这里引发了第三个疑问，出现了两个 user key，会不会影响读取呢？实际上只要位于同一层就不影响，因为根据 Memtable 里面的介绍，Sequence Number 是从新到旧来排序的。我们的查找方式允许每一次都找到 b1 里面的值，也就是始终是一个最新的数据。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>FindLargestKey 用来找一系列文件中最大的 key，如果是空的，则返回 false。否则遍历这些文件，统计出最大的 key。<br>现在找到了 <code>compaction_files</code> 也就是 <code>c-&gt;inputs_[0]</code> 中最大的 key，即 largest_key 了。<br>然后用 FindSmallestBoundaryFile 在 level_files 中找最小的 b2=(l2, u2)，满足 l2 &gt; u1 且 user_key(l2) = user_key(u1)。这里的 u1 就是 largest_key。<br>如果不存在这样的文件，就退出循环。如果存在这样的文件，那么说明存在 Boundary File，我们要将这个文件加到 compaction_files 里面，然后更新 largest_key 为这个 Boundary File 的 largest，继续搜索。为什么可以直接更新呢？因为找到的 l2 肯定大于 largest_key 了，那么 u2 也就是这里的 largest 肯定更大于了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  InternalKey largest_key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Quick return if compaction_files is empty.</span></span><br><span class="line">  <span class="keyword">if</span> (!FindLargestKey(icmp, *compaction_files, &amp;largest_key)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> continue_searching = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">while</span> (continue_searching) &#123;</span><br><span class="line">    FileMetaData* smallest_boundary_file =</span><br><span class="line">        FindSmallestBoundaryFile(icmp, level_files, largest_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If a boundary file was found advance largest_key, otherwise we're done.</span></span><br><span class="line">    <span class="keyword">if</span> (smallest_boundary_file != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      compaction_files-&gt;push_back(smallest_boundary_file);</span><br><span class="line">      largest_key = smallest_boundary_file-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      continue_searching = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看一下 FindSmallestBoundaryFile。其实这里有个疑惑，level_files 有可能是无序的么，为什么这里还是线性遍历？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Finds minimum file b2=(l2, u2) in level file for which l2 &gt; u1 and</span></span><br><span class="line"><span class="comment">// user_key(l2) = user_key(u1)</span></span><br><span class="line"><span class="function">FileMetaData* <span class="title">FindSmallestBoundaryFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> InternalKey&amp; largest_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = icmp.user_comparator();</span><br><span class="line">  FileMetaData* smallest_boundary_file = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; level_files.size(); ++i) &#123;</span><br><span class="line">    FileMetaData* f = level_files[i];</span><br><span class="line">    <span class="keyword">if</span> (icmp.Compare(f-&gt;smallest, largest_key) &gt; <span class="number">0</span> &amp;&amp; <span class="comment">// l2 &gt; u1</span></span><br><span class="line">        user_cmp-&gt;Compare(f-&gt;smallest.user_key(), largest_key.user_key()) == <span class="comment">// user_key(l2) = user_key(u1)</span></span><br><span class="line">            <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (smallest_boundary_file == <span class="literal">nullptr</span> ||</span><br><span class="line">          icmp.Compare(f-&gt;smallest, smallest_boundary_file-&gt;smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        smallest_boundary_file = f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> smallest_boundary_file;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SetupOtherInputs-主体"><a href="#SetupOtherInputs-主体" class="headerlink" title="SetupOtherInputs 主体"></a>SetupOtherInputs 主体</h3><p>首先计算 all_start 和 all_limit，也就是整个 Compaction 过程涉及的区间：</p>
<ol>
<li><code>AddBoundaryInputs</code> 扩充一下 <code>c-&gt;inputs_[0]</code>。<br> 防止在 <code>current_-&gt;files_[level]</code> 的后续的 SST 文件中还存在相等的 user key。</li>
<li>用 GetRange 获得 Level N 的 range。</li>
<li>用 GetOverlappingInputs，根据 Level N 的 range，计算出 Level N+1 和 Level N 重叠的 SSTable 文件，并放入 <code>c-&gt;inputs_[1]</code>。</li>
<li>用 GetRange2 计算 Level N 和 Level N+1 合并起来的 range。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::SetupOtherInputs(Compaction* c) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后，如果 Level N+1 和 Level 1 存在重叠，即 <code>c-&gt;inputs_[1]</code> 不为空。则：</p>
<ol>
<li>首先用 GetOverlappingInputs 再更新一下<br> 原因是 GetRange2 又一次扩大了 all_start 和 all_limit，需要重新计算一下和 <code>level</code> 层的 overlap。</li>
<li>调用 <code>AddBoundaryInputs</code> 处理 <code>level</code> 层的边界。</li>
<li>如果新的边界实际让 <code>c-&gt;inputs_[0]</code> 变得更大了，新的数据大小在阈值<ol>
<li>重新计算 <code>c-&gt;inputs_[1]</code> 即 expanded1，如果没有使 <code>c-&gt;inputs_[1]</code> 更大，则拓展 all_start 和 all_limit</li>
<li>否则就不拓展。也就是说不会再扩展 <code>c-&gt;inputs_[0]</code> 了。</li>
</ol>
</li>
</ol>
<p>为什么这样是安全的呢？我觉得有几点：</p>
<ol>
<li>因为 Compact 之后是到 level+1 层的，所以 level+1 层不存在 boundary 问题。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line">  <span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line">  <span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">    AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">    <span class="keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[<span class="number">0</span>].size() &amp;&amp;</span><br><span class="line">        inputs1_size + expanded0_size &lt;</span><br><span class="line">            ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">      InternalKey new_start, new_limit;</span><br><span class="line">      GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">      current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                     &amp;expanded1);</span><br><span class="line">      <span class="keyword">if</span> (expanded1.size() == c-&gt;inputs_[<span class="number">1</span>].size()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log,</span><br><span class="line">            <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">            level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].size()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].size()),</span><br><span class="line">            <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.size()),</span><br><span class="line">            <span class="keyword">int</span>(expanded1.size()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">        smallest = new_start;</span><br><span class="line">        largest = new_limit;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">        c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">        GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，设置一下 <code>c-&gt;grandparents_</code> 这个字段。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                   &amp;c-&gt;grandparents_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>记录下一轮的 <code>compact_pointer_</code>。我们在这里立即更新，而不是等到 VersionEdit 被 Apply 的时候更新，这样当 Compaction 失败后，能下次能尝试一个不同的 key range。</p>
<ol>
<li>【Q】什么是 <code>compact_pointer_</code>？<br> 查看 <code>PickCompaction</code> 函数，它会找到 largest 大于 <code>compact_pointer_[level]</code> 后的第一个文件。<br> 可以发现，其实每一次要 Compaction 的文件就是通过 <code>compact_pointer_</code> 指定的。</li>
<li>【Q】在这之后，Compaction 会因为什么失败？</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DoCompactionWork的辅助函数"><a href="#DoCompactionWork的辅助函数" class="headerlink" title="DoCompactionWork的辅助函数"></a>DoCompactionWork的辅助函数</h2><h3 id="MakeInputIterator"><a href="#MakeInputIterator" class="headerlink" title="MakeInputIterator"></a>MakeInputIterator</h3><p>Create an iterator that reads over the compaction inputs for “<code>*c</code>“. The caller should delete the iterator when no longer needed.</p>
<p>分两种情况：</p>
<ol>
<li>如果是 Level0，则将这一层中的所有文件对应的 iterator 加入到 list 中</li>
<li>如果是其它层，则创建一个基于这个层的 LevelFileNumIterator + NewTwoLevelIterator<br> LevelFileNumIterator 用来遍历这一层中的所有的文件。返回每个 entry 的 key 是每个文件的最大的 key，value 是这个文件的一些信息。我想这个迭代器应该要依赖传进来的 <code>c-&gt;inputs</code> 是有序的。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Iterator* VersionSet::MakeInputIterator(Compaction* c) &#123;</span><br><span class="line">  ReadOptions options;</span><br><span class="line">  options.verify_checksums = options_-&gt;paranoid_checks;</span><br><span class="line">  options.fill_cache = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Level-0 files have to be merged together.  For other levels,</span></span><br><span class="line">  <span class="comment">// we will make a concatenating iterator per level.</span></span><br><span class="line">  <span class="comment">// TODO(opt): use concatenating iterator for level-0 if there is no overlap</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> space = (c-&gt;level() == <span class="number">0</span> ? c-&gt;inputs_[<span class="number">0</span>].size() + <span class="number">1</span> : <span class="number">2</span>);</span><br><span class="line">  Iterator** <span class="built_in">list</span> = <span class="keyword">new</span> Iterator*[space];</span><br><span class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;inputs_[which].empty()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c-&gt;level() + which == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">          <span class="built_in">list</span>[num++] = table_cache_-&gt;NewIterator(options, files[i]-&gt;number,</span><br><span class="line">                                                  files[i]-&gt;file_size);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Create concatenating iterator for the files from this level</span></span><br><span class="line">        <span class="built_in">list</span>[num++] = NewTwoLevelIterator(</span><br><span class="line">            <span class="keyword">new</span> Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),</span><br><span class="line">            &amp;GetFileIterator, table_cache_, options);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(num &lt;= space);</span><br><span class="line">  Iterator* result = NewMergingIterator(&amp;icmp_, <span class="built_in">list</span>, num);</span><br><span class="line">  <span class="keyword">delete</span>[] <span class="built_in">list</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DBImpl-DoCompactionWork"><a href="#DBImpl-DoCompactionWork" class="headerlink" title="DBImpl::DoCompactionWork"></a>DBImpl::DoCompactionWork</h2><p>DoCompactionWork 是一般情况下的 Major Compact 过程，来自 <code>BackgroundCompaction</code> 的调用。<br>那么这个函数做啥呢，不就是个归并排序么？且慢，考虑几个问题：</p>
<ol>
<li>如何处理同一个 user key 有不同 Sequence Number 呢？<br> 目标肯定是只保留最新的。</li>
<li>如何兼容 Snapshot</li>
</ol>
<p>其中 <code>CompactionState</code> 封装了 <code>Compaction</code>。<br>几个 assert：</p>
<ol>
<li>要压缩的 Level N 层是要有文件的。</li>
<li>几个结构是 nullptr。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::DoCompactionWork(CompactionState* compact) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br><span class="line">  assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">  assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据<a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">文章</a>：</p>
<ol>
<li>如果有 Snapshot，则保留大于 Snapshot SN 的所有 Record，以及在小于 Snapshot SN 的 Record 中，SN 最大的 Record。<br> 在这个函数的后半部分判断是否要删除某个键的时候，会先检查那个键的 SN 要小于等于 smallest_snapshot。从而保证这个键比最老的 Snapshot 还要老，这样才能删掉。</li>
<li>如果没 Snapshot，则设置 smallest_snapshot 为 LastSequence。<br> 也就是说可以删除掉所有的旧的 KV。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们执行 <code>MakeInputIterator</code>，得到的迭代器可以按照 key 大小遍历所有冲突文件中的每个 KV 对。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">  input-&gt;SeekToFirst();</span><br><span class="line">  Status status;</span><br><span class="line">  ParsedInternalKey ikey;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line">  <span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面这个 while 循环遍历刚才得到的迭代器 <code>input</code>，进行 Major Compaction。<br>但且慢，每一次前进 input 迭代器前，都需要先检查有没有 Immatable Memtable，如果有的话，就需要先执行 Minor Compaction。<strong>这也说明了 Minor Compaction 的优先级更高</strong>。<br>简单再介绍下原子操作：</p>
<ol>
<li><code>shutting_down_</code>，采用了 Release-Acquire 内存模型，保证了一定的并行顺序。<br> 如果线程 A Release Store，线程 B Acquire Load，那么<a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">线程A中所有在 Release 前的(atomic或者非atomic)写</a>，对线程 B 都可见。</li>
<li><code>has_imm_</code>，采用了 Relaxed 内存模型。<br> 只保证读写的原子性，不保证并发时和其他变量的 Order。因为加锁之后，会再检查一遍 <code>imm_</code> 是否为空。</li>
</ol>
<p>【Q】这里有个问题，如果这中间 Minor Compaction 了，这也意味着在某一层可能多了一个 SSTable，它是可能 overlap 的，是不是需要重新计算 range？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">    <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">      mutex_.Lock();</span><br><span class="line">      <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        CompactMemTable();</span><br><span class="line">        <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">        background_work_finished_signal_.SignalAll();</span><br><span class="line">      &#125;</span><br><span class="line">      mutex_.Unlock();</span><br><span class="line">      imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>检查当前输出文件(应当位于level+1层)是否与level+2层文件有过多冲突，如果是就要完成当前输出文件，并产生新的输出文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    Slice key = input-&gt;key();</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">        compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面就是判断是不是能 <code>drop</code>，也就是和前面计算的 <code>compact-&gt;smallest_snapshot</code> 比较。<br>正常情况下 <code>ParseInternalKey</code> 不会失败，我们跳过这个分支。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line">    <span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">      <span class="comment">// Do not hide error keys</span></span><br><span class="line">      current_user_key.clear();</span><br><span class="line">      has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">      last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面这个 if，判断的是 <code>current_user_key</code> 第一次出现的情况。包括处理完上一个 user key，到达下一个 user key，或者刚开始处理第一个 user key 的情况。设置 <code>last_sequence_for_key</code> 为最大的 kMaxSequenceNumber，我们不丢弃这种情况下的 key。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">          user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">              <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First occurrence of this user key</span></span><br><span class="line">        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line">        has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">        last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面比较 Sequence Number，如果 <code>last_sequence_for_key</code> 都小于 <code>compact-&gt;smallest_snapshot</code> 了，那么我这个 key 肯定更小，这是因为<a href="/2021/04/09/leveldb-memtable/">Sequence Number是按照降序排列的</a>。对于这种情况，省点事，直接不要了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">        drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下一个判断复杂点，表示对于特定情况下，<a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">一个删除操作也是可以丢掉的</a>。<br>如果：</p>
<ol>
<li>某个删除操作的版本小于等于 <code>smallest_snapshot</code><br> 这说明这个 Key 的 Sequence Number 一定小于最小存活的 Snapshot。</li>
<li>并且在更高层没有相同的 user key，那么这个删除操作及其之前更早的插入操作可以同时丢弃了<br> IsBaseLevelForKey 用来判断更高层有没有这个 key 了。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">        <span class="comment">// For this user key:</span></span><br><span class="line">        <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">        drop = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      last_sequence_for_key = ikey.sequence;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果 drop 条件不符合，那么就写入到 <code>compact-&gt;current_output()</code> 里面，同时更新 largest。<br>同时我们关注文件大小，如果超限了，就 FinishCompactionOutputFile。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">      <span class="comment">// Open output file if necessary</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        status = OpenCompactionOutputFile(compact);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">      &#125;</span><br><span class="line">      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">      compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">      <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">          compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">        status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    input-&gt;Next();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>截至现在，我们已经遍历完迭代器了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = input-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> input;</span><br><span class="line">  input = <span class="literal">nullptr</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>更新状态</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line">    stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面加锁。所以其实在遍历 <code>input</code> 这个迭代器的时候，是没有在加锁的。<br><code>InstallCompactionResults</code> 是一个关键过程，它将这次 Compaction 的内容加入到 VersionEdit 里面，并且最终调用<code>LogAndApply</code>。内容包括什么呢？增加和删除的文件：</p>
<ol>
<li><code>InstallCompactionResults</code> 会调用 <code>Compaction::AddInputDeletions</code>，需要删除的文件，包括 <code>input_[0]</code> 和 <code>input_[1]</code></li>
<li>向<code>compact-&gt;compaction-&gt;edit()</code> 中添加 <code>compact-&gt;outputs</code> 中的所有文件</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/34674504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34674504</a></li>
<li><a href="https://blog.csdn.net/tmshasha/article/details/47703245" target="_blank" rel="noopener">https://blog.csdn.net/tmshasha/article/details/47703245</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51573929" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51573929</a></li>
<li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/basic.html</a></li>
<li><a href="https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/" target="_blank" rel="noopener">https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a></li>
<li><a href="http://blog.jcix.top/2018-05-11/leveldb_paths/" target="_blank" rel="noopener">http://blog.jcix.top/2018-05-11/leveldb_paths/</a></li>
<li><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">http://bean-li.github.io/leveldb-version/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/46718964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46718964</a></li>
<li><a href="http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html" target="_blank" rel="noopener">http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a><br> 这是一个DB完整执行过程的表述。</li>
<li><a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-PickCompaction</a><br> 解释了GetOverlappingInputs的原理</li>
<li><a href="http://lerencao.github.io/posts/lsm-tree-compaction-strategy/" target="_blank" rel="noopener">http://lerencao.github.io/posts/lsm-tree-compaction-strategy/</a></li>
<li><a href="http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/" target="_blank" rel="noopener">http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/</a><br> 上面两篇文章介绍STCS和LCS</li>
<li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181498475</a><br> 图解Compact过程</li>
<li><a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction</a><br> RocksDB对Compaction的讲解</li>
<li><a href="https://blog.csdn.net/weixin_36145588/article/details/78064777" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36145588/article/details/78064777</a></li>
<li><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html</a><br> 这位同学解释了AddBoundaryInputs的来源</li>
<li><a href="https://blog.didiyun.com/index.php/2018/11/20/leveldb-compaction/" target="_blank" rel="noopener">https://blog.didiyun.com/index.php/2018/11/20/leveldb-compaction/</a></li>
<li><a href="https://www.cnblogs.com/cchust/p/6007486.html" target="_blank" rel="noopener">https://www.cnblogs.com/cchust/p/6007486.html</a><br> 介绍了 Compaction 的一些理论</li>
<li><a href="https://zhuanlan.zhihu.com/p/458198720" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/458198720</a><br> 也是理论方面的介绍</li>
<li><a href="https://zhuanlan.zhihu.com/p/141186118" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/141186118</a><br> 分析了一些读写空间放大的情况</li>
<li><a href="https://zhuanlan.zhihu.com/p/37003275" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37003275</a><br> 对于 Compaction 的总体性的理解</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/leveldb/" rel="tag"># leveldb</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/17/leveldb-version/" rel="next" title="LevelDB 之 Version">
                <i class="fa fa-chevron-left"></i> LevelDB 之 Version
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/23/leveldb-wal/" rel="prev" title="LevelDB 之 WAL 实现">
                LevelDB 之 WAL 实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">250</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">153</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#前置知识"><span class="nav-number">1.</span> <span class="nav-text">前置知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#读放大、写放大、空间放大"><span class="nav-number">1.1.</span> <span class="nav-text">读放大、写放大、空间放大</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LCS-和-STCS"><span class="nav-number">1.2.</span> <span class="nav-text">LCS 和 STCS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#STCS"><span class="nav-number">1.2.1.</span> <span class="nav-text">STCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LCS"><span class="nav-number">1.2.2.</span> <span class="nav-text">LCS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#层数和写放大的关系"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">层数和写放大的关系</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RocksDB-的实现"><span class="nav-number">1.3.</span> <span class="nav-text">RocksDB 的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Tiered-Leveled"><span class="nav-number">1.3.1.</span> <span class="nav-text">Tiered+Leveled</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Level-N"><span class="nav-number">1.3.2.</span> <span class="nav-text">Level-N</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#减少写放大"><span class="nav-number">1.4.</span> <span class="nav-text">减少写放大</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#思路1：KV-分离"><span class="nav-number">1.4.1.</span> <span class="nav-text">思路1：KV 分离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路2：Partition"><span class="nav-number">1.4.2.</span> <span class="nav-text">思路2：Partition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#思路3：容忍一定程度的无序"><span class="nav-number">1.4.3.</span> <span class="nav-text">思路3：容忍一定程度的无序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Compaction-主流程"><span class="nav-number">2.</span> <span class="nav-text">Compaction 主流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#总览"><span class="nav-number">2.1.</span> <span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调用路径"><span class="nav-number">2.1.1.</span> <span class="nav-text">调用路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compaction种类"><span class="nav-number">2.1.2.</span> <span class="nav-text">Compaction种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Compaction条件"><span class="nav-number">2.1.3.</span> <span class="nav-text">Compaction条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBImpl类"><span class="nav-number">2.1.4.</span> <span class="nav-text">DBImpl类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compaction-的触发和调度"><span class="nav-number">2.2.</span> <span class="nav-text">Compaction 的触发和调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DBImpl-BackgroundCall"><span class="nav-number">2.2.1.</span> <span class="nav-text">DBImpl::BackgroundCall</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DBImpl-MaybeScheduleCompaction"><span class="nav-number">2.2.2.</span> <span class="nav-text">DBImpl::MaybeScheduleCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PosixEnv-Schedule"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">PosixEnv::Schedule</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#和Compaction的实际执行"><span class="nav-number">2.3.</span> <span class="nav-text">和Compaction的实际执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DBImpl-BackgroundCompaction"><span class="nav-number">2.3.1.</span> <span class="nav-text">DBImpl::BackgroundCompaction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minor"><span class="nav-number">2.3.2.</span> <span class="nav-text">Minor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非Minor-Compaction"><span class="nav-number">2.3.3.</span> <span class="nav-text">非Minor Compaction</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Minor-Compaction-流程"><span class="nav-number">3.</span> <span class="nav-text">Minor Compaction 流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CompactMemTable"><span class="nav-number">3.1.</span> <span class="nav-text">CompactMemTable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WriteLevel0Table"><span class="nav-number">3.2.</span> <span class="nav-text">WriteLevel0Table</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RemoveObsoleteFiles"><span class="nav-number">3.3.</span> <span class="nav-text">RemoveObsoleteFiles</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Major-Compaction流程"><span class="nav-number">4.</span> <span class="nav-text">Major Compaction流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#思考"><span class="nav-number">4.1.</span> <span class="nav-text">思考</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Compaction-类"><span class="nav-number">4.2.</span> <span class="nav-text">Compaction 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IsTrivialMove"><span class="nav-number">4.2.1.</span> <span class="nav-text">IsTrivialMove</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-CompactionState-类"><span class="nav-number">4.3.</span> <span class="nav-text">DBImpl::CompactionState 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-BackgroundCompaction-1"><span class="nav-number">4.4.</span> <span class="nav-text">DBImpl::BackgroundCompaction</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造Compaction对象"><span class="nav-number">4.4.1.</span> <span class="nav-text">构造Compaction对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#根据Compaction对象进行Compact操作"><span class="nav-number">4.4.2.</span> <span class="nav-text">根据Compaction对象进行Compact操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收尾"><span class="nav-number">4.4.3.</span> <span class="nav-text">收尾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-PickCompaction"><span class="nav-number">4.5.</span> <span class="nav-text">Version::PickCompaction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-SetupOtherInputs"><span class="nav-number">4.6.</span> <span class="nav-text">Version::SetupOtherInputs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GetRange和GetRange2"><span class="nav-number">4.6.1.</span> <span class="nav-text">GetRange和GetRange2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AddBoundaryInputs"><span class="nav-number">4.6.2.</span> <span class="nav-text">AddBoundaryInputs</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#实现"><span class="nav-number">4.6.2.1.</span> <span class="nav-text">实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SetupOtherInputs-主体"><span class="nav-number">4.6.3.</span> <span class="nav-text">SetupOtherInputs 主体</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DoCompactionWork的辅助函数"><span class="nav-number">4.7.</span> <span class="nav-text">DoCompactionWork的辅助函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MakeInputIterator"><span class="nav-number">4.7.1.</span> <span class="nav-text">MakeInputIterator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DBImpl-DoCompactionWork"><span class="nav-number">4.8.</span> <span class="nav-text">DBImpl::DoCompactionWork</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2021/04/18/leveldb-compaction/';
          this.page.identifier = '2021/04/18/leveldb-compaction/';
          this.page.title = 'LevelDB 之 Compaction 实现';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
