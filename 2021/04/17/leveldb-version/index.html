<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据库,leveldb," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="在本文中介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。本文拆解自《LevelDB之Compaction》。">
<meta name="keywords" content="数据库,leveldb">
<meta property="og:type" content="article">
<meta property="og:title" content="LevelDB之Version">
<meta property="og:url" content="http://www.calvinneo.com/2021/04/17/leveldb-version/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="在本文中介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。本文拆解自《LevelDB之Compaction》。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/cm.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/manifest_detail.jpeg">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/manifest.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/version_update.jpeg">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/version.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/versionset.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leveldb/compaction/versionset_link.png">
<meta property="og:updated_time" content="2023-08-29T14:29:15.561Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LevelDB之Version">
<meta name="twitter:description" content="在本文中介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。本文拆解自《LevelDB之Compaction》。">
<meta name="twitter:image" content="http://www.calvinneo.com/img/leveldb/compaction/cm.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2021/04/17/leveldb-version/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>LevelDB之Version | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2021/04/17/leveldb-version/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                LevelDB之Version
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-17T23:09:06+08:00">
                2021-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在本文中介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。<br>本文拆解自《LevelDB之Compaction》。</p>
<a id="more"></a>

<p>目录：</p>
<ol>
<li><a href="/2021/04/09/leveldb-memtable/">LevelDB之Memtable实现</a></li>
<li><a href="/2021/04/12/leveldb-sstable/">LevelDB之SSTable实现</a></li>
<li><a href="/2021/04/17/leveldb-version/">LevelDB之Version</a></li>
<li><a href="/2021/04/18/leveldb-compaction/">LevelDB之Compaction</a></li>
<li><a href="/2021/04/24/leveldb-proc/">LevelDB之流程概览</a></li>
</ol>
<h1 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h1><p>需要注意的是，LevelDB是一个单机的数据库，所以实际承载的SSTable文件都位于一台机器上。</p>
<p><img src="/img/leveldb/compaction/cm.png"></p>
<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType &#123;</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>kLogFile：WAL日志文件，文件名数字.log</li>
<li>kDBLockFile：db锁文件，文件名LOCK</li>
<li>kTableFile：SSTable文件，文件名数字.sst</li>
<li>kDescriptorFile：Manifest文件，存储VersionEdit信息，文件名为MANIFEST-数字<br> 对应<code>descriptor_file_</code>这个字段。<br> Manifest文件中维护了所有的SSTable的key范围，层级，以及其他的元信息。</li>
<li>kCurrentFile：记录当前的Manifest文件，文件名为CURRENT</li>
<li>kTempFile：临时文件，db在修复【？】过程中会产生临时文件，文件名为数字.dbtmp</li>
<li>kInfoLogFile：日志文件，文件名为LOG</li>
</ol>
<h1 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h1><p>Memtable 和 log 一一对应。</p>
<h1 id="Version-机制和-Manifest-文件"><a href="#Version-机制和-Manifest-文件" class="headerlink" title="Version 机制和 Manifest 文件"></a>Version 机制和 Manifest 文件</h1><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>LevelDB 每次新生成 SSTable 文件，或者删除 SSTable 文件，都会从一个版本升级成另外一个版本。</p>
<p>LevelDB 采用了增量式的存储方式，用 VersionEdit 记录每一个 Version 对上一个 Version 的变化情况。</p>
<p>Manifest 文件专用于记录版本信息。一个 Manifest 文件中，包含了多条<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">Session Record</a>。一个 Session Record 记录了从上一个版本至该版本的变化情况。每一个 Session Record 对应一个 VersionEdit。<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">其中第一条 Session Record 包含当时LevelDB的全量版本信息</a>，这个应该是通过 <code>WriteSnapshot</code> 来实现的，可以看下面的介绍。</p>
<p>如下展示了 Manifest 文件的结构。</p>
<p><img src="/img/leveldb/compaction/manifest_detail.jpeg"></p>
<p>借助 Manifest 文件，LevelDB 启动时，可以根据一个初始的版本状态，不断地应用后面的 VersionEdit，使得系统的版本信息恢复到最近一次使用的状态。</p>
<p>如下所示，Manifest 中的每个 Entry，即 Session Record 包含：</p>
<ol>
<li>增加的 SSTable<br> kNewFile。比如如果是因为 minor compaction 或者 replay 生成了一个新的 sst file，则记录该信息。</li>
<li>删除的 SSTable<br> kDeletedFile</li>
<li>当前 Compaction 的下标<br> kCompactPointer</li>
<li>日志文件编号<br> kLogNumber</li>
<li>数据库已经持久化数据项中最大的 Sequence Number<br> kLastSequence</li>
</ol>
<p>对应的代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/img/leveldb/compaction/manifest.png"></p>
<p>写 Manifest 的代码应该是 <code>Writer::AddRecord</code>。这是因为一个 Manifest 就是一个 WAL 文件。</p>
<p>读 Manifest 的代码，例如 <code>VersionSet::Recover</code>。</p>
<h2 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h2><p>记录当前的 Manifest 文件名。<br>随着 LevelDB 运行时间的增长，一个 Manifest 中包含的 Session Record 会越来越多，故 LevelDB 在每次启动时都会重新创建一个 Manifest 文件，并将第一条 Session Record 中记录当前 Version 的快照状态。<br>其他过期的 Manifest 文件会在下次启动的 recover 流程中进行删除。<br>LevelDB 通过这种方式，来控制 Manifest 文件的大小，但是数据库本身没有重启，Manifest 还是会一直增长。</p>
<h2 id="Version-机制"><a href="#Version-机制" class="headerlink" title="Version 机制"></a>Version 机制</h2><p>大前提，Compaction 过程是通过独立线程异步并发执行的。因此可能出现压缩前后的新老 SSTable 并存的情况。我们不能立即删除老的 SSTable文件，这可能是因为这个 SSTable 还在被读取，所以要等到老 SSTable 的引用计数为0才行。因此 Version 机制可以用来辨别这些 SSTable 的版本。借助于 Version 机制，也能实现 MVCC。</p>
<p>Version 变更，即升级发生在：</p>
<ol>
<li>完成一次 major compaction 整理内部数据</li>
<li>通过 minor compaction 或者重启阶段的日志重放新生成一个0层文件</li>
</ol>
<p><img src="/img/leveldb/compaction/version_update.jpeg"></p>
<p>如下所示，新版本 New-Version 由 <code>Version</code> 类和 <code>VersionEdit</code> 类来描述。即 <code>VersionEdit</code> 是 New-Version 相对于 Version 的改动。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-<span class="keyword">Version</span> = <span class="keyword">Version</span> + VersionEdit</span><br></pre></td></tr></table></figure>

<p><img src="/img/leveldb/compaction/version.png"></p>
<p>LevelDB 将所有的 Version 置于一个双向链表之中，因此所有的 Version 组成一个名为 VersionSet 的集合。这个集合也代表了当前 DB 的状态，包含了最新的 Version，以及其他正在服务的 Version。<br><img src="/img/leveldb/compaction/versionset.png"></p>
<p>容易概括出下面的对应关系：</p>
<ol>
<li>VersionSet - Manifest</li>
<li>VersionEdit - Session Record</li>
</ol>
<h1 id="Version、VersionEdit-和-VersionSet"><a href="#Version、VersionEdit-和-VersionSet" class="headerlink" title="Version、VersionEdit 和 VersionSet"></a>Version、VersionEdit 和 VersionSet</h1><h2 id="相关类型"><a href="#相关类型" class="headerlink" title="相关类型"></a>相关类型</h2><h3 id="FileMetaData"><a href="#FileMetaData" class="headerlink" title="FileMetaData"></a>FileMetaData</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> refs;</span><br><span class="line">  <span class="keyword">int</span> allowed_seeks;          <span class="comment">// Seeks allowed until compaction</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  <span class="keyword">uint64_t</span> file_size;         <span class="comment">// File size in bytes</span></span><br><span class="line">  InternalKey smallest;       <span class="comment">// Smallest internal key served by table</span></span><br><span class="line">  InternalKey largest;        <span class="comment">// Largest internal key served by table</span></span><br><span class="line"></span><br><span class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h2><p>介绍作为桥梁作用的<code>VersionEdit</code>类，它对应了 Session Record。这个类里面的方法大部分是用来读写里面的私有成员的，所以不再介绍。</p>
<ol>
<li><p><code>std::string comparator_;</code></p>
</li>
<li><p><code>uint64_t next_file_number_;</code>/<code>bool has_next_file_number_;</code>，通过 SetNextFile 设置<br> VersionSet 里面也有类似字段，是一个全局分配器，分配下一个可用的 file number。这个 number 是 SSTable、Manifest 等共用的。详见对应章节。<br> VersionSet 在 LogAndApply 中会调用 VersionEdit::SetNextFile 将自己的 <code>next_file_number_</code> 设置给 VersionEdit。</p>
</li>
<li><p><code>uint64_t log_number_;</code>，通过 SetLogNumber 设置<br> log 文件的 file number，也就是<code>000003.log</code>的这个3。<code>log_number_</code> 表示<a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">小于这个值的Log是可以被删除的</a>。<br> 【Q】这个字段的作用是什么呢？目前来看，在 Recover 的时候会用到。<br> 【Q】为什么 VersionSet 里面也有？其实 VersionSet 里面的才是主要的，VersionEdit 里面的这个字段，是在 LogAndApply 的时候，由 VersionSet 设置过来的。<br> 【Q】这个 number 和版本的关系是什么，是一一对应的么？比如一次 Compaction 之后就要换个 log？</p>
<ul>
<li>在 DBImpl::CompactMemTable 中会更新为 <code>logfile_number_</code>。而后者是在 MakeRoomForWrite 中更新。</li>
<li>在 DB::Open 中会更新。</li>
<li>在 VersionSet::LogAndApply 中会设置，这是在 Recover 场景。</li>
</ul>
</li>
<li><p><code>uint64_t prev_log_number_;</code>/<code>bool has_prev_log_number_;</code><br> 包括 <code>void SetPrevLogNumber(uint64_t num)</code> 这个函数。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">这篇文章</a>说 <code>prev_log_number_</code> 已经废弃了，出于兼容性才保留的。</p>
</li>
<li><p><code>SequenceNumber last_sequence_;</code>/<code>bool has_last_sequence_;</code><br> SSTable 中的最大的 Sequence Number。VersionSet 里面也有个平行的。</p>
</li>
<li><p><code>bool has_comparator_;</code></p>
</li>
<li><p><code>bool has_log_number_;</code><br> 当被调用了 SetNextFile，has_log_number_ 会为 true。<br> 在重启后 Recover 数据库时，在 VersionSet::Recover 中，当调用了 DecodeFrom 后 has_log_number 会为 true。</p>
</li>
<li><p><code>std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</code><br> 主要用于 Major Compaction 的时候选择文件。first 表示每个 level。<br> 【Q】在 <code>Compaction</code> 类和 <code>VersionSet</code> 类里面也有一个这个字段。它们的作用是什么呢？</p>
</li>
<li><p><code>DeletedFileSet deleted_files_;</code></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br></pre></td></tr></table></figure>

<p> pair 存储了 level 和 file。表示将第 level 层中的 file 删除。</p>
</li>
<li><p><code>std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</code><br> <code>FileMetaData</code> 存储了 file number、文件大小，以及文件中最小的 Key 和最大的 Key。</p>
</li>
</ol>
<h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h3 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h3><ol>
<li><p>VersionSet相关<br> 指向这个 Version 所属的 VersionSet，以及双向链表和引用计数。<br> 所以说每个 Version 只能属于一个 VersionSet，这个也是很好理解的。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"><span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br></pre></td></tr></table></figure></li>
<li><p>SSTable相关<br> <code>files_</code> 表示 LevelDB 中每一层中所有的 SSTable 的文件信息。<br> <code>file_to_compact(_level)_</code> 标记下一个要 Compact 的文件以及属于的 Level。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure>

<p> 根据<code>SaveTo</code>函数的<a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">论述</a>，<code>files_[level]</code><strong>是有序的</strong>。</p>
</li>
<li><p>其他字段<br> <code>compaction_score_</code><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">用来计算最迫切需要 Compaction 的 Level</a>，所以可以决定是否需要发起 Major Compaction。这个分数取决于某一层所有 SSTable 的大小。<br> <code>NeedsCompaction</code> 会读取这个字段，计算是否需要根据 Version 的情况来 Compaction，并呈递给 <code>MaybeScheduleCompaction</code>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"><span class="comment">// Score &lt; 1 means compaction is not strictly needed.</span></span><br><span class="line"><span class="keyword">double</span> compaction_score_;</span><br><span class="line"><span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol>
<li><p>PickLevelForMemTableOutput</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key, <span class="keyword">const</span> Slice&amp; largest_user_key)</span></span>;</span><br></pre></td></tr></table></figure>

<p> 给定一个 Memtable 里面的 Key 的范围，返回这个 Memtable 被 Ingest 的话要放到第几层。</p>
</li>
<li><p><code>Compaction* PickCompaction();</code><br> 用来处理 size compaction 和 seek compaction。<br> 这个函数，在“Compaction主函数”这个章节介绍。</p>
</li>
<li><p><code>Compaction* CompactRange(int level, const InternalKey* begin, const InternalKey* end);</code></p>
</li>
</ol>
<h2 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h2><h3 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h3><ol>
<li><code>Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu)</code><br> 这个函数接受一个 VersionEdit，产生一个新的 Version。</li>
<li><code>std::string compact_pointer_[config::kNumLevels];</code><br> 这个字段在 Major Compaction 过程中被用到。表示每个 level 上，下一次 Compaction 需要开始的 key 的位置。它要么是一个空串，要么是一个 InternalKey。<br> 在什么时候被设置呢？从代码上来看，在 VersionSet::Apply 时，会用 edit 中的 <code>compact_pointers_.second</code> 来设置。而 edit 中的是在 SetupOtherInputs 中设置的 largest。<br> 根据<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">文章</a>，这个 <code>compact_pointer_</code> 实际上表示这一层上一次 Compact 时文件的 largest。下一次 Compaction 从这个 key 开始。</li>
<li><code>Status Recover(bool* save_manifest);</code><br> 关于 Recover 机制，我们不在这篇文章中介绍。详见“LevelDB之流程概览”这篇文章。</li>
</ol>
<p>有关 Sequence：</p>
<ol>
<li><code>uint64_t LastSequence() const { return last_sequence_; }</code>，通过<code>SetLastSequence</code>设置。<br> 返回最近的 Sequence Number。这个是在写入记录的时候会使用并且更新。<br> 【Q】VersionEdit 里面也有个平行的，他们之间的关系是什么呢？<ul>
<li>首先 VersionSet 的 <code>last_sequence_</code> 会随着 <code>DBImpl::Write</code> 操作更新。</li>
<li>当需要进行 Compact 的时候，会在 <code>LogAndApply</code> 中赋给 VersionEdit 中的对应字段。而 VersionEdit 的目的，似乎只是持久化这个信息。</li>
</ul>
</li>
</ol>
<p>有关日志：</p>
<ol>
<li><code>prev_log_number_</code>/<code>log_number_</code><br> 【Q】和 VersionEdit 里面同名字段的关系是什么？在 LogAndApply 后，会用 VersionEdit 中的 <code>log_numer_</code> 来更新。</li>
</ol>
<p>有关文件编号：</p>
<ol>
<li><p><code>next_file_number_</code><br> 被下列函数修改。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">    next_file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这个字段用来生成系统中下个文件的编号。<br> 【Q】这里的 file number 指的是 SSTable 的 file number么？<a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">不是</a>，而是<a href="https://www.wandouip.com/t5i49833/" target="_blank" rel="noopener">Manifest 文件、SSTable 文件啥的共用一个编号</a>，这也是为什么一开始 Log 文件是0，Manifest 文件是1，SetNextFile 是2的原因。<br> <code>NewFileNumber</code>调用：</p>
<ul>
<li><code>DB::Open</code> 中产生 log 的编号</li>
<li><code>WriteLevel0Table</code> 中产生 SSTable 的编号</li>
<li><code>OpenCompactionOutputFile</code></li>
<li><code>MakeRoomForWrite</code> 中产生新的 memtable 以及对应的 log 的编号</li>
</ul>
</li>
<li><p><code>manifest_file_number_;</code><br> 表示Manifest文件的编号，主要在Recover时用到。</p>
</li>
</ol>
<p>疑问：</p>
<ol>
<li>VersionSet 和 DBImpl是一一对应的么？<br> 应该是的，DBImpl 持有一个<code>VersionSet*</code>。</li>
</ol>
<h3 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h3><p>在前面已经简单介绍过这个函数的功能了。这个函数主要在下面几个地方用到：</p>
<ol>
<li><code>DB::Open</code><br> 当 DB 启动的时候，可能需要通过 <code>DBImpl::Recover</code> 调用 <code>VersionSet::Recover</code> 从 log 中恢复一部分数据。这些数据会以 VersionEdit 的方式被 Apply。</li>
<li><code>DBImpl::CompactMemTable</code><br> Minor Compaction。在这个过程中，会将 Immutable Memtable 生成 SSTable 文件，然后会将 edit 的 log_number_ 更新为 logfile_number_，也就是从 Immutable Memtable 对应的值更新为 Memtable 对应的值。然后就会调用 LogAndApply。<br> CompactMemTable 在下面的地方调用：<ul>
<li>BackgroundCompaction 中调用 CompactMemTable：这是通常情况，也就是发现有 Immutable Memable 了。</li>
<li>DoCompactionWork：也就是在 Major Compaction 的过程中也要有限处理 Minor Compaction。</li>
</ul>
</li>
<li><code>BackgroundCompaction</code> 的非 manual 模式，这是平凡情况<br> 这种情况只是将某个 SSTable 移动到别的层。</li>
<li><code>BackgroundCompaction</code> 的 manual 模式，这是非平凡情况，也是常见情况<br> 需要归并。</li>
</ol>
<p>函数的流程主要是：</p>
<ol>
<li>将 VersionEdit 应用在 <code>current_</code>，并借助于 <code>VersionSet::Builder</code> 生成一个新的 Version。Builder 类的实现是比较巧妙的，会在稍后来讲解。</li>
<li>调用 <code>Finalize</code> 函数更新 <code>compaction_level_</code> 和 <code>compaction_score_</code>。</li>
<li>更新 Manifest 文件。主要是把 VersionEdit 中的内容 <code>VersionEdit::EncodeTo</code> 到 Manifest 文件里面。</li>
<li>调用 <code>AppendVersion</code> 将新版本添加到 VersionSet 的双向链表中，并且设置新的 <code>current_</code>。</li>
</ol>
<p>下面这里讲解一下源码。<br><code>__attribute__((exclusive_locks_required))</code>表示检查在调用 <code>LogAndApply</code> 函数之前就要持有锁 <code>mu</code>。因此同时只会有一个线程执行 <code>LogAndApply</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">  <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果 VersionEdit 有 log_number_，说明这来自于一个 Recover 过程，要和 VersionSet 的 log_number_ 进行校验：</p>
<ol>
<li>要大于等于 VersionSet 的 log_number_<br> 这是因为在 VersionSet::Recover 时会用一个循环不断地 apply 所有的 VersionEdit。在 apply 之后，会将 edit 的 log_number_ 赋值给自己。而后一个 VersionEdit 的 log_number 肯定是大于等于前一个的。【Q】为什么这里能取等号？是不是和 Major Compaction 有关？</li>
<li>要小于 <code>next_file_number_</code>，因为这是个过去的 log，它的编号肯定小于 <code>next_file_number_</code></li>
</ol>
<p>否则，就用 VersionEdit 的 log_number_ 来设置自己的 log_number_。从 CompactMemTable 可以看到，edit 的 log_number_ 实际等于 logfile_number_，也就是当前使用的 Memtable 对应的 log 的 number。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>把 VersionSet 的 <code>last_sequence_</code> 传给 edit，在对 <code>VersionSet::Builder</code> 的论述中已经推断过这里的作用了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">  Finalize(v);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的 <code>descriptor_file_</code> 就是一个 Manifest 文件。<br>如果此时 <code>descriptor_log_</code> 是 NULL，根据注释，这个对应到首次打开数据库的状态。要新建一个 Manifest 文件，此时<code>DescriptorFileName</code>产生一个 <code>&quot;/MANIFEST-%06llu&quot;</code> 格式的文件名字。<br>通过 <code>WriteSnapshot</code> 把 <code>descriptor_log_</code> 写到新的 Manifest 文件里面，这个实际上就是 Current Version 的快照。<code>WriteSnapshot</code> 里面也会调用 <code>EncodeTo</code> 和 <code>AddRecord</code>。为什么用 <code>WriteSnapshot</code>？回忆之前介绍了 Manifest 文件的构造，里面提到第一条 Session Record 记录了当前数据库的全量数据，就是在这里实现的。<br>【Q】注意，<code>VersionSet::ReuseManifest</code> 也会修改这个 <code>descriptor_log_</code>，有什么影响呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，是把 VersionEdit 中的内容 <code>EncodeTo</code> 到 Manifest 文件里面。这里不是 <code>WriteSnapshot</code> 写快照了，而是写一条 Log。其实 Manifest 文件的格式就是 Log。<br>后面就是一系列写文件的操作，因为不需要加锁，所以看到 LevelDB 故意将它们集中在一起做，并在这之前释放了锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>EncodeTo</code> 将信息按照下面的Tag分类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>AddRecord</code> 将信息编码到文件中，对应的读取函数是 <code>Reader::ReadRecord</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们现在得到了一个新的 Version 即 <code>v</code>，调用 <code>AppendVersion</code> 将它设置为 <code>current_</code>。这个函数还会将 <code>v</code> 添加到 VersionSet 里那个双向链表里面。<br><a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">文章</a>中有疑问这里遇到多线程怎么办，但 LevelDB 中 Compact 只有一条后台线程，并且这里是持有锁的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VersionSet-AppendVersion"><a href="#VersionSet-AppendVersion" class="headerlink" title="VersionSet::AppendVersion"></a>VersionSet::AppendVersion</h3><p>这里 <code>dummy_versions_</code> 是 VersionSet 维护的环状链表头，<code>dummy_versions_.prev_</code> 就是 <code>current_</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::AppendVersion(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以通过<a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">下面的图</a>清晰看出这个链表的结构。<br><img src="/img/leveldb/compaction/versionset_link.png"></p>
<h3 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h3><p>这个类的作用是应用一系列 VersionEdit 得到一个新的 Version。不过感觉大头都已经被 VersionEdit 做掉了啊，这里还需要处理什么呢？主要是几点：</p>
<ol>
<li>当前 Version 到底包含哪些文件，这总不能每次都从 VersionEdit 重新计算吧。</li>
<li>Compact 相关。</li>
</ol>
<p>LevelState 记录了需要被删除的文件的 number，这来自每个 VersionEdit 的 <code>deleted_files_</code>。还记录了需要被添加的文件的信息，这来自 <code>new_files_</code>。FileSet 指定根据 <code>v-&gt;files_[file_number].smallest</code> 排序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;FileMetaData*, BySmallestKey&gt; FileSet;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LevelState</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; deleted_files;</span><br><span class="line">  FileSet* added_files;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>看看主要的成员：</p>
<ol>
<li><code>VersionSet* vset_;</code><br> 在构造时传入的 VersionSet。</li>
<li><code>Version* base_;</code><br> 在构造时传入的，一般为 <code>current_</code>。</li>
<li><code>LevelState levels_[config::kNumLevels];</code><br> LevelState 里面记录了增加和删除的文件。</li>
<li><code>void Apply(VersionEdit* edit)</code><br> 将 <code>edit</code> 里面的变动应用到 <code>current_</code>。例如要加些什么文件，写到 <code>levels_[level].added_files</code> 这个列表里面。但是我们不实际写，而是到 <code>SaveTo</code> 里面再一次性写。<br> 【Q】为什么要这样子呢？原因有2：<ul>
<li><code>v-&gt;files_[level]</code>这个是有序存储的。一起处理可以节约分配空间的开销，并且可以一次性 merge 解决问题。</li>
<li>可以知道哪些文件最后还是被删除了，这样在 MaybeAddFile 添加的时候就可以不添加。</li>
</ul>
</li>
<li><code>void SaveTo(Version* v)</code><br> 注意，从<code>VersionSet::Recover</code>可以看出，Apply 和 SaveTo 并不是一对一的关系。例如我们从一个文件中多个记录里面恢复，那么每读取一个记录就要 Apply 一次，但最后再 SaveTo。</li>
</ol>
<h4 id="VersionSet-Builder-Apply"><a href="#VersionSet-Builder-Apply" class="headerlink" title="VersionSet::Builder::Apply"></a>VersionSet::Builder::Apply</h4><p>这个函数设置诸如 <code>levels_[level].added_files</code> 的字段，表示需要做什么改变。<br>首先将 VersionEdit 记录的 <code>compact_pointers_</code> 应用到 VersionSet。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后把要增加和删除的文件记录到自己的 <code>levels_</code> 字段里面。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在增加文件的时候，需要处理 <code>allowed_seeks</code> 字段。这里的 <code>16384U</code> 有点奇怪，是啥意思？根据注释，我们假设：</p>
<ol>
<li>一次 Seek 耗时 10ms</li>
<li>读写 1MB 耗时 10ms，也就是 IO 速度是 100MB/s</li>
<li>一次 Compaction，假设是 1MB，需要消耗 25MB 的 IO<ol>
<li>需要从这一层读取 1MB</li>
<li>从下一层读取 10-12MB 的数据(boundaries may be misaligned)</li>
<li>写 10-12MB 的数据到下一层</li>
</ol>
</li>
</ol>
<p>这说明 25 次 Seek 的开销等于 1MB 数据的 Compaction 成本，也就是一次 Seek 大概摊还下来是 40KB 数据的压缩成本。我们做一些保留，让 16KB 对应一次 Compaction，也就是允许更多的 Seek 次数。同时，我们将 <code>f-&gt;allowed_seeks</code> 最小值设为100，这样也不会一直 Compaction。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// 16*1024</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】还需要注意的是，在添加文件之前，需要在 deleted_files 中删除对应的 file_number，这是为何？难道同一个文件还可以先被删除，再被添加回来？</p>
<h4 id="VersionSet-Builder-SaveTo"><a href="#VersionSet-Builder-SaveTo" class="headerlink" title="VersionSet::Builder::SaveTo"></a>VersionSet::Builder::SaveTo</h4><p><code>SaveTo</code> 的最终影响是 <code>MaybeAddFile</code>，也就是说将文件添加到 Version 里面。添加到 <code>v-&gt;files_</code> 里面。用一个简单的式子表达，也就是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_-&gt;files_[level] + (levels_[level].added_files - levels_[level].deleted_files) = v-&gt;files_[level]</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  BySmallestKey cmp;</span><br><span class="line">  cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的循环中依次处理每一层的合并。主要内容是：</p>
<ol>
<li>将添加的文件合并到<code>files_</code></li>
<li>删除文件</li>
</ol>
<p>之前介绍过 <code>Version* base_</code> 在构造时传入，一般为 CURRENT，我们就是要对 <code>base_</code> 去应用这些修改，形成一个新的 Version。<br><code>base_iter</code> 用来遍历 <code>base_</code> 中原有的文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">    <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们首先<strong>预留最大空间，避免到时候的频繁动态分配</strong>。但是实际上最终未必用满这个空间，因为 <code>MaybeAddFile</code> 不一定真的添加文件。<br>下面就是插入操作，创建 added_iter，依次遍历要添加的 <code>levels_[level].added_files</code>，这也是之前通过 Apply 统计的所有 VersionEdit 的累计。</p>
<p>下面要做的就是将 <code>base_</code> 和 <code>levels_</code> 里面的文件都添加到 <code>v</code> 中。这是一个归并的过程，分两步：</p>
<ol>
<li>插入原有的 <code>base_</code> 里面的文件，这些文件要小于等于 <code>added_file</code><br> 我们通过 <code>std::upper_bound</code> 找到第一个大于 <code>added_file</code> 的位置 <code>bpos</code>。那么就先将 bpos 之前的 base_ 中的文件先插入。<br> 用 <code>MaybeAddFile</code> 插入，因为这些文件可能已经被标记删除。</li>
<li>插入 <code>added_file</code></li>
<li>自增 added_iter，继续处理下一个文件 </li>
</ol>
<p>总而言之，我们先初始化了 <code>bpos</code>，但是循环中自增的却是 <code>base_iter</code>，<code>for(A;B;C)</code>里面 A 和 C 的主体不一样，挺新鲜的。</p>
<p><strong>这么做的好处是什么</strong>？我认为是减少了比较的次数，从 O(n) 到了 O(logn)。因为这里是<code>BytewiseComparator</code>，是两个Slice之间的比较，所以开销还是比较大的，这是值得学习的一个 Best Practice。特别是我们 merge delta 层和 stable 层的时候，因为 delta 层相对较少，所以往往可以使用这种办法快速跳过大块的 stable 层的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">      <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">               <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">           base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MaybeAddFile(v, level, added_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add remaining base files</span></span><br><span class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">      MaybeAddFile(v, level, *base_iter);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在 Debug 的状态下，会去检查除 Level0 之外的层有没有重叠。检查方法也很简单，就是看后一个文件的 smallest 是不是一定<strong>严格</strong>大于前一个文件的 largest。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">        <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                       prev_end.DebugString().c_str(),</span><br><span class="line">                       this_begin.DebugString().c_str());</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VersionSet-Builder-MaybeAddFile"><a href="#VersionSet-Builder-MaybeAddFile" class="headerlink" title="VersionSet::Builder::MaybeAddFile"></a>VersionSet::Builder::MaybeAddFile</h4><p>如果后续的 VersionEdit 中又删除了这个 file，那么在最终 SaveTo 的时候，就可以不添加了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;</span><br><span class="line">      <span class="comment">// Must not overlap</span></span><br><span class="line">      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                  f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;refs++;</span><br><span class="line">    files-&gt;push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="VersionSet-Builder-析构函数"><a href="#VersionSet-Builder-析构函数" class="headerlink" title="VersionSet::Builder 析构函数"></a>VersionSet::Builder 析构函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">~Builder() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">const</span> FileSet* added = levels_[level].added_files;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; to_unref;</span><br><span class="line">    to_unref.reserve(added-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (FileSet::const_iterator it = added-&gt;begin();</span><br><span class="line">        it != added-&gt;end(); ++it) &#123;</span><br><span class="line">      to_unref.push_back(*it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> added;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; to_unref.size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = to_unref[i];</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  base_-&gt;Unref();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VersionSet-Finalize"><a href="#VersionSet-Finalize" class="headerlink" title="VersionSet::Finalize"></a>VersionSet::Finalize</h3><p>这个函数在新 Version 产生后，处理一些额外的工作，主要是计算 Compaction 相关的东西。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果 LevelDB 的第0层超过 kL0_CompactionTrigger 个文件就会触发 Compaction，如果超过 kL0_SlowdownWritesTrigger 就会 slow down write。<strong>针对第0层的特殊情况，这里使用文件数量而不是大小来计算 Compaction Score</strong>，注释里面列了两个原因：</p>
<ol>
<li>允许更大的写 buffer，从而减少 Level0 Compaction 的数量。<br> 这里的写 buffer 应该是 <code>options_.write_buffer_size</code> 这个东西。这个阈值控制 Memtable 何时转换成 Immutable Memtable，以及在 Recover 的时候何时直接 dump 成 SSTable。<br> 佶屈聱牙，实际上的意思是，如果写 buffer 太大，又用固定的 size 限制死了的话，可能 Level0 的文件数量会很少，比如就1个，这样会导致频繁的 Level0 Compaction。</li>
<li>Level0 的文件每次读取都会被 Merge。我们不希望有很多个小文件(perhaps because of a small write-buffer setting, or very high compression ratios, or lots of overwrites/deletions)。<br> 如果写 buffer 很小，这样会导致更多的 Level0 文件。因为 Level0 的文件是 overlap 的，所以如果数量过多，每次查询需要 Seek 的文件数量就越多。这样造成了较大的读放大。</li>
</ol>
<p>总结一下，L0 不希望有一个单独的大文件，也不希望有很多个小文件。所以它选择直接控制文件数量。另外，还要考虑读。我们不希望 Compaction 挤占读带宽，所以当 Compaction 很大的时候，会 slow down write 或者 write stall。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      score = v-&gt;files_[level].size() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger); <span class="comment">// ==4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于第1层以下的层，<strong>计算文件总大小</strong>，而不是文件数量了。<code>MaxBytesForLevel</code> 的大概意思就是 Level1 总大小是 10M，下面每一层翻10倍。如果现在这一层的文件总大小大于 <code>MaxBytesForLevel</code>，则它就具有一个大于 1 的值，从而导致可能的 Compaction。我们会计算整个 Version 中 score 最大的 Level，将它计入 compaction_score_ 中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h3><p>这个函数计算每一层的最大大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>将自己从链表中移除。<br>对于自己管理的所有文件，引用计数减一。【Q】这边不搞个原子操作么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="LevelDB对MVCC的实现总结"><a href="#LevelDB对MVCC的实现总结" class="headerlink" title="LevelDB对MVCC的实现总结"></a>LevelDB对MVCC的实现总结</h2><h3 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h3><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">文章</a>中论述了一次版本升级的过程，但我会批注一下具体实现的函数和逻辑</p>
<ol>
<li>新建一个 Session Record，记录状态变更信息</li>
<li>讨论版本升级原因<ol>
<li>Minor Compaction 或者日志 replay<br> 在 Session Record 中记录新增的文件信息、最新的 journal 编号、数据库 Sequence Number 以及下一个可用的文件编号。</li>
<li>Major Compaction<br> 在 Session Record 中记录新增、删除的文件信息、下一个可用的文件编号即可。</li>
</ol>
</li>
<li>通过 VersionEdit 生成新版本<br> 相较于旧的版本信息，新的版本信息更改的内容为：<ol>
<li>每一层的文件信息：在 <code>VersionSet::Builder::Apply</code> 中。</li>
<li>每一层的计分信息：在 <code>VersionSet::Finalize</code> 中。</li>
</ol>
</li>
<li>将 Session Record 持久化<br> 在 <code>VersionSet::Builder::SaveTo</code> 中。</li>
<li>讨论是否是第一条 Session Record<br> 在 LogAndApply 的 Finalize 调用之后的部分<ol>
<li>是<br> 新建一个 Manifest 文件，并将完整的版本信息全部记录进 Session Record 作为该 Manifest 的基础状态写入，同时更改 Current 文件，将其指向新建的 Manifest。</li>
<li>不是<br> 将该条 Session Record 进行序列化后直接作为一条记录写入即可。</li>
</ol>
</li>
<li>将当前的 Version 设置为刚创建的 Version<br> 这个会修改 <code>current_</code> 的指向。这个操作应该是原子的（不然最新版本岂不是会不一致么）实际上也在 <code>mutex_</code> 的保护下。<br> 在 LogAndApply 对 <code>AppendVersion</code> 的调用中。</li>
</ol>
<h1 id="一些功能性函数"><a href="#一些功能性函数" class="headerlink" title="一些功能性函数"></a>一些功能性函数</h1><h2 id="插入-SST-文件"><a href="#插入-SST-文件" class="headerlink" title="插入 SST 文件"></a>插入 SST 文件</h2><p>主要在 Version::PickLevelForMemTableOutput 逻辑中。</p>
<h3 id="OverlapInLevel"><a href="#OverlapInLevel" class="headerlink" title="OverlapInLevel"></a>OverlapInLevel</h3><p>先介绍辅助函数 <code>OverlapInLevel</code>，作用是判断范围 <code>[smallest_user_key,largest_user_key]</code> 和 level 中的文件有没有 Overlap。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Version::OverlapInLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span><br><span class="line">                             <span class="keyword">const</span> Slice* largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                               smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SomeFileOverlapsRange"><a href="#SomeFileOverlapsRange" class="headerlink" title="SomeFileOverlapsRange"></a>SomeFileOverlapsRange</h3><p>SomeFileOverlapsRange 是 <code>OverlapInLevel</code> 的辅助函数。返回 <code>files</code> 中有没有在范围 <code>[smallest_user_key,largest_user_key]</code> 中的 key。<br><code>disjoint_sorted_files</code> 表示传入的 <code>files</code> 里面的 key 是不是不 Overlap 的。Level0 会 Overlap，其他不会。<br><code>AfterFile</code> 和 <code>BeforeFile</code> 都比较 FileMetaData 里面的 <code>largest</code>/<code>smallest</code> 的 <code>user_key()</code> 字段。复习一下，<code>largest</code> 的类型是 InternalKey，由 User Key，Sequence Number 和 Value Type 组成。AfterFile 表示传入的 key 比传入的 f 中最大的 key 还大，disjoint_sorted_files 表示传入的 key 比传入的 f 中最小的 key 还小。<br>普通情况，对于一个文件 <code>f</code>，如果 <code>smallest_user_key</code> 大于该文件中的最大值，或者 <code>largest_user_key</code> 小于最小值，那么认为是不 Overlap 的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SomeFileOverlapsRange</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> disjoint_sorted_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = icmp.user_comparator();</span><br><span class="line">  <span class="keyword">if</span> (!disjoint_sorted_files) &#123;</span><br><span class="line">    <span class="comment">// Need to check against all files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      <span class="keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||</span><br><span class="line">          BeforeFile(ucmp, largest_user_key, f)) &#123;</span><br><span class="line">        <span class="comment">// No overlap</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Overlap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果是不相交的文件，就可以基于 <code>FindFile</code> 对 <code>files</code> 集合二分查找。<strong>所以我们看到，在某一个 Level 找 SSTable 的时候是可以二分的</strong>。<br>可以思考下用什么做二分的 key 呢？答案是每个 file 的 largest。我们要找到第一个 largest 大于等于 <code>smallest_user_key</code> 的文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Binary search over file list</span></span><br><span class="line">  <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (smallest_user_key != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Find the earliest possible internal key for smallest_user_key</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">small_key</span><span class="params">(*smallest_user_key, kMaxSequenceNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">                          kValueTypeForSeek)</span></span>;</span><br><span class="line">    index = FindFile(icmp, files, small_key.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= files.size()) &#123;</span><br><span class="line">    <span class="comment">// beginning of range is after all files, so no overlap.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>二分法找到<strong>可能存在</strong>的文件 <code>files[index]</code> 后，不要忘了在判断下这个文件<strong>实际有没有 overlap</strong>。这是二分法的基本规则。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FindFile"><a href="#FindFile" class="headerlink" title="FindFile"></a>FindFile</h3><p>用来二分某个有序的 files 集合，从中找到可能存在 key 的文件。<br>它在写入、读取的过程中都会被用到。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindFile</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files, <span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = files.size();</span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> FileMetaData* f = files[mid];</span><br><span class="line">    <span class="keyword">if</span> (icmp.InternalKeyComparator::Compare(f-&gt;largest.Encode(), key) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at "mid.largest" is &lt; "target".  Therefore all</span></span><br><span class="line">      <span class="comment">// files at or before "mid" are uninteresting.</span></span><br><span class="line">      left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at "mid.largest" is &gt;= "target".  Therefore all files</span></span><br><span class="line">      <span class="comment">// after "mid" are uninteresting.</span></span><br><span class="line">      right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span><br><span class="line">                                        <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>首先判断要加入的文件的 <code>[smallest_user_key,largest_user_key]</code> 和 Level0 有没有交叠。如果有交叠，就进不了这个 if，直接放到第一层，等后面 Major Compaction 了。<br>如果没有交叠，尝试能否将它下放到 <code>config::kMaxMemCompactLevel</code> 之前的层。【Q】为什么要设置上限 <code>kMaxMemCompactLevel</code> 呢？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为什么会有这个？下面讲。</span></span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断level-2层情况的分支详解"><a href="#判断level-2层情况的分支详解" class="headerlink" title="判断level + 2层情况的分支详解"></a>判断level + 2层情况的分支详解</h3><p>这里需要着重讲解一下 <code>level + 2 &lt; config::kNumLevels</code> 这个分支的含义。</p>
<p>作为普通人，我觉得判断完 <code>OverlapInLevel(level + 1,...</code> 就可以直接 <code>level++</code> 了啊，但是大佬肯定是不平凡的。<br>大佬觉得在把文件放到 level + 1 层前要先打住，看看 level + 2 层是什么情况，也就对应到下面的代码。我们要计算所有重叠的文件的总大小，如果这个大小超过了阈值，那么就不把这个 SSTable 进行下放。<br>这是防止 level + 1 和 level + 2 的重叠范围太大，导致这两层进行 Compaction 时涉及的 SSTable 过多，耗时过长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickLevelForMemTableOutput中的片段代码</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>于是，先要用 <code>GetOverlappingInputs</code> 这个函数，计算 level + 2 层中到底有哪些文件和 <code>[smallest_user_key,largest_user_key]</code> 有交叠，这些文件会放到 <code>overlaps</code> 里面。然后用 <code>TotalFileSize</code> 对这些重叠的文件的 <code>FileMetaData::file_size</code> 字段求和，得到总大小。<br>然后和 <code>MaxGrandParentOverlapBytes</code> 返回的阈值进行比较，如果大于这个阈值，就跳出循环，不再往下放了。</p>
<h3 id="GetOverlappingInputs-MaxGrandParentOverlapBytes"><a href="#GetOverlappingInputs-MaxGrandParentOverlapBytes" class="headerlink" title="GetOverlappingInputs/MaxGrandParentOverlapBytes"></a>GetOverlappingInputs/MaxGrandParentOverlapBytes</h3><p><code>GetOverlappingInputs</code> 的目标是找到 level 中和 <code>[begin,end]</code> 重叠的所有文件，并放到 <code>inputs</code> 里面。这个函数对 Level0 有特殊的处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="keyword">void</span> Version::GetOverlappingInputs(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span><br><span class="line">                                   <span class="keyword">const</span> InternalKey* end,</span><br><span class="line">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs) &#123;</span><br></pre></td></tr></table></figure>

<p><code>user_begin</code> 和 <code>user_end</code> 是从 InternalKey 中提取出的 user key。如果传入 nullptr，表示在比较时 <code>begin</code> 永远小于任何 key。<br>【Q】这里为什么去找的 user key 而不是 InternalKey 呢？貌似很多地方都是找 user key。在<a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">这篇文章</a>中指出一个很容易注意到的性质，就是除了 Level0，每一层 Level 都是有序的。进一步地，由于 LevelDB 使用 leveled 策略(LCS)，即强调一个 key 在每一层至多只有1条记录，不存在冗余记录。【Q】但在<a href="/2021/04/18/leveldb-compaction/">LevelDB之Compaction</a>中，AddBoundaryInputs 的出现似乎告诉我们还是会存在重复的 user key 在同一层上的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; config::kNumLevels);</span><br><span class="line">  inputs-&gt;clear();</span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (begin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = begin-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = end-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>默认遍历这一层的所有的文件。前面两个 if 分别处理文件和 range 完全不重叠的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>else 处理有重叠的情况。我们把这个文件加入到 <code>inputs</code> 里面作为结果返回。对于 <code>PickLevelForMemTableOutput</code> 的逻辑而言，这里就到此为止了。</p>
<p>但是 <code>GetOverlappingInputs</code> 这个函数还会在 <code>CompactRange</code>、<code>SetupOtherInputs</code> 这些函数中用到。此时，需要处理 Level0 的逻辑。<br><strong>且慢，我们已经逐文件遍历了啊，还会有什么问题呢？</strong><br>在<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">这篇文章</a>中，详细解释了原因。这因为认为 Level1 的文件是比 Level0 要旧的，所以<strong>如果要把 Level0 中的某个文件 <code>f</code> 移动到 Level1 中，则要把 Level0 中所有和 <code>f</code> Overlap 的文件都放到 Level1 里面</strong>。这样，实际上保证了如果我有一个 Key 在 Level0 里面，那么 inputs 包含了所有包含这个 Key 的文件。<br>所以这里我们要修改遍历的区间。也就是说，当检查到 <code>user_begin</code> 在文件 <code>[file_start,file_limit]</code> 中后，需要将 <code>user_begin</code> 调整为文件的开头 <code>file_start</code>，从而扫描和整个文件 <code>f</code> 重叠的所有文件。对 <code>user_end</code>也是同理的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的存在，也回答了后续在 Compaction 过程中的一些疑问：</p>
<ol>
<li>在 Level0 往 Level1 归并的时候，其实也应该看到这个过程。事实上 <code>PickCompaction</code> 的代码实现中也能看到在最后有个 <code>if (level == 0)</code> 的判断。</li>
<li><code>IsTrivialMove</code> 为什么 Level 层有两个的时候，不能简单把其中一个文件移动到下层。<br> 因为可能另一个文件的和下层 key 有重叠。</li>
</ol>
<h2 id="重启后-Recover"><a href="#重启后-Recover" class="headerlink" title="重启后 Recover"></a>重启后 Recover</h2><h1 id="Snapshot机制"><a href="#Snapshot机制" class="headerlink" title="Snapshot机制"></a>Snapshot机制</h1><h2 id="Snapshot-对-Compaction-的影响"><a href="#Snapshot-对-Compaction-的影响" class="headerlink" title="Snapshot 对 Compaction 的影响"></a>Snapshot 对 Compaction 的影响</h2><p>这里说明 Snapshot 对 Compaction 的影响：导致同一个 user key 的不同的 Sequence Number 版本存在多个。</p>
<p>Snapshot 实际上就是某个特定的 Sequence Number。<br>【Q】Sequence Number 是全局递增的么？应该是这样的，在 Put 和 Get 的实现中，看到的都是读取的<code>VersionSet::LastSequence()</code>这个。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-version/</a></li>
<li><a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">https://www.ravenxrz.ink/archives/1ba074b9.html</a><br> 介绍了Snapshot</li>
<li><a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-version</a><br> 解释了Version的实现</li>
<li><a href="http://www.petermao.com/leveldb/leveldb-8-snapshot.html" target="_blank" rel="noopener">http://www.petermao.com/leveldb/leveldb-8-snapshot.html</a><br> 介绍了snapshot机制</li>
<li><a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60188395</a><br> 带Snapshot的Compaction，以及为什么会导致Issue 320的问题</li>
<li><a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360345923</a><br> 也讲解了AddBoundaryInputs的来源，并且指出了快照会导致Issue 320的问题。</li>
<li><a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35343043</a><br> 讲解VersionSet/VersionEdit里面出现的各种文件编号</li>
<li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a><br> 版本控制相关</li>
<li><a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-manifest/</a><br> 有关Manifest文件的深入讨论</li>
<li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li>
<li><a href="https://draveness.me/database-concurrency-control/" target="_blank" rel="noopener">https://draveness.me/database-concurrency-control/</a><br> 同样介绍了MVCC，包括乐观锁和悲观锁机制</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/leveldb/" rel="tag"># leveldb</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/04/12/leveldb-sstable/" rel="next" title="LevelDB之SSTable实现">
                <i class="fa fa-chevron-left"></i> LevelDB之SSTable实现
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/04/18/leveldb-compaction/" rel="prev" title="LevelDB之Compaction实现">
                LevelDB之Compaction实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">236</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#常见文件"><span class="nav-number">1.</span> <span class="nav-text">常见文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">1.1.</span> <span class="nav-text">文件类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WAL"><span class="nav-number">2.</span> <span class="nav-text">WAL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Version-机制和-Manifest-文件"><span class="nav-number">3.</span> <span class="nav-text">Version 机制和 Manifest 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Manifest"><span class="nav-number">3.1.</span> <span class="nav-text">Manifest</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Current"><span class="nav-number">3.2.</span> <span class="nav-text">Current</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version-机制"><span class="nav-number">3.3.</span> <span class="nav-text">Version 机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Version、VersionEdit-和-VersionSet"><span class="nav-number">4.</span> <span class="nav-text">Version、VersionEdit 和 VersionSet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关类型"><span class="nav-number">4.1.</span> <span class="nav-text">相关类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#FileMetaData"><span class="nav-number">4.1.1.</span> <span class="nav-text">FileMetaData</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VersionEdit"><span class="nav-number">4.2.</span> <span class="nav-text">VersionEdit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Version"><span class="nav-number">4.3.</span> <span class="nav-text">Version</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#相关字段"><span class="nav-number">4.3.1.</span> <span class="nav-text">相关字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关函数"><span class="nav-number">4.3.2.</span> <span class="nav-text">相关函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VersionSet"><span class="nav-number">4.4.</span> <span class="nav-text">VersionSet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员介绍"><span class="nav-number">4.4.1.</span> <span class="nav-text">成员介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-LogAndApply"><span class="nav-number">4.4.2.</span> <span class="nav-text">VersionSet::LogAndApply</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-AppendVersion"><span class="nav-number">4.4.3.</span> <span class="nav-text">VersionSet::AppendVersion</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-Builder"><span class="nav-number">4.4.4.</span> <span class="nav-text">VersionSet::Builder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-Apply"><span class="nav-number">4.4.4.1.</span> <span class="nav-text">VersionSet::Builder::Apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-SaveTo"><span class="nav-number">4.4.4.2.</span> <span class="nav-text">VersionSet::Builder::SaveTo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-MaybeAddFile"><span class="nav-number">4.4.4.3.</span> <span class="nav-text">VersionSet::Builder::MaybeAddFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#VersionSet-Builder-析构函数"><span class="nav-number">4.4.4.4.</span> <span class="nav-text">VersionSet::Builder 析构函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VersionSet-Finalize"><span class="nav-number">4.4.5.</span> <span class="nav-text">VersionSet::Finalize</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MaxBytesForLevel"><span class="nav-number">4.4.6.</span> <span class="nav-text">MaxBytesForLevel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#析构函数"><span class="nav-number">4.4.7.</span> <span class="nav-text">析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LevelDB对MVCC的实现总结"><span class="nav-number">4.5.</span> <span class="nav-text">LevelDB对MVCC的实现总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#版本升级"><span class="nav-number">4.5.1.</span> <span class="nav-text">版本升级</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些功能性函数"><span class="nav-number">5.</span> <span class="nav-text">一些功能性函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#插入-SST-文件"><span class="nav-number">5.1.</span> <span class="nav-text">插入 SST 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OverlapInLevel"><span class="nav-number">5.1.1.</span> <span class="nav-text">OverlapInLevel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SomeFileOverlapsRange"><span class="nav-number">5.1.2.</span> <span class="nav-text">SomeFileOverlapsRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FindFile"><span class="nav-number">5.1.3.</span> <span class="nav-text">FindFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主流程"><span class="nav-number">5.1.4.</span> <span class="nav-text">主流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断level-2层情况的分支详解"><span class="nav-number">5.1.5.</span> <span class="nav-text">判断level + 2层情况的分支详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GetOverlappingInputs-MaxGrandParentOverlapBytes"><span class="nav-number">5.1.6.</span> <span class="nav-text">GetOverlappingInputs/MaxGrandParentOverlapBytes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重启后-Recover"><span class="nav-number">5.2.</span> <span class="nav-text">重启后 Recover</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Snapshot机制"><span class="nav-number">6.</span> <span class="nav-text">Snapshot机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Snapshot-对-Compaction-的影响"><span class="nav-number">6.1.</span> <span class="nav-text">Snapshot 对 Compaction 的影响</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">7.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2021/04/17/leveldb-version/';
          this.page.identifier = '2021/04/17/leveldb-version/';
          this.page.title = 'LevelDB之Version';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
