<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据库,redis," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Redis持久化机制包括AOF和RDB两种：  RDB保存二进制形式的数据库快照。 AOF以协议文本的方式，记录数据库写入的指令。  本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。作为Redis源码分析的系列文章，本文使用的版本和Redis底层对象实现原理分析、Redis Sentinel实现原理分析等文章是相同的。">
<meta name="keywords" content="数据库,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis持久化机制实现">
<meta property="og:url" content="http://www.calvinneo.com/2021/03/13/redis-persist/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="Redis持久化机制包括AOF和RDB两种：  RDB保存二进制形式的数据库快照。 AOF以协议文本的方式，记录数据库写入的指令。  本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。作为Redis源码分析的系列文章，本文使用的版本和Redis底层对象实现原理分析、Redis Sentinel实现原理分析等文章是相同的。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-08-18T07:28:41.685Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis持久化机制实现">
<meta name="twitter:description" content="Redis持久化机制包括AOF和RDB两种：  RDB保存二进制形式的数据库快照。 AOF以协议文本的方式，记录数据库写入的指令。  本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。作为Redis源码分析的系列文章，本文使用的版本和Redis底层对象实现原理分析、Redis Sentinel实现原理分析等文章是相同的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2021/03/13/redis-persist/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>Redis持久化机制实现 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2021/03/13/redis-persist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis持久化机制实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-13T19:20:33+08:00">
                2021-03-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Redis持久化机制包括AOF和RDB两种：</p>
<ol>
<li>RDB保存二进制形式的数据库快照。</li>
<li>AOF以协议文本的方式，记录数据库写入的指令。</li>
</ol>
<p>本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。<br>作为Redis源码分析的系列文章，本文使用的版本和<a href="/2018/07/23/redis_learn_object/">Redis底层对象实现原理分析</a>、<a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a>等文章是相同的。</p>
<a id="more"></a>

<h1 id="RIO"><a href="#RIO" class="headerlink" title="RIO"></a>RIO</h1><p><code>rioInitWithFile</code>从<code>FILE</code>创建一个<code>rio</code>对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解释一下剩下来的两个参数：</p>
<ol>
<li><code>autosync</code><br> 表示在写入<code>autosync</code>个字节之后，就进行<code>fsync</code>。<br> 可以通过<code>rioSetAutoSync</code>函数进行设置。</li>
</ol>
<h1 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h1><p>Redis将耗时的io操作放到后台的线程来执行。因此叫做background io。</p>
<h2 id="创建一个io任务"><a href="#创建一个io任务" class="headerlink" title="创建一个io任务"></a>创建一个io任务</h2><p>可以将下列的任务给bio做</p>
<ol>
<li><code>BIO_CLOSE_FILE</code><br> 等于延迟了的<code>close(2)</code></li>
<li><code>BIO_AOF_FSYNC</code><br> 等于延迟了的AOF fsync</li>
<li><code>BIO_LAZY_FREE</code><br> 等于延迟了的内存释放<br>对于每一种类型，维护一个任务队列<code>bio_jobs[type]</code>，一个互斥量<code>bio_jobs[type]</code>和一个条件变量<code>bio_newjob_cond[type])</code>。<br>创建io任务很简单，首先获得对应任务类型的锁，然后将任务<code>job</code>加到对应列表<code>bio_jobs[type]</code>的尾部，然后通知条件变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h2><p>从<code>bioInit</code>里面可以看到，这个<code>void *arg</code>，实际上传入的是int类型的<code>type</code>。Redis会为每一种任务创建一个线程专门来处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bioProcessBackgroundJobs</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> type = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) arg;</span><br><span class="line">    <span class="keyword">sigset_t</span> sigset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the type is within the right interval. */</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= BIO_NUM_OPS) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Warning: bio thread started with wrong type %lu"</span>,type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BIO_CLOSE_FILE:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_close_file"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_AOF_FSYNC:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_aof_fsync"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_LAZY_FREE:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_lazy_free"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这个函数接受一个字符串，类似”0,2,3”, “0,2-3”, “0-20:2”这样。表示设置对某些CPU的亲和性。<br>此外，还需要让线程可以异步终止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redisSetCpuAffinity(server.bio_cpulist);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the thread killable at any time, so that bioKillThreads()</span></span><br><span class="line"><span class="comment"> * can work reliably. */</span></span><br><span class="line">pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="literal">NULL</span>);</span><br><span class="line">pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>下面是处理信号机制，在这里面需要对<code>bio_mutex[type]</code>加锁的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line"><span class="comment">/* Block SIGALRM so we are sure that only the main thread will</span></span><br><span class="line"><span class="comment"> * receive the watchdog signal. */</span></span><br><span class="line">sigemptyset(&amp;sigset);</span><br><span class="line">sigaddset(&amp;sigset, SIGALRM);</span><br><span class="line"><span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Warning: can't mask SIGALRM in bio.c thread: %s"</span>, strerror(errno));</span><br></pre></td></tr></table></figure>

<p>下面的循环是一个经典的生产者消费者模型，我们这个函数是消费者。因此，如果我们检查到自己的队列是空的，那么就在条件变量<code>bio_newjob_cond[type]</code>上面等待，我们还需要同时传入<code>bio_mutex[type]</code>，因为条件变量的实现需要对这个mutex加锁或者解锁。如果说队列不是空的，就<strong>读取</strong>队头，<strong>但是不实际pop</strong>，并且解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The loop always starts with the lock hold. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(bio_jobs[type]) == <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Pop the job from the queue. */</span></span><br><span class="line">    ln = listFirst(bio_jobs[type]);</span><br><span class="line">    job = ln-&gt;value;</span><br><span class="line">    <span class="comment">/* It is now possible to unlock the background system as we know have</span></span><br><span class="line"><span class="comment">     * a stand alone job structure to process.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br></pre></td></tr></table></figure>

<p>下面就是根据任务类型，去做相应的工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process the job accordingly to its type. */</span></span><br><span class="line"><span class="keyword">if</span> (type == BIO_CLOSE_FILE) &#123;</span><br><span class="line">    close((<span class="keyword">long</span>)job-&gt;arg1);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_AOF_FSYNC) &#123;</span><br><span class="line">    redis_fsync((<span class="keyword">long</span>)job-&gt;arg1);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">    <span class="comment">/* What we free changes depending on what arguments are set:</span></span><br><span class="line"><span class="comment">     * arg1 -&gt; free the object at pointer.</span></span><br><span class="line"><span class="comment">     * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span></span><br><span class="line"><span class="comment">     * only arg3 -&gt; free the skiplist. */</span></span><br><span class="line">    <span class="keyword">if</span> (job-&gt;arg1)</span><br><span class="line">        lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">        lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg3)</span><br><span class="line">        lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Wrong job type in bioProcessBackgroundJobs()."</span>);</span><br><span class="line">&#125;</span><br><span class="line">zfree(job);</span><br></pre></td></tr></table></figure>

<p>等我们处理完了，再把对应的节点pop出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Lock again before reiterating the loop, if there are no longer</span></span><br><span class="line"><span class="comment">         * jobs to process we'll block again in pthread_cond_wait(). */</span></span><br><span class="line">        pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">        listDelNode(bio_jobs[type],ln);</span><br><span class="line">        bio_pending[type]--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unblock threads blocked on bioWaitStepOfType() if any. */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;bio_step_cond[type]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB机制的调用链（从下到上）如下所示：</p>
<ol>
<li><code>startSaving</code><ol>
<li><code>rdbSave</code><ol>
<li><code>flushAllDataAndResetRDB</code><ol>
<li><code>flushallCommand</code><br> <code>FLUSHALL</code>指令</li>
</ol>
</li>
<li><code>saveCommand</code><br> <code>SAVE</code>指令</li>
<li><code>rdbSaveBackground</code><ol>
<li><code>bgsaveCommand</code><br> <code>BGSAVE</code>指令</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="rdbSave"><a href="#rdbSave" class="headerlink" title="rdbSave"></a>rdbSave</h2><p>观察函数签名，将一个结构<code>rsi</code>存到文件<code>filename</code>里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span></span></span><br></pre></td></tr></table></figure>

<p>首先是尝试创建临时的rdb文件，这里先创建临时文件，可能是为了防止RDB过程执行到一半宕掉了，导致写的RDB文件不全或者有问题。这样等到确定成功再改名会好一点？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</span><br></pre></td></tr></table></figure>

<p>如果文件创建失败，会产生错误日志</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"Failed opening the RDB file %s (in server root dir %s) "</span></span><br><span class="line">    <span class="string">"for saving: %s"</span>,</span><br><span class="line">    filename,</span><br><span class="line">    cwdp ? cwdp : <span class="string">"unknown"</span>,</span><br><span class="line">    strerror(errno));</span><br></pre></td></tr></table></figure>

<p>下面就是真正的dump过程。首先创建一个rio对象rdb，并且调用函数<code>startSaving</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">startSaving(RDBFLAGS_NONE);</span><br></pre></td></tr></table></figure>

<p>这个函数根据传入的<code>rdbflags</code>，向Redis发送事件。有关事件模块的内容，我们不在这里进行论述。需要注意，函数中额外检查了pid，从而确定是同步RDB还是异步RDB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSaving</span><span class="params">(<span class="keyword">int</span> rdbflags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Fire the persistence modules end event. */</span></span><br><span class="line">    <span class="keyword">int</span> subevent;</span><br><span class="line">    <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE)</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getpid()!=server.pid)</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;</span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的<code>rdbflags</code>有下面的取值</p>
<ol>
<li><code>RDBFLAGS_NONE</code><br> 在<code>rdbSave</code>中调用</li>
<li><code>RDBFLAGS_AOF_PREAMBLE</code><br> 是否用于AOF机制</li>
<li><code>RDBFLAGS_REPLICATION</code><br> 是否用于主从复制</li>
<li><code>RDBFLAGS_ALLOW_DUP</code><br> 这是一个选项</li>
</ol>
<p>如果开启了<code>rdb_save_incremental_fsync</code>增量写盘，就设置一下rio的autosync字段，<code>REDIS_AUTOSYNC_BYTES</code>默认是32MB。容易看出，写32MB才刷盘，如果此时系统宕机，Redis的持久性是得不到保障的，这个在我们对InnoDB的介绍中也出现过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">    rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br></pre></td></tr></table></figure>

<p>下面是核心逻辑<code>rdbSaveRio</code>，我们在后面专门讨论</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">    errno = error;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面执行fflush，将C库缓冲区写到内核缓冲区，再调用fsync强制落盘。由于RDB类似于写checkpoint而不是写日志，所以这边写完直接刷盘，不需要统计autosync。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></span><br><span class="line"><span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure>

<p>下面调用<code>rename</code>转换成正式的名字，调用<code>stopSaving(1)</code>发送成功事件。如果rename失败，就发送失败事件，并且调用<code>unlink</code>删除临时文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(...);</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"DB saved on disk"</span>);</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br></pre></td></tr></table></figure>

<h2 id="rdbSaveRio"><a href="#rdbSaveRio" class="headerlink" title="rdbSaveRio"></a>rdbSaveRio</h2><p>首先看一下<code>dump.rdb</code>的内容，他通常位于redis的安装目录下。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">REDIS0006</span>þ^@^@^<span class="keyword">Ac</span>À^<span class="keyword">B</span>^@^<span class="keyword">Ab</span>À^<span class="keyword">A</span>^@^<span class="keyword">Aa</span>À^@ÿ&lt;<span class="keyword">92</span>&gt;?<span class="keyword">6</span>Ä<span class="keyword">x</span>^<span class="keyword">B</span>±Ä</span><br></pre></td></tr></table></figure>

<p>照例查看函数声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>首先写入magic，和全局以及所有模块的辅助信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">    rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line"><span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,RDB_VERSION);</span><br><span class="line"><span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure>

<p>下面对于每一个数据库<code>j</code>，进行dump写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">    redisDb *db = server.db+j;</span><br><span class="line">    dict *d = db-&gt;dict;</span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>

<p>这里获得一个<a href="/2018/07/23/redis_learn_object/">安全迭代器</a>，也就是说在这个迭代器存在的时候是停止Rehash的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the SELECT DB opcode */</span></span><br></pre></td></tr></table></figure>

<p>写入<code>RDB_OPCODE_SELECTDB</code>这个op，并保存一些元数据：</p>
<ol>
<li>当前db的编号</li>
<li>当前db的size</li>
<li>当前db的expires链表的size</li>
</ol>
<p>这些元数据会通过提前写入的<code>RDB_OPCODE_</code>进行区分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the RESIZE DB opcode. */</span></span><br><span class="line"><span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">db_size = dictSize(db-&gt;dict);</span><br><span class="line">expires_size = dictSize(db-&gt;expires);</span><br><span class="line"><span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure>

<p>下面，遍历迭代器，以存储实际的数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line"><span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sds keystr = dictGetKey(de);</span><br><span class="line">    robj key, *o = dictGetVal(de);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">    initStaticStringObject(key,keystr);</span><br></pre></td></tr></table></figure>

<p>函数<code>getExpire</code>是用来获取key的过期时间的，我们需要同时将过期时间也写到RDB里面。而过期时间是单独存放在<code>db-&gt;expires</code>里面的，所以这里需要额外取出来，再存进去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        expire = getExpire(db,&amp;key);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">         * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">         * order to have a smaller final write. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">            rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">        &#123;</span><br><span class="line">            processed = rdb-&gt;processed_bytes;</span><br><span class="line">            aofReadDiffFromParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这些代码不太清楚是什么</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment"> * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment"> * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment"> * master will send us. */</span></span><br><span class="line"><span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">    di = dictGetIterator(server.lua_scripts);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *body = dictGetVal(de);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">"lua"</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure>

<p>最后，存入一个EOF和CRC64校验码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="flushAllDataAndResetRDB"><a href="#flushAllDataAndResetRDB" class="headerlink" title="flushAllDataAndResetRDB"></a>flushAllDataAndResetRDB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAllDataAndResetRDB</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    server.dirty += emptyDb(<span class="number">-1</span>,flags,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) killRDBChild();</span><br><span class="line">    <span class="keyword">if</span> (server.saveparamslen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Normally rdbSave() will reset dirty, but we don't want this here</span></span><br><span class="line"><span class="comment">         * as otherwise FLUSHALL will not be replicated nor put into the AOF. */</span></span><br><span class="line">        <span class="keyword">int</span> saved_dirty = server.dirty;</span><br><span class="line">        rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">        rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">        rdbSave(server.rdb_filename,rsiptr);</span><br><span class="line">        server.dirty = saved_dirty;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_JEMALLOC)</span></span><br><span class="line">    <span class="comment">/* jemalloc 5 doesn't release pages back to the OS when there's no traffic.</span></span><br><span class="line"><span class="comment">     * for large databases, flushdb blocks for long anyway, so a bit more won't</span></span><br><span class="line"><span class="comment">     * harm and this way the flush and purge will be synchroneus. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; EMPTYDB_ASYNC))</span><br><span class="line">        jemalloc_purge();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF机制的调用链（从下到上）如下所示：</p>
<ol>
<li><code>feedAppendOnlyFile</code><ol>
<li><code>propagate</code><br> 通常在各个模块中被带有<code>PROPAGATE_AOF|PROPAGATE_REPL</code>参数地调用</li>
</ol>
</li>
</ol>
<p><a href="/2018/07/23/redis_learn_object/">在key过期时，<code>propagateExpire</code>会被调用，从而发送过期消息给AOF</a>。</p>
<h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><h3 id="feedAppendOnlyFile"><a href="#feedAppendOnlyFile" class="headerlink" title="feedAppendOnlyFile"></a>feedAppendOnlyFile</h3><p>首先看参数，<code>dictid</code>实际上表示当前redis数据库的id</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>下面的这些<code>cat...Command</code>方法，实际上都是根据操作去重新组装回命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">sds buf = sdsempty();</span><br><span class="line">robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The DB this command was targeting is not the same as the last command</span></span><br><span class="line"><span class="comment"> * we appended. To issue a SELECT command is needed. */</span></span><br><span class="line"><span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">    <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</span><br><span class="line">    buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">    server.aof_selected_db = dictid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">    cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">    <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">    buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">    <span class="comment">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exarg || pxarg) &#123;</span><br><span class="line">        <span class="comment">/* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* All the other commands don't need translation or need the</span></span><br><span class="line"><span class="comment">     * same translation already operated in the command vector</span></span><br><span class="line"><span class="comment">     * for the replication itself. */</span></span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数<code>sdscatlen</code>将<code>buf</code>追加到<code>server.aof_buf</code>末尾，类似于concat，但这个取名有点迷惑，让人觉得是category的简写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></span><br><span class="line"><span class="comment"> * of re-entering the event loop, so before the client will get a</span></span><br><span class="line"><span class="comment"> * positive reply about the operation performed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">    server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br></pre></td></tr></table></figure>

<p>如果<code>BGREWRITEAOF</code>正在进行，还需要将命令追加到重写缓存中，记录当前正在重写的AOF文件和数据库当前状态的差异。这个命令用于异步执行一个AOF文件重写操作，重写会创建一个当前AOF文件的体积优化版本。即使<code>BGREWRITEAOF</code>执行失败，也不会有任何数据丢失，因为旧的AOF在<code>BGREWRITEAOF</code>成功之前不会被修改。<br>为什么要支持AOF重写呢？考虑下面的情形：对一个计数器调用了100次<code>INCR</code>，AOF文件需要使用100个条目来记录。但实际上只使用一条<code>SET</code>保存最后的值就行了。所以<code>BGREWRITEAOF</code>可以在不打断服务客户端的情况下，重建AOF文件，这个文件包含重建当前数据集所需的最少命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="aofRewriteBufferAppend"><a href="#aofRewriteBufferAppend" class="headerlink" title="aofRewriteBufferAppend"></a>aofRewriteBufferAppend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    listNode *ln = listLast(server.aof_rewrite_buf_blocks);</span><br><span class="line">    aofrwblock *block = ln ? ln-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        <span class="comment">/* If we already got at least an allocated block, try appending</span></span><br><span class="line"><span class="comment">         * at least some piece into it. */</span></span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> thislen = (block-&gt;<span class="built_in">free</span> &lt; len) ? block-&gt;<span class="built_in">free</span> : len;</span><br><span class="line">            <span class="keyword">if</span> (thislen) &#123;  <span class="comment">/* The current block is not already full. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(block-&gt;buf+block-&gt;used, s, thislen);</span><br><span class="line">                block-&gt;used += thislen;</span><br><span class="line">                block-&gt;<span class="built_in">free</span> -= thislen;</span><br><span class="line">                s += thislen;</span><br><span class="line">                len -= thislen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len) &#123; <span class="comment">/* First block to allocate, or need another block. */</span></span><br><span class="line">            <span class="keyword">int</span> numblocks;</span><br><span class="line"></span><br><span class="line">            block = zmalloc(<span class="keyword">sizeof</span>(*block));</span><br><span class="line">            block-&gt;<span class="built_in">free</span> = AOF_RW_BUF_BLOCK_SIZE;</span><br><span class="line">            block-&gt;used = <span class="number">0</span>;</span><br><span class="line">            listAddNodeTail(server.aof_rewrite_buf_blocks,block);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Log every time we cross more 10 or 100 blocks, respectively</span></span><br><span class="line"><span class="comment">             * as a notice or warning. */</span></span><br><span class="line">            numblocks = listLength(server.aof_rewrite_buf_blocks);</span><br><span class="line">            <span class="keyword">if</span> (((numblocks+<span class="number">1</span>) % <span class="number">10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> level = ((numblocks+<span class="number">1</span>) % <span class="number">100</span>) == <span class="number">0</span> ? LL_WARNING :</span><br><span class="line">                                                         LL_NOTICE;</span><br><span class="line">                serverLog(level,<span class="string">"Background AOF buffer size: %lu MB"</span>,</span><br><span class="line">                    aofRewriteBufferSize()/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install a file event to send data to the rewrite child if there is</span></span><br><span class="line"><span class="comment">     * not one already. */</span></span><br><span class="line">    <span class="keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="number">0</span>) &#123;</span><br><span class="line">        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,</span><br><span class="line">            AE_WRITABLE, aofChildWriteDiffData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="catAppendOnlyExpireAtCommand"><a href="#catAppendOnlyExpireAtCommand" class="headerlink" title="catAppendOnlyExpireAtCommand"></a>catAppendOnlyExpireAtCommand</h3><p>我们抽取一个<code>cat...Command</code>进行分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">catAppendOnlyExpireAtCommand</span><span class="params">(sds buf, struct redisCommand *cmd, robj *key, robj *seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> when;</span><br><span class="line">    robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we can use strtoll */</span></span><br><span class="line">    seconds = getDecodedObject(seconds);</span><br><span class="line">    when = strtoll(seconds-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == setexCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when += mstime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Redis中的引用计数规则，让人觉得有点难懂，原因是有的对象是由被调用者而不是调用者释放的，但在这里的代码基本都是由调用者释放（调用<code>decrRefCount</code>）的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    decrRefCount(seconds);</span><br><span class="line">    argv[<span class="number">0</span>] = createStringObject(<span class="string">"PEXPIREAT"</span>,<span class="number">9</span>);</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    argv[<span class="number">2</span>] = createStringObjectFromLongLong(when);</span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf, <span class="number">3</span>, argv);</span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h2><h3 id="flushAppendOnlyFile"><a href="#flushAppendOnlyFile" class="headerlink" title="flushAppendOnlyFile"></a>flushAppendOnlyFile</h3><p>服务器先写AOF，再返回给客户端。因为客户端进行写操作的机会是在event loop中，我们需要将所有的AOF写先缓存起来，并且在重新进入event loop前进行刷盘。<br>目前AOF刷盘有几种策略：</p>
<ol>
<li>每个命令刷盘一次<br> 这也是最安全和最慢的</li>
<li>每秒刷盘一次(everysec)</li>
<li>从不刷盘</li>
</ol>
<p>当采用everysec方式的时候，如果后台线程有在fsync，那么会延迟这次fsync，这是因为Linux上，<code>write(2)</code>调用也会被后台的fsync阻塞。当这种情况发生时，说明要尽快刷AOF缓存。所以会尝试在<code>serverCron()</code>里面刷。但是如果force是1，那么无论是否fsync，都强行写入。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_WRITE_LOG_ERROR_RATE 30 <span class="comment">/* Seconds between errors logging. */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Check if we need to do fsync even the aof buffer is empty,</span></span><br><span class="line"><span class="comment">         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is</span></span><br><span class="line"><span class="comment">         * called only when aof buffer is not empty, so if users</span></span><br><span class="line"><span class="comment">         * stop write commands before fsync called in one second,</span></span><br><span class="line"><span class="comment">         * the data in page cache cannot be flushed in time. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.aof_fsync_offset != server.aof_current_size &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync &amp;&amp;</span><br><span class="line">            !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">            <span class="keyword">goto</span> try_fsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        sync_in_progress = aofFsyncInProgress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></span><br><span class="line"><span class="comment">         * If the fsync is still in progress we can try to delay</span></span><br><span class="line"><span class="comment">         * the write for a couple of seconds. */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No previous write postponing, remember that we are</span></span><br><span class="line"><span class="comment">                 * postponing the flush and return. */</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></span><br><span class="line"><span class="comment">                 * than two seconds this is still ok. Postpone again. */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></span><br><span class="line"><span class="comment">             * over two seconds. */</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></span><br><span class="line"><span class="comment">     * at least if the filesystem we are writing is a real physical one.</span></span><br><span class="line"><span class="comment">     * While this will save us against the server being killed I don't think</span></span><br><span class="line"><span class="comment">     * there is much to do about the whole server stopping for power problems</span></span><br><span class="line"><span class="comment">     * or alike */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">        usleep(server.aof_flush_sleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    <span class="comment">/* We want to capture different events for delayed writes:</span></span><br><span class="line"><span class="comment">     * when the delay happens with a pending fsync, or with a saving child</span></span><br><span class="line"><span class="comment">     * active, and when the above two conditions are missing.</span></span><br><span class="line"><span class="comment">     * We also use an additional event name to save all samples which is</span></span><br><span class="line"><span class="comment">     * useful for graphing / monitoring purposes. */</span></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-pending-fsync"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-active-child"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-alone"</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"aof-write"</span>,latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We performed the write so reset the postponed flush sentinel to zero. */</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Log the AOF write error and record the error code. */</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Short write while writing to "</span></span><br><span class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></span><br><span class="line">                                       <span class="string">"expected=%lld)"</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">"Could not remove short write "</span></span><br><span class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></span><br><span class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></span><br><span class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If the ftruncate() succeeded we can set nwritten to</span></span><br><span class="line"><span class="comment">                 * -1 since there is no longer partial data into the AOF. */</span></span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle the AOF write error. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></span><br><span class="line"><span class="comment">             * reply for the client is already in the output buffers, and we</span></span><br><span class="line"><span class="comment">             * have the contract with the user that on acknowledged write data</span></span><br><span class="line"><span class="comment">             * is synced on disk. */</span></span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></span><br><span class="line"><span class="comment">             * set an error to stop accepting writes as long as the error</span></span><br><span class="line"><span class="comment">             * condition is not cleared. */</span></span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></span><br><span class="line"><span class="comment">             * was no way to undo it with ftruncate(2). */</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">         * OK state and log the event. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></span><br><span class="line"><span class="comment">     * arena size of 4k minus some overhead (but is otherwise arbitrary). */</span></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></span><br><span class="line"><span class="comment">     * children doing I/O in the background. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform the fsync if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">/* redis_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        redis_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/12/meet-in-changsha/" rel="next" title="长沙攻略">
                <i class="fa fa-chevron-left"></i> 长沙攻略
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/14/mysql-lock/" rel="prev" title="MySQL锁">
                MySQL锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">223</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">154</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RIO"><span class="nav-number">1.</span> <span class="nav-text">RIO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bio"><span class="nav-number">2.</span> <span class="nav-text">bio</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建一个io任务"><span class="nav-number">2.1.</span> <span class="nav-text">创建一个io任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#后台处理"><span class="nav-number">2.2.</span> <span class="nav-text">后台处理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#RDB"><span class="nav-number">3.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#rdbSave"><span class="nav-number">3.1.</span> <span class="nav-text">rdbSave</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rdbSaveRio"><span class="nav-number">3.2.</span> <span class="nav-text">rdbSaveRio</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#flushAllDataAndResetRDB"><span class="nav-number">3.3.</span> <span class="nav-text">flushAllDataAndResetRDB</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOF"><span class="nav-number">4.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#写入"><span class="nav-number">4.1.</span> <span class="nav-text">写入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#feedAppendOnlyFile"><span class="nav-number">4.1.1.</span> <span class="nav-text">feedAppendOnlyFile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#aofRewriteBufferAppend"><span class="nav-number">4.1.2.</span> <span class="nav-text">aofRewriteBufferAppend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#catAppendOnlyExpireAtCommand"><span class="nav-number">4.1.3.</span> <span class="nav-text">catAppendOnlyExpireAtCommand</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#刷盘"><span class="nav-number">4.2.</span> <span class="nav-text">刷盘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#flushAppendOnlyFile"><span class="nav-number">4.2.1.</span> <span class="nav-text">flushAppendOnlyFile</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">5.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2021/03/13/redis-persist/';
          this.page.identifier = '2021/03/13/redis-persist/';
          this.page.title = 'Redis持久化机制实现';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
