<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="分布式,raft,论文阅读,paxos,一致性," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。">
<meta name="keywords" content="分布式,raft,论文阅读,paxos,一致性">
<meta property="og:type" content="article">
<meta property="og:title" content="Paxos算法">
<meta property="og:url" content="http://www.calvinneo.com/2021/01/06/paxos/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/bpaxos.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/ong7.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/ong8.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/ong9.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/ong10.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/12.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/13.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/14.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/15.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/20.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/ong22.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/26.a.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/26.b.png">
<meta property="og:image" content="http://www.calvinneo.com/img/paxos/q1.png">
<meta property="og:updated_time" content="2024-12-19T15:42:09.862Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Paxos算法">
<meta name="twitter:description" content="本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。">
<meta name="twitter:image" content="http://www.calvinneo.com/img/paxos/bpaxos.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2021/01/06/paxos/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>Paxos算法 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2021/01/06/paxos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Paxos算法
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-01-06T19:20:33+08:00">
                2021-01-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。</p>
<a id="more"></a>
<h1 id="Basic-Paxos-Lamport"><a href="#Basic-Paxos-Lamport" class="headerlink" title="Basic Paxos(Lamport)"></a>Basic Paxos(Lamport)</h1><p>Paxos允许消息被任意延迟、丢包、重复，但不允许消息被损坏。<br>Basic Paxos弱化了Leader的概念，而使用了Proposer的概念。<br>Basic Paxos只对一个Value决议。这个Value实际上<a href="https://stackoverflow.com/questions/65175880/how-can-i-understand-value-in-bacis-paxos" target="_blank" rel="noopener">类似于Raft里面的一个Log Entry</a>，即<code>x=1</code>或者<code>y=42</code>之类的。根据原版论文<em>The part-time parliament</em>，这里的Value即法令，类似于禁止画画或者允许自由艺术等。<br>注意，一个 Value 被决定是 chosen 而不是 accepted，即决议的过程是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propose(issue) -&gt; accept -&gt; chosen</span><br></pre></td></tr></table></figure>

<h2 id="论证1"><a href="#论证1" class="headerlink" title="论证1"></a>论证1</h2><p>在论证1的部分，我们从原始要求倒推出需要维护的不变量 P2b。</p>
<h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><p>考虑没有丢包和机器故障，并且假设只有一个proposer。对于该平凡情况，可以得到下面的要求：<br>一个 acceptor 必须接受它收到的第一个 proposal。</p>
<p>显然这个方案存在一个问题，不同的 proposer 可能提出不同的value，这会导致每个 acceptor 收到了不同的 value，但其中没有一个 value 是占 majority 的。<br>这个问题导致我们需要让 acceptor 去 accept 多于一个 proposal。为了区分这些 proposal，就要引入 proposal number。<br>一个 Value 被 chosen，当具有这个 Value 的 proposal 已经被大部分的 acceptor accept 了。</p>
<h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><p>经过上面的论证，我们允许 choose 多个 proposal，前提是所有被 chosen 的 proposal 都有相同的 Value，因此提出下面的要求：<br>如果具有 Value <code>v</code> 的 proposal 被 <strong>chosen</strong> 了，那么对于任意更高的 number 的 proposal，如果它被 <strong>chosen</strong>，那么它就一定有 Value <code>v</code>。</p>
<h3 id="P2a"><a href="#P2a" class="headerlink" title="P2a"></a>P2a</h3><p>就 P2 进一步推导，因为被 chosen 的前提是这个 proposal 要至少被一个 acceptor <strong>accept</strong>，可以通过满足下面条件来满足P2：<br>如果具有 Value <code>v</code> 的 proposal 被 <strong>chosen</strong> 了，那么对于任意更高的 number 的 proposal，如果它被任意的 accpetor <strong>accept</strong>，那么它就一定有 Value <code>v</code>。</p>
<p>这个条件更强，因为它从要求 chosen Value 变成要求 accept Value，相当于提前了。但前提还是已经有 proposal 被 chosen。</p>
<h3 id="P2b"><a href="#P2b" class="headerlink" title="P2b"></a>P2b</h3><p>注意，仍然需要满足要求 P1，这样保证至少能 accpet 一个 proposal。因此可以构造出下面的情况：</p>
<ol>
<li>一个新的 proposer propose 了一个更高的 number 的 proposal，但是具有不同的 Value <code>v2</code>；</li>
<li>一个之前从来没有收到过任何 proposal 的 acceptor 收到了这个 proposal；</li>
<li>根据 P1，这个 acceptor 需要 accept 这个 proposal；</li>
<li>根据 P2a，这个 acceptor 不能 accept 这个 proposal，因为它必须有之前的 Value <code>v</code>；</li>
</ol>
<p>我们发现这里产生了矛盾，因此还需要继续强化要求P2a：<br>如果具有 Value <code>v</code> 的 proposal 被 <strong>chosen</strong> 了，那么对于任意更高的 number 的 proposal，在它被任意 proposer 发出时，就一定有 Value <code>v</code>。</p>
<p>这个条件更强，因为它从要求 accept Value 变成要求 propose Value，相当于更提前了。但前提还是已经有 proposal 被 chosen。</p>
<p>所以截止目前为止，我们还是不能得到一个完整的算法，因为<strong>缺少尚未 chosen 时的行为规则</strong>。</p>
<h2 id="论证2"><a href="#论证2" class="headerlink" title="论证2"></a>论证2</h2><p>论证2紧接着论证1，讲述如何维护 P2b 性质。</p>
<h3 id="P2c"><a href="#P2c" class="headerlink" title="P2c"></a>P2c</h3><p>首先要做的是，对 proposal 编号。</p>
<p>为了方便表示，规定 <code>proposal(m,v)</code> 表示具有 number <code>n</code> 和 Value <code>v</code> 的 proposal。下面查看 P2b 是如何保证自己一直成立的。</p>
<p>考虑 <code>proposal(m,v)</code> 被 chosen，那么要证明任何 number 大于 <code>m</code> 的 <code>proposal(n)</code> 也有 Value <code>v</code>。证明如下：<br>如果 <code>m</code> 被 chosen，那么一定有大多数 acceptor accept 了这个 proposal，这些 acceptor 属于集合 <code>C</code>。再结合 P2b，可以推出<code>C</code>中所有的 acceptor 都 accept 了从 <code>m</code> 到 <code>n-1</code> 的 proposal，并且这些被 accept 的 proposal 都具有 Value <code>v</code>。</p>
<p>因为任意包含大多数 acceptor 的集合 <code>S</code> 必须包含 <code>C</code> 中的至少一个成员，可以得出 P2c。也就是只要满足 P2c，就能维护 P2b 性质。</p>
<p>考虑一个 proposer 发出了 <code>proposal(v,n)</code>，那么存在一个上述的 acceptor 集合 <code>S</code>，满足要求 <strong>P2c</strong>：</p>
<ol>
<li>要么 <code>S</code> 中的 acceptor 都没有 accept 过低于 <code>n</code> 的 proposal；</li>
<li>要么 accept 的最大的小于 <code>n</code> 的 proposal 的 Value 是 <code>v</code>。<br> 【Q】这种情况下，是否可能 accept 多个 Value 呢？</li>
</ol>
<h2 id="论证3"><a href="#论证3" class="headerlink" title="论证3"></a>论证3</h2><p>为了维护 P2c，我们发现一个 proposer 在发出 <code>n</code> 这个 proposal 之前，需要检查最大的小于 <code>n</code> 的 proposal，看它是否<strong>已经</strong>或者<strong>将要</strong>被某些 acceptor accept。前者容易，但是后者不容易，因为要预测某个 proposal 是否会被 accept。</p>
<p>为了简化掉这个预测，引入了一个提前的阶段。这个阶段中，proposer 要求 acceptor 保证不会再去 accept 任何低于 <code>n</code> 的 proposal 了。</p>
<p>现在，得到下面的算法，该算法指导如何 issue 一个 proposal。</p>
<h3 id="Proposer-算法-Step1"><a href="#Proposer-算法-Step1" class="headerlink" title="Proposer 算法 Step1"></a>Proposer 算法 Step1</h3><p><strong>在这里，我们引入了一个 Prepare 请求。需要注意 Prepare 请求和 proposal 的区别。</strong><br>proposer 选择一个新的 number <code>n</code>，发送请求 <code>Prepare(n)</code> 给某个集合中的所有 acceptor。注意这个 Prepare 请求不同于 proposal，它不需要带上 Value。<br>此时每个 acceptor 应该返回：</p>
<ol>
<li>保证不再接受<strong>小于</strong> <code>n</code> 的 proposal；</li>
<li>自己目前 accept 了的最大的小于 <code>n</code> 的 proposal。如果没有的话，就不需要返回。</li>
</ol>
<h3 id="Proposer-算法-Step2"><a href="#Proposer-算法-Step2" class="headerlink" title="Proposer 算法 Step2"></a>Proposer 算法 Step2</h3><p>如果这个 proposer 收到了 majority 的 acceptor 的回复，那么就可以发送一个 <code>Accept(n,v)</code> 的请求。其中 <code>n</code> 是 Prepare 时候的 <code>n</code>，<code>v</code> 则遵循下面的规则选择：</p>
<ol>
<li>如果没有人对 <code>v</code> 的值有 proposal，那么这个 proposer 就可以任选 <code>v</code> 的值。</li>
<li>否则，就返回最大的小于 <code>n</code> 的 proposal 给出的 <code>v</code> 值。</li>
</ol>
<p>文章特别强调，Prepare 请求和 Accept 请求可以发送给不同的 acceptor。</p>
<h3 id="Acceptor-算法"><a href="#Acceptor-算法" class="headerlink" title="Acceptor 算法"></a>Acceptor 算法</h3><p>该算法又名 P1a 约束：</p>
<ol>
<li>一个 acceptor 可以安全地忽略任何的请求。</li>
<li>acceptor 可以回应 Prepare 请求。</li>
<li>acceptor 可以回应 Accept 请求，并去 accept 某个 proposal，当且仅当它<strong>没有保证不接受</strong>这个请求，即：<br>当且仅当一个 acceptor 没有回应<strong>大于</strong> <code>n</code> 的 Prepare 请求，它可以接受一个 <code>n</code> 编号的 Accept 请求。可以看出，P1 是 P1a 的特例。</li>
</ol>
<p>也就是说，如果回应了 <code>n+1</code> 的 Prepare 请求，那么：</p>
<ol>
<li>可以忽略编号是任意的 Accept 请求；</li>
<li>可以 Accept 编号是 <code>n+1</code> 的 Accept 请求；</li>
<li>不能 Accept 编号是 <code>n</code> 的 Accept 请求；</li>
<li>能不能 promise 编号是 <code>n</code> 的 Prepare 请求？<br> 文章中指出，没有理由去回应这样的请求。因为根据上一点，连编号为 <code>n</code> 的 Accept 请求都不会被响应了，更何况 Prepare 请求呢？<br> 同理，如果一个请求已经被 accept 了，那么我们也不会再去回应对应的 Prepare 请求了。<br> 根据 Proposer 算法 Step 1，我是保证不会接受<strong>小于</strong> <code>n</code> 的 proposal，但在这之前我已经保证不接受小于 <code>n+1</code> 的 proposal 了。但假如我们回应了 promise <code>n</code>，那么会返回之前的 proposal 给出的 <code>v</code> 值，我理解这样也不会出问题。所以这归根结底是个优化。</li>
</ol>
<h3 id="持久化要求"><a href="#持久化要求" class="headerlink" title="持久化要求"></a>持久化要求</h3><p>为了维护 P2c 这个不变量，一个 acceptor 需要持久化：</p>
<ol>
<li>自己回复的最大的 Prepare 请求的 number；</li>
<li>自己 Accept 的最大的 proposal number；</li>
</ol>
<p>此外，一个 proposer 可以忘记或者放弃自己的 proposal，只要它不会产生具有相同 number 的另一个请求。因此 proposer 需要持久化：</p>
<ol>
<li>自己使用过的最大的 proposal number</li>
</ol>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>将 Proposer 和 Acceptor 组合起来，可以看到 Paxos 算法的全貌。</p>
<h3 id="Phase-1：Prepare"><a href="#Phase-1：Prepare" class="headerlink" title="Phase 1：Prepare"></a>Phase 1：Prepare</h3><ol>
<li>proposer<br> 选择 <code>n</code>，发送 <code>Prepare(n)</code> 到 majority 个 acceptor 上。<br> <strong>注意 Prepare 阶段实际不要带上自己意向的 Value</strong>。</li>
<li>acceptor<br> 对于 <code>Prepare(n)</code>，如果 <code>n</code> 高于已经响应过的其他 <code>Prepare</code> 请求，则：<ol>
<li>promise 不会再 accept 任何<strong>小于</strong> <code>n</code> 的请求；</li>
<li>发送最大的小于 <code>n</code> 的 accept 的 proposal，这里面包含了 Value。</li>
</ol>
</li>
</ol>
<h3 id="Phase-2：Accept"><a href="#Phase-2：Accept" class="headerlink" title="Phase 2：Accept"></a>Phase 2：Accept</h3><ol>
<li>proposer<br> 如果收到了 majority 的 acceptor 对自己 <code>Prepare(n)</code> 的响应，则发送 <code>Accept(n,v)</code> 请求给所有这些 acceptor。这里 <code>v</code> 的选择参见<em>Proposer 算法 Step2</em>一节。</li>
<li>acceptor<br> 除非自己已经回复了 <code>Prepare(n+1)</code> 或者更高的 Prepare 请求，否则 acceptor 需要 accept 请求 <code>Accept(n,v)</code>。<br> 注意，如下文所述，一个 acceptor 可能 accept 不同的 Value，也就是可能变票。</li>
</ol>
<h2 id="Learner"><a href="#Learner" class="headerlink" title="Learner"></a>Learner</h2><p>容易发现，因为没有 Leader，所以从单一的 acceptor 角度，并不能很方便地去检查某个 proposal 是否已经被 chosen 了。</p>
<p>一个平凡的方法就是每进行一次 accept，就告知 Learner 一次，不过这有很大的通信开销。考虑到 Learner 也不会出现拜占庭错误，所以 Learner 间可以相互通信以得到被 accept 的值，因此可以让每个 acceptor 只响应某一些 Learner。</p>
<p>如果考虑到这一些 Learner 可能失败，导致丢失 acceptor 信息，问题还会更复杂。此时，一个值被 chosen 了，但是没有 Learner 发现。虽然 Learner 可以再逐个询问 acceptor，但只要有一个 acceptor 宕掉，就可能导致 Learner 无法了解某个 proposal 是否得到多数同意。在这种情况下，只有当一个新的 proposal 被 chosen Learner 才会再次发现。这就有点类似于 Raft 中新 Leader 不能提交旧 term 的日志的感觉。</p>
<p>【Q】对此，可以提出一个问题，对于 <code>n&gt;m</code>，如果 <code>n</code> 被 chosen，那么 <code>m</code> 是不是一定被 chosen 呢？</p>
<h2 id="活锁问题"><a href="#活锁问题" class="headerlink" title="活锁问题"></a>活锁问题</h2><p>上述的 Basic Paxos 算法存在活锁问题。考虑</p>
<ol>
<li><code>p</code> 发送 <code>Prepare(n1)</code>；</li>
<li><code>q</code> 发送 <code>Prepare(n2)</code>，其中 <code>n2&gt;n1</code>；</li>
<li>此时 <code>p</code> 不能成功地 <code>Accept(n1)</code> 了，因为 acceptor 保证了不会 accept 低于 <code>n2</code> 的请求；</li>
<li>于是 <code>p</code> 继续发送一个 <code>Prepare(n3)</code>，其中 <code>n3&gt;n2</code>；</li>
<li>由此开始循环往复。</li>
</ol>
<p>因此必须选出一个<strong>proposer</strong>，这个 proposer 起到 Leader 的作用，只有它可以发送 proposal。在论文后面提到，这个 Leader 实际上还起到首要的 Learner 的作用。</p>
<p>可以发现，Raft 之所以引入 Leader，一定程度上也是为了减少活锁的问题。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>acceptor 的回复需要带上对应的 proposal number。acceptor 需要先持久化自己的回复，再发送给对方。<br>下面讨论如何保证没有两个 proposal 的 number 是相同的。方法很简单，不同的 proposer 从不同的不相交集中取这些序号即可，比如模上自己的序号。每个 proposer 持久化自己所选取的最大的 proposal number。</p>
<h2 id="实现状态机"><a href="#实现状态机" class="headerlink" title="实现状态机"></a>实现状态机</h2><p>使用多个服务器组成集群，每个服务器构成一个单独的状态机。因为状态机都是确定的，所以每个服务器对应的状态机的状态和输出始终是一致的。<br>为了保证每个状态机都能执行相同的状态机命令，实现了</p>
<h1 id="Basic-Paxos-Ongaro"><a href="#Basic-Paxos-Ongaro" class="headerlink" title="Basic Paxos(Ongaro)"></a>Basic Paxos(Ongaro)</h1><p>在 Ongaro 等的视频里面，进一步理清了 Basic Paxos 的相关概念。<br>首先是 Basic Paxos Instance、Server、Proposer 和 acceptor 的关系。一个 Instance 指的是 Basic Paxos 决定一个 Value 的过程。因此 Basic Paxos 被称为是 Single decree 的，因为它只决定一个值。</p>
<p>一般一个 Server 同时是一个 proposer 和 acceptor。一个 acceptor 完全被动地处理来自 proposer 的请求。<strong>一个 acceptor 可能 accept 不同的 Value</strong>，也就是可能变票。</p>
<p>特别地，只有提出某个 proposal 的 proposer 才能知道是否已经被 chosen；对于其他的 proposer，必须用自己的 proposal 执行一遍 basic paxos才行。</p>
<h2 id="Basic-Paxos-的图解"><a href="#Basic-Paxos-的图解" class="headerlink" title="Basic Paxos 的图解"></a>Basic Paxos 的图解</h2><p><img src="/img/paxos/bpaxos.png"></p>
<h2 id="Split-Votes讨论"><a href="#Split-Votes讨论" class="headerlink" title="Split Votes讨论"></a>Split Votes讨论</h2><p>这个章节论述 Paxos 算法是如何被得到的，所以有点往回讲。<br>如果 acceptor 每次只接受发给自己的第一个 proposal，那么就会出现下面的情况。为了避免，需要 acceptor 能够 accept 不同的 Value。<br><img src="/img/paxos/ong7.png"></p>
<p>如果 acceptor 接受所有给它发来的 proposal，也不行。<br>第一个问题如下所示，可能导致有多个不同的 Value 被 chosen。为了解决这个问题，就有了 P2b，也就是一旦 chosen，那么后续 proposer 只能 propose 同样的 Value。这个由一个两阶段的协议来保证。<br><img src="/img/paxos/ong8.png"></p>
<p>第二个问题如下所示。在这个场景下 S3 选择不同的策略可以导致不同的 Value 被 chosen。<br>如果我们秉持“接受所有发来的 Proposal”的策略，那么就会导致如下的情况：</p>
<ol>
<li>S5 并不需要 propose red 这个 Value，因为这个时候 red 还没有被 chosen。<br> <strong>所以这个问题和第一个问题不同</strong>，因为这个时候 proposal 还没有被 chosen，所以 P2b 发挥不了作用。<strong>但 acceptor 还是不能来者不拒</strong>。<br> <strong>所以这就是为什么 P2b 时还没引入 proposal number，到了 P2c 时就要引入了</strong>。</li>
<li>但是 S3 必须要 reject 掉 Accept(S1, red)，因为在收到这个 Accept 请求的时候 blue 已经 chosen 了。</li>
</ol>
<p><img src="/img/paxos/ong9.png"></p>
<p>Ongaro 说要引入 order，也就是新的 proposal 要比老的 proposal 更优先。当然，如果老的 proposal 已经被 chosen 了，那就按照 P2b 规则来。不然又退化成接受所有给它发来的 proposal 了。</p>
<p>所以为了解决问题二，实际上规则是：</p>
<ol>
<li>一旦 chosen，就只能 propose 和 accept 同一个 proposal</li>
<li>否则，永远 accept 最新的 proposal</li>
</ol>
<h3 id="Proposal-Number"><a href="#Proposal-Number" class="headerlink" title="Proposal Number"></a>Proposal Number</h3><p>接着，Ongaro 提出一种实现 Proposal Number 的方案，也就是高位的 Round Number 和低位的 Server ID。这些 Round Number 需要被持久化到磁盘上，以保证 proposal number 不会被重复使用。</p>
<p><img src="/img/paxos/ong10.png"></p>
<p>Round Number 是全局递增的，而不是自己实现一个 Local 的计数器。每个 Server 基于自己看到的最大的 Round Number 来选取新的 Rounder Number：</p>
<ol>
<li>自增自己维护的 maxRound</li>
<li>将自己的 Server ID 贴在后面</li>
</ol>
<h2 id="Paxos-算法"><a href="#Paxos-算法" class="headerlink" title="Paxos 算法"></a>Paxos 算法</h2><p>下面的图表示了 Basic Paxos 的消息通信过程<br><img src="/img/paxos/12.png"></p>
<h2 id="三种Prepare顺序讨论"><a href="#三种Prepare顺序讨论" class="headerlink" title="三种Prepare顺序讨论"></a>三种Prepare顺序讨论</h2><p>下面讨论 Paxos 中三种常见的 Prepare 顺序和对应的结果。<br>框框中的 <code>P 3.1</code> 表示<strong>收到</strong>来自 Server1 的 Round Number 为 3 的 proposal，<code>A 3.1 X</code> 表示<strong>收到而不是接受</strong>这个 proposal，它的值为 <code>X</code>。<br>在这些场景中，有两个 proposer 试图 propose，分别是 S1 要 propose 值 X，且 S5 要 propose 值 Y。</p>
<h3 id="1-当值X已经被chosen"><a href="#1-当值X已经被chosen" class="headerlink" title="1. 当值X已经被chosen"></a>1. 当值X已经被chosen</h3><p>如下图所示，当来自 S5 的 proposal <code>P 4.5</code> 到来时，值 <code>X</code> 已经被 chosen 了。那 S3 会在 Prepare 的时候就告诉它自己已经 accept X 这个值了。后续 S5 的 proposal 也只好去 propose 这个值，也就是发送 <code>Accept(3.1, X)</code>。<br><img src="/img/paxos/13.png"></p>
<h3 id="2-当值X没有被chosen，但新的proposer能够看到"><a href="#2-当值X没有被chosen，但新的proposer能够看到" class="headerlink" title="2. 当值X没有被chosen，但新的proposer能够看到"></a>2. 当值X没有被chosen，但新的proposer能够看到</h3><p>注意 S3 已经 accept 了 <code>A 3.1 X</code>，所以当 S5 发出 <code>P 4.5</code> 后，它会告诉 S5 值已经被自己 accept 为 <code>X</code> 了。所以后续 S5 就发送 <code>Accept(X)</code>。</p>
<p><img src="/img/paxos/14.png"></p>
<h3 id="3-当值X没有被chosen，新的proposer也看不到"><a href="#3-当值X没有被chosen，新的proposer也看不到" class="headerlink" title="3. 当值X没有被chosen，新的proposer也看不到"></a>3. 当值X没有被chosen，新的proposer也看不到</h3><p>此时 S3 上的 <code>A 3.1 X</code> 请求实际上不会被 accept，因为 <code>Prepare(4.5)</code> 已经捷足先登了。<br><img src="/img/paxos/15.png"></p>
<h1 id="Multi-Paxos-Ongaro"><a href="#Multi-Paxos-Ongaro" class="headerlink" title="Multi Paxos(Ongaro)"></a>Multi Paxos(Ongaro)</h1><p>主要讲了几件事情：</p>
<ol>
<li>如何维护一个 Log 也就是一系列 Entry，而不是某一个 Entry。</li>
<li>性能优化，包括两方面，但主要是借助于 Leader：<ol>
<li>去掉 proposer 之间存在的活锁<br> 如果在任何一个时刻，保证只有一个 proposer 发请求的话，那么就不会存在活锁。</li>
<li>去掉冗余的 Prepare 请求<br> 即对每个 log 而不是每个 entry 进行一次 Prepare，这样话大部分 entry 可以在一轮 RPC 中被 chosen，即执行一轮 accept。</li>
</ol>
</li>
<li>如何实现所谓的 <strong>Fully Replication</strong>，即让大家都知道某个 Entry 已经被 chosen 了。</li>
<li>客户端协议以及状态机相关。</li>
</ol>
<p>可以看到，这些事情也正是 Raft 相比 Basic Paxos 增加的大部分内容，也是 Raft 容易理解和实现的原因。</p>
<h2 id="维护一个Log"><a href="#维护一个Log" class="headerlink" title="维护一个Log"></a>维护一个Log</h2><p>如下图所示，粗线框表示这个 Entry 我们知道已经被 chosen 了。而没加粗线框的 Entry，只是说明 accept 了这个值。</p>
<p>现在准备新增一个 entry 到 log。client 发送一个 jmp 给 S1，S1 选择哪一个 entry 呢？这可能涉及以下的情况：</p>
<ol>
<li>在 Entry1 和 Entry2 中，mov 和 add 被复制到了所有机器上，并且 S1 已经知道被 chosen 了。如下图所示，用粗框子框出来了。</li>
<li>在 Entry3 中，cmp 被 S1 和 S3 accept 了，所以实际上已经被 chosen 了。但是 S1 并不知道，这个可能是因为 S3 的 acceptor 被分区了。其实我觉得还有可能是因为这个 proposal 不是 S1 提出来的，所以 S1 不知道。</li>
</ol>
<p><img src="/img/paxos/20.png"></p>
<p>下面考虑 S3 被分区的情况：</p>
<ol>
<li>S1 找到第一个自己不知道被是否 chosen 的 entry，即后面提到的 <code>firstUnchosenIndex</code>。也就是下图中的 Entry3。</li>
<li>根据 Basic Paxos 算法，对这个 entry 去 propose 一个 Value 为 jmp 的 proposal。显然，这个 Value 是不能被 accept 的，并且会在 Prepare 阶段就被要求使用 cmp 去发送 Accept 请求。因为已经有一个 acceptor 接受了 cmp 这个值了。所以这个 Basic Paxos Instance 跑完，实际上还是导致 cmp 在 Entry3 中被 chosen。并且 S1 知道了这个结果。</li>
<li>接着回到第1步，检查下一个尚未被发现已经 chosen 的 entry，即 Entry4，并尝试 propose。显然，这次 jmp 还是不能被成功 propose，因为 sub 已经被 S2 上的 acceptor accept 了。</li>
</ol>
<p>上面实际上就是所谓“补空洞”的过程。可以发现，由新 proposer 来帮助老 proposal 实现 chosen，类似于 raft 中由新 Leader 帮助老 Leader 完成 commit 的过程。但我觉得实际上 Paxos 更加灵活，因为可以有多个 proposer 同时做这个工作。</p>
<p>通过这种方式，Server 可以并发处理多条来自 client 的请求。演讲者提到，例如第一个请求用到了 Entry3，那么下一个请求可能会尝试 Entry4 或者 Entry5 等等。</p>
<p>注意 Entry5 上原来的 cmp 命令，它只出现在 S3 上。但可能因为它被分区了，所以最终被 chosen 的是 jmp，并且 S3 上最终是个 shl。如果在这里有疑惑，如果 cmp 被 S3 accept 了，为啥还能先后 accept 不同的值？需要回过头去看 Split Votes 这一章节。或者看下习题2。</p>
<p>【Q】我们能保证 client 的请求在 Paxos log 层面是 in order 的么？也就是说 client 可能找一个 proposer 要求写入 cmp，另一个 proposer 要求写入 shl。然后它们实际的写入顺序是不一致的？</p>
<h2 id="提升性能的办法"><a href="#提升性能的办法" class="headerlink" title="提升性能的办法"></a>提升性能的办法</h2><p>解决方案：</p>
<ol>
<li>引入 Leader<br> 这样只有一个 Server 能 propose，减少冲突的可能性。</li>
<li>消除大部分 Prepare<br> 每个 log Prepare 一次，而不是每个 entry Prepare 一次。<br> 减少 choose 一个 Value 需要的 RPC 轮数。</li>
</ol>
<p><img src="/img/paxos/ong22.png"></p>
<h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>需要注意的是，Paxos 在有多个 Leader 的时候依旧能够正常运作，只是效率会受到影响；但是 Raft 等就必须要求有唯一的 Leader。<br>Lamport 提出一种简单的办法，就是令具有最大的 Server ID 的 proposer 为 Leader。接着所有的 Server 互相向其他 Server 以间隔 <code>T</code> 发送心跳包，心跳包中包含自己的 Server ID。如果一个 Server 在 <code>2T</code> 的时间内没有收到一个具有更高的 Server ID 的心跳包，那么它就以 Leader 的方式行动，即开始处理来自 client 的请求，且同时执行 proposer 和 acceptor 的角色。相对应地，如果一个 Server 不是 Leader，那么它不处理 client 的请求，并且只执行 acceptor 的角色。</p>
<p>演讲者后来指出，一般来说，并不会用这种方案。</p>
<h3 id="减少Prepare"><a href="#减少Prepare" class="headerlink" title="减少Prepare"></a>减少Prepare</h3><p>下面讨论如何减少 Prepare 请求。首先，为什么要有 Prepare 请求呢？</p>
<ol>
<li>阻止具有旧的 number 的 proposal</li>
<li>发现可能存在的已经被 chosen 的 Entry<br> 因为 acceptor 处理 Prepare 请求时，如果自己已经 accept 了某个 proposal，会返回该 proposal。 即 Proposer 算法 Step1。</li>
</ol>
<p>下面对这两点目的进行改进：</p>
<ol>
<li>阻止具有旧的 number 的 proposal<br> 让 proposal number 和整个 log 关联，而不是和某个 entry 关联。</li>
<li>发现可能存在的已经被 chosen 的 Entry<br> 在处理 Prepare 请求时，acceptor 不仅要返回对于当前 entry 的最大的 proposal number，还要检查当前 entry 之后的所有 entry。如果这些 entry 里面没有任何 proposal 被 accept，那么就返回 <code>noMoreAccepted</code>。</li>
</ol>
<p>如果一个 acceptor 返回了 <code>noMoreAccepted</code>，那么后续就不再发送 Prepare 请求，直到某个 Accept 请求被拒绝。【Q】根据 Basic Paxos 算法，acceptor 只有在已经响应了更高的 proposal number 的情况下，才会拒绝 Accept 请求。所以好奇什么情况下会拒绝呢？<a href="https://www.beyondthelines.net/algorithm/multi-paxos/" target="_blank" rel="noopener">应该是当某一个新的 Leader 出现后</a>，它会发起一个更高的 Prepare，从而导致某个 acceptor 会开始拒绝 Accept 请求。<br>如果一个 Leader 从多数的 acceptor 处都收到了 <code>noMoreAccepted</code>，它就不再需要发送 Prepare 请求了。这个状态可能会被另一个当选的 Leader 打破，此时旧 Leader 会收到被拒绝的 Accept 请求。</p>
<h2 id="Fully-Replication"><a href="#Fully-Replication" class="headerlink" title="Fully Replication"></a>Fully Replication</h2><p>因为最终所有的 Log Entry 都需要过 RSM，所以要保证最终每个 Server 上的 Log 都是全的，并且他们知道哪些已经被 chosen 了。这通常包括两个目标：</p>
<ol>
<li>保证 Entry 最终在所有的机器上被复制，但目前只保证了 majority。</li>
<li>保证所有的 Server 都能知道某个 Entry 是否被 chosen。这样所有的 Server 才能及时跟进 Leader 的状态机。<br> 目前只有对应的 proposer 知道。因为 proposer 需要向 majority 个 acceptor 发送 Accept。</li>
</ol>
<p>下面是解决方案，一共有四个措施，但其实大部分措施都是为了处理就 Leader 宕机的情况。</p>
<h3 id="措施1：Proposer-需要不断地重复-Accept-请求，直到所有的-acceptor-都回复"><a href="#措施1：Proposer-需要不断地重复-Accept-请求，直到所有的-acceptor-都回复" class="headerlink" title="措施1：Proposer 需要不断地重复 Accept 请求，直到所有的 acceptor 都回复"></a>措施1：Proposer 需要不断地重复 Accept 请求，直到所有的 acceptor 都回复</h3><p>当已经复制玩 majority 后，这个操作就可以在后台完成了。<br>这个策略保证了在这个 Server 上创建的大部分新 entry 都能给复制到其他 Server 上。但还是不充分的，原因是考虑当 Proposer 宕掉时，他未必能够将所有的 Entry 都进行复制。其实我还认为就算复制过去，但对方还是不知道这个 entry 是否可以 chosen 啊。</p>
<h3 id="措施2：跟踪所有被-chosen-的-Entry"><a href="#措施2：跟踪所有被-chosen-的-Entry" class="headerlink" title="措施2：跟踪所有被 chosen 的 Entry"></a>措施2：跟踪所有被 chosen 的 Entry</h3><p>每个 Server 对自己知道的，已经被 chosen 的 Entry 设置 <code>acceptedProposal[i]=INF</code>，INF 也是能够无缝适配协议的，因为不可能存在一个更大的 proposal number 来 overwrite 掉这个 proposal 了。<br>每个 Server 维护一个 <code>firstUnchosenIndex</code>，也就是在“维护一个Log”中介绍的那个。</p>
<h3 id="措施3：-Proposer-将自己的-firstUnchosenIndex-附加在-Accept-请求中发送"><a href="#措施3：-Proposer-将自己的-firstUnchosenIndex-附加在-Accept-请求中发送" class="headerlink" title="措施3： Proposer 将自己的 firstUnchosenIndex 附加在 Accept 请求中发送"></a>措施3： Proposer 将自己的 firstUnchosenIndex 附加在 Accept 请求中发送</h3><p>这样，一个 Accept 请求具有下面的结构。表示 3.4 这个 proposal，设置 index = 8 处的 Value 为 v，并且 proposer 处第一个没标记为 chosen 的是 index = 7。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request = Accept(proposal=3.4, index=8, value=v, firstUnchosenIndex=7)</span><br></pre></td></tr></table></figure>

<p>而 acceptor 会对每个 <code>Entry[i]</code> 进行如下的检查，如果下面两个条件被满足，那么就将 <code>Entry[i]</code> 标记为 chosen。</p>
<ul>
<li><code>i &lt; request.firstUnchosenIndex</code></li>
<li><code>acceptedProposal[i] == request.proposal</code></li>
</ul>
<p>下面说的 Leader 指的是当前唯一能发送 proposal 的 proposer。在前面章节，我们论述了为什么要引入 Leader，以及如何选出一个 Leader。</p>
<p>为了解释这种情况，我们查看下面的这个例子。下图中，每个格子里面的数字指的是 proposal number。容易看到，在处理 Accept 请求前，这台 Server 上的 Entry 1/2/3/5 已经被 chosen 了。<br><img src="/img/paxos/26.a.png"><br>现在，来自 Leader 的一个 Accept 请求告知 <code>firstUnchosenIndex=7</code>，意味着在 Leader 上，Entry1 到 Entry6 都被 chosen 了。此时 acceptor 扫描自己上面所有的 unchosen entry，如果发现这些 entry 具有和 Leader 发来的 proposal number，这里即 3.4 一样的 proposal number，则将对应 entry 设置为 chosen。对应下图中，就是将 Entry6 设置为 chosen。<br><img src="/img/paxos/26.b.png"></p>
<p>然后我们有几个疑问：</p>
<ol>
<li>Entry 6 为什么可以被标记为 chosen？<br> 首先这个 acceptor 知道 Entry 6 也是来自于发送这个 Accept 的 Leader，即是这个 Leader 写入的。<br> 但这还不够，有关于 Entry 6 的具有另外一个值的 Accept 请求呢？我想这样的话，proposal number 一定会变得更大。但既然能 accept 这个 <code>3.4</code> 的请求，说明 3.4 这个 proposal number 是最新的。<br> 那么，既然这个 entry 是当前 Leader 写入的，并且 Leader 说它已经被 chosen 了，而这个 Leader 又是最新的，那被 chosen 的这个值一定就是 acceptor 日志里面的这个值。<br> 【Q】同一个 Leader 会发送 Entry 6 上具有另外一个值的 Accept 请求么？我觉得应该不会，新的写入应该对应新的 Entry 啊。</li>
<li>Entry 4 为什么不能被标记为 chosen？<br> 因为 Entry 4 具有不同于 3.4 的 proposal number，也就是说来自于另外一个 Leader。所以没办法像 Entry 6 一样确定这不是一个陈旧的数据。也就是说，这个 accpetor 知道 Entry 4 被 chosen 了，但是并不知道这个被 chosen 的 Value 是不是自己 Log 里面的那个 Value。因为在 “Split Votes” 中提到，acceptor 可以 accept 不同的 value，所以很可能这个值又被改了。<br> 那么后续这个 Entry 怎么办呢？往后看。</li>
<li>Entry 7 是怎么回事？为什么我们收到的 Accept 请求是写 Entry 8 而不是空的 Entry 7 的呢？</li>
</ol>
<h3 id="措施4：Success-RPC"><a href="#措施4：Success-RPC" class="headerlink" title="措施4：Success RPC"></a>措施4：Success RPC</h3><p>acceptor 会在对 Accept 消息的返回中附带上自己的 <code>firstUnchosenIndex</code>，当 Proposer 收到该 acceptor 返回后会将该值和自己的 <code>firstUnchosenIndex</code> 进行比较。如果 acceptor 的 <code>firstUnchosenIndex</code> 小于自己的，说明这个 acceptor 落后了，此时需要在后台发送 Success RPC。<br>这个 RPC 需要包含 index 以告知是那个 Entry 被 chosen 了，并且附带上一个 <code>v</code> 表示被 chosen 的值。当 acceptor 收到这个消息后，将：</p>
<ol>
<li><code>acceptedValue[index]=v</code></li>
<li><code>acceptedProposal[index]=INF</code></li>
<li>返回新的 <code>firstUnchosenIndex</code> 给 Proposer，Proposer 会根据这个值判断是否需要再次发送 Success RPC</li>
</ol>
<p>发送的 <code>firstUnchosenIndex</code> 有点类似于 Raft 中的 leaderCommit。</p>
<h3 id="Leader-缺少日志问题"><a href="#Leader-缺少日志问题" class="headerlink" title="Leader 缺少日志问题"></a>Leader 缺少日志问题</h3><h2 id="Paxos-和-Raft-的比较"><a href="#Paxos-和-Raft-的比较" class="headerlink" title="Paxos 和 Raft 的比较"></a>Paxos 和 Raft 的比较</h2><p>Raft 可以被视为去掉 propose 阶段的 Multi Paxos。这是因为：</p>
<ol>
<li>Raft 借助于日志选主，而不需要 propose 环节来竞争一个 propose number 了。</li>
<li>Paxos 中可以 accept 不同的值，这也对应了 Raft 中新的 Leader 会把老 Leader 复制的日志覆盖掉的情况。</li>
<li>Raft 中会拒绝来自更低的 term 的 Leader 日志。这对应 acceptor 会拒绝掉更低的 Propose Number。</li>
<li>Success RPC 类似于 leaderCommit 和对应的日志的 AppendEntries</li>
</ol>
<h2 id="Client协议"><a href="#Client协议" class="headerlink" title="Client协议"></a>Client协议</h2><p>这一部分和 Raft 一样，非 Leader 的 Server 会把请求转发给 Leader。同样的，Leader 也会在 Client 提交的命令被 chosen 以及被 RSM 执行之后，才会返回。<br>如果请求超时，例如 Leader 宕机了，那么 Client 会将命令发送给其他 Server，在最终发现新Leader后，重试命令。</p>
<h3 id="如何保证Exact-once语义"><a href="#如何保证Exact-once语义" class="headerlink" title="如何保证Exact once语义"></a>如何保证Exact once语义</h3><p>这个问题通常发生在当老 Leader 在执行完自己的状态机后、返回给 Client 前宕机。根据上面的论述，Client 实际上会通过另一个 Leader 重试，在这种情况下，可能同样的命令就会被执行两次。其实这种情况在我实现 Raft 协议的时候也遇到过。</p>
<p>对此，演讲者建议 Client 对每个命令设置一个唯一的 ID。每个 Server 上的 RSM 都会自己记录一下自己执行过的最新的ID。那么当 RSM 在执行每个命令的时候，会首先检查它是否已经被执行过，如果被执行过了就忽略，并且返回当时的结果。这种策略的要求是 Client 不挂，因为 ID 是由 Client 设置的。</p>
<h2 id="配置变更"><a href="#配置变更" class="headerlink" title="配置变更"></a>配置变更</h2><p>包含：</p>
<ol>
<li>每个 server 的 ID、addr</li>
<li>定义什么组成一个 majority，例如节点的上下线等</li>
</ol>
<p>Conf Change 的难点是它会改变 majority。</p>
<p>Paxos 的配置变更的思路是：</p>
<ol>
<li>配置被作为 log entry 来存储，并按照 log entry 来复制</li>
<li>用来 choose Entry i 的配置由 i-α 决定</li>
</ol>
<p>因此：</p>
<ol>
<li>α 控制了并发度。i+α 只有在 i 被 chosen 之后才会被 chosen。</li>
</ol>
<h1 id="Disk-Paxos"><a href="#Disk-Paxos" class="headerlink" title="Disk Paxos"></a>Disk Paxos</h1><p><a href="https://lamport.azurewebsites.net/pubs/disk-paxos.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/pubs/disk-paxos.pdf</a></p>
<p>Disk Paxos 的核心思想是将 Paxos 算法的状态（如提议号、值等）存储在共享磁盘上。只要有大多数的磁盘还存活，那么算法的一致性就能得到保证。前提是至少有一个 CPU 也存活。</p>
<h1 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h1><h2 id="幽灵日志"><a href="#幽灵日志" class="headerlink" title="幽灵日志"></a>幽灵日志</h2><h3 id="第三态"><a href="#第三态" class="headerlink" title="第三态"></a>第三态</h3><p><strong>超时就是分布式系统中除了“成功”和“失败”之外的第三态</strong>，对于客户端而言，我们并不知道到底是成功还是失败：</p>
<ol>
<li>如果是在处理过程中，因为分区、宕机等因素导致的没有 Commit 成功，这个也许是失败；</li>
<li>如果是在 Commit 和 Apply 成功之后，返回客户端时宕机或者分区了，这个应当认为是成功。</li>
</ol>
<h3 id="一个case"><a href="#一个case" class="headerlink" title="一个case"></a>一个case</h3><ol>
<li>A被选为Leader，写日志1-10，其中1-5已经Commit和Apply，并返回给客户端。</li>
<li>A宕机，但6-10没有被Commit和Apply，因此客户端会超时。</li>
<li>B选为Leader。B应当从6开始写新的日志，此时客户端无法查到6-10号日志，因为它们还没提交。</li>
<li>B提交了6和20号日志，并返回给客户端，但随后又宕机了。</li>
<li>此时A又被选为Leader。</li>
</ol>
<p>此时，A如果想要Propose，肯定会发现自己得先补空洞，这就是类似“维护一个Log”章节中的操作：</p>
<ol>
<li>针对日志6，A去跑一遍Basic Paxos，因为实际上这条日志已经被Chosen了，所以A也会接受被多数派认可的日志。</li>
<li>针对日志7-10，A是有本地日志的，但并没有被chosen，于是A会尝试提交本地日志。</li>
<li>针对日志11-19，A没有本地日志，所以这边就都是Noop。</li>
<li>针对日志20，也是接受被多数派认可的日志。</li>
</ol>
<p>现在从时间的角度考虑日志7-10。在A宕机后，客户端超时了，实际上是陷入了第三态。这有什么问题呢？我们考虑这是个转账场景，客户发现第一次超时了，可能就会重试。此时A从宕机恢复过来，又把7-10给补上了，这就很可能导致用户重复转了两次账。</p>
<p>那么如何解决这个问题呢？朴素的想法就是“前任Leader留下的烂摊子，如果我不确定是不是可以Commit的，那么我就不能直接Commit它”。回过头来会发现，这个和Raft中新Leader不能直接提交来自较旧Leader的日志一样。</p>
<p>对于MultiPaxos而言，yubai老师的方案其实是类似的，也就是给每个Leader赋一个term，因为MultiPaxos的Leader不进行Propose，所以这个term就可以用proposal number。在补漏洞的过程中，要忽略掉term比自己小的日志。</p>
<h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="官方习题"><a href="#官方习题" class="headerlink" title="官方习题"></a>官方习题</h2><p>来自于Raft作者的博客。</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下面哪些日志是可能存在的？<br><img src="/img/paxos/q1.png"></p>
<ol>
<li>这个应该是个标准情况，肯定是可以的。</li>
<li>也是可以的</li>
<li>也是可以的，Paxos容许日志缺失</li>
<li>也是可以的</li>
</ol>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在 Basic Paxos 中，考虑在一个5节点的集群中，有三个 acceptor 接受了 <code>proposal(5.1, X)</code> ，在此之后，是否可能有某些机器去 accept 另一个 Value Y 呢？</p>
<p>这个问题并没有挑战，如果在一个时间节点中存在 majority 个节点都 accept 了一个 proposal，是不是可以立刻认为这个 proposal 被 chosen？因为 accept 另一个 Value 的机器只会在小分区中。所以存在这个情况，并不和判定 chosen 的规则矛盾。</p>
<p>注意，这里的proposal number由<code>round_number.server_id</code>这样的方式构成。</p>
<p>答案是可能的。</p>
<p>我们知道，只要一个 acceptor 回复了 <code>Prepare(5.1)</code>，那么他就不可能去 <code>Accept(3.4,Y)</code> 或者 <code>Prepare(3.4,Y)</code> 了。所以如果这个可能发生，那么 <code>Prepare(3.4)</code> 一定要在 <code>Prepare(5.1)</code> 之前。<br>于是，我们尝试下面的顺序：</p>
<ol>
<li>P4: <code>Prepare(3.4)</code><br> 发送到 S1/S2/S3/S4/S5。</li>
<li>S4/S5/S1 和 S2/S3 发生分区</li>
<li>P1: <code>Prepare(5.1)</code><br> 发送到 S4/S5/S1。因为分区，没给 S2/S3。<br> 因为 5.1 更大，所以 S4/S5/S1 会保证不会再 accept 小于 5.1 的请求。因为目前 S4/S5/S1 没有 accept 任何 proposal，所以返回的“最大的小于 <code>n</code> ”的 proposal 为空。</li>
<li>P2: <code>Accept(5.1,X)</code><br> 发送到 S4/S5/S1。因为分区，没给 S2/S3。</li>
<li>P1: <code>Accept(3.4,Y)</code><br> 发送到 S2/S3。<br> 由于分区，所以 S2/S3 没有回复 <code>Prepare(5.1)</code>，更别说 <code>Accept(5.1,X)</code> 了。所以它能够接受请求 <code>Accept(3.4,Y)</code>。</li>
</ol>
<p>官方答案：</p>
<blockquote>
<p>Yes. If it’s S1, S2, and S3 that have accepted &lt;5.1, X&gt;, other servers could still accept Y if it has a stale proposal number.<br>For example, S4 could prepare 3.4 and discover no values. Then S1 could prepare 5.1 on just S1, S2, S3. Then S1 could<br>complete accepts on just S1, S2, S3. And S4 can still complete accepts on S4 and S5 with &lt;3.4, Y&gt;.</p>
</blockquote>
<p>【Q】不过如果 S2/S3 从分区中恢复后，会将自己的值改成5.1对应的值么？不然是不是不能从这些节点 LocalRead 了？</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>在 MultiPaxos 中，如果一个 Server 刚变成 Leader，并且此时没有其他 Server 是 Leader。进一步地，假设这个 Server 继续是 Leader 一段时间，其中 chosen 了一系列 Entry，并且在这段时间中没有其他 Server 成为 Leader。</p>
<ol>
<li>这个 Server 最少需要发送几轮 Prepare？<br> 我觉得最少只要一轮，在这一轮中大家都 Accept了，并且返回 <code>noMoreAccepted</code>。</li>
<li>这个 Server 最多需要发送几轮 Prepare？<br> 这个我没啥 idea，答案说统计 Leader 上面所有满足下面条件的 Entry，那么就需要一条 Prepare<ol>
<li>还没有被 Leader 标记为 chosen；</li>
<li>曾经被某个 acceptor 接受。<br>这个过程通常是这样的，Leader 向该这个 Entry 发送一个 Prepare，然后发现这个 Entry 已经被某个 acceptor 接受了，因此它去促使这个 Entry 最终被 chosen，并且在这之后去尝试去 Prepare 下一个 Entry。这个也对应了不断递增 <code>firstUnchosenIndex</code>，找到合适的可添加 Entry 的 slot 的过程。</li>
</ol>
</li>
</ol>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>如果一个 acceptor 通过来自 proposer 的 <code>firstUnchosenIndex</code> 知道了某个 Entry 被 chosen 了，它必须先比较自己 Entry 里面的 proposal number 是不是和这个 proposer 匹配。说明这个比较是不是必要的，并解释。</p>
<p>这个肯定是必要的，原因在“Entry 4为什么不能被标记为chosen”里面解释过了。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>考虑 proposal number 的两个部分被对调了，即现在变成<code>server_id.round_number</code>，那么：</p>
<ol>
<li>是否会影响算法的 Safety<br> 我觉得是有影响的，每个 proposer 会维护单独的 <code>server_id</code>，那么对于1号机器，它的 proposal number 始终是小于2号机器的，无论它如何自增 id。<br> 但答案是说没有影响的，因为在 MultiPaxos 中只要求 proposal number 是唯一的，这时候因为 <code>server_id</code> 是唯一的而 <code>round_number</code> 是自增的，所以 proposal number 是唯一的。</li>
<li>是否会影响算法的 Liveness<br> 看答案，是会的。例如具有较大 <code>server_id</code> 的 proposer 会发送一个 Prepare 请求给每个 acceptor，然后永远地宕机了。此时其他的 proposer 就无法再行动了，因为 acceptor 上的 <code>minProposal</code> 值对这些 proposer 来说太高了。</li>
</ol>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>假定一个 proposer 打算执行 <code>Accept(n,v1)</code>，但在某个时间点宕掉了，如果这个 proposer 重启并且打算执行 <code>Accept(n,v2)</code>，这个是否安全呢？</p>
<p>这个在<em>Paxos made simple</em>中就明确指出是不可以的。</p>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>在一个成功的Accept请求中，acceptor设置<code>minProposal</code>为<code>n</code>（即Accept请求中的proposal number）。描述一种场景，此时这个行为确实改变了<code>minProposal</code>的值，例如在这之前<code>minProposal</code>并不是<code>n</code>。描述如果没有这个操作，系统会出现问题的一个场景。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>Consider a configuration change in Multi-Paxos, where the old configuration consists of servers 1, 2, and 3, and the new configuration consists of servers 3, 4, and 5. Suppose that the new configuration has been chosen for entry N in the log, and entries N through N+α (inclusive) have also been chosen. Suppose that at this point the old servers 1 and 2 are shut down because they are not part of the new configuration. Describe a problem that this could cause in the system.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>Paxos Made Simple</li>
<li>Paxos Summary</li>
<li>The part-time parliament</li>
<li><a href="https://zhuanlan.zhihu.com/p/278054304" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/278054304</a></li>
<li><a href="https://www.bilibili.com/video/BV1WW411a77S/?spm_id_from=333.788.videocard.13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1WW411a77S/?spm_id_from=333.788.videocard.13</a></li>
<li><a href="http://oceanbase.org.cn/?p=90" target="_blank" rel="noopener">http://oceanbase.org.cn/?p=90</a><br> yubai大佬的日志，描述了如何基于Basic Paxos去维护多个Log Entry</li>
<li><a href="http://oceanbase.org.cn/?p=111" target="_blank" rel="noopener">http://oceanbase.org.cn/?p=111</a><br> yubai大佬的日志，描述了Multi Paxos</li>
<li><a href="https://ongardie.net/static/raft/userstudy/quizzes.html" target="_blank" rel="noopener">https://ongardie.net/static/raft/userstudy/quizzes.html</a><br> paxos习题</li>
<li><a href="https://ongardie.net/static/raft/userstudy/rubric.pdf" target="_blank" rel="noopener">https://ongardie.net/static/raft/userstudy/rubric.pdf</a><br> 习题解答</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/分布式/" rel="tag"># 分布式</a>
          
            <a href="/tags/raft/" rel="tag"># raft</a>
          
            <a href="/tags/论文阅读/" rel="tag"># 论文阅读</a>
          
            <a href="/tags/paxos/" rel="tag"># paxos</a>
          
            <a href="/tags/一致性/" rel="tag"># 一致性</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/12/13/gcc-glibc-compile/" rel="next" title="GCC 和 GLIBC编译">
                <i class="fa fa-chevron-left"></i> GCC 和 GLIBC编译
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/01/06/bash/" rel="prev" title="Bash介绍">
                Bash介绍 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">235</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic-Paxos-Lamport"><span class="nav-number">1.</span> <span class="nav-text">Basic Paxos(Lamport)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#论证1"><span class="nav-number">1.1.</span> <span class="nav-text">论证1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P1"><span class="nav-number">1.1.1.</span> <span class="nav-text">P1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2"><span class="nav-number">1.1.2.</span> <span class="nav-text">P2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2a"><span class="nav-number">1.1.3.</span> <span class="nav-text">P2a</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2b"><span class="nav-number">1.1.4.</span> <span class="nav-text">P2b</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#论证2"><span class="nav-number">1.2.</span> <span class="nav-text">论证2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P2c"><span class="nav-number">1.2.1.</span> <span class="nav-text">P2c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#论证3"><span class="nav-number">1.3.</span> <span class="nav-text">论证3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proposer-算法-Step1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Proposer 算法 Step1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proposer-算法-Step2"><span class="nav-number">1.3.2.</span> <span class="nav-text">Proposer 算法 Step2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Acceptor-算法"><span class="nav-number">1.3.3.</span> <span class="nav-text">Acceptor 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#持久化要求"><span class="nav-number">1.3.4.</span> <span class="nav-text">持久化要求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算法"><span class="nav-number">1.4.</span> <span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-1：Prepare"><span class="nav-number">1.4.1.</span> <span class="nav-text">Phase 1：Prepare</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Phase-2：Accept"><span class="nav-number">1.4.2.</span> <span class="nav-text">Phase 2：Accept</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Learner"><span class="nav-number">1.5.</span> <span class="nav-text">Learner</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#活锁问题"><span class="nav-number">1.6.</span> <span class="nav-text">活锁问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现"><span class="nav-number">1.7.</span> <span class="nav-text">实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现状态机"><span class="nav-number">1.8.</span> <span class="nav-text">实现状态机</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic-Paxos-Ongaro"><span class="nav-number">2.</span> <span class="nav-text">Basic Paxos(Ongaro)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Basic-Paxos-的图解"><span class="nav-number">2.1.</span> <span class="nav-text">Basic Paxos 的图解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Split-Votes讨论"><span class="nav-number">2.2.</span> <span class="nav-text">Split Votes讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proposal-Number"><span class="nav-number">2.2.1.</span> <span class="nav-text">Proposal Number</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Paxos-算法"><span class="nav-number">2.3.</span> <span class="nav-text">Paxos 算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种Prepare顺序讨论"><span class="nav-number">2.4.</span> <span class="nav-text">三种Prepare顺序讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-当值X已经被chosen"><span class="nav-number">2.4.1.</span> <span class="nav-text">1. 当值X已经被chosen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-当值X没有被chosen，但新的proposer能够看到"><span class="nav-number">2.4.2.</span> <span class="nav-text">2. 当值X没有被chosen，但新的proposer能够看到</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-当值X没有被chosen，新的proposer也看不到"><span class="nav-number">2.4.3.</span> <span class="nav-text">3. 当值X没有被chosen，新的proposer也看不到</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-Paxos-Ongaro"><span class="nav-number">3.</span> <span class="nav-text">Multi Paxos(Ongaro)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#维护一个Log"><span class="nav-number">3.1.</span> <span class="nav-text">维护一个Log</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#提升性能的办法"><span class="nav-number">3.2.</span> <span class="nav-text">提升性能的办法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader"><span class="nav-number">3.3.</span> <span class="nav-text">Leader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选举"><span class="nav-number">3.3.1.</span> <span class="nav-text">选举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#减少Prepare"><span class="nav-number">3.3.2.</span> <span class="nav-text">减少Prepare</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fully-Replication"><span class="nav-number">3.4.</span> <span class="nav-text">Fully Replication</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#措施1：Proposer-需要不断地重复-Accept-请求，直到所有的-acceptor-都回复"><span class="nav-number">3.4.1.</span> <span class="nav-text">措施1：Proposer 需要不断地重复 Accept 请求，直到所有的 acceptor 都回复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#措施2：跟踪所有被-chosen-的-Entry"><span class="nav-number">3.4.2.</span> <span class="nav-text">措施2：跟踪所有被 chosen 的 Entry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#措施3：-Proposer-将自己的-firstUnchosenIndex-附加在-Accept-请求中发送"><span class="nav-number">3.4.3.</span> <span class="nav-text">措施3： Proposer 将自己的 firstUnchosenIndex 附加在 Accept 请求中发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#措施4：Success-RPC"><span class="nav-number">3.4.4.</span> <span class="nav-text">措施4：Success RPC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Leader-缺少日志问题"><span class="nav-number">3.4.5.</span> <span class="nav-text">Leader 缺少日志问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Paxos-和-Raft-的比较"><span class="nav-number">3.5.</span> <span class="nav-text">Paxos 和 Raft 的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Client协议"><span class="nav-number">3.6.</span> <span class="nav-text">Client协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#如何保证Exact-once语义"><span class="nav-number">3.6.1.</span> <span class="nav-text">如何保证Exact once语义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置变更"><span class="nav-number">3.7.</span> <span class="nav-text">配置变更</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Disk-Paxos"><span class="nav-number">4.</span> <span class="nav-text">Disk Paxos</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些讨论"><span class="nav-number">5.</span> <span class="nav-text">一些讨论</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#幽灵日志"><span class="nav-number">5.1.</span> <span class="nav-text">幽灵日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第三态"><span class="nav-number">5.1.1.</span> <span class="nav-text">第三态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个case"><span class="nav-number">5.1.2.</span> <span class="nav-text">一个case</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#习题"><span class="nav-number">6.</span> <span class="nav-text">习题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#官方习题"><span class="nav-number">6.1.</span> <span class="nav-text">官方习题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1"><span class="nav-number">6.1.1.</span> <span class="nav-text">1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2"><span class="nav-number">6.1.2.</span> <span class="nav-text">2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3"><span class="nav-number">6.1.3.</span> <span class="nav-text">3</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4"><span class="nav-number">6.1.4.</span> <span class="nav-text">4</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5"><span class="nav-number">6.1.5.</span> <span class="nav-text">5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6"><span class="nav-number">6.1.6.</span> <span class="nav-text">6</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7"><span class="nav-number">6.1.7.</span> <span class="nav-text">7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8"><span class="nav-number">6.1.8.</span> <span class="nav-text">8</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2021/01/06/paxos/';
          this.page.identifier = '2021/01/06/paxos/';
          this.page.title = 'Paxos算法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
