<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Fortran数组的C++实现]]></title>
      <url>%2F2017%2F01%2F18%2FFortran%E6%95%B0%E7%BB%84%E7%9A%84C%2B%2B%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++的工具，其中涉及到使用C++为Fortran实现一个数组库，其中关于C++元编程的部分我合并到了C++模板编程这篇文章中，其他的部分放在这里 for1array&lt;typename T&gt;for1array&lt;T&gt;是一个1维的数组，可以理解为对C++原生数组的一个包装，使得数组能够自定义上下界，和列优先的存储模式。事实上这种嵌套(nested)数组在实现Fortran的内在函数时存在相当大的麻烦。例如将初始化序列按列映射到一个嵌套的数组for1array&lt;for1array&lt;...for1array&lt;T&gt;...&gt;&gt; farr中，如果通过通常的递归来做，那么就要从结构最里面的for1array&lt;T&gt;进行递归，然而这是比较难于实现的。实际上解决方案对于嵌套的for1array数组按照通常一样从外到内进行递归遍历，而计算farr[a1][a2]...[an]时对应的一维序列中的位置。对于farr数组中的第k层的指针增加1，实际上相当于一维序列中向后移动size[1] * size[2] * ... size[k-1]，其中size[i]为farr中第i层的大小。但是对于transpose这样的函数使用嵌套数组实现的代价就相当大了，特别地，fortran90标准对转置秩大于2的数组并没有规定行为： 13.13.109 TRANSPOSE (MATRIX)Description. Transpose an array of rank two.Class. Transformational function.Argument. MATRIX may be of any type and must have rank two. 因此实际上对于一个N维/秩数组$X$，假设第$i$维的取值范围是$[0, n_i]$，定义转置$X^T$，满足$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$。 farray&lt;typename T, int D&gt;Fortran90标准中数组的维数，上下界都是确定的，即使出现的可调数组（类似于C99中的VLA）、假定形状数组（仅给出维/秩数）和假定大小数组（最后一维的上下界是不定的）也是作为哑元（形参的）。Fortran77标准更是使用完全静态环境(fully static environment)的运行时（编译原理及实践§7），因此都不支持递归调用。因此Fortran多维数组并不需要锯齿数组，也不需要实现类似动态表的自扩。因为要尽可能保证和源代码一致性，所以不能将上界统一改为0开始，在设计时需要使用在对象中维护每一维的上下界。有一些方法可以使得表示上下界的数组称为编译期常量，例如使用constexpr构造函数，不过我选择了牺牲一点空间，因为我使用的MSVC2015尚不支持Extended Constexpr。 实现transpose现在实现transpose函数，transpose函数主要是通过变换$n_i$和对应的一维序列，满足上面式子。对于原矩阵$X[a_1][a_2]…[a_n]$，可以映射到$X$对应的一维序列的第$\sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$项，令$\prod_{N + 1}^{N}{} = 1 $；对于转置后的矩阵$X^T[b_1][b_2]…[b_n]$，令其每一维大小为$n’_i $，可得$n’_i = n_{N + 1 - i}$，可以映射到$X^T$对应的一维序列的第$\sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$项，其中令$\prod_{1}^{0}{} = 1 $。根据$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$，带入$b_i = a_{N + 1 - i}$，可以得到映射规则$X: \sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$ $\Rightarrow$ $X^T: \sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$ = $\sum_{i=1}^{N}{(a_{N + 1 - i} \times \prod_{j = i + 1}}^{N}{n_{N + 1 - j}})$。以上是对于C-style的数组讨论的，对于Fortran-style的数组，将$\Sigma$的上下界改成$0 .. i - 1$此外，对于2维矩阵转置有$O(1)$空间的方法。 slice数组片段fortran中的slice是by reference的，对slice的修改也是对原数组的修改，于是要实现一个forslice函数，其返回的slice应当是数组片段的引用。对于这种情况，首先可以考虑使用vector&lt;shared_ptr&lt;T&gt;&gt; data来存储，但是这样会产生不必要的空间开销。因为虽然每一个slice是不一样的，没办法对shared_ptr&lt;vector&lt;T&gt;&gt; data，但是每个slice的data部分是作为一个整体的。所以还是使用的裸指针RAII，对于从forslice函数构造的farray，在构造时加一个tag，析构时不释放指针即可。考虑到Fortran77标准本身的完全静态环境，Fortran90可能是基于栈的，所以不会出现悬挂指针导致的AV错误。 数组的秩此外fortran中有使用到数组的秩作为参数（通常参数名为dim）的函数，要注意秩是从1开始计算的。 farray&lt;typename T&gt;fortran有一个slice操作，它返回的维数是不固定的，例如a(:, 1, 1:2)返回一个2维的数组，但是a(:, 1, 1:1)返回一个三维的数组，虽然这两个数组所承载的数据是一样的。这给实现带来了困难，因为返回类型是根据slice_info的初始化列表来决定的，为了追求语法尽可能简单，贴近fortran源码，对slice_info这样的工具类模板开洞我觉得是不太好的，因此决定将维数参数也移出模板参数。 array builderFortran中的数组构造器(array constructor)我认为是一个很方便实用的功能，根据Fortran90标准，数组构造器使用下面的语法 array-constructor is (/ ac-value-list /)R432 ac-value is expr or ac-implied-doR433 ac-implied-do is ( ac-value-list , ac-implied-do-control )R434 ac-implied-do-control is ac-do-variable = scalar-int-expr , scalar-int-expr [ , scalar-int-expr ]R435 ac-do-variable is scalar-int-variable 在翻译时，数组构造器应当被当作一个一维的数组。注意数组构造器在赋值和构造时都可能用到，所以比较方便的方法是对(/ /)直接生成farray而不是一个brace-init-list： An array constructor is defined as a sequence of specified scalar values and is interpreted as a rank-one arraywhose element values are those specified in the sequence. AST中的节点会碰到这样的问题，例如上面的数组生成器，可以生成一个NT_ARRAYBUILDER节点，所以NT_ARRAYBUILDER也是一个NT_EXPRESSION节点，而数组生成器是可以出现的等号右边构成表达式，于是也可以作为赋值式归约成NT_EXPRESSION节点。所以问题存在于直接将NT_ARRAYBUILDER立即归约成表达式NT_EXPRESSION节点还是当NT_ARRAYBUILDER和新的串构成例如赋值式时再归约成表达式。对于第一种方法，会在AST的深度方向产生较多的节点，在访问节点属性时比较麻烦，如果修改语法，可能也要修改语义处理程序对于第二种方法，容易在单独使用NT_ARRAYBUILDER的时候出现问题，例如使用if(X == NT_EXPRESSION)筛选NT_EXPRESSION节点时会因为NT_ARRAYBUILDER != NT_EXPRESSION造成被误筛掉]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++中static关键字的用法]]></title>
      <url>%2F2017%2F01%2F02%2FC%2B%2Bstatic%E7%94%A8%E6%B3%95%2F</url>
      <content type="text"><![CDATA[C++中static关键字比较复杂，常在不同的情景下出现。第一种是声明局部静态变量，第二种是声明静态函数，第三种是声明类的静态成员 声明局部静态变量此时static作为五种storage duration specifiers(auto, register, static, extern, thread_local)中的一种，static声明的静态变量（称为local static）相对于auto(C++11标准后auto关键字另作他用)声明的自动变量，它的生存空间是从所属模块（编译单元）开始全局的，并且能够保证在函数调用之前被初始化构造完成。但是相对于直接使用全局变量，将static置于全局函数内部并返回引用可以保证在任何访问该静态对象的时候，该对象都已完成初始化（可参见Effective C++），由此可以实现单例模式，称为Meyers’ Singleton。从C++11标准开始，Meyers’ Singleton是线程安全的，这是因为新的标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它，而在之前的标准中可能会产生多次初始化的结果。其他的单例模式还包括使用atomtic，和std::call_once，可以访问http://www.cnblogs.com/liyuan989/p/4264889.html来了解。 声明静态函数/变量表示该函数/变量名字只能在该编译单元内部使用，而不导出（可以尝试在多个cpp文件中定义相同名字的变量并编译来理解）。因此可以利用static实现在头文件中直接给出函数定义，也就是使用static修饰。但这是非常不好的做法，正确的做法应该是分情况使用constexpr或者inline。 声明类的静态成员]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++初始化方式(翻译)]]></title>
      <url>%2F2016%2F12%2F30%2FC%2B%2B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[C++11/114标准之后对初始化方式有了很多的变动，现在主要分为五种list initialization、aggregate initialization、zero initialization、default initialization、value initialization其中aggregate initialization可以看做list initialization的一个特例首先初始化和赋值是不一样的，例如bool b = 1;是初始化，bool b; b = 1;后一句是赋值。初始化和函数声明也要区分，例如std::vector&lt;int&gt; X()是一个函数声明，std::vector&lt;int&gt; X{}是从C++11标准以后的value initialization。 list initializationlist initialization是使用braced-init-list的初始化语句当一个类定义了从std::initializer_list的构造函数后，对于使用{}语法将调用该构造函数，例如std::vector&lt;int&gt;(10)创建10个元素并对每个元素进行zero initialization，std::vector&lt;int&gt;{10}创建一个值是10的元素。使用下面的初始化语句会导致list initialization direct-list-initialization Syntax T object { arg1, arg2, ... }; (1) T { arg1, arg2, ... }; (2) new T { arg1, arg2, ... } (3) Class { T member { arg1, arg2, ... }; }; (4) Class::Class() : member{arg1, arg2, ...} {... (5) copy-list-initialization Syntax T object = {arg1, arg2, ...}; (6) function( { arg1, arg2, ... } ) ; (7) return { arg1, arg2, ... } ; (8) object[ { arg1, arg2, ... } ] ; (9) object = { arg1, arg2, ... } ; (10) U( { arg1, arg2, ... } ) (11) Class { T member = { arg1, arg2, ... }; }; (12) narrow conversionnarrow conversion是下面的隐式转换 浮点数与整数互相转换 从高精度到低精度 list initialization主要规则list initialization的部分作用，来自cppreference第2、3、4条， 如果braced-init-list是空的 如果T是一个有默认构造函数的class，那么进行value initialization 如果T是个aggregate聚合类型，那么进行aggregate initialization 否则考虑匹配所有接受std::initializer_list作为唯一的或者唯一的非默认的参数的构造函数，首先匹配能精确匹配的，其次放宽要求匹配非narrow conversion的。 以下规则来自cppreference的notes部分 brace-init-list不是一个表达式，所以没有类型，因此模板类型推导不能直接推导出来。auto关键字会将所有的braced-init-list推导为std::initializer_list。 value initialization使用下面的初始化语句会导致value initialization Syntax T(); (1) new T (); (2) Class::Class(...) : member() { ... } (3) T object {}; (4) (since C++11) T{}; (5) (since C++11) new T {}; (6)(since C++11) Class::Class(...) : member{} { ... } (7) (since C++11) value initialization具有以下作用： 当一个class没有默认构造函数（包含使用了自定义的构造函数或者构造函数是delete），这个对象是default initialization 当一个class具有默认构造函数，这个对象先zero initialization，如果有non-trival的默认构造函数，再调用该默认构造函数进行default initialization value initialization对于数组中的每个元素进行value initialization zero initialization使用下面的初始化语句会导致zero initialization Syntax static T object ; (1) T () ; (2) (since C++11) T t = {} ; (2) (since C++11) T {} ; (2) (since C++11) char array [ n ] = &quot;&quot;; (3) zero initialization适用以下情景： static和thread local的有名字的变量在其他初始化前先进行zero initialization 作为非class类型和使用value initialization初始化无构造函数的class的成员的过程的一部分 字符数组初始化时未初始化部分被zero initialization zero initialization具有以下作用： 当T是一个scalar type标量类型，用0值来初始化 如果T是一个非union联合的class，所有的基类和非静态成员进行zero initialize，所有padding被初始化为0，并不考虑构造函数 如果T是一个union联合，第一个非静态成员用0值初始化，所有padding被初始化为0 如果T是一个数组，数组中的每个元素被zero initialize 如果T是一个引用，不做任何事情 default initializationdefault initialization发生在当一个变量未使用initializer(the initial value of a variable)构造，特别地，从C++11标准以后空的圆括号不算做未使用initializer。详情可以参照下面的初始化语句使用下面的初始化语句会导致default initialization Syntax T object ; (1) new T ; (2) new T () ; (2) (until c++03) default initialization适用以下情景： 当一个变量的存储方式是auto、static、thread_local（注：还有两种是register和extern，详见storage duration specifiers），并且没有initializer 当一个变量具有dunamic storage duration，特别地，C++11标准后使用空圆括号（类似std::vector&lt;int&gt; a()）不算做默认初始化 当基类和非静态成员不在某个构造函数的construct initializer list（类似:a(_a), b(_b), c(_c)）中时 default initialization按照以下规则： aggregate initializationaggregate initialization是list initialization的特例C++17标准对于public base的情况有一些修订，这里省略了部分，而说明C++14标准 aggregate（聚合）类型聚合类型包括： 数组 特定的类 没有private或protected非静态成员 没有用户提供的（since C++17, 继承的、显式的）构造函数，但是可以有=default或者=delete 没有virtual、private或protected的基类 没有虚成员函数 aggregate initialization规则 对于数组或者非静态成员（静态成员和未命名的位域被跳过），按照声明顺序或者下标顺序，使用initializer list中对应的initializer clause进行copy-initialization 如果对应的clause是个表达式，可以进行非narrowing conversion的隐式转换（参见list-initialization） 如果对应的clause是一个嵌套的braced-init-list（这就不算是表达式了），使用list-initialization进行初始化 初始化未知长度的数组通过braced-init-list的长度确定 如果braced-init-list的长度超过了，是ill-formed，并产生编译错误 长度不足的情况 1.（C++11前）剩下来的采用value-initialization 2.（C++14）对于剩下来的member，如果该member的class提供default-initializer，采用default-initializer，否则采用空列表初始化（和list-initialization一样） 特别地，如果里面有引用，则是ill-formed]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++模板编程]]></title>
      <url>%2F2016%2F12%2F22%2FC%2B%2B%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[最近使用C++实现了一些fortran的内部函数和STL，其中遇到了一些问题 注意事项引用列表vector放引用应当使用reference_wrapper，不过挺恶心的，因为不能重载operator.的缘故，必须得get()一下 operator重载operator=、operator()、operator[]、operator-&gt;、operator T不能作为non-member function，这是因为担心与自动合成的operator=出现行为不一致的问题 初始化类中的const成员在构造函数的初始化列表中可以进行初始化，对于常量数组，可以使用{}进行初始化在MSVC2015中，下面的代码是无法通过编译的123456789101112struct C &#123; const int x; C(int _x) :x(_x) &#123; &#125;&#125;;int main() &#123; const C c(1); int a[c.x]; system("pause");&#125; 原因是在C.x虽然是常量，但是要到运行期才能知道，事实上只用const修饰的类成员仍然是占空间的，const节省空间的意义是由于其不可变，所以发生拷贝时，const对象实际上并不发生复制 函数模板特化全特化函数模板和同签名的普通函数对于全特化的函数模板，它和不加template&lt;&gt;的普通函数有什么区别呢？根据C++ Premier中的说明 当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的 template&lt;&gt;特化函数模板比普通函数匹配更为精确，比如123456789101112131415161718// #1 template&lt;typename T&gt;void promotion(T x, T y) &#123; puts("template");&#125;// #2 template&lt;&gt;void promotion(double x, double y) &#123; puts("template&lt;&gt;");&#125;// #3void promotion(double x, int y) &#123; puts("function");&#125;int main()&#123; promotion(1, 1.0); promotion(1.0, 1.0);&#125; main中第1条语句输出&quot;function&quot;，因为1是int，不能精确匹配2号函数的两个double，所以只能匹配到3号函数main中第1条语句输出&quot;template&lt;&gt;&quot;，这时候两个参数都是double，于是2号函数更精确了。又例如将3号和main改为12345678// #3void promotion(double x, double y) &#123; puts("function");&#125;int main() &#123; promotion(1, 1.0);&#125; 首先根据上面的结论，1号模板函数肯定是匹配不了的，注释掉2，得到输出是function，这是因为第一个参数1被隐式转换成1.0了注释掉3，得到编译错误，因为特化模板要精确匹配 “偏特化”函数需要注意的是，函数模板不能偏特化，如果需要使用“偏特化的函数模板”，考虑在一个偏特化类中实现static函数。这又带来一个新的问题，考虑要偏特化一个类中成员函数，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考这里的说明，这里另外给出对于非类型模板参数的写法例如现在需要判断一个关于类型T的D维矩阵中维数D是否为1，可以这样写123456789101112typedef typename std::conditional&lt;D == 1, std::true_type, std::false_type&gt;::type is_vector;farray&lt;T, D&gt; &amp; _pluseq_impl(const farray&lt;T, D&gt; &amp; x, std::true_type) &#123; cout &lt;&lt; "true" &lt;&lt; endl; return *this;&#125;farray&lt;T, D&gt; &amp; _pluseq_impl(const farray&lt;T, D&gt; &amp; x, std::false_type) &#123; cout &lt;&lt; "false" &lt;&lt; endl; return *this;&#125;farray&lt;T, D&gt; &amp; operator+=(const farray&lt;T, D&gt; &amp; x) &#123; return _pluseq_impl(x, is_vector());&#125; 可以发现实际上可以根据函数的重载而不是“偏特化”来实现上面的功能。 此外，模板函数一旦全特化，就应当和对待普通函数一样，使用inline，static，extern关键字防止重复包含 使用void_t实现Expression SFINAE模板偏特化是相对原型（primary template）模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板SFINAE(Substitution Failure Is Not An Error)是C++的模板编译规则，当推导模板参数（注意在函数内部使用ill-formed会导致hard error）失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。于是可以通过人为构造ill-formed的表达式或者类型来实现一些功能。1234567// https://www.zhihu.com/question/34264462template&lt;typename Cont, typename = void&gt; struct has_push_back : std::false_type &#123;&#125;;template&lt;typename Cont&gt;struct has_push_back&lt;Cont, std::void_t&lt;decltype(&amp;Cont::push_back)&gt;&gt; : std::true_type &#123;&#125;; 始终对std::vector&lt;int&gt;断言失败。后来查看SoF以为是MSVC2015对std::void_t的支持有问题。后来在SoF的另一篇博文上发现如果不是选择成员函数，而是选择数据成员就可以通过12345678910111213141516171819template&lt; class , class = void &gt;struct has_member : std::false_type&#123; &#125;;// specialized as has_member&lt; T , void &gt; or discarded (sfinae)template&lt; class T &gt;struct has_member&lt; T , void_t&lt; decltype( T::member ) &gt; &gt; : std::true_type&#123; &#125;;class A &#123;public: int member;&#125;;class B &#123;&#125;;static_assert( has_member&lt; A &gt;::value , "A" );static_assert( has_member&lt; B &gt;::value , "B" ); 后来去SoF上问了一波，这是因为std::vector&lt;int&gt;::push_back有多个重载版本，于是应该还要匹配函数签名。这样就可以了。关于这种expression sfinae，可以参考这个回答但是这样还有个问题，例如1234567891011template&lt;typename _Container_value_type, typename = void&gt;void getsize_impl(const for1array&lt;_Container_value_type&gt; &amp; farr) &#123;&#125;template&lt;typename _Container_value_type, typename = std::void_t&lt; decltype(std::declval&lt;_Container_value_type&gt;().size()) &gt;&gt;void getsize_impl(const for1array&lt;_Container_value_type&gt; &amp; farr) &#123;&#125;template&lt;typename _Container_value_type&gt;void getsize(const for1array&lt;_Container_value_type&gt; &amp; farr) &#123; getsize_impl&lt;_Container_value_type&gt;(farr);&#125; 这样会出现函数模板已经定义的错误。在cppreference中给出了说明 A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal. 此外在SoF 上给出了如下说明 SFINAE only works for deduced template arguments 此外，实际上编译器不需要指定特化就可以区分匹配下面的两个函数1234567891011template&lt;typename Cont&gt; void for1array_init(Cont &amp; farr) &#123; puts("not array");&#125;;template&lt;typename Cont&gt; void for1array_init(for1array&lt;Cont&gt; &amp; farr) &#123; puts("array"); for1array_init&lt;typename Cont::value_type&gt;(farr(1)); // 报错，因为typename Cont::value_type是ill-fromed for1array_init(farr(1)); // 得到正确结果&#125;; 编译错误是因为编译器会对typename Cont::value_type这个ill-formed求值报错，而不是重新使用上面的primary template推导，因此只可以在模板参数里写出要有value_type，这样的”concept”。例如下面的用法同样也是错的1234template &lt;typename T&gt;struct for1array_gettype2 &#123; typedef std::conditional&lt;is_for1array::test&lt;T&gt;(nullptr), typename for1array_gettype&lt;typename T::value_type&gt;::type, T&gt; type;&#125;; 判断模板参数是否是广义函数目前广义函数包括函数、std::function、lambda、仿函数，其中std::is_function只能识别函数。c++17标准添加了std::is_callable，现在考虑C++14标准。 实现member function的const版本有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据stackoverflow，可以直接const_cast this指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改费mutable成员，那么可以实现一个static非成员模板函数，将this传进去 将带类型推导的lambda传给std::function返回值不是函数签名的一部分，不被推导根据StackOverflow上的这个答案，lambda是函数对象而不是函数，但是可以被转换(convert to)成std::function，这是由std::function的可以有所有能被调用的类型构造，也就是说这可以这么写std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };。但是类型推导是另一回事，因为lambda并不是std::function，所以编译器不能通过一个lambda去推导std::function的参数因此比较好的解决方式是直接使用template&lt;typename F&gt;，所以说现在的问题是如何得到F的返回值类型。从这个回答可以看到，可以实现这样一个function_matcher123456789101112131415161718192021template &lt;typename T&gt;struct function_traits : public function_traits&lt;decltype(&amp;T::operator())&gt;&#123;&#125;;// For generic types, directly use the result of the signature of its 'operator()'template &lt;typename ClassType, typename ReturnType, typename... Args&gt;struct function_traits&lt;ReturnType(ClassType::*)(Args...) const&gt;&#123; // we specialize for pointers to member function enum &#123; arity = sizeof...(Args) &#125;; // arity is the number of arguments. typedef ReturnType result_type; template &lt;size_t i&gt; struct arg &#123; typedef typename std::tuple_element&lt;i, std::tuple&lt;Args...&gt;&gt;::type type; // the i-th argument is equivalent to the i-th tuple element of a tuple // composed of those arguments. &#125;;&#125;; 此外注意到有个std::result_of的东西，能不能用它来推导typename F的返回类型呢？经测试可以推导函数对象的返回类型，不能推导原生函数的返回类型。1234567891011121314151617181920int native_func(int a) &#123; return 0;&#125;struct object_func &#123; int operator()(int a) &#123; return 0; &#125;&#125;;template&lt;typename F&gt;auto call_func(F f)-&gt; std::result_of_t&lt;F(int)&gt; &#123; return 0;&#125;int main() &#123; typename std::result_of&lt;object_func(int)&gt;::type x; // Yes typename std::result_of&lt;native_func(int)&gt;::type y; // No object_func of; call_func(of); // Yes call_func(native_func); // Yes system("pause");&#125; 参考了StackOverflow上的答案，这是因为原生函数并不是一个type，但是std::result_of&lt;F(Args...)&gt;中的F必须要是一个类型，合适的解决方法是直接使用decltype+declval，decltype(native_func(std::declval&lt;int&gt;()))，而不是用std::result_of 常用术语参数包：parameter pack类型限定符（const, volatile）：qualification adjustment返回类型后置：trailing return type函数签名：signature模板类型推导：template argument deduction聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释非类型模板参数：non type template parameter包扩展：pack expansionbrace-init-list省略号(…)：ellipsis符号扩展、零扩展可变参数模板：Variadic Templates pack展开模式：pattern决议：resolution]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ICPC CHINA-FINAL小记]]></title>
      <url>%2F2016%2F12%2F11%2FICPC%20CHINA-FINAL%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[退役之战 正式赛赛题热身赛虽然是GCJ或者APAC的题目，然而特意刷了一遍的我并没有什么映像啊。第一题是求2的多少进制都是1，推出一个等比数列，套求和公式，然而发现爆long long就WA了，于是我建议遍历位数，二分底数，zyyyyy很快敲了一发WA了，后来他发现还是会爆long long，于是又敲了一发又WA了。然后我看他的代码发现他的算B的n+1次幂Sn+1的时候使用Sn * B &lt; 0来判断溢出，然而只有加减法才可以这么用，于是我让他改成LONGLONG_MAX/B来判溢出，结果1A了。一进门首先发现午饭已经发了。。。Google出题一般一头一尾是水题，zyyyyy直接过掉了A，L我们在找规律，zyyyyy直接dfs过掉了，下面就是搞D和H 感受 熟悉的shu，熟悉的体育馆，熟悉的安检，熟悉的烂键盘，熟悉的小屏幕，熟悉的沙滩椅，熟悉的羽绒背心，熟悉的80元卡（终于可以挂在脖子上了） 热身赛结束的时候陈老师居然找到我们后面的sjtu退役队玩（后来发现是是叉姐的队！我们居然没认出来！），然后我们求合影，然后发现杜老师也在，酸酸地说粉丝要和你合影，于是我们和两位老师合了影（好像还是叉姐帮我们拍的照片，啊~~） 图书馆下面的超市居然这次不收税了！于是我们九张卡扫荡了一波，晚饭直接零食解决了，然后大家都好污啊。。。 抓娃娃机好坑啊 热身赛遇到了几个巴基斯坦学生 上大旁边的一条街真是无敌了，什么吃的都有 我认为对于一个努力的人来讲，他自己到最后不一定在意这个结果了，因为他自己的进步本身就是对自己的认可了。但对于我来说，我有过痛苦的经历，我希望每一个努力的人都能获得一些外界的认可，就算他自己不在乎。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NUAA-HHU联赛小记]]></title>
      <url>%2F2016%2F12%2F04%2FNUAA-HHU%E8%81%94%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[今天参加NUAA-HHU联赛，拿了1030分，第六，出了9条。这是排行榜 正式赛赛题一进机房发现妈的旁边的都是触屏的大屏幕，就我们是小屏幕。机器是windows，只带devc。发题目之前看了I，觉得比较难搞，纸质题目发下来我从后向前切，zzzyy从前向后，zyyyyy调完devc看了A有思路说我们不要看了，敲完1A，这时候我已经放弃了ML两条，K题面样例有问题，我和zzzyy吐槽了，于是zzzyy去看，我看J觉得是dp，推了一下有了结果，给zzzyy讲了他觉得有道理，不过这时候zyyyyy过了C在做比较麻烦的D，于是我先压着，看一看榜B过的很多，看B卧槽不就是NOI2016那条膜蛤题么，知乎上看到过的，zzzyy觉得H能做就是找出两个只出现一次的数（其他出现两次），于是搞了一波nlogn算法T了，zyyyyy说有O(n)的算法，于是他去搞D，然后我想n的算法，zyyyyy1A了D之后（我们第一了）我突然灵光一现想到只有一个出现一次的数就xor就行了，两个不知道是否可以，问zyyyyy觉得是有方法的，于是我偷着百度一下发现可以按照lowbit出来的那一位分成两组分别异或这样就是两个重复的数了。交了T，妈的有常数解法？我觉得判题有问题，于是问了贴气球（在墙上）的人，他们说没有多组样例，妈的去掉while != EOF就1A了，结束后发现nlogn也能过，真是醉了。然后搞完BH，zyyyyy写I，看榜发现GEFK有人在搞，G最多，推了一会儿G没结果，然后zyyyyy的I wa了两次然后他发现了问题准备想怎么解决。于是我说我来想你先把我有思路的J敲了呗，于是J1A了，还是一血，我很高兴于是上了个厕所，然后在厕所我突然想到可以从边界的O开始DFS，这些O肯定不会被消掉，其他的O肯定会被消掉，回来很兴奋告诉zyyyyy，zyyyyy觉得是对的，改了一下A了。所以说上厕所还是很关键的。后来zyyyyy就决定xjb搞G，直接预处理以下就过了。这时看到好多人E拿了90分估计是T了，F也有若干的过了，LM各过了一个，于是我建议zyyyyy线段树搞一下E水个90，然后我们研究下FLM，zyyyyy交了一下E发现90分不错，但是是没有错误提示的RE，赛后告诉我们90分就算A了。这时候我都在推L，首先floyd是肯定的，然后我觉得就是一个01背包，不过我以为k是定值（实际上人家是k_i），所以状态转移推错了。然后我就建议zyyyyy搞一搞F，用不等式缩小一下范围，zyyyyy上了个二分的优化居然搞出来60分，K暴力一波40分。然后搞M大模拟，zyyyyy用pq实现了一波，但是样例没过，于是换sort水了40分，后来觉得应该是平衡树，于是上map红黑树，卧槽这次只有30分了，于是放弃。后来发现其实一开始的思路是对的，只是在分蚯蚓的时候加上(i-1)q就行了。 感受 晚上吃了北京烤鸭，在那边9+1玩了狼人杀，我当了两次预言家三次警长。感觉有些人玩的挺好的，有些人是新手所以有不少漏洞可以钻。第一局大家都太水了。第二局我是预言家和警长，第一轮测了zyyyyy狼，发言的时候我先评价了别人的发言点了一下我怀疑的几个人然后归票zyyyyy，虽然我之前说了我已经我归票的人我认为狼面是最大的，不过大家显然不太适应我的套路于是把我投死了（其实我直接跳预言家得了），于是我把警徽撕了，到最后sxm的猎人被杀了，但是她忘了带人了。最后剩zyyyyy一条狼，不过最后zzzyy的解药可能因为上帝hj没提到吧没有用在自己身上所以神都死光了，所以狼居然赢了。第三局sxm上帝，我是平民，然后zzzyy（平民）选了警长，不过他第一轮就被杀了，然后他点了三个人觉得是狼（无敌了全中）就把警徽给我了（卧槽为啥这么信任我）。发言阶段wdf没说话，zjt附和zyyyyy，于是我归票wdf，只有zqh投了zjt。第二轮平安夜，hj表示很奇怪因为她是女巫然后她觉得她没救sxm，然后事情就很明显了，我甚至有点怀疑我上局杀错了wdf，因为大家毫不犹豫就投了wdf（后来发现是狼放弃铁狼了）。不过zys说怀疑zzzyy是狼，不过我觉得他要是狼完全可以把警徽给狼队友。因此我归票zjt，这时候预言家还不跳，zqh我觉得又不是预言家，不过这时候女巫和未跳的猎人（zyyyyy），所以我有点担心是不是zzzyy预言家强行装平民。第三天天黑了然后女巫毒死了最后一头狼，游戏结束。 OJ交题各种等，气球发不全，没打印服务只好强行手机调试。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++实现function matcher]]></title>
      <url>%2F2016%2F12%2F02%2FC%2B%2B%E5%AE%9E%E7%8E%B0functionmatcher%2F</url>
      <content type="text"><![CDATA[使用C++中的SFINAE特性实现function matcher 一个function matcher现在有需求，对于模板函数12template&lt;typename T, typename C&gt; init(); // 1template&lt;typename T, typename C&gt; init(); // 2 当std::is_same&lt;T, C&gt;时，调用函数1，否则调用函数2，一开始试图利用重载来解决这个问题，但是重载是对类型而言的，而if只能判断true/false值，非类型模板参数又不能使用整型以外的类型。所以必须要有个机制来将整型值包装成类型，这就是int2type12345template &lt;int I&gt;struct Int2Type&#123; enum &#123; value = I &#125;;&#125;; 这个可以解决很多问题，例如对成员函数的偏特化 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct when_eq &#123;&#125;;struct when_neq &#123;&#125;;template&lt;typename T, typename C, when_neq J&gt;void test(T x, C y, when_neq j) &#123; cout &lt;&lt; 1 &lt;&lt; endl;&#125;template&lt;typename T, typename C, when_eq J&gt;void test(T x, C y, when_eq j) &#123; cout &lt;&lt; 2 &lt;&lt; endl;&#125;template&lt;typename T, typename C&gt;void judge_test(T x, C y) &#123; typedef std::conditional&lt;std::is_same&lt;T, C&gt;::value, when_eq, when_neq &gt;::type extra_judge; test &lt; T::value_type, C::value_type , extra_judge&gt; (x, y, extra_judge());&#125;int main() &#123; vector&lt;int&gt; a, b; judge_test(a, b); system("pause"); return 0;&#125;事实上是不能通过编译的，因为非类型模板参数只能为整数或者指针，报错如下：1231&gt;f:\codes\competition\acm\acm\src\test_template.2.cpp(14): error C2993: “when_neq”: 非类型模板参数“J”的类型非法1&gt; 1&gt;1&gt;f:\codes\competition\acm\acm\src\test_template.2.cpp(18): error C2993: “when_eq”: 非类型模板参数“J”的类型非法 也可以利用SFINAE特性来解决。SFINAE特性可以用来要求匹配一个具有特定成员函数名的类型。为了使用该特性，首先要实现一个matcher，下面给出一个例子，XXX_matcher能够匹配带函数XXX的类型。12345template&lt;typename T, int (T::*)()&gt;struct func_matcher;template &lt;typename T&gt;using XXX_matcher = func_matcher&lt;T, &amp;T::XXX&gt;*; 下面就是使用SFINAE，SFINAE(Substitution Failure Is Not An Error)，虽然C++中模板匹配遵循尽可能精确的原则，当最精确的模板匹配失败时，编译器并不报错，而是会再尝试候选模板。现在用SFINAE解决上面的问题，首先发现T可能是任意类型，但是C其实是个容器类型，所以一定有一个size函数。因此可以通过匹配T是否也具有size函数来判断是不是C类型。12template&lt;typename T, typename C&gt; init(XXX_matcher&lt;T&gt;); // 1template&lt;typename T, typename C&gt; init(...); // 2 注意调用该SFINAE的函数时需要显式给出模板参数。这里给出一个demo：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;type_traits&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;tuple&gt;using namespace std;template&lt;typename T, typename Return, Return(T::*)()const&gt;struct const_func_matcher;template &lt;typename T&gt;using vector_matcher = const_func_matcher&lt;T, size_t, &amp;(T::size)&gt;*;template &lt;typename T&gt;void accept_vector(T x, vector_matcher&lt;T&gt;) &#123; puts("T is vector");&#125;template &lt;typename T&gt;void accept_vector(T x, ...) &#123; puts("T is not vector");&#125;template &lt;typename T&gt;struct hack_vector &#123; size_t size() const &#123; return 0; &#125;&#125;;int main() &#123; vector&lt;int&gt; c; int d = 0; hack_vector&lt;hack_vector&lt;int&gt;&gt; e; accept_vector&lt;vector&lt;int&gt;&gt;(c, nullptr); accept_vector&lt;int&gt;(d, nullptr); accept_vector&lt;hack_vector&lt;hack_vector&lt;int&gt;&gt;&gt;(e, nullptr); system("pause");&#125;// T is vector// T is not vector// T is vector 可以发现function matcher能够匹配所有具有相同函数签名的函数。如果仅仅需要对vector&lt;T&gt;这一种精确处理，可以写这样的代码1234template &lt;typename T&gt;void func(T x);template &lt;typename T&gt;void func(vector&lt;T&gt; x);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCPC2016宁波总决赛小记]]></title>
      <url>%2F2016%2F11%2F28%2FCCPC2016%E6%80%BB%E5%86%B3%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[CCPC2016宁波总决赛小结，唉dalao太多了，这场就是去膜的。 正式赛赛题Google出题一般是一头一尾水题，就像热身赛喜欢出GCJ或者招聘笔试题一样，首先zzzyy从头开始切，我从尾巴开始切，zyyyyy调配置。我看最后的L的题目夏令时便觉得能做（之前有人在群里发白皮黄点的气球觉得这条是金牌题），简单推了下就把模板给了zyyyyy。这时候zzzyy也发现了A的规律，之前WA了一片的A后来又重测过了许多，于是先交A1Y，然后zyyyyy慢慢敲L，我切J题，讲的就是icpc出线调参的事情，就是暴力枚举一下Y。过了L之后zyyyyy敲J，不过他犯了两个低级错误，所以到了11点才写完，这时我们3Y，已经在铜末了。对面的tju一队还不如我们，后面的河南大学软件学院的老朋友（他们合肥站在我们对面）还是1个气球（话说他们热身赛第一条拿了一血），他们对面的q神已经5Y了。在zyyyyy敲J的时候我在看B，zzzyy在看H。我想了想B觉得只有洗衣机的情况那就是贪心最早结束的方案，现在再加了一个烘干机，应该还是宜早不宜迟，因为衣服尽早洗完可以再等。所以我觉得就使用一个pq来维护洗每件衣物时每个洗衣机/烘干机的结束时间选最早的就行了。zyyyyy觉得这个想法也是可以的，但是他用了一个比较复杂的线段树来实现。这时候我和zzzyy看H题，之前zyyyyy觉得是网络流，但仔细看了之后觉得这个是互斥的，所以用不了网络流，应该是个dp，我推了一会儿觉得有点问题，如果取dp值为方案数的话实际上可以有很多个最优的选择，因此具体选哪个还需要继续搜索。而zzzyy那边的搜索思路他觉得应该会超时。后来马上要封榜了我们还是卡BH，然后我就建议zyyyyy强行刚一波H，然后我和zzzyy再想点B的样例。zyyyyy不负众望在还有20分钟的时候用状压dp过了，复杂度1e10也过了。与此同时zzzyy和我想了很多B的样例结果都是可行的，于是我们觉得可能实现上有问题。比赛结束后我们问了对面天津大学的一队，结果他们用了一个奇妙的二分答案过的，对于我们的想法他们说是过不了2 2 2 5 3 3 5这样的样例的。不过其实官方解法是把烘干机当做洗衣机的逆过程，维护两个pq最后匹配一下。很多dalao陪伴我们死在这条题上，最后I题过的居然比B要多了。 感受 宁波真冷，风太大，比赛组委会居然发的长袖t恤，比赛的时候张老师给我们买了几个暖宝宝贴在肚子上和腿上 我们周五下午去了天一阁、月湖公园和南塘老街，感觉那天宁波烟雨蒙蒙特别漂亮，晚上在南塘老街吃了奉化牛肉面超级大块的牛肉感觉很好吃。 周六上午我们去了宁波博物馆，在宁波历史那边有个大叔讲的特别认真，带我们从河姆渡一直讲到清朝。 学校食堂晚上居然是自助餐，吃的撑死了，最后拿喝饮料的杯子装了三四个鸡翅回去吃 大佬太多了，开幕式和讲题看到了xiaodao，正式赛结束我们还要到了q神的签名。第一名clj队比赛结束后还在搞K题，难怪他们那么强 回南京的路上我们在高铁上和张老师朱老师一起玩你画我猜，然后发现zzzyy居然不知道费列罗（好可怜） 热身赛的时候大家发挥聪明才智测评测机的T，为了避免O2的优化，最后还用了random，后来发现评测机跑的比本地快多了 周五晚上张老师和朱老师请我们吃了12个鸡翅两块华夫饼和饮料，然后拉我们谈了超级久，从ACM队谈到学院的创训。 其实我校ACM起步很晚的，是从13年参加的邀请赛，然后打到南京赛区的名额开始的，据说那场比赛GB就和中国的组委会闹翻了（难怪2014年开始取消中国组委会，2015搞出CCPC）。其实学长不仅搞ACM，而且英特尔杯获得某评委的青睐，然后虽然做得有点离题但还是给了二等奖，说到要注册几个CF或之类账号看看训练情况，要给ACM的队员排名。然后水上明珠BBS居然是张老师上学的时候的一个土豪大神（还是我老乡）同学（后来他创业了）搞出来的，之前还写了好多小游戏，结果有人痴迷于游戏把成绩弄掉了。话说那时候还没有勤学楼，大家只有做课设的时候才有电脑，而且大四的时候有特别多的大课，比如操作系统软件工程啥的（卧槽大三都学啥啊）。大家对创训最后放弃的人进行了吐槽，然后说了说关于专利和写文档的事情。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[组合博弈]]></title>
      <url>%2F2016%2F11%2F23%2F%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88%2F</url>
      <content type="text"><![CDATA[总结一下网上教程关于组合博弈的部分要点 Nim 博弈Nim游戏的典型形式是假设有N堆石子数量是 $ a_1, a_2 .. a_n $，两人轮流从某一堆取若干个（不能一个不取），最后不能取的人算失败。为了解决这个问题，先定义必败态，也就是先手必败，这里先手必败指的不是游戏开始时的先后手，而是指的当前局面的先后手。必败态的所有的下一步都是非必败态，非必败态存在某个下一步是必败态。因此假设A此时拿到一个必败态，那么无论他如何移动，都会留给B一个非必败态；而B的非必败态经过移动可以留给A一个必败态。可以发现，如果每一堆的石子数的和异或起来为0的话，当前状态是必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = 0 $ 是必败态（Bouton’s Theorem）。这是因为： 不能取时每一堆石子都是0，因此异或的结果还是0，因此是必败态 假设此时A是一个必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = 0 $，假设存在$ a_i $使得取完之后的 $ a’_i $ 也满足异或结果为0。由于异或具有消去律，因此$ a’_i = a_i $ 假设此时A是一个非必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = k \neq 0 $，总能找到一个 $ a_i $ 使得 $ a_i \ xor \ k \lt a_i $，这样的构造只需要 $ a_i $ 把 $k$ 最高位的1异或掉就行了。这样把 $ a_i $ 替换成 $ a_i \ xor \ k $ 就能得到一个新的异或为0的必败态给对方。 ICG和SG函数由此可以引出ICG和SG函数，刚才的必败态对应于SG函数中的P-position，P是Previous，指的是刚取完石子的那人赢，因为只有两个人玩，所以就是先手输。对应的状态是N-position，N指的是Next。ICG（Impartial Combinatorial Games）指的是公平组合游戏，满足下面的性质： 两名选手轮流行动，每一次行动可以在有限合法操作集合$ f $中选择一个，若轮到某位选手时，该选手的合法操作集合为空，则这名选手判负 游戏的任何一种可能的局面（position），合法操作集合只取决于这个局面本身；局面的改变称为“移动”（move）任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成一个有向无环图。如果 $\langle x, y \rangle \in E$，表示从x局面可以到达y局面。 首先定义mex（minimal excludant）运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 $ mex \lbrace 0, 1, 2, 4 \rbrace = 3 $，$ mex \lbrace \rbrace = 0 $。对于ICG对应的DAG中的每一个顶点（局面），定义SG函数 $ sg(x) = mex \lbrace sg(y) \mid \langle x, y \rangle \in E \rbrace $。当 $ sg(x) = k $ 时表示 $ \forall i \ , 0 \le i \lt k, \ \exists \ \langle x, y \rangle \in E, \ sg(y) = i \ $ ，也就是说，$k = sg(x)$ 是最小的不属于 $sg(y)$的值，其中$y$是$x$的所有后继局面。下面介绍这个值的具体意义。事实上SG函数拥有和Nim游戏同样的性质，$ sg(x) = 0 $ 对应着必败态，$ sg(x) \neq 0 $ 对应着非必败态，表示通过可选操作 $ k = sg(x) $ 个可以到达一个P状态。以一个较为简单的取石子问题为例，假设有1堆n个的石子，每次只能取1、3、4个石子，先取完石子的人胜利，求各个状态的SG值。现在定义SG函数$sg(i)$为状态i下的石子数，显然有$sg(0) = 0$，设操作$f=[1,3,4]$表示可以取1、3、4个石子。当$x=1$时，可以取走$1$个石子（不能不取），$y = \lbrace 0 \rbrace$，$sg(1) = mex \lbrace sg(1) \rbrace = 1$当$x=2$时，可以取走$1$个石子，$y = \lbrace 1 \rbrace$，$sg(2) = mex \lbrace sg(2) \rbrace = 0$当$x=3$时，可以取走$\lbrace 1, 3 \rbrace $个石子，$y = \lbrace 0, 2 \rbrace$，$sg(3) = mex \lbrace sg(0), sg(2) \rbrace = 1$当$x=4$时，可以取走$\lbrace 1, 3, 4 \rbrace $个石子，$y = \lbrace 0, 1, 3 \rbrace$，$sg(4) = mex \lbrace sg(0), sg(1), sg(3) \rbrace = 2$当$x=5$时，可以取走$\lbrace 1, 3, 4 \rbrace $个石子，$y = \lbrace 1, 2, 4 \rbrace$，$sg(5) = mex \lbrace sg(1), sg(2), sg(4) \rbrace = 3$现在假设A面临5个石子的局面，他选择可选操作“取3个”，将剩2个石子的局面留给B，B发现$sg(2) = 0$，是个必败态，无论他如何取都将不敌A。对于刚才的取石子游戏，可以想象成在A和B一个有向图上从开始的点轮流沿有向边移动棋子，直到到达一个出度为0的点。而SG函数的意义表示一堆石子的个数。而现在有n堆石子，每一堆石子都对应一个SG函数，这个游戏就可以分成n个子游戏。对于这样的情况，有Sprague-Grundy Theorem给出该游戏的和的SG函数值是它的所有子游戏的SG函数值的异或，即 $ sg(G) = sg(G_1) \ xor \ sg(G_2) \ xor \ .. xor \ sg(G_n) $。 例题 POJ 2505题意设p初始值为1，A和B轮流对p乘上一个2和9之间的数，谁先大于等于n谁就获胜]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git rebase 用法]]></title>
      <url>%2F2016%2F11%2F19%2Fgit-rebase%2F</url>
      <content type="text"><![CDATA[最近发现自己某个项目的.git文件夹有点大，考虑到里面有很多无效提交，所以希望能够将有些提交删除或者合并，这就用到git rebase这个命令有的时候我们有若干个branch，对一个branch进行rebase会影响到其他的branch么？这里做了个实验 rebase对branch的影响新建git仓库12345678910echo "1" &gt; test.txtgit add .git commit -m"1"echo "2" &gt; test.txtgit add .git commit -m"2"echo "3" &gt; test.txtgit add .git commit -m"3"git branch 0.1 查看此时log123456789101112131415161718$ git logcommit d299f0788909111c0a9d13dfb756f901092c85ceAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:41 2016 +0800 3commit b601f3c9e5b4b814eefb5889d5110076ec234304Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2commit b6a00666d366a77ab03bac5f79b035a705a9d64cAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 rebase master将master分支的3号commit合并到2号commit上1234$ git rebase -i --root[detached HEAD 00d6d06] 2 1 file changed, 1 insertion(+), 1 deletion(-)Successfully rebased and updated refs/heads/master. 再次查看master的git log1234567891011121314$ git logcommit 00d6d06ef697290483cbab5f5e6324491abb5f85Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2 3commit 55cb8ae13c8cef61c3bf7b89ce3001eac29de630Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 发现已经成功合并查看0.1分支的git log12345678910111213141516171819$ git checkout 0.1$ git logcommit d299f0788909111c0a9d13dfb756f901092c85ceAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:41 2016 +0800 3commit b601f3c9e5b4b814eefb5889d5110076ec234304Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2commit b6a00666d366a77ab03bac5f79b035a705a9d64cAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 发现并没有变化于是结论很显然，git rebase只会影响当前分支 rebase对annotation tag的影响新建tag按照上面的步骤重新构建了一个git仓库，下面对提交2（a8ede39f9ff56c4a43ee89e80ba30c0aad8f2f26）打tag1$ git tag -a v0.1 a8ede3 切换到v0.1的tag12345678910111213$ git checkout v0.1Note: checking out 'v0.1'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_nameHEAD is now at a8ede39... 2 注意到这里说明现在在一个’detached HEAD’ state，这是因为tag 相当于是一个快照，是不能更改它的代码的，如果要在 tag 代码的基础上做修改，新建一个分支。下面看一下这个detached HEAD的提交历史123456789101112$ git logcommit ed4c38d8247a454b49a97962006ccaa659cae32cAuthor: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 2commit 2b84833dd18c6802893029c7c0dfaa781ec20aa8Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 1 发现提交1还在下面回到master分支，并将master分支压缩成一个分支1234$ git rebase -i --rootpick fea1e3c 1s a8ede39 2s 9b9a18c 3 再次查看log123456789101112$ git logcommit a8ede39f9ff56c4a43ee89e80ba30c0aad8f2f26Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 2commit fea1e3cf0a1939544ae01f1160d2c87c2960e661Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 1 发现tag的log并没有改变]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Floyd求最小环]]></title>
      <url>%2F2016%2F11%2F17%2FFloyd%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF%2F</url>
      <content type="text"><![CDATA[使用Floyd算法求最小环 FloydFloyd算法原理是对于点k = [1..n]，尝试用它来松弛边(u, v)。在实现时维护 $ dist[n][n] $ 数组，用来表示i和j之间可以通过$ 1..k $的最短路径。因此算法复杂度为 $ O(n^3) $ ，能计算任意两点最短路径，能够处理负边。Floyd计算最小环时，考虑k的两个邻居i和j，他们三者可以构成一个至少有三条边的环（其中实际不存在的边边权为无穷大）。事实上查看算法可以发现计算最小环的操作位于Floyd算法k循环松弛操作的上方，也就是在用k松弛i和j前先计算经过k的最小环，这么做是为了防止重复计算经过同一点的最小环。 注意点 一开始定义const int inf的时候不能设太大，不然容易wrap掉 遍历k要放在最外层]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HUSTOJ使用]]></title>
      <url>%2F2016%2F11%2F16%2FHUSTOJ%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[最近给 http://acm.hhu.edu.cn/JudgeOnline/ 出了一点题，总结一下这个OJ使用的一些注意点 添加题目之后题目显示的是reserved状态，这时候普通用户并不能看到这道题目 在加题界面添加的sample input和sample output都会被添加到testdata里面，因此要注意准确性 testdata里面可以存放多个.in和.out文件 此外我写了一些辅助工具一个自动重复测试数据的工具一个自动根据标程生成.out文件并计算运算时间的工具注意使用VS的Debug模式编译可能时间相比实际运行时间长很多，这是因为Debug模式自带很多检查]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[segmentfault 双11光棍节程序猿闯关秀]]></title>
      <url>%2F2016%2F11%2F14%2Fsegmentfault1111%2F</url>
      <content type="text"><![CDATA[双十一segmentfault推出一个双十一解密游戏，不过当时我在前往北京的火车上，于是今天从北京跪回来玩了一下，作为玩过arthurluk的人感觉还是没有压力的。 第一关https://1111.segmentfault.com/全选看到连接 第二关https://1111.segmentfault.com/?k=05f5a5b740dbba332ea21005b7214c44查看源代码发现密码 第三关https://1111.segmentfault.com/?k=c0781e0fb05d15fa6ecb71b324805f9f首先发现这个密钥都很有规律，应该是个md5，于是去www.cmd5.com这个坑比网站上试了，没用，又瞎搞了几个盐也没用，代码里面只有一个amazon的js，应该不是提示。于是猜测是不是在http响应头里面，一看果然是的，密码是The-Key-Is字段。 第四关https://1111.segmentfault.com/?k=a87ff679a2f3e71d9181a67b7542122c这一关就是md5了，响应头里面给了个X-Hit，以为是盐，用坑比网站解密发现是4。然后下一关网址就是5加密，但是怎么都不对，后来发现就是个裸的md5，没有盐，X-hit好像是用来看缓存是否命中的。 第五关https://1111.segmentfault.com/?k=e4da3b7fbbce2345d7772b0674a318d5给了个二维码，扫了之后发现是这东西。根据我玩arthurluk的经验，我把https://1111.segmentfault.com/5.png 和404的那个svg图改成了bmp、jpg、png、svg、php、txt等格式发现都没有用。于是这一关我投降了，查看题解发现要把这个图片下载下来，作为txt打开。可以看到下面的密码。 第六关https://1111.segmentfault.com/?k=bdbf46a337ac08e6b4677c2826519542题目是：f4de502e58723e6252e8856d4dc8fc3b，只能告诉你这么多。首先想到的是这可能是寻找一个二级页面，然后提示在二级页面里面。于是不管三七二十一先去坑比网站上查一下，结果查到了，要付费购买。那去不坑比的网站查一下，http://www.dmd5.com/ 查到了，是2323k14jm，显然这不对。后来发现数字可能是多个char拼起来的，但是考虑下并不是ascii或者unicode。不会了，google下，发现twitter直接给答案，这不怪我咯。 第七关https://1111.segmentfault.com/?k=1573402aa6086d9ce42cfd5991027022好吧，原来是测翻墙技术的。搞了半天，直接把这串填进去就行了 第八关https://1111.segmentfault.com/?k=110a21f15af64b25163fe67799abecda给你一个表单，input填好密码，但是没有submit按钮。查看源码发现123&lt;form method="GET"&gt;&lt;input type="text" name="k" value="cda7ea6afa6ba887e7b8695b9ebac61d"&gt;&lt;/form&gt; 卧槽这method=&quot;GET&quot;欲盖弥彰啊，改成post，过了 第九关https://1111.segmentfault.com/?k=110a21f15af64b25163fe67799abecda （注意带上post的数据）貌似是ascii构成的base64，用python硬搞一波，转成一堆乱码，但是问题是下划线不知道转成什么。仔细看一下觉得也不像π、e之类的常数，于是决定假设_始终代表0和1中得到某一个值。用0试，出现奇妙字符，用1试，是合法的base64。用工具转成文本，得到一堆乱码，于是可能是图片。试了一试也不行。那直接MD5也不行。不会，后来发现原来是保存成文件。我写了个代码在这里，特别注意的是windows有个神坑，当按照文件读写的时候\n(0x10)是默认变成\r\n(0x1310)的，因此压缩包会无法解压，如下图所示（使用Hex Compare比较）：因此应当使用wb而不是w来写文件。 第十关（通关）从解压得到的图片上可以看到通关页面：https://1111.segmentfault.com/?k=e4a4a96a69a1b2b530b3bec6734cdf52]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC 2016 北京站小记]]></title>
      <url>%2F2016%2F11%2F14%2FICPC2016%E5%8C%97%E4%BA%AC%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这周六日在北京大学参加了2016年的最后一场ICPC区域赛。我们周五晚上乘坐T66列车从南京站出发，与此同时，平行世界里面同一时间参加ICPC青岛赛区的两队dalao们已经在青岛的海边玩了一个下午了。 赛题首先我先切了D题，看到一半清恒说F水题能做，于是我跳到F题开始敲，调试居然不过样例，原来是operator&lt;比较的时候用了两个this。过了之后清恒给我讲他们D题的思路，认为最大减最小就行了，我觉得他们题目理解错了，这时候我已经有了想法，然后赶快敲完过了。过了队友说K没搞懂什么意思，于是我去切K。接下来我们KE并行搞，E题通过的多，但是K题的通过率达到了惊人的100%。K题意思是问从1到N, N &le; 10100里面有多少个数等于从1到N所有数中数字”1”的个数之和。题目给了样例说明前100000000000个数里面有83个这样的数，其中最大的是11111111110。这道题我一开始觉得是dp，后来发现数字太大了，不太好做，便放弃了。队友们接过K，觉得先打表。过了一阵子他们觉得10100里面也只有83个数，交了一发发现翻了低级错误wa了，改了一阵子过了。这时候我在做E。E题是有个长度为5的由&#39;0&#39;-&#39;9&#39;组成的字符串，可以对这五个数字中任意一个进行乘2（总共3次）、加1（总共2次），和交换（不限次数），问组成”12345”需要的最少操作数，若不能就输出-1。我的想法是打表求出把&#39;0&#39;-&#39;9&#39;变成&#39;1&#39;-&#39;5&#39;需要的最少步数，然后再加上交换的次数。然后把五个数转成五个数的最小步数时候遇到了问题，这并不是一个贪心问题，我打算用bfs硬搞，算了算复杂度可能不行，于是尝试用图论算法（KM匹配）浪费了不少时间，最后时间不够了上bfs然后WA了，这时候比赛也结束了。封榜前我们是106名，想着今年据说Cu线改成605%了，应该能拿个Cu。不过后来发现还是45%的线，于是打铁滚粗。 感受 前面的队名叫latte，最后果然两题拿铁滚粗，这给我们启示比赛的时候不要喝拿铁（然而摩卡巧克力太腻，卡布奇诺有点苦）。 电子科技大学的一队拿到了AK两条的fb，于是怒拿冠军出线。这又一次给我们启示风水和气运很重要。 pku发了一人4张的20元卡（实际上除掉手续费只有16元了）。表示很奇怪为什么这卡要搞三张，难道是一张卡上只有4bit么？后来拿到发现卡上有若干洞，不禁想到多年前看到的matrix67的这篇博文，有空算一算 感觉北大好牛逼，报到的时候送了每人一个纪念U盘和水杯，开幕式和颁奖poucher和GB都出现了（GB口语好差啊），比赛午餐是开封菜，一对辣翅一个汉堡，每人一个大橘子。北大食堂只开放了艺园和农园，据说是比较差的食堂，但是依然是便宜可口。我们比赛的邱德拔体育馆整个还是北京奥运会的装扮。 北京用的hihocoder做的judge，参赛时果然没给我们CB，尿壶也不好用，但是给了个eclipse，我觉得还挺好用的。 晚上在中关村吃了东来顺火锅，因为之前吃过北京火锅的，并不喜欢那种芝麻酱，但是在北京吃到正宗的觉得还是挺好的，关键是不腻也不算太甜。本来准备去全聚德买个烤鸭寄给我姐的，但是实在没时间了 卧槽宾馆好远啊，住在人大那边的如家]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5074 Hatsune Miku]]></title>
      <url>%2F2016%2F11%2F09%2FHDU5074%2F</url>
      <content type="text"><![CDATA[HDU 5074 Hatsune Miku 2014 ACM/ICPC AnShan 题意使用m种音符组成一个长为n的歌曲，定义两个相邻音符(a, b)的美丽度是score[a][b]，而一个长为n的歌曲a[1..n]的美丽度是所有的n - 1个(ai, ai + 1)美丽度的和。现在已知在歌曲的某些位置的音符已经被钦定了，问能够达到的最大的美丽度是多少？ 思路代码常规的暴力法就是对每一位枚举并计算美丽度，复杂度是\( m^n \)。但实际上可以dp来做。定义dp[i][j]是第i个音符选j时前i个序列的最大美丽度。然后在dp的时候考虑i - 1和i分别是-1和正数的四种情况： 当i - 1位置和i位置全部已知的时候，dp[i][j]是个定值。 当i - 1位置未知、i位置已知为j的时候，dp[i][j]就是在i - 1位置枚举所有的值取大的更新，继续维护dp数组的性质。 i位置未知时候，问题实际上分解为m个小问题，令j = [1..m]，然后按照2的方法计算。 有一个坑就是最后一个数可能不是-1，所以输出答案的时候先判断是-1了，再比较输出最大的dp[n][j]。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[拓扑排序]]></title>
      <url>%2F2016%2F11%2F07%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
      <content type="text"><![CDATA[在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。 每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径。也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点A到顶点B的路径，那么在排序中B出现在A的后面。 拓扑排序的一种实现方式就是对每个点维护它的入度。每次选取任意一个入度为0的点，然后删掉它的所有出边，更新入度。容易看拓扑排序的结果是不固定的，因此一般还会有其他的限制条件。这样一般是从大到小或从小到大取，并且采用小顶堆或者大顶堆来形成最终的顺序。 经典题目HDU 5695 Gym Class题意思路代码同上面的，因为前面的要尽可能大，所以使用大顶堆。toposort里面遍历0入度的点应当从大到小。这条题目注意最后的方案要lld输出。 HDU 4857 逃生题意现在需要对[1..n]排序，要求编号小的一定在编号大的前面，但是此外还有若干形如(a, b)的约束条件，要求a必须在b前面。现在输出排序方案（保证一定有解）。 思路正确的代码需要反向拓扑（反向建边），维护一个大顶堆，然后反向输出 错误的代码读取(a, b)，对(a, b)建立有向边（正向拓扑），维护小顶堆，正序输出。 错误原因在阅读了这个帖子之后，明白了。考虑下面的例子： 1 3 1 3 1 正确的输出应当是 3 1 2 但是我的程序输出了 2 3 1 按照题意，3应该在1前面，1应该在2前面。但我的实现保证了按字典序排列，2的字典序较小，所以排在3前面，但是这就不满足编号小的在编号大的前面这个限制条件了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[岩土工程实习]]></title>
      <url>%2F2016%2F11%2F07%2F%E5%B2%A9%E5%9C%9F%E5%B7%A5%E7%A8%8B%E5%AE%9E%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[这是去年岩土工程实习的实习报告。这是学习岩土工程这一个土木工程学科下面的细分方向之后的第一次实习，也是我们进入土木院后的第一次实习，不同于水工等学科实习得跑到浙江新安江的水坝那边去，南京本身就提供给我们土木工程很多实习的场所，例如最近一直在建的地铁，过江隧道，处处加盖的高楼，以及宁镇山脉的边坡治理等等。这样带来的好处是，有很多地方，我们在之前的例如工程地质实习中已经参观过了，因此有了一定的基础知识，再来理解这一部分就减少了很多难度。此外，对于作为在江苏成长，在南京生活了两年有余的我来说，也多了一次接触认识家乡的机会。从总体的实习安排中可以看出我们这次的实习主要分为三个方面，第一天我们主要感受了两个地基处理的样例，第二天我们参观了一个边坡治理的样例，第三天我们参观了隧道的施工。它们都分别代表着岩土工程的几个不同方面的应用。第一天我们参观了位于中山东路与龙蟠中路交界处东北角的中山东路301项目和位于卡子门大街与汇景北路交界处东北角的复地宴南都项目。这两个都是在做地基处理，两者都是深基础，其中中山东路的项目尚未完成底板，复地宴南都已经完成了。进入中山东路项目的工地，首先看到的便是两个巨大的基坑，这两个基坑分别由钻孔灌注桩拼成的桩墙（A）和地下连续墙（B）围住，起到了挡水挡土的作用。听老师的讲解，钻孔灌注桩和地下连续墙虽然都能够起到这个目的，但是它们的成本和效果差别很大。其中钻孔灌注桩成本小，但是由于施工的原因其表面会有坑坑洼洼的状况，而且钻孔灌注桩只有上部的2/3有钢筋，所以质量相对于地下连续墙差，而地下连续墙是先挖一道“沟”，再往沟里面布筋，灌浆处理而来，成本比较高，在中山东路的项目中，只有靠近地铁二号线的那一侧采用了地下连续墙进行挡土防倒灌处理。接下来在钻孔灌注桩和地下连续墙内部浇筑一些纵横梁起到加固作用，当然，等到底板做好之后，这些纵横梁就失去了作用，到时候可以选择作为地下停车场的顶板或者直接敲掉，这里的项目是选择直接敲掉。当然其实钻孔灌注桩在做好底板之后也可以敲掉，转而有建筑的外墙来承担挡土的功能。由于是一个深基础，地下有好几层，一般采用的是先打好桩，然后做好第一层的纵横梁，接着往下挖出第二层并造好第二层的纵横梁，敲掉露出来的桩，使用钢结构的柱子临时顶上（由于纵横梁最后都要拆掉的，所以没必要再造个柱子出来）。然后再往下面挖第三层。值得注意的是我们发现纵横梁的接近底部处按照一定间距均匀排布的很多细的塑料管，大家都不明白这些塑料管是干什么用的，后来咨询了工地方面才了解到，在浇筑混凝土的时候往往会发生涨模现象，这个时候就要用对螺栓将模板固定好，为了能够重复利用这些螺栓，就用塑料管将它们包起来，这样可以方便地取出，实际上这些小的实用技巧存在于工地的方方面面，往往是书本上面难以学习到的。我们接着有下到工地下面去观察了一下钻孔灌注桩，如同老师所讲的那样，这种桩质量确实不好，往往经常有缩颈（桩的一段的横截面积突然变小）等现象，而且有的装孔灌注桩内侧还有渗水的现象。此外我还发现为了防止外侧水位过高，在桩中间也留了一些水管，方便外部的地下水流出。图中的弯起钢筋的作用是辅助浇筑纵横梁。在工地上，这些“脚手架“一样的建筑往往占了很大的比重。，虽然它们最终都要拆掉，但是这看似浪费成本的办法实际上往往是最合理的。下午我们又参观了位于卡子门附近的复地宴南都项目，卡子门这边的地形浅一点，据说这边已经能够挖到基岩了，而上午的中山东路那边软土层比较厚，往往达几十米，打桩也只能打摩擦桩。这边已经做好了底板和承台（承台是桩与柱或墩联系部分。承台把几根，甚至十几根桩联系在一起形成桩基础），很多台挖掘机在不停的挖土方，监理们在走来走去指挥农民工做事。总体上讲，地基处理的成本往往占到了总成本的40-50%有了一个可靠的地基，才能保证建筑物的安全。这两个项目都是采用的箱形基础，箱型基础是由钢筋混凝土的底板、顶板、侧墙及一定数量的内隔墙构成封闭的箱体。这种基础整体性和刚度都好，适用于作软弱地基上的面积较小，平面形状简单，荷载较大或上部结构分布不均的高层重型建筑物的基础及对沉降有严格要求的设备基础或特殊构筑物，但混凝土及钢材用量较多，造价也较高。但在一定条件下采用，如能充分利用地下部分，那么在技术上、经济效益上也是较好的。对应的还有沉井，又名开口沉箱，对横断面为圆形、方形或矩形，顶底都敞开的井筒，在井筒内挖土，并靠井筒自重下沉后接长井筒，继续挖土和浇筑混凝土建成的基础工程。第二天我们跟车前往南京麒麟科创园青龙山沿线矿山地质环境治理示范工程—永平治理区工程。这边位于宁镇山脉处，我们上学期的工程地质实习就在这里附近的青龙山，阳山碑材附近实习过。在上学期的工程地质实习中我们了解到，青龙山属扬子地层区下扬子分区宁镇地层小区，地层发育齐全，有从最老的志留系至第四系连续完整的分布。构造上地处下扬子台褶带宁镇褶皱束的西南缘，西临南京坳陷，南接宁芜火山岩盆地，构造线总体呈北东向展布，断裂和褶皱均比较发育。区域上岩浆活动比较频繁，但以燕山期为主，具多旋回、多阶段、多形式的特点。我们今天去观摩的，是其中的永平治理区。根据区内地貌成因和形态类型划分，这里位于青龙山山系西南端，地处山体西坡。山体总体呈北东走向，地形纵向切割较深，山脊狭窄，两侧山体坡面较平直，自然坡度一般为20-25°；横向切割较小，冲沟多呈宽缓的“U字型”。周边山体林型为落叶阔叶林和常绿阔叶混交林，植被发育良好。麒麟科创园青龙山沿线矿山地质环境治理示范工程位于主城区东侧的麒麟科创园和东郊风景区范围内，北接仙林大学城、南临江宁大学城。该区域内，早年矿山开采形成的裸露边坡和矿山废弃地，不仅破坏了区域自然景观，与周边绿荫成群的青山绿水极不协调，而且成为京沪高铁、沪宁高速公路、绕城高速公路的视觉污染源，同时矿山存在多处地质灾害隐患。其中永平治理区，就有着江苏罕见的高度的坡体（据说是江苏省最大的单体）。顺着小路上山，我们首先看到的是一个楔形体，这个还没有治理，可以看到楔形体下部到该山体底部有两三道非常粗的黄色痕迹，据老师讲解，这就是因为这两天下雨，流下来的水。此外在山体的两侧，散布着很多碎石砂砾，似乎是从楔形体出崩塌下来的。据老师讲解此处楔形体还没有治理，将来是要被直接挖掉的。边坡加固一般有三种方法，一种是加固，比如说采用预应力锚索，采用锚杆，或者抗滑桩，对于小规模的边坡，可以直接采用格栅内种植植物生态护坡的办法，一般还会配合上剪刀梁，从而防止塌土的现象；还有一种就是直接削坡。永平治理区工程综合利用了这两种方法，而且在很多地方都创造了江苏之最，比如，他们采用竖直向下打方桩（作为抗滑桩），因为方桩的防滑能力好。2.8*1.8米尺寸的方桩，我们并没有见到，但是看到它的箍筋（附照片）的时候还是吓了一跳，这种尺寸，我们很难将它们和箍筋联想起来。显然的，这种桩是很难打进去的，这边采用了人工挖的方法。此外，还有一种方法就是做一个平台，打孔插钢筋，然后往里面灌混凝土，就和地下连续墙差不多的样子。抗滑桩的理想深度（打到最深）大概50-60米左右，这里的抗滑桩大概在50-30米分了六个等级。此外还使用了锚索，锚索的长度大概在50-100多米之间，一根价格往往上万。稍后在项目工地上，我们又阅读了整个项目的工程图纸，可以看出，这是一个很大的项目，目前治理的是其中的一小部分。第三天我们参观了南京地铁四号线草场门站现场和南京纬三路施工项目部，顺路路过了已经建成的纬七路过江隧道和南京长江大桥。这两个都是隧道，但是仔细研究起来还是有很大的不同之处的。首先是草场门地铁站，这个地铁站位于北京西路和虎踞路交界处，周围有比较多的古建筑和高层建筑，此外城西干道草场门隧道下穿北京西路，因此，我们看到这里面大都采用的是地下连续墙，而且是最厚的那种，厚度达到1.2m。中间有很多横梁用来防止两侧墙的位移变形。站在工地的旁边往下看，第一个感觉就是高、深。整个地铁站分为三层，其中第一层到地面之间的水泥层占了大概一个层高。由于南京的软土环境，因此随着盾构机的推进，去加固周围的土层是很重要的。以南京为例，北京东路今年的十月份至十一月份之间就连续发生了五次塌陷。据专家称，北京东路九华山这段路地下是古秦淮河道的流沙层。古秦淮河由南向北纵贯市区，由武定门经大行宫、玄武湖菱洲和樱洲，横穿中央路、福建路，到狮子山东注入长江。古秦淮河河道非常宽，最宽处达1000多米，简直就是浩浩荡荡注水入江。1万多年前的北京东路沿线，是宽敞的河流。当古秦淮河被埋藏时，形成了厚厚的流沙层，这些流沙层中还有一定的水分。地铁挖到七八米深的地下，就会遇到古河道，只要出现裂缝，流沙中的水分流出来，流沙就会跟着水走，造成塌陷。虽然施工方已经调整了施工方案，对没有施工的路段地层进行加固，然后再进行盾构施工。但是即使施工前先对地层进行加固，但也无法完全避免塌陷，毕竟地下的地质构造太复杂了，其中可见地下水对岩土工程的影响之巨大。据工地人员介绍，目前盾构机已经掘进离草场门站两公里处，所以我们是看不到盾构机的，但是随着我们走下工地，到达最深的一层，我们看到了岛式的月台，已经两个车道。其中南侧的部分已经铺上了铁轨，甚至已经有轨道车在上面跑动，在月台的尾端，就是两个巨大的圆形隧道。我们走下月台，走到隧道内，发现整个水泥管道是由很多片宽约半米的弧形的管片（也就是衬砌）围城的，其中中下部的管片靠自重维持原位置，但是上部和底部的管片表面就布满了很多螺丝，这些都是弯螺栓，通过它们将两片管片栓到一起，这样就防止管片的错位了。此外，在底部我们还发现了一些空洞，揭开盖子，我们可以从这里面往管片外部注浆进一步提高周围土的强度。下午我们主要前往纬三路隧道项目部进行参观，在去的途中，我们经过了已经建成的纬七路长江隧道。南京扬子江隧道（即纬三路过江隧道）是双管双层八车道X形隧道，分别经南北两条线路穿越长江，上层为江北至江南方向，下层为江南至江北方向。南线全长7363米；北线全长7014米。两条隧道均为上下两层，每层双向4车道，设计时速80公里，其中S线盾构段长达4.135km，N线隧道长4.936km。具有如下特点：盾构直径超大，开挖直径达到14.98米，隧道最深处到江面约74米（本来还会深五米，但是考虑到上土下岩的问题，因此高了五米）。设计最高静水压力达到7.4bar，盾构一次掘进距离长，S线4140米，N线3533米。江底盾构覆土深度前，N线隧道上方覆土厚度最前处不及1倍洞径。地质条件复杂，需穿过卵石层，泥岩层，砂岩层。纬七路越江隧道要穿过泥层和岩层。对于泥层，我们可以采用刮刀处理，对于岩层，我们可以将滚刀伸出，这样就可以用滚刀处理，减少刮刀的磨损。这些情况都是很好处理的，最难处理的是上土下岩这种情况。这种情况会带来局部磨损，因此必须要带压开仓，通过潜水员来更换刀片。然而这里位于长江江水下70多米深处，潜水员们必须能够承受70米水头带来的压强。一般的方法是往泥浆里面注射一些东西，使得周围泥浆的强度变高，形成泥膜，但是这时候周围的压强转而由空气产生，潜水员同样要承受70m水头的压力。为了能够抵挡这样的压力，就需要潜水员经过三级加压舱的逐级适应，一般要加压到1.6MPa左右，然后在进入这个环境作业。对于纬七路隧道施工是这样做的，但是纬三路隧道施工的过程中，发生了意外，中国方面的一些工人，在更换刀片后再也没有能够回来，因此，中交轨道局（负责到定淮门大街一线，中航负责到扬子江大道一线）请了德国北海公司专业的高压隧道作业人员进行处理，当然价格很高，一周每个人需要支付20万欧，作为比较，这个隧道施工的总经费在204096万。为了配合，我们设计出了一个高压生活舱，平常高压作业的潜水员就直接生活在这个舱内，等到需要作业的时候，就将这个舱运到工作地点。回来的路上我们计算了一下成本，我们发现建隧道的成本其实很大，以盾构机来说吧，首先盾构机本身就分为了前面的刀片部分，后面用来铺设管片的部分，还有三道运输吊车。总长达到了133米，而且刀片一般都是采用的碳化钨制造，一般一片刀片价格就达到五位数甚至六位数，而这样的盾构机往往是不能重复利用的，即使遇到设计尺寸基本相符的工程，也需要花费额外的金钱和人力去更换适合的刀片，以及进行评估。相比之下桥梁的成本就低了很多了。而且一条隧道存在的安全隐患代价都应该远远高于一座过江大桥，所以为什么为什么我们还是要挖隧道而不是建桥呢，城市快速路使用隧道避了扰民，优化了城市的景观，可以理解，但是过江通道为什么不能考虑造桥呢？总结这次的实习，我们将书本上面的知识，在实际中得到了验证，同时，我们也感受到了岩土工程施工一线的环境和气氛，对我们的职业道路的规划起到了重要的指导与启迪作用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[POJ 1037 A Decorative Fence 动态规划解排序计数]]></title>
      <url>%2F2016%2F11%2F07%2FPOJ1037%2F</url>
      <content type="text"><![CDATA[这是在北京大学暑期课《ACM/ICPC竞赛训练》的一道DP的题目。 题意现在要排列长度为[1..N]的N个木棒，要求除了两端的木棒外，每一根木棒要不比左右的都长，要不比左右的都短。现在给定C，要求输出在所有符合上述条件的建法中按照字典序第C种排布方式。 思路这是课程pdf提供的源码（修改后）这是我的代码这道题分成两步，第一步是计算合法排列数量N，第二步是通过N来计算第C个合法排列。第一步，其实可以先写一个递归的方案，然后再改成dp就行了，我觉得比较巧妙的地方是把up方案和down方案区分开来了。第二步，依次对第[1..i]位枚举剩下来的第[1..k]长的木棒，因为已经求得up[i][k]和down[i][k]。这种思想可以用来实现c++里面的next_permutation函数，这里给出了一个实现。 需要注意 c需要用long long去读 在计算up[i][k]的时候，我原先是从k + 1开始算的，但是实际上应当从k开始算。因为up[i][k]指的是所有由i个木棒组成的方案中以这些木棒中第k短的木棒开头的up方案的个数。也就是需要取走第k短木棒kk后的i - 1木棒组成的是一个down方案。注意到取走kk后，应当从比kk长的第一个木棒开始计算，也就是从i根木棒的第k + 1短开始。但是原来i根木棒的第k + 1短变成了现在i - 1根木棒的第k短，因此还是要从k开始搜索。 在排序计数时退出条件应当是c == 1而不是c == 0。 然后注意是n - i + 1或者n - i（看下标上界是0还是1），不是i。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[基础工程复习]]></title>
      <url>%2F2016%2F11%2F06%2F%E5%9F%BA%E7%A1%80%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[这是根据同济大学版的《基础工程设计原理》整理的复习提纲。 绪论 建筑物三要素：上部结构、基础、地基 地基 地基是承受建筑物荷载的地层 所以增加基础材料的强度并不能提高地基的极限承载力 地基可分为持力层和下卧层 第一章 地基模型 地基模型：描述地基土应力和应变关系的数学表达式 最常用的线性弹性地基模型：文克勒地基模型、弹性半空间地基模型、分层地基模型 文克勒地基模型： 假定地基有许多独立且互不影响的弹簧组成，因此地基任一点的压强p之和该点地基变形s成正比，即$ p = ks $，其中k是地基基床系数，表示产生单位变形所需要的压力强度（$ kN/m^3 $）。 这忽略了地基中的剪应力，是一个近似模型，地基越软，土的抗剪强度越低，越接近实际。 地基基床系数可由载荷板实验、室内三轴试验、固结试验获得。 弹性半空间模型： 将地基视作均匀的、各项同性的弹性半空间体。 由此可以使用Boussinesq解：$ s = \frac{Q(1 - v^2)}{\pi E r} $ 实际计算沉降偏大，一般认为是地基压缩层厚度是有限的且地基是分层的，即使同一种土，变形模量随深度增加。 分层地基模型： 我国地基基础规范。地基最终沉降等于压缩层范围内各计算分层在完全侧限条件下的压缩量之和。 地基模型的选择： 主要原则： 土的变形特征，外荷载在地基中引起的应力水平 荷载的种类和施加方式 土层的分布 基础和上部结构的刚度和形成过程 基础的埋置深度 施工过程 时效（考虑到土的固结） 常见形式 沙土、无粘性土、基础柔软、局部集中荷载：文克勒 基础埋深大、土质紧密：分层 粘性土：弹性空间地基模型、分层地基模型 文克勒模型的柔度矩阵： 将地基的面积分成m个$ a \times b $大小的矩形。，假设在j网格中点作用集中力Rj，那么当且仅当$ i = j $时，$ s_{ij} = \frac{R_i}{k_i \times a \times b} $。因而文克勒地基模型的柔度矩阵是个对角矩阵。 第二章 浅基础设计原理 地基基础设计需要考虑的因素： 基础所用材料和结构形式 基础埋深 地基土的承载力 基础的形状和布置，与相邻地下（基础、构筑物、管道）的关系 上部结构的类型、使用要求、对不均匀沉降的敏感性 施工期限、方法、设备 抗震要求 浅基础的类型： 按照所用基础材料的性能：无筋扩展基础、扩展基础、柱下钢筋混凝土条形基础 按照形状和大小：独立基础、条形/十字交叉条形基础、筏板基础、箱形基础、壳体基础 按照刚度：刚性基础（无筋扩展基础）、柔性（扩展基础） 无筋扩展基础 自重大、抗拉抗剪强度不高，一般相对高度较大，不会发生弯曲变形，因此被称为刚性基础 对于荷载大、沉降敏感建筑物，持力层土质差不适宜 钢筋混凝土扩展基础抗拉抗剪强度较高，因此在扩大基础底面积（为了满足地基承载力要求）不需要增加埋深；又称为柔性基础或有限刚度基础。可分为柱下钢筋混凝土独立基础和柱下钢筋混凝土条形基础和十字交叉条形基础。 筏板基础比十字交叉条形基础具有更大的整体刚度，有利于调整不均匀沉降。分为平板式和梁板式。 箱形基础在使用十字交叉基础不能满足承载力要求又不能采用桩基时。比筏板基础有更大的抗弯刚度，可视作绝对刚性基础。箱形基础是补偿基础。箱型基础材料消耗大，还会遇到深基坑开挖带来的困难。 基础埋深： 基础地面到天然地面的垂直距离 影响因素： 建筑物用途和荷载大小性质 对于地下室：承载力、变形、补偿基础的要求 对于高层：稳定性 对于承受水平荷载：满足抗滑要求 工程地质和水位地质 直接支撑基础的土层成为持力层，以下各土层成为下卧层。持力层必须强度足够稳定可靠。 当上层土承载力较低，应将基础埋置在下层较好的土层之中。如果需要深埋，需要和加固上层土或者短桩基础进行比较决定 例如上海某些地方，软土为不良持力层，但表面有2-3m硬壳层，六层以下民居可以利用 易于风化软岩，开挖后立即铺设垫层防止风化 地下水存在时，尽量在地下水位以上；否则要考虑基坑排水，坑壁支护等措施 若持力层下存在承压水，要控制基坑开挖深度，避免引起突涌或者流砂现象 相邻地下（基础、构筑物、管道）的关系 新建筑物埋深不宜深于旧的。否则要保证间距或者采用地连墙、分段施工、加固原有地基等措施。 地基土冻胀和融陷的影响冻结危害：地面不均匀隆起，土体膨胀，使墙体开裂，门窗不能开启化冻危害：土体松软，融陷，强度降低，沉降 补偿基础： 为了减小拟建建筑物的沉降量，除去地基处理或桩基础，还可以选用补偿基础。 箱形基础和筏板基础是补偿基础。由于地下室的存在基础具有大量空间，免去大量的回填土，可以用来补偿上部结构的全部或部分压力。基底附加应力p0公式为：$ p_0 = p - σ_c = \frac{N}{A} - γ_0 \times d $。其中N为作用在基地的荷载（$ kN $），A为基础底面积，d为基础埋深，$ γ_0 $为埋置深度内土重度的加权平均值。 定义当$ p_0 $时候的基础为全补偿基础，也就是建筑物的重力等于基坑挖去的总土量；否则是部分补偿基础。 无筋扩展基础和钢筋混凝土扩展地基的区别 无筋扩展基础是刚性基础，抗压高，拉剪弱 钢筋混凝土基础是柔性基础，抗拉、抗剪强度较高 减小不均匀沉降的措施 建筑措施 建筑物的体型力求简单 增强结构的整体刚度 设置沉降缝 相邻建筑物基础间要有合适净距 调整某些设计标高 结构措施 设计圈梁增强刚度 使用合适的结构形式 减轻建筑物和基础自重 减小调正基地附加压力 增强基础刚度 施工措施 先高后低 施工前使地基预先沉降 注意沉桩、降水对邻近建筑物的影响 基坑开挖保护坑底土 尽可能不扰动土的原状结构 确定地基承载力方法 地基承载力：地基土在同时满足强度和变形两个条件时，单位面积上所能承受的最大荷载的能力 承载力理论公式 现场载荷试验 浅层平板载荷和深层平板载荷实验。 经验方法 计算地基承载力 包含地基持力层承载力验算和软弱下卧层承载力验算。 天然地基上浅基础设计的内容 选择基础的材料、类型，进行基础平面布置 选择基础的埋置深度 确定地基承载力设计值 确定基础的底面尺寸 必要时进行地基变形与稳定性验算 进行基础结构设计（按基础布置进行内力分析、截面计算和满足构造要求） 绘制基础施工图，提出施工说明 第三章 浅基础结构设计 地基反力分布假设 墙下条形基础、柱下独立基础、筏板基础等（持力层土质均匀、上部结构刚度较好、各柱距相差不大、柱荷载分布均匀）：直线分布 弹性地基梁 基础结构设计主要内容 无限长和有限长梁的区分 文克勒模型上有限长和无限长梁内力求解 偏向受压独立基础、条形基础设计 第四章 桩基础桩基础由基桩和连接于桩顶的承台共同组成 桩的种类和优缺点 预制桩（挤土桩） 包含预制钢筋混凝土桩、预应力钢筋混凝土桩、钢桩 噪音大 灌注桩 钻孔灌注桩（非挤土桩） 人工挖孔灌注桩（非挤土桩） 沉管灌注桩（挤土桩） 噪音大 跳打：待混凝土强度足够时再在新桩的近旁施打相邻桩 轴向荷载沿桩身传递方式 开始加荷于桩顶，桩身压缩，桩侧受土的向上摩阻力 桩身荷载和压缩变形随深度递减 荷载增加，桩身压缩量增大，桩下部的摩阻力随之增加，产生桩端阻力 桩端土层压缩加大桩土相对位移，使桩身摩阻力进一步增大 桩身摩阻力达极限，继续加荷，荷载增量将全部由桩端阻力承担。桩端持力层大量压缩并塑性变形，直至桩端阻力达到极限，位移迅速增大至破坏。此时，桩达到其极限承载力。 影响桩侧桩端阻力的因素（荷载传递函数） 与土层性质、埋深、桩径等有关 桩侧桩端分担比还与桩土相对刚度、长径比l/d有关。桩土相对刚度越大，长径比l/d越小，桩端传递的荷载就越大 主特征参数：极限摩阻力$ q_su $ 和极限位移 $ s_u $ 单桩破坏形式 Q-s曲线（桩顶荷载/沉降曲线） 0-1阶段， 1-2阶段，桩侧土弹塑性阶段 当桩顶侧摩阻力达极限时（1点），桩侧进入塑性状态，随荷载增大，桩侧土塑性范围由浅到深发展，直至均达到塑性状态（2点） 2-3阶段，桩侧土完全塑性阶段 新增荷载全部由桩端承担，直至持力层破坏（$ k_s s_l \geq q_bu $），其中$ k_s, s_l, q_bu $ 分别是垂直方向地基反力系数、桩的沉降量和桩端承载力 摩擦型桩 2-3段近似直线，陡降，2点现明显拐点 端承型桩 端阻占比大，2点不现明显拐点，破坏需较大位移，曲线呈缓变型 深度效应 沉桩效应 单桩承载力确定方法 经验参数法 静载荷试验法 静力计算法 静力触探法 高应变动测法 负摩阻力及产生原因 当桩周土体发生下沉切沉降速率大于桩的下沉时，土对桩产生向下的摩阻力，称为负摩阻力。 负摩阻力产生原因有： 桩基附近地面大面堆载，引起地面沉降，产生负摩阻力。如大面积堆放重物的车间、仓库建筑桩基础。 因黄土湿陷、冻土融化产生地面下沉。 打桩，桩周土产生超空隙水压力，停止后桩周土的再固结作用引起下沉； 桩穿过欠固结土层（如填土）进入硬持力层，自重固结下沉； 土层中抽取地下水或其他原因，因自重固结下沉 群桩效应 群桩中任意一根基桩的工作性状都不同于孤立的单桩，群桩承载力不等于各单桩承载力之和，群桩沉降明显大于单桩。 定义群桩效率系数 $ \eta = \frac{P_u}{n Q_u} $。其中$ P_u, Q_u, n $ 分别为群桩竖向极限承载力、单桩竖向极限承载力和桩数。定义沉降比 $ \zeta = \frac{s_n}{s} $。$ n $和$ \zeta $主要取决于桩距和桩数，其次与土质和土层构造、桩径、桩的类型及排列方式等因素有关。 由端承桩组成的群桩，工作性状于独立单桩相近 由摩擦桩组成的群桩，桩顶荷载主要有桩侧摩阻力传到土层中，在桩端平面产生应力重叠。因此在粘性土中的群桩随着桩数增多，群桩效率系数η明显下降。 控制沉桩挤土效应方法：设置防振沟、挤土井、预钻孔、排水砂井、控制沉桩速度以及调整打桩流水 计算题：桩顶荷载和桩身最大弯矩计算 第五章 沉井基础 定义及特点 沉井是井筒状的结构物。它是以井内挖土，依靠自身重力克服井壁摩阻力后下沉到设计标高，然后经过混凝土封底并填塞井孔，使其成为结构物的基础。 沉井优点： 埋置深度大，整体性强、稳定性好 可作为挡土和挡土围堰结构物 施工工艺不复杂 施工时对邻近建筑物影响小 沉井的缺点： 施工周期长 易发生流砂现象，造成沉井倾斜（粉细砂） 大孤石、树干或井底岩层表面倾斜过大，给施工造成困难 沉井基础下沉困难的原因和解决措施 原因： 开挖面深度不够，正面阻力大 偏斜或刃脚下遇到障碍物、坚硬岩层和土层 井壁摩阻力大于沉井自重 井壁无减阻措施或泥浆套、空气幕等减阻构件遭到破坏 解决方案： 增加压重 提前接筑下节沉井 在井顶加压砂袋、钢轨等重物 不排水下沉时，可井内抽水 减小井壁摩阻力 井壁内埋设高压射水管组，射水辅助下沉 利用泥浆套或空气幕辅助下沉 增大开挖范围和深度 必要时还可采用0.1∼0.2kg炸药起爆助沉 沉井下沉突沉的原因和解决方案 原因： 井壁摩阻力较小，当刃脚下土被挖除时，沉井支承削弱 排水过多 挖土太深 出现塑流 解决方案： 控制均匀挖土，减小刃脚处挖土深度 在设计时可采用增大刃脚踏面宽度或增设底梁的措施提高刃脚阻力 流砂出现原因和解决方案 原因：土中动水压力的水头梯度大于临界值 解决方案： 排水下沉时发生流砂，可采取向井内灌水 不排水除土下沉时，减小水头梯度 采用井点，或深井和深井泵降水 沉井基础的施工工序（旱地） 整平场地 制造第一节沉井 制造沉井前，应先在刃脚处对称铺满垫木，以支承第一节沉井的重量 拆模及抽垫 挖土下沉 接高沉井 筑井顶围墙 地基检验和处理 封底、充填井孔及浇筑顶盖 水中沉井基础施工方法 筑岛法 浮运沉井施工 沉井下沉倾斜的原因和解决措施 原因： 土岛表面松软，河底土质软硬不匀 井壁与刃脚中线不重合 抽垫方法欠妥，回填不及时 除土不均匀对称 刃脚遇障碍物顶住而未及时发现 排土堆放不合理，或单侧受水流冲击淘空等导致沉井承受不对称外力作用 解决方案： 在沉井高的一侧集中挖土，在低的一侧回填砂石 在沉井高的一侧加重物或用高压射水冲松土层 在沉井顶面施加水平力扶正 沉井设计基本内容]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC 2015 沈阳网络赛]]></title>
      <url>%2F2016%2F11%2F03%2FICPC2015%E6%B2%88%E9%98%B3%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2015 沈阳网络赛 1006 Fang Fang题意给你一个由小写字母组成的循环字符串S（循环字符串的意思是你可以从任意位置i开始，顺时针经过n回到i-1的位置），问至少需要序列F中的多少项才能组成字符串S。 思路水题，代码 1010 Jesus Is Here1012 Largest Point]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5952 Counting Cliques]]></title>
      <url>%2F2016%2F11%2F02%2FHDU5952Counting-Cliques%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2016 沈阳站 Counting Cliques这道题蛮可惜的，其实就是暴力，不过在现场zyyyyy使用了set实现，实际上用vector就过了。 题意求一个N(N &le; 100)点M(N &le; 1000)边的无向图容量为S的团的个数。已知每个点的度不大于20。 思路如代码所示，进行dfs，dfs维护一个conn数组用来表示一个大小为sz的完全图的所有点。在每层的dfs中每次寻找并添加一个可能的点，这个点必须要满足和已有的完全图能够成一个新的大小为sz+1的完全图（也就是和完全图中的所有其他点的都要有边）。在实现过程中有以下优化： 为了避免重复，只从边号小到边号大建边 为了节约时间，筛掉度小于S-1的边 为了节约时间，第一层dfs完毕后将该点的从图中去掉。 去掉以上两个优化在hdu上还是能过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Visual Studio 2015使用技巧]]></title>
      <url>%2F2016%2F11%2F01%2FVS2015%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[VS2015的一些使用技巧 重定向源码路径 调试为了能够顺利进行调试，将 工程属性-调试-工作目录 设为新的目录 添加文件默认的右键工程目录添加文件并不好用，因为每次总是给定$(SolutionDir)$(ProjectName)下的一个地址，因此可以使用插件Add New File，只需要Shift+F2即可 出现符号未定义或者符号重定义的情况这是正常现象，重生成清理都没有用，正确方法是讲涉及的文件移出工程再重新添加即可，一般这种原因是某个函数所声明的h文件曾经被rename过。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCPC 2016 杭州站]]></title>
      <url>%2F2016%2F10%2F30%2FCCPC2016%E6%9D%AD%E5%B7%9E%2F</url>
      <content type="text"><![CDATA[CCPC2016杭州赛区推出了大中学生对抗赛，于是全场比赛主要看点一是clj封榜前能不能AK，另一个就是看清华学长PK清华学弟。 1001 ArcSoft’s Office Rearrangement题意给定a[1..N]，可以合并相邻两项或者将一项拆开成两项，问是否能够得到b[1..K]且b中每项都相等。 思路我的错误代码代码 1002 Bomb题意平面上给了n个炸弹，引爆其中的炸弹i需要代价ci，一个炸弹爆炸会使得它半径ri内的炸弹爆炸，以此类推。求使得所有炸弹爆炸需要的最小代价。 思路强连通缩点，然后找入度为0的所有的联通块，然后在联通块内找一个花费最小的即可。找联通快和寻找花费最小代价的点可以在tarjan的弹栈操作完成。特别地，寻找入度为0的所有连通块是通过遍历所有的边然后比较(u,v)是否属于同一联通块实现的实现的。此外注意引爆具有有向性。代码 1003 Car题意一辆车保持不减速运动（速度为实数），时间从0开始，在某些整数时刻记录下车的位置（整数递增），求最少需要多长时间达到最后一个记录点 思路这道题目的坑主要是卡精度，求ceil得时候要减去eps=1e-7。或者直接用分数类也能过。代码 1006 Four Operations题意在一个最多20位的整数里面按顺序插入+、-、*、/（整除）四个运算符，要求结果最大。 思路要注意整数有20位，使用long long。代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hihoCoder 1392 War Chess 大模拟]]></title>
      <url>%2F2016%2F10%2F25%2Fhiho1392War-Chess%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2016 北京网络赛赛题 War Chess 题意HDU上有一道类似题目链接HDU以游戏曹操传为背景，给定地图N &times; M的矩阵。Gi j表示任人物穿过这个方格的行动值减小量。每个人物有以下属性： 生命值 HP 攻击力 AT 行动力 MV 攻击范围 [AD1, AD2] 起始坐标 (STx, STy) 所在阵营 GR 每个人物可以攻击攻击范围内的敌对玩家，一旦人物的HP小于等于0，将它的移出棋盘。人物可以从当前格子开始向四周移动，在人物移动过程中，当人物从格子(i,j)移到格子(x,y)时，他的行动力减少Gx y。当移动力小于0时移动是非法的。同时，当该人物四周有敌对人物时，该人物移动力变为0。现在给定游戏记录，要求模拟游戏，并判断合法性。 思路需要注意自己局中不能移动他人的棋子，死亡人物不能进行操作。我的不能使用的代码修改后的代码有几点做的不好： 可以开一个数组记录每个格子被谁占领，注意走和被Drive out后要及时更新 Attack前先要检测Attack之后HP是不是会小于等于0，如果是的就不能Attack 其实选择人物的时候并不需要检查Round 中间我还犯了一些错误，比如OC[dx][dy]写成了OC[x][y]，没有设vis[STx][STy]。此外的move时的bfs里面，不能更新Cha[cha].MV，这是一个固有的值，每次走完MV是不变的，所以应当记录走完之后MV用了多少。 比赛的时候用的dfs，这样太慢了，实际上是bfs，用一个优先队列维护mv最大的状态，每次都是贪心从mv最大的状态走。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[emacs学习笔记]]></title>
      <url>%2F2016%2F10%2F24%2Femacs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[鉴于2015年icpc北京站没有cb等ide，来学习emacs。由于本人之前比较习惯使用vim，因此这里将部分地和vim进行对比。不过后来发现有尿壶geany（虽然我觉得很难用，关键是RE直接退出），和eclipse cdt（虽然eclipse我很讨厌但总比没有强吧），所以我决定不学了（VS大法好）。 基本操作在bash on windows下运行sudo apt-get emacs。安装完毕后运行emacs filename可以打开/创建一个新文件。使用Ctrl+X Ctrl+C可以退出emacs，类似vim的:q。 命令说明和vim不同，emacs比较依赖Ctrl，Meta键。Ctrl键是比较寻常的，Meta键有三种作用方式： Alt + X Esc X (先按Esc松开后按X) Ctrl+[ X 注意vim命令常可带数字前缀，例如3fa可以表示当前行第三个a，4yy表示复制四行。 光标跳转 操作 emacs(不使用光标控制键) vim(默认Normal模式) 光标控制键 备注 光标左移 Ctrl+B H ← 光标右移 Ctrl+F L → 光标上移 Ctrl+P K ↑ 光标下移 Ctrl+N J ↓ 上一词首 Alt+B b / vim不会忽略标点符号 上一词尾 ge / 下一词首 w / 下一词尾 Alt+F e / emacs实际移到插入位置，类似vim按a进入插入模式 上一页 Alt+V Ctrl+B Page Up 下一页 Ctrl+V Ctrl+F Page Down 逐行下滚 Ctrl+E 逐行上滚 Ctrl+Y 行首 Ctrl+A 0 Home 行首(忽略前导空白) ^ 行末 Ctrl+E $ End 行末(忽略尾部空白) g_ 句首 Alt+A ( 句子以空行和句号分隔 句末 Alt+E ) 段首 Ctrl+{ { 段以空行分隔 段末 Ctrl+} } 首行 1G, gg 末行 G 置顶当前行 zt 置底当前行 zb 到本行下一个char字符处 f+char 到本行下一个char字符前 t+char 到本行前一个char字符处 F+char 到本行前一个char字符前 T+char 括号匹配 % 插改增删复制黏贴删除删除指令可以主要以d开头，可以在d后面指定重复次数，也可以在d前面指定重复次数。 操作 emacs vim vim(插入模式)或gedit 备注 删除当前字符 x, d+→ del 删除前一个字符 d+← del 删除当前单词 dw 删到行首 do 删到行尾 d$ 删到一行 dd 查找emacs概念]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC 2016 沈阳站小记]]></title>
      <url>%2F2016%2F10%2F24%2FICPC2016%E6%B2%88%E9%98%B3%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[周六周日参加了icpc沈阳站的比赛。这次出题是doc老师，和去年的合肥一样，沈阳站撇去两条水题是1题铜两题银，我们过了C卡了E，最后以罚时打了铁。 正式赛赛题AB比较水，第一题选两个最大的数相加，第二题求分子质量。C是给出函数$ f(x) = 2 * f(x - 2) + f(x - 1) + x ^ 4 $给定$ f(1) $，$ f(2) $，求$ f(n) $。E是求含有S个点的完全图的数量。一开始我们分配是推C的公式（觉得不像是快速幂），我想的是dfs解决E，用在合肥的方法，但是不太好去重，后来zyyyyy试了一会儿C放弃了，写了另一个dfs试图过E，结果T了。后来我和Song打算搞C的快速矩阵幂，我快速幂记不得了，后来Song给我讲我也没听懂，因为她把矩阵右乘左乘搞反了，不过后来我想到了杨辉三角，构造了一个7阶矩阵：$$M\times\begin{bmatrix}f(n - 2) \\f(n - 1) \\1 \\i \\i^2 \\i^3 \\i^4 \\\end{bmatrix}=\begin{bmatrix}f(n - 1) \\f(n) \\1 \\i + 1 \\(i + 1)^2 \\(i + 1)^3 \\(i + 1)^4 \\\end{bmatrix}\tag{1}$$ 然后就过了。E题一直没过，后来看到旁边南航4题铜牌队过了，一问他们也是搜索，不过他们用了vector来判重的，但是我们是set。这道题的题解专门列了个blog 感受 第一次坐飞机，第一次去东北，表示非常兴奋。东北其实并不冷，但是沈阳风很大，而且喜怒无常，穿上棉毛裤也不感觉暖和一点，不穿也不感觉冷，但是裤子要sa起来，不然确实串风。东北菜其实不太好吃，但是锅包肉确实特别好吃，我们吃了两次，第二次在饭店里面的还加了柠檬，几乎被我们五个人秒了。此外杀猪菜也很好吃，就是量少，酸菜有点酸，我吃不惯。玉米面烙饼也很好吃。 在东北大学见到了老同学，老同学非常热情，晚上请我们吃了顿饭（PS东北菜不太吃得惯，但是锅包肉真心好吃），第二天还买了特产小梨子送给我们。 比赛完了我们和老师五人一起玩了南湖公园，在南湖公园溜冰。具体就不说了，大家都比较惨，还玩了那个两个脚独立的滑板。 周日晚上我们开始八卦之夜。大家分享对对方的看法，各种互黑，我也树立了毕业之后去说相声的远大志向。 热身赛是去年的题目，第一题居然是No Input猜一个数字，结果是东北大学的建校的年份。然后有一道题应该用SAM做的，然后我提出就暴力一下，顺便测测T，结果交了一发居然A了。 被质疑的大连海事大学金牌队就在我们对面，而且他们没有来，被我们缴获了他们的密码。 刚下车从机场打车到东北大学，司机东北人非常爱说话，说小萌是歌星（她来的时候带了个帽子），我们是小萌的保镖，又调侃小萌太男孩子（鉴于她最近搞了一个超级丑的头还不承认），过收费站的时候和收费员一个劲的美女的称呼。 这次比赛暴露出了一些问题，因为ACM是一个1+1+1&gt;3的比赛，和OI是不同的。队员实力导致必然每个人有擅长的方面，也有每个人不擅长的方面，但否能够扬长避短考验每个团队的能力。无论是去在有异议时理解和信任别人的想法，还是在别人质疑时有自信坚持和完善自己的想法都是非常考验一个人的。这次比赛我觉得在这些点上，大家都做得不够好，但是相比合肥站，我觉得其实是没有遗憾的，每个人都非常努力地发挥了，并且在互相理解和信任上也进步了很多。因此在我们每一次1Y的时候，我是非常骄傲能在这么一个队里面。这次题目偏难一点，我们之前也没有训练过这种一题铜的比赛，有点猝不及防，最后也是输在了罚时，但是我相信大家将来会越做越好。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCPC2016合肥小记]]></title>
      <url>%2F2016%2F10%2F16%2FCCPC2016%E5%90%88%E8%82%A5%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[今天参加了CCPC2016合肥站的比赛。因为z+y的神脑洞，我们没有在规律题上怎么卡，而是死在了图论上，果然Cu到Ag还是算法不行。今天重现赛，我把我改掉那&amp;&amp;短路的代码交了一遍就1A了，考虑到我比赛最后30min一个人在队友怀疑中敲完了自己的思路，而且被短路虽然是低级失误，但我之前真的没遇到过（我平常if, for都是打大括号的，这次实在是赶时间）。我也问心无愧。我不遗憾，只是太可惜了。代码 正式赛赛题我们过了HIEC，卡了A（图论）。I题是位运算，对r先求补，mask掉highbit，然后不停lowbit修改l，比赛的时候zyyyyy写的，这是重现时我写的代码，在实际上写的时候将long long映射到int[64]会比直接的位操作要方便一点。H题要求给定序列a[i]，查询a[l..r]的xor的结果。一开始我样例搞错了，因为我把异或和非异或记反了。E题扫雷，要求是3行N列的矩阵的扫雷游戏，其中第二行的所有格子是已知的且都没有雷。求所有雷的安放的情况的总数。可以发现只要第一列确定了，后面每列的雷数（0, 1, 2）就确定了。这里贴一份网上扒的代码。C题是一道博弈的题目，给定一棵树，树的边权为0或1。对于每个查询，给定一个点作为树根，女生和男生交替选择一条权为1的边，并翻转从这条边到树根路径上的所有边。直到某一方不能找到权为1的边时，另一方就赢了。首先对于一条链来说如果根节点所在的边权为1，那么就可以翻转。一开始我没看懂，因为树的顶点是可以指定的，所以不一定就在最上面。A题，将一个竞赛图拆成两部分P和Q，判断P和Q是否同时都是传递的。当时我们的想法是首先不能有环，其次每条链上都必须是传递的，也就是每两点距离都是1。因此我当时敲的解法是dfs，使用to[u][v]表示能从u到v，假设现在对s进行dfs，首先对所有s连通的点i进行dfs，如果不满足性质则整个都不满足性质，然后检查i的所有能到达的点j，如果从s到j有直接边并且从j到s没有后向边，那么就是满足性质的。不过时间比较紧，我调试的时候遇到了sof（递归爆栈），当时比赛没发现是sof，因为控制台上没有出现任何错误提示，都以为时中途某个代码RE了。后来发现是有一句话把dfs短路掉了，导致最后一个单独的点无法被访问。对这条题目是比较遗憾的，因为当时队内一直希望找到更有效的解法，我自己也不自信，等到最后的半小时的时候我才开始敲我的思路，最后也非常紧张，没调试出来。我们对面的河南大学软件学院的同学是用了SPFA(O(kE), k&lt;=2)求了每两个点之间的最短路（dijkstra的O(V2)说会超时），然后检查是否存在有两点之间距离大于等于2。另有做法是分别添加Q的边和反向边插到P里面，然后拓扑排序判断是否有环。特别注意的是，我们使用PC^2评测的时候，PE是判成WA的，也就是没有PE，在做H还是I题的时候多输入了一个换行符，于是就WA了，浪费了一点罚时（不过也到不了银牌就是了）。PS补充一下CB有的时候是不能直接在Console黏贴的，这是正常的，可以将控制台换成gnome就好。 感受 合肥站的组织继承了ccpc组织优良的传统（虽然这才第二年）。热身赛的时候我们的键盘是大回车，导致backspace很容易按错，结果主办方第二天就换了键盘（虽然这次end键移到右上角，各种误触page up了）。 安徽大学好大啊，而且建筑特别漂亮，环境也好，第一天中午在操场上玩了半天器材，晚上走了半天才从最北边走到图书馆（中轴）。 第一次混进了教练餐（自助餐），感觉挺不错的，宾馆是安徽大学磬苑宾馆，感觉挺好的。安徽大学是发的自己学校的校园卡，80块钱，我们都买了一堆零食，SBzyyyyy给自己买个副耳机也是醉了。 正式赛早上恰逢合肥国际铁人三项，好多人堵在天宫酒店过不来，我们在坐在体育馆的看台上等了好长时间，中间还有志愿者给我们送来热水，期间我们看隔壁icpc大连场大佬们各种神过题（后来那一场4个AK，7题才铜）。最后十一点半比赛才开始，很多人最后都没赶上回去的车。 有幸遇到了初中同桌+6，本来晚上准备找她吃饭的，结果她晚上有个招聘，不过招聘完了晚上大家在宾馆玩杀人游戏，不过真是醉了，每次都是天亮了我死了，唯一一次我没死是因为我是杀手。 热身赛的时候没有比过石河子大学，正式赛报了“仇”。 学弟们都很强，希望他们能够再接再厉，为我校取得更好的成绩。 同沈阳最后一条感受。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[字符串算法学习]]></title>
      <url>%2F2016%2F10%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[总结一下常用到的字符串匹配和查找算法，如KMP、Trie、AC自动机等。并使用摊还分析等方法分析了部分算法的复杂度 KMPKMP算法是一种前缀搜索方法，也就是说在搜索窗口内从前向后逐个读入文本字符，搜索窗口中文本和模式串的最长公共前缀。相对于前缀搜索，还有后缀搜索（Boyer-Moore、Horspool、Sunday）、子串搜索等方法。为了方便阅读，未特别注明情况下统一模式串为P，长m，以j为下标；文本串为S，长n，以i为下标，i和j下标从0开始。(i,j)表示匹配S[i]和P[j]。 KMP对朴素算法的优化 朴素的字符串匹配算法复杂度为O(n*m)，对于长n的文本串S，从位置[0..(n-m)]开始搜索匹配长m的模式串，对于每个位置至多需要m次比较。假设在(i,j)位置发生失配，那么接下来应当从(i-j+1,0)位置开始重新匹配。 容易发现其中有一些比较和回退操作是多余的。例如，假定模式串为P为&#39;ABCDABD&#39;，文本串为S=&#39;ABC ABCDAB&#39;，假设从(0,0)位置开始匹配，在(3,3)位置发现&#39; &#39;和&#39;D&#39;不等。此时朴素算法直接在(1,0)位置重新开始匹配，但实际上在刚才比较过程中可以得到(0..3,0)位置都是不行的，因为&#39;B&#39;、&#39;C&#39;、&#39; &#39;都不等于&#39;A&#39;，因此可以从(4,0)重新开始匹配。 另一个例子，考虑新的S=&#39;ABCDAB ABCDABCDABDE&#39;，在(6,6)处发现&#39; &#39;和&#39;D&#39;不等失配。同时发现P[0..1]和P[4..5]都能匹配S[4..5]（当然S[4..5]和S[0..1]都能匹配P[0..1]的&#39;AB&#39;，但目前我们考虑只移动模式串），由此可以尝试从(4,2)（注意j变成了2不是0）开始重新匹配，容易发现S并没有发生回退，而P右移了4位，用自己P[0..1]而不是P[4..5]的&#39;AB&#39;去匹配S[4..5]了。 因此可以得到KMP算法的思想：如果模式串P在(i,j)处失配文本串S，那么可以知道至少P[0..(j-1)]和S[i..(i+j-1)]是匹配的，既然如此，不妨可以利用已经匹配的这段长度，只回退（将串向右移动）模式串P，不回退文本串S。因此通过KMP算法，假设在(i,j)位置发生失配，那么接下来应当右移符号串j-f(j)长度，从(i,f(j))位置开始重新匹配（注意此时失配前P[0..(j-1)]和S[i-(j-1)..i-1]已经匹配的部分会和P[f(j)-(j-1)..f(j)-1]重新匹配），其中f为next函数，将在下节中详细介绍；特别地，当j = 0时，我们应当从(i+1,0)开始匹配。可以得到这样算法的复杂度为O(n+m)。 KMP算法和next函数首先定义边界的概念，v是u的边界表示v是u的后缀，也是u的前缀。有两类函数可以实现KMP，一种是fail函数fail(j)，对于失配的(i,j)，fail(j)是P[0..j]中最长边界对应的前缀的最后一个元素的下标。另一种是next函数next(i)，对于失配的(i,j)，next(j)是P[0,j-1]中最长边界后面那个元素的下标，所以next(j)表示在(i,j)失配后从(i,next(j))重新匹配。fail实现的特点是计算的值会有很多-1，但是next实现只有next(0)是-1。一般采用next函数进行描述。 next函数f(j)指出了查找下一个匹配时的模式串（这里可以理解为P[0..m-1]的子串P[0..j]）的回退距离（模式串P向右移动的距离），或者可以被称作最长边界。对于模式串P[0..j]来说，f(j) = max(k)满足P[(j-1)-(k-1)..(j-1)] = P[(j-k）..(j-1)] = P[0..(k-1)]（注意是j-1和k-1，有别的定义是j和k的）。这里要求是最大的k是考虑到可能存在多个k，为了不丢失匹配，回退距离应当尽可能小。 特别地，当j = 0时，即对于(i,0)位置的失配，指定f(0) = -1，这意味着我们应当右移文本串S。 为了计算f(1..j)，根据定义，朴素的方法需要O(m^2)的复杂度。但是可以采用dp实现线性复杂度的算法：令f(j) = k，即已知最大的k满足P[j-k...j-1] = P[0...k-1]，现在求f(j+1)： 如果P[k] = P[j]，则f(j+1) = k+1。 如果P[k]!=P[j]，于是显然P[0..k]显然不是P[0..j]的后缀（注意根据f定义下标分别是到j和k），所以只能在P[0..(k-1)]上寻找P[0..j]的后缀，但是P[0..(k-1)]也不一定就满足条件，当然可以对P[0..(k-1)]的所有前缀判O(k^2)次，但是也有简单办法，那就是利用失配前已经匹配了的结果。令k= k2 = f(k)，继续寻找，如果此时P[k2]=P[j]，那就符合了，否则还要继续寻找。为什么说只要比较P[k2]=P[j]就行了呢？前面的k-1的长度不需要比较了么？因为k2是最大的满足P[k-k2..k-1] = P[0..k2-1]（也就是P[0..k2-1]的最长边界长度），而注意到我们发现P[k]!=P[j]，说明至少P[0..k-1]和P[j-k..j-1]是匹配的，因此P[0..k2-1] = P[k-k2..k-1] = P[j-k..j-1]，即我们新找到的P[0..k2-1]也和P[j-k..j-1]匹配。 下面对P=&#39;ABCDABD&#39;构造next函数。根据上文，首先有f(0)=-1。接下来计算f(1)，也就是在(i,j = 1)发生失配。我们需要找到此时P[0..(j-1)]=&#39;A&#39;的某个后缀同时也是P的前缀，显然并不存在。 求next函数和KMP算法比较KMP算法实际上是求模式串P[0..m]对文本串S[0..n]长度为m+1的边界（如果存在即找到）。next函数实际上是求模式串P[0..j]对模式串P[0..j]长度最大的边界。回想KMP算法，在(i,j)位置发生失配，那么接下来应当从(i,f(j))位置开始重新匹配，因为f(j)是P[0..(j-1)]的最长边界。而在计算next函数f(j+1)时候，如果P[k]!=P[j]，那么可以理解为模式串P[0..k]在匹配文本串P[0..j]时在(j,k)发生失配，因此同样可以利用之前已经匹配了的结果，按照KMP应当从(j,f(k))开始寻找。 相关资料KMP算法有很多教程，每个教程都给出了自己的一套理解方法，没有一个我能够完全看懂。在学习过程中，我参照了Wikipedia的解释，其中适当后缀(proper suffix)，指的是不是自己本身的后缀，也就是“真后缀”。1234567891011121314151617181920212223242526272829303132333435363738// kuangbin模板void kmp_pre(const char P[],int m,int f[])&#123; // f[]：x[j-f[j]...j-1]=P[0...f[j]-1] // f[j]：为满足x[j-k...j-1]=P[0...k-1]的最大k值 // 对应于： // next[j]为满足x[j-z...j-1]=x[0...z-1]的最大z值 // next[j+1]为满足x[j-(z-1)...j]=x[0...z-1]的最大z值 int j,k; k=f[0]=-1; j=0; while(j&lt;m) &#123; while(k!=-1 &amp;&amp; P[j]!=P[k]) k=f[k]; f[++j]=++k; &#125;&#125;int KMP_Count(char P[],int m,char S[],int n)&#123; // P是模式串，S是主串 int i,j; int ans=0; kmp_pre(P,m,next); i=j=0; while(i&lt;n) &#123; while(-1!=j &amp;&amp; S[i]!=P[j]) j=next[j]; i++;j++; if(j&gt;=m) &#123; ans++; j=next[j]; &#125; &#125; return ans;&#125; 复杂度分析求next函数具有线性复杂度，考虑到内部有一层while，使用通常方法不易计算。实际的复杂度计算使用了摊还分析。 摊还分析对于一个操作序列，并不是所有操作的复杂度都相等的，例如对于std::vector，push_back()操作是O(1)的，但是当满了之后resize的操作却是O(n)的，仅通过push_back()便认为对std::vector增加一个元素需要常量时间是不恰当的（虽然却是是常量时间）。摊还分析(amortized analysis)是一种分析操作序列中所有操作的平均时间上界的方法。摊还分析主要有聚合法，核方法和势能法。 聚合法聚合法就是求出所有操作加起来最坏情况的总代价，然后除以总操作数。对于std::vector的添加元素操作来说，假设初始大小是1，倍增因子是m，要添加$n$个元素，需要重新分配内存$\lceil log_{m}{n} \rceil$次，第$i$次分配内存需要移动$m^{i-1}$个元素，总共需要$ \sum_{i=1}^{\lceil log_{m}{n} \rceil}{m^{i-1}} = O(n) $次移动操作，另需要push_back $n$次。因此复杂度为O(1) 核方法MIT的算法导论课公开课老师讲这个的时候在黑板上写了2 3 3 3…对这个记忆犹新核方法的原理就是把复杂度低的操作承担一部分复杂度高的操作的代价，从而证明算法复杂度的上界。定义$c_i$为第$i$个操作的真实代价，定义$\hat{c}_i$为摊还代价。在第$i$时刻，定义信用为$\sum_{i=1}^n{\hat{c}_i} - \sum_{i=1}^n{c_i}$，选取的摊还代价要保证信用始终非负，因为一旦信用是负数，那么这个操作实际上是在开销上界内不能完成的上图是一个倍增因子m为2的动态表std::vector，$size_i$表示添加第$i$项时的表达大小，真实代价$c_i$由两部分组成，一部分是添加进表的固定成本（$c_i$第一行），另一部分是把元素复制到新表中的成本（$c_i$第二行），$bank_i$就是信用。对于$m=2$的情况，可以发现$\hat{c}_i$取3即可，这包括自己的真实代价，移动表的前一半的代价，和移动表的后一半的代价。对于普遍的倍增因子m，后面m-1的元素要m个元素的移动代价，加上添加进表的1，摊还代价取$1 + \frac{m}{m - 1}$，特别地$i = 1$时只要支付自己的移动代价，故摊还代价为$1$，于是等式左边$\sum_{2}^{n}{(\frac{m}{m - 1})} + n = \frac{2nm - n - m}{m - 1} $，等式右边$n + \sum_{0}^{\lceil log_{m}{n} - 1 \rceil}{m^i} = n + \frac{n - 1}{m - 1} = \frac{nm - 1}{m - 1}$，发现左边恒大于右边。 势能法势能法和核方法基本上是相同的，区别在于核方法要先假设摊还代价，而势能法先考虑的信用和（也就是势）。对于有的题目势能法比核方法简单。对于上面的$m=2$的动态表，定义势函数$\phi(D_i) = 2i - 2^{\lceil log_{2}{i} \rceil}$，由于$i = 2^{log_{2}{i} }$，所以可以得到式子恒为正。因此满足势函数的基本要求$\phi(D_0) = 0$和$\phi(D_i) \ge 0$。下面计算摊还代价$\hat{c}_i = c_i + \phi(D_i) - \phi(D_{i - 1}) $，其中$c_i = \begin{cases} i \, , \, (i - 1) &amp; ((i - 1) - 1) == 0 \\1 \, , \, otherwise \end{cases}$。通过对$i$的讨论，可以发现每个操作的摊还代价是3，这和前面的核方法形成了印证。下面考虑倍增因子为m的情况，定义势函数为$\phi(D_i) = 2i - m^{\lceil log_{m}{i} \rceil}$，可以进行类似的计算，得到每个操作的摊还代价是$1 + \frac{m}{m - 1}$ 求next函数的复杂度下面使用摊还分析计算求next的kmp_pre函数的复杂度。首先跟踪变量k，因为k出现在了最内层的while中，但是j没有出现。发现对k有两次操作，第一个是k = f[k]，这个操作是当P[k] != P[j]时，利用先前的结果计算f(j+1)。第二个是++k，这个是当(j, k)匹配时，令f[j + 1] = k + 1，并继续外层的while循环循环计算f(j + 2)的值，直到j &gt;= m结束，m是模式串的长度。可以发现外层的j和k每次自增1，并且在等于m的时候跳出循环，这类似于对动态表添加元素的1的代价。特别地可以发现j和k的上界最高就是m。内层while循环是将k不断缩小，很难求出外循环的某次循环中内循环共循环了多少次，但是可以看出内循环体在整个函数中最多被执行m次，这是因为k最多只能加到m，所以最多只能变小m次。将外层循环视为操作序列，内层循环摊还的代价就是O(1)。因此这个函数的总代价是线性的。 TrieTrie（/ˈtraɪ/，字典树，前缀树）将多个字符串组成一棵有序树。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。在构造Trie树时，需要用flag数组标记每个节点是否可能是某个字符串的结尾 例题HDU 1247是Trie的简单应用，首先把每个字符串添加到Trie树上，然后对于每个字符串，搜索他的每个前缀，对于任意前缀，如果它产生的字符串属于这个单词表（碰到flag为true的节点），那么紧接着继续往下搜索看能不能搜到第二个字符串。这道题注意要搜索每个前缀，考虑下面的样例 ha hat word hatword 如果在实现时，对hatword第一次query到ha即返回，下面从tword开始就无法匹配了，由于第一次query已返回，所以也不会继续搜索前缀hat了。 AC自动机AC自动机（Aho-Corasick automation）结合了Trie和KMP算法。它能够匹配多个字符串]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最大流]]></title>
      <url>%2F2016%2F10%2F14%2F%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
      <content type="text"><![CDATA[总结一下最大流的各种算法 最大流问题设赋权有向图D(V,E,C)，其中每一条边的权值c∈C表示这条边的容量。流f : V * V -&gt; R是对于边e∈E的函数，且必须满足： f(u,v) &lt;= c(u,v)f(u,v) = -f(v,u)Σf(u,*) = 0, u不是S和T 以上三个条件保证了每条边的流量|f(u,v)|（流出即为负流量）不能超过容量、流经中间节点的流量无损耗。特别注意，对于条件2，可以得到只要有向边(u,v)上存在流f(u,v)，那有向边(v,u)（该边可能不存在，这意味着c(v,u)=0）上必然存在f(v,u) = -f(u,v)。但是实际上我们只考虑流量为正的边，所以在一些教程上也只画出了这样的边。最大流问题就是求解从源S（唯一的开始节点）能够流出的最大流量，也就是汇T（唯一的结束节点）能够得到的最大流量。 Ford Fulkerson方法最大流最小割定理对于网络流G(V,E)，以下命题等价： f是G的最大流残余网络不存在增广路径最大流的值就是这个网络的最小割。 残量网络残量网络是一个双向图。定义剩余容量cv(u,v) c(u,v) - f(u,v) 若(u,v)∈E 由cv为权的新有向图称为残量网络。并且当f(u,v)为负数时，cv(u,v)会大于c(u,v)。 增广路径Ford Fulkerson方法的Edmonds Karp实现与朴素Ford-Fulkerson算法不同的是Edmonds-Karp要求每次找长度最短的增广路径，即使用BFS查找增广路径。时间复杂度是O(n*m²)，空间复杂度是O(n²)。 Dinic算法SAP算法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5889 Barricade 最大流最小割+BFS]]></title>
      <url>%2F2016%2F10%2F13%2FHDU5889Barricade%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2016 青岛网络赛赛题 Barricade 题意有图G(N, M)，每条边具有相同的长度和不同的权值。现在有敌人从点N沿最短长度路径到点1。现在要求在部分边上设置障碍，使敌人无论怎么走总能碰到障碍，求这些切断的边的最小权值之和。 思路分析因为敌人走最短路径，所以要建立新图，新图中只能保留死路和最短路径。因为每条路的长度都相等，所以可以采用bfs来寻找最短路径。在建立新图之后对新图用网络流即可。从点N开始使用dis记录到各点最短路。当bfs到点x，尝试使用点x松弛所有相连点i并在新图中添加路径(x,i)；但当bfs到点1并且点当前点x的长度大于dis[i]（广度优先搜索总是最短路的），则不使用该点更新dis。这样得到的图只含有死路（在得到dis[i]前bfs的部分）和最短路径。代码 需要注意的地方有几个地方需要注意： 第一个是使用bfs建立新图时 第二个是这道题源是N，汇是1，是反过来的 第三个因为最短路，所以只要添加单向边就好。 在bfs更新dis的时候我把u和v搞反了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC 2013 杭州邀请赛]]></title>
      <url>%2F2016%2F10%2F13%2FICPC2013%E6%9D%AD%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9B%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2013 杭州邀请赛复现 1010 Shaolin题意少林寺和尚上山需要比武，每个和尚具有id和武力值(k, g)。新和尚在比武时在已经上山的和尚中选择和自己武力值最接近的和尚比武（如果有两个就选择比自己弱的那个），现在给定和尚上山顺序，对于每个和尚计算应该和谁比武。 解答模拟，考虑到set是自动排序的，因此可以使用两个set分别存正序和逆序，然后分别lower_bound，注意处理只有一个武力值最大/最小的情况。代码 1009 Building bridges题意有一个m行n列的矩阵上有C岛H岛和O海洋。现在要在H和C之间建一个曼哈顿距离最短的桥。要求输出选择的H岛的坐标(x1,y1)和C岛坐标(x2,y2)，在曼哈顿距离相同的情况下依次按照x1, y1, x2, y2从小到大进行排序。 解答直接爆搜O(n^2*m^2)。代码 1001 Robot题意有一个1..n的环，从点1开始以均等概率逆时针或顺指针走w步，问进行m次操作后，停在[l,r]区间上的概率。 分析这道题目是概率dp，假设在旋转次m时，落在环上每一点的概率可以由旋转m-1次的概率求得。比较坑的地方是这题卡常数，我的一个算法用((((1 + x) % n) + n - 1) % n) + 1求wrap，多调用了几次mod就挂了。这也提醒我一般mod使用要注意，在我的笔记本电脑上测试1s能跑5.2e7次，乘法能跑1.6e8次。代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC 2014 广东现场赛]]></title>
      <url>%2F2016%2F10%2F13%2FICPC2014%E5%B9%BF%E4%B8%9C%2F</url>
      <content type="text"><![CDATA[ACM/ICPC 2014 广东现场赛复现 1011 How Many Maos Does the Guanxi Worth题意有N个点，要求去掉一个点使得不连通（输出Inf），如果不能做到则使得最短路径路径最长（输出该值）。 思路裸的dijkstra，增加del[disable] = true，在判断vis[j]的地方加上判断!del[j]。由于删掉一个节点导致图可能不连通，因此注意红书模板mark==-1的时候要直接return，外循环不要N次。代码 1002 The E-Pang Palace题意有小于30个点，找出两个（必须是两个）不相邻、不相交的矩形。求面积并的最大值。 思路用vector&lt;int&gt; corx，cory记录出现过的坐标，并排序。用bool hit[x][y]表示点(x, y)是否出现过。在corx和cory中枚举出x1, x2, y1, y2（x1 != x2, y1 != y2）。如果点(x1, y1)和点(x2, y2)存在，那么将矩形添加到vector&lt;RECT&gt; vecrect中。接着分别检测相交（矩形1有一个点在矩形2里面）、相邻（横坐标相等，一个矩形纵坐标左边在另一个矩形的两个纵坐标中间）。这里如果实现保证struct RECT中x1 &lt; x2 &amp;&amp; y1 &lt; y2，会比较方便。但是还是WA，后来发现矩形1在矩形2内也算对的。我觉得这就比较坑了，因为题意是圈地分封，如果两个矩形成包含关系怎么分封呢？代码 1009 Little Zu Chongzhi’s Triangles题意有N个长度不等的线段，问能够组成的所有三角形最大面积和是多少，棒子不一定要全部用完。 思路贪心（当然这条数据较小也可以暴力，复杂度(12,3)(9,3)(6,3)）。每次取尽可能长的边。首先对数组a从小到大排序，如果a[i], a[i - 1], a[i - 2]能够组成三角形，那么加上这一组，如果不能，考虑a[i - 1], a[i - 2], a[i - 3]（舍弃a[i]是因为根据两边之和大于第三边，a[i - 3]相对于a[i - 2]肯定更不可以了）。证明：在HDU 5914上我们得到结论一个数列上任意三条边不构成当且仅当该序列是类斐波拉契数列的子数列。代码 1005 Song Jiang’s Rank List题意给水浒英雄排座次，按杀人多少，杀人数相同按照名字字典序排列。阅读理解，水题。代码 1004 Signal Interface题意思路]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[西瓜书笔记]]></title>
      <url>%2F2016%2F10%2F12%2F%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[开始写周志华教授的《机器学习》一书的学习笔记。也包含prml等书的学习笔记。 绪论假设空间]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[最长上升子序列(LIS)和最长公共子序列(LCS)]]></title>
      <url>%2F2016%2F10%2F04%2FLISLCS%2F</url>
      <content type="text"><![CDATA[最长上升子序列的O(NlogN)方法和最长公共子序列(LCS) 最长公共子序列(LCS)这是一个经典的dp问题，使用dp[i][j]表示表示序列X的i位和序列Y的j位之前的最长公共子序列的长度。那么如果X[i] == Y[j]，dp[i][j] = dp[i+1][j+1] + 1；否则dp[i][j] = max{d[[i-1][j], dp[i][j-1], dp[i-1][j-1]}。 例题 POJ 1458 Common Subsequence第一次写成这样。应该是这样 最长上升子序列(LIS)O(N2)方法运用动态规划的方法，记录li为序列a1..(i-1)中前i个数组最长的上升序列长度。现在要求ai，考虑将ai插在aj，j &lt; i后面，则那就是要满足以下条件： 必须ai &gt; aj lj最长 因此，对于ai + 1，需要遍历1..i的所有l，找出最大的l[m]并且a[m] &lt; a[i]。可以发现复杂度为O(n^2)。容易发现，寻找最大的lj可以使用二分法。因此可以得到下面的O(NlogN)方法。 区间段问题为了更好地理解下面的O(NlogN)方法，可以考虑有若干个任务具有不同的起止时间，在同一时间只能做同一任务，并且该任务完成后才能开始新的任务。现在要求找出能够完成的最多任务数。容易想到这是一个贪心问题。事实上每次选取结束时间最早的任务，这样保证了剩下的时间短尽可能地长，而一个较长的时间段肯定比它的较短的部分的可选工作数要多（至少不会变少）。 O(NlogN)方法这个方法与区间段问题的思想类似，要使得上升子序列最长，就要使得序列上升尽可能慢，因此我们希望每次在序列最后加上的数尽可能小，当然由于数列的长度是有限的，所以不一定这样能得到足够长的LIS序列，所以我们在确定新得到的LIS数列足够长的时候再更新长度。因此我们记录dpi为长度为i的LIS序列的末尾元素的值，使用len记录目前最长LIS的长度，显然dpi关于i是单调不减的。对于aj，我们顺着dp1开始找，一旦发现dpi - 1 &lt; aj &lt; dpi，那么可以用aj更新dpi。同时如果当前的i（从1开始）大于记录的len时，用i更新len。需要注意的是，虽然在原序列中aj出现在dpi对应的aj‘之后，如果aj包含在序列中，那么比aj大的aj‘显然不会包含在序列中，但是这不影响取得最大值，因为除非从aj开始的新序列能够去得更长的len，否则仍然取得的是当前的序列。在寻找时，考虑到dp是一个不降序列，可以使用lower_bound函数（内部采用二分查找）。这个函数将会返回大于等于val的第一个值的指针，如果不存在就返回end指针，在使用时候注意区别upper_bound函数，upper_bound函数返回的是严格大于val的第一个值。注意指针的差值从0开始，但是序列长度从1开始，所以得到的差值转换成长度要加1。 例题 HDU 5532 Almost Sorted Array此题题意要求找出一个序列是否可以去掉最多一个元素形成一个sorted array。因此可以正反（考虑到可能是不升序列也可能是不降序列）求一次LIS（不降子序列），那求出的最长上升子序列的长度至少要大于等于n-1那么就是满足题意的。当然这道题目也可以用O(n)实现。O(n)算法需要注意不能只判断连续情况。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5914 Triangle]]></title>
      <url>%2F2016%2F10%2F04%2FHDU5914Triangle%2F</url>
      <content type="text"><![CDATA[这道题来自HDU 5914/ CCPC2016 长春现场赛 Triangle这道题目一开始想的是打表的解法，后来发现一直WA。后来找规律发现是斐波拉契数列。 题意有边长1..n（n不超过20）的边，问最少去掉几个边才能使得剩下的边不能组成三角形。 证明充分性：斐波拉契数列的任意项li，lj，lk均不构成三角形。由于任意三角形三边a、b、c（a &lt; b &lt; c）均需要满足a + b &lt; c。而对于斐波拉契数列中任意的边lk - 2 + lk - 1 = max(li + lj, i,j &lt; k) = lk，因此不可能存在构成三角形。必要性：在斐波拉契数列中增加任意一项，则可以构成至少一个三角形。假设添加边长m在li和li + 1之间，由于li + li + 1 = li + 2，因此 li + m &gt; li + 2，因此至少构成一个三角形。特别地，形如1, 3, 4, 7, 11…或者2, 5, 7, 12…等数列同样具有斐波拉契数列f[i] = f[i - 1] + f[i - 2]的性质，但是以1, 1开始的斐波拉契数列显然“利用率”最大。 打表方法之前有试过贪心打表方法，具体地，对于每个n，枚举出所有的三角形，统计出在三角形中出现最多次数的边（如果次数相等则进行dfs搜索），不断剔除边和，并移除该边对应的三角形，直到所有三角形都被移除。但事实上这种方法是不行的。例如对n=13，算法分别移除9（出现40次）、10（40）、8（39）、11（38）、6（34）、4（25）、12（35）、3（18），但却没有移除13（30）。其构成的1, 2, 5, 7, 13并不是最优的数列。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HDU 5553 Advanced Calculator 表达式求值]]></title>
      <url>%2F2016%2F10%2F01%2FHDU5553Advanced-Calculator%2F</url>
      <content type="text"><![CDATA[这道题来自HDU 5553/ ICPC2015 合肥现场赛 Advanced Calculator，现场赛无人做（那场1题Cu，2题Ag，4题Au）。截至目前HDU上只有三人过这条。我现在还没有过这条，所以想贴出来我的想法、遇到的一些坑和代码http://paste.ubuntu.com/23275313/，也希望有大神能给我一点测试数据什么的。这道题就是表达式求值，运算符有+、-、*、/、(、)、=（可以连等）。操作数分为int和double。同时有唯一输出函数print。通常想到的办法就是逆波兰式。 逆波兰式基本的逆波兰式逆波兰式将中缀表达式转换为后缀形式。首先需要两个栈，表达式栈tok储存后缀表达式结果，栈ops用来暂时存放运算符。遇到变量的时候直接入tok栈。遇到运算符比较当前运算符op和ops.top()运算符的优先级。如果当前运算符op优先级大，则将op直接入栈ops；如果当前运算符优先级小于等于则依次弹出ops栈中运算符并入tok栈，直到栈空。特别地，当ops栈顶是左括号(时候，可以认为左括号优先级最小，因此当前运算符op可以直接入ops栈。在当前符号是右括号)的时候，弹出ops运算符中并入表达式栈，直到看到左括号(。 处理单目运算符有两个单目运算符正号+和负号-，同时他们也身兼二目运算符加法和减法的作用。为了区别这两个运算符，需要增加bool Arity2来记录是否在每个操作符前面出现了操作数，如果出现了，则是二目运算符。特别地，唯一的函数print可以作为一个单目运算符处理，实际上对于逆波兰表达式而言，函数本身就应当作为一个运算符，只是参数数目要以逗号数目确定。 不同数据类型的四则运算首先是数据的存储，对于运算数存储，一种方法是采用union来合并double和int，同时使用type来记录类型信息，不过这里考虑到可能存在的精度问题，以及将变量和常量统一起来，这里采用string val来记录数据，对于常量val为其字面值，对于变量，val为器变量名，对应值查表slots。对于运算符，直接采用char op存储。同时采用struct Item来把运算数和运算符统一，这样方便统一栈操作。 已知的坑不同数据类型的连等号考虑以下代码:1234int a;double b;b = a = 1 + 1.5;print(b); 结果应该a=2，b=2.000000而不是2.500000。 使用double2string转换丢失精度在进行计算的时候，采用sprintf和sscanf进行string和valuetype之间的转换。根据cppreference对sprintf的说明： Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6.可以发现从string到double必须人为指定一个较长的数精度，这里指定了30位的小数。 It should be noticed that not all C— programs should contain variable statements变量是可以没有声明的直接引用的，这时候默认变量的值是0。 string::substr这个错误是经常犯的，substr的第二个参数是长度，而不是结束为止。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[二分图匹配]]></title>
      <url>%2F2016%2F08%2F21%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
      <content type="text"><![CDATA[总结一下二分图匹配的匈牙利算法 定义把图的顶点分为不相交集合U和V，不存在连接U或V内部点的边，这样的图成为二分图（bipartite graph）。二分图有一些性质，如二分图中不存在奇数条边的环（奇圈），因为环必须首尾相接的，奇数条边必定会使首和尾分处于U和V中。匹配是对于边而言的，表示在所有的边中，任意两条边都没有公共顶点。如果一个图中的所有顶点都能够构成匹配，则称这个图存在完美匹配，否则这个图只存在最大匹配，含有尽可能多的匹配边数。一个点被当前匹配饱和指这个点在当前匹配的某个边上。 匈牙利算法算法介绍匈牙利算法试图优化当前的匹配，得到边数+1的匹配。构造的方式是从一个非饱和点（也称为非匹配点，saturated vertex）开始，依次通过非匹配边、匹配边、非匹配边…（这样非匹配边和匹配边交替形成的路径叫做交替路）。容易发现这样的路径总结束于一个到非饱和点的非匹配边，因为到达于一个匹配点，如果轮到走该点关联的那条匹配边，这样要么走完完美匹配，要么到达另一个匹配点。如果轮到走非匹配边，则可能到达一个匹配点（回到上个情况），也可能到达一个非饱和点，但是非饱和点肯定是不能继续走匹配边形成更长的交替路的，于是结束。可以发现，这样走下来非匹配边始终比匹配边多一条，并且除了一头一尾的两个节点，中间节点全部是匹配点，如果反向匹配边和非匹配边，就能够得到边数+1的匹配。因此把这条起点和终点未饱和的交替路称为增广路。可以发现这样的增广路中每个点至多出现一次，因此反向匹配边和非匹配边后不会出现一个点有两个匹配边连接的情况，并且增广路的长度总是奇数，并且总是起于二分图的一端，终于二分图的另一端。根据berge定理，如果图G中不存在对匹配M的增广路，那么该匹配M是最大匹配。 算法实现在实现匈牙利算法时，并不需要显式地去建立交替路，交替路的扩展和反转通过dfs（或者bfs）隐式地表现出来。这样的算法复杂度O(EV)，经过优化的Hopcroft-Karp算法复杂度可达到O(E*sqrt(V))。首先实现寻找增广路径的算法。从节点U（大写表示二分图左部）进行dfs寻找从U开始的增广路（因为从U开始，所以U必然要是非饱和点）。对于U的所有出边(U, v)，假如v是非饱和点，那么可以直接匹配U和v，显然匹配数会增加1。假如v已经和W匹配，但是能够为W在右部找到另一个匹配点x，那么就将U和v匹配。即对于这一种情况，匹配数同样是增加1的，假设原先(W, v)是匹配的，如果现在匹配U和v，则W失去匹配，匹配数并没有增加，但是如果能够找到另一个x能够和W匹配，那匹配数增加1，当然这个过程是递归的（因此匈牙利算法寻找增广路使用dfs实现），x和W匹配同样可能导致x的原配失配，因此这个算法的返回值是个表示是否存在增广路的布尔量，如果在递归的末端存在x的匹配Y不能找到新的匹配，也就是不存在从x开始的增广路，那么也不存在从v开始的增广路。对于其他情况就不存在从U开始的增广路。因此整个算法可以枚举二分图左边的点x，寻找是否存在增广路，从而得到匹配。在实现算法的时候需要注意对于有向图邻接矩阵不能设置m[dest][src]。下表给出了一个匈牙利算法的实例，其中红色点表示已经匹配了的点。增广路搜索始终从左端开始，因此从左侧到右侧是搜索的是不在当前匹配M中的边，从右侧到左侧是在当前匹配M中的边 初始情况 寻找增广路 新的匹配 例题 HDU2063代码 Hopcroft-Karp算法算法介绍匈牙利算法使用dfs寻找增广路，Hopcroft-Karp算法作为改进使用bfs寻找增广路，bfs相对dfs的优势是找到的增广路永远是最短的。因此Hopcroft-Karp每轮按层搜索多条无公共顶点的增广路并全部替换。算法流程如下： 将所有未饱和的左侧顶点作为第0层 对于偶数层顶点，通过不在当前匹配中的边寻找 对于奇数层顶点，通过在当前匹配中的边寻找 当发现未饱和右部顶点，或搜完全部顶点，bfs终止 如果搜到未饱和的右侧顶点，进行反向dfs，搜索回第一层的某个点，这样形成一条增广路。将这条增广路加入匹配，并临时删除这条路上的点和边。重复此步操作直到无法到达第0层。重新开始bfs。 算法实现Edmonds算法以上两种算法只可以在二分图上使用，这是因为二分图不会包含奇圈。 学习资料 Wikipedia 南京大学程龚讲义]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[沙盒跳出]]></title>
      <url>%2F2016%2F08%2F21%2F%E6%B2%99%E7%9B%92%E8%B7%B3%E5%87%BA%2F</url>
      <content type="text"><![CDATA[因为参加在上海举办的计算机设计大赛决赛，今天没事所以去了上海科技馆，我们观赏了多个展区之余尝试突破展览馆中计算机展览程序的沙盒，并玩一盘扫雷游戏。首先在物理展区，我们遇到一个运行着全屏课件程序的计算机，只提供了一个鼠标，系统是winxp。在查看多个界面后，我们发现在留言区有一个切换输入法的按钮，于是我们切换成微软全拼输入法，于是屏幕上出现输入法的浮动窗，右击菜单随便选择一个选项，桌面弹出一个窗口，同时出现了任务栏，切换输入法找出软键盘，运行winmine即可。在3d打印区，我们遇到了一个被ClipCursor的win7计算机，提供了一个全键盘，但是功能键（如win键，ctrl+alt键等）全部被锁了。同时展览程序的窗体被持续设置了焦点。对于这台计算机，我们采用了连按5次shift开启粘滞键的方法，对于win7系统，粘滞键启动会导致弹出一个提醒框，点击提醒框中提示即可打开新的窗口并显示任务栏。在体验区，我们遇到了一个全屏的chrome程序，只提供了一个鼠标，我们找到一个有滑动条的页面，右击滑动条选择另存为，再在框中右击选择属性，即可看到桌面。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tarjan算法]]></title>
      <url>%2F2016%2F08%2F21%2Ftarjan%2F</url>
      <content type="text"><![CDATA[求有向图强连通分量的tarjan算法直观上来讲，tarjan算法对有向图建立搜索树，每一个连通分量都是该搜索树的一棵子树。tarjan算法由一个dfs构成，在dfs过程中，将访问过的节点压入一个栈中，栈顶到栈中的的某个元素构成一个极大强连通分量。 算法原理算法需要dfn[u]=1..vertex_count记录对节点u的访问次序， 记录这个次序主要是为了处理后向边。low[u]记录u的最早祖先。显然当dfn[u]==low[u]时，得到极大强连通分量，因为u不存在可到达的祖先了，此时u也作为这个子树的根（并查集也有类似的性质），对应到栈中，根离栈顶最远，永远在最后被弹出。显然，dfn[u]和low[u]的初始值应当都为相等为x，因为此时u所在的连通分量中只发现有x。low[u]在三种情况下更新： 当存在树边(u, v)时，应当尝试用low[v]更新low[u]。树边指的是如果节点v是因为对边(u, v)搜索而被发现（注意此时未必对v进行了dfs）的，因此v是u的儿子。显然这种情况发生在对节点u的所有未访问过的子节点递归遍历的过程中。因此low[v]总是先于low[u]被更新。可以通过dfn[v]是否为0判断v是否被访问过 当存在后向边(u, v)时，应当尝试用dfn[v]更新low[u]。后向边指的是如果v是u的祖先（不仅是父节点），特别地，自环也被认作后向边。显然这种情况发生在v在栈中，因为v必然已经被访问过。因此可以得到low[i]的递推公式，这里取最小值是因为较小的总是祖先（由low和dfn的定义决定）。1234567for each (u ,v) in E if (!dfn[v]) tarjan(v); low[u] = min(low[u], low[v]) else if(v exist in stack) low[u] = min(low[u], dfn[v]) // 否则v属于另一个连通分量已被弹出 下面是整个tarjan算法12345678910111213void tarjan(int u)&#123; dfn[u] = low[u] = ++index; stack.push(u); update low[u] if(dfn[u] == low[u]) // 注意不要把if写在update的for each循环里面 pop stack to u // 注意是u不是dfn[u]&#125;int main()&#123; zero(dfn); for each u in V if(!dfn(u)) tarjan(u)&#125; 可以看到算法对于每个点都访问一次，由dfn(u)!=0保证，同样，对每个边(u, v)都访问一次。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++资源管理]]></title>
      <url>%2F2016%2F08%2F05%2Fcpp%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
      <content type="text"><![CDATA[对Effective C++在资源管理部分的内容进行总结。 C++运行时内存C++运行时内存主要分为常量区、全局/静态变量区、栈区、堆区和自由存储区。其中前两者存在于程序的整个生命周期，栈中的变量由编译器自动分配和清除，所以称作自动变量。堆区由new调用构造函数初始化，由delete调用析构函数回收。自由存储区由malloc分配一块指定大小的内存，由free释放。 RAII可以看出对于动态分配的内存（堆和自由存储）必须能够在适当时机调用delete/free进行释放，否则会造成泄露，也有可能某处代码在先前已经delete/free了，造成悬空指针undefined behaviour。当然可以建立一张表（称为对象池）登记这些指针，当满足一些条件的时候进行删除的手动管理。不过最好的方法是通过RAII借助编译器管理指针。编译器的自动回收机制包含了栈和对象两种。其中栈能够管理自动对象，但是它只会清除指针本身而非指针指向对象。 复制一般对象之间的复制行为分为4种： 浅复制：浅复制也是默认复制构造函数的实现，将源对象中的成员复制到新的对象中。因此如果源对象中存在指针，那么实际上源对象和新对象是共享指针指向的对象的，这并不是一个错误的逻辑，但是问题在于新老对象都没有意识到自己和别的对象共享着资源，如果存在析构函数（除非使用手动管理，否则必然要有析构函数用来释放指针指向对象），那么必然会造成悬空指针。 深复制：需要自定义复制构造函数，在复制行为发生时递归地建立对象成员以及指针指向对象的副本。 资源控制权转移：资源占用具有排他性 资源控制权共享：类似于浅复制，但是这种方案解决了资源释放的问题，对于需要共享的资源设置引用计数，当引用计数变为0时销毁对象，而不再通过构造函数。 深复制在深复制中可能存在一个问题，假设有若干个派生类继承基类Derived_i : public Base，现在有一个Base * d，但是不知道具体类型，现在希望对这个基类进行深复制。直接调用基类的复制构造函数Base p = new Base(d)显然是行不通的，一方面C++没有提供虚复制构造函数。常用的办法是自己定义一个clone函数。同样地，对于其他的构造函数，也是不存在多态的，因此如果需要对于不同的参数返回不同的派生类的指针，可以通过定义一个工厂函数来解决。对于没有使用继承或派生的类型，当然可以定义三个函数（复制、赋值、析构）进行深复制，假设复制对象obj，可以认为复制了一棵树，树中任何节点（成员）的析构都会导致该节点为树根的子树被删除，所以对于这棵树只能修改树根或叶子，否则会造成内存泄露。 复制构造函数和赋值构造函数复制构造函数指的形如A(const A &amp;)的构造函数，赋值构造函数指的形如A &amp; operator=(const A &amp;)的构造函数。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[flex和bison使用]]></title>
      <url>%2F2016%2F07%2F29%2Fflex%E5%92%8Cbison%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[flex/bison是对lex/yacc的开源实现，可以方便地进行编译器构造。本文主要总结了VS下的flex和bison使用。 在VS2015下配置在Sourceforge上下载 Win flex-bison插件。下载后解压，将custom_build_rules文件夹按照右击项目-&gt;生成依赖项-&gt;生成自定义-&gt;查找现有的-&gt;选择custom_build_rules文件夹并添加确定。由此可以创建以.l结尾的flex文件和以.y结尾的bison文件。为了能够编译，还需要讲win_flex和win_bison复制到.l和.y所在目录下面。同时工具-&gt;选项-&gt;项目和解决方案-&gt;生成并运行可以选择输出的详细级别，改成普通之上可以得到flex和bison的编译输出信息。 flex使用说明如何重定向输入输出流可以使用yy_scan_buffer函数。12345678910// std::string in_str 被扫别识别的字符串// slen字符串长度YY_BUFFER_STATE buffer = yy_scan_buffer(buff, slen + 2);char * buff = (char *)malloc(slen + 2);// 要以两个'\0'结束memset(buff, 0, slen + 2);strcpy(buff, in_str.c_str());int token = yylex();yy_delete_buffer(buffer);free(buff); 这里需要注意一点的是，buffer必须以”\0\0”结尾，原因是在生成文件*.flex.cpp中，函数yy_scan_buffer的部分代码如下：123456789101112131415Y_BUFFER_STATE yy_scan_buffer (char * base, yy_size_t size )&#123; YY_BUFFER_STATE b; if ( size &lt; 2 || base[size-2] != YY_END_OF_BUFFER_CHAR || base[size-1] != YY_END_OF_BUFFER_CHAR ) /* They forgot to leave room for the EOB's. */ return 0; b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ); if ( ! b ) YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" ); b-&gt;yy_buf_size = size - 2; /* "- 2" to take care of EOB's */ 如何实现迭代读取因为yylex函数默认只返回int，用来表示识别出的终结符号的类型，我们不能直接改变yylex的定义，因此用next_token封装yylex。假设要实现函数int next_token(std::string in_str, int start)，能够识别非终结符[start, end]，它的长度是内置变量yyleng。首先必须要能够记录当前读取后的位置。flex是不自带这个变量的，所以必须在每个规则的识别之后自动记录此时的读取位置，方法就是定义一个全局变量pos，并在每次识别后增加yyleng。事实上我们希望next_token能够返回一个结构，这个结构能够包含识别出的终结符号本身（如+、-、var_name、0.5之类的），识别出终结符号的类型（META_INTEGER、META_FLOAT等），长度，行号以及位置。我们定义一个FlexState结构来组织这些信息。调用层次如下： next_token调用yylex yylex进行词法分析，如果满足某一正则表达式，那么调用规则对应的处理语句 在处理语句（使用函数int make_term_flex封装）内构造FlexState，并放到全局变量中。处理语句必须return一个int，同时为了确保和yacc的兼容，建议return用%token定义的终结符，由yacc的yyparse来返回你需要的YYSTYLE类型的值。 next_token返回上步构造好的FlexState类型的全局变量flex_state 关于bison的说明bison提供了获取终结符行号和光标位置的功能。可以使用@n访问第n个文法符号的first_line、first_column、last_line、last_column属性，所以如果只需要这四个属性，可以不定义自己的struct。 yymoreyymore用来读入下一个字符串。可以参照下面代码的运行结果：123456789101112131415161718%&#123;#include &lt;stdio.h&gt;#include &lt;string&gt;%&#125;%option yymore%%"1" &#123; yymore(); ECHO; putchar('\n'); printf("yytext %s\n", yytext); &#125;"2" &#123; ECHO; putchar('\n'); &#125;\n &#123; putchar('\n'); &#125;%%int yywrap() &#123; return(1); &#125;int main() &#123; yylex(); puts("");&#125; 运行结果123456789101112131415161111yytext 111yytext 11111yytext 111222222233233 常常希望在bison中使用yymore去处理区分else和else if的情况，然而往往每次的yytext并没有和上次叠加，原因主要有两点：1. 规则中出现了return。2. 空格没有yymore，导致打断。 特殊情况的处理 假如读入字符不属于任意规则 如果不加处理，这个字符会被保留，例如,www如果定义了[A-Za-z]规则但没有定义,www规则会直接返回,www,但是匹配长度还是3。虽然可以再次截取出正确的字符，但是显然这是没有必要的。因此可以在最后为任意字符.加上规则。 假如到达读入字符串尾端 此时yylex函数返回0 用正则表达式表达字符串 \&quot;(\\.|[^&quot;])*\&quot; 注意在方括号内部引号自动转义 yymore_used_but_not_detected 需要在l文件第一部分使用%token yymore显式说明需要yymore函数。 根据manual，可使用一些语法来指定大小写不敏感的规则，但是要求flex的版本要高于2.5.3，配置时，在项目属性页选择Flex Files-&gt;FlexOptions-&gt;Case-insensitive mode 找不到入口点(main函数) 注意要将flex生成的cpp文件添加进VS项目中 bison使用说明可以参考Bison的帮助文档或者Lex and YACC primer或者YACC文档 部分元素的意义 %left、%right、%token、%nonassoc %token用来声明一个终结符号的类型（META_INTEGER、META_FLOAT等），这个函数将被放到.tab.h文件中供flex程序引用，上文提到的yylex返回的int值，实际上就是在这里定义的。 此外，%left和%right用来描述运算符的优先级和结合性。考虑二义性文法：E : E + E| E - E| E * E| E / E| i，我们当然可以写成以下的无二义性文法避免+-和*/之间的移进归约冲突，当然这样带来了比较多的归约步骤， 123E : E + T| E - T| TT : T * F| T / F| FF : i 因此我们规定每个操作符的优先级，方法是较上行的%left（%right，%nonassoc）定义比较下行的%left（%right，%nonassoc）定义优先级要低，这样解决了不同操作符的优先级问题，而且相对于引入TF终结符，我们可以少定义一些非终结符和产生式（参加下例）。 但是对于1-2+3，分析程序仍然是不知道按照(1-2)+3还是1-(2+3)归约。因此对于同优先级的符号，用%left和%right来规定结合性。 %nonassoc表示当前操作符op是没有结合性的，也就是说不可能出现x op y op z的这种情况。 yylval，%type，YYSTYLE，%union 前面说到yylex返回值是一个int，这对于语法分析是足够的，但是对于之后的语义分析是不够的。例如对于属性文法E.val-&gt;T1.val + T2.val，我们还需要语法分析时候顺便把属性也提取出来，相比扩充状态栈，yacc提供了一个YYSTYPE类型的全局变量yylval。YYSTYPE的类型是可以自定义的。 同时，对于不同的属性，bison可以直接给出parse之后的类型。例如对于浮点123.4，yacc能够解析出123.4。这是因为bison通过%union来列出yylval返回值类型，通过%type规定对于什么非终结符返回什么类型。例如， 12345678%union&#123; int intval; double floatval; char word[20];&#125;%type &lt;intval&gt; YY_INTEGER%type &lt;floatval&gt; YY_FLOAT%type &lt;identname&gt; YY_WORD 这里%union实现上就是C++中的union。union不同于struct，它的所有成员时分复用存储空间，因此一个union的大小等于所有成员大小的最大值。使用union相对使用void*避免了较多的reinterpret_cast。 %start %start用来标注开始符号，这是可选的 flex+bison使用常见问题 yylex identifier not found 注意在y文件中第一部分extern yylex声明。 字面意义常量 对于ascii码表中的字符终结符，如+，*等运算符，这些字符会在yylex以自身ascii码的形式返回（如果定义了相应规则或者.规则）。而一些需要用string来表示的终结符，例如生存空间符号::，则需要通过%token(%left，%right)定义。这也是为什么%token(%left，%right)生成的终结符对应的index从258开始的原因（避开ascii表）。当然也可以自己来定义终结符号的类型所对应的值，这有一些显而易见的好处，比如说我们可以用值的大小表示优先级关系（虽然yacc也会帮你做），可以用正负表示一个操作符或者一个操作数或者关键字。出于此，可以直接在%token Y_INT META_INTEGER给Y_INT赋值，而不是由Bison决定。特别注意不要重定义0，这是yylex和yyparse的结束记号。 定义struct的yylval yylval的类型是YYSTYPE，flex程序可以通过yylval向bison程序传递参数。 tldp文档提供了两种方案 #define YYSTYPE structXXX 可能出现错误缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int。，经查看，源码中有： 123/* for90.tab.h */// YYSTYPE is not defined, YYSTYPE_IS_DECLARED is not defined #if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLARED 解决方案是不在.y和.l文件中#define，而是在一个.y和.l文件共同#include的头文件中#define。 使用%union将struct包起来 使用这种方案不需要#define YYSTYPE，同样查看源码： 123456789/* for90.tab.h */#if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLAREDtypedef union YYSTYPE&#123;/* Line 387 of yacc.c */#line 16 "for90.y" FlexState fs;/* Line 387 of yacc.c */#line 139 "for90.tab.cpp" 在以上步骤之后要确认这个union的定义是有的。 可能会出现如下问题：错误 C2280 “YYSTYPE::YYSTYPE(void)”: 尝试引用已删除的函数。对应代码为: 12345/* The semantic value of the lookahead symbol. */YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);和 /* The semantic value stack. */YYSTYPE yyvsa[YYINITDEPTH]; 这两个函数/数组定义要求union实现构造函数和析构函数，但是这个是不行的。后来发现包含构造函数/析构函数/拷贝构造函数/赋值运算符/虚函数的类成员，在union中都是不被允许的，所以改成union的成员改成对应的指针就可以了。 左递归的避免 左递归对LALR(1)编译器是有害的（事实上对大多数分析方法左递归都不是省油的灯，例如LL1递归下降分析法直接要求消除左递归）。因此尽量编写没有左递归的产生式。例如处理else if的产生式可以写成： 12elseif_stmt : YY_ELSE YY_IF exp YY_THEN stmt | YY_ELSE YY_IF exp YY_THEN stmt elseif_stmt 开启yacc调试 12#define YYDEBUG 1#define YYERROR_VERBOSE 注意yymsgp是const char*，所以如果重新定义yyerror参数要注意。 12345678# define YYSYNTAX_ERROR yysyntax_error (&amp;yymsg_alloc, &amp;yymsg, \ yyssp, yytoken) &#123; /* 以上省略 */ yyerror (yymsgp); if (yysyntax_error_status == 2) goto yyexhaustedlab; &#125; 此外还可以在项目属性页选择Flex Files-&gt;FlexOption或对应的Bison标签页中开启DEBUG模式。 memory exhausted通常出现在语法嵌套比较深的情况。例如： 123456789101112suite : stmt | stmt suite | program : YY_PROGRAM _optional_name crlf suite YY_END YY_PROGRAM _optional_name crlfwrapper : function_decl | program | suitefortran_program : wrapper | wrapper fortran_program 需要去掉wrapper的suite分支 空规则空规则必须要在大括号内{}处理更新$$规则，不然$$是不确定的，可能是上一次的ParseNode。 控制结构的翻译可以参照这里提供的例程]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[语法分析实战]]></title>
      <url>%2F2016%2F07%2F22%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[自上而下和自下而上是两种常用的上下文无关语言分析方法。其中自上而下的方法的难点在于选择哪个产生式进行推导，自下而上的分析方法难点在于在不同的格局下选择移进或归约的矛盾。 上下文无关文法C不是上下文无关语言，因为它们都要求标识符的声明先于引用，并且允许标识符任意长。由于这一点，描述这些语言语法的文法只是用id这样的记号来代表所有的标识符，而在这些语言的编译器中，由语义分析阶段检查标识符的声明必须先于引用。同样VB和Fortran也不是上下文无关语言，因为它们会同时出现数组A(i)和函数A(i)，这同样需要语义分析程序进行处理，在语法分析阶段可以把数组的slice和dimension部分看作一种特殊形式的参数表。事实上，很多需要用更强的文法分析方法的问题可以在语义阶段较轻松地解决。推导，从开始符号推导出和输入串相匹配的句子，最右推导成为规范推导。归约，用非终结符代替一段文法符号串。通常需要解决两个问题，一是何时进行归约，二是使用哪一个产生式进行归约。称自左向右的归约过程（最左归约）为规范归约。 自上而下的分析方法自顶向下分析方法相对来说比较符合人的思维（我们交谈时一个句子听到一点中能估计到大概的意思，而不是要把一句话听完才能恍然大悟），编译器写起来也方便。自上而下的分析方法分为非确定的和确定的两种，确定指的是根据当前的输入符号，选择用来推导产生式是唯一确定的；对应的，非确定的自顶向下分析可以在关于一个非终结符有多个候选产生式的时候进行回溯，效率较低。确定的分析方法对文法要求较高，例如文法中就不能出现左递归和左公因子。 递归下降法LL(1)预测分析法LL分析（以下出现的LL分析指代LL(1)分析），是一种确定的自顶向下分析技术，确定体现在在推导过程中可以完全按照当前的输入符号（或者再向前看k-1个符号）决定哪个产生式向下推导。FIRST集：FIRST集是对于一个句型α来讲的。表示一个句型所有可能的第一个非终结符。注意如果α可推导为ε，则ε也属于FIRST集。可以得到所有文法符号的FIRST(Xi)集的生成方法： VT的FIRST集是自己 非终结符的FIRST集包含以下： ε，如果该非终结符有ε产生式，或者有全部由非终结符组成的产生式并且这些非终结符全部有ε产生式 终结符a，如果该非终结符有以a开头的产生式 所有终结符的FIRST集但不包含ε，如果该非终结符有全部由非终结符组成的产生式并且存在一个非终结符没有ε产生式 SELECT集：SELECT集是对于一个产生式A-&gt;α而言的，返回的是终结符的集合。表示在推导A且当前读取位置为a时，对于A的所有产生式A-&gt;α，如果SELECT(A-&gt;α)中含有a，那么使用产生式A-&gt;α推导。显然有且仅有一个这样的产生式，当出错时没有（注意，SELECT(A-&gt;α)集合中可能有多个元素，但是对于相同的非终结符A，同一个终结符a只会在它的一个SELECT集中，即通过键值对&lt;A, a&gt;可以唯一确定一个产生式）。容易发现SELECT(A-&gt;α)有两部分组成，一部分是α不推导为ε时候，是FIRST(α)，一部分是α推导为ε时候，是FOLLOW(α)。 FOLLOW集：FOLLOW集是对于一个非终结符A来讲的。表示所有可能在A后面的非终结符。在计算时，{ # }和所有A-&gt;αBβ产生始终的FIRST(β)的非空元素都属于FOLLOW(B)。当然β可能推导为空，这样的情况下也将FOLLOW(A)加入FOLLOW(B)中。然后反复直到各个FOLLOW集合不再增大。 将非确定的文法转换成确定的LL(1)文法提取左公因子左公因子的存在会导致SELECT集相交，这是显然的。对于显式的左公因子，直接提出来即可，如 A -&gt; αβ|αγ 可以变为 A -&gt; αA&apos; A&apos;-&gt; β|γ 对于隐式的左公因子（即左边以非终结符开头的情况），可以使用关于该非终结符的所有右部以终结符开头的产生式展开，例如 A -&gt; ad A -&gt; Bc B -&gt; aA B -&gt; bB 展开得到 A -&gt; ad A -&gt; aAc // B =&gt; aA A -&gt; bBc // B =&gt; bB B -&gt; aA B -&gt; bB 消除左递归考虑下面的文法 A -&gt; Ab A -&gt; a 可以发现对于非终结符A，并不能确定用来推导的产生式，于是只能采用非确定的递归下降法，寻找最左非终结符，于是会陷入展开A的死循环A =&gt; Ab =&gt; Abb =&gt; Abbb通过改写文法消除左递归后，这就是一个确定的文法了 A -&gt; aB B -&gt; bB | ε 还要注意一点，有些人会将左递归和尾调用等同起来，但这是不同的两个概念 左递归是针对文法而言的。不消除左递归，不能使用确定的自上向下分析 尾调用是对于一个函数调用而言的。当一个函数的最后一个工作是调用自己的时候，这样的调用称为尾递归，例如计算阶乘的某些实现。当这个函数计算仅占用常量的栈空间的时候，特别是对于LISP这样的函数式语言，可以进行尾递归优化(Tail Call Optimization, TCO)，即可以不在调用栈上面添加一个新的栈帧，而是更新它，如同迭代一般。通过尾递归优化，可以将O(n)的栈帧使用变为O(1)，减少部分递归程序的开销 自下而上的分析方法不同于自上而下的分析，自下而上的分析方法总是等到句柄（即最左直接短语）出现后进行归约。分析器在读取输入串的每一个符号时要选择对这个符号是移进还是归约、按那个产生式规约（LR0，SLR1，LR1，LALR1文法的差别体现于此）。但无论如何先要找到句柄，因此引入活前缀的概念。定义活前缀，S&#39;=&gt;αAw=&gt;αβw。因为w是终结符串（说明A是最右非终结符），所以=&gt;指的是规范（最右）推导。如果γ是αβ的前缀，那么γ是S的一个活前缀。可以看出，β是句型αβw相对于非终结符A的短语。γ是规范句型（也就是右句型，最右推导得到的句型）的前缀，而一旦栈中出现αβ，也就是形成了A的句柄，那么就可以按照A-&gt;β归约，因此，只要输入串的已扫描部分可以归约成一个活前缀，那就意味着已经扫描的部分没有错误。LR分析栈中的文法符号总是构成活前缀。LR分析器不需要扫描整个分析栈（状态栈和符号栈）就可以知道句柄是否出现在栈顶（而教科书中显示给出了栈是为了方便理解，在编译器实际处理过程中并不需要访问非栈顶元素），因为栈顶的状态符号包含了确定句柄所需要的一切信息。因此LR分析表的转移函数本质上等同于一个识别整个文法的活前缀和可归前缀的有限自动机。因此最直接的生成分析表的方法是构造一个NFA，其中所有产生式的每个项目都对应于NFA的一个状态，而规定拓展文法的开始符号的唯一产生式所对应的项目S&#39;-&gt;·E为初始状态。然后可以使用子集法把这个NFA确定化为一个DFA。 LR(0)分析表的一般构造方法也可以不通过确定化NFA或正则文法构造分析表。首先定义项目集规范族。定义项目集I是一组项目的集合，对应着DFA中的一个状态。定义构成识别一个文法活前缀的DFA项目集（状态）的全体称为这个文法的项目集规范族。项目集规范族包含一组项目集。闭包CLOSURE是针对一个项目集I而言的。闭包的求法： I属于闭包 对于闭包中的所有项目，如果圆点右边是非终结符，将该非终结符的所有产生式加入闭包。 如果圆点右边是终结符，那这是一个移进项目，不属于当前状态对应的项目集，不需要加入闭包。 如果圆点右边是什么都没有，那这是一个归约项目，不需要加入闭包。定义GO(I, X)=CLOSURE(J)，其中I是包含某一项目集的状态，X为终结符或非终结符，J是I中任何型如A-&gt;αX·β的项目。即，如果状态I能够识别活前缀γ，那么状态J能识别活前缀γX。注意GO和GOTO表的意义是不一样的，GOTO(S, X)表示栈顶状态在S时读入文法符号（终结符或非终结符）为X的时候转换到的状态，而转换函数GO用来求出移动圆点之后的新的项目集。对于LR(0)，分析表（GOTO和ACTION）可以按以下方式构造： 终结符移进：如果项目A-&gt;α·aβ属于项目集Ik，并且GOTO(I&lt;sub&gt;k&lt;/sub&gt;, a)=I&lt;sub&gt;k&lt;/sub&gt;，当a未终结符时置ACTION(k, a)为S。 终结符归约：如果项目A-&gt;α·属于项目集Ik，则对于所有的终结符a（下面的SLR在这里改进，向前看a从而决定是否移进或如何归约）和#置ACTION(k, a)为rj，j是产生式A-&gt;α的符号。 非终结符移进：如果GO(Ik, A)=Ij，则GOTO(k, A)=j。 接收状态：如果项目S&#39;-&gt;S·属于项目集Ik，则置ACTION(k, #)为acc，也就是接受。 核心项目：所有圆点不在产生式右部左端的项目，初始项目除外。非核心项目相反。每个所需要的项目集都可以由取核心项目集的闭包形成。求项目集规范族的过程为： 对初态求闭包，得到一个完整的项目集（通过对核心项目求闭包始终可以得到所有的非核心项目） 对于得到的项目集中的每个项目，读入一个文法符号，向右移动圆点。读入不同的文法符号会通向不同的新状态/项目集（当然原项目集I中的两个项目在读取同一个文法符号X之后必然属于同一个状态/项目集，即使它们对应的产生式左部不相同，这是由于GO(I, X)是唯一确定的）。对于这些新状态，再求闭包，由此循环。 如果存在规范推导S =&gt; δAw =&gt; δα·βw那么项目[A-&gt;α·β, a]对活前缀δα是有效的。 SLR(1)分析对冲突的解决思想LR(0)文法相对于LL的预测分析法，将归约的时刻推迟到了读完句柄之后。这减少了冲突，但是因为在能归约的地方总是归约，所以仍存在冲突。考虑变量声明的问题吗，以C语言为例通常为t &lt;varname&gt; [,&lt;varname&gt;]，这里省略了赋初值，同时类型标识符作为一个终结符t出现，在上文中解释过这是因为受到上下文无关文法的限制。得到的文法为S&#39;-&gt;S S-&gt;tD D-&gt;D,i, D-&gt;i，构造文法的项目集族，容易发现会产生移进归约冲突：S-&gt;tD· D-&gt;D,·i,，也就是说当遇到int i,j这样的情况，编译器现在读到j，已经形成了S-&gt;tD的句柄，可以归约了，但是这样的归约是错误的，因为后面的,j就会被丢掉了。显然解决的办法就是再往前看一个字符，如果是,，就继续移进，如果不是就归约。当然也可以引进分号，修改文法为S-&gt;tD;避免冲突。所以得到以下方案：设I={X-&gt;α·bβ A-&gt;γ· B-&gt;δ·}，则X和A、X和B有移进归约冲突，A和B有规约规约冲突。所以向前读一个输入符号a， 避免移进归约冲突：若a=b则按照产生式X移进 避免规约规约冲突：如果a=FOLLOW(A)则按A归约，如果a=FOLLOW(B)则按B归约。显然FOLLOW(A)和FOLLOW(B)必须不相交（当然不能和所有的移进终结符相交）。 可以发现其实这和LL(1)的预测分析法是类似的思路。只不过LL(1)向前读的是当前非终结符的第一个非终结符，但是SLR(1)读的是“下一个非终结符”的第一个非终结符。SLR(1)算法的分析表（ACTION和GOTO）的构造和LR(0)算法是相似的，不同之处在于读入终结符决定归约时，只对属于FOLLOW(A)的终结符添加ACTION表中记录。 LR(1)分析SLR(1)不能完全避免移进归约冲突。考虑以下的情况： S - &gt;α·aβ A -&gt; α· a∈FOLLOW(A) 显然按照S产生式面临输入符号a时应当移进，但是按照A产生式应当归约。这种情况的产生是因为a∈FOLLOW(A)说明存在有一种符号串Aa，但不是对于所有的符号串A后面都有a的。因为通常运气不会好到所有FOLLOW集都不会出现两个及以上数目的非终结符，于是我们惊讶前面的SLR(1)算法居然也能跑！其实并不是这样，SLR(1)要求表示移进的终结符不在表示归约的终结符集（也就是FOLLOW集）里面，对于上述文法，可以求得a∈FOLLOW(S)，但是根据S-&gt;α·aβ可以看到FOLLOW(S)和{ a }是有交集的，所以SLR(1)在前一步就以移进归约冲突报错了。还可以考虑以下C赋值语句文法的实际意义进一步加深理解： 赋值表达式 S -&gt; V=E|E 左值 V -&gt; *E|id 右值 E -&gt; V 按照SLR分析算法，现在考虑I2项目集S-&gt;V·=E E-&gt;V·，可以计算出=∈FOLLOW(E)，所以句型V=E既可以按照E-&gt;V归约，也可以按照S-&gt;V=E移进，冲突发生了。但是仔细琢磨，其实文法中的信息没有被完全表达出来。一个左值V完全可以出现在等号的右边，但是一个右值是不能出现在等号的左边的，如果按照E-&gt;V归约，那必定会推出V=V形成错误。虽然SLR(1)在前一步就以移进归约冲突报错了。所以解决的方案就非常显然了，既然FOLLOW集太过笼统，那就对每个项目单独给出后继符号，即搜索符。首先给出搜索符的定义：对于项目集A-&gt;α·Bβ B-&gt;·γ，如果使用生成式B-&gt;γ归约，则FIRST(β)即为搜索符。搜索符对β非空的项目[A-&gt;α·β, a]是不起作用的，但对形式为[A-&gt;α·, a]的项目，它表示只有在下一个输入符号是 a时，才能要求按A-&gt;α·归约。因此可以看做是FOLLOW集的对每个项目的特化，LR(1)文法的1同时也意味着搜索符是长度是1的终结符。如果存在规范推导S =&gt; δAw =&gt; δα·βw其中γ=δα且a是w的第一个符号或者w是ε、a是$，那么项目[A-&gt;α·β, a]对活前缀γ是有效的。LR(1)和SLR(1)的流程大致是相同的，首先也要计算CLOSURE函数。因为LR(1)项目集多了搜索符，因此CLOSURE函数需要一些修改。假设项目A-&gt;α·Bβ, a属于CLOSURE(I)，那么对于产生式B-&gt;γ，当β∈FIRST(βa)时，B-&gt;·γ, b也在CLOSURE中。LR(1)算法的分析表（ACTION和GOTO）的构造和LR(0)、SLR(1)算法是相似的，不同之处在于读入终结符决定归约时，只对属于搜索符（是一个终结符）添加ACTION表中记录。 LALR(1)对LR(1)的简化如果两个项目集除了搜索符其他都一样，那么这两个项目集为同心集。合并同心集后不会产生移进归约冲突，但可能仍会产生规约规约冲突。 冲突的解决思想总结我们希望我们的文法分析过程是确定性的。这也就是说，对于LL分析，我们希望当推导时碰到某个非终结符的产生式有多个候选的时候，我们能够唯一确定一个候选进行推导；对于LR分析，我们希望能够唯一确定任何一时刻下的分析器的动作应该是移进还是归约（避免移进归约冲突，例如C语言的悬空else情况if(..)if(..)else中，在else位置是移进外层的if，还是归约内层的if，当然这个二义文法已经不算是LR文法了）、按照哪个产生式归约（避免规约规约冲突，例如前面所说的VB6语言A(i)可能是一个数组元素，也可能是一个函数调用，特别地，(1+2)和func_name(1+2)也可能导致规约规约冲突）。 因此可以发现事实上LR所能描述的文法是LL(1)预测分析法的真超集。回顾LL(1)预测分析法的流程，LL(1)预测分析法由一个栈S和一个预测分析表M组成。M[A,a]表示推导A时当遇到输入符a时，应当选择的A的产生式（这是唯一确定的）。也就是说，对于任意的产生式A-&gt;α，如果a在SELECT(A-&gt;α)集合中，那就必须要选择产生式A-&gt;α，如果对于A的所有产生式，它们的SELECT集都不出现a，那就报错。这也就意味着选择A的哪一个产生式完全取决于a。假设应用产生式A-&gt;lβ如下推导S=&gt;αAbw=&gt;rlβbw（其中α为符号串，A为最右非终结符，w为终结符串），LL(1)预测分析法需要在看到l时就作出决定选择产生式A-&gt;lβ，但是LR分析法可以在看到b之后再决定是否把lβ规约为A，因此LR实际上获得了更多的信息。同时LL(1)文法还是不能够出现左公因子和左递归的：对于前者可以发现同一个非终结符的所有SELECT集合是存在交集的；对于第二种情况，直接左递归A-&gt;Aβ或者间接左递归可以推出它们的SELECT集也是相交的。有的时候，虽然文法是二义性的，但是语言却可以不是二义性的，这可以通过语义分析解决。 通过重写文法解决二义性stmt -&gt; if expr then stmt else stmt | if expr then stmt | other 可以提取公因子，重写为： stmt -&gt; if expr then stmt optional_else | other optional_else -&gt; else stmt | other 一般来说，对于文法 A -&gt; αη B -&gt; βη 可以改写为 A -&gt; αC B -&gt; βC C -&gt; η 但是这样的坏处是会引入终结符C，并且这个C可能没有明确的语义作用。 通过设置终结符优先级解决二义性考虑通常的表达式文法， E-&gt;E + E| E * E | (E)| id 对于1 + 2 * 3，能产生两种语法树，产生移进归约冲突，原因在于面临+的时候可以按照E-&gt;E + E归约，也可以按照E-&gt;E * E移进，于是规定*的优先级高于+，所以选择移进。对于1 + 2 + 3，同样能产生移进归约冲突，因此规定+是左结合的，因此对于项目id + id · + id，应当归约，而不是移进。此外，这个文法同样可以通过重写文法来消除二义性，例如E-&gt;E+T|T T-&gt;T*F|F F-&gt;(E)|id，这样的文法产生式的右边会出现单非终结符的产生式，增加了归约的次数。 通过设置产生式优先级解决二义性考虑排版文法： E -&gt; E ^ E _ E E -&gt; E ^ E E -&gt; E _ E E -&gt; {E} E -&gt; c 其中^表示上标，_表示下标。从定义形式语言的角度来讲，第一个产生式是多余规则，因为用2和3产生式能够得到1产生式可推导出的句子。但是从语义的角度来说它作为一个优先归约的特殊规则存在。考虑会产生的以下三个排版：ai2 a2i ai2它们的效果（语义）是不一样的，因此单独将第一个产生式列出来，优先级最高，当满足第一个产生式时，不使用后两个产生式进行归约。同样的方法可以用在处理A(args)和(exp)的冲突上面。 语义分析上的两种分析方法语法树语法树（推导树）的特点是非叶子节点都是非终结符，叶子节点都是终结符。因此从左到右遍历（也就是DFS）语法树即可生成代码。特别地，单趟编译器（one-pass compiler）不先建立语法树后编译。这样的编译器由语法分析带动整个编译流程，在语法分析的同时计算属性值，这样的做法称为语法指导翻译。TCC(Tiny C Compiler)就是这样的一个编译器。属性文法对遵循语法制导语义(syntax-directed semantic)原理的语言最有用，它表明程序的语义内容与它的语法密切相关。 综合属性和继承属性考虑一棵语法树，综合属性总是自下而上传递的，例如2.4+3*4，在语法树的根节点+，得到了结果14.4，注意到类型从int上升到double体现了自下而上的过程。继承属性是在语法树水平或者从上往下传递的，例如C语言中的变量初始化语句int i = 0, j = 0;，容易得到属性文法： T -&gt; int| real T.type = int| real L -&gt; L1, id| id L1.in = L.in; do_symbol_table; D -&gt; TL L.in = T.type 可以发现，属性先从T横向向右传递给L，然后由L向下传给L1。在产生式上来看，综合属性属于产生式的左部非终结符，从产生式右部的文法符号的属性得到（自下而上），继承属性属于产生式右部的文法符号，从产生式左部（自上而下）或者产生式右部该文法符号之前的文法符号（横向）的属性得到。 L属性文法的自顶向下和自下而上分析自顶而下的L属性文法会导致翻译模式，也就是需要在产生式的右部文法符号中间嵌入语义计算动作（yacc中使用花括号{}括起来，里面可以写C++的代码，详情可以参考我的另一篇文章：flex和bison使用）。考虑常见的if..elseif..else..endif文法。 if_stmt : YY_IF exp YY_THEN stmt endif_stmt | YY_IF exp YY_THEN stmt else_stmt | YY_IF exp YY_THEN stmt elseif_stmt elseif_stmt : YY_ELSE YY_IF exp YY_THEN stmt | YY_ELSE YY_IF exp YY_THEN stmt elseif_stmt | YY_ELSE YY_IF exp YY_THEN stmt endif_stmt else_stmt : YY_ELSE stmt endif_stmt endif_stmt : YY_END YY_IF]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[线段树和树状数组]]></title>
      <url>%2F2016%2F07%2F13%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[理解线段树和树状数组 树状数组考虑求和A[n]=a[1..n]。首先有O(n)的朴素方法，树状数组则是O(logn)的方法。理解树状数组，可以考虑对于任何一个十进制数，可以表示成按权展开的多项式，假设以2为底，则自然数x可以表示成： x = a020 + a121 + … + an2n， 其中ai可以取0或1。这样计算的复杂度为O(logn)。类似地，计算上面的和A[n]，可以把n做上述的展开。例如计算A[13]，可以得到 十进制 二进制 区域和 13 1101B a[13] 12 1100B a[9..12] 8 1000B a[1..8] 下面来计算这些区域和，定义T[i]为区间a[lowbit(i)+1 .. i]共lowbit(i) = 2k个元素的和（其中k表示i二进制表示最后的0的个数，因此i最多能被2k整除）。 线段树 线段树的大小MAXN应当至少为4N假设对[1..N]建立线段树，其中2^n &lt;= N &lt;= 2^(n+1)。容易得到树的底层至少需要2^(n+1)个节点，因此整个树需要2^(n+2)个节点，也就是必须满足MAXN &gt;= 2^(n+2) 。把n用N代替，得到4N &gt;= 2^(n+2)，显然对于任意MAXN &gt;= 4N，有MAXN &gt;= 2^(n+2)。 线段树查询 为什么需要fr，to，l，r四个变量？ 线段树的查询开销在O(lgn)。假设我们要求[fr..to]之间的值，我们实际上是找寻长度为2^i的若干子树，它们能够 开闭区间的问题 首先要注意优先级，&lt;&lt;的优先级低于+，所以应当写成(root &lt;&lt; 1) + 1这样。 Modify操作只需要更新一侧]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PAT解题报告]]></title>
      <url>%2F2016%2F07%2F06%2FPAT%2F</url>
      <content type="text"><![CDATA[浙江大学PAT(Programming Ability Test) A-level、top-level以及CCCC练习题的部分解题报告。源码在 https://github.com/CalvinNeo/PAT [YN\d]\t(\d+-)+\t([\w ]+)(\d+).* 1001 A+B Format注意判断-999,999的情况 1002 A+B for Polynomials1003 Emergency1004 Counting Leaves1005 Spell It Right比较简单，注意POSIX没有itoa，得用sprintfaccumulate第三个size_t参数最好直接设为0，在函数外加上初值。 1006 Sign In and Sign Out1007 Maximum Subsequence Sum思路:1234567891011121314151617if(maxsumto[i-1]+n[i] &lt; n[i])&#123; // re-count maxsumto here maxsumto[i] = n[i]; start[i] = i; if (maxv &lt; maxsumto[i]) &#123; maxv = maxsumto[i]; maxid = start[i]; &#125;&#125;else&#123; maxsumto[i] += n[i]; start[i] = start[i - 1]; if (maxv &lt; maxsumto[i]) &#123; maxv = maxsumto[i]; maxid = start[i]; &#125;&#125; 有一个bug，为了方便计算，输入数据从n[1..k]，定义n[0] = start[0] = 0; 考虑1 -1 1 -1 1 -1 1 -1 1 -1这样的序列，得到结果为1 0 1，但是实际的结果应当是1 1 1。因此start[0] = 1。 HHU1 1003注意LL应当用printf(“%lld”)或者printf(“%I64d”)输出但是double应当用printf(“%f”)输出此外，要注意输入3 1 1 4的输出是4而不是1。 HHU2 1001二叉查找树的中序遍历非递归实现使用一个栈，栈中的节点都已经遍历过左子树。比较容易的做法是再开一个vis数组用来记录这N个节点是否全部被遍历过。 HHU2 1002(POJ2823)线段树的大小MAXN应当至少为4N HHU4(HDU5524) N节点的完全二叉树深度为⌊log(N)⌋+1，上⌊log(N)⌋层一定是满二叉树。对于满二叉树，第i层有2i-1个节点，前i层有2i-1个节点。 完全二叉树左右子树中至少有一个满二叉树 二叉树始终有叶子。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSCPC总结]]></title>
      <url>%2F2016%2F05%2F09%2FJSCPC2016%2F</url>
      <content type="text"><![CDATA[五月八日在南京大学参加了第一届江苏省程序设计大赛。这次破天荒拿了7A。 首先是热身赛，第一条是最基本的dp，第二条是一个pq，第三条是带两个cost的dijkstra。进入正赛，一般这种比赛都是AJ水题。我先切的A，A是摩尔斯电码的翻译，是一条手速题，我看完的时候学弟已经看完B题了。B题是给出二叉树后序遍历的第k项。学弟用了二分，不过讲题的时候说因为数据故意改弱了，所以可以直接建树暴力做。B题WA了下，等到做完我断断续续把A题敲完了，1A过。后来发现I是个水题，就是dijkstra，另外建一个map把站点映射成index就行了，正好可以用刚才热身赛的dijkstra，我写了个框架给张清恒填dijkstra，不过这道本以为1A的题目居然卡了很久，最后还是学弟调出来的。中间看了J题，之前学弟第一个切了J，觉得J没见过难，我一看是个人肉pattern recognition：给一段话，要你分析出是English还是Spanish还是Chinese Pingyin。这个主要思路一个是特征词，比如西班牙语特有el，y，e，o，por这种词，另外就是长度判别，中文一定是长度小于6的，因为句子都是选自维基百科等的实际文献，而且长度都大于100个词，所以不要担心会产生误判。不过在写代码的时候WA了两次，有个坑，std::string的find会默认对pattern做trim，而trim之后，“y”也会同样匹配“sky”这样的英文单词了，所以得手写一个find，这里直接对find之后的index首尾直接验证有没有空格。J是倒数第二个A的，之前学弟有A了C和F。这时候张清恒在推G题，G题是个类似博弈的题目，但实际上是推一个公式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[winsock/boost::asio笔记]]></title>
      <url>%2F2016%2F04%2F15%2Fwinsock%2F</url>
      <content type="text"><![CDATA[WinSock/boost::asio 编程遇到的一些问题 未归类的配置问题 fatal error C1189: #error: WinSock.h has already been included这个是windows SDK + boost的一个历史问题，解决方案是在最前面#include &lt;WinSock2.h&gt; error LNK2019: 无法解析的外部符号 “void __cdecl func_name(void)” (?func_name@@YAXXZ)，该符号在函数 _wmain 中被引用这种错误一般是因为在头文件里面声明了某个函数，但是却没有实现它。但是仔细检查发现并不是这个问题。使用#pragma messagelog一下发现也不是头文件包含上面出现了问题。后来发现这个函数所声明的h文件曾经被rename过，于是重新添加该文件到工程中，问题就被解决了。事实上很多时候经常出现类似某个符号无法找到或者重复声明的错误，clean build都没有用，这时候常常可以重新添加代码文件即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[numpy的套路]]></title>
      <url>%2F2016%2F03%2F06%2Fnumpy%2F</url>
      <content type="text"><![CDATA[本文主要包括numpy，matplotlib以及python在用法上的一些套路和坑。 ndarray复制问题np.array(arr)并不能复制arr（如果arr是ndarray的话），必须要用np.copy(arr)来复制1234arr = np.array([1,2,3,4,5])arr2 = np.array(arr)arr[2] = 999print arr 以上代码输出：[ 1 2 999 4 5] ndarray去重以下代码可以去除重复的行1234a = rest_points.copy()b = np.ascontiguousarray(a).view(np.dtype((np.void, a.dtype.itemsize * a.shape[1])))_, idx = np.unique(b, return_index=True)rest_points = a[idx] 其中ascontiguosarray用法如下：12345ref: numpy\core\numeric.pydef asarray(a): return array(a, dtype, copy=False, order=order)def ascontiguousarray(a): return array(a, dtype, copy=False, order='C', ndmin=1) 可见ascontiguousarray默认以C模式（而不是Fortran）模式输出数组，ndmin=1是为了保证C模式不出错（数组至少有一维）。np.ndarray.view表示用不同的数据类型type看这个数组np.dtype是个比较奇特的函数，我还没有搞透彻，这里的意思是把那一行的数组转成二进制来表示，这样就成了一个对应着原来数组行数的一维数组，其中数组每一行的那个数是原数组对应行所有列的二进制表示。np.unique就是找出筛出数组中的唯一项了。 最小二乘法使用from scipy.optimize import leastsq可以做最小二乘法，但是有一点要非常注意：一般我们拟合时，平面方程一般选取1z = -(a*x + b*y + d) 这样的形式。这样去表示一个数组，是可以满足大多数的需要的，但是当我们考虑拟合平面Ax + By + D = 0时，由于固定了C = 1，所以会导致A, B参数数量级过大，而被误认为产生了过拟合现象。 any()和all()用来返回在指定轴上是否存在/对于任意的点都是True ndarray的运算符/内置函数的适配以下函数可以直接适用ndarray： len 一般返回ndarray的行数 zip 同list直接的zip]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GCC和MSVC在pow函数实现和类型转换比较]]></title>
      <url>%2F2016%2F01%2F16%2FC-GCC-VS-pow%2F</url>
      <content type="text"><![CDATA[ACM中常常遇到卡精度的问题，卡精度可能因为取整、比较相等、高精度等多种原因。这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。 问题描述江科大的nomasp同学在刷Leetcode(171:Excel Colmun Number)的时候发现了一个问题。他的代码（简化后）如下：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int solve(string s) &#123; int n = 0, len = s.length(); for(int i = 0; i &lt; len; ++ i) &#123; int c = s[i] - 'A' + 1; n += c * pow(26, len - 1 - i); cout&lt;&lt;"c = " &lt;&lt; c &lt;&lt; endl; cout&lt;&lt;"pow = " &lt;&lt; pow(26, len - 1 - i) &lt;&lt; endl; cout&lt;&lt;"n = " &lt;&lt; n &lt;&lt; endl; cout&lt;&lt;endl; &#125; return n;&#125;int main() &#123; cout&lt;&lt;solve("AAB"); return 0;&#125; 使用Mingw32 GCC/G++(4.7.2)编译(g++.exe cpp_path -o exepath -std=c++11 -g3 -static-libstdc++ -static-libgcc -g3)后，输出如下：使用VS2015编译后，输出如下：稍有常识的人都会看出，GCC的结果是错误的。 问题分析有同学认为pow函数是个浮点函数，因此应当转成int之后再相加减，但实际试验之后发现这个问题仍然存在，结果是：经过分析，如果手动实现pow函数则GCC的结果是对的。因此定位到调用pow函数这边出了问题。因此取一下测试代码分析。12345678910#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;int main() &#123; float f = pow(26, 2); int i = f; int i2 = pow(26, 2); printf("%f %d %d\n", f, i, i2); //似乎这个版本的GCC不支持%lf return 0;&#125; 在GCC下编译运行得：在VS下编译运行得：可以发现GCC在两次赋值操作的时候是没有问题的，但是在初始化操作的时候，莫名其妙减了1。谦谦同学提出pow函数返回的是double，在转成int的时候需要先转成float再转成int。在他的提示下，我把pow函数改成powf函数，发现返回值正常了。（谦谦同学一并指出在GCC520版本下源代码也能正常运行） 下面，我们分别比较对pow函数的实现以及类型转换机制。 VS对pow的实现VS中我们实际上使用的是double pow&lt;int, int&gt;(int _Left, int _Right); 这个重载版本。首先定位到头文件xtgmath.h：123456789101112//xtgmath.h_C_STD_BEGIN// #define _STD ::std::// #define _CSTD ::template&lt;class _Ty1, class _Ty2&gt; inline typename _STD enable_if&lt; _STD is_arithmetic&lt;_Ty1&gt;::value &amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value ,typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;::type pow(const _Ty1 _Left, const _Ty2 _Right) &#123; // bring mixed types to a common type typedef typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type; return (_CSTD pow(type(_Left), type(_Right))); &#125; 可以看到最后调用一个参数是_Common_float_type的pow函数，那这个函数在哪里呢，我们首先来看一下_Common_float_type这个类型。123456789101112131415161718192021//xtr1common.h typedef integral_constant&lt;bool, false&gt; false_type;// integral_constant is convenient template for integral constant types//xtgmath.h template&lt;class _Ty&gt; struct _Promote_to_float &#123; // promote integral to double typedef typename conditional&lt;is_integral&lt;_Ty&gt;::value, double, _Ty&gt;::type type; &#125;; template&lt;class _Ty1, class _Ty2&gt; struct _Common_float_type &#123; // find type for two-argument math function typedef typename _Promote_to_float&lt;_Ty1&gt;::type _Ty1f; typedef typename _Promote_to_float&lt;_Ty2&gt;::type _Ty2f; typedef typename conditional&lt;is_same&lt;_Ty1f, long double&gt;::value || is_same&lt;_Ty2f, long double&gt;::value, long double, typename conditional&lt;is_same&lt;_Ty1f, double&gt;::value || is_same&lt;_Ty2f, double&gt;::value, double, float&gt;::type&gt;::type type; &#125;; 这边说明一下这段代码：std::is_integral用来判断一个类型是否是整数std::conditional有三个参数，其作用相当于_Test? _Ty1: _Ty2，其中_Ty1和_Ty2都是类型，而std::enable_if相对std::conditional省略了假的情况。std::is_same用来判断_Ty1和_Ty2是否相同类型。这个是模板编程里面常用到的元函数。_Promote_to_float用来将integral（整数）类型扩成double类型，如果是浮点数则不变。说到扩展，也挺有意思的，例如char在被爆之后是直接变成int，还有符号扩展和0扩展啥的，这些都先略过。_Common_float_type意思就是123456if (_Ty1 is long double || _Ty2 is long double) typedef type long doubleelse if(_Ty1 is double || _Ty2 is double) typedef type doubleelse typedef type float 用来给浮点数之间运算结果选择适合的精度 下面我们开启调试，跟踪pow函数执行。在调试中，在断点_CSTD pow(type(_Left), type(_Right))处发现type(_Left)和type(_Right)都已经通过_Common_float_type变成了double，继续跟踪发现直接调用了math.h中的pow。特别地，对于c mode，pow实际直接调用了pow(double, double)。此外还注意到&lt;cmath&gt;中有一个的_Check_return_ inline double pow(_In_ double _Xx, _In_ int _Yx)函数，而这个函数实际上调用了&lt;cmath&gt;中的_Pow_int函数，该函数如下： 1234567891011121314151617template&lt;class _Ty&gt; _Check_return_ inline _Ty _Pow_int(_Ty _Xx, int _Yx) _NOEXCEPT &#123; unsigned int _Nx; if (_Yx &gt;= 0) _Nx = static_cast&lt;unsigned int&gt;(_Yx); else _Nx = static_cast&lt;unsigned int&gt;(-_Yx); for (_Ty _Zx = static_cast&lt;_Ty&gt;(1); ; _Xx *= _Xx) &#123; if ((_Nx &amp; 1) != 0) _Zx *= _Xx; if ((_Nx &gt;&gt;= 1) == 0) return (_Yx &lt; 0 ? static_cast&lt;_Ty&gt;(1) / _Zx : _Zx); &#125; &#125; 这段代码主要就是处理指数为int的情况，其使用的是类似于快速幂的方法得到的结果。不过经过测试，这段代码始终没有被调用的情况，为什么标准库不使用这个重载版本，我想附录里面的一段答案应该能够给我们启发。对于以上代码，我想最重要的就是_Common_float_type，它避免了GCC472版本的类型二次转换的错误，直接调用对应类型的重载版本。 VS对类型转换的实现为了分析_pow函数，需要先了解一下VS对于类型转换的实现方案 double -&gt; int123456789101112131415161718192021222324; int i = pow(26, 2);00E7277E push 2 00E72780 push 1Ah 00E72782 call pow&lt;int,int&gt; (0E71064h) 00E72787 add esp,8 00E7278A call __ftol2_sse (0E71195h) 00E7278F mov dword ptr [i],eax ; int i = pow(26.0, 2.0);00FE277E sub esp,8 00FE2781 movsd xmm0,mmword ptr ds:[0FEAB98h] 00FE2789 movsd mmword ptr [esp],xmm0 00FE278E sub esp,8 00FE2791 movsd xmm0,mmword ptr ds:[0FEABD0h] 00FE2799 movsd mmword ptr [esp],xmm0 00FE279E call _pow (0FE11FEh) 00FE27A3 add esp,10h 00FE27A6 call __ftol2_sse (0FE1195h) 00FE27AB mov dword ptr [i],eax ; double s = 26.0;00D8277E movsd xmm0,mmword ptr ds:[0D8AB98h] 00D82786 movsd mmword ptr [s],xmm0 ; int i = s;00D8278B cvttsd2si eax,mmword ptr [s] 00D82790 mov dword ptr [i],eax 这里我们发现如果pow参数都为int则是调用pow，而这个pow是通过xtgmath.h中的pow函数实现的：12345678910111213141516171819202122_C_STD_BEGIN;template&lt;class _Ty1,; class _Ty2&gt; inline; typename _STD enable_if&lt; _STD is_arithmetic&lt;_Ty1&gt;::value; &amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value,; typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;::type; pow(const _Ty1 _Left, const _Ty2 _Right); &#123; // bring mixed types to a common type00FE2B12 mov ecx,30h 00FE2B17 mov eax,0CCCCCCCCh 00FE2B1C rep stos dword ptr es:[edi] ; typedef typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type;; return (_CSTD pow(type(_Left), type(_Right)));00FE2B1E cvtsi2sd xmm0,dword ptr [_Right] 00FE2B23 sub esp,8 00FE2B26 movsd mmword ptr [esp],xmm0 00FE2B2B cvtsi2sd xmm0,dword ptr [_Left] 00FE2B30 sub esp,8 00FE2B33 movsd mmword ptr [esp],xmm0 00FE2B38 call _pow (0FE11FEh) 00FE2B3D add esp,10h ; &#125; cvtsi2sd来自SSE2，负责取出最低位的64位整型，并将其转换为一个浮点值，存放到xmm0浮点寄存器中。mmword负责将xmm0内的浮点移到[esp]所以pow实现也是先转换成浮点再调用_pow对于__ftol2_sse函数底层是调用cvtsi2sd函数的，相比之下由于double是有符号而且表示范围要大于int，因此需要额外加一些处理。所以实际上通过调用cvttsd2si函数进行了类型转换。 float -&gt; int1234567891011121314151617; int i = powf(26, 2);00C5277E push ecx 00C5277F movss xmm0,dword ptr ds:[0C5AB48h] 00C52787 movss dword ptr [esp],xmm0 00C5278C push ecx 00C5278D movss xmm0,dword ptr ds:[0C5AB4Ch] 00C52795 movss dword ptr [esp],xmm0 00C5279A call _powf (0C51523h) 00C5279F add esp,8 00C527A2 call __ftol2_sse (0C51195h) 00C527A7 mov dword ptr [i],eax ; float s = 26.0;00D5277E movss xmm0,dword ptr ds:[0D5AB48h] 00D52786 movss dword ptr [s],xmm0 ; int i = s;00D5278B cvttss2si eax,dword ptr [s] 00D52790 mov dword ptr [i],eax VS对_pow函数的实现下面分析_pow函数首先win7并没有装VS2015的库，编译成静态IDA导入不了PDB，都是天书。于是再在win10下面使用ollydbg来调试，然而并找不到_main，只看到_cinit函数包含的_initterm，只好靠调用关系和参数传递硬找。 过程 图片 解释 进入main函数 main函数 pow函数 pow函数 跳转使用SSE指令集计算pow pow函数返回 pow函数返回后准备调用类型转换函数 使用cvttsd2si的类型转换函数 第一行的cmp指令由于不等于0，所以使用cvttsd2si而不是fistp，注意和后面gcc使用fistp进行比较 类型转换的结果 od_win10_vs_after_main_exit 退出main函数 可以看到exit和_cexit函数 GCC对pow的实现GCC版本之间差别比较大，我们这里还以GCC 472(Mingw32)分析。并简化了函数12345678#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;int main() &#123; int i2 = pow(26, 2); printf("%d\n", i2); return 0;&#125; 跟踪pow函数，发现实际调用了/MinGW32/lib/gcc/mingw32/5.7.2/include/c++/cmath中的函数12345678template&lt;typename _Tp, typename _Up&gt; inline _GLIBCXX_CONSTEXPR typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type pow(_Tp __x, _Up __y) &#123; typedef typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type; return pow(__type(__x), __type(__y)); &#125; 的重载std::pow&lt;int, int&gt;(__x = 26, __y = 2)汇编代码如下1234567891011 0x00401d20 &lt;+0&gt;: push %ebp 0x00401d21 &lt;+1&gt;: mov %esp,%ebp 0x00401d23 &lt;+3&gt;: sub $0x18,%esp 0x00401d26 &lt;+6&gt;: fildl 0xc(%ebp) 0x00401d29 &lt;+9&gt;: fildl 0x8(%ebp) 0x00401d2c &lt;+12&gt;: fxch %st(1) 0x00401d2e &lt;+14&gt;: fstpl 0x8(%esp) 0x00401d32 &lt;+18&gt;: fstpl (%esp)=&gt; 0x00401d35 &lt;+21&gt;: call 0x401c88 &lt;pow&gt; 0x00401d3a &lt;+26&gt;: leave 0x00401d3b &lt;+27&gt;: ret 其中fildl表示往st（浮点数操作堆栈）栈顶放入一个长整数，fstpl是取出一个长整型数然后调用了crt中的pow函数的汇编代码 12345678910111213141516 0x74cd34b0 &lt;+0&gt;: cmpl $0x0,0x74cf6d84=&gt; 0x74cd34b7 &lt;+7&gt;: je 0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt; 0x74cd34bd &lt;+13&gt;: sub $0x8,%esp 0x74cd34c0 &lt;+16&gt;: stmxcsr 0x4(%esp) 0x74cd34c5 &lt;+21&gt;: mov 0x4(%esp),%eax 0x74cd34c9 &lt;+25&gt;: and $0x1f80,%eax 0x74cd34ce &lt;+30&gt;: cmp $0x1f80,%eax 0x74cd34d3 &lt;+35&gt;: jne 0x74cd34e4 &lt;pow+52&gt; 0x74cd34d5 &lt;+37&gt;: fnstcw (%esp) 0x74cd34d8 &lt;+40&gt;: mov (%esp),%ax 0x74cd34dc &lt;+44&gt;: and $0x7f,%ax 0x74cd34e0 &lt;+48&gt;: cmp $0x7f,%ax 0x74cd34e4 &lt;+52&gt;: lea 0x8(%esp),%esp 0x74cd34e8 &lt;+56&gt;: jne 0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt; 0x74cd34ea &lt;+58&gt;: jmp 0x74ce0249 &lt;msvcrt!modf+9193&gt; 0x74cd34ef &lt;+63&gt;: nop 其中stmxcsr将MXCSR存储到32位寄存器，modf将数分解为整数部分和小数部分。在0x74cd34b7 &lt;+7&gt;处程序进入msvcrt!_CrtDbgReportWV+84。然后在其中某一个modf方法中卡死。于是很奇怪为什么要用到msvcrt!_CrtDbgReportWV这个函数后来我试图用IDA来调试，不过win10 把我的安装程序杀掉了，所以我试图在win7里面用IDA调试，首先装完DevCPP之后进行调试，发现了不一样的光景。crt中pow函数的代码变成了这样！ 1234567891011121314=&gt; 0x7613608f &lt;+0&gt;: cmpl $0x0,0x761b50c0 0x76136096 &lt;+7&gt;: je 0x7613609d &lt;pow+14&gt; 0x76136098 &lt;+9&gt;: jmp 0x76140eb8 &lt;msvcrt!_CIpow+271&gt; 0x7613609d &lt;+14&gt;: lea 0xc(%esp),%edx 0x761360a1 &lt;+18&gt;: call 0x76120c6f &lt;msvcrt!_clearfp+230&gt; 0x761360a6 &lt;+23&gt;: jmp 0x76120c85 &lt;msvcrt!_clearfp+252&gt; 0x761360ab &lt;+28&gt;: movl $0x8,-0x218(%ebp) 0x761360b5 &lt;+38&gt;: jmp 0x7611cf67 &lt;wtoi+1860&gt; 0x761360ba &lt;+43&gt;: cmp %edi,%esi 0x761360bc &lt;+45&gt;: jne 0x7611c269 &lt;wcsncpy_s+30&gt; 0x761360c2 &lt;+51&gt;: jmp 0x7615dbb3 &lt;msvcrt!_ftol2_sse_excpt+114168&gt; 0x761360c7 &lt;+56&gt;: xor %eax,%eax 0x761360c9 &lt;+58&gt;: mov %ax,(%esi) 0x761360cc &lt;+61&gt;: jmp 0x7611c2b8 &lt;wcsncpy_s+109&gt; 反汇编居然不一样了！那到底哪个结果是对的呢？用IDA调试发现GCC编译结果连main函数都不知道在哪里，到处都是sub_xxxx的无名函数，于是使用OD进行调试，至少能看清楚先后调用关系 下面是调试过程 过程 图片 解释 进入main函数 前面要先经过两个jmp 进入pow函数 进入CRT中的pow函数的跳转 这里是一个jmp跳转 进入CRT中真正的pow函数 可以和WIN10和WIN7下的DEVCPP的反汇编进行对比 CRT中pow函数返回 注意右边寄存器表中的ST0的值是正确的26**2==676.00 printf前的结果 注意到eax实际上存放着printf的参数int i2，但是变成了整数0x02A3==675而不是676 所以应该是在浮点数变成整数这块出了问题先解释几个汇编指令 汇编 解释 fstcw 存储FPU控制字到一个内存区域 fldcw 逆运算 fistp 存储ST(0)到整数并弹出寄存器堆栈 下面来看main函数中是如何将FPU中的运算结果拿到eax中并提供给printf输出的 过程 图片 解释 从pow函数跳出 发现此时运算结果还在ST(0)中，并且fstcw指令从[esp+1e]处存取浮点控制字，fisttp指令将ST(0)存放到[esp+1c]==0x0028ff1c处 运行完fistp检查内存块0x0028ff1c 发现此时结果变为2a3==675，于是应该是fistp指令出现了问题 总结VS2015和GCC472(MinGW)使用了不同的汇编指令进行类型转换，导致出现问题。GCC使用了x87 FPU指令而VS2015使用了SSE指令集。如果改成这样的方式123456789#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;const double eps = 1e-6; int main() &#123; int i2 = pow(26, 2) + eps; printf("%d\n", i2); //似乎这个版本的GCC不支持%lf return 0;&#125; 输出结果在GCC472版本上也是正确的了 Postscript本文参考了在 cplusplus.com 上guestgulkan给出的这样的解答： This is actually quite interesting and works differently on Microsoft Visual Studio 2008 and Dev C++(using mingw); Microsoft Visual Studio 2008 cmath is basically a wrapper that calls math.h.In math.h if running in C mode you only get one power function pow(double, double).In C++ mode (which we are using) you get the c++ overloaded functions:long double pow(long double,int), float pow(float,int), double pow(double,int) and a few others.So calling pow(int, int) for example pow(3,2) will always fail due to ambiguity whether you include cmath or math.h DEV C++ with MINGWWith this set up, math.h just contains the the usual C functionpow(double, double) - so all the functions work because with pow(int, int) both ints get promoted to double by compiler and all is OKcmath in more than a wrapper for math.h. First it includes math.h and then undefines a whole lot of stuff that math.h defined, and substitutes the c++ versions.This includes the pow function declaration.As the c++ overloaded functions (same as any other c++ compiler), you will get the ambiguity problem - when using pow(int, int).P.S The ambiguity occurs with pow(int, int) because integers can be promoted to floats or doubles, which means that pow(int, int) can fit any of the 6 or so overloaded c++ pow function - so the compiler gets confused. 对于标准库对pow函数的处理，stackoverflow上的enigmaticPhysicist给出了这样的回答： A specialisation of pow(x, n) to where n is a natural number is often useful for time performance. But the standard library’s generic pow() still works pretty (surprisingly!) well for this purpose and it is absolutely critical to include as little as possible in the standard C library so it can be made as portable and as easy to implement as possible. On the other hand, that doesn’t stop it at all from being in the C++ standard library or the STL, which I’m pretty sure nobody is planning on using in some kind of embedded platform.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[brainfuck]]></title>
      <url>%2F2015%2F12%2F26%2Fbrainfuck%2F</url>
      <content type="text"><![CDATA[brainfuck是一个图灵完备的语言，仅有8个操作，晦涩难懂，但能够像图灵机一样完成任何计算。本文主要讨论一下brainfuck的一些编程技巧。 brainfuck由8个操作，输入输出流，一块初始化为0的内存，以及一个全局指针ptr（默认指向内存块的开始）构成。八个操作分别为（这里采用c描述）：12345678&gt; ptr++&lt; ptr--+ *ptr++- *ptr--, *ptr = getchar(). putchar(*ptr)[ while(*ptr)&#123;] &#125; // of while 马上就是新年了，下面这段程序可以输出HappyNewYear1++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++.+++++++++++++++..+++++++++.&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++.&lt;--.++.&gt;.----.+++++++++++++++++. brainfuck由于语法简单，所以解释器也非常好实现，这里也实现了一个：Calvin’s brainfuck interpreter。由于写bf会导致+-&lt;&gt;比较多，解释器也提供了+(48)表示连续48个加号的糖，同时也可使用%作注释，使用#stk访问变量表。程序可以开启debug模式，可以使用#dbg和#cdb代码块局部开启或关闭debug模式。同时这边也附了一个贪心算法的实现，用比较短的bf代码打印字符串。等我考完试再优化一下ლ(╹◡╹ლ)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# https://github.com/CalvinNeo/brainfuck/blob/master/print_gen.py#coding:utf8import sysdef naive_gen(ascii): code = '' for x in ascii: code += '&gt;' + '+' * ord(x) + '.' return codedef greedy_gen(ascii): current = [] code = '' ptr = -1 for x in ascii: if len(current) == 0: code += '+' * ord(x) + '.' ptr += 1 current.append(x) else: min_dist = 256 min_index = 0 for (index, y) in zip(range(len(current)), current): if abs(ord(y)-ord(x)) &lt; min_dist: min_dist, min_index = abs(ord(y)-ord(x)), index if min_dist &lt; ord('A'): if ord(current[min_index]) &gt;= ord(x): ptr_delta = '-' * ( ord(current[min_index]) - ord(x) ) else: ptr_delta = '+' * ( ord(x) - ord(current[min_index]) ) if min_index &gt;= ptr: ptr_move = '&gt;' * ( min_index - ptr ) else: ptr_move = '&lt;' * ( ptr - min_index ) code += ptr_move + ptr_delta + '.' ptr = min_index current[min_index] = x else: code += '&gt;' * (len(current) - ptr) + '+' * ord(x) + '.' current.append(x) ptr = len(current) - 1 return codeif __name__ == '__main__': ascii = raw_input() print greedy_gen(ascii) 下面介绍一下brainfuck的常用技巧。 数学运算 乘法以下代码实现了两个一位数乘法：123456789101112131415161718,-(48)&gt;,-(48) % read 2 integers[- % while $2-- &lt; % set ptr to $1 [ - % while $1-- &gt;&gt;+ % $3++ &gt;+ % $4++ &lt;&lt;&lt; % set ptr back to $1 ] &gt;&gt;&gt; % set ptr to $4 [ % copy $4 to $1 - % while $4-- &lt;&lt;&lt;+ % $1++ &gt;&gt;&gt; % set ptr back to $4 ] &lt;&lt; % move ptr to $2 and continue]&gt;+(48). % print answer in $3 内存操作 清空存储区这里需要特别强调一下，brainfuck里面没有生存空间这样的概念，也就是它的ptr是全局的单例的，在使用[]嵌套循环的时候，要特别注意这一点。12 语言结构 if语句 switch语句 嵌套循环]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[C++中for循环的一个用法]]></title>
      <url>%2F2015%2F12%2F22%2FC-for%2F</url>
      <content type="text"><![CDATA[今天发现了C/C++里面for的一个不常见到的用法，来水一篇文章。 今天看到一个技术交流群上面分享了下面这一段代码；12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; for(int i = s.size(); i--;)&#123; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 请注意这一行for(int i = s.size(); i--;){ 乍一看循环根本不能跳出，使用g++编译，发现得到了正确的反向字符串。我们使用char[]代替string，并跟踪i，发现i实现了递减，并且当(i--)等于0时，循环跳出。12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char s[] = &#123;'a','b','c','d','e'&#125;; for(int i = 5; i--;)&#123; cout &lt;&lt; i; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 于是得出初步结论，for(A;B;C)语句中，当C为空时，B在更新循环标记的同时起返回值作为循环结束的条件。其作用相当于下面代码中的judge_end函数。12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool judge_end(int &amp; i)&#123; return i-- &lt;= 0 ? false : true;&#125; int main()&#123; char s[] = &#123;'a','b','c','d','e'&#125;; for(int i = 5; judge_end(i);)&#123; cout &lt;&lt; i; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ACM/ICPC EC-FINAL小结]]></title>
      <url>%2F2015%2F12%2F14%2FICPC-EC-FINAL%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[EC-FINAL是2015年度最后一次ACM区域赛了，这次总共有288个队参加比赛。命题还是Google。 正式赛赛题这次出生点在强队中间，右后方就是本次冠军，唯一的9A，陈立杰的华莱士队，左边是北航的7A，正后方是浙大，右边是广大。热身赛题目是Google一次网试的笔试题。A题Dynamic Grid，直接暴力模拟。B题IP Summarization，要求是给出若干个IP以及他们的掩码，要求输出合并的Normalize之后的所有IP，Google给的思路就是建一颗二叉树。实际做的时候发现这道题要注意一点就是你要先排序，考虑子网和合并的情况。C题Virtual Rabbit，讲的是一个人只能在[W,H)和[B,G)时间段内喂兔子，兔子在X秒内不被喂食就会死去，问喂食的最少次数。正式赛还是比较有难度的。水题是ADLM。A题Boxes and Balls，据说是一个初中数学题，找最大的m，使得m(m+1)/2 &lt; N，解方程的时候用double可能会出精度问题，没清WA了一次，其实也可以用二分去做。M题November 11th，电影院里面Singles不能坐在相邻的座位，且有B个坏椅子的坐标，求最多最少可以坐多少个单身狗。这里要注意只要两个人中间隔两个就不能坐人了，一开始想成了一个。结果是模3有规律，直接硬算找规律。然后就是坑爹的D题，题目的意思是你有A块钱，不过是整的，你现在要买一个自动售货机换得零钱然后去付另外的B块钱，问你最少需要在自动售货机上面卖多少钱东西，其中A,B∈{0.01,0.02,0.05,0.1,0.2,0.5,1,2,5,10,20,50,100}。又看到样例T&lt;=78的时候笑了，这个不就是打表嘛，总共78个样例，于是我们在纸上手算了半天，但是到最后还是没有A出来，出来之后才知道，可以在自动售货机上面买若干次。至于L题，讲的是有一个无限大的乘法表，现在给定一个由数字和问号（相当于未知）矩阵，问这个矩阵有没有可能是这个大的乘法表的一部分。这道题目思路就是只要矩阵中知道两个数，那么我们就可以把整个矩阵的所有值解出来，这样我们就可以一一确定剩下来的值是否符合我们已经确定了的矩阵了。但是我们忽略了一种情况，就是如果只有一个数的话，这个矩阵不一定存在，比如1这个数，他只能出现在第一行的第一列，如果有这样的一个矩阵：123? ? ?? 1 ?? ? ? 那它肯定不是乘法表的一部分，因此我们少一步分解因数，检查每一个数字是否能够出现在这个乘法表中的过程。 感受 上海大学宝山校区好荒啊，我们住在蓝波万酒店感觉名字好屌啊，走到学校好远啊。然而宾馆只有一张大床一张小床，我和良哥阿洁哥一起睡的，纪存哥阿涛和清恒拼在一起睡得，结果他们晚上被阿涛各种挤。 晚上吃了羊蝎子火锅超级逗，一盆饭6块钱，一盘豆芽菜1块钱，阿涛点了六盘豆芽菜，然后大家最后实际上就是在吃豆芽菜 宾馆里面有电脑！于是热身赛晚上张老师让我们写一写热身赛的题目，于是我们只好装做在电脑上写，但是阿涛一直给女票盈盈买衣服，张老师来了也不停，超级逗笔。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LaTeX学习笔记]]></title>
      <url>%2F2015%2F12%2F02%2FLaTeX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[目录 Step 0. 使用TeXStudio Step 1. 使用LaTeX做Routine Work Hello, World 带格式的文本 加入数学公式的文本 特殊字符的输入 Step 2. 支持中文 Step 3. 论文编辑的常用元素 一些额外需要注意的配置 数学符号 矩阵 表格 有序列表和无序列表 代码 Step 4. 段落，段落格式和目录 分段 目录和标题 交叉引用 Step 5. 图片 Step 6. 页面设置 Step 7. 模板 Step inf. 额外说明 Step 0. 使用TeXStudioTeXStudio的界面还是比较简单容易操作的。其中配置常出现以下问题： Make sure that you have installed a (La)TeX distribution这是因为没有没有安装LaTeX发行版的缘故，TeXStudio是一个可配置的LaTeX编辑器，我们需要单独安装对应的编译器。有很多LaTeX的发行版，我们这里可以安装使用MikTeX。可前往MikTeX官网 http://miktex.org/ 上下载对应的版本。安装完后应当进入Options-&gt;Configure TeXStudio-&gt;Commands来检查MikTeX路径是否正确 没有错误，但是无法生成文档。这个可能是因为安装了其他LaTeX发行版，比如CTEX整合包的缘故，卸载该整合包，重新安装MikTeX即可。 Step 1. 使用LaTeX做Routine Work Hello, World 新建文档，并输入 1234\documentclass&#123;article&#125; % meta info of the document\begin&#123;document&#125; Hello, World\end&#123;document&#125; 生成文档，预览 带格式的文本 新建文档，并输入 123456789101112131415161718\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent % no indent at the head of this paragraph \textbf&#123;Bold&#125; \newline % use this command to start a new line \textit&#123;Italic&#125; \\ % another way to start a new line \underline&#123;Underline&#125; \begin&#123;flushleft&#125; Left \end&#123;flushleft&#125; \begin&#123;center&#125; Middle \end&#123;center&#125; \begin&#123;flushright&#125; Right \end&#123;flushright&#125;\end&#123;document&#125; 生成文档，预览 其中： \noindent 取消段首缩进 \textbf{your_text} 加粗your_text \textit{your_text} 斜体的your_text \underline{your_text} 带有下划线的your_text \newline 和 \\ 是换行指令 \begin{command} 和 \end{command} 之间是command的scope，其中flushleft, center, flushright表示靠左、居中和靠右对齐 加入数学公式的文本 数学公式和普通文本的格式是不同的，应当使用$和$，\(和\)，\begin{math}和\end{math}将数学公式包起来，如 12345678910\documentclass&#123;article&#125;\begin&#123;document&#125; $a_&#123;1&#125;+b_&#123;1&#125; = c_&#123;1&#125;$ \\ \( a^&#123;2&#125; + b^&#123;2&#125; = c^&#123;2&#125; \) \\ \begin&#123;math&#125; \frac&#123;1&#125;&#123;2&#125; + \sqrt&#123;3&#125; = 0 \end&#123;math&#125;\end&#123;document&#125; 特别地，使用\[和\]或者\begin{displaymath} 和\end{displaymath}能够另起一行显示公式，试比较 123456789101112\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent the equlation \[ 1+2+3+4 = 7 \] is not established the equlation \( 1+2+3+4 = 7 \) is true\end&#123;document&#125; 对于多个方程我们可以使用\begin{equation}和\end{equation}来标记,并且使用\label{name}来标记,使用\ref{name}来引用。 1234567891011121314\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \label&#123;eq:eps&#125; \epsilon &gt; 0 % our formula \end&#123;equation&#125; \begin&#123;equation&#125; \label&#123;eq2:eps&#125; \delta &lt; 0 \end&#123;equation&#125; From (\ref&#123;eq2:eps&#125;), we can ... \end&#123;document&#125; 使用\textrm{xxx}插入普通格式的文本 特殊字符的输入 LaTeX中有一些字符是不能“正常”输入的。 除反斜杠之外的特殊字符，#、$、%、^、&amp;、_、{、}、~，可在前面直接加反斜杠，如\#便可显示# 反斜杠（stroke）：可使用$\backslash$生成。 空格：使用\,强行插入多个空格，注意一般英文文本需要两个\,才能达到理想的单词间距。 日期：可使用\today生成。 引号：用`` 产生左双引号，用&#39;&#39;产生右双引号。用` 产生左单引号，用&#39;产生右单引号。当单引号与双引号相邻时，在两者中间插入空格\,。 取反号和波浪号：用\~{}生成取反号（位置靠上），用$\sim$生成波浪号（位置竖直居中） 角度°：角度是一个上标的圆圈，圆圈用\circ生成，于是10度角就是$10^{\circ}$ Step 2. 支持中文缺少ctex库的情况： 运行 C:\Program Files (x86)\MiKTeX 2.9\miktex\bin\mpm.exe 设置Repository，这里建议选择第一个中科大的资源站，如果不幸40X或者50X的话可以选择翻墙去比如华盛顿大学的（翻墙的话需要配置Connection Settings）镜像站。 选择安装ctex安装过程是这样的（注意进度条结束之后可能还有一个解压过程，不要点Cancel，等安装完毕，Cancel会变成Close） 按照以上方法安装 l3kernel, l3packages, ms, ulem, zhnumber, （cjk, cjkpunct）（PS 亦可通过ftp://mirrors.ustc.edu.cn/CTAN/systems/win32/miktex/tm/packages/ 直接下载lmza文件安装） 测试1234567\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; 蛤蛤蛤蛤蛤蛤\end&#123;CJK&#125;\end&#123;document&#125; Step 3. 论文编辑的常用元素 0. 一些额外需要注意的配置 需要补充安装 amsmath，listings，mptopdf几个包。这几个包的安装方法都可以参照Step2中中文支持包一样安装。 1. 数学符号 希腊字母 123\alpha α; \beta β; \gamma γ; \delta δ; \epsilon ε; \zeta ζ; \eta η; \theta θ; \iota t; \kappa κ; \lambda λ; \mu μ; \xi ξ：\nu ν; \o o; \pi π; \rho ρ; \sigma σ; \tau ?; \upsilon υ; \phi Φ; \chi Χ; \psi Ψ; \omega ω 将首字母大写可以得到大写的希腊字母 空格 在这里提过，可以用\,来生成一个小空格，此外数学公式中还可以用\quad和\qquad生成大小不等的空格。 一般来说，可以使用\来得到一个空格，这个空格比较小，用于词语词之间的分隔；用\@得到一个较大的句子之间的空格，用~得到一个不会在此处换行的空格。 此外，用来在一行中并列排放两个数学变量，用\quad也是一个不错的选择。其实对于空格，有以下的一些比例：\quad 即\hspace{1em}，一个英文字符**M**的宽度 \qquad 即\hspace{2em}，两个英文字符**M**的宽度 \; 5/18个英文字符的宽度 \: 4/18个英文字符的宽度 \, 3/18个英文字符的宽度 \! -3/18个英文字符的宽度 \hspace{长度} 产生指定宽度 \phantom{文本} 产生指定文本的宽度 插入普通文本 在这里 数学符号 对于任意的：\forall 存在：\exists 根号：\sqrt[n]表示n次方根，其中平方根可以省略[n] 括号：使用\big( \Big( bigg( Bigg( 生成不同大小的左（括号 省略号：ldots（位置靠下）和cdots（位置居中） 上标和下标 上标使用^来，下标采用_。特别地，当要将一个式子（而不是字母）作为上标，需要将这个式子整体括起来，如a^{x+y} 可以同时指定上标和下标，如a^{2}_{i} 特殊的上标，如导数符号，使用&#39;获得。例如对f求导，应当输入f&#39;而不是f^{&#39;} 修饰符 向量：\vec a，\overrightarrow{AB} 大的数学符号 如sigma，limit之类的数学符号在LaTeX中是相对容易输入的，选择对应的命令，按照上下标的输入方式输入即可。 1234567891011121314\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \label&#123;eq:eps&#125; \epsilon \textrm&#123; simple text&#125; &gt; 0 % our formula \end&#123;equation&#125; \begin&#123;equation&#125; \label&#123;eq1:eps&#125; \lim_&#123;n \to \infty&#125; \sum_&#123;k=1&#125;^n k = \infty \end&#123;equation&#125;\end&#123;document&#125; 数学公式 使用双斜杠换行 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \alpha_1 f_c b x = f_y A_s \\ M_u = f_y A_s (h_0 - \frac&#123;x&#125;&#123;2&#125;) \\ M_u = \alpha_1 f_c b x (h_0 - \frac&#123;x&#125;&#123;2&#125;) \\ \end&#123;equation&#125;\end&#123;document&#125; 方程组的情况： 2. 矩阵 12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;listings&#125; \usepackage&#123;graphicx&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \begin&#123;bmatrix&#125; -1&amp; 1&amp; 1&amp; 1&amp; -1&amp; \ldots &amp; -1 \\ -1&amp;1&amp;1&amp;-1&amp;-1&amp; \ddots &amp; -1 \\ \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \\ 1&amp; 1&amp; 1&amp;-1&amp;-1&amp; \ldots &amp; 1 \\ \end&#123;bmatrix&#125; \end&#123;equation&#125;\end&#123;document&#125; 这里要注意几点：\begin{bmatrix}标记的，不过需要在数学编辑的环境下哦。 第一，\usepackage{amsmath}这个包是必备的，如果没有是无法生成文档的。 第二，&amp;区分矩阵中每一行的元素，\\区分矩阵中的每一行。 第三，&amp;后面的空格不是必须的，但是有了这个空格，源码会显得比较明朗，也易于修改。 第四，\ldots，\ddots，\vdots分别表示横过来的，斜过来的，竖过来的省略号。 3. 表格 首先先生成一个最简单的表格 123456789101112\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|l|c|r|&#125; \hline 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\ \hline \end&#123;tabular&#125; \end&#123;document&#125; 可以看出表格和矩阵时差不多的，&amp;区分矩阵中每一行的元素，\\区分矩阵中的每一行。额外有几点的区别，补充说明如下： 我们使用\begin{tabular}和\end{tabular}来标记一个表格（注意，是tabular不是table哦）。 后面的{|l|c|r|}抽象地表示了一个表格的一行。其中|表示竖向的表格线，从而形成一行表格，当然也可以用||，这样表格线就是双层的啦。里面的l、c、r分别表示在这个格子里面中的文字是靠左，居中还是靠右对齐。特别地，当表格有很多行的时候写起来会比较麻烦，这时候可以采用重复指令*{n}{repeat}，其中*{n}{repeat}表示重复repeat n次，模板如下：*{3}{|c}| 表示一个三列的表格且都是居中。 \hline表示横向的表格线。 下面给表格加上一个标题： 12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;table&#125; \caption&#123;My first table&#125; \centering \begin&#123;tabular&#125;&#123;|l|c|r|&#125; \hline 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\ \hline \end&#123;tabular&#125; \end&#123;table&#125;\end&#123;document&#125; 可以看到，在\begin{tabular}外面又套了一层\begin{table}，这两层是不相同的，我们需要在\begin{table}里面，\begin{tabular}外面用\caption{My first table}指定标题为“My first table”，而下面的\centering指令是让表格居中。 其实我们可以发现\begin{tabular}表示一个表格实体的开始，而\begin{table}表示一个表格连同标题至脚注的开始。 在Word中常常用到“合并单元格”和拆分单元格指令，在LaTeX中可以通过\multirow和\multicolumn来实现。这里\usepackage{multirow}是必备的。 先看一个例子：现有一个4x4的表： 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline 1行1列 &amp; 1行2列 &amp; 1行3列 &amp; 1行4列 \\ 2行1列 &amp; 2行2列 &amp; 2行3列 &amp; 2行4列 \\ 3行1列 &amp; 3行2列 &amp; 3行3列 &amp; 3行4列 \\ 4行1列 &amp; 4行2列 &amp; 4行3列 &amp; 4行4列 \\ \hline \end&#123;tabular&#125;\end&#123;CJK&#125;\end&#123;document&#125; 下面我们合并第一列和第三列。 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline \multirow&#123;4&#125;&#123;2cm&#125;&#123;第1列&#125; &amp; 1行2列 &amp; \multirow&#123;4&#125;&#123;2cm&#125;&#123;第3列&#125; &amp; 1行4列 \\ &amp; 2行2列 &amp; &amp; 2行4列 \\ &amp; 3行2列 &amp; &amp; 3行4列 \\ &amp; 4行2列 &amp; &amp; 4行4列 \\ \hline \end&#123;tabular&#125;\end&#123;CJK&#125;\end&#123;document&#125; 对比代码发现，合并行单元格，我们只要在被合并的单元格的起始单元格调用\multirow命令，然后在被这个大单元格占据的其他地方使用空格代替原来的字符就行了。 这里说明一下\multirow命令的参数，第一个参数，这里是4表示向下合并多少行的单元格，第二个参数，这里是2cm一般取2cm或者*就可以，第三个参数，就是这个大单元格里面的内容了，你可以在里面嵌入其他指令，如textbf用来加粗等。 此外对于合并列，有同样的\multicolumn指令，注意这里第二个参数变成了{c|}这样，用来说明这个大单元格内文本的对齐方式。不过这里需要特别注意的一点就是，在同一行中，我们不需要给被\multicolumn吃掉的单元格占位置了。 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125; \begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline 1行1列 &amp; 1行2列 &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;1行34列&#125; \\ \cline&#123;1-4&#125; 2行1列 &amp; 2行2列 &amp; 2行3列 &amp; 2行4列 \\ 3行1列 &amp; 3行2列 &amp; 3行3列 &amp; 3行4列 \\ 4行1列 &amp; 4行2列 &amp; 4行3列 &amp; 4行4列 \\ \hline \end&#123;tabular&#125; \end&#123;CJK&#125;\end&#123;document&#125; 注意这里第10行的\cline{1-4}，试着将它去掉，我们可以发现\multicolumn部分失去了下面的表格构造线。这里\cline{1-4}表示在第1列到第4列画上表格构造线。 如果要实现合并多行多列的单元格可以嵌套使用指令\multirow，\multicolumn。 1234567891011121314% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|ccc|&#125; \hline 1 &amp; 2 &amp; 3 \\ 4 &amp; \multicolumn&#123;2&#125;&#123;c|&#125; &#123; \multirow&#123;2&#125;&#123;*&#125;&#123;&#123;?&#125;&#125; &#125; \\ 7 &amp; &amp; \\ \hline \end&#123;tabular&#125;\end&#123;document&#125; 特别地，\renewcommand用来重定义一个指令，对于\renewcommand{\multirowsetup}{\centering}来说，就是把系统中已有的\multirowsetup重新定义成了使用\centering命令，从而达到强制multirow中内容居中居中的效果。当然还有newcommand用来定义一个之前不存在的命令，如同C++里面的#define一样。 斜线表头。为了能够使用斜线表头，需要\usepackage{diagbox}，\usepackage{pict2e}，\usepackage{fp}包。 1234567891011121314151617% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;booktabs&#125;\usepackage&#123;diagbox&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|l|ccc|&#125; \hline \diagbox&#123;Time&#125;&#123;Room&#125;&#123;Day&#125; &amp; Mon &amp; Tue &amp; Wed \\ \hline Morning &amp; used &amp; used &amp; \\ Afternoon &amp; &amp; used &amp; used \\ \hline \end&#123;tabular&#125;\end&#123;document&#125; 注意第11行\diagbox{Time}{Room}{Day}表示顺时针的三个Time，Room，Day。 三线表。对于英文论文来说，表格尽量 使用三线表格式。需要 12345678910111213141516% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;booktabs&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;ccc&#125; \toprule 2&amp;9&amp;4\\ \midrule 7&amp;5&amp;3\\ 6&amp;1&amp;8\\ \bottomrule \end&#123;tabular&#125;\end&#123;document&#125; 4. 有序列表和无序列表 有序列表enumerate： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;enumerate&#125; \item C \item Python \item Haskell \end&#123;enumerate&#125;\end&#123;document&#125; 无序列表enumerate： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;itemize&#125; \item CSharp \item Javascript \item Rust \end&#123;itemize&#125;\end&#123;document&#125; 带小标题的列表description： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;description&#125; \item[C++] Leaking basin \item[PHP] Best language in the world \item[Perl] WTF \end&#123;description&#125;\end&#123;document&#125; 5. 代码 1234567891011\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;listings&#125; \begin&#123;document&#125; \noindent \begin&#123;lstlisting&#125;[language=python] #coding:utf8 import numpy as np \end&#123;lstlisting&#125;\end&#123;document&#125; 这里同样注意\usepackage{listings}包不能丢掉，其中language表示里面显示的是什么语言。 Step 4. 段落，段落格式和目录 分段 LaTeX对分段有着以下几个明确的指令 1234567\section&#123;...&#125;\subsection&#123;...&#125;\subsubsection&#123;...&#125;\paragraph&#123;...&#125;\subparagraph&#123;...&#125;\part&#123;...&#125;\chapter&#123;...&#125; 注意：chapter仅限于report和book类（点击查看详细说明） 前五个命令表示从大到小的5个五级标题，其中含paragraph的一般为段落，前面没有标号，而且需要有实际的内容，不然这个paragraph就不会被显示（试着将含有remove me的行注释掉，注意观察编译结果），编译： 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \section&#123;section&#125; \subsection&#123;subsection&#125; \subsubsection&#123;subsubsection&#125; \paragraph&#123;paragraph1&#125; there's some subparagraph \subparagraph&#123;subparagraph1&#125; \subparagraph&#123;subparagraph2&#125; \paragraph&#123;paragraph2&#125; % remove me there's no more subparagraph % remove me\end&#123;CJK&#125;\end&#123;document&#125; 此外，还有一种\section{short_title}{long_title}的写法，在中间的short_title我们指定一个简短的标题名，用来后面生成目录。 下面是part指令，类似于section，不过相比section，part是不带编号的，而且\part{}自动生成类似Part I这样的标题，不需要写成\part{Part I}，所以一般part指令都是用在比较独立的地方，比如用在chapter和section中间。 这边注意一点：请不要用section或者paragraph指令去做有序列表或者无序列表，点此查看专门的方案 1234567891011\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \section&#123;section1&#125; \part&#123;&#125; \part&#123;&#125; \part&#123;&#125; \section&#123;section2&#125; \end&#123;CJK&#125;\end&#123;document&#125; 通过之前的几个例子，我们发现section系是不带编号的，paragraph和part是带编号的。事实上section也可以不带编号，paragraph也可以带编号。事实上这个是可以调整的。 运行一下代码，将\setcounter的最后一个参数从1一直调到5，逐次编译，比较每次的不同。 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \setcounter&#123;secnumdepth&#125;&#123;5&#125; % change this from 1 to 5 %控制显示4层编号 \section&#123;A&#125; \subsection&#123;B&#125; \subsubsection&#123;C&#125; \paragraph&#123;D&#125; D \subparagraph&#123;E&#125; E\end&#123;CJK&#125;\end&#123;document&#125; 对于article文档类来说，\setcounter默认的是3，也就是默认section系的有编号，parag系的没有编号。 事实上，如果我们仅仅只是想去掉一级section的编号的话，可以使用\section*{...}在\section和实际内容之间加上一个*就可以实现了。 目录和标题 先使用\title{}，\author{}和可选的\data{}为文章设置标题。 再使用\maketitle显示标题标题。 交叉引用 Step 5. 图片Step 6. 页面设置Step 7. 模板Step inf. 额外说明 文档类 文档类一般包括以下几个 12345article 最常用的minimal 最基本的文档类，一般仅用来查错report 较长的报告和论文book 书籍slides 幻灯片 使用\documentclass{...}定义。本文中大多数都是article类型]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[django配置与使用]]></title>
      <url>%2F2015%2F10%2F21%2Fdjango%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[在配置Django的时候常常会出现一些问题，比如migrate无效，表单提交valid验证不过等问题，本文给出了一些解决方案 同步数据库的问题根据不同版本有对应以下两种方法同步数据库：1python manage.py syncdb (用于旧版本)12python manage.py makemigrationpython manage.py migrate (用于新版本)其中migrate方法一般要提前建一个空的数据库，但是数据表是自动同步的 自定义数据表一般地，django在数据库中存储的表名为model name，但是可以通过以下方式自定义表名123class MyModel(models.Model): class Meta: db_table = 'xxx' 上传文件问题 上传空文件会导致is_valid不过 不能在如view.py, model.py中正常地import 这些文件的sys.path中的当前目录是manage.py所在目录，一般比这些文件本身所在的目录高一级。所以sys.path.append中的路径应当比实际高一层。 同样因为这个原因，保存文件时路径不能以’/upload/‘开头，而应该直接以’upload/‘开头。在外部程序访问时，应当做一个路径转化。 Migrate问题 RuntimeError: Error creating new content types. Please make sure contenttypes is migrated before trying to migrate apps individually.检查Model.pyContentType 模型对应数据库中django_content_type表，主要用户维护django project中所安装的所有用户模型出现这个问题一定是模型问题，我后来发现我的原因是因为 models.XXXField 里面多了一些参数比如required什么的删掉就好，此外form也要注意之后一定要先drop database再migrate就可以了 file clean之后变成None摘自C:\Program Files (x86)\Python27\Lib\site-packages\Django-1.9-py2.7.egg\django\forms\forms.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def full_clean(self): """ Cleans all of self.data and populates self._errors and self.cleaned_data. """ self._errors = ErrorDict() if not self.is_bound: # Stop further processing. return self.cleaned_data = &#123;&#125; # If the form is permitted to be empty, and none of the form data has # changed from the initial data, short circuit any validation. if self.empty_permitted and not self.has_changed(): return self._clean_fields() self._clean_form() self._post_clean()def _clean_fields(self): for name, field in self.fields.items(): # value_from_datadict() gets the data from the data dictionaries. # Each widget type knows how to retrieve its own data, because some # widgets split data over several HTML fields. if field.disabled: value = self.initial.get(name, field.initial) else: value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name)) try: if isinstance(field, FileField): initial = self.initial.get(name, field.initial) value = field.clean(value, initial) else: value = field.clean(value) self.cleaned_data[name] = value if hasattr(self, 'clean_%s' % name): value = getattr(self, 'clean_%s' % name)() self.cleaned_data[name] = value except ValidationError as e: self.add_error(name, e)def _clean_form(self): try: cleaned_data = self.clean() except ValidationError as e: self.add_error(None, e) else: if cleaned_data is not None: self.cleaned_data = cleaned_data 看了半天源码发现，里面的name要和Form里面的name相同 python的小坑python是没有select/switch语句的，为了避免很麻烦的if-elif-else，可以采用{condition:value}[statement]近似替代select/switch语句，这个小坑在于，所有的condition:value都会被求值，所以一方面会降低性能，一方面要考虑副作用的问题了。 字符集的小坑request.GET.get得到的参数是unicode，必须先转换类型才能使用哦 HttpResponse的小坑HttpResponse不能正确处理array object的情况，例如下面的代码是不能得到正确的结果的哦：123456789return HttpResponse([ &#123;'name':'TP', 'value':assessmodel.TP&#125; ,&#123;'name':'TN', 'value':assessmodel.TN&#125; ,&#123;'name':'FP', 'value':assessmodel.FP&#125; ,&#123;'name':'FN', 'value':assessmodel.FN&#125; ,&#123;'name':'P', 'value':assessmodel.P&#125; ,&#123;'name':'R', 'value':assessmodel.R&#125; ,&#123;'name':'F1', 'value':assessmodel.F1&#125; ]) 运行发现前端得到的是这样的数据：解决方案是当遇到对象数组的时候使用json.dump()函数将它转化为json，然后返回application/json格式的HttpResponse，如return HttpResponse(json_stuff, content_type =&quot;application/json&quot;)，当然千万注意前端ajax拿到data之后就不要eval了。 转义Django和Angular等框架合用需要注意转义：openblock { %closeblock % }templatetag openvariable { {templatetag closevariable } }openbrace {closebrace }opencomment { #closecomment # } Angular的问题这边顺便说一下Angular和jQuery混合使用常犯的一个错误：12345678910$.ajax(&#123; url : '' ,data : &#123; &#125; ,async : true ,success : function (data, textStatus) &#123; $scope.data = data &#125;&#125;) 如上代码$scope是不能更新的，因为success函数不在angular的名字空间里面了。 Python urllib2的问题使用以下代码抓取网页123456def getHtml(url): req = urllib2.Request(url) req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0') page = urllib2.urlopen(req) html = page.read() return html 发现报502错，这时候检查一下自己的翻墙软件是不是全局代理，这边我的Shadowsocks开启了全局代理，urllib2就不能抓https://127.0.0.1:8091了，502报错1urllib2.HTTPError: HTTP Error 502: Server dropped connection Django + Nginx + Https这里有一个非常大的坑，如果使用本机调试的话，千万不要选择localhost，而应该选择127.0.0.1.因为localhost可以是[::1]也可以是127.0.0.1，详见 这里 和 这里如果使用了localhost，那么会造成1min左右的加载问题，最初我以为是static files的问题，后来查看了error发现是 *24 upstream timed out (10060: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond) while connecting to upstream, client: 127.0.0.1, server: localhost ，这种问题一般都是写了localhost。–推荐以下blog http://www.ziqiangxuetang.com/django/django-models.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[钢筋混凝土学习]]></title>
      <url>%2F2015%2F10%2F20%2F%E9%92%A2%E7%AD%8B%E6%B7%B7%E5%87%9D%E5%9C%9F%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[土木工程这个学科啊，excited。特别是钢混这门课，总是学的有点迷糊（虽然我最后考试满绩）。我觉得钢混这门课学好大概有三件事，第一是理解清楚钢筋与砼这两种关键材料的性质，这些性质决定了我们设计的原则；第二是掌握承载能力的计算方法，对于梁的抗弯、抗剪，柱的抗压等构件的计算方法；第三是理解建筑设计的一般原则，将构件组成结构之后需要注意哪些方面。如果说还有一点就是实际设计截面时要注意一些构造要求，比如说弯起钢筋的排布，或者对钢筋排数和直径的限制。但这些都是次要的，主要的就是三件事情，因为这些原则它们的目的都是统一的，就是为了发挥钢筋混凝土这种材料的最大性能。 材料性质首先是钢筋与砼的性质，有一大串的指标：理解这些很重要。 混凝土部分混凝土的强度混凝土立方体强度等级fcu,k其中下标cu表示立方体，k表示标准值。立方体抗压强度没有设计值，在标准条件测得。标准条件：温度20℃±2℃，相对湿度为95%以上养护20d。这里有一个标准值和设计值的区别要看清楚。 荷载标准值k就是设计时要比它大。荷载设计值就是标准值乘以分项系数γ。一般地，恒荷载γg=1.2，活荷载γQ=1.4。同理，材料强度设计值等于标准值除以分项系数。例如混凝土轴心抗拉强度设计值ft=ftk/γc，其中γc=1.4。 标准试验方法需要注意： 加载速度越快越高 试验方法涂抹润滑剂会导致横向变形更容易，因此更容易破坏 尺寸效应小尺寸测得抗压强度要搞 其他强度fck 轴心抗压强度，和立方体抗压强度fcu,k之间存在公式转换。能更好的反应实际抗压能力。ftk 轴心抗拉强度，通过劈裂实验测量 混凝土的变形变形模量 原点模量（弹性模量）$ E_r $：应力应变曲线上过原点的切线。 割线模量$ E’_c $：应力应变曲线任一点和原点的连线。 切线模量$ E’’_c $：应力应变曲线任一点和原点的切线。 徐变徐变具有两面性： 优点：有利于结构内力重分布，减少外界因素对超静定结构的不利影响，降低附加应力 缺点：引起结构变形增大，导致预应力损失、结构破坏、徐变特点：加载越早、水泥越多、水灰比越大，徐变越大。骨料越坚硬弹性模量越高（对水泥徐变约束大）、养护时温湿度越高（水化充分），徐变越小。受到荷载作用后温度越高湿度越低，构件尺寸越大（失水受限），徐变越小。 混凝土本构关系可参考教材 混凝土的破坏一般混凝土的破坏指达到极限压应变 钢筋部分钢筋破坏有明显流幅（屈服台阶）的钢筋计算时以屈服点作为强度限值，没有明显流幅或屈服点的，取残余应变的0.2%对应的应力作为条件屈服强度标准值。同时对钢筋极限拉应变也有要求 钢筋本构关系钢筋与混凝土协同工作光面钢筋粘结力的形成因素：胶结力（水泥浆体对钢筋表面氧化层的渗透）和摩阻力（混凝土收缩）变形钢筋粘结力形成因素：机械咬合作用 混凝土保护层的作用 防止纵筋锈蚀 火灾情况下减缓钢筋温度上升 钢筋和混凝土更好粘结 梁的正截面承载力设计适筋梁破坏三阶段这个将来会做实验看到 I阶段：混凝土未裂阶段 Ia阶段：可作为受弯构件抗裂度计算依据 II阶段：混凝土带裂缝工作阶段 可作为正常使用阶段盐酸变形和开展宽度的依据 III阶段：破坏阶段 梁的正截面破坏形式此处可以对比柱的五种破坏形式 适筋梁适筋梁的破坏是塑性破坏，始于受拉区钢筋屈服，这时候受压区混凝土还未达到极限压应变。 超筋梁超筋梁的破坏是脆性破坏，始于受压区混凝土的压碎（达到极限压应变），此时钢筋还未屈服。 少筋梁少筋梁的破坏是脆性破坏，始于受拉区钢筋迅速屈服并进入强化阶段。对于这种破坏裂缝往往集中出现一条，宽度和高度都比较大。 梁的抗弯设计梁的抗弯设计相对比较简单。主要是考虑钢筋拉力T，受压区混凝土的均布力C（拉区混凝土相对于钢筋可以忽略不计）和弯矩M的平衡。此外还要避免超筋和少筋破坏。 梁的抗弯设计所做的简化的假定 五个基本假定 平截面假定 不考虑混凝土抗拉 混凝土受压应力应变曲线 注意和前面的本构关系比较，发现两者并不相同 钢筋极限拉应变取0.01 等效矩形应力图 受压区混凝土理论应力图形较难计算，这里等效成矩形，可以方便地得到C的大小和作用位置，同时引入了系数$ \alpha_1 $和$\beta_1$。 常用符号以及解释 符号定义 意义 $ A_s $ 纵向钢筋总截面面积 $ a_s $ 下部受拉钢筋合力点到截面受拉区边缘的距离 $ h_0 = h - a_s $ 下部受拉钢筋合力点到截面受压区边缘的距离 $ \rho = \frac{A_s}{b h_0} $ 配筋率 $ x$ 混凝土受压区高度 $ x_c $ 中和轴高度/受压区理论高度 $ \xi = \frac{x}{h_0} = \rho \frac{f_y}{\alpha_1 f_c} $ 相对受压区高度/配筋系数 $ \xi_b = \frac{x_b}{h_0} $ 界限受压区高度 $ \alpha_1, \beta_1 $ 受压区等效矩形应力图系数 $ f_y $ 钢筋抗拉强度设计值 $ f_c $ 混凝土抗压强度设计值 $ M_u $ 截面受弯承载力设计值 基本方程$$\alpha_1 f_c b x = f_y A_s \\M_u = f_y A_s (h_0 - \frac{x}{2}) \\M_u = \alpha_1 f_c b x (h_0 - \frac{x}{2}) \\$$以上方程可以暴力解 快速计算]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hexo常出现的配置问题]]></title>
      <url>%2F2015%2F10%2F19%2FHexo%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[在配置Hexo的时候常常会出现一些问题，比如hexo d无法部署，tags不自动生成，评论不正常显示等问题，本文给出了一些解决方案 HexoHexo（Hail EXO，好吧这个我瞎编的）是基于nodejs的静态博客构建工具。由于Ruby的蜜汁信仰问题（而且windows下Ruby有点坑），我弃Jekyll投Hexo。配置方法烂大街，这里不提了，可以去https://blog.lmintlcx.com/post/blog-with-hexo.html 这里看看。这次主要说一些可能遇到的问题。 常见问题git 问题 常见错误1event.js:72 throw er;// Unhandled &apos;error&apos; event 常见错误2Error: fatal : Not a git repository (or any of the parent directories): .git 解决方法：检查自己的.git文件夹是否在.deploy_git下，否则重新git init tags问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.calvinneo.com/tags/ 不能正常显示tag 检查是否安装了必须的包 1234npm install hexo-generate-index --savenpm install hexo-generate-tags --savenpm install hexo-generate-category --savenpm install hexo-generate-archive --save 检查是否配置了tags页面 检查/.deploy_git/tags下是否有index.html，这个是不会自动生成的，在命令行输入： 1hexo new page tags 该命令/source/tags/目录下新建了index.md。打开文件，键入或修改： 1type: "tags" npm故障 可能会出现如下故障: TypeError: Cannot read property ‘latest’ of undefined hexo 这可能是因为已经安装了以上npm包，所以不需要重复安装了。建议在hexo init后直接npm install即可。 NexT主题问题NexT主题使用多说插件有一些小注意点，比如说有些文章“喜欢”之后的分享转进来的链接是yoursite.com这个域下面的。打开duoshuo_shortname.duoshuo.com发现这些文章的地址也是yoursite.com。这个有三点原因： 检查site和theme的两个_config.yml中，是否url字段配置成自己的域名。 一旦同名文章添加进多说，其地址不会再次更改，因此要将多说中的文章先手动删除一下。 还有一种原因是文章的标题变动了，对于这种情况可以先hexo clean，再重新生成并部署。注意这时多说后台会生成一个新的文章，旧的文章并没有被替换。 设置网站的favicon值得一提的是有一个方便的设置favicon的方法： 将所需图片如favicon.jpg复制到source下 在网站的_config.yml下输入1avatar: /favicon.jpg Hexo中md文件转义的问题这可能是某篇文章有字符未转义，出现解析错误 sitemap网站地图12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 可能产生错误： duplicated mapping key at … path: baidusitemap.xml这是yaml的语法问题，比较简单的方法是直接去掉两个path中间的一个，每次只生成google或baidu的sitemap。当然你也可以把path缩进一下，这样就可以了。 Hexo s 命令不能在本地调试首先检查是否安装了hexo-server。其次不要在config里面显式用plugins指定插件。 MARKDOWN表格写法12345678&lt;!-- 上面一定要空一行 --&gt;| 表头1 | 表头2 | 表头3|&lt;!-- 下面冒号表示对齐方式 --&gt;|:-|:-:|-:|&lt;!-- 下面开始内容 --&gt;|a|b|c||d|e|f| 效果是这样的: 表头1 表头2 表头3 aaaa bbb cc d ee fff vendors文件夹无法访问vendors里面主要是脚本等东西，缺少之后网页无法显示。f12看到整个vendors里面的东西都404了。然后我在一个新建文件夹新建了文件/test/1.txt并deploy，发现以下错误：既然确定了是github抽风了，就将网站搞一份到coding.net，可以使用下面配置：12345deploy: type: git repository: coding: git@git.coding.net:calvinneo/calvinneo.git,coding-pages github: https://github.com/CalvinNeo/calvinneo.github.io.git,master 这边特别注意，里面一定要用空格而不是tab缩进。然后更新dns，之前因为github不稳定，我常常使用ss代理访问，但是代理的dns不一定立即更新，鉴于目前在国内网站coding.net重新部署了，可以直接访问www.calvinneo.com2016年11月10日更新：部署到coding之后vendors又被禁了。真是醉了，后来想起来蒲神给我看了这个issue，从github下了最新版本的next，这个问题解决了，FYI，我原来的版本是5.0.0。值得注意的是蒲神也是next，一次没坏过（无敌了）。然后在配置新版本的_config.yml的时候发现现在next可以支持MathJax和busuanzi了，之前我还一直手动的。 使用MathJax首先要将hexo的_config.yml和next的_config.yml都设置为true。然后next的_config.yml是默认给出了一个cdn去加载，但是我希望能够从本地加载（家里断网了），并且希望能够在用到的时候（流量有限）再加载这个模块。 配置本地的MathJax根据这篇博文，解压下来居然有50M，真是吐血！后来听从博客，放到theme的source目录下面的js里面了。 配置可选的MathJax加载方式根据这篇博文和这篇博文，在/themes/next/layout/_scripts/third-party下面找到了mathjax.swig。swig表示这里是使用的swig模板语言（有的是使用的ejs模板语言）。然后改成这样 123456789101112&#123;% if theme.mathjax.enable &amp;&amp; page.mathjax %&#125; &lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; ...&#123;% endif %&#125; 注意swig模板语言不能在\{\% if \%\}块里面嵌入\{\% inlcude \%\} hexo部署本地MathJaxnode内存溢出在配置的时候我一开始是把它放在/source/cdn/mathjax/目录下面的，我以为是这个原因，后来完全去掉这个模块还是不行，生成的db.json有150M炸了。后来发现还真是因为那个文件＋太大了的原因，导致第一次出现了Template render error: (unknown path)错误，然后因为db.json生成太大了，下面再读取这个db.json的时候内存就直接爆炸了。而我移除模块之后，还要再clean一下，把那个超大的json去掉才行。后来发现得放在theme/source/js里面。然后最好还要设置一下hexo的_config.yml里面的skip_render，下面方法来自这里 单个文件夹下全部文件：skip_render: test/*单个文件夹下指定类型文件：skip_render: test/*.html单个文件夹下全部文件以及子目录: skip_render: test/**多个文件夹以及各种复杂情况： 123skip_render: - test1/*.html - test2/** 静态文件过多在把MathJax放在theme/source/js里面以后在windows下hexo s发现：1Error: EMFILE, too many open files 出现以上的错误信息，目前还没有找到解决方法。 Hexo Mathjax转义部分LaTeX符号需要进行转义输入 LaTeX Hexo+LaTeX \ \\ \\ \\\\ _ \_ {, } \{, \} 重新建立网站git丢失icon和avataricon和avatar是不一样的，icon是favicon.ico决定的，显示在浏览器标签页的最左边（chrome），avatar是在_config.yml里面指定的，显示在侧边栏。 给Hexo(NexT)加上搜索功能swiftype是大家都推荐的工具，我用了之后各种资源加载不了，而且他还是一个收费的工具，于是我换成了Local Search根据https://github.com/iissnan/hexo-theme-next/pull/694上的介绍可以添加配置，还是非常简单的但是配置完成之后发现并没有弹出搜索窗口，显示的是javascript:;，然而根目录下的search.xml是存在的。后来f12发现是我在站点的配置文件中的swifttype_key字段没有注释掉，于是相当于现在还是使用的swifttype搜索，于是注释掉之后重新hexo g，再hexo s就出现搜索框了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCPC2015小记]]></title>
      <url>%2F2015%2F10%2F19%2FCCPC2015%E5%B0%8F%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[这周末(Oct 17-18 2015)，第一次参加了ACM类的比赛，感触颇深，小记一番。 这次比赛是第一届的ACM国赛，充满着对目前ICPC区域赛的怨念（开幕式上各种高级黑）不过也造福了长春赛区的ACMer们（榜惨不忍睹，好可惜我们没有拿到长春的名额啊），和我土力学实验、校庆志愿者、毛概实践课、计算机等级考试都重起来了，一天之内怒请五个假。晚上和张老师去火车站和阿洁哥良哥他们汇合，然后就是不出意料的火车晚点，不出意料的CCPC专列（上海到南阳的K1106），不出意料的上铺很冷，不出意料地发现自己身高不咋地。早上的Face++神牛们的会被我们睡过了，下午开幕式之后直接热身赛，三条题目。A题Googol String（这次比赛Google命题）意思是要找一个特定生成的二进制字符串序列的第Googol项。这条我一开始的思路是把它的每一项理解成一个序列，然后求出他的通项公式。后来良哥找到了循环节 (001 0) (110 0) 顺着这个思路想下去将每组中的第四项提出发现依然具有相同的循环节(001 0) (110 0)。这条AC。B题New Years Eve给出了如下的酒杯排布123456789第1层 1第2层 1 2 3第3层 1 2 34 5 6 这条最后硬上模拟做了出来。第二天是正式赛。12条。签到题两条L和A。L的意思是一串瓶子都相同，里面的东西不同，问如何用最少的瓶子去区分。答案显而易见，就是把瓶子摆成一个对称的形状，这样无论拿正拿反都一样了。如 D-C-B-A-B-C-D 答案就是2n+1。不过因为我们当时题目意思没理解对，导致一直不敢交，白浪费了20min。A题就是两个2x2矩阵 a b e f c d g h 叫你判断旋转之后是否相同，其实只要硬写四个if就好了。当时搞了两个数组，反而复杂了，WA了两次。不过因为这条我体验了一把主敲和现场A题的滋味。爽。下面是H，二阶数独，阿洁哥A了。我和良哥讨论CDG三条。C题是在一个1000长度的串N中找出所有的上升子列，问有多少种方法，这一条现场把case由10个增到了100个，按照朴素的N3算法，达到了1011的计算量，后来良哥又想了个N2LogN的算法，不过还是有109的量，良哥觉得并不能在1s内解决（不过仔细优化下应该还是可以的，我记得当时对面的陕西师范大学的人说这条题目卡常数，应该他们也是这个复杂度类的），不过题解说是N2复杂度就可以了，这具体怎么做，还不是太明白的。D题是一个扩展的背包问题。意思就是把一些线段（golden stick）去覆盖另一条线段（container segment），不过多了一个限制条件，也就是这些golden stick可以有一部分超出container segment的外面，只要整个的重心在里面。如图所示： 这条良哥先提出一个想法，G是这次比赛最蛋疼的一条，因为它真的很简单，我们的思路很清晰，然后中坑的也是这一条，WA了7次。先说题目就是围棋，问走一步能不能吧对方的棋子吃掉。这一条的思路就是BFS/DFS找出所有的连通分量，然后逐个棋子检测有多少个“气”。我们错在后来的优化上面，忽略了多个棋子可能公用一个“气”的情况，直接把每个棋子的“气”加起来看大于不大于1。赛题说完了，谈一下比赛的一些感受。首先是学习到了一些经验，比如说弱队看着榜选题A，比如说ACM的一些专用的调试工具，比如说切题的一些技巧。其次是失败的原因。首先我们学校这方面不是很强，对，不过这次也不至于输的这个憋屈吧？南大女队都比我们高到不知道哪里去了。究其原因我觉得我们还是在简单题上，没有做好，难题，我们确实不会，不过别人也不会，6A就可以上银牌区，4A就可以上铜牌区，而AGHL都属于签到题，CDK也是属于有时间可以想出来的题目，有难题，像BIJ，但是全场AK也就SJTU一个。所以我们差在哪里。签到题L，别人2min过，我们20min才过，为什么呢？只是一个对称的构造，原理很简单，但是我们一直在怀疑自己的判断 。接下来签到题A，WA了三次？为什么呢？代码写错了。为什么代码写错了呢？一个简单问题，用了一个比较复杂的方法来做（用了数组，WA的话可能是wrap上问题）,换成简单的实现就可以了。其实题目没这么难。 最后给出zhihu上面的评价 http://www.zhihu.com/question/36617747?rf=36617203–未完待续–PS 其实我只是先先看看这个模板效果23332016-12-04 我决定不续了，马上都退役了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[arthurluk攻略]]></title>
      <url>%2F2011%2F05%2F22%2Farthurluk%E6%94%BB%E7%95%A5%2F</url>
      <content type="text"><![CDATA[arthurluk是高中（大概2010年暑假）matrix67介绍的一个智力游戏，当时是大神arrowrowe引进的，我们做到46关。后面是收集的一些攻略。新版html -&gt; php 1http://riddle.arthurluk.net/stageone.htmldon’t install 2http://riddle.arthurluk.net/snowflakes.htmlCtrl+A点右下角链接 3http://riddle.arthurluk.net/fruit.html观察图片中水果种类strawberry 4http://riddle.arthurluk.net/strawberry.html查看源代码, 最后一行cleverest 5http://riddle.arthurluk.net/cleverest.html查看源代码，发现16是p，于是明白数字n代表第n个英文字母。（这技巧以后会经常用）{16, 15, 3, 11, 5, 20}→pocketpocket 6http://riddle.arthurluk.net/pocket.html谷歌搜索”弹珠台秘技 无限弹珠”bmax 7http://riddle.arthurluk.net/snowman/windows.html那是哪个操作系统的标志？linux 8http://riddle.arthurluk.net/snowman/linux.htmlCtrl+A看到”有聽過甚麼是元素週期表嗎？”于是查询：Phosphorus是第15号磷，Lithium是第3号锂，Boron是第5号硼，Hydrogen是第1号氢，Silicon是第14号硅。得到{15, 3, 5, 1, 14}。查看源代码，发现提示用第五关方法。{15, 3, 5, 1, 14}→oceanocean 9http://riddle.arthurluk.net/snowman/ocean.html在图中发现五个字母：左上角s，中下方阴影里o，右下角礼盒上l，圣诞树中上方偏右的外部v，左下角esolve 10http://riddle.arthurluk.net/snowman/eraser.html标题栏”diagonal”，于是连对角线发现”continue”continue 11http://riddle.arthurluk.net/search/unsinkable.html宣称永不沉没之船沉没了——再看图片风格——立刻想到泰坦尼克。查询得知泰坦尼克沉没于1912年1912 12http://riddle.arthurluk.net/search/1912.html标题栏”What’s the song?”，于是查歌词，发现是陈奕迅的《1874》1874 13http://riddle.arthurluk.net/search/carol.html标题栏”I wish I can see Pets Not Giants”，发现首字母故意大写标出PNG图片网址”http://riddle.arthurluk.net/search/tiger.jpg&quot;，换jpg为png，打开&quot;http://riddle.arthurluk.net/search/tiger.png“发现图片上的答案wingdingswingdings 14http://riddle.arthurluk.net/search/wingdings.html计算。3^12+659+8+2483=534202534202 15http://riddle.arthurluk.net/search/534202.html计算。4562*3+65536/256=1394213942 16http://riddle.arthurluk.net/search/13942.html查看源代码，发现提示”数字人生”（香港有个电台节目叫”数字人生”）查询”数字人生”（http://baike.baidu.com/view/1234166.htm）发现歌词中”534202 13942”测试下一行”13424”，错误然后发现下面还有一行”534202 13942”，测试它的下一行”43140624”43140624 17http://riddle.arthurluk.net/search/running.html熟悉网页应立即意识到”&nbsp;”是空格，空格的英文”space”恰为5个字母space 18http://riddle.arthurluk.net/search/excuse.html查询”71828, 18284, 59045, 23536, 02874”，发现它是自然对数的前5个5位截断（http://baike.baidu.com/view/11033.htm）于是用第6个5位截断71352 19http://riddle.arthurluk.net/number/morse.html地址中”morse”提示莫尔斯，查看源代码发现提示”if “”l”” represents “”-“””用”-“替换”l”得到”-i-i i-i i i- - i”据莫尔斯编码（http://baike.baidu.com/view/20024.htm）对照替换得到&quot;create“create 20http://riddle.arthurluk.net/number/copycat.html地址”copycat”提示把图片另存为，用记事本打开后发现含明文字符串”The password is supply.”supply 21http://riddle.arthurluk.net/number/battery.html超链接（”Hyper Text Markup”意为”超链接”）中划去Lhttp://riddle.arthurluk.net/number/battery.htm 22http://riddle.arthurluk.net/number/battery.htm图片左下角发现”run! escape!”，去掉非英文runescape Oops!http://riddle.arthurluk.net/number/runescape.htm需要L回来http://riddle.arthurluk.net/number/runescape.html 23http://riddle.arthurluk.net/number/runescape.html“QWERTY”指键盘排序转字母序，例：O是第9个，对应第9个字母i{9, 19, 12, 1, 14, 4}→islandisland 24http://riddle.arthurluk.net/number/heartbreak.html查看源代码，发现提示”別說你沒有這個遊戲 :P”，联想地址”heartbreak”、说明”偷走你們的心”、图片纸牌，得到结论红心大战查询红心大战计分法（http://wenwen.soso.com/z/q89592561.htm）得到&quot;每张红桃1分，黑桃Q 13分”结合标题”addition”（加和），于是计算13+1*5=18，测试18，错误，测试eighteeneighteen 25http://riddle.arthurluk.net/number/pascal.html地址和标题都提示”pascal”，于是用pascal运行此代码得到44244424 26http://riddle.arthurluk.net/flash/tutorial.html查看源代码，发现”答案在下面”，到最下面一行发现”你好像誤解了我的意思”，领悟到指的是Flash的下面打开Flash（http://riddle.arthurluk.net/flash/flash.swf），调节比例（纵向拉长），发现&quot;The password is :champion”champion 27http://riddle.arthurluk.net/flash/stillflash.html要等3600s，足足1h，当然要跃过时间。发现无法跳帧，于是动用VB（因为VB最方便嘛 = =。）代码：（添加Flash播放器控件，命名S） S.Movie = “http://riddle.arthurluk.net/flash/wait.swf“ S.Play S.SetVariable “time”, 0发现”well… well…\nthe password is ATTIC”attic 28http://riddle.arthurluk.net/ballgames/snooker.html查看源代码，发现”Again, a=1”，于是寻找数字组地址和标题都提示”snooker”，于是查询斯诺克计分法（http://baike.baidu.com/view/5025.htm，相关术语&gt;&gt;彩色球）得到红1、白2、绿3、棕4、蓝5、粉6、黑7转换球得到{1, 3, 3, 5, 4, 5}→accedeaccede 29http://riddle.arthurluk.net/ballgames/accede.html查询”eagle par”（http://www.google.com.hk/search?hl=zh-CN&amp;source=hp&amp;q=eagle+par&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）立刻明白是birdiebirdie 30http://riddle.arthurluk.net/moon/essential.html第一个来月球的当然是阿姆斯特朗了armstrong 31http://riddle.arthurluk.net/moon/armstrong.html查看源代码，发现提示”Not mathematics but coordinates”（不是数学而是坐标）在图片中建立标准计算机坐标系（左上角原点，X正方向水平向右，Y正方向竖直向下）在底下那串数字里得到坐标（+为坐标间的分隔，-为X、Y间的分隔）检查每一组坐标对应的点所指向的字母，得到horoscopehoroscope 32http://riddle.arthurluk.net/moon/horoscope.html标题栏”A cartoon character”，查看源代码，图片对应”Who’s my owner?”联想到多来A梦的任意门doraemon 33http://riddle.arthurluk.net/checked/normal.html图片上一闪而过”REMEMBER THE PASSWORD: 69368549465021468008”（用截屏软件或者干脆(Alt+)PrintScreen再粘贴）69368549465021468008 34http://riddle.arthurluk.net/checked/advancedsearch.html标题提示”In Depth Battlepedia”、源码提示”NQII InSaNe Mode”、说明提示”no space, no capital”（无空格，无大写）搜索过程是枯燥的，就省略了。最终找到了此游戏的资源库（http://items.jellyneo.net/?go=show_items&amp;name=bow&amp;name_type=partial&amp;desc=&amp;cat=0&amp;specialcat=0&amp;status=0&amp;rarity=0&amp;sortby=name&amp;numitems=20）第二页的左下角就是这把弓，图片完全一致。名称是”Bow of Destiny”（去空格，去大写）bowofdestiny 35http://riddle.arthurluk.net/checked/bowofdestiny.html查看源代码，图片的Aim属性”Find the composer”（找到作曲者）查询”Sonata in E minor, Op.90”，发现作曲者是Beethovenbeethoven 36http://riddle.arthurluk.net/checked/hogwarts.html地址提示霍格沃茨，图片提示火车，源码提示”有 hogwartsone 即是有…”查询之（http://www.google.com.hk/search?hl=zh-CN&amp;safe=strict&amp;q=%E6%9C%89+hogwartsone+%E5%8D%B3%E6%98%AF%E6%9C%89...&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）找到（”http://zhidao.baidu.com/question/165484021.html&quot;）gillywater 37http://riddle.arthurluk.net/checked/gillywater.html标题”The soup of Sung”（宋家汤？）、输入框answerlength属性”6 or 7”、查看源码”Guess a food”查询”The soup of Sung”（http://www.google.com.hk/search?hl=zh-CN&amp;source=hp&amp;q=The+soup+of+Sung&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）果然是罗宋汤。borsch 38http://riddle.arthurluk.net/express/love.html输入Romeo、Juliet不解释……计算得到24.5%24.5 39http://riddle.arthurluk.net/express/24.5.html谷歌地球发挥作用。查看25°2’1”N 121°33’52”E处，是台北taipei 40http://riddle.arthurluk.net/express/taipei.html标题”Vowel”，动用Notepad++复制文本进去，用正则”[AEIOU]”高亮全部结果，发现隐藏着的EXTRAextra 41http://riddle.arthurluk.net/express/extra.html标题”Keyboard caesar”，于是用CaesarCode加解密dyrq，均错误恺撒密码 后推三位联系Keyboard和第23关经验，于是用键盘顺序来作密表，加密dyrq得到hour 键盘后推三位hour 42http://riddle.arthurluk.net/express/hour.html标题意为帝国时代2，Ctrl+A看到”這建築物的英文名稱？”翻译铁匠铺得到BlackSmithblacksmith 43http://riddle.arthurluk.net/factory/mix.html地址提示”混合”，联想”巧克力、咖啡”得到摩卡咖啡（http://baike.baidu.com/view/8123.htm）mocha 44http://riddle.arthurluk.net/biologycity/entrance.html查看源代码，进入”http://riddle.arthurluk.net/biologycity/plant.html“那个蘑菇（http://riddle.arthurluk.net/biologycity/mushroom.jpg）哪里错了呢？（它不是蘑菇，好像是树。。。）于是进入http://riddle.arthurluk.net/biologycity/tree.jpg，可是这里是草于是进入http://riddle.arthurluk.net/biologycity/grass.jpg，可是这里是蜗牛于是进入http://riddle.arthurluk.net/biologycity/snail.jpg，可是这里是鳄鱼于是进入http://riddle.arthurluk.net/biologycity/crocodile.jpg，可是这里是熊猫于是进入http://riddle.arthurluk.net/biologycity/panda.jpg大写字母要敏感的。。http://riddle.arthurluk.net/biologycity/troy.html 45http://riddle.arthurluk.net/biologycity/troy.html需要翻墙。。不解释。请跳到下一关 46http://riddle.arthurluk.net/highway/quest.html德沃夏克键盘… 47http://riddle.arthurluk.net/factory/fix.htmlorienteering43关是mix…不要说,查吧… 48http://riddle.arthurluk.net/factory/charlie/chocolate.html查理的巧克力工厂 49http://riddle.arthurluk.net/highway/calculator.html卡西欧 FX3650P 计算器 Mem clear : ? → A : ? → B : Lbl 1 :B ÷ A – .5 : Fix 0 : Rnd : Norm 1 : Ans → C :B – AC : Ans 10x D M+ : C → B :D + 1 → D : C =&gt; Goto 1 : M Find the output if A=5 and B=2007 也是很好算的 31012 50.1http://riddle.arthurluk.net/highway/fifty.html关键是“THIS TIME”直接在dvorak键盘上平移而不是转到普通键盘 发现和果然和上次41关一样，右移动3位，得到答案：truth 50.2http://riddle.arthurluk.net/highway/truth.htmlsilver.jpg 改为 gold.jpg 50.3http://riddle.arthurluk.net/highway/choice.html图的左上角 51http://riddle.arthurluk.net/highway/park.html数独，填出来是1942，中途岛海战,二战119 97 14 = war 52http://riddle.arthurluk.net/highway/secondworldwar.html保龄球 积分规则得到以下分数:7 9+10 10+10 10+8 8 10+10 10+10 10+10 10+10 10+8答案 187 53.1：http://riddle.arthurluk.net/samuelriddle/shadow.html看到那个括号了吗？仔细看，那个单词中有一个字母是错误的，改正它放入地址栏进入riddle 53.2：http://riddle.arthurluk.net/samuelriddle/riddle.htmlc c r a n e 能组成什么新单词呢？cancer(我弄了半小时!!!) 53.3：http://riddle.arthurluk.net/samuelriddle/cancer.htmlmspaint_a.png，把-a换成b.d.e.f.g…？一个一个的跳,直到h后把源码中所有mspaint_h.html全替换成空白 然后你看到一个网页，在右下角。。。mspeint_h.html 53.4：http://riddle.arthurluk.net/samuelriddle/mspeint_h.html这关就不为难你们了，需要专门的查看器，所以答案是muffin54关：http://riddle.arthurluk.net/samuelriddle/muffin.html察看图片吧 55关：http://riddle.arthurluk.net/chem_is_try/muffin.html原来这四个都是 欧盟的 危险品标识corrosive有害的harmful易爆的Explosive易燃的flammable首字母 55.2：http://riddle.arthurluk.net/chem_is_try/chef.html！！擦，同上一关类似~http://s2.hubimg.com/u/80145_f496.jpg 这是资料 55.3http://riddle.arthurluk.net/chem_is_try/beef.html希望你们还活着。。把XXXX改成txt，得到提示然后，1，听歌，2 谷歌它（元素周期表） 56关：http://riddle.arthurluk.net/chem_is_try/rubidium.html255汉诺塔。。。 57关： 微软雅黑所属的字体类型的名字Segoe Ui~~微软在Windows Vista和Office 12中放弃Windows XP中的Tahoma字体，转而启用新的Segoe UI字体，意在提高字体的可读性，使之更加人性化看图片名称，找出这个字体~是特有的哦~ 58关：http://riddle.arthurluk.net/escalator/segoeui.html1293，卡通人物 tiyilon=doraemon 59关：http://riddle.arthurluk.net/poker/chinese_horoscope.html罗马数字，生肖，首字母，我相信你知道的~ 60.http://riddle.arthurluk.net/poker/drop.html德国61.http://riddle.arthurluk.net/poker/germany.html一个日期(希特勒的生日)62.http://riddle.arthurluk.net/poker/hitler.htmlpiano(36个白,52个黑)63.http://riddle.arthurluk.net/goldengatebridge/obstacle.php看提示“此地不宜久留，請到圖所示的地方。”~~这是金门大桥呀~~再看网址http://riddle.arthurluk.net/goldengatebridge/obstacle.html ，其实的文件夹名就是金门大桥的意思，那剩下的obstacle是什么意思呢？百度之，原来是障碍~~那么，我们去掉障碍不就能到金门大桥了嘛~~于是输入http://riddle.arthurluk.net/goldengatebridge ，发现它跳了几次后跑到网站首页去了~~怎么回事？~~再看提示，“此地不宜久留”，哦，就是说要在它跳转的时候看代码~~于是多试几次呗，在跳转中不停地打开代码，直到你看到“你最後還是停了下來！”为止 64.http://riddle.arthurluk.net/goldengatebridge/flashgame.html这一关提示为“辛苦了這麼久，來玩個射擊遊戲吧！(Arthur：這關算是大放送XD)本關目標就是要找出 Final Boss 的名稱 (** Zombie)”，嗯，那就玩游戏吧~~只有几个要注意的，一是密码门那儿的密码就是门框上的不过要从右往左输；二是中毒后大左边的箱子，注意看会有个黑色的小东西出现，，打它得红卡，然后打右上按钮左边的黑线，即刷卡，然后依次打按钮即可~~最后要注意的是最终boss名字出现时间较短，要用心记~~嗯，最后出现的是“Limbless Zombie”意为无足的僵尸~~然后再注意一点，提示中已经给出Zombie了 65.http://riddle.arthurluk.net/goldengatebridge/limbless.html这一关咋一看我还以为是多少进制的呢，再一看代码，有个“ADFGVX cipher”，谷歌维基之，得ADFGVX密码~~是一战时候用的哦~~简单的说就是一个6*6的表格，行和列的表头都是ADFGVX，然后把26个字母和10个数字以一定顺序填入方框中，这样每个字母或数字都可以用如AD这样的坐标来代替(AD代表t)，读坐标时先读行再读列~~这样，题目“ADDDXF FXXFGXAD FGADAFGAXF AGFG GFAFAXADGGXDXF.DDADXAAG”就被翻译成了the next stage ls capture.html~~神奇吧~~不过里面有一处应该是is作者弄成了ls，应该是他错了~~ 66.http://riddle.arthurluk.net/goldengatebridge/capture.html 67.http://riddle.arthurluk.net/fortress/atmosphere.php看代码，里面有句“What is ISP in full name?”和一句“size=”20” maxlength=”20” answerlength=”23””~~意为答案是23为长度的ISP的全称~~百度，得Internet Service Provider~~输入internetserviceprovider，发现答案栏不够输，因为刚才代码中写了，最长范围为20答案有23~~于是输到网址中~~它说“答案就對了，不過你應把答案放到該放的位置。”~~看来还是要放到答案栏中~~怎么办呢？~~把源码保存下来，在本地自己用此源码新建个网页，改动action=”../check3.php”&gt;变为action=”http://riddle.arthurluk.net/check3.php&quot;&gt;，size=&quot;20“ maxlength=”20” 变为size=”23” maxlength=”23” ~~保存，打开，输入~~成功啦~~ 68.http://riddle.arthurluk.net/fortress/umbrella.html 69.http://riddle.arthurluk.net/fortress/vincentvangogh.html这一关其实就是个数学推理题，不过有点难度~~它问：ICQ+IQC+CIQ+CQI+QIC+QCI=WHAT，提示“WHAT is the answer”，于是计算呗~首先我们设2I+2C+2Q=XT，于是题目变成XT+10XT+100XT=WHAT~~我们用穷举法假设XT的所有可能，最后得出XTAHW=28013、83019、37014、73018、38124、83129、46015、64017、47125、74128、48235、84239、65127、57236、75238、58346、85349、76348、68457、86459、87569~~那么接下来就一个一个试呗~~我运气好，试第一个就对啦~~3108~~嗯，下一关 70. 72.http://riddle.arthurluk.net/fortress/bend.html盐…http://riddle.arthurluk.net/fortress/salt.html 73.http://riddle.arthurluk.net/fortress/sodiumchloride.phpNonogram游戏填充,是heart 74.http://riddle.arthurluk.net/marble/maze.phpbasketballhttp://riddle.arthurluk.net/marble/basketball.htmlJerry Alan Westhttp://riddle.arthurluk.net/marble/jerry.php这条是ascii和16进制解码 75.http://riddle.arthurluk.net/marble/chat.htm:題目為ひらえ うわ てを おそまけけふまそめ，由提示的伊呂波歌得下面歌詞：いろはにほへとちりぬるをわかよたれそつねならむういのおくやまけふこえてあさきゆめみしえひもせす並且由原始檔中寫的pic16.gif圖中看出A~Z&amp;a~z順序（Wedding字形），為縱行排序。將伊呂波歌依序填入1~47的空格，就可拼出”The pw is crossworD”（pw為password縮寫），故密碼為crossword 76.http://riddle.arthurluk.net/marble/exifforh人名 Aragorn Eowyn Gollum Théoden答案gate 77.http://riddle.arthurluk.net/sweater/english帝国时代答案 isolation 78.http://riddle.arthurluk.net/sweater/colour.php 79.http://riddle.arthurluk.net/sweater/royalblue.phpfind the director电影是mission impossible的海报导演brian de palma 80.http://riddle.arthurluk.net/sweater/briandepalma.php是纽约的夜景(联合国总部)答案 unitednations 81.http://riddle.arthurluk.net/sweater/unitednations.php香港童子军 答案 voyageraward 82.http://riddle.arthurluk.net/keroro/floppy.phpatbash密码 解码出来是notepad 记事本图片的名字为treasuremap.jpg,改成treasuremap.txt得到关于隐藏关卡的信息(aboutthehiddenstage.html),然后读到好几句话,每句话的字数:20,18,9,1,14,7,12,5;得到triangle 83.http://riddle.arthurluk.net/keroro/triangle.html图片名是tan.jpg,打开sin.jpg和cos.jpg得到fire love就是恋爱三要素和燃烧三要素 首字母来的答案honest 84. 一开始毫无头绪~~我查了标题triangle，是三角形的意思，还有一部电影也叫这个名字，恰巧我看过~于是输入导演名，不对~~然后看图片~我把图片后缀改成bmp、png、txt都不对~~又百度了图片中的Toblerone，是卡夫的三角形巧克力~~依然无头绪~~后来在卡了好久之后，我突然发现图片名tan不就是三角函数嘛~于是我试了sin和cos~出现心和火之类的~~我输入heart、fire这些都不对~~后来我突然想到会不会这回是要改前面的网址呢~于是我改成heart.php之类的，还是不对~~再后来我在打heart时突然想到会不会是heat温度呢？输入heat.php~显示“Partly correct.”部分正确~~然后我就无能为力了~~于是各种谷歌百度~网上有人提示“oxygen”氧气~~于是输入oxygen.php~~显示“Partly correct.”~~这时就有点眉目了~火燃烧的三个条件就是温度、氧气、可燃物~~于是看sin那张图~~试了好几次，最后发现是fuel~输入fuel.php~~显示“Partly correct.”~~对了，这时候注意到每个源文件中都有“That’s 1/6 of the answer”，也就是说我们还少三个单词~~好吧，继续百度，有大大说是passion激情~输入passion.php~~显示“Partly correct.”~~还有，这回出现的图片是船，前面分别是礼物盒子、急救车、问号~完全不知道是什么~~继续找大大~~有人说是“intimacy”亲密，出现一个圆~~又有人说是“commitment”委托，出现火车~~好啦现在6个全齐了~输入“heatoxygenfuelpassionintimacycommitment.php”~~竟然不对！~~我彻底疯了~~八成是要拆字~~好吧，我承认我拆不出来~~于是再去找大大~~得到提示“honest”~~输入，通过~~下一关http://riddle.arthurluk.net/keroro/honest.php ~~好吧，其实这一关我真的没干啥，全是在大大们的各种指引下才过的~真悲催~~唔！刚才洗澡的时候我突然地悟啦！~那个三角形中间套个火的图案其实在我们的化学书上见到过的，讲的就是火的三元素，所以才是温度heat、氧气oxygen、可燃物fuel~~那么那个三角形中间套个love的图案，讲的就是爱的三要素了~我百度“爱情三要素”，得到“爱情三角形理论”：美国心理学家斯腾伯格提出的爱情理论，认为爱情由三个基本成分组成：亲密（Intimacy）、激情（passion）、及承诺(commitment) ~~所以啦，那6个答案就都出来啦~~至于怎么把这6个答案合成honest~我现在还不知道~~http://riddle.arthurluk.net/keroro/honest.phphttp://riddle.arthurluk.net/keroro/angol.php 85.http://riddle.arthurluk.net/keroro/100000000000000.php在数字键盘上写字1478963456填上发现是A，9874123是C，852是I，74178621是D，9874123456是E，1475369是N，789852是T，合起来就是ACCIDENT哈~这一关一开始还真以为是什么找规律呢，结果看了好久也没看出个所以然来~~后来百度这些数字~~竟然被我找到了专门讲键盘加密方法的一个网页http://bbs.moyu8.com/home.php?mod=space&amp;uid=85626&amp;do=blog&amp;id=10751 ~~这个里面的数字键盘加密法，说白了就是在数字键盘上写字，怎么像怎么来~~于是我在数字键盘上把1478963456填上发现是A，9874123是C，852是I，74178621是D，9874123456是E，1475369是N，789852是T，合起来就是ACCIDENT意外事故~于是输入accident，通过~~下一关http://riddle.arthurluk.net/regular/recycle.php ~~86.http://riddle.arthurluk.net/regular/recycle.php这一关我的浏览器没发出声音，不知道你们的是不是~~不过我在源文件中发现了音乐的地址http://riddle.arthurluk.net/regular/stage86.mid ~~ 呃~但是我听不出来这是什么哎~~这就是从小没学音乐的后果~呜~~然后我用了一个在线录歌搜音乐的网站http://www.midomi.com/ ~~可惜还是没搜出来，这个网站主要是搜有人唱的歌的~~呃~于是我就只好在百度上搜“世界名曲钢琴曲”~然后一首一首的听~~终于被我听到啦~~是《土耳其进行曲》~~然后百度“土耳其进行曲”~得到是奥地利音乐家莫扎特Mozart于1781年至1783年间在慕尼黑或维也纳所作的~~于是输入mozart~~呃，竟然不对？幸亏我有没事就查看源文件的习惯~只见源文件中赫然写着“The next stage is in problem.php” 87.1http://riddle.arthurluk.net/regular/problem.php先看源代码，发现图片名为stage87pic1，于是好奇的输入stage87pic2，又出来一个图片~一共有5幅~~然后挨个儿看吧~~第一幅图片一开始我以为是什么游戏，后来猛然想到应该是元素，中间是质子，周围是一圈圈电子层~第二幅图片是一排数列？呃，这个彻底不知道，先放着~~第三幅图片是一个雪屋，大概是爱斯基摩人的吧~用百度翻译翻译雪屋，得igloo~这个有点小把握~~第四幅是一堆橘子，orange~~第五幅是扫雷游戏，可惜我家的这台电脑是中文版的，要是宿舍的那台英文版的就好了~所以只好百度，好像扫雷游戏的英文名是mine sweeping~~其实我一开始也愣了好久，后来才想到可能是用各个图片的首字母~~现在可能是是z?iom（？为一个任意字母，*为任意个任意字母）~~我用必应词典，输入z?iom~竟然没有！~~于是去掉最不肯定的z~~输入??iom~得axiom（公理）和idiom（习语）~~挨个试~~试到idiom时，终于对了，进入第二小关 87.2The grass is always greener on the other side，这山望着那山高http://riddle.arthurluk.net/regular/thegrassisalwaysgreener.php 88.http://riddle.arthurluk.net/regular/idiom.php点白色一团纸 89.http://riddle.arthurluk.net/eightynine.php 116.http://arthurluk.net/riddle/horror/quaver.php 117.http://riddle.arthurluk.net/revolution/mountain.php不要输密码框118.http://arthurluk.net/riddle/revolution/emptyfortstrategy.php 参考了以下的文章http://www.zhangshengdong.com/post/2012-03-17/15426274http://www.douban.com/group/topic/27282526/http://jilu.zhangshengdong.com/post/2012-05-30/40028636785http://www.sudokufans.org.cn/forums/topic/732/http://jilu.zhangshengdong.com/post/2012-05-30/40028636785和这个攻略 1:点击Don’t install. 2:Ctrl+A ，你看见了什么？ 3：查看图片的地址然后打开，知道是？ 4:打开源文件。 5:这个是字母表密码。 6:goole一下无限弹珠的游戏秘籍 7:与Windows齐名的另一款系统软件 企鹅系统？ 8:（元素周期表）先翻译成数字，再翻译成字母。 9:看见图上的字母了吗？我一直以为是loves 10:源文件老规矩看title “Diagonal” 11:泰坦尼克号：不沉的船还是沉了 12:百度一下你就知道（1874） 13:看见源文件中有一个Pets Not Giant.取首字母得PNG,拷贝老虎图片地址，将后缀名改成png便知秘密 14:直接算出来吧（534202） 15:直接算出来吧（13942） 16:数字人生（43140624） 17:空格？ 18:百度一下 自然对数？（71352） 19: 如果l是-那么i就是….【摩斯电码】 20:另存为——用记事本打开 或者查看图片注释。 21:去掉超文本标记html后边的l 22:仔细看图片？左下角？还有上一关？ 23:键盘移位密码： qwert键盘上对应的数字？ 24:红心大战记分规则？，答案用英文表示。 25:sqr()函数：平方 ; trunc()函数：去小数保整数。 26:打开FLASH源地址 冠军的身上- - (champion) 27:等吧。或者把FLASH下下来跳帧（好吧 不浪费大家时间了 答案是attic） 28:计分，并替换成英文字母。 29:Google之 30:…度娘一下吧 31:下载图片，进入画图，每个坐标对应一个字母。 32:这个门是叮当猫的。。。（很冷） 33:截屏。 34:在Jellyneo的Data base中搜索。 35:贝多芬的曲子。。 36:由hogwartsone推想hogwartszero然后google之 37:观察源文件得到提示，然后Google之 38:随便试试 39:Google Earth之 40:所有的元音调一下。 41:键盘凯撒。 42:帝国时代2建筑 43:Google之 44:不停地修改错误 45:其实就是作者的Xanga. 46:sign my questbook然后翻到最后一页，期间可以欣赏Simon大神的留言。。 47:Google之 48:观看标题，《查理的巧克力工厂》 49:老老实实算吧。 50:1)凯撒 2)观看源文件知道如何加密 3)看到silver想到gold 4)Jellyneo的Data base 5)看图的左上角 51:先解数独，然后猜事件 52:保龄球 187 53:1)改正riddle.. 2)cancer. 3)图片右下角，carrot. 4)破解QR码，muffin 54:修改中间,查看图片 55:1)首字母缩写 chef 2)同上 beef 3)观察标题。 56:汉诺伊塔 57:Segoe UI 58:1293..Google之 59:MCMLXXXVIII=1988=D MCMLXII=1963=R MCMLXII=1997=O MMVII=2007=P 60:帝国三主城 Germany的Berlin 61:加起来，然后看源文件，得到答案。 62:钢琴。 63:停止。先remove obstacle,然后停止 64:完成游戏。 65:查询得结果，棋盘密码。 66:语法 67:修改源文件 68:Google，然后多试几次 69:当成小学奥数题算，然后多试几次 70:这个。。看源文件。。观察日期的规律。 71:1)重复第21关 2)找出4种货币和他们对应的名称，连起来即可 72:考验你的时候到了。嘿嘿 73:填充，然后我发现这个简直是表白利器啊！！ 74:拼图，然后组词，这个词我想了很久。。 75:1)Google之 2)Hex+Ascll嘿嘿！别想太复杂 3)直接Google找答案！！ 76:看过《魔戒》没,认出你能认出的所有的，然后枚举吧！ 77:这个铁匠铺和外面的世界__？eyesolation是什么？ 78:http://ken.frwonline.com/color.htm自己研究吧 79:Wiki之 80:真的很简单 81:这个组织我好喜欢啊。为什么大陆没有呢？ 82:很烦人的一关，先观源文件，然后转换，然后翻译，然后再观汉字，然后再转字母 83:这个。。找吧。 84:1)太变态了！！Arthur 恶趣味！！！ 2)不断加0!!Arthur 恶趣味！！！ 85:感谢密码吧 86:看源文件就应该清楚它问的是什么。。然后相信自己。。 87:1)认出你会的所有的，然后枚举吧！ 2) 西方谚语 88:1)压力。。。 2)猜猜看呀。。。首页是？ 89:1)四边形推理 2)Do it! 看起来是什么幂诶。。。 90:1)单键吗？ 2)偶尔来一个水关反而会死很多人。。 3)What is missing? 4)呃。。 91:什么东西？一片空白？ 92:话说他少鸣谢了一个。。见66关 93:移去8个字母 94:去源文件看看吧。。嘿嘿。。相信你自己 95:找到赛道吧。 96:首页的图片 97:文字游戏 98:缩写 99:把图片绘出，然后识别一下 100:手机上写写，然后枚举！！ 101:排列组合 102:哇！这纸应该会很大！！ 103:100关后还有如此水关。。 104:搜索这个星舰 105:用圆周率来跳读，然后回答问题。 106:什么平均数来着？ 107:我。。。我以为是圣经。。原来是本儿童读物。 108:有一个原来的技巧在里面。 109:brick ignore the k 然后就行了 110:这个。。先变黑白，然后再flip然后就行了 111:保存下来，各种拉伸 112:这是某样东西的分布图 113:下载程序，然后找吧 114:旋转呀！ 115:哇哈哈，这些音符我太熟了 116:等效代换，有问题的可以问我。。 117:有密码框就一定要输吗？]]></content>
    </entry>

    
  
  
</search>
