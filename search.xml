<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gRPC配置]]></title>
    <url>%2F2018%2F03%2F28%2FgRPC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[gRPC的配置真的是蛋疼。主要原因是官方的推荐方式是从源码编译。于是我首先花了一个下午用小水管clone了下gRPC和它的十来个三方库。 protobuf首先Ubuntu默认的protobuf是2.6.1，而Google给的helloworld示例需要protobuf 3才能编译，于是我们的protobuf也要从源码编译装一下。注意gRPC不会自动帮你make install protobuf，所以需要到third_party目录下找到protobuf的源码编译安装。 使用cmake编译gRPC在编译gRPC项目时，对于客户端会生成.pb.h和.pb.cc两个文件；但是服务端则需要.grpc.pb.h和.grpc.pb.cc两个文件。这四个文件是由protoc通过不同的指令生成的，如下所示，这里grpc_out即表示生成服务端需要使用的带.grpc.pb系文件，plugin字段需要我们指明grpc_cpp_plugin这个插件所在的位置。如果我们从源码编译安装的话，这个插件一般会在/usr/local/lib里面，我们一般需要将这个路径export出来，或者可以运行这个脚本来一劳永逸地解决问题，如果直接使用Makefile来编译，我们需要先按照下面的规则生成四个文件，此外我们还需要将程序链接到protobuf、grpc++、grpc这三个库上。gRPC的官方Git仓库中提供了Makefile的demo。12$ protoc -I ../../protos --grpc_out=. --plugin=protoc-gen-grpc=`which grpc_cpp_plugin` ../../protos/route_guide.proto$ protoc -I ../../protos --cpp_out=. ../../protos/route_guide.proto gRPC的官方Git仓库也提供了CMakeLists的Demo，不过我并没有能够成功进行编译，它提示缺少gRPCConfig.cmake或grpc-config.cmake文件，于是我放弃了来自官方的CMakeLists。在我先前的protobuf试用中，我了解了cmake中的PROTOBUF_GENERATE_CPP宏可以编译出.pb.h和.pb.cc两个文件，现在我们需要依葫芦画瓢搞出一个PROTOBUF_GENERATE_GRPC_CPP宏就行了。在爆栈网的一篇回答中我找到了一个实用的实现，借助于它我实现了自己的CMakeLists。注意目前gRPC的编译需要C++11标准的支持，所以这里我使用了SET(CMAKE_CXX_COMPILER /usr/bin/g++-7 CACHE PATH &quot;&quot; FORCE)来强制设置了编译器。]]></content>
      <tags>
        <tag>gRPC</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++智能指针的使用与实现]]></title>
    <url>%2F2018%2F03%2F18%2FC%2B%2B-smart-pointer%2F</url>
    <content type="text"><![CDATA[在C++史前时代只有一种智能指针std::auto_ptr&lt;T&gt;，它的行为类似一个lock_guard&lt;T&gt;，或者经过封装的RAII，但在使用中发现，依托于RAII是不够的，为了方便地实现更复杂逻辑下的资源管理，我们需要从资源的所有权上对智能指针进行更加细致的分类。在C++11之后，标准库引入了std::shared_ptr&lt;T&gt;、std::unique_ptr&lt;T&gt;、std::weak_ptr&lt;T&gt;来替换之前的std::auto_ptr&lt;T&gt;。截至目前为止，我基本没怎么用过智能指针，一方面之前做的项目都比较局限，使用RAII或者对象池会更方便，另一方面智能指针和对C风格的兼容性也不是很好，例如很多C风格的代码要求bit-wise而不是member-wise的操作，而智能指针并不是trivial的，而且具有传染性，所以往往适用不了。【未完待续】 shared_ptr正确使用shared_ptr构造函数、删除器与分配器std::shared_ptr的构造函数有12种之多，这里只列举几种重要的123456789// 构造一个空的智能指针constexpr shared_ptr() noexcept;constexpr shared_ptr( std::nullptr_t ) noexcept;// 这是最常用的template&lt;class Y&gt; explicit shared_ptr( Y* ptr );// 这里在后面加了一个删除器的参数template&lt;class Y, class Delete &gt; shared_ptr( Y* ptr, Deleter d );// 这里又添加了一个分配器的函数template&lt;class Y, class Deleter, class Alloc&gt; shared_ptr( Y* ptr, Deleter d, Alloc alloc ); 删除器和分配器构成了智能指针的主要特性之一。我们知道智能指针的重要特点就是自动帮助我们管理资源，它们解决了何时销毁对象的难题WHEN，但同时也让我们可以自行定义如何创建和销毁对象的次要问题HOW。标准库为我们提供了两个标准的std::default_delete&lt;T&gt;的实现，其内容是非常的简单，即直接调用delete和delete []，在这里列出了后者的实现。123456789101112131415template&lt;class _Ty&gt; struct default_delete&lt;_Ty[]&gt;&#123; // 一个默认的构造函数 constexpr default_delete() _NOEXCEPT = default; // 一个默认的复制构造函数 template&lt;class _Uty, class = typename enable_if&lt;is_convertible&lt;_Uty(*)[], _Ty(*)[]&gt;::value, void&gt;::type&gt; default_delete(const default_delete&lt;_Uty[]&gt;&amp;) _NOEXCEPT &#123;&#125; template&lt;class _Uty, class = typename enable_if&lt;is_convertible&lt;_Uty(*)[], _Ty(*)[]&gt;::value, void&gt;::type&gt; void operator()(_Uty *_Ptr) const _NOEXCEPT &#123; static_assert(0 &lt; sizeof (_Uty), "can't delete an incomplete type"); delete[] _Ptr; &#125;&#125;; 循环引用与weak_ptr正确使用shared_ptr与裸指针我们知道智能指针是有传染性的，这意味着我们要避免同时使用raw pointer和智能指针，也要注意不能显式或者隐式地让多个智能指针同时管理同一个raw pointer。我们进一步地探讨这个问题，shared_ptr的主要创建方式有三种： make_shared函数 这个函数是Effective Modern C++所推荐的示例，它会创建一个控制块和一个对象。根据cppreference的介绍，这个函数有5个重载 123456789template&lt;class T, class... Args&gt; shared_ptr&lt;T&gt; make_shared( Args&amp;&amp;... args );// 从C++20开始，这里T是数组U[]template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared(std::size_t N);// 从C++20开始，这里T是数组U[N]template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared();// 从C++20开始，这里T是数组U[]template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared(std::size_t N, const std::remove_extent_t&lt;T&gt;&amp; u);// 从C++20开始，这里T是数组U[N]template&lt;class T&gt; shared_ptr&lt;T&gt; make_shared(const std::remove_extent_t&lt;T&gt;&amp; u); 我们注意一下这里的初始化是小括号初始化而不是C++11新规定的uniform初始化，即花括号初始化，例如下面的语句会创建10个20，如果我们想放两个元素10和20进去就要显式创建一个初始化列表 1234567// 10个20auto upv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(10, 20);// 10, 20// create std::initializer_listauto initList = &#123; 10, 20 &#125;;// create std::vector using std::initializer_list ctorauto spv = std::make_shared&lt;std::vector&lt;int&gt;&gt;(initList); shared_ptr构造函数 这种情况下我们将一个裸指针传给shared_ptr，这时就可能将裸指针泄露出去，从而导致可能的double free问题。因此在Effective Modern C++的条款19中强调best practice是我们写成将new语句写到参数列表里面 1std::shared_ptr&lt;Widget&gt; spw1(new Widget); 特别地，我们也可以从一个unique_ptr构造shard_ptr，这时候我们和上面的裸指针是类似的。 我们不能忽视this也是一个raw pointer，但我们又不能在内部直接定义一个std::shared_ptr&lt;T*&gt;(this)，这毫无疑问会导致循环引用。更严重的是在对象内部传出this是非常常见的，例如bind系列的函数，会使用this作为一个context。为了能够正确使用this，就得让我们的类继承一个enable_shared_from_this&lt;T&gt;，并传入一个shared_from_this()作为this的化身。写起来的代码是类似这样的，书中甚至对这种继承一个以自己为模板参数的父类的方法介绍了一种专门的称呼，叫The Curiously Recurring Template Pattern(CRTP)。12345struct Widget: public std::enable_shared_from_this&lt;Widget&gt;&#123; void process()&#123; processedWidgets.emplace_back(shared_from_this()); &#125;&#125;; 我们下面来探究一下这个类的实现原理。它首先寻找当前对象的控制块，然后创建一个新的std::shared_ptr来引用那个控制块。 使用make函数而不是使用智能指针的构造函数这个来自于Effective Modern C++的条款21。原因之一是make函数是异常安全的，下面的代码可能导致内存泄露1processWidget(std::shared_ptr&lt;Widget&gt;(new Widget), computePriority()); // potential resource leak! 原因是什么呢？我们考虑这个调用的过程可以分为下面三个阶段： 创建new Widget 构造std::shared_ptr&lt;Widget&gt; 计算computePriority() 根据C++标准，这三个的求值顺序是UB的。我们考虑编译器产生1/3/2这样的执行顺序，并且此时computePriority()产生了异常，此时步骤1中new出来的对象就泄露了。此外，对shared_ptr来说，使用make_shared函数还能提高效率。这是由于创建new Widget和控制块分配两次内存，而使用make_shared函数可以一次分配完。我们来看看标准库的实现，在这里我们看到只分配了一个_Ref_count_obj&lt;_Ty&gt;的对象，这个对象实际上继承了我们上面看到的_Ref_count_base的子类，它有一个typename aligned_union&lt;1, _Ty&gt;::type _Storage的字段管理了我们实际的对象。12345678910111213141516template&lt;class _Ty, class... _Types&gt; inlineshared_ptr&lt;_Ty&gt; make_shared(_Types&amp;&amp;... _Args)&#123; // make a shared_ptr _Ref_count_obj&lt;_Ty&gt; *_Rx = new _Ref_count_obj&lt;_Ty&gt;(_STD forward&lt;_Types&gt;(_Args)...); shared_ptr&lt;_Ty&gt; _Ret; _Ret._Resetp0(_Rx-&gt;_Getptr(), _Rx); return (_Ret);&#125;// In _Ref_count_obj's definitiontemplate&lt;class... _Types&gt; _Ref_count_obj(_Types&amp;&amp;... _Args) : _Ref_count_base()&#123; // construct from argument list ::new ((void *)&amp;_Storage) _Ty(_STD forward&lt;_Types&gt;(_Args)...);&#125; 此外从之前的讨论中我们看到make_shared杜绝了我们看到裸指针的一切可能性，因为它在函数内部创建了智能指针所指向类的实例，因此也更安全。 shared_ptr的结构与实现我们以PJ Plauger的STL实现为例来查看这个智能指针的实现 基类_Ptr_basestd::shared_ptr继承了_Ptr_base，里面持有了两个指针，第一个就是实际的裸指针_Ptr，另一个是控制块指针_Rep。所有的控制块包括_Ref_count&lt;T&gt;、_Ref_count_del&lt;T&gt;、_Ref_count_del_alloc&lt;T&gt;、_Ref_count_obj&lt;T&gt;、_Ref_count_obj_alloc&lt;T&gt;，都继承自_Ref_count_base。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// shared_ptr的基类template&lt;class _Ty&gt; class _Ptr_base &#123; // base class for shared_ptr and weak_ptr /* ... */ private: // 这是真实资源的指针 _Ty *_Ptr; // 这是shared_ptr外挂式的控制块 _Ref_count_base *_Rep; // 所有的实例化的_Ptr_base都互为友元 template&lt;class _Ty0&gt; friend class _Ptr_base; &#125;;&#125;;// 所有控制块对象的基类class _Ref_count_base &#123; // common code for reference countingprivate: // 删除裸指针 virtual void _Destroy() _NOEXCEPT = 0; // 删除自己 virtual void _Delete_this() _NOEXCEPT = 0;private: _Atomic_counter_t _Uses; _Atomic_counter_t _Weaks;protected: // 注意在涉及引用计数的部分，都要是原子的，这里默认使用了Windows的互锁函数，详情可参见我的[博文《并发编程重要概念及比较》](/2017/12/28/Concurrency-Programming-Compare/) // _Ref_count_base() &#123; // construct // 在构造时我们初始化引用计数都为**1** _Init_atomic_counter(_Uses, 1); _Init_atomic_counter(_Weaks, 1); &#125;public: // 虚析构函数 virtual ~_Ref_count_base() _NOEXCEPT &#123; // ensure that derived classes can be destroyed properly &#125; bool _Incref_nz() &#123; // increment use count if not zero, return true if successful ... &#125;; // 这里直接进行强转，以便调用互锁函数 #define _MT_INCR(x) _InterlockedIncrement(reinterpret_cast&lt;volatile long *&gt;(&amp;x)) #define _MT_DECR(x) _InterlockedDecrement(reinterpret_cast&lt;volatile long *&gt;(&amp;x)) void _Incref() &#123; // increment use count _MT_INCR(_Uses); &#125; void _Incwref() &#123; // increment weak reference count _MT_INCR(_Weaks); &#125; void _Decref() &#123; // decrement use count if (_MT_DECR(_Uses) == 0) &#123; // destroy managed resource, decrement weak reference count _Destroy(); _Decwref(); &#125; &#125; void _Decwref() &#123; // decrement weak reference count if (_MT_DECR(_Weaks) == 0) _Delete_this(); &#125; ... 初始化过程的实现进一步研究上面列出的构造函数中的实现，我们发现它们引用了下面三个函数之一，分别是适用于构造函数是否指定了Deleter和Allocator的情况。这里我们看到shared_ptr的某些构造函数是会抛出异常的，所以我们会看到书中的best practice建议使用make系函数而不是构造函数进行创建。下面我们首先查看三个_Resetp函数，这些函数用来接管一个裸指针_Px，根据上面的讨论，我们知道这时候控制块肯定是不存在的，因此创建一个全新的控制块，它们实际上对应通过裸指针创建shared_ptr的构造函数。我们稍后会看到一组_Reset函数，它们则处理较为复杂的情况12345678910111213141516171819202122232425262728293031323334353637383940private: template&lt;class _Ux&gt; void _Resetp(_Ux *_Px) &#123; // release, take ownership of _Px _TRY_BEGIN // allocate control block and reset // 注意_Ref_count在创建时两个引用计数都为1了，因为它继承了_Ref_count_base，详见_Ref_count_base相关代码 _Resetp0(_Px, new _Ref_count&lt;_Ux&gt;(_Px)); _CATCH_ALL // allocation failed, delete resource delete _Px; _RERAISE; _CATCH_END &#125; template&lt;class _Ux, class _Dx&gt; void _Resetp(_Ux *_Px, _Dx _Dt) &#123; // release, take ownership of _Px, deleter _Dt _TRY_BEGIN // allocate control block and reset _Resetp0(_Px, new _Ref_count_del&lt;_Ux, _Dx&gt;(_Px, _Dt)); _CATCH_ALL // allocation failed, delete resource _Dt(_Px); _RERAISE; _CATCH_END &#125; template&lt;class _Ux, class _Dx, class _Alloc&gt; void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax) &#123; // release, take ownership of _Px, deleter _Dt, allocator _Ax typedef _Ref_count_del_alloc&lt;_Ux, _Dx, _Alloc&gt; _Refd; typedef _Wrap_alloc&lt;_Alloc&gt; _Alref0; typename _Alref0::template rebind&lt;_Refd&gt;::other _Alref(_Ax); _TRY_BEGIN // allocate control block and reset _Refd *_Pref = _Alref.allocate(1); _Alref.construct(_Pref, _Px, _Dt, _Ax); _Resetp0(_Px, _Pref); _CATCH_ALL // allocation failed, delete resource _Dt(_Px); _RERAISE; _CATCH_END &#125; _Resetp0是所有_Resetp的终点，包含了两个调用，我们将对此进行探讨1234567public: template&lt;class _Ux&gt; void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx) &#123; // release resource and take ownership of _Px this-&gt;_Reset0(_Px, _Rx); _Enable_shared(_Px, _Rx); &#125; this-&gt;_Reset0 _Reset0基类_Ptr_base中有定义，并且派生类std::shared_ptr也没有进行覆盖，它的功能是切换智能指针管理另一个资源。可以看到，如果此时智能指针已经绑定了控制块，那么就调用_Decref自减一次（代码可查看上面_Ptr_base的实现），因为稍后我们的智能指针即将管理新的_Other_rep控制块和_Other_ptr对象指针了。容易看到，在被_Resetp0调用时_Rep是空指针，所以我们直接赋值。 12345678void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)&#123; // release resource and take new resource // 这里的_Rep是_Ptr_base持有的_Ref_count_base * if (_Rep != 0) _Rep-&gt;_Decref(); _Rep = _Other_rep; _Ptr = _Other_ptr;&#125; 既然如此，为什么我们不增加下_Other_rep的调用数目呢？其实是会增加的，只是不在_Other_rep之中。首先根据上面的讨论，当_Other_rep是新被创建的对象时，它的两个引用计数就默认被设为0了。其次，当_Other_rep是由其它智能指针创建的，也就是说我们此时将智能指针是从另一个智能指针创建的时，我们会调用之前提到的_Reset函数，而这个函数在自增对方的控制块_Other_rep后才会调用_Reset0 123456789101112131415161718template&lt;class _Ty2, class = typename enable_if&lt;is_convertible&lt;_Ty2 *, _Ty *&gt;::value, void&gt;::type&gt;shared_ptr(const shared_ptr&lt;_Ty2&gt;&amp; _Other) _NOEXCEPT&#123; // construct shared_ptr object that owns same resource as _Other this-&gt;_Reset(_Other);&#125;template&lt;class _Ty2&gt;void _Reset(const _Ptr_base&lt;_Ty2&gt;&amp; _Other)&#123; // release resource and take ownership of _Other._Ptr _Reset(_Other._Ptr, _Other._Rep);&#125;void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)&#123; // release resource and take _Other_ptr through _Other_rep if (_Other_rep) _Other_rep-&gt;_Incref(); _Reset0(_Other_ptr, _Other_rep);&#125; _Enable_shared 这里的_Enable_shared用来处理继承了enable_shared_from_this&lt;T&gt;的情况，我们将在下面的讨论中详细了解有关这个函数和enable_shared_from_this的实现。 enable_shared_from_this上文讨论了当需要传出this时，我们应当让我们的类继承template&lt;class _Ty&gt; class enable_shared_from_this，现在来查看一下这个类模板的结构。12345678910111213141516171819202122232425262728template&lt;class _Ty&gt; class enable_shared_from_this&#123; // provide member functions that create shared_ptr to thispublic: // 稍后我们将看到，这个_EStype被用来做SFINAE typedef _Ty _EStype; shared_ptr&lt;_Ty&gt; shared_from_this() &#123; return (shared_ptr&lt;_Ty&gt;(_Wptr)); &#125; shared_ptr&lt;const _Ty&gt; shared_from_this() const &#123; return (shared_ptr&lt;const _Ty&gt;(_Wptr)); &#125;protected: constexpr enable_shared_from_this() _NOEXCEPT &#123;&#125; enable_shared_from_this(const enable_shared_from_this&amp;) _NOEXCEPT &#123;&#125; enable_shared_from_this &amp; operator=(const enable_shared_from_this&amp;) _NOEXCEPT &#123; return (*this); &#125; ~enable_shared_from_this() _NOEXCEPT &#123;&#125;private: // 这个函数是个自由函数，它接受三个参数，分别是托管对象的指针、enable_shared_from_this指针和控制块指针。 // 由于托管对象继承了enable_shared_from_this，所以这两个指针其实是一样的，我们将看到在_Enable_shared函数中直接进行了强转 template&lt;class _Ty1, class _Ty2&gt; friend void _Do_enable(_Ty1 *, enable_shared_from_this&lt;_Ty2&gt;*, _Ref_count_base *); weak_ptr&lt;_Ty&gt; _Wptr;&#125;; 下面我们可以继续查看上面提到的_Enable_shared函数，可以看到这里实际上是一个SFINAE，如果我们的类继承了enable_shared_from_this&lt;T&gt;，那么就会执行_Do_enable函数1234567891011template&lt;class _Ty&gt;inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr, typename _Ty::_EStype * = 0)&#123; // reset internal weak pointer if (_Ptr) _Do_enable(_Ptr, (enable_shared_from_this&lt;typename _Ty::_EStype&gt;*)_Ptr, _Refptr); &#125;inline void _Enable_shared(const volatile void *, const volatile void *)&#123; // not derived from enable_shared_from_this; do nothing&#125; 下面我们来查看这个关键的_Do_enable函数12345template&lt;class _Ty1, class _Ty2&gt;inline void _Do_enable(_Ty1 *_Ptr, enable_shared_from_this&lt;_Ty2&gt; *_Es, _Ref_count_base *_Refptr)&#123; _Es-&gt;_Wptr._Resetw(_Ptr, _Refptr);&#125; 别名使用构造函数和owner_before在shared_ptr的定义中，我们能发现一个奇特的构造函数，即别名使用构造函数(aliasing constructor)。此时它管理一个指针，但同时指向另外一个指针。这个用法看似奇怪，但当我们考虑到如果我们将一个智能指针指向另一个智能指针所拥有的对象的某个成员时，事情变得显然了起来。12template&lt;class Y&gt; shared_ptr( const shared_ptr&lt;Y&gt;&amp; r, element_type* ptr ) noexcept; 以下面的代码为例1234567891011121314151617struct Son &#123; // some data that we want to point to&#125;;struct Father &#123; Son son;&#125;;shared_ptr&lt;Father&gt; father = make_shared&lt;Father&gt;(...);shared_ptr&lt;Son&gt; son(father, &amp;father-&gt;son);// 这时候Father对象的引用计数为2，我们不对Son来计算引用计数father.reset();// 这时候Father对象仍然存在，并且引用计数为1// 如果我们对Son对象计算引用计数的话，这个对象就会被销毁了func(son); 此时如果使用operator&lt;比较shared_ptr的大小关系就会发现它们不等，因为指向的对象不同。但此时应当owner_before用来比较两个shared_ptr之间的“大小关系”。1234567std::shared_ptr&lt;Father&gt; father = std::make_shared&lt;Father&gt;(Son());std::shared_ptr&lt;Son&gt; son(father, &amp;father-&gt;son);printf("%d %d\n", father.owner_before(son), son.owner_before(father)); // 0 0std::shared_ptr&lt;Father&gt; father2 = std::make_shared&lt;Father&gt;(Son());std::shared_ptr&lt;Son&gt; son2 = std::make_shared&lt;Son&gt;();printf("%d %d\n", father2.owner_before(son2), son2.owner_before(father2)); // 1 0 unique_ptrunique_ptr实际上相当于一个安全性增强了的auto_ptr。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中常见的work around]]></title>
    <url>%2F2018%2F03%2F10%2FC%2B%2B%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84workaround%2F</url>
    <content type="text"><![CDATA[本篇中记载了C++编程中常使用的Workaround。 限制类型特性在concept前，C++限制类型特性常可以通过static_assert对应traits或直接上SFINAE解决，这里还列出一些特殊的情形。 创建只能在栈上的对象：在对象内重写全局的void * operator new (size_t) 创建只能在堆上的对象：禁用析构函数 在栈上new对象：使用placement new 不借助final关键字创建final对象 实际上就是让我们不能定义出一个派生对象，我们知道将构造函数设为私有之后这个这个类就不能实例化了，不过这个就像化疗一样，虽然派生类不能实例化了，但是自己也不能实例化。 将函数的返回值加入重载决议 注意返回值不是函数签名的一部分（所以函数重载决议也是不包括返回值的），不被推导。如果希望实现将返回值也加入重载决议类似的效果，可以借助于类型转换操作符operator T::U()实现。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[csapp data lab]]></title>
    <url>%2F2018%2F01%2F18%2Fcsapp-data-lab%2F</url>
    <content type="text"><![CDATA[csapp中的lab非常出名，在这篇文章中我主要记载第一部分，也就是data lab的解法。所有lab的源码在我的Github上。在知乎的一篇文章中记录了一些和二进制处理相关的内容，我觉得也是非常好的学习材料 abs使用位运算求绝对值。这里用到一些位运算的基础概念。相反数的求法是~x + 1。符号位的判断方法是x &gt;&gt; 31，如果是负数得到的是0xffffffff（注意是算数右移），如果是正数得到的是0x0。于是可以得到下面的方法12int sgn_bit = x &gt;&gt; 31; int abs_val = (x ^ sgn_bit) - sgn_bit; 这里x ^ y是个有趣的用法，根据异或的性质，当y全为0时，返回x；而当y全为1时，返回~x。所以x ^ sgn_bit会对负数的所有位取反，而不修改正数的任何位。不过有意思的是我这份对拍代码在Dev-C++ 5.5.3、Window10 1709版上会报Trojan:Win32/Fuerboos.C!cl。点此查看图片 logicalShift借助右移可以在右边添加若干0，借助算数左移0x80000000可以在左边添加若干1。12int mask1 = ((1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1;int mask = ~mask1; 在上面的代码中mask1这样写是为了在没有-的情况下实现1 &lt;&lt; (32 - n)，不过这样写是不太靠谱的，在下面的fitsBits中类似的写法会导致n == 32时溢出。 bit count这道题要求仅使用位运算! ~ &amp; ^ | + &lt;&lt; &gt;&gt;和小于0xff的数在40步之内来统计一个int32_t里面的1的数量，这题标准实现就是种群计数。种群计数实际上是按bit的分治法，核心思想是一个$n$位数中1的数量等于高$\frac{n}{2}$位和低$\frac{n}{2}$位的1的数量的和。考虑递归的最下层需要计算一个2位数$x$，即(x &amp; 0b01) + ((x &gt;&gt; 1) &amp; 0b01)，扩展到16个2位数就成了(x &amp; 0x55555555) + ((x&gt;&gt;1) &amp; 0x55555555)，这个结果的每两位上的值表示这两位中1的数量。下面考虑把相邻的两个2位数拼成一个四位数，方法是(x &amp; 0b11) + ((x &gt;&gt; 2) &amp; 0b11)，理解也非常简单，把每个2位数当成四进制数就好。123456789int bitCount(int x)&#123; x = (x &amp; 0x55555555) + ((x&gt;&gt;1) &amp; 0x55555555); x = (x &amp; 0x33333333) + ((x&gt;&gt;2) &amp; 0x33333333); x = (x &amp; 0x0f0f0f0f) + ((x&gt;&gt;4) &amp; 0x0f0f0f0f); x = (x &amp; 0x00ff00ff) + ((x&gt;&gt;8) &amp; 0x00ff00ff); x = (x &amp; 0x0000ffff) + ((x&gt;&gt;16) &amp; 0x0000ffff); return x;&#125; bang这道题当时让我感到困难的地方是怎么将所有的非零值映射到一个数上。后来在网上看到解法是(~x + 1) | x，这样可以确保符号位肯定是1。 fitsBits直观地看，一个$n$位数的前32 - n位要么全是0，要么全是1。所以可以得到下面的代码12345678int mask = (1 &lt;&lt; 31) &gt;&gt; (32 + ~n + 1);if (x &lt; 0)&#123; return (x | ~mask) == 0xffffffff; // return (~x &amp; mask) == 0; // de morgan&#125;else&#123; return (x &amp; mask) == 0;&#125; 下面应用下德摩根律，就可以把这个if结构缩成!((x ^ p) &amp; mask)。 divpwr2这道题一开始的思路是1return (x &lt; 0) ? -((-x) &gt;&gt; n) : x &gt;&gt; n; 但是这样的方法是不对的，考虑当x取0x80000000时，-x就溢出了。正确方法可以借助于前面abs的求法123int mask = x &gt;&gt; 31;int offset = ((1 &lt;&lt; n) - 1) &amp; mask;return (x + offset) &gt;&gt; n; 注意这个offset来自于CSAPP上的公式$\lfloor x / y \rfloor = \lceil x / y + (y - 1) / y \rceil$ isPositive这道题很简单，借此总结一下一些常用的操作。 构造0xffffffff：~0 映射0到0，非0到1：!!x 映射0到0，1到0xffffffff：~(x - 1) isLessOrEqual首先熟记此图然后发现，两数同号时比较除符号位剩下的31位，否则比较符号位。因此可以得到这样的代码123456789101112int isLessOrEqual(int x, int y) &#123; int sgn_x = x &gt;&gt; 31; int sgn_y = y &gt;&gt; 31; int do_cmp = ~(sgn_x ^ sgn_y); // 判断是否同号 int cmp_res = y - 1; int sgn_res = cmp_res &gt;&gt; 31; if(do_cmp)&#123; return sgn_res == 0; &#125;else&#123; return !!sgn_x; &#125;&#125; 可以按照下面的方法去掉if块123// do_cmp is either 0x0 or 0xffffffffreturn do_cmp ? x : y;return (do_cmp &amp; x) | (~do_cmp &amp; y); ilog2 这个就是二分法，在字长小于等于4后，可以直接暴力算。注意最后结果要减1。 float_neg从这里开始的三条是浮点数的题目。本题很简单，特判下NaN即可。注意符号位连上阶码为9位而不是8位，这真的很丑啊。 float_i2f 考虑x的绝对值ux。规格化的浮点数尾数共有24位有效数字，其中整数部分恒为1，但不显式表示出来，小数部分为23位。如果ux的有效数字不够24，那么需要左移使得其最高的1对其到24，如果有效数字超过24就需要右移，这时候发生舍入造成精度损失。阶码E是可以根据ux的有效数字算出来的，与ux需要左移/右移多少没有关系，我们应当参照小数部分的最高位，即$2^{-1}$而不是最低位$2^{-24}$，简单地来理解，由于最高位已经对齐到了整数位的个位，所以要将最高位1后面的部分也移到最高位1的后面，也就是要去掉最高位1前面的前导0。不过我很快遇到一个巨大的困难，对于0x80000001来说计算的值是0xcf000000，等于0x80000000，容易发现这里出现了一个舍入。CSAPP中说明了向偶数舍入的规则，但我不是很懂，这里看了CSDN的一篇文章终于搞明白了。其实这个说的是一个特殊情况。一般当多余数字严格小于或大于最低有效位的一半时，我们按照传统的四舍五入的规则。考虑对下面的数字舍入到小数点后3位，1.0011001 -&gt; 1.010，这里由于1001 &gt; 1000因此进位，同理，1.0010111 -&gt; 1.001就直接抹掉后面四位。当多余数字刚好等于1000时，这里就应当使用向偶数舍入的原则。最后未压缩的代码是这样的 float_twice这个主意分情况讨论，首先NaN/无穷大还是NaN/无穷大。接着是非规格化的情况，如果尾数最高位不为1，直接&lt;&lt;=尾数部分，否则阶码加1切回规格化。对于规格化情况，首先增加阶码，如果阶码满了，就&lt;&lt;=尾数部分，并牺牲精度，容易发现随着移动自然而然能够达到无穷大（尾数为0）的情况，这体现了浮点数设计的巧妙之处。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树]]></title>
    <url>%2F2018%2F01%2F17%2FB-tree%2F</url>
    <content type="text"><![CDATA[B树的设计目的是减少磁盘存取，而不是诸如二叉堆、红黑树一样试图减少比较次数。根据局部性原理，当一个数据被访问时，那么它附近的数据很大概率会马上被访问，因此我们可以一同将其加载。这个原理常常被用在存取速度不同的两个设备间，如寄存器与主存（多级缓存）以及数据库系统中出现的磁盘与内存的情况。B树相对于一般的平衡BST的特点是高度低、出度大、节点大。一个高度低的树能有效减少检索磁盘的次数。一个具有较大的分支因子的树可以减少$k*log(n)$的常数$k$，其中$n$是总关键字数，也能减少磁盘存取。特别地，B树的节点设计不仅要考虑到容纳尽可能多的节点，也要同时考虑到从磁盘加载的便利性。 B树B树具有一个最小度数$t$，表示一个节点的最小出度，我们要求最小出度必须$t \ge 2$，容易发现当$t = 1$时这个B树实际上就退化为二叉树了。B树主要构造如下： 对节点$x$ 每个节点$x$应当具有$x.n$个按照非降序排列的关键字$x.key_i$。对于叶子节点$s$，它们具有相同的层高$h$。对于内部节点$x$，还具有$n + 1$个指向子节点的指针$x.c_i$。B树递归的有序性表现在对于任意一个子树$x.c_i$记录的关键字$k_i$，它满足$k_1 \le x.key_1 \le k_2 \le x.key_2 \le … \le x.key_{x.n} \le k_{x.n+1}$。如下图所示 对关键字个数$x.n$ B树要求每个节点的出度在$[t, 2t]$之间，因此$x.n$的的上下界为$[t - 1, 2 t - 1]$。当一个节点中存在$2 t - 1$个关键字后，这个节点就是满的。 搜索节点B树分裂节点的CPU复杂度是$O(t)$，磁盘复杂度是$O(1)$。向B树插入新关键字是从树根开始的，磁盘复杂度为$O(t log_t n)$]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程重要概念及比较]]></title>
    <url>%2F2017%2F12%2F28%2FConcurrency-Programming-Compare%2F</url>
    <content type="text"><![CDATA[在本篇中比较了各种并发、并行技术。并发(concurrency)强调的是逻辑上的同时发生，在实际上并发程序可能是由一个处理器同时(simultaneously)处理多个任务，因此并发过程中常出现一个线程等待其他资源的情况。此时常伴随着线程的阻塞和调度。并发过程通常可划分为多个级别：Blocking、Obstruction-Free、Lock-Free、Wait-Free，其中后三种统称为Non-blocking的。并行(parallelism)属于并发，并行强调这两个并发事件实际上也是同时发生的，例如在多个处理器上运行的多个任务。【未完待续】 处理器层面的并发这里不详细论述处理器层面的并发相关，例如SMP架构、流水线、分支预测、多级缓存等技术。 流水线CPU流水线的目的是为了提高吞吐量(throughput)，但会增加每条指令的延迟(latency)，这是因为执行一条指令需要经过更多的流水线寄存器。特别地，一个较深的流水线可能带来很大的流水线寄存器延迟，从而制约了吞吐量能提高的上限。根据CSAPP，一条指令在CPU中被执行会经过取指(fetch)、译码(decode)、执行(execute)、访存(memory)、写回(write back)、更新PC（在SEQ+中和取指进行了合并）等阶段。容易想到在某一时钟周期内，每一个阶段都可以独立运行。例如当指令PC在执行阶段时，我们可以对指令PC+1进行译码，这样译码器就不会闲置，这就是流水线化的一个简单思路。CPU流水线中通过暂停(stalling)和转发(forward)/旁路(bypassing)的机制维护了指令级别的并发。 CPU的缓存和缓存一致性x86往往都有高速缓存Cache，而且有多级。高速缓存基于静态RAM(SRAM)技术，区别于主存的动态RAM(DRAM)技术。现代CPU中寄存器与内存之间没有直接的渠道，而必须通过多级的高速缓存才能到内存。高速缓存的作用依然是为了弥补CPU和内存在速度上的差异，高速缓存提高效率的原理是基于时间局部性和空间局部性，也就是说被引用过一次的存储器位置很可能在不远的将来再次被引用，而存储器中的某一个地址被引用过，那么它附近的地址很可能也会被使用。在CSAPP中专门对高速缓存有将近一章的讨论。虽然高速缓存对用户来说是透明的，我们的代码要不直接操作寄存器，要不直接操作内存，但它并不是不存在，如果深究下去会发现如何保障内存和对应CPU缓存的同步是个问题。但是我们不要担心诸如此类的“一个核心写另一个核心脏读”的情况，x86会在一个CPU修改高速缓存行后自动作废其他CPU的高速缓存行，而缓存一致性协议能够解决内存和多核CPU缓存之间的同步性问题。 缓存一致性和volatile既然我们CPU总是能读到内存里面最新的值，那为啥还需要volatile呢？原因有二 CPU不一定会读缓存 这时候要注意区分CPU缓存一致性和volatile之间的关系。例如出于优化的角度，编译器可能把一个在内存的值放到到寄存器里面，以避免访问内存，既然不访问内存那和缓存一致也没啥关系了。但这样就会出现问题，如果某个线程修改了这个值对应的内存，那么寄存器是不知道的，所以这时候volatile强制说不要在寄存器里面读啦，直接从内存里面读，这时候缓存就能发挥应该有的作用了。所以CPU缓存一致性解决的是CPU的Lx缓存和内存之间之间的问题，而不是CPU寄存器和内存之间的问题。 有的缓存一致性也不保证是任意时刻的 经过简单的了解，CPU缓存行的写操作也分为直写(write though)和回写(write back)两种策略。对于直写来说，确实可以做到任意时刻各缓存中的内容等于内存中内容；但回写就不一定是任意时刻了，因为它并不是立即更新缓存，而是值修改本级缓存，而将对应缓存标记为脏段，只有当所有脏段被会邂逅我们才能达到一致性。具体还可以参看缓存一致性。 缓存一致性协议MESI是实现缓存一致性的一个基础协议，MESI分别表示缓存行可能处于的四个状态Modified、Exclusive、Shared、Invalid。其中Intel使用了扩展的MESIF，增加了状态Forward，而AMD使用了MOESI，增加了状态Owned。MESI协议需要正确处理local read(LR)、local write(LW)、remote read(RR)、remote write(RW)四个场景，其中local表示处理器对本地缓存读写，而remote则表示处理器需要对主存读写。一个缓存行Cache0初始状态为I，因为它并不缓存任何数据。当本地处理器向该缓存行请求时，CPU会向其他缓存行询问，如果存在缓存行Cache1拥有该缓存，则将对应缓存行设为S状态，表示目前有多个缓存行缓存有该数据；否则从内存中加载到Cache0，并设为E状态，表示目前只有一个缓存行缓存有该数据。当本地处理器写入时，缓存行状态变为M，此时缓存与主存之间的数据不一致，CPU通知所有对应的其他的缓存行失效，状态变为I。 伪共享伪共享(False Sharing)是在MESI模型下多个线程对同一缓存行竞争写所导致的性能降低。我们考虑这篇博文中的一个场景一个数组int32_t arr[]被同时加载到CPU0和CPU1的L1缓存Cache0和Cache1上。现在两个线程A和B试图分别修改arr[0]和arr[1]。这种情况下是不存在race condition的，但是可能导致伪共享。我们考虑初始情况下Cache0和Cache1都处于S状态，现在CPU0收到线程A的请求，写arr[0]，Cache0状态变为M，而Cache1收到通知后也作废了自己的缓存行。接下来CPU1发起了写操作，根据MESI模型，CPU0会先将arr[0]写回内存，此时Cache0变为I，之后CPU1才能从内存重新读取，Cache1变成E，然后CPU1才能修改arr[1]。 测试缓存大小内核层面的并发中断在现在的多核CPU（特别是SMP架构）背景下，中断的机制和单核有所区别。在x86中使用的是高级可编程中断控制器(APIC)，APIC由本地APIC和IO APIC组成，其中本地APIC与每个处理器核心对应，IO APIC负责采集和转发来自IO设备的中断信号。根据Intel的规定，广义上的中断可分为同步中断和异步中断。同步中断又称异常，实际上是由CPU产生的，因此显然不能被屏蔽，异常分为故障(fault)、陷阱(trap)和终止(abort)，异常对应到中断号的0-15。异步中断又称中断，分为外部非屏蔽中断(NMI)和外部可屏蔽中断(INTR)，分别对应中断号的16-31和32-47。中断处理的原则是快，否则很容易被覆盖。在Intel中将非屏蔽中断也归入异常，所以异常一般为来自外设或CPU中的非法或故障状态。除了一些硬件故障，来自外部IO设备的中断常是可以等待的，所以属于可屏蔽中断，当IF标志为1时，CPU可以不响应可屏蔽中断，而是将它缓存起来，在开中断后会传给CPU。当CPU在响应一个异常时，所有的可屏蔽中断都将被屏蔽，而如果此时再出现一个异常，即产生了double fault故障，一般来说系统就会宕机。 软中断和硬中断在操作系统如Linux中，中断还可以被分为软中断（内部中断）和硬中断，硬中断是来自硬件的中断，它可以是可屏蔽的，也可以是不可屏蔽的，软中断一般是由int指令产生的，由操作系统提供，在Linux中软中断对应于中断号48-255。软中断是不可屏蔽的（不然干嘛调用int呢），但在操作系统中软中断也可能是由一个硬中断产生的，例如一个来自打印机的硬中断可能产生一个软中断给内核中的相关处理程序，这就是所谓的中断推后处理机制。Linux中硬中断是可嵌套的，也就是说它可以被非同种中断打断，Linux禁止来自同种类中断的打断，而是挂起后来的中断，这主要是为了防止重入现象的发生。Linux通过巧妙的办法来防止同种类中断重入。如果不希望中断的嵌套的发生，可以进行关中断操作，因为它屏蔽的可屏蔽硬件中断具有抢占性。在关中断时要注意关中断会导致异步IO、调度等一系列依赖中断的功能失效，所以屏蔽中断后一定要尽快执行完临界区内代码。在Linux内核中是允许在硬中断中出现中断嵌套的。这是指在中断处理函数handle_IRQ_event中开启了中断，但是在这个函数前的一条调用链中都是关中断的，可参考这篇文章。所以说只要非同种中断发生就可以抢占内核是不准确的。研究Linux中的进程状态时，我们可以看到一个TASK_UNINTERRUPTIBLE，即不可中断的睡眠状态，这是指这个进程不响应SIGKILL等外部信号，因此必须是十分短暂的，在ps -aux命令中显示为D。顺带一提另一中不能响应外部信号的僵尸进程Z，僵尸进程的资源已经被全部释放，只留下包括task_struct在内的一点信息用来给父进程提供返回码等信息，如果此时父进程被阻塞而不能回收子进程，那么子进程就会进入僵尸状态。Linux中，软中断是不能嵌套的，但可以被硬中断打断，所以可以认为硬中断具有更高的“优先级”，但Linux中并没有中断优先级的概念（不过也有个中断线程化的东西）。软中断可以在SMP的不同CPU上并行执行，Linux上每一个CPU都拥有一个中断栈。Linux中使用一个softirq_action结构维护软中断123struct softirq_action &#123; void (*action) (struct softirq_action *); /* 软中断的处理函数 */ &#125;; 可以看出，软中断实际上很像一个回调函数。那么软中断和回调函数之间有什么区别呢： 中断能够实现不同优先级代码的跳转 中断的重入性和回调函数不同 中断下半部和软中断Linux的外部中断处理过程可以参考文章。中断延时处理和中断下半部分别是来自Windows和Linux的中断推后处理机制。Linux中完整的中断处理包含上半部和下半部，其中上半部是真正的中断处理程序，它短小精悍，运行时需要关中断。Linux中的中断下半部的实现有三种机制：Orignial Bottom Half机制、Task Queue机制、软中断Softirq机制、tasklet和工作队列，其中前两种已被替代。注意到很多博客提到众多下半部不属于中断上下文，但又有说软中断处理函数属于中断上下文，从而不允许休眠。但注意工作队列由内核线程eventX执行，允许被调度甚至睡眠 调度任务抢占式调度被动式的调度指的是使用一个调度器决定哪一个任务会在下一刻运行，而不是由进程主动放弃处理器。调度器暂时停止一个任务并让另一个任务开始执行的行为就是抢占式(preempt)调度。抢占式调度分为用户抢占和内核抢占两种。以Linux为例，调度器工作在内核态，所以用户抢占并不是在用户态下，而是发生在进程即将从内核态返回用户态时，这对应两种情况，从系统调用返回和从中断处理程序返回。如果不开启内核抢占，那么进程在内核态的运行会直至结束（主动放弃/时间片耗尽/阻塞），这样的假设方便了内核的编写，特别是在单处理器(UP)下。考虑到在内核态中不存在进程上下文的切换，内核并不需要考虑对临界资源的竞争访问问题，而用户程序也可以假设在一次系统调用过程中不需要保护内核临界资源。但需要注意的是中断仍然存在，所以在进入临界区前还需要关中断。通过内核抢占，系统允许高优先级的进程抢占低优先级的进程的内核态，这将能提高系统的实时性能。内核抢占是可以被关闭的，即所谓的关抢占的几种情况： 内核正在处理中断 这时候也就是所谓的中断上半部，中断在操作系统中拥有最高的优先级 中断的bottom half 通常有上文所述的三种方式，当内核执行软中断和tasklet是禁止内核抢占（注意此时可以被硬中断打断） 当进程持有自旋锁读写锁 这实际上是为了保护临界资源，在有关自旋锁的讨论中会详细说明 当内核调度器scheduler正在运行时 内核操作Per-CPU data structures 在SMP架构中，不同的CPU仍然会维护一些私有数据，此时抢占可能造成一个进程被调度到另一个CPU上去，此时Per-CPU变量就会发生改变 关中断 这是一种特殊情况，关中断后抢占机制自然无法实现了 Linux通过内核抢占锁preempt_count来跟踪一个进程的可抢占性，当内核代码具有抢占性时，则调用preempt_schedule_irq进行内核抢占。因此可以总结到内核抢占可能发生在中断处理程序返回到内核空间前、内核代码具有抢占性、内核代码显式调用调度器schedule、内核中的任务被阻塞。 可重入函数考虑单线程模型下的并发，一个典型的模型是signal机制（借助于软中断实现）。一些条件会影响函数的可重入性，例如全局变量的使用，假如说在函数func涉及读写全局变量errno，在运行过程中被signal中断，而中断处理程序也会访问这个errno，那么当继续进行func时就可能读到无效的errno。容易联想到一些和硬件有副作用的函数也是不可重入的，如fprintf、malloc等。异步可重入和线程安全是两个不同的概念，一般来说线程安全的函数不一定是可重入的，如malloc，而反之则可以使用锁机制来避免。所以我们可以体会到Linux提供的signal机制虽然能够实现异步，但是却十分不体面。 内核向外提供的并发设施多进程进程是UNIX设计模型中的一个重要部分，UNIX推崇以多进程+IPC的方式组成应用系统，充分贯彻了KISS的方针。在UNIX产生的年代，这种方式无疑是很健壮的。 进程模型五状态进程模型包括新建、就绪（等待CPU）、阻塞（等待事件）、运行和退出。在五状态模型之外，还有挂起操作。挂起操作指的是将进程交换到外存，这常常是由于内存紧张或者该进程被阻塞的缘故。挂起不同于阻塞或者就绪，被挂起的进程犹如进入一个平行世界，当等待的事件到达时，它能够从挂起阻塞直接切换成挂起就绪。一个挂起的进程必须脱去挂起这层壳之后才能重新进入五状态模型，如一个挂起就绪态进程必须换回到内存切换成就绪态才能被调度。 同步与异步在进程IPC中同步和异步是两种编程模型，描述了IPC中被调用者的行为。在同步模型中一个调用只有在等到结果时才返回，被调用者并不会进行通知。而异步模型中调用会立即返回，而由被调用者选择在结果达到后通过回调函数或者信号等机制进行通知。UNP书中还强调异步过程中用户不需要手动将数据从内核复制到用户（即不需要在被通知后调用read等函数）。需要和同步异步进行区分的是阻塞和非阻塞的概念，这两个描述了调用结果未到达时调用者的状态。阻塞调用会直接睡眠线程。而非阻塞调用不会阻塞线程，这时候线程可以继续执行下面的逻辑，消息到达时线程收到一个异步信号或者回调，或者采用类似协程的方法，这时候适用异步非阻塞模型。当然线程也可以选择在原地自旋进行轮询，这就是同步非阻塞模型。IO多路复用是一种特殊的同步模型，这是因为在poll函数中仍然需要手动将数据从内核复制回来，并且它们在消息到来前必须在一个循环中轮询，而不是立即返回，跳出循环。不过IO多路复用并不属于同步阻塞模型，因为当一个fd在等待结果时，线程可能在处理来自其它fd的返回结果。IO多路复用也不属于同步非阻塞模型，因为事实上线程还是会被阻塞的。以UNIX套接口为例，SS_NBIO和SS_ASYNC标志分别表示非阻塞和异步的选项，其中非阻塞套接口在请求资源不满足时会返回EWOULDBLOCK，而异步套接口则会通过SIGIO信号来通知进程。 多线程从定义上看，进程是资源分配的最小单位，而线程是程序执行的最小单位。线程通常和同一程序下的其他线程共享一套地址空间，其中包含应用程序拥有的程序代码与资源，每个线程自己维护一套运行上下文。 Linux的线程模型对Linux内核来说，线程和进程是不区分的，无论是fork()还是pthread_create()，最后都是调用do_fork()，不过是普通进程和轻量级进程的区别。pthread(POSIX threads)是POSIX下的一套线程模型，它运行在内核外。在Linux平台上，在glibc库源码的nptl目录下可以看到pthread的具体实现。NPTL(Native POSIX Thread Library)是POSIX线程模型的新实现，它的性能和稳定性方面都优于从前用进程模拟线程的的LinuxThreads。fork出的子进程默认会拷贝父进程的一系列资源，包括内存（包括堆栈）、文件（Python的subprocess库中提供了关闭文件的功能）、信号设定、Nice优先级值、工作目录等 协程协程(Coroutine)是具有多个入口点的函数，协程内部可通过yield进行中断，此时处理器可能被调度到执行其他的函数。虽然线程也可以被睡眠，睡眠本身涉及用户态与内核态的上下文切换，开销较大。对于套接字等IO密集型的应用，协程在提高CPU使用率上比线程轻很多。 stackful和stacklessstackless实现不保存调用栈和寄存器等上下文，因此效率比较高。stackful即栈式构造，这时候协程拥有自己的堆栈等上下文。 约束线程间并发行为线程间实现互斥与同步的任务常具有下面两种形式： 多个线程同时访问一个共享资源，需要维护该共享资源的完整性。这就是Race condition问题，将在本节讨论。 一个线程向另一个线程通告自己的结果/等待另一个线程的结果，这将在章节数据共享中讨论。 总的来说，为了实现同步，等待资源的一方可以处于用户态（忙等）或者内核态（睡眠），而获得资源的一方可以选择锁进行同步，或者使用原子操作保证自己访问不被打断。这分别下面的基于锁和原子操作的工具。Linux、Windows和C++11的标准库中都对这些工具提供了不同程度的支持，具体可参考文档。 Race condition当两个线程竞争同一资源时（但竞态条件也会出现在逻辑电路等地方），如果对资源的访问顺序敏感，就称存在竞态条件(race condition)，导致竞态条件发生的代码区称作临界区。 volatile在有关CPU缓存一致性的章节中，我们讨论的volatile、寄存器、主存和CPU缓存之间的关系。这里我们讨论语言（C/C++）层面的volatile的有关特性。C++中的volatile并不以任何形式保证线程安全，它仅用来告知编译器期修饰的变量是易变的，要避免对其进行优化，这里所谓的优化常常是将变量缓存到寄存器中而不是每次都从内存读取。volatile并不蕴含禁止编译器或者处理器进行重排或乱序，我们需要通过编译器屏障或者内存屏障来实现这一点。volatile关键字有时是有用的，例如可以在自旋锁中防止多次循环中始终读取寄存器中的值。但滥用volatile不仅不会提高程序的安全性，而且会导致程序变慢。对于以为可以加“volatile”就可以解决的问题，一般可以使用std::atomic来避免使用内核锁的开销。 内核锁内核锁一般基于内核对象互斥量/信号量，它们通常是阻塞锁，会导致线程进入睡眠。锁的存在通常限制了并发范围，变并行访问为串行访问。在使用锁维护临界资源时应当争取让序列化访问最小化，真实并发最大化。 互斥量在C++中一般不直接使用std::mutex，而使用lock_guard和unique_lock。lock_guard和unique_lock利用了RAII来自动管理加锁解锁操作，它们能够应用到包括互斥量的所有Lockable的对象上。unique_lock相比于lock_guard更灵活，用户能够手动地加/解锁，例如在条件变量中就需要unique_lock以便解锁，而在取得对临界资源后进行处理时也可以暂时解锁。unique_lock还是可移动的，以下面的代码为例，这里1处是一个直接返回lk，编译器可能进行NRVO，当然即使不这么做，2作为一个直接初始化操作，也可以接受get_lock返回的将亡值，从而完成移动构造std::unique_lock&lt;std::mutex&gt;。因此这里锁的控制权从get_lock转移到了process_data。123456789101112std::unique_lock&lt;std::mutex&gt; get_lock()&#123; extern std::mutex some_mutex; std::unique_lock&lt;std::mutex&gt; lk(some_mutex); prepare_data(); return lk; // 1&#125;void process_data()&#123; std::unique_lock&lt;std::mutex&gt; lk(get_lock()); // 2 do_something();&#125; 一般会将mutex和临界资源一起放到一个类中进行管理，此时宜保证该临界资源是非public的，并且不会以引用或者指针的形式传出。这些场景例如成员函数直接返回指针或者引用，友元函数，或者一个接受函数指针P作为参数的函数，且P接受了临界成员的指针或引用，并将其泄露到类外（C++ Concurrency in Action），因此我们还要避免在持有锁时调用用户提供的代码。虽然我们的愿景是希望最大化真实并发，因此要追求较小粒度的锁(small granularity)，一个较小的粒度表现在锁所保护的临界数据较少，并且持有锁的时间较短，但粒度不可能无限小。例如考虑删除双向链表中的一个节点，需要修改三个节点的数据，如果对这三个修改单独加锁，其实等于没有加锁。因此一个直截了当的解决方案是在删除过程中锁住整个链表。如果是仍然希望为每个节点维护一把锁，那么对于删除操作必须获得被删除节点和其相邻的共三把锁，当重新连接节点时，必须在获得当前节点锁的前提下尝试获取下一节点的锁（但一旦持有了下一节点的锁就可以释放当前节点的锁了），以防后继节点产生变化。与此同时，我们还要考虑在遍历的时候需要对要访问的节点上锁，因此遍历时同样需要按照和删除相同的上锁步骤。下面我们考虑一个线程安全的栈，其中实现了empty()、top()、size()、push()、pop()等常见方法。在多线程下，下面的代码中pop()可能使得top()的结果无效，这是因为在1和2两个方法间可能有另一个线程执行了pop()。容易看出无论这些方法内部怎么加锁都无法避免这种情况，因为这里的竞态发生在这些方法之间，C++ Concurrency in Action特别指出这属于接口设计的问题。在后面内存模型的部分，我们能看到类似的问题，原子操作虽然避免了竞态，但原子操作之间可能存在的乱序必须要被考虑。书中还指出了另一个更严重的2和3之间竞争的错误，假设有两个线程并行执行该段代码，我们期望的顺序是top[1] -&gt; pop[1] -&gt; top[2] -&gt; pop[2]，中括号表示执行该方法的线程。然而实际执行顺序可能是top[1] -&gt; top[2] -&gt; pop[1] -&gt; pop[2]。这就导致了从栈顶开始的两个元素有一个被处理了两次，另一个完全没有被处理。一个简单的解决方案是将这两个调用合并成一个带返回值的pop，使用一个mutex来管理，但Tom Cargill指出这处理方式是有问题的。这涉及到为什么标准库在设计时选择将top()和pop()两个方法，原因是可能发生在成功将元素pop后而拷贝函数失败，这个元素就被丢失，所以先取top()再pop()保证了top()失败情况下可以选择不执行pop()。123456stack&lt;int&gt; s;if (! s.empty())&#123; // 1 int const value = s.top(); // 2 s.pop(); // 3 do_something(value);&#125; 死锁使用互斥量的另一个问题是死锁，这时候锁机制避免了竞态，却可能产生线程对锁的竞争，即线程间互相等待对方的锁。死锁的产生满足四个条件：互斥、占有且请求、不可抢占和循环等待。其中等待且请求条件很关键，当完成一个操作需要获得两个及以上的锁时，死锁往往就会发生。为了解决死锁就要想办法破坏它的四个条件之一。从占有且求的角度来解决，我们可以借助于Dijkstra的银行家算法。在C++11中，我们可以使用标准库函数std::lock来同时上锁，不过现实情境下我们往往难以在申请锁时就确定自己需要哪些锁。从破坏循环等待条件的解读来设计的一个解决方案是永远按照一个顺序来获得锁，以哲学家就餐问题为例，我们将筷子进行编号，并约定哲学家们总是先尝试获得编号较低的筷子，用完后总是先释放编号较高的筷子，这样就能避免死锁问题。注意到约定哲学家们总是先拿起左手边的筷子，再拿起右手边的筷子恰恰会导致死锁问题，因为在这里我们并不是对每一个哲学家的操作指定一个相对的规则，而是为所有的资源（锁）的获取直接指定一个绝对的顺序。于是我们发现有时候去确定一个顺序并不是很容易。对于swap函数来说，我们可以按照参数的顺序来加锁，例如先获得第一个参数的锁，再获得第二个参数的锁。可惜这个是相对的，例如考虑如下面代码所示的两个规则，容易发现这两个线程并行执行时死锁就会发生了。1234// thread 1swap(a, b);// thread 2swap(b, a); 为了解决这个问题，一个方法是对每个对象求Hash，从而进行排序，另一种是借助于std::lock函数。这个函数的作用是将多个互斥量同时上锁（失败时则抛出异常并释放已经获得的锁），下面代码展示了一个线程安全的swap。12345678910111213141516171819202122232425class some_big_object;void swap(some_big_object&amp; lhs,some_big_object&amp; rhs);class X&#123;private: some_big_object some_detail; std::mutex m;public: X(some_big_object const&amp; sd):some_detail(sd)&#123;&#125; friend void swap(X&amp; lhs, X&amp; rhs) &#123; if(&amp;lhs==&amp;rhs) return; std::lock(lhs.m, rhs.m); // 1 // std::adopt_lock告知这个lock_guard已获得锁 std::lock_guard&lt;std::mutex&gt; lock_a(lhs.m, std::adopt_lock); // 2 std::lock_guard&lt;std::mutex&gt; lock_b(rhs.m, std::adopt_lock); // 3 swap(lhs.some_detail, rhs.some_detail); &#125;&#125;;// 注意1/2/3也可以换为以下代码 std::unique_lock&lt;std::mutex&gt; lock_a(lhs.m, std::defer_lock); std::unique_lock&lt;std::mutex&gt; lock_b(rhs.m, std::defer_lock); // unique_lock 不对互斥量上锁 std::lock(lock_a, lock_b); // 互斥量在这里上锁 std::lock的实现借助了try_lock即_Try_lock。1234567891011121314151617181920212223242526272829303132333435363738template&lt;class _Lock0, class _Lock1, class... _LockN&gt; inlinevoid lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN)&#123; // lock N mutexes int _Res = 0; while (_Res != -1) _Res = _Try_lock(_Lk0, _Lk1, _LkN...);&#125; template&lt;class _Lock0&gt; inlineint _Try_lock(_Lock0&amp; _Lk0)&#123; // try to lock one mutex if (!_Lk0.try_lock()) return (0); else return (-1);&#125;template&lt;class _Lock0, class _Lock1, class... _LockN&gt; inlineint _Try_lock(_Lock0&amp; _Lk0, _Lock1&amp; _Lk1, _LockN&amp;... _LkN)&#123; // try to lock n-1 mutexes int _Res; // 如果第一个锁_Lk0直接失败，则返回失败0 if (!_Lk0.try_lock()) return (0); try&#123; // 否则递归地尝试获取第二个锁_Lk1，如果失败则解开第一个锁并修改_Res为失败0 if ((_Res = std:: try_lock(_Lk1, _LkN...)) != -1) &#123; // tail lock failed _Lk0.unlock(); ++_Res; &#125; &#125;catch(...)&#123; // 如果出现异常同样解开第一个锁并返回失败0 _Lk0.unlock(); throw; &#125; return (_Res);&#125; 值得注意的是引起死锁的并不一定是锁，而可以扩展到造成互相等待的其他情况，例如一组线程互相join等待对方，相互阻塞，这导致整个程序无法往下运行，或者线程在持有锁时同时等待其他线程。另一种解决死锁的办法从锁的角度，为锁提供层级。一个已持有低层级锁的线程是不能试图获得高层级的锁的，试图违反这一约定的行为将导致抛出异常或终止程序。注意到不能同时持有相同层级上的锁，所以这些互斥量往往形成一条链。一个层次互斥量hierarchical_mutex的实现可以对每个线程使用一个thread_local全局变量进行维护当前线程所持有的锁的层级，默认取UINT_MAX，这样线程可以获得任何层级的互斥量。但即使可以避免死锁也要注意锁的粒度（保护数据规模与持有时间）对性能的影响，一个总的原则是一个锁应当被持有尽可能少的时间，并且在持有过程中只应该去完成必要的工作。特别地，持有一个锁的同时等待另一个锁，即使不造成死锁，也要考虑其性能问题。以判定两个int是否相等为例，在先前我们看到了一个swap函数的实现方案，同时对两个互斥量进行加锁。但这里考虑到实际上int非常小，所以比较好的是分别对两个int加锁，复制副本，并比较两个副本，从而避免同时持有两个锁。注意和前面top()和pop()所遇到的问题一样，在对intA和intB的读操作(LOAD)间可能发生另一个线程对intA的写操作，导致先前读取到的是旧值。 自旋锁自旋锁是一种忙等锁(busy waiting)，它适用于短时间锁定某个资源，这样可以避免内核锁所需要的线程睡眠（两次线程上下文切换）等一系列的开销，但持有过长的自旋锁会导致浪费大量CPU资源。特别是在单核CPU上，自旋锁的使用需要审慎考虑，因为在单核CPU上同一时间只能运行一个线程，这时候如果等待锁的线程先运行，那么它势必进入空等直到时间片用完，因为获得锁的线程势必不能运行以释放锁。因此在单核CPU上使用内核锁进入睡眠是一个好的选择。自旋锁常被用在对称多处理器(SMP)系统中，在多CPU的情况下保护临界区。 自旋锁与中断处理处理中断时不能使用互斥量、信号量等让线程进入睡眠的锁，因此自旋锁常用于内核中有关中断处理的部分。内核锁必须在进程上下文中才能使用，这里的关闭中断的目的是为了关闭调度，因为关闭了时钟中断（时钟中断是可以被关闭的），调度器就无法运转了。这样就产生了睡死的现象。 持有自旋锁时不能进入睡眠自旋锁适用于不能睡眠的场景，但双向地来说，持有自旋锁时也不能进入睡眠，否则会引起死锁。为了理解原因，首先要了解为什么自旋锁常伴随关中断和关抢占。Linux中提供了各个品种的自旋锁操作函数。其中spin_lock系列的关闭了抢占而不关中断，而spin_lock_irqsave、spin_lock_irq、spin_lock_bh会一道把中断也关了。关抢占的原因是如果一个低优先级的线程A获得自旋锁而紧接着被一个高优先级的进程B抢占，那么会造成这两个线程死锁，直到时间片用尽，也就是所谓的优先级反转（优先级倒置）现象，会严重影响性能。关中断的原因是如果一个进程A获得自旋锁然后被一个中断打断，如果这个中断处理器也试图获得同一个自旋锁，那么就会造成在中断内部的死锁（自旋锁不能嵌套上锁，否则会造成自死锁现象），并且中断处理无法被抢占（但可以被其他中断打断）。可以参考文章和知乎。既然使用自旋锁应当关闭中断或者调度，那么原因就很明显了，如果进程A获得了自旋锁并且阻塞在内核态，此时内核调度了进程B（阻塞可导致调度），而B也试图获得自旋锁，那么B将永远自旋，A将永远睡眠，这类似于开中断时在中断内的死锁情况，不过在这种情况下仍有可能B时间片用完从而再次重新调度。此外另一种解释认为对于不关中断的自旋锁在睡眠后可能会被重新调度，从而造成自死锁的现象。这种思想同样值得用在处理异常、信号等会破坏程序执行顺序的地方。 临界区相对于互锁访问函数这种“有限的”原子操作，临界区允许对一段代码进行“原子操作”，临界区相对于互斥量比较轻便，这是由于互斥量能够跨进程，并且支持等待多个内核对象。同时线程在进入一个被占用的临界区时会首先尝试自旋锁，在自旋锁循环一定次数失败后再让线程进入睡眠。 临界资源的初始化我们考虑临界资源的初始化问题，一个重要的情景就是实现单例模式。在C++11后，可以方便地使用局部静态变量（Meyers Singleton满足初始化和定义完全在一个线程中发生，并且发生在所有其他线程访问之前）或者std::call_once（在C++11前我们只能使用Linux系统中的替代品pthread_once）实现线程安全的单例模式。不过首先先看看一个使用锁的朴素的，也是开销巨大的方案。查看下面的代码，我们可以发现这里用一把大锁保证了不会有两个线程竞争创建/访问p_singleton的实例。但同时需要意识到当实例被唯一地创建好后，这个函数就不需要要锁来保护了，因为在这种情况下它简单到可以作为原子操作，然而事与愿违的是每次调用这个函数都需要获得锁。因此我们需要一种仅保护临界资源初始化过程的机制。12345678Singleton * p_singleton = nullptr;Singleton * get_singleton() &#123; std::lock_guard&lt;std::mutex&gt; lock(mtx); if (p_singleton == nullptr) &#123; p_singleton = new Singleton(); &#125; return p_singleton;&#125; 双重检查锁定模式(Double-checked locking pattern, DCLP)指的是在加锁前先进行一次验证是否可以加锁。下面使用双重检查锁定模式来减少加锁的开销，具体的做法是先检查一遍p_singleton是否为nullptr。12345678910Singleton * p_singleton = nullptr;Singleton * get_singleton() &#123; if (p_singleton == nullptr) &#123; // a std::lock_guard&lt;std::mutex&gt; lock(mtx); if (p_singleton == nullptr) &#123; // b p_singleton = new Singleton(); &#125; &#125; return p_singleton;&#125; 但其实这种加锁方式也是有理论上的风险的，例如我们的p_singleton不是原子的，甚至都不是volatile的，基于我们与编译器的约定，编译器完全可以认为p_singleton的值不会发生变化，因此直接将两层if削掉一层。但是即使我们将p_singleton套上std::atomic、加上volatile，这个代码仍然是错误的。原因在于p_singleton = new Singleton()这条语句不是原子的。我们可以把该语句分为三步 分配内存 构造对象 指针指向对象 编译器在理论上（但实践中编译器没有理由去进行这样的重排）会在2构造对象前执行1内存分配和3指针指向操作。假设线程在1/3步骤完毕之后被挂起而来不及执行2步骤，而另一个线程开始访问a处的代码，注意到此时p_singleton已经不是nullptr了，于是函数会返回一个未初始化的内存。继续思考我们发现，这里的问题是由于第一个线程此时已经在初始化p_singleton，这第二个线程就不应该有机会执行到a处的代码，试想即使第二个线程知道初始化再被另一个线程执行，那它也做不了任何事情，因为代码中写了要么初始化并返回指针，要么直接返回指针。选择前者会破坏第一个线程的初始化过程，选择后一个会造成上面说的结果。因此在a处对p_singleton进行保护是非常有必要的。在稍后的章节中，我们将对双重检查锁定模式进行进一步的讨论。 因此实际上使用上面提到的std::call_once是一个更好的解决方案。在下面的代码中，只会输出一行Called once。12345678910111213std::once_flag flag; void do_once() &#123; std::call_once(flag, []()&#123; std::cout &lt;&lt; "Called once" &lt;&lt; std::endl; &#125;); &#125;int main() &#123; std::thread t1(do_once); std::thread t2(do_once); t1.join(); t2.join();&#125; 这里的std::once_flag不能被拷贝和移动，其实相当于一个锁，call_once实现如下1234567891011121314151617181920212223242526272829303132333435363738template&lt;class _Fn, class... _Args&gt; inline void (call_once)(once_flag&amp; _Flag, _Fn&amp;&amp; _Fx, _Args&amp;&amp;... _Ax) &#123; // call _Fx(_Ax...) once // 定义一个_Tuple类型 typedef tuple&lt;_Fn&amp;&amp;, _Args&amp;&amp;..., _XSTD exception_ptr&amp;&gt; _Tuple; // _Seq的值索引上面的_Tuple typedef make_integer_sequence&lt;size_t, 1 + sizeof...(_Args)&gt; _Seq; _XSTD exception_ptr _Exc; // 将回调函数参数打包到_Tuple类型里面，最后一个是exception_ptr _Tuple _Tup(_STD forward&lt;_Fn&gt;(_Fx), _STD forward&lt;_Args&gt;(_Ax)..., _Exc); // 使用_Tup里面的上下文特化_Callback_once函数模板 _Lambda_fp_t _Fp = &amp;_Callback_once&lt;_Tuple, _Seq, 1 + sizeof...(_Args)&gt;; // 在xonce.cpp中实际调用了__crtInitOnceExecuteOnce的WINAPI if (_Execute_once(_Flag, _Fp, _STD addressof(_Tup)) != 0) return; if (_Exc) _XSTD rethrow_exception(_Exc); _XGetLastError(); &#125; // xonce.cpp_STD_BEGIN_CRTIMP2_PURE int __CLRCALL_PURE_OR_CDECL _Execute_once( once_flag&amp; _Flag, _Lambda_fp_t _Lambda_fp, void *_Pv) _NOEXCEPT &#123; // wrap Win32 InitOnceExecuteOnce() static_assert(sizeof(_Flag._Opaque) == sizeof(INIT_ONCE), "invalid size"); return (__crtInitOnceExecuteOnce( reinterpret_cast&lt;PINIT_ONCE&gt;(&amp;_Flag._Opaque), reinterpret_cast&lt;PINIT_ONCE_FN&gt;(_Lambda_fp), _Pv, 0)); &#125; 读写锁相对于临界区，读写锁能提供更精细的控制，它适用于写操作远少于读操作的数据结构。读写锁允许一个写线程独占访问，而多个读线程并行访问。当写线程需要独占访问时，它需要获得一个排它锁，如果此时有另外的线程持有排它锁或者共享锁，那么本线程就会被阻塞。当读线程需要共享访问时，只要没有线程持有排它锁，那么他就可以立即获得共享锁。读写锁的过程可以参照来自博文的论述12345678910111213Read object begin P(object.lock) AtomicAdd(object.activeReader, 1) V(object.lock) Do Actual Read AtomicAdd(object.activeReaders, −1)endWrite object begin P(object.lock) while object.activeReaders != 0 do delay Do Actual Write V(object.lock)end 对读写锁Windows API提供了所谓的SRW系列函数，Linux提供了rwlock系列函数。在C++17中终于提供了std::shared_mutex来实现读写锁，此时我们的读锁可以声明为std::shared_lock&lt;std::shared_mutex&gt;(C++14)，写锁可以声明为std::unique_lock&lt;std::shared_mutex&gt;(C++11)，如此跨越三个版本的标准才能完成的实现，你只有在C++中才能看到。从实现上来看，无论是关键段、互斥量、信号量，甚至是条件变量都可以实现读写锁。 关键段的实现方式 这里摘录了CSDN上的一个实现。其思想如下 互斥量的实现方式 使用互斥量时我们需要注意在进行读操作时我们要获取写锁以免脏读，但可能出现多个读线程竞争写锁的情况，所以我们需要一个读锁。只有竞争到读锁的线程才能去锁定写锁。其过程如下 1234567891011121314151617// 写lock(mutex_write);write();unlock(mutex_write);// 读lock(mutex_read);if(readers == 0) lock(mutex_write);readers++;unlock(mutex_read);read();lock(mutex_read);readers--;if(readers == 0) unlock(mutex_write);unlock(mutex_read); 信号量的实现方式 这里的Swait(sem, t, d)表示信号量sem的P操作需要t个资源，并且会消耗d个资源，Ssignal(sem, d)表示信号量sem的V操作产生d个资源。这里Swait类似std::lock，可以同时对若干个信号量上锁，从而避免死锁。 1234567891011121314// 初始化max_reader = n; // 最多允许n个读者读Sinit(sem_read, max_reader);Sinit(sem_write, 1);// 写Swait(sem_write, 1, 1; sem_read, max_reader, 0);write();Ssignal(sem_write, 1);// 读Swait(sem_write, 1, 0; sem_read, 1, 1);write();Ssignal(sem_read, 1); 条件变量的实现方式 不变量与恶性条件竞争不变量(invariant)是某个特定数据结构始终保持的特性。例如通过链表的前向指针始终能到达前驱结点。不变量对应的特性常常在更新过程中被破坏，特别是当更新涉及到修改多个值，或者需要多个过程时。这就类似于在最终一致性系统的窗口内强一致性被破坏。当不变量遭到破坏时，才会产生竞态条件（C++ Concurrency in Action: Ch3）。为了解决竞态条件，一种方法是确保只有当前进行修改的线程才能看到不变量被修改的中间状态，也就是将临界资源保护起来，前面看到的互斥量等属于这种机制。另一种方法是借助于锁无关编程技术，这种技术将对数据结构的修改分解为若干个不破坏不变量的原子操作。还有一种办法是借助于事务的STM技术，将所需要的操作存储于日志中，再合并提交。 锁无关锁无关(Lock-Free)是一种比无干扰(Obstruction-Free)高层次的并发模型，它是一个容易混淆的概念。锁无关与其他模型的本质区别并不是不用锁(Lockless)，而是确保各个线程在访问共享资源时之间不会互相阻塞，从而使得整个程序整体上能够始终向后执行。相对应地，如果使用内核锁，如果一个获得内核锁的线程被挂起或者挂掉，这容易导致其他拥有锁的线程陷入永久等待。但即使借助于原子操作，也会产生死锁、竞态的问题，例如自旋锁的死锁问题和使用CAS时可能出现的ABA问题。加锁操作通常存在着一些问题，锁无关的编程虽然复杂，但相对于使用锁，锁无关的可伸缩性和性能方面会强于锁相关的算法，并且如果我们能够有序地组织各个线程“各行其道”，就能减少锁的使用。通常来说一个基于锁的算法在高竞争的系统中有较好的效率，因为当发生竞态时线程进行睡眠而不是立即重试，但在一般的情境中，不使用锁往往能避免上下文切换的开销。相应的还有一个无阻塞(Non-blocking)的概念，无阻塞的限制条件要弱于锁无关。属于无阻塞算法而不属于无锁算法的常见例子包括自旋锁。在自旋锁中，所有的线程都不会进入睡眠，因此是非阻塞算法；而考虑当获得锁的线程因为一些原因被暂停时，所有的其他线程仍然需要在原地自旋忙等，因而自旋锁不是无锁算法。 原子操作原子操作是常见的实现锁无关编程的方式，常见的原子操作有CAS、FAA、TAS、TTAS等。原子操作指的是不可被中断的一系列操作，在原子操作保证当前操作中不发生线程切换，因此保证了其他的线程不可能访问这个资源。原子操作一般有两种实现方式，第一个是使用锁或者CPU的特殊指令等机制来维持原子性，第二个是当出现并发写等破坏原子性的情况时让操作失败，因此对于第二种情况需要使用一个循环不断尝试。这里需要注意的是，原子操作并不一定就能够提高效率，也就是所谓的scalability，这是由于涉及对共享对象操作的原子指令都可能造成cache invalidation，也就是需要重新刷新缓存行。另外，原子操作本身也是很慢的，如下图所示我们知道x86汇编要求对任意位置的1字节，以及对2/4/8对齐的2/4/8长度的整型读取都是原子的，但是C++11前我们却不能假设甚至是对一个int赋值的操作是原子的，而在C++11后我们需要使用std::atomic来显式声明一个原子的变量。这一方面是由于C++无法保证通过一条指令从内存的存取（考虑一些违反strict aliasing的胡乱cast破坏了对齐）。另一方面也是C++11前根本没有考虑对多线程提供语言级别的支持（这点Java就做得比较好），C++标准规定data race，即并发地去修改一个对象是UB的，所以编译器可以不考虑多线程的情况而进行优化，产生错误。因此通常的方式是直接使用操作系统提供的API，一般来说如果能够有一个原子的CAS，那么就能够借助它实现其他的原子操作。为了展示问题的复杂性，下面展示了一个早期GCC编译器的问题1234567891011121314151617extern int v;void f(int set_v)&#123; if (set_v) v = 1;&#125;// GCC 3.3.4--4.3.0 O1f: pushl %ebp movl %esp, %ebp cmpl $0, 8(%ebp) movl $1, %eax cmove v, %eax ; load (maybe) movl %eax, v ; store (always) popl %ebp ret 在这个问题中考虑调用f(0)，理想情况下v的值无论如何都不会变动的，但是在gcc生成的代码中，我们看到一个始终执行的存储movl %eax, v。显然编译器认为f并不会被修改，而且这对仅面向单线程优化的编译器是完全有理由说得通的。但如果在load和store之间发生了切换，并导致竞态。除了上面的例子，一些常见的优化，例如循环展开都会造成严重后果。 互锁访问函数和CAS操作操作系统提供的原子API常借助于某些CPU（比如Intel处理器）提供的指令，能够对某些类型实现某些原子操作。注意到对SMP架构而言，会出现多个核心并发写的情况，这个涉及到后面的内存模型，并且在这里我们可以暂时忽略这个问题。Windows API提供了一系列Interlocked开头的互锁访问函数，这些函数在处理器层面被保证独占访问。其中一个很关键的便是InterlockedCompareExchange(PLONG dest, LONG value, LONG old)函数，这个函数提供了对LONG类型的原子的CAS操作。InterlockedCompareExchange将*dest和old进行比较，如果相等就将*dest设为value。显然，通过内核锁能够方便地实现原子语义，但原子操作通常会借助于这样的CAS操作，因为这样能避免线程进入睡眠。借助于CAS可以实现其他的原子操作，例如下面的对LONG进行原子赋值的InterlockedExchange函数。在C++11的std::atomic类型中，我们会看到更多的CAS的应用。1234567LONG InterlockedExchange(LONG volatile * target, LONG value)&#123; LONG old; do&#123; old = *target; &#125;while(! InterlockedCompareExchange(target, value, old)); return old;&#125; 这里的do-while循环保证了在InterlockedCompareExchange失败之后再来一遍能够再来一遍直到成功，但是不能将这个循环和自旋锁中的忙等混淆，从而认为CAS不是锁无关的。这是因为CAS实际上并没有“持有”临界资源，它只需要一个指令就能结束战斗。因此任意一个线程的暂停并不会使得其他线程进入忙等，甚至能够使得CAS的成功率更高。因此可以看出CAS在这里对竞争访问实际上是“消极防御”的态度，也就是所谓的乐观锁(Optimistic Locking)，乐观锁是一种非独占锁，它并不是向内核锁一样直接让竞争者们睡眠，而是返回一个失败的状态。相对应的，之前的内核锁和自旋锁等机制属于悲观锁、独占锁。相比乐观锁，悲观锁有以下的弱点（也可以理解为基于锁算法的弱点） 上下文切换造成的性能开销 可能造成的死锁问题 优先级倒置 使用CAS操作实现的并发缓冲队列常见的用CAS实现的Lockfree算法例如缓冲队列。首先对于一读一写的模型我们可以仅通过约束读指针和写指针的行为即可实现，并不需要接触并发模型。下面我们考虑多对多的模型，以论文Implementing Lock-Free Queues中的论述为例。123456789101112131415161718192021Enqueue(x) &#123; q = new record(); q-&gt;value = x; q-&gt;next = NULL; do &#123; p = tail; // 使用tail维护链表尾指针的位置 &#125; while( CAS(p-&gt;next, NULL, q) != true); // 1 CAS(tail, p, q); // 2&#125;DeQueue() &#123; do&#123; p = head; if (p-&gt;next == NULL)&#123; return ERR_EMPTY_QUEUE; &#125; &#125; while( CAS(head, p, p-&gt;next) != TRUE ); return p-&gt;next-&gt;value;&#125; 这里有一个疑问，就是为什么2这句不使用循环保护起来，这是因为这个语句是始终能够成功的。我们考虑成功进行了1处CAS的线程T1，它使得tail-&gt;next不为NULL了，假如此时另一个线程T2执行到1，那么它的CAS一定是失败的。这个过程一直到语句2之后tail被成功更新成q，因此实际上可以把tail-&gt;next看成一个锁一样的东西。既然如此，我们容易发现一个违背锁无关性质的可能性，也就是当线程T1在执行语句2时挂掉了，那就会阻塞所有其他在循环中的线程。因此我们提出下面的改良版123456789101112131415EnQueue(x)&#123; q = new record(); q-&gt;value = x; q-&gt;next = NULL; p = tail; oldp = tail; do &#123; while (p-&gt;next != NULL) p = p-&gt;next; &#125; while( CAS(p-&gt;next, NULL, q) != TRUE); // 1 CAS(tail, oldp, q); // 2&#125; 考虑到可能来自其他线程的未提交（指未执行语句2）的添加，我们发现语句p = tail中的tail并不一定是结尾，这也导致了为了维护离开循环时p必须指向结尾这个特性，线程需要在循环内自旋，从而导致上述的死锁现象的产生。为了解决问题，在这一版本中我们索性放宽假设，认为tail只是“接近”结尾，因此现在我们需要使用一个内层的while循环来从tail开始尝试更新结尾。这样即使T1线程挂在语句2，没能更新完tail指针，线程T2也可以自动跟踪到T1在1处的修改。此时我们也不要担心语句2的失败问题，因为有的时候它应该失败。考虑下面的执行顺序：原先链表中只有一个元素1，此时线程T1添加了一个元素2，并且成功执行语句1，将p指向了元素2的位置。此时发生了调度，线程T2获得处理器，它需要在队列中加一个元素3，T2在刚进入循环时它发现自己的tail是指向1的，但它在内层的while循环中根据p的next指针走到了刚被T1添加进去的元素2处。因此T2在元素2的末尾增加了元素3，并且更新自己的p指向元素3。T2继续执行语句2，此时tail == oldp指向元素1，所以CAS成功，tail指向了元素3。接着T1重新获得了处理器，此时tail已经被T2修改到指向元素3了，于是不能匹配oldp，这个CAS就会失败。容易看到这个失败不会影响tail指向精确的队列结尾。但是如果我们稍稍修改下上面的运行顺序，按照T1添加元素2 =&gt; T2添加元素3 =&gt; T1修改tail =&gt; T2修改tail(失败)来执行，那么我们就会发现tail被更新到指向元素2而不是元素3。所以我们看到先前我们放宽的假设是非常有必要的，在论文中作者指出这种情况下tail指针距离列表的准确结束位置最多相差2 * p - 1个节点。其实这个“最多”还是有点多的，所以在实践中我们常常结合两种方案来使用。 CPU提供的原子操作如果细究上面WINAPI的InterlockedCompareExchange，容易猜到它的实现方式来自于CPU的硬件支持，因为它只能为特定数据类型提供服务。事实上，这里用了x86中的cmpxchg命令。CPU原子操作的实现借助于总线锁、缓存锁等机制。 C++的原子操作库在上面的章节中，我们概览了锁无关编程的一些思想。从现在开始，我们将讨论C++11标准库提供的原子操作支持。 std::atomic_flagstd::atomic_flag是C++11原子库的一个基础设施，它被广泛地运用到下面的std::atomic类模板的实现中。std::atomic_flag基于TAS(test-and-set)操作维护了一个布尔量flag，提供了test_and_set和clear两个方法，可以保证对flag的写不会冲突，读不会脏读。test_and_set尝试将flag从false设为true，如果发现flag已被设置，否则原子地设置flag为true，该函数返回的是flag先前的值。由于std::atomic_flag原子地维护了一个flag，它常被用来实现自旋锁。下面的代码来自MSVC的atomic库，它在std::atomic的_Atomic_copy方法中被调用。123456789101112inline void _Lock_spin_lock( volatile _Atomic_flag_t *_Flag) &#123; while (_ATOMIC_FLAG_TEST_AND_SET(_Flag, memory_order_acquire)) _YIELD_PROCESSOR; &#125;inline void _Unlock_spin_lock( volatile _Atomic_flag_t *_Flag) &#123; _ATOMIC_FLAG_CLEAR(_Flag, memory_order_release); &#125; 此外，容易发现TAS操作也可以通过CAS实现，其代码很简单1return InterlockedCompareExchange(&amp;flag, true, false); 在MSVC的标准库实现中test_and_set借助了Interlock互锁访问函数，保证了访问的原子性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 #if defined(_M_ARM) || defined(_M_ARM64) #define _INTRIN_RELAXED(x) _CONCAT(x, _nf) #define _INTRIN_ACQUIRE(x) _CONCAT(x, _acq) #define _INTRIN_RELEASE(x) _CONCAT(x, _rel) #define _INTRIN_SEQ_CST(x) x #else /* defined(_M_ARM) || defined(_M_ARM64) */ #define _INTRIN_RELAXED(x) x #define _INTRIN_ACQUIRE(x) x #define _INTRIN_RELEASE(x) x #define _INTRIN_SEQ_CST(x) x #endif /* defined(_M_ARM) || defined(_M_ARM64) */inline int _Atomic_flag_test_and_set(volatile _Atomic_flag_t *_Flag, memory_order _Order) &#123; /* atomically test flag and set to true */ switch (_Order) &#123; case memory_order_relaxed: return (_INTRIN_RELAXED(_interlockedbittestandset)(_Flag, 0)); case memory_order_consume: case memory_order_acquire: return (_INTRIN_ACQUIRE(_interlockedbittestandset)(_Flag, 0)); case memory_order_release: return (_INTRIN_RELEASE(_interlockedbittestandset)(_Flag, 0)); case memory_order_acq_rel: case memory_order_seq_cst: return (_INTRIN_SEQ_CST(_interlockedbittestandset)(_Flag, 0)); default: _INVALID_MEMORY_ORDER; return (0); &#125; &#125;inline void _Atomic_flag_clear(volatile _Atomic_flag_t *_Flag, memory_order _Order) &#123; /* atomically clear flag */ static_assert(sizeof(_Atomic_flag_t) == sizeof(_Uint4_t), "Unexpected _Atomic_flag_t size"); switch (_Order) &#123; case memory_order_relaxed: case memory_order_release: case memory_order_seq_cst: _Atomic_store_4((volatile _Uint4_t *)_Flag, 0, _Order); break; default: _INVALID_MEMORY_ORDER; break; &#125; &#125; std::atomic在前面的讨论中我们已经明白C++中的基本类型并不保证是原子的，所以std::atomic&lt;T&gt;定义了一系列具有原子行为的类型。std::atomic禁用了复制构造函数和复制赋值运算符（同时也不允许移动）。这是由于这两个操作发生在两个对象间，势必要破坏原子性，而一个std::atomic的所有操作都是原子的。对于用户自定义类型(UDT)typename T，std::atomic的主模板要求T满足standard layout、trivial default constructor和trivial destructor，即编译器可以使用memcpy等进行bitwise的复制并使用memcmp进行bitwise的比较。在CAS操作的实现中调用了memcpy和memcmp。这看起来限制很大，我们希望有用户自定义的复制构造函数，这样我们就可以进行member-wise的操作了，对此想法，C++ Concurrency in Action一书中指出，如果有自定义的复制构造函数，那么就势必要将锁定区域（下文中会交待其实std::atomic的主模板实现中可能会有自旋锁）内的数据交给这些用户代码，如果在用户代码中再使用了锁，就可能产生死锁的现象。容易发现我们常用的智能指针std::shared_ptr并不能被放到std::atomic里面，但是我们又确实有这个需要，因此标准库通过重载std::atomic_系列函数为std::shared_ptr提供了原子操作的支持。而对于std::atomic类型，我们既可以通过std::atomic_系列函数，也可以通过std::atomic模板中提供了compare_exchange_weak、compare_exchange_strong、load、store等操作。一般标准库会对一些大小满足能够直接使用某些处理器的原子指令的类型进行特化，例如指针类型、integral类型和一些用户定义类型。对于指针类型，std::atomic会进行偏特化。原子的指针运算可以通过fetch_开头的函数和相应的operator运算符来实现。对integeral类型std::atomic类模板也会进行特化，其实现类似指针类型，并且添加了对位运算的支持。对于“复杂”的整型计算如乘法，虽然atomic未提供，但可以通过compare_exchange_weak等函数间接实现。从C++20开始，std::atomic类模板提供对浮点类型的特化。注意在这之前，compare_exchange_strong等CAS方法对浮点数可能出现问题，原因显而易见是memcmp的锅，C++浮点数之间比较时甚至都不能使用==，遑论memcmp。在上文中提到，除了std::atomic_flag，std::atomic&lt;typename T&gt;类模板都是不保证不使用锁的（情况特定于处理器和标准库实现），用户可通过bool is_lock_free()函数判断是否Lockfree的。以PJ Plauger的实现为例，主模板的load()内部就使用了上文提到的用std::atomic_flag实现的自旋锁。1234567inline void _Atomic_copy(volatile _Atomic_flag_t *_Flag, size_t _Size, volatile void *_Tgt, volatile const void *_Src, memory_order _Order)&#123; _Lock_spin_lock(_Flag); _CSTD memcpy((void *)_Tgt, (void *)_Src, _Size); _Unlock_spin_lock(_Flag);&#125; 这里要提一句，主模板的template&lt;class _Ty&gt; struct atomic的实现继承了_Atomic_base&lt;_Ty, sizeof (_Ty)&gt;。这个_Atomic_base&lt;_Ty, sizeof (_Ty)&gt;模板又继承了_Atomic_impl&lt;_Bytes&gt;模板，其作用相当于把_Atomic_impl&lt;_Bytes&gt;中全void *的东西封装回了_Ty。我们查看最核心的_Atomic_impl&lt;_Bytes&gt;模板，它是和数据字节数相关的，分别对1/2/4/8字节的进行了偏特化。模板里面定义了最重要的_Is_lock_free、_Store、_Load、_Exchange、_Compare_exchange_weak、_Compare_exchange_strong等操作，全部是void*的。我们刚才看到的_Atomic_copy来自于主模板。我们下面看看_Atomic_impl&lt;_Bytes&gt;的偏特化版本，如对于一个uint2_t是如何实现的1234567891011121314151617181920212223242526272829303132333435363738394041424344 #define _Compiler_barrier() _ReadWriteBarrier() #if defined(_M_ARM) #define _Memory_barrier() __dmb(_ARM_BARRIER_ISH) #endif /* defined(_M_ARM) */ #if defined(_M_ARM64) #define _Memory_barrier() __dmb(_ARM64_BARRIER_ISH) #endif /* defined(_M_ARM64) * /* _Atomic_load_2 */inline _Uint2_t _Load_seq_cst_2(volatile _Uint2_t *_Tgt) &#123; _Uint2_t _Value; #if defined(_M_ARM) || defined(_M_ARM64) _Value = __iso_volatile_load16((volatile short *)_Tgt); _Memory_barrier(); #else _Value = *_Tgt; _Compiler_barrier(); #endif return (_Value); &#125;inline _Uint2_t _Load_relaxed_2(volatile _Uint2_t *_Tgt) &#123; _Uint2_t _Value; #if defined(_M_ARM) || defined(_M_ARM64) _Value = __iso_volatile_load16((volatile short *)_Tgt); #else _Value = *_Tgt; #endif return (_Value); &#125;inline _Uint2_t _Load_acquire_2(volatile _Uint2_t *_Tgt) &#123; return (_Load_seq_cst_2(_Tgt)); &#125; 可以发现在这个偏特化版本的实现中直接借助了处理器提供的设施，而避免了自旋锁的使用。 weak和strong版本的CAS类似与Windows API的互锁访问函数，atomic库通过bool atomic::compare_exchange_weak(old, value)和bool atomic::compare_exchange_strong(old, value)提供了对CAS操作的支持。这两个函数监测该std::atomic中维护的std::atomic_flag _My_flag（在_Atomic_impl模板中定义）的值，如果等于old就改为value，函数返回一个表示修改是否成功的bool量。因此容易发现这两个函数不总是成功的，因为CPU可能仅对某些类型提供了相应的CAS原子指令，对于其他的类型则必须通过使用自旋锁甚至内核锁来实现。12345678910111213inline int _Atomic_compare_exchange_weak(volatile _Atomic_flag_t *_Flag, size_t _Size, volatile void *_Tgt, volatile void *_Exp, const volatile void *_Src, memory_order _Order1, memory_order _Order2)&#123; /* atomically compare and exchange with memory ordering */ int _Result; _Lock_spin_lock(_Flag); _Result = _CSTD memcmp((const void *)_Tgt, (const void *)_Exp, _Size) == 0; if (_Result != 0) _CSTD memcpy((void *)_Tgt, (void *)_Src, _Size); else _CSTD memcpy((void *)_Exp, (void *)_Tgt, _Size); _Unlock_spin_lock(_Flag); return (_Result);&#125; 这两个函数有一些细致的区别，compare_exchange_weak在可能会False Negative，这是由于weak允许spurious failure。在某些平台（不错ARM、PowerPC又被点名了）上的CAS是通过LL/SC实现的，而不像x86上那样只通过一条指令，所以可能存在问题。因此使用compare_exchange_weak的时候需要一个循环。注意到这个!expected不是必要的。123bool expected=false;extern atomic&lt;bool&gt; b; // set somewhere elsewhile(!b.compare_exchange_weak(expected,true) &amp;&amp; !expected); 在Stackoverflow上相关问题的整理中提到了这两者之间的性能比较，由于weak会忽视检查，所以一般weak比strong快。但是如果使用strong能避免weak+loop，那么选择strong是适合的。注意到即使使用strong，loop也不是就一定可以避免的，因为原子操作本来就存在使用乐观锁的情况。 ABA问题伴随着CAS的是可能存在的ABA问题。ABA问题的根源是从内存中取出值和CAS这两个操作不是原子的，因此可能在这两个过程中发生切换。 原子操作与锁的关系在上面的讨论中，我们能够直观地发现原子操作和锁的关系。原子操作看起来是“独善其身”的只能管住自己，原子操作之间、原子操作和非原子操作之间可能发生乱序或重排；而锁像大哥，能护住一段代码。由此我们思考如何通过原子操作来组织其他的那些非原子操作呢？这就要引入下面讨论的内存模型的问题。 其他的同步原语在上面的几个章节中，我们论述了基于锁和基于原子操作的同步原语。还有一些其他的同步原语，例如RCU、MCS Lock等。在Linux中使用了 Hazard PointerHazard Pointer类似于面向多线程的智能指针，它能够无等待地进行线程安全的垃圾回收。 RCURCU(Read Copy Update)是一种替代读写锁的方法，在Linux内核中被广泛使用。其思想是 对于写操作 从数据结构中移除对应的指针，因此后面的读者将不能成功读取 等待前面的读者完成读取 通过内存模型约束线程对变量的读写顺序锁无关编程的难点之一就是需要从编译器与CPU两个层面考虑行为对线程间的同步造成的的影响，也就是考虑编译器重排和CPU缓存与乱序对读写逻辑可能造成的影响。当我们试图使用原子操作去解决非原子操作间的竞态问题时，那么我们需要谨慎选择使用恰当的内存模型，这样能够在提升效率的同时保证安全性。 原子操作的线程间顺序我们知道从C++语言到运行程序得到结果之间需要经历编译器优化和处理器优化两道坎，处理器优化包括高速缓存和指令乱序，编译器优化可能进行重排。编译器和处理器达成的协议是不能改变单线程程序的行为。以编译器优化为例，下面展示的代码在O0下，g++7按照1-2的原始顺序来编译，但开启O1后，g++7就会进行Store-Store重排，将2提到1前面，先对b赋值，再对a赋值；并且还去除了一部分没用的代码。对单线程来说，这样的优化并没有任何问题。但对于多线程来说则可能出现问题。一方面，由于去除部分代码的原因，汇编O1事实上不能在a处观察到a == 1 &amp;&amp; b == 1的情况，而假设O0汇编在进行到b处被抢占，那么其他的线程有机会看到以上的情况。另一方面，在O1中先对b赋值再对a赋值，仍然会出现问题。假如说在3和4间线程被强占，那么另外一个线程观察a和b，得到b为123，而a为不确定值（或者1，如果前面赋初值语句没有被删去的话），而如果编译器不进行重排，我们理想中的原始结果是a为43，b为不确定值。12345678910111213141516171819202122int main()&#123; int a = 1, b = 1; // 0 // a a = b + 42; // 1 // c b = 123; // 2 printf("%d %d", a, b); return 0;&#125;// compile with -O0 movl $1, -8(%rbp) movl $1, -4(%rbp) // b movl -4(%rbp), %eax addl $42, %eax movl %eax, -8(%rbp) movl $123, -4(%rbp) movl -4(%rbp), %edx movl -8(%rbp), %eax// compile with -O1 movl $123, %ecx // 3 movl $43, %edx // 4 出于性能方面的考虑，对多线程的程序而言并不存在和单线程一样的硬性要求。在使用原子操作等锁无关技术时，不能假设所有环境下程序最后行为一如我们希望代码所“暗示”一样。事实上编译器或处理器可以在不同线程间对不同变量间进行读写乱序，而这在多线程中会造成问题。例如在单线程中将对B的写提到对A的读前面是没有问题的，但是对多线程来说，这往往就会出现问题。虽然大部分时候我们不需要操心这个问题，这是因为一方面在使用mutex等内核锁时，内核帮我们做了相关工作，另一方面部分处理器（如x86）也提供了（近似，实际上是TSO）acquire/release的保障，并也可以通过一些指令命令编译器在某些地方减少优化，但这依然是一个客观存在的问题。 可见性和有序性可见性指一个线程对变量的写操作对其它线程后续的读操作可见，这里见的是结果。可见性要求CPU在对缓存行写操作后能够保证至少在某个时间点前必须写回内存，从而保证其他线程能读到最新的值。有序性指的是数据不相关变量在并发的情况下，实际执行的结果和单线程的执行结果和单线程的执行结果是一样的，不会因为重排/乱序的问题导致结果不可预知。 根据以上的定义，我们引入下面的两个概念：如果操作A先行发生(happen-before)于操作B，那么A造成的修改能够被B观察到。我们以知乎上举出的一个例子来理解，根据上面有关原子操作的线程间顺序的讨论，我们知道下面的代码在单线程条件下断言是始终成立的，即使语句1和2之间发生了重排。容易看出happen-before强调的是一个现象，C++保证在单线程中happen-before现象是始终成立的，不管后面编译器和CPU如何进行重排。123456int a, b;void foo() &#123; a = 42; // 1 b = a; // 2 assert(b == 42);&#125; 如果A同步发生(synchronizes-with)于B，那么某个线程中A的修改能够被另一个线程中的B观察到。它实际上是建立一种方法，使得一个时间点前内存的变化能够被其他线程看到。我们引用同样的来源的一个例子，由于重排的问题，在下面的代码中语句4的断言不一定成立（我们不考虑x86 CPU的TSO模型）。这就说明在Relax等无约束或者少约束的内存模型下，在多线程中试图通过某原子量来同步非原子量并不是可靠的。1234567891011121314int data;std::atomic_bool flag &#123; false &#125;;// Execute in thread Avoid producer() &#123; data = 42; // (1) flag.store(true, memory_order_relaxed); // (2)&#125;// Execute in thread Bvoid consume() &#123; while (!flag.load(memory_order_relaxed)); // (3) assert(data == 42); // (4)&#125; 内存一致性模型广义上的一致性模型包括Strict Consistency、Sequential Consistency、Causal Consistency、Processor Consistency、FIFO consistency、Cache Consistency、Slow Consistency、Release consistency、Entry Consistency、General Consistency、Local Consistency等。在std::atomic中提供了六种内存模型(memory order)来描述不同线程之间相同/不同数据的读写的顺序。顺序一致性(sequential consistency, SC)是最强的模型，要求程序中的行为从任意角度来看，序列顺序都是一致的(have single total order)；这是在说这段多线程程序的行为和一段单线程程序的行为是一致的，类似于不是并行的并发。这个模型禁止了任何四种类型的读写重排，因此我们可以认为SC下每次读到的都是最新值。在C++ Concurrency in Action中举了一个例子，使用四个线程运行下面四个函数，断言无论如何z永远不可能为0。这说明了在read_x_then_y和read_y_then_x两个函数至少有一个能看到x和y同时被设为true。容易看出将1/2/3/4任意排序，那么上面的断言是显然的（注意到即使read_x_then_y在write_x前被调用也有while循环兜底）。但是如果(1 -&gt; 3)和(2 -&gt; 4)这两个步骤并行发生的话，上面断言就不成立了。12345678910111213141516171819202122std::atomic&lt;bool&gt; x = false, y = false;std::atomic&lt;int&gt; z = 0;void write_x()&#123; x.store(true,std::memory_order_seq_cst); // 1&#125;void write_y()&#123; y.store(true,std::memory_order_seq_cst); // 2&#125;void read_x_then_y()&#123; while(!x.load(std::memory_order_seq_cst)); // a if(y.load(std::memory_order_seq_cst)) // 3 ++z;&#125;void read_y_then_x()&#123; while(!y.load(std::memory_order_seq_cst)); // b if(x.load(std::memory_order_seq_cst)) // 4 ++z;&#125; 自由模型(Relaxed ordering)是最弱的模型，它对线程间的执行顺序不做任何synchronizes-with的假设，但同线程的变量仍然遵循happens-before假设，即它除了禁止重排单线程上对单个变量的访问顺序，并不作任何额外的事情。下面展示的一个C++11对应的自由模型std::memory_order_relaxed的例子，注意在后面的详述中可以看到，由于特定平台的一致性模型要强于自由模型，所以std::memory_order_relaxed只是保证强于等于自由模型。注意到这时候仍然保证了1先于2、3先于4，且3读到true，但是z就可能为0了。这是由于x和y是两个不同变量，自由模型不关注它们之间的关系。关注一下图5.4，我们发现这张图非常反直觉，例如4步骤还会返回false，这是出于什么机理呢？但是在这之前，先在x86下的MSVC2015上测试一下，发现z始终不为0，这是为什么呢？我在StackOverflow上提了个问题。回答首先指出std::memory_order_relaxed的副作用实际上是禁止编译器（注意区分编译器的重排行为和处理器的乱序行为）重排x和y的Store-Store，但是断言失败还可能由于CPU决定颠倒写x和写y的顺序（虽然一般不会进行这种乱序），或者CPU的缓存导致了x延迟写入内存。回答接着解释了为什么x86上不会assertion fail，这是因为x84提供了acquire/release语义，保证了当3是true时，在2前的对3后的可见。注意到这个并不违反x86对Store-Load可能的乱序，它实际上利用了Store-Store不会乱序的特性。回顾之前的最严格的顺序一致模型，它要求对于每个共享变量，Load-Load、Load-Store、Store-Load、Store-Store都不乱序。12345678910111213std::atomic&lt;bool&gt; x = false, y = false;std::atomic&lt;int&gt; z = 0;void write_x_then_y()&#123; x.store(true,std::memory_order_relaxed); // 1 y.store(true,std::memory_order_relaxed); // 2&#125;void read_y_then_x()&#123; while(!y.load(std::memory_order_relaxed)); // 3 if(x.load(std::memory_order_relaxed)) // 4 ++z;&#125; acquire/release模型相对灵活一点，也是x86实现的语义。release可以理解为写操作，acquire可以理解为读操作。acquire fence要求其后面的RW不能与其前面的R重排，也就是RW不能重排到（原本在自己前面的）R前，例如R1 W2不能变成W2 R1，否则R1读到的就是脏值的。release fence要求其前面的RW不能和其后面的W重排，也就是RW不能重排到（原本在自己后面的）W后，例如R1 W2不能重排为W2 R1，否则R1又脏读。但是这两个模型即使组合起来也不能禁止其前面的W和后面的R重排。C++11使用剩下四个内存模型常数来实现这一机制，memory_order_release和memory_order_acquire表示B线程在使用memory_order_acquire读时，线程A在memory_order_release前的所有写操作都是可见的。而稍弱一点的memory_order_release和memory_order_consume只用来保证当前操作涉及到的对象的可见性。 Store-Load乱序问题在前面的讨论中提到了x86的Store-Load乱序问题，对于x86，Loads May Be Reordered with Earlier Stores to Different Locations，但对于相同地址则不会乱序。在这篇博文中记录了一个有关Store-Load乱序的实验。在实验中，X的写操作可能被延迟到Y的读操作之后，尽管我们插入了compiler barrier。这时候我们需要一个full/general memory barrier，也就是实现让它前面所有的Load/Store操作对它后面的Load/Store操作都是可见的，包括了止Store-Load类型的乱序。在同一篇博文中指出可以使用插入一个mfence，以实现full/general memory barrier。12345// gccasm volatile("mfence" ::: "memory")// c++11// https://stackoverflow.com/questions/25478029/does-atomic-thread-fencememory-order-seq-cst-have-the-semantics-of-a-full-memostd::atomic_thread_fence(std::memory_order_seq_cst) SoF上指出虽然atomic(seq_cst)和atomic(seq_cst)始终不会重排，但是在atomic(seq_cst)附近的non-atomic甚至是atomic(non-seq_cst)形式的STORE-LOAD都会被重排。例如在下面的代码中1和3的STORE-LOAD肯定不会被重排，但2和3的STORE-LOAD就可能被重排，所以一定要注意。1234std::atomic&lt;int&gt; a, b, c;a.store(2, std::memory_order_seq_cst); // 1: movl 2,[a]; mfence;c.store(4, std::memory_order_release); // 2: movl 4,[c];int tmp = b.load(std::memory_order_seq_cst); // 3: movl [b],[tmp]; 因此在x86上至少要对LOAD/STORE其中的一个加上MFENCE，或者用一个LOCK指令，而这也实现了类似memory_order_seq_cst的效果。在章节内存模型的实现中还有更多说明。下面的代码不一定是等价的12345678910atomic&lt;int&gt; x, yy.store(1, memory_order_relaxed); //(1)atomic_thread_fence(memory_order_seq_cst); //(2)x.load(memory_order_relaxed); //(3)atomic&lt;int&gt; x, y;y.store(1, memory_order_seq_cst); //(1)// Nothingx.load(memory_order_seq_cst); //(3) fence常见的fence包括thread fence(memory/CPU barrier)和signal fence(compiler barrier)。 signal fencesignal fence类似下面的东西，参考Wikipedia123456// gccasm volatile("" ::: "memory");// msvc__MACHINE(void _ReadWriteBarrier(void))// c++11std::atomic_signal_fence(memory_order_acq_rel) 对于gcc版本，asm、volatile、memory三个关键字的作用可以参考SoF上的回答对于MSVC版本，根据MSDN，_ReadWriteBarrier限制了编译器可能的重排。C++11标准库中的std::atomic_signal_fence在MSVC上也是利用Compiler Barrier实现的。一个signal fence的作用是 强制单线程和该线程上的异步中断之间的顺序性 强制单核上运行的多线程之间的顺序性 注意到在SMP架构下这一点难以保证，所以对于多线程程序往往需要更强的thread fence。 thread fencethread fence也就是所谓的内存屏障，我们可以使用下面的语句进行声明，此外，我们还可以声明一个单独的Store/Load Barrier。这里补充一下Store Barrier强制所有屏障前的store指令，都在屏障指令执行之前被执行，并把store缓冲区的数据都刷到主存。Load Barrier强制所有屏障后的load指令，都在屏障指令执行之后被执行，并且一直等到load缓冲区被该CPU读完才能执行之后的load指令。而一个full barrier兼而有之。12345678910// x86asm volatile("mfence":::"memory")// gcc__sync_synchronize// msvcMemoryBarrier()// c++11std::atomic_thread_fence(memory_order_seq_cst)// other methods_mm_mfence 我们需要注意的是内存屏障是相当耗时的操作，甚至还要超过原子操作，内存屏障还会干扰CPU的流水线，导致性能的降低。下面我们查看一下标准库atomic_thread_fence函数的实现12345678910111213141516171819202122// MSVCinline void _Atomic_thread_fence(memory_order _Order) &#123; /* force memory visibility and inhibit compiler reordering */ #if defined(_M_ARM) || defined(_M_ARM64) if (_Order != memory_order_relaxed) &#123; _Memory_barrier(); &#125; #else _Compiler_barrier(); if (_Order == memory_order_seq_cst) &#123; /* force visibility */ static _Uint4_t _Guard; _Atomic_exchange_4(&amp;_Guard, 0, memory_order_seq_cst); _Compiler_barrier(); &#125; #endif &#125;// GCCinline voidatomic_thread_fence(memory_order __m) noexcept&#123; __atomic_thread_fence(__m); &#125; 可以发现由于x86自带的acquire/release语义，除非是最强的memory_order_seq_cst，否则atomic_thread_fence等价于atomic_signal_fence。而memory_order_seq_cst下的thread fence的full barrier实现则比较奇特，仔细查看这个full barrier的实现这里为啥不直接插入一个MemoryBarrier()，而是利用了一个原子操作呢？ 内存模型的实现六种内存模型通过加入Compiler Barrier和Memory Barrier来实现。在SoF中指出acquire/release相当于在relax后面加一道栅栏，即下面的代码是等价的。但如果不显示加入fence的话，编译器可以视情况生成等价的更好的代码。而在x86等强内存模型架构cpu上，也不一定生成fence，例如单独的atomic_thread_fence(memory_order_acquire)就可以简化为nop。12345// 1a.load(memory_order_acquire)// 2a.load(memory_order_relaxed)atomic_thread_fence(memory_order_acquire) 而memory_order_seq_cst则需要额外的MFENCE或者LOCK，可参考上节所述。下面的代码是等价的12345678910if (var.load(std::memory_order_acquire) == 0)&#123; assert(a==123);&#125;if (var.load(std::memory_order_relaxed) == 0)&#123; std::atomic_thread_fence(std::memory_order_acquire); assert(a==123);&#125; 使用内存模型解决双重检查锁定模式(DCLP)存在的问题在之前的章节中，我们曾经提到过双重检查锁定模式中存在的问题，对此文章Double-Checked Locking is Fixed In C++11指出我们可以通过适当的内存屏障或者atomic store/load语义来解决。1234567891011121314151617std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(std::memory_order_relaxed); std::atomic_thread_fence(std::memory_order_acquire); if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(std::memory_order_relaxed); if (tmp == nullptr) &#123; tmp = new Singleton; std::atomic_thread_fence(std::memory_order_release); m_instance.store(tmp, std::memory_order_relaxed); &#125; &#125; return tmp;&#125; 123456789101112131415std::atomic&lt;Singleton*&gt; Singleton::m_instance;std::mutex Singleton::m_mutex;Singleton* Singleton::getInstance() &#123; Singleton* tmp = m_instance.load(); if (tmp == nullptr) &#123; std::lock_guard&lt;std::mutex&gt; lock(m_mutex); tmp = m_instance.load(); if (tmp == nullptr) &#123; tmp = new Singleton; m_instance.store(tmp); &#125; &#125; return tmp;&#125; 无等待无等待(Wait-Free)是比锁无关更高层面的并发。无等待指的是程序中的每个线程都可以一直运行下去而不阻塞。 并发编程中数据共享措施常见的并发模型有共享变量、Communicating Sequential Process(CSP)、Actor等模型。共享变量最为常见，多个线程通过锁或者原子操作对变量进行有序访问。CSP模型可以参照Go语言中的channel。Actor模型可以参照Mapreduce模型。 condition variable锁lock_guard和unique_lock能够保证线程之间的互斥访问临界资源，但是不能控制这些访问的先后顺序。自然而然地可以想到可以用锁维护一个共享变量记录状态，以实现线程间同步的措施，例如在生产者/消费者模型中用它来描述产品数量。一个比较naive的方式是轮询(poll)1234567891011121314bool flag;std::mutex m;void wait_for_flag()&#123; std::unique_lock&lt;std::mutex&gt; lk(m); while(!flag) &#123; lk.unlock(); // 1 解锁互斥量 std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 2 休眠100ms lk.lock(); // 3 再锁互斥量 &#125; flag = false;&#125; 注意这里这里仍然是需要锁的，否则可能两个互相竞争的线程同时获得flag。另一种更好的方法是利用条件变量，条件变量(condition variable)是利用共享的变量进行线程之间同步的一种机制。条件变量维护一个等待列表，相对于前面的轮询，条件变量应用了推的机制，当某一个线程所需要的条件不满足时，它会被阻塞。拥有锁的线程在退出临界区时使用notify_one/notify_all发出信号通知（注意并不是拥有锁才能notify）条件变量，条件变量会唤醒一个/所有正在等待的线程。使用条件变量等待事件通常是类似下面的形式1234567891011121314151617181920void wait_for_event()&#123; std::unique_lock&lt;std::mutex&gt; uni_lock(mtx); while (!condition) &#123; cv.wait(uni_lock, []()&#123;return condition;&#125;); // wait until condition &#125;&#125;void signal_event()&#123; std::unique_lock&lt;std::mutex&gt; uni_lock(mtx); condition = true; cv.notify_one();&#125;void broadcast_event()&#123; std::unique_lock&lt;std::mutex&gt; uni_lock(mtx); condition = true; cv.notify_all();&#125; 其中cv.wait会将线程挂到等待队列上，然后释放锁，并使用进入睡眠阻塞线程，否则带着锁睡觉会死锁。当cv.wait返回时，它会重新获得锁。特别地，上面wait对应的一系列步骤必须要是原子的，否则会造成丢失signal的问题。例如当条件满足!condition时，程序进入cv.wait等待，cv.wait会释放锁并准备进入睡眠，此时一个signal产生了，但是线程却并不能收到这个信号。这一现象广泛出现在使用边缘触发(Edge triggered)机制的程序中，常见的边缘触发还有Linux的信号。相对于水平触发（select/poll等），边缘触发只会唤醒已经等待在wait上的线程，因此可能出现丢失信号的问题，例如当notify操作早于wait操作时，这个notify就会丢失了。注意到上面的实现中，cv.notify_one和cv.notify_all函数始终是出现在修改condition之后的，这也是为了保证当睡眠线程在收到信号后能够及时观察到条件满足了。在陈硕大牛的博客中还指出了更多的例子。例如不为signal部分上锁是错误的，因为可能在wait部分的while循环和pthread_cond_wait函数之间发生修改condition和pthread_cond_signal，这样进入pthread_cond_wait的wait部分代码就会丢失这次的signal。不过即使为signal部分上锁还可能丢失信号。原因是生产者和消费者竞争同一把锁虽然能够保证wait和signal是串行的顺序，但可能整个signal过程都在wait过程前面。使用条件变量时可能发生虚假唤醒(spurious wakeup)的问题，虚假唤醒指的是被wait中阻塞的线程在没有notify的情况下被唤醒，或者一次signal_one唤醒多个线程。虚假唤醒可能发生在多处理器系统和接收Linux信号时，条件变量设计者出于性能因素容忍了虚假唤醒的存在。APUE指出pthread_cond_signal函数可能唤起多个线程。SoF中指出，当等待队列中的Linux线程收到一个系统信号时，会得到虚假唤醒。在另一个回答中，Jon Skeet大神指出其深层次原因是没有任何的保障是一个被唤醒(awakened)的线程一定会被调度(scheduled)，很可能当一个等待队列中的线程被唤醒后准备获得锁时，另一个线程已经捷足先登了获得了锁，并且重置了条件condition的值。但注意，即使是虚假唤醒的情况，cv.wait也是在获得锁之后再返回，但这时候条件condition可能已经不满足了，这时候就出现了虚假唤醒。解决虚假唤醒的方案很简单，如上文wait_for_event所示，可以将wait包裹在一个while循环里面。在SF上记录了一番实验，强行产生虚假唤醒。12345con_var.notify_one();// trigger the spurious wakeuplock.unlock();std::this_thread::sleep_for(std::chrono::seconds(2));condition = true; 可以发现在notify和unlock两个过程之后的两秒内消费者线程已经被唤醒了，但在拿到锁和条件变量后它发现其实condition值并不为true，这就产生了一次虚假唤醒。 事件Windows中通过事件的机制类似于条件变量的机制。 信号量的实现future条件变量的一个重要的应用就是生产者/消费者模型，但对于一些平凡的情况，消费者只等待一次(one-off)来自生产者的结果。一个普遍的场景是启动一个计算线程并异步获取它的结果，不过std::thread不能直接提供获取返回值的方法，此时可以考虑使用全局变量或者传入指针和回调函数。另一个较为方便的做法是使用std::future来获取异步任务中的结果。从一定意义上讲，future类似于一个callback。C++中提供了std::future和std::shared_future，可以触发一个或多个事件。当多个线程访问std::future时，需要锁来保护线程安全。 async如下面代码所示，future常和std::async一并使用，容易看到，它类似于Python中的subprocess.call，是个高层面的封装。123456int main()&#123; std::future&lt;int&gt; the_answer = std::async(get_integer()); do_other_stuff(); std::cout&lt;&lt; the_answer.get() &lt;&lt; std::endl;&#125; 这里面的std::async用来实现一次异步调用。std::async是一个模板函数，它可以接受一个std::launch类型的参数，其中使用std::launch::defered表示异步调用延迟到.wait()或.get()再执行。而std::launch::async表示在一个独立线程中运行。默认是std::launch::defered | std::launch::async表示这两个二选一。std::async能够接受函数指针、函数对象（的左值、右值。引用和std::ref），也能够通过类似std::bind一样的机制以引用、std::ref等方式传入对象的上下文。注意在仅C++11中，future的析构函数可能会阻塞线程。 packaged_task不同于std::async，std::packaged_task是个函数对象，这个函数对象有点类似std::function（但std::function还能够复制构造），因此std::packaged_task需要手动调用以运行。1234567std::packaged_task&lt;int()&gt; task(sleep);auto f = task.get_future();// 在主线程中运行task();// 启动另一个线程运行，注意只能移动packaged_taskstd::thread myThread(std::move(task));f.get(); 由于std::packaged_task能移动到某个std::thread中，因此适合用来实现线程池，负责打包待计算的任务。std::packaged_task还可以被用来向另一个线程派发任务。 promise在上面的两种派发任务-等待获取结果的模型中，我们的主线程是作为等待任务结果的一方，而将执行任务的异步线程则是产生结果的一方。std::future对象由主线程持有，主线程会调用std::async或者packaged_task启动一个任务，并且在需要结果时调用f.get()获得异步线程的结果。对于异步线程来说，自己并不需要额外工作，正常返回。但是这在promise中就不一样了，在使用promise时，异步线程需要显式向主线程设置值p.set_value()或传递异常p.set_exception()。 并发编程中的基础架构在设计高性能的并发代码时，我们需要注意以下几点： 充分利用局部性假设，是同一线程中的数据紧密联系 减少线程上所需的数据量 让不同线程访问不同位置，避免伪共享 线程安全的队列线程池一个简单的线程池的实现需要借助一个线程安全队列。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>并行计算</tag>
        <tag>Linux</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[libutp源码简析]]></title>
    <url>%2F2017%2F12%2F05%2Flibutp%E6%BA%90%E7%A0%81%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[libutp是uTorrent使用的类似TCP的传输层实现。它基于UDP提供可信的、有序的点对点的传输，并具有最少的时延。需要注意的是utp和另一个基于UDP的传输协议QUIC的实现思路和优势并不一样，例如QUIC更强调连接建立的快速性，建立连接时只需要1至2次握手，又如QUIC将TLS整合到协议中，实现了0RTT，而基于HTTP2的协议需要2/3RTT。QUIC还允许在用户层面配置各种拥塞控制算法。网上有关libutp实现的介绍几乎没有，因此我打算就其源码做一个简单的分析。这里要注意UTP是基于包的而不像TCP是基于流的，虽然它提供的API还是基于流的。这样有一些影响，例如黏包问题的处理、缓冲区的管理（例如可以去掉PUSH标记）、窗口管理、重新分组等方面。 uTP源码简介utp.h以C89的形式提供接口。例如utp_write是以proactive的方式实现的。utp相关的实现大多在utp_internal.cpp文件中。utp_packedsockaddr.cpp中封装了sockaddr_in结构。ucat.c基于uTP框架构建了一个基础的应用。uTP的设计主要是异步的，应用代码不会阻塞在异步IO操作上，而是指定回调函数并立即返回。utp_callbacks.cpp中注册了各种回调函数，utp向外界传输消息都是以这里回调的形式开展的。例如当收到数据包时，ctx-&gt;callbacks[UTP_ON_READ]这个回调函数就会被调用。 使用回调函数也体现了libutp总体的设计思路： 回调函数能够屏蔽掉套接字API的细节 一个可靠通信协议的主要任务是在不可靠的设施上建立可靠的传输通道，至于使用哪一种不可靠的传输方式并不是核心问题。uTP协议的内部实现能够与UDP套接字等做到隔离，utp不是继承或者封装了UDP套接字描述符，然后提供一个TCP的鸭子类型。而是完全工作在UDP上层，打包了一些对UDP的操作，方便用户调用。 例如uTP就可以选择不实现sendto等方法，而用户选择使用send还是write还是sendmsg，然后写成回调，uTP只需要在它需要通过UDP发送它构造的数据报时调用这个回调就好了。又例如系统从UDP套接口收到一个消息时，它并不是直接处理，而是调用utp_process_udp函数。对于一个已连接的套接字，这个函数会找到对应的UTPSocket结构，并调用utp_process_incoming函数，该函数是个非常大的函数，里面uTP协议根据自己的报头处理了相关消息之后，调用用户设置的回调函数通知收到了消息。对于连接请求，我们将在下面的被动连接上详细讨论。 回调函数方便实现proactive和reactive风格的API常见的反射式(reactive)异步IO模型包括select、poll、kqueue、Java NIO等，只会通知到某IO设备上产生了IO事件，然后由用户来发起IO请求，例如调用read、recv等。前摄式(proactive)包括IOCP、Boost Asio等，用户主动发送IO请求（即使现在IO设备还没有准备好）并提前向系统注册一个回调函数，当实际的IO事件发生时由系统处理该IO操作，并在完成后触发指定的回调函数，因此前摄式能够避免用户将数据从内核取回来的开销。因此前摄式强调的是对未来读取事件的预期，抽象程度要高一点，用户可以利用Proactor的回调构造一条执行顺序链，而Reactor必须手动维护接受的状态。 回调函数能减少处理并发问题的难度 鉴于以上的这几点，在分析uTP协议时必须要将ucat.c纳入考虑范围，不然很难搞懂原理。 ucat简介ucat使用了poll来维护了两个fd，stdin和套接口，并且设置了500ms的超时时间。 uTP重要数据结构utp_context12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// utp.htypedef struct struct_utp_context utp_context;// utp_internal.hstruct struct_utp_context &#123; void *userdata; utp_callback_t* callbacks[UTP_ARRAY_SIZE]; uint64 current_ms; utp_context_stats context_stats; UTPSocket *last_utp_socket; Array&lt;UTPSocket*&gt; ack_sockets; Array&lt;RST_Info&gt; rst_info; UTPSocketHT *utp_sockets; size_t target_delay; size_t opt_sndbuf; size_t opt_rcvbuf; uint64 last_check; // utp_api.cpp struct_utp_context::struct_utp_context() : userdata(NULL), current_ms(0), last_utp_socket(NULL), log_normal(false), log_mtu(false), log_debug(false) &#123; memset(&amp;context_stats, 0, sizeof(context_stats)); memset(callbacks, 0, sizeof(callbacks)); target_delay = CCONTROL_TARGET; utp_sockets = new UTPSocketHT; callbacks[UTP_GET_UDP_MTU] = &amp;utp_default_get_udp_mtu; callbacks[UTP_GET_UDP_OVERHEAD] = &amp;utp_default_get_udp_overhead; callbacks[UTP_GET_MILLISECONDS] = &amp;utp_default_get_milliseconds; callbacks[UTP_GET_MICROSECONDS] = &amp;utp_default_get_microseconds; callbacks[UTP_GET_RANDOM] = &amp;utp_default_get_random; // 1 MB of receive buffer (i.e. max bandwidth delay product) // means that from a peer with 200 ms RTT, we cannot receive // faster than 5 MB/s // from a peer with 10 ms RTT, we cannot receive faster than // 100 MB/s. This is assumed to be good enough, since bandwidth // often is proportional to RTT anyway // when setting a download rate limit, all sockets should have // their receive buffer set much lower, to say 60 kiB or so opt_rcvbuf = opt_sndbuf = 1024 * 1024; last_check = 0; &#125; ~struct_utp_context()&#123; delete this-&gt;utp_sockets; &#125; void log(int level, utp_socket *socket, char const *fmt, ...); void log_unchecked(utp_socket *socket, char const *fmt, ...); bool would_log(int level); bool log_normal:1; // log normal events? bool log_mtu:1; // log MTU related events? bool log_debug:1; // log debugging events? (Must also compile with UTP_DEBUG_LOGGING defined)&#125;; utp_context的成员 utp_sockets utp_sockets指向一个UTPSocketHT : utpHashTable&lt;UTPSocketKey, UTPSocketKeyData&gt;哈希表。这个哈希表维护了所有的套接字： 在utp_sockets析构时调用UTP_FreeAll释放所有的套接字。 当UDP包被接受时，会调用utp_process_udp这个处理程序。此时我们仅能获得对应的套接字地址const struct sockaddr *，因此需要能够通过这个指针找到对应的套接字。 UTPSocketHT中的键UTPSocketKey和值UTPSocketKeyData的构造如下： 键UTPSocketKey中存放了对应UTPSocket中的PackedSockAddr addr以及recv_id字段。 PackedSockAddr addr字段是在utp_initialize_socket设置的，表示指向的目标地址。 recv_id对应着套接字里面的conn_id_recv字段，是在utp_initialize_socket中随机生成的。这里的recv_id的主要功能是作为ATP协议中“host端的端口号”来使用。查看相关代码我们可以发现conn_id_send始终比conn_id_recv要大1。 123456// utp_process_udputp_initialize_socket(conn, to, tolen, false, id, id+1, id);// void utp_initialize_socket(utp_socket *conn, const struct sockaddr *addr, socklen_t addrlen, bool need_seed_gen, uint32 conn_seed, uint32 conn_id_recv, uint32 conn_id_send)&#123;// ...conn_id_recv += conn_seed;conn_id_send += conn_seed; 下面讨论了几个重要的问题 为什么我们要使用id而不直接使用四元组呢？ 使用id能够方便地实现以下的机制（虽然libutp并不一定实现了） 使用三次握手和四次挥手的很高创建成本很高，使用ID能够复用已经创建好的连接 将连接概念独立于四元组概念，方便隔离底层，从而实现连接迁移。QUIC实现了这个特性 为什么要有两个id呢？ 这是因为在同一个UDP port上会存在多个uTP连接，因此我们需要增设一个ID字段来区分这些连接。对于每一个套接口，uTP选择它的发送和接受都设置一个ID。当utp_process_udp接受到UDP包的时候，他获得的是一个sockaddr地址，所以需要找到对应的UTPSocket套接字，当套接字不存在时，需要发送RST包。当套接字关闭时，需要它来维护2MSL的等待时间，实际上由于UDP的UTPSocketKey包含了recv_id，所以2MSL是不必要的，在UTPSocket::check_timeouts代码中看到只等到rto_timeout就行。 为什么选择conn_id_recv而不是conn_id_send来作为哈希值呢？ 这是因为当数据报到达时，要通过里面的recv_id找到具有特定conn_id_recv的套接字。 值UTPSocketKeyData中主要持有了对应的UTPSocket *的指针。 opt_sndbuf和opt_rcvbuf 这两个size_t表示发送缓冲区和接收缓冲区的默认大小。缓冲区的大小与窗口大小形成协同。在创建套接字时，套接字的opt_sndbuf和opt_rcvbuf会“继承自”对应的context。 target_delay单位为微秒，初始值为CCONTROL_TARGET = 100 * 1000。 current_ms的作用是用来保存当前时间，这样可以避免多次调用获取时间函数的开销。 context_stats是一个utp_context_stats类型的结构，用来统计不同大小的uTP包的数量。 ack_sockets与schedule_ack机制有关，详见超时重传部分。 rst_info维护了RST_INFO_LIMIT个reset信息，详见连接重置部分。 utp_context的用途 方便集中管理的UTP套接口UTPSocket 从上面的结构中看到所有的UTPSocket被放到一个哈希表里面。当UTPSocket销毁时，要将哈希表中对应的&lt;UTPSocketKey, UTPSocketKeyData&gt;键值对删掉，在utp_initialize_socket函数中要往context里面注册自己，这些操作实际上都是为了方便集中管理套接字。 以utp_check_timeouts函数为例，这个函数作为每次“时钟中断”的入口，接受的是一个utp_context而不是一个UTPSocket，context里面对所有的UTPSocket调用了check_timeouts，这样避免了为每一个套接字维护一个时钟信号的开销。 方便实现UTP服务 libutp是工作在用户态的，所以并不能向外提供系统调用，因此每一个进程会维护一个utp_context。 utp_socket123456// utp.htypedef struct UTPSocket utp_socket;// utp_internal.cppstruct UTPSocket &#123; // ...&#125;; UTPSocket类型用来维护一个套接字的上下文，里面东西比较多，将在下面展开讨论。 OutgoingPacket对于一个（将要）被发出去的包，有一个OutgoingPacket与其对应。12345678struct OutgoingPacket&#123; size_t length; // 总长 size_t payload; // 有效载荷 uint64_t time_sent; // microseconds uint32_t transmissions; // 总传输次数 bool need_resend; char data[1];&#125;; 这里的data是个VLA，实际上是包头+数据包的全部内容。注意到最好不要将包头和数据包分开存放，不然又要多一次复制的开销。 PacketFormatV1/PacketFormatAckV1首先查看基础的PacketFormatV1，这是一个uTP常规数据报的报头。1234567891011121314151617181920212223// utp_internal.cppstruct PACKED_ATTRIBUTE PacketFormatV1 &#123; // packet_type (4 high bits) // protocol version (4 low bits) byte ver_type; byte version() const &#123; return ver_type &amp; 0xf; &#125; byte type() const &#123; return ver_type &gt;&gt; 4; &#125; void set_version(byte v) &#123; ver_type = (ver_type &amp; 0xf0) | (v &amp; 0xf); &#125; void set_type(byte t) &#123; ver_type = (ver_type &amp; 0xf) | (t &lt;&lt; 4); &#125; // Type of the first extension header byte ext; // connection ID uint16_big connid; uint32_big tv_usec; uint32_big reply_micro; // receive window size in bytes uint32_big windowsize; // Sequence number uint16_big seq_nr; // Acknowledgment number uint16_big ack_nr;&#125;; ver_type ver_type标志了数据报的类型，这个类似于压缩了后的TCP报头中的flags字段，节约了一些空间，并且更加直观。包含下面的5种。 12345678enum &#123; ST_DATA = 0, // Data packet. ST_FIN = 1, // Finalize the connection. This is the last packet. ST_STATE = 2, // State packet. Used to transmit an ACK with no data. ST_RESET = 3, // Terminate connection forcefully. ST_SYN = 4, // Connect SYN ST_NUM_STATES, // used for bounds checking&#125;; 这里ST_STATE即一个不带数据的探查包，因此并不会增加seq_nr。 ext 这个表示扩展号，默认是0，设为1时表示使用了EACK的扩展，对应着扩展后的PacketFormatAckV1类型的数据包。 connid connid的用途已在前面的utp_context进行了论述。 tv_usec tv_usec是一个时间戳，表示数据包的发送时间，在send_data中被设置。我们看到相比TCP则保守地用了TCP Timestamps Option这个选项，UTP中强制将其整合了进来。其实时间戳的作用是非常大的，例如借助于时间戳可以更精确地计算出RTT。否则我们只能对非重传的数据包进行采样。时间戳还能方便我们对高带宽下序号迅速耗尽进行PAWS(Protect Againest Wrapped Sequence numbers)防范，不过我检查下代码发现UTP里面并没有PAWS的机制（详见后面收包的部分）。 reply_micro reply_micro在utp_process_incoming中被设置，当A发送数据包给B时，B提取收到数据包中的tv_usec字段并和自己的本地时间作差，得到更新的reply_micro。这个值会随着下一个数据包被传送给对端（send_data函数）。 这里再提一下PACKED_ATTRIBUTE这个属性，在utp_internal.cpp中已经使用了#pragma pack，这里是为了双重保险。12345678910111213141516// utp_internal.cpp#if (defined(__SVR4) &amp;&amp; defined(__sun)) #pragma pack(1)#else #pragma pack(push,1)#endif// utp_types.h// Allow libutp consumers or prerequisites to override PACKED_ATTRIBUTE#ifndef PACKED_ATTRIBUTE#if defined BROKEN_GCC_STRUCTURE_PACKING &amp;&amp; defined __GNUC__ // Used for gcc tool chains accepting but not supporting pragma pack // See http://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html #define PACKED_ATTRIBUTE __attribute__((__packed__))#else #define PACKED_ATTRIBUTE#endif // defined BROKEN_GCC_STRUCTURE_PACKING &amp;&amp; defined __GNUC__ PacketFormatAckV1这个包表示当这个包是EACK包时的附加数据，EACK包是类似于SACK的一种机制，用于选择性确认。在UTPSocket::send_ack函数中能看到EACK将acr_nr前最多32个报文的接受情况按位放到长度为4的字节数组里面，这是一个非常巧妙的方法。123456struct PACKED_ATTRIBUTE PacketFormatAckV1 &#123; PacketFormatV1 pf; byte ext_next; byte ext_len; byte acks[4];&#125;; SizableCircularBuffer这是一个环形缓冲区，值得注意的是这个缓冲区并不是线程安全的，不过libutp的接口不是线程安全的。12345678910111213141516171819202122232425struct SizableCircularBuffer &#123; // This is the mask. Since it's always a power of 2, adding 1 to this value will return the size. size_t mask; // This is the elements that the circular buffer points to void **elements; void *get(size_t i) const &#123; assert(elements); return elements ? elements[i &amp; mask] : NULL; &#125; void put(size_t i, void *data) &#123; assert(elements); elements[i&amp;mask] = data; &#125; void grow(size_t item, size_t index)&#123; // Figure out the new size. size_t size = mask + 1; do size *= 2; while (index &gt;= size); // Allocate the new buffer void **buf = (void**)calloc(size, sizeof(void*)); size--; // Copy elements from the old buffer to the new buffer for (size_t i = 0; i &lt;= mask; i++) &#123; buf[(item - index + i) &amp; size] = get(item - index + i); &#125; // Swap to the newly allocated buffer mask = size; free(elements); elements = buf; &#125; void ensure_size(size_t item, size_t index) &#123; if (index &gt; mask) grow(item, index); &#125; size_t size() &#123; return mask + 1; &#125;&#125;; 环形缓冲区的大小size始终是2的整数幂，这里的mask等于size - 1，因此全部为1。mask起到类似取模的作用。这里的ensure_size和grow的参数有点奇怪，其实查看调用情况可以发现item表示要插入的元素的编号，如seq_nr；而index表示当前队列中元素的个数，如cur_window_packets，这样队列就不会出现假溢出的现象。如果说队列中元素比容量size = mask + 1要多了，那么就要扩展队列。由于扩展队列变了模数，不同余了，所以要按照模前的数(item - index + i)进行复制。 环形缓冲区的增长grow需要提供item和index，两个变量可以分别理解为缓冲区中最旧的序号和最新的序号，其中item - index表示最老的未确认的ATPPacket的序号。对于缓冲区中的序号$seq$，有$seq \, mod \, m1 = x$，当mask从$m1$增长到$m2$时，需要求出在$seq$未知的情况下求出$seq \, mod \, m2 = y$。其实有个简单的开销较大的办法，就是用一个std::pair把原始的序号计算出来。 套接字的连接关闭与读写操作创建套接字utp_create_socket用来创建一个套接字，在创建套接字时并不向context进行注册，这也是因为目前已有信息无法计算出哈希值的缘故。state = CS_UNINITIALIZED 定位套接字在uTP中，当我们收到一个UDP数据包时会调用utp_process_udp函数通告context，context会根据端口和报头来定位到具体套接字。 主动连接实现在函数utp_connect内。 首先调用utp_initialize_socket utp_initialize_socket的作用初始化套接字，这里的操作包括设置dest端的地址/端口，初始化conn_id_recv和conn_id_send，初始化套接字的部分字段。向context注册自己。 在初始化之后，套接字具有状态state = CS_IDLE 然后调用UTPSocket::send_packet 这个函数详见下面 被动连接uTP对被动连接的处理在utp_process_udp函数中。首先context会判断是否接受连接，条件如下： 是否设置了UTP_ON_ACCEPT回调 是否已存在该连接 context中保持的连接数是否已超过3000 可以看出，uTP对连接的限制还是比较放松的，在TCP协议中还会对在连接队列中（三次握手尚未完成）的套接口有限制，即listen的backlog参数。事实上协议实现会分别维护连接中的队列so_q0和已连接的队列so_q，并保持一个so_head指向accept套接字指针。 来自防火墙回调utp_call_on_firewall的反馈 发包操作UTPSocket::send_packet是主要的发包函数 UTPSocket::send_packet、UTPSocket::send_ack、send_rst send_packet函数用来发送构造好的OutgoingPacket::data。 send_ack会就地构造一个ACK包，然后调用send_data发送。 send_rst直接调用更基础的send_to_addr发送RST包。 UTPSocket::send_data 这个函数的存在主要是处理一些UTPSocket::send_packet和UTPSocket::send_ack的共同部分 send_to_addr 这个函数位于调用链的最下端，调用了注册的callback函数来发送数据包，同时调用utp_register_sent_packet像utp_context::context_stats报告了发送长度用来统计。这个统计信息可以被API函数utp_get_context_stats取得，以供用户分析。 写操作utp_writeutp_write被作为utp_writev的一个特例来处理。 utp_writev同UNIX套接口函数writev一样，utp_writev接受一个指向iovec数组的指针iovec_input：1234struct iovec&#123; void *iov_base; size_t iov_len;&#125;; utp_writev按照iovec_input[0 .. num_iovecs-1]的顺序从缓冲区发送数据，并返回成功发送的总字节数。utp_writev主要做一些检查，如num_iovecs是否超过了UTP_IOV_MAX。然后将iovec_input复制到自己的一块缓存iovec里面（为啥呢），计算所有iovec的大小的总和到bytes。我们实际发送的数据量num_to_send为bytes和连接最多允许的数据包大小packet_size（由MTU决定）两者的最小值。当bytes过大时，就需要分批发送，如下面的代码所示。123456size_t packet_size = conn-&gt;get_packet_size();size_t num_to_send = min&lt;size_t&gt;(bytes, packet_size);while (!conn-&gt;is_full(num_to_send)) &#123; bytes -= num_to_send; sent += num_to_send; conn-&gt;write_outgoing_packet(num_to_send, ST_DATA, iovec, num_iovecs); 这里的is_full由窗口决定。utp_writev下面会调用write_outgoing_packet(size_t payload, uint flags, struct utp_iovec *iovec, size_t num_iovecs)。我们知道OutgoingPacket用来描述一个数据包的上下文，在第一次握手时由于没有数据需要传输，所以直接调用的utp_send_packet，相当于只发送了一个包头。而对于utp_writev来说，需要在包头后面加上数据。下面的代码将每个iov[i]中的iov_base复制到。12345678910111213for (size_t i = 0; i &lt; num_iovecs &amp;&amp; needed; i++) &#123; if (iovec[i].iov_len == 0) continue; size_t num = min&lt;size_t&gt;(needed, iovec[i].iov_len); memcpy(p, iovec[i].iov_base, num); p += num; iovec[i].iov_len -= num; iovec[i].iov_base = (byte*)iovec[i].iov_base + num; // iovec[i].iov_base += num, but without void* pointers needed -= num;&#125; write_outgoing_packetwrite_outgoing_packet接受一个utp_iovec数组，然后组织数据包结构，并将其放入发送缓存。注意write_outgoing_packet函数并不会直接调用send_packet发送数据包。write_outgoing_packet主要是一个大循环12345do &#123; // ... payload -= added;&#125; while (payload);flush_packets(); 首先write_outgoing_packet在发送缓冲区中取出前一个seq_nr - 1序号的pkt，试图重用它。注意到如果窗口小于等于0，那么实际的pkt就是NULL，这是为了保证当窗口小于等于0时，不会再往当前的pkt里面放东西了，否则pkt的容量超过窗口导致被缓存。相反的，我们重新开一个包放超出窗口的数据，这样只有这个新开的包会被缓存。123if (cur_window_packets &gt; 0) &#123; pkt = (OutgoingPacket*)outbuf.get(seq_nr - 1);&#125; 下面的代码的上半部分，当数据包pkt尚未满载，并且尚未发送时，在本次循环中会重新使用它，在它的后面续上added长度的空间，供添加数据使用。sizeof(OutgoingPacket) - 1是减去VLA的一个字节。1234567891011121314151617// if there's any room left in the last packet in the window// and it hasn't been sent yet, fill that frame firstif (payload &amp;&amp; pkt &amp;&amp; !pkt-&gt;transmissions &amp;&amp; pkt-&gt;payload &lt; packet_size) &#123; // Use the previous unsent packet added = min(payload + pkt-&gt;payload, max&lt;size_t&gt;(packet_size, pkt-&gt;payload)) - pkt-&gt;payload; pkt = (OutgoingPacket*)realloc(pkt, (sizeof(OutgoingPacket) - 1) + header_size + pkt-&gt;payload + added); outbuf.put(seq_nr - 1, pkt); append = false; assert(!pkt-&gt;need_resend);&#125; else &#123; // Create the packet to send. added = payload; pkt = (OutgoingPacket*)malloc((sizeof(OutgoingPacket) - 1) + header_size + added); pkt-&gt;payload = 0; pkt-&gt;transmissions = 0; pkt-&gt;need_resend = false;&#125; 下面的代码紧接着上面，为pkt添加added长度的数据1234567891011121314151617181920212223if (added) &#123; assert(flags == ST_DATA); // Fill it with data from the upper layer. unsigned char *p = pkt-&gt;data + header_size + pkt-&gt;payload; size_t needed = added; for (size_t i = 0; i &lt; num_iovecs &amp;&amp; needed; i++) &#123; if (iovec[i].iov_len == 0) continue; size_t num = min&lt;size_t&gt;(needed, iovec[i].iov_len); memcpy(p, iovec[i].iov_base, num); p += num; iovec[i].iov_len -= num; iovec[i].iov_base = (byte*)iovec[i].iov_base + num; // iovec[i].iov_base += num, but without void* pointers needed -= num; &#125; assert(needed == 0);&#125; append表示是否是一个需要被加入缓冲区的新数据包，在上面的if块中被设置12345678if (append) &#123; // Remember the message in the outgoing queue. outbuf.ensure_size(seq_nr, cur_window_packets); outbuf.put(seq_nr, pkt); p1-&gt;seq_nr = seq_nr; seq_nr++; cur_window_packets++;&#125; 接下来write_outgoing_packet调用flush_packets来刷新缓冲区 flush_packetsflush_packets函数在发包时和重传计时器超时时被调用。123456789101112131415161718192021222324bool UTPSocket::flush_packets()&#123; size_t packet_size = get_packet_size(); // send packets that are waiting on the pacer to be sent // i has to be an unsigned 16 bit counter to wrap correctly // signed types are not guaranteed to wrap the way you expect for (uint16 i = seq_nr - cur_window_packets; i != seq_nr; ++i) &#123; OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(i); if (pkt == 0 || (pkt-&gt;transmissions &gt; 0 &amp;&amp; pkt-&gt;need_resend == false)) continue; // have we run out of quota? if (is_full()) return true; // Nagle check // don't send the last packet if we have one packet in-flight // and the current packet is still smaller than packet_size. if (i != ((seq_nr - 1) &amp; ACK_NR_MASK) || cur_window_packets == 1 || pkt-&gt;payload &gt;= packet_size) &#123; send_packet(pkt); &#125; &#125; return false;&#125; 读操作在ucat.c中，当context收到UDP包之后会交给对应socket的udp_process_incoming函数进行处理，这个函数中涉及和uTP实现可靠传输有关的很多内容，因此与之相关的内容将放在下面的章节中进行讨论，本节主要讨论uTP处理出数据并返回上层的相关内容。首先我们看到udp_process_incoming调用了utp_register_recv_packet，这是一个统计用的函数，我们可以不做考虑。 主动关闭12345678910111213141516171819202122void utp_close(UTPSocket *conn)&#123; switch(conn-&gt;state) &#123; case CS_CONNECTED: case CS_CONNECTED_FULL: conn-&gt;state = CS_FIN_SENT; conn-&gt;write_outgoing_packet(0, ST_FIN, NULL, 0); break; case CS_SYN_SENT: conn-&gt;rto_timeout = utp_call_get_milliseconds(conn-&gt;ctx, conn) + min&lt;uint&gt;(conn-&gt;rto * 2, 60); // fall through case CS_GOT_FIN: conn-&gt;state = CS_DESTROY_DELAY; break; case CS_SYN_RECV: // fall through default: conn-&gt;state = CS_DESTROY; break; &#125;&#125; 超时重传与可靠传输引起发送方超时重传的原因有大致三种： 分组丢失。这里指报文并没有顺利到达接收方，因此需要发送发进行重传。 确认丢失。这里报文顺利传送到接收方，但接收方返回的ACK报文丢失了。这种情况下发送方很可能会在超时之后重新发送该分组，而接收方应该选择丢弃并重新确认。 经受延迟。这里报文和ACK都顺利传送，但整个过程耗时超过了Timeout，这时发送方也会进行重传。 对于发送出去的每个数据包设置一个定时器，等定时器超时之后触发回调进行重传是开销很大的。实际上可以维护一个超时重传计时器，当对方有数据包过来时就重置这个计时器，否则当计时器超时时，就重传发送队列中的所有数据包。 发送ACK当对方封包过来时，需要根据其序号更新自己的确认号，并进行相关处理，如发送ACK、处理乱序包等。这是一个复杂的流程，本部分介绍如何向对方发送一个ACK。而在此之前的例如接受封包，更新自己的ack_nr则在下面的数据包接收（确认部分）进行介绍。 延迟确认uTP使用了schedule_ack的机制来实现Delayed ACK特性。首先使用UTPSocket::schedule_ack向context注册socket自己，表示请不要立即发送一个空的ACK包，而是尝试将ACK放到带用户数据的包里面。当计时器超时时，utp_issue_deferred_acks函数会被调用（在ucat.c里面）。这个函数调用ack_sockets里面所有注册了的socket的send_ack()方法，发送ACK包。12345for (size_t i = 0; i &lt; ctx-&gt;ack_sockets.GetCount(); i++) &#123; UTPSocket *conn = ctx-&gt;ack_sockets[i]; conn-&gt;send_ack(); i--;&#125; 当新的ACK能够随着带用户数据的包一同发送时，就能免于发送一个空ACK包的开销。这时候会调用removeSocketFromAckList函数将这个socket从ack_sockets列表中删除。12345678910111213141516void removeSocketFromAckList(UTPSocket *conn)&#123; if (conn-&gt;ida &gt;= 0) &#123; UTPSocket *last = conn-&gt;ctx-&gt;ack_sockets[conn-&gt;ctx-&gt;ack_sockets.GetCount() - 1]; assert(last-&gt;ida &lt; (int)(conn-&gt;ctx-&gt;ack_sockets.GetCount())); assert(conn-&gt;ctx-&gt;ack_sockets[last-&gt;ida] == last); last-&gt;ida = conn-&gt;ida; conn-&gt;ctx-&gt;ack_sockets[conn-&gt;ida] = last; conn-&gt;ida = -1; // Decrease the count conn-&gt;ctx-&gt;ack_sockets.SetCount(conn-&gt;ctx-&gt;ack_sockets.GetCount() - 1); &#125;&#125; 这个函数会将需要移除的指针和队尾指针互换，并弹出队尾。需要注意的是延迟确认存在很多特殊情况： 保活心跳包立即发送 SYN和FIN等关键包立即发送 当窗口变为0立即发送，因为窗口为0表示一段时间内不能向对方发送数据了 具体实现从具体实现上看，libutp在void UTPSocket::ack_packet(uint16 seq)函数里面处理对方发过来的ACK，在void UTPSocket::send_ack(bool synack)里面向对方发送自己对对方的ACK。ack_packet函数有3个返回值，返回0表示正常ACK，返回1表示这个包已经被ACK过了，返回2表示这个包还没有被发送。 数据包接收（确认部分）TCP协议中使用的是后退N重传(Go-Back-N)协议，即从第一个未确认的包开始全部传送。TCP用ACK号表示小于ACK号的所有字节都已经被接受到。例如A发送了1/2/3/4四个数据包，如果截止到A的RTO超时，B只接受到了1/3，那么它只能ACK到1。这时候A就必须重传2/3/4三个数据包，但其实3是可以不重传的。此时在传输过程中发生了乱序，这里数据包3号早于数据包2号到达了。uTP使用reorder_count记录数据包乱序抵达的情况。我们查看在utp_process_incoming中有关处理对方序号的部分12// seqnr is the number of packets past the expected packet this is. ack_nr is the last acked, seq_nr is the current. Subtracring 1 makes 0 mean "this is the next expected packet".const uint seqnr = (pk_seq_nr - conn-&gt;ack_nr - 1) &amp; SEQ_NR_MASK; 这里的pk_seq_nr指的是数据包包头中的seq_nr字段，而conn-&gt;ack_nr表示我们最后确认的序号，因此seqnr为0时表示这个包是序号紧接着的数据包。注意这个是能够正确处理溢出的情况的。接下来跳过若干行，在utp_process_incoming函数的最后，对当前的数据包进行确认工作，并调用utp_call_on_read回调。查看代码，这里对seqnr是否为0，也就是是否为乱序包展开了讨论，首先查看不是乱序包的情况，我们直接在代码中进行注释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (seqnr == 0) &#123; size_t count = packet_end - data; if (count &gt; 0 &amp;&amp; conn-&gt;state != CS_FIN_SENT) &#123; // Post bytes to the upper layer utp_call_on_read(conn-&gt;ctx, conn, data, count); &#125; conn-&gt;ack_nr++; // Check if the next packet has been received too, but waiting in the reorder buffer. // 这里检查是否可以释放缓存着的乱序包，例如seqnr==1的包可能已经到达，但由于当前seqnr==0的包还未到达，所以无法确认，只能缓存着 for (;;) &#123; if (conn-&gt;got_fin &amp;&amp; conn-&gt;eof_pkt == conn-&gt;ack_nr) &#123; if (conn-&gt;state != CS_FIN_SENT) &#123; conn-&gt;state = CS_GOT_FIN; conn-&gt;rto_timeout = conn-&gt;ctx-&gt;current_ms + min&lt;uint&gt;(conn-&gt;rto * 3, 60); utp_call_on_state_change(conn-&gt;ctx, conn, UTP_STATE_EOF); &#125; // if the other end wants to close, ack conn-&gt;send_ack(); // reorder_count is not necessarily 0 at this point. even though it is most of the time, the other end may have sent packets with higher sequence numbers than what later end up being eof_pkt since we have received all packets up to eof_pkt just ignore the ones after it. conn-&gt;reorder_count = 0; &#125; // 当已经没有乱序包了，就直接退出循环。这里和后面的assert联动 // Quick get-out in case there is nothing to reorder if (conn-&gt;reorder_count == 0) break; // Check if there are additional buffers in the reorder buffers // that need delivery. byte *p = (byte*)conn-&gt;inbuf.get(conn-&gt;ack_nr+1); if (p == NULL) break; conn-&gt;inbuf.put(conn-&gt;ack_nr+1, NULL); count = *(uint*)p; if (count &gt; 0 &amp;&amp; conn-&gt;state != CS_FIN_SENT) &#123; // Pass the bytes to the upper layer utp_call_on_read(conn-&gt;ctx, conn, p + sizeof(uint), count); &#125; conn-&gt;ack_nr++; // Free the element from the reorder buffer free(p); assert(conn-&gt;reorder_count &gt; 0); conn-&gt;reorder_count--; &#125; // 向context注册一个延迟确认 conn-&gt;schedule_ack();&#125; 下面查看是乱序包的情况1234567891011121314151617181920212223242526272829303132333435363738// if we have received a FIN packet, and the EOF-sequence number is lower than the sequence number of the packet we just received something is wrong.if (conn-&gt;got_fin &amp;&amp; pk_seq_nr &gt; conn-&gt;eof_pkt) &#123; return 0;&#125;// 如果这里接受到一个序号距离ack_nr偏移非常严重的包，选择直接丢弃。注意到这里实际上也处理了一个序号在pk_seq_nr前的包的情况// if the sequence number is entirely off the expected one, just drop it. We can't allocate buffer space in the inbuf entirely based on untrusted inputif (seqnr &gt; 0x3ff) &#123; return 0;&#125;// we need to grow the circle buffer before we check if the packet is already in here, so that we don't end up looking at an older packet (since the indices wraps around).conn-&gt;inbuf.ensure_size(pk_seq_nr + 1, seqnr + 1);// 一个提前抵达的包同样可能已经被处理过// Has this packet already been received? (i.e. a duplicate) If that is the case, just discard it.if (conn-&gt;inbuf.get(pk_seq_nr) != NULL) &#123; return 0;&#125;// Allocate memory to fit the packet that needs to re-orderedbyte *mem = (byte*)malloc((packet_end - data) + sizeof(uint));*(uint*)mem = (uint)(packet_end - data);memcpy(mem + sizeof(uint), data, packet_end - data);// Insert into reorder buffer and increment the count of # of packets to be reordered. we add one to seqnr in order to leave the last entry empty, that way the assert in send_ack is valid. we have to add one to seqnr too, in order to make the circular buffer grow around the correct point (which is conn-&gt;ack_nr + 1).assert(conn-&gt;inbuf.get(pk_seq_nr) == NULL);assert((pk_seq_nr &amp; conn-&gt;inbuf.mask) != ((conn-&gt;ack_nr+1) &amp; conn-&gt;inbuf.mask));conn-&gt;inbuf.put(pk_seq_nr, mem);conn-&gt;reorder_count++;#if UTP_DEBUG_LOGGINGconn-&gt;log(UTP_LOG_DEBUG, "0x%08x: Got out of order data reorder_count:%u len:%u (rb:%u)", conn-&gt;reorder_count, (uint)(packet_end - data), (uint)utp_call_get_read_buffer_size(conn-&gt;ctx, conn));#endif// 向context注册一个延迟确认conn-&gt;schedule_ack(); RTT与RTO的计算RTT(Round-Trip Time)即往返时间。受到链路的传播时间、终端系统的处理时间、路由器缓存与处理时间的影响。如果我们使用发送时间戳TS和收到ACK的时间戳TR来计算$RTT = TR - TS$，那么这个值是偏大的，因为它包含了链路中的来回时间以及对端在收到数据包之后到发送ACK包之间的包括缓存、处理的时间。RTO(Retransmission TimeOut)，超时重传时间，与RTT有关。RFC793中使用低通过滤器对RTT进行平滑，然后再乘上一个因子$\beta$得到初次重传RTO。此外在往返时间变化起伏较大是，还要根据均值和方差计算RTO。RTO随着重传次数是按照指数增长的，即第二次超时则重传时间变为2倍的RTO。在新的RFC2988/6298中又更新了相关的算法，在此不详述。 uTP中RTT和初始RTO的计算实现在ack_packet函数里面。ack_packet是作用在发送队列上的，当数据包没有被重传的时候，使用当前时间减去它的发送时间来计算出ertt，然后计算出rtt和rto。而rto_timeout指的是超时的时刻，初始化时有rto_timeout = ctx-&gt;current_ms + retransmit_timeout。当ctx-&gt;current_ms - rto_timeout时则超时条件触发。下面是ack_packet中具体的代码。注意我们只对没有重传的包计算RTT，这是因为如果数据包经历了重传，并且我们收到了来自对端的ACK，我们无法知道这个ACK是对原始包还是被重传包的响应。1234567891011121314151617181920212223// 我们只对没有重传的包计算RTTif (pkt-&gt;transmissions == 1) &#123; // Estimate the round trip time. const uint32 ertt = (uint32)((utp_call_get_microseconds(this-&gt;ctx, this) - pkt-&gt;time_sent) / 1000); if (rtt == 0) &#123; // First round trip time sample rtt = ertt; rtt_var = ertt / 2; // sanity check. rtt should never be more than 6 seconds// assert(rtt &lt; 6000); &#125; else &#123; // Compute new round trip times const int delta = (int)rtt - ertt; rtt_var = rtt_var + (int)(abs(delta) - rtt_var) / 4; rtt = rtt - rtt/8 + ertt/8; // sanity check. rtt should never be more than 6 seconds// assert(rtt &lt; 6000); rtt_hist.add_sample(ertt, ctx-&gt;current_ms); &#125; rto = max&lt;uint&gt;(rtt + rtt_var * 4, 1000);&#125;retransmit_timeout = rto;rto_timeout = ctx-&gt;current_ms + rto; QUIC的解决方案QUIC协议的一个非常不同的地方在于它虽然也是按照Packet编号的，但是它的编号是严格递增的。对于承载的流数据，QUIC提供了stream offset来维护其顺序和可靠性。 超时重传TCP的实现超时重传一般是设置一个超时重传定时器icsk-&gt;icsk_retransmit_timer，通过inet_csk_init_xmit_timers来注册。常用的超时方式有使用alarm信号、使用select、设置SO_RCVTIMEO和SO_SNDTIMEO字段、使用Linux提供的定时器（setitimer等）。但是在uTP的实现里面我并没有发现使用上面定时器的痕迹，这个定时器在哪里呢？我们首先找到uTP的超时重传实现，在void UTPSocket::check_timeouts函数里，而这个函数只被utp_check_timeouts调用。utp_check_timeouts是作为uTP的API函数，在应用程序ucat.c中，每次network_loop中的poll函数超时时，utp_check_timeouts就被调用。其实libutp框架更类似于一个个中断处理程序，而不是一个服务，它需要来自外部的信号才能驱动。下面我们来查看UTPSocket::check_timeouts这个方法。这个方法中出发了对坚持定时器zerowindow_time、重传定时器rto_timeout、保活定时器last_sent_packet和时间等待定时器rto_timeout（这里复用了）。首先查看最基本的重传定时器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283case CS_SYN_SENT:case CS_SYN_RECV:case CS_CONNECTED_FULL:case CS_CONNECTED:case CS_FIN_SENT: &#123; if ((int)(ctx-&gt;current_ms - rto_timeout) &gt;= 0 &amp;&amp; rto_timeout &gt; 0) &#123; // 这里删去了处理mtu探测的部分内容，移到专门的章节 // 这里删除了一段被注释了的重传次数大于4就重新计算rtt的策略 // Increase RTO const uint new_timeout = ignore_loss ? retransmit_timeout : retransmit_timeout * 2; // 这里防范恶意连接的情况，当第三次握手超时时就直接关闭连接 if (state == CS_SYN_RECV) &#123; state = CS_DESTROY; utp_call_on_error(ctx, this, UTP_ETIMEDOUT); return; &#125; // 这里删去了处理连接超时的部分内容，移到专门章节 retransmit_timeout = new_timeout; rto_timeout = ctx-&gt;current_ms + new_timeout; if (!ignore_loss) &#123; // 此时连接超时，ignore_loss只有当执行mtu探测任务时才为true duplicate_ack = 0; int packet_size = get_packet_size(); if ((cur_window_packets == 0) &amp;&amp; ((int)max_window &gt; packet_size)) &#123; // 这时连接处于闲置状态，并不急切需要重置拥塞窗口 max_window = max(max_window * 2 / 3, size_t(packet_size)); &#125; else &#123; // 此时延迟非常大，因此将拥塞窗口缩小到1个数据包，并开始慢启动算法 max_window = packet_size; slow_start = true; &#125; &#125; // 这个时候使用后退N协议全部重传 for (int i = 0; i &lt; cur_window_packets; ++i) &#123; OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(seq_nr - i - 1); if (pkt == 0 || pkt-&gt;transmissions == 0 || pkt-&gt;need_resend) continue; // uTP使用`need_resend`来描述一个包是否需要被重传。 pkt-&gt;need_resend = true; assert(cur_window &gt;= pkt-&gt;payload); cur_window -= pkt-&gt;payload; &#125; if (cur_window_packets &gt; 0) &#123; retransmit_count++; fast_timeout = true; timeout_seq_nr = seq_nr; OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(seq_nr - cur_window_packets); assert(pkt); // Re-send the packet. send_packet(pkt); &#125; &#125; // Mark the socket as writable. If the cwnd has grown, or if the number of // bytes in-flight is lower than cwnd, we need to make the socket writable again // in case it isn't if (state == CS_CONNECTED_FULL &amp;&amp; !is_full()) &#123; state = CS_CONNECTED; #if UTP_DEBUG_LOGGING log(UTP_LOG_DEBUG, "Socket writable. max_window:%u cur_window:%u packet_size:%u", (uint)max_window, (uint)cur_window, (uint)get_packet_size()); #endif utp_call_on_state_change(this-&gt;ctx, this, UTP_STATE_WRITABLE); &#125; if (state &gt;= CS_CONNECTED &amp;&amp; state &lt; CS_GOT_FIN) &#123; if ((int)(ctx-&gt;current_ms - last_sent_packet) &gt;= KEEPALIVE_INTERVAL) &#123; send_keep_alive(); &#125; &#125; break; 注意这里对于一个socket而不是一个数据包维护一个retransmit_count。下面查看时间等待定时器，这里并不需要等2MSL的时间，而是3*RTO和60之间的较小值。1234567891011121314151617// check_timeoutscase CS_GOT_FIN:case CS_DESTROY_DELAY: if ((int)(ctx-&gt;current_ms - rto_timeout) &gt;= 0) &#123; state = (state == CS_DESTROY_DELAY) ? CS_DESTROY : CS_RESET; if (cur_window_packets &gt; 0) &#123; utp_call_on_error(ctx, this, UTP_ECONNRESET); &#125; &#125; break; // utp_process_incomingif (conn-&gt;state != CS_FIN_SENT) &#123; conn-&gt;state = CS_GOT_FIN; conn-&gt;rto_timeout = conn-&gt;ctx-&gt;current_ms + min&lt;uint&gt;(conn-&gt;rto * 3, 60); utp_call_on_state_change(conn-&gt;ctx, conn, UTP_STATE_EOF);&#125; Fast retransmitFast retransmit虽然也是超时重传行为，但实际上是拥塞避免算法中的一部分。因此将在拥塞控制部分论述。 Selective Acknowledgment在TCP协议中使用SACK选项进行选择确认，使用若干组[start, end)来表示已经接受到数据的区间。SACK能够有效减少重传数据包的数量，对于带宽紧张的网络十分有用。不过需要注意恶意使用SACK对CPU资源造成的损害。在先前的数据包头构造部分已经提到了UTP的EACK机制，这是一个非常巧妙的方案，即用一个32位的比特串来表示从ack_nr + 2开始的32个未确认的包中有哪些是已经收到了在缓存里的，这里不从ack_nr + 1开始是因为我们可以默认这个包丢了，不然的话ack_nr就至少会到ack_nr + 1的值了。有关SACK的代码在UTPSocket::send_ack方法里面。1234567891011121314151617181920212223if (reorder_count != 0 &amp;&amp; state &lt; CS_GOT_FIN) &#123; // if reorder count &gt; 0, send an EACK. reorder count should always be 0 for synacks, so this should not be as synack assert(!synack); pfa.pf.ext = 1; pfa.ext_next = 0; pfa.ext_len = 4; uint m = 0; // reorder count should only be non-zero if the packet ack_nr + 1 has not yet been received assert(inbuf.get(ack_nr + 1) == NULL); size_t window = min&lt;size_t&gt;(14+16, inbuf.size()); // Generate bit mask of segments received. for (size_t i = 0; i &lt; window; i++) &#123; if (inbuf.get(ack_nr + i + 2) != NULL) &#123; m |= 1 &lt;&lt; i; &#125; &#125; pfa.acks[0] = (byte)m; pfa.acks[1] = (byte)(m &gt;&gt; 8); pfa.acks[2] = (byte)(m &gt;&gt; 16); pfa.acks[3] = (byte)(m &gt;&gt; 24); len += 4 + 2;&#125; 首先我们看到条件是reorder_count != 0 &amp;&amp; state &lt; CS_GOT_FIN，这表明在非连接建立/关闭时，当出现数据包乱序抵达时，启动EACK机制。ESAK是不允许Reneging的， 连接的异常终止重传失败在Linux中使用tcp_retries1 = 3和tcp_retries2 = 15（计算得到的一个时间戳）来限定普通包的重传次数。特别地，在握手时设有专门的tcp_syn_retries，这是由于对于连接建立时的重传需要精心设计以防止可能的SYN Flood攻击。在UTP中的重传失败机制比较简单。1234567891011if (retransmit_count &gt;= 4 || (state == CS_SYN_SENT &amp;&amp; retransmit_count &gt;= 2)) &#123; // 4 consecutive transmissions have timed out. Kill it. If we // haven't even connected yet, give up after only 2 consecutive // failed transmissions. if (state == CS_FIN_SENT) state = CS_DESTROY; else state = CS_RESET; utp_call_on_error(ctx, this, UTP_ETIMEDOUT); return;&#125; 连接重置保活定时器从TCP对长连接的管理上来讲，服务器通常会对其的对端启用保活定时器，以避免在对端意外崩溃下连接的浪费。我们看到TCP是非常珍惜服务器端的连接资源的，这还体现在TCP往往鼓励客户端主动关闭，从而让客户端而不是服务端等待2MSL。TCP规定当给定的连接在两个小时之内无任何动作，则服务器向对端发送探测包。根据客户端的状态会分为四种情况：1. 当客户端和网络都正常时，那么服务器能够得到正常响应，于是复位保活定时器。2. 当客户主机崩溃（关闭或重启中）时，客户端没有响应，服务器会等待10次75秒的超时，直到关闭连接。3. 当客户主机从崩溃中恢复后，服务器将受到来自客户端的RESET。4. 当客户端正常运行，但网络异常，类似网络分区状况，这种情况类似2。在libutp中设定了一个KEEPALIVE_INTERVAL 29000的阈值，表示29秒后会启动保活探测，它同时指出这个阈值来自对很多家庭NAT设备的计量。保活探测很简单，就是发送一个重复的ACK。1234567891011void UTPSocket::send_keep_alive()&#123; ack_nr--; #if UTP_DEBUG_LOGGING log(UTP_LOG_DEBUG, "Sending KeepAlive ACK %u [%u]", ack_nr, conn_id_send); #endif send_ack(); ack_nr++;&#125; 流量控制和拥塞控制流量控制着眼于接收端，保证发送端的发送速率能够匹配接收端的接受速率和缓存大小。流量控制包含滑动窗口rwnd、Nagle算法等。拥塞控制着眼于整个网络的性能，是当前发送端的速率匹配当前链路能承载的的限额。拥塞控制包含拥塞窗口rwnd、慢启动、拥塞避免、Fast retransmit和Fast recovery等。 标准TCP中的拥塞控制首先简单地讨论下TCP进行拥塞控制的原理。拥塞的发生一般有两个预兆，一个是超时，另一个是收到重复的ACK。这里重复的ACK来自于一个超出可靠传输协议的额外约定，也就是当我们收到一个失序的报文段时，我们仍然需要立即回复一个ACK给对方的，而这个ACK在对方看来肯定是重复的了。必须要说明的是，这两者的还可能是由分组损坏导致的对端的丢包，但是这种情况很少，所以我们并不考虑。在TCP协议中我们考虑发送方和接收方之间存在较多路由器以及较慢链路的情况。在滑动窗口协议的控制下，我们知道只要窗口未被填满，缓冲区有数据，我们就可以往对端发包。但当链路较为复杂时，我们就必须要考虑当流量过大时，中途某个路由器可能无法负担而直接丢包，诸如此类的情况实际上限制了TCP的吞吐量。为了解决这个问题，TCP首先提出了慢启动的算法。慢启动要求我们增加一个拥塞窗口cwnd，当连接刚建立时，我们设置cwnd为1个MSS的大小，并随着对方的每次的ACK而线性增大。注意在没有约束的情况下这实际上导致了指数增大的过程，例如一开始cwnd是1（个MSS），发送一个包，对方确认之后cwnd到2，我们现在可以最多发送两个包，接着我们真的发送两个包，对方确认后cwnd增长到4。我们能看到称为TCP自计时(self-clocking)的行为，也就是接收方返回的ACK的间隔和发送发送间隔趋于一致，我们可以从TCPIP详解（卷一）中看到一个详细的图示。这个原因是我们假设网络是对称的，并且也不考虑链路上出现的排队。当这个过程收敛后（出现拥塞或者达到慢启动阈值ssthresh），也就是发送方和接收方之间的管道被填满，此时连接饱和，无论拥塞窗口和通告窗口是多少都不能再容纳更多数据，此时只有一个包被确认，发送方才能再发送另一个包。我们看到“慢启动”其实一点都不慢。上面的慢启动过程以拥塞和达到阈值ssthresh（默认为65535）为结束，特别地，当cwnd超过ssthresh后需要执行拥塞避免算法。拥塞避免算法实际上将cwnd从慢启动的指数增长变为线性增长，也就是在一个RTT内只增大cwnd一次，对应到每个确认，我们只增加1/cwnd；而在慢启动中，该RTT中收到几个ACK就增加几次（注意cwnd是按字节计算的，由于成块数据流往往以MSS为单位发送，所以我们按照ACK来简化讨论，但合并的ACK并不影响）。一旦拥塞发生，拥塞避免会减半慢启动阈值ssthresh，然后拥塞窗口cwnd立刻变为1，重新开始慢启动算法。容易看到这个第二次开始的慢启动算法在达到原先阈值的一半就会停止并进入拥塞避免，这类似于用一种二分法的思路寻找稳定的承载量。下面我们看到一个称为快速重传和快速恢复算法的改进，这个算法要求对于由重复的ACK（至少3次）报告的拥塞，我们在减半慢启动阈值ssthresh后不进行慢启动，而是只将拥塞窗口cwnd下降到新的ssthresh处，并继续执行拥塞避免算法。还有一类被称为长肥管道的连接，它的带宽(bandwidth)乘以RTT的积很大，在这种管道上传输时由于时延高，往往出现窗口耗尽而报文还没送达对端的问题，对此可以使用扩大窗口选项解决。但丢包问题仍可能造成发送窗口收敛到很小，因此网络通信速度急剧下降。上面的快速重传与快速恢复能够部分地解决问题，但不管怎么样，吞吐率还是受到了影响。这时候使用SACK可以避免再重传对方已经收到的包，减少了冗余的ACK包。 TCP的其他拥塞控制算法上面一节讨论了标准TCP对于拥塞控制的一种“加性增、乘性减”的控制算法，该算法以最大化利用网络上瓶颈链路的带宽为目的，不断尝试更大的窗口直到丢包发生（从超时或者重复的ACK来监测）。该算法在应对长肥管道类型的连接时有一些注意点。此外，我们还需要注意到一个称为bufferfloat的问题。 BBR在前面的讨论中我们能够发现探测丢包是比较困难的一件事情，我们不仅需要间接地探测丢包事件，还要判断出丢包是来源于拥塞还是无效包（虽然无效包是一个较小的概率）。因此BBR算法放弃了从丢包角度的考虑，而是从带宽和RTT的角度进行考虑。 uTP拥塞控制概述uTP拥塞控制选择了丢包率和单向缓冲时延(one way buffer delay)进行度量。我们注意到在链路中存在一些设备能够缓存几秒钟内通过的数据，但uTP希望实现0字节的发送缓存。在实践中uTP的目标延迟在100ms，即当套接字侦测到自己发送数据包经受了100ms以上的延迟时，它就会调整拥塞窗口。下面我们查看相关逻辑的实现。在uTP报文头部我们可以看到tv_usec和reply_micro，通过这两个值uTP可以维护一个两分钟内的最小延迟值delay_base，我们将它作为两个服务器之间的延迟的基线，如果我们的实际延迟超过基线100ms，那么就认为网络发生了拥塞。delay_base在DelayHist::add_sample中更新，DelayHist使用数组cur_delay_hist维护所有delay值相对于delay_base的偏移。我们将在下面的时间测量部分继续讨论DelayHist的相关实现。在UTPSocket::apply_ccontrol中，首先取our_delay用DelayHist::get_value()获得的所有cur_delay_hist的最小值，注意由于没有样本时返回UINT_MAX，所以此时our_delay取RTT。12345678910// DelayHist::get_value()uint32 get_value()&#123; uint32 value = UINT_MAX; for (size_t i = 0; i &lt; CUR_DELAY_SIZE; i++) &#123; value = min&lt;uint32&gt;(cur_delay_hist[i], value); &#125; // value could be UINT_MAX if we have no samples yet... return value;&#125; 我们在套接字中定义一个target_delay默认为100000微秒即100毫秒，我们希望每个套接字发送端的延时不超过100ms。 uTP的窗口libutp定义了一些有关窗口的变量123456789101112131415// the number of packets in the send queue. Packets that haven't// yet been sent count as well as packets marked as needing resend// the oldest un-acked packet in the send queue is seq_nr - cur_window_packetsuint16 cur_window_packets;// how much of the window is used, number of bytes in-flight// packets that have not yet been sent do not count, packets// that are marked as needing to be re-sent (due to a timeout)// don't count eithersize_t cur_window;// maximum window size, in bytessize_t max_window;// max receive window for other end, in bytessize_t max_window_user; 其中cur_window_packets表示数据包的窗口，包含所有在发送队列的数据包，无论是否已经被发送，或者是否需要重传。因此最旧的未被对方确认的序号是seq_nr - cur_window_packets。UTP对cur_window_packets的限制是一定要小于OUTGOING_BUFFER_MAX_SIZEcur_window就是按字节算的通常意义上的窗口，在计算时不包含需要重传的包。max_window表示最大的窗口，它和max_window_user不同的是max_window还包含了拥塞窗口，而max_window_user来自对方，表示对方缓冲区的大小。下面的is_full判断从cur_window_packets和cur_window角度窗口是否饱和。123456789101112131415161718bool UTPSocket::is_full(int bytes)&#123; size_t packet_size = get_packet_size(); if (bytes &lt; 0) bytes = packet_size; else if (bytes &gt; (int)packet_size) bytes = (int)packet_size; size_t max_send = min(max_window, opt_sndbuf, max_window_user); // subtract one to save space for the FIN packet if (cur_window_packets &gt;= OUTGOING_BUFFER_MAX_SIZE - 1) &#123; last_maxed_out_window = ctx-&gt;current_ms; return true; &#125; if (cur_window + bytes &gt; max_send) &#123; last_maxed_out_window = ctx-&gt;current_ms; return true; &#125; return false;&#125; Fast retransmit当发送方连续收到3次相同的ACK，那么就重传可能被丢了的包。这里为什么是至少收到3次而不是2次是因为丢包情况下发送方至少会收到三次重复的ACK。从实现上看，有的快速重传选择只重传最初被丢的包，有的选择重传所有被丢的包。uTP使用duplicate_ack来记录收到重复ACK的次数。在utp_process_incoming函数中对duplicate_ack进行更新123456789101112131415161718192021if (conn-&gt;cur_window_packets &gt; 0) &#123; // 当ack_nr等于最后被对方确认的序号时，这里`conn-&gt;seq_nr - conn-&gt;cur_window_packets`等于第一个没被对方确认的包 if (pk_ack_nr == ((conn-&gt;seq_nr - conn-&gt;cur_window_packets - 1) &amp; ACK_NR_MASK) // 这里作者强调了当数据包带上了用户数据后，就不应该算入重复ACK中，这和BSD4.4 TCP实现是一致的 &amp;&amp; pk_flags == ST_STATE) &#123; ++conn-&gt;duplicate_ack; if (conn-&gt;duplicate_ack == DUPLICATE_ACKS_BEFORE_RESEND &amp;&amp; conn-&gt;mtu_probe_seq) &#123; // It's likely that the probe was rejected due to its size, but we haven't got an ICMP report back yet if (pk_ack_nr == ((conn-&gt;mtu_probe_seq - 1) &amp; ACK_NR_MASK)) &#123; conn-&gt;mtu_ceiling = conn-&gt;mtu_probe_size - 1; conn-&gt;mtu_search_update(); &#125; else &#123; // A non-probe was blocked before our probe. Can't conclude much, send a new probe conn-&gt;mtu_probe_seq = conn-&gt;mtu_probe_size = 0; &#125; &#125; &#125; else &#123; conn-&gt;duplicate_ack = 0; &#125; // TODO: if duplicate_ack == DUPLICATE_ACK_BEFORE_RESEND and fast_resend_seq_nr &lt;= ack_nr + 1, resend ack_nr + 1 also call maybe_decay_win()&#125; 报文分段MTU(Maximum Transmission Unit)，最大传输单元。通常地，以太网的MTU是1500，而IP是65535（包括头部），Internet的标准MTU是576。所以对于较大的IP包，如果在以太网上传输就需要进行分片。而TCP协议提供了MSS选项用来在建立连接时写上MSS大小，也就是TCP的最大的分段大小，超过这个MSS的数据就需要进行分段传输。MSS的协商在前两次的SYN握手时处理。而UDP是不带有分片功能的，所以对于较大的数据包是采用IP进行分片的。这其中带来一些问题，IP分片后只有第一个分片带有UDP头部，因此只要有一个IP数据报传输失败，那么整个UDP报文就无法交付（校验和和长度都通不过）。而IP协议本身并没有重传功能，且分片可能发生在链路上的任一路由器上，实际上根本无法知道原数据包是怎么被分片的。因此如果在UDP上层的实现要求重传（UDP本身不带重传），必须整个UDP数据报全部重传。所以说我们重新考虑UDP协议就会发现它头部的2字节的长度显得很不必要，因为根本不会发这么长的数据报。事实上按照TCP的按字节编码省掉一个长度字段也是方便的。因此我们基于UDP实现的传输层协议首先要做的就是避免IP层为我们分片，这样就能保证每个IP数据报中都要带有UDP头和我们的协议头，是个完整的传输层协议包。这就意味着我们需要让我们的基于UDP的协议的MSS + HEAD + UDP_HEAD + IP_HEAD小于可能的链路层的MTU。 MTU探测UTP通过截取ICMP Type3 Code4(fragmentation needed)来获得分片情况，即在IP首部设置了不可分片标志，但如果UDP报文达到MTU上限则会丢弃该IP报，返回ICMP不可达差错。UTP通过这个机制使用二分法来找到一个合适的MTU。在UTPSocket::mtu_reset函数中，预置了MTU搜寻空间为[576, udp_mtu]，也就是default IP maximum datagem size。不过由于以太网的流行，所以将576作为下限，此时对应于TCP的MSS为536。123456void UTPSocket::mtu_reset()&#123; mtu_ceiling = get_udp_mtu(); mtu_floor = 576; mtu_discover_time = utp_call_get_milliseconds(this-&gt;ctx, this) + 30 * 60 * 1000;&#125; 时间测量本章将详细讨论在前面拥塞控制等章节遇到的各类延迟的计算。 延迟测量在数据报报头的tv_usec和reply_micro两个字段用来测量延迟。发送端S设置tv_usec表示发送时间S1123// send_datauint64 time = utp_call_get_microseconds(ctx, this);b1-&gt;tv_usec = (uint32)time; 接收端R计算reply_micro表示接受时间R1与发送时间S1的差，粗略地估计了从S到R的经历的时间。注意由于两个主机的时钟不一定一致，所以这个值不精确。1234567// utp_process_incominguint64 p = pf1-&gt;tv_usec;// get delay in both directions// record the delay to report backconst uint32 their_delay = (uint32)(p == 0 ? 0 : time - p);conn-&gt;reply_micro = their_delay; 为了消除误差，UTP借助了NTP授时协议的机制。这里需要假设S与R之间的网络状况是对等的（这是一个很强的假设），即从S到R的速度不至于显著慢或快于从R到S的速度。这时候从R往S端发送一个回复的数据包，记录下这次的发送时间R2和接收时间S2。可以计算得到仅由网络原因造成的延时为$(S2 - S1) - (R2 - R1)$，还能得到S和R两个主机之间的时间差是$\frac{(R1 - S1) + (R2 - S2)}{2}$。12// send_datab1-&gt;reply_micro = reply_micro; DelayHist类型DelayHist记录了时间的延迟，具有以下的方法 shift 用来将所有的delay_base_hist向右偏移一段时间长度 clock drift问题由于UTP被用来实现一些BT下载软件，这个机制是UTP用来防止用户故意调慢时钟从而霸占带宽设计的，并且不会产生误报(False positive)。 uTP数据包统计在utp_context_stats和utp_context_stats中进行context和socket级别的统计。1234567891011121314151617// Returned by utp_get_context_stats()typedef struct &#123; uint32 _nraw_recv[5]; // total packets recieved less than 300/600/1200/MTU bytes fpr all connections (context-wide) uint32 _nraw_send[5]; // total packets sent less than 300/600/1200/MTU bytes for all connections (context-wide)&#125; utp_context_stats;// Returned by utp_get_stats()typedef struct &#123; uint64 nbytes_recv; // total bytes received uint64 nbytes_xmit; // total bytes transmitted uint32 rexmit; // retransmit counter uint32 fastrexmit; // fast retransmit counter uint32 nxmit; // transmit counter uint32 nrecv; // receive counter (total) uint32 nduprecv; // duplicate receive counter uint32 mtu_guess; // Best guess at MTU&#125; utp_socket_stats; 此外在utp_context中也维护了rst_info等信息。 序号溢出问题TCP中使用了32位的序号，并且具有PAWS机制防止在大带宽的情况下序号被迅速耗尽后产生回绕。如前文所展示的，在uTP的实现中利用了无符号整数的溢出来避免回绕时序号变为0的问题。12345678910111213141516// compare if lhs is less than rhs, taking wrapping// into account. if lhs is close to UINT_MAX and rhs// is close to 0, lhs is assumed to have wrapped and// considered smallerbool wrapping_compare_less(uint32 lhs, uint32 rhs, uint32 mask)&#123; // distance walking from lhs to rhs, downwards const uint32 dist_down = (lhs - rhs) &amp; mask; // distance walking from lhs to rhs, upwards const uint32 dist_up = (rhs - lhs) &amp; mask; // if the distance walking up is shorter, lhs // is less than rhs. If the distance walking down // is shorter, then rhs is less than lhs return dist_up &lt; dist_down;&#125;]]></content>
      <tags>
        <tag>网络</tag>
        <tag>UDP</tag>
        <tag>libutp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP套接字编程]]></title>
    <url>%2F2017%2F12%2F02%2FUDP-Socket-Programming%2F</url>
    <content type="text"><![CDATA[UDP协议是相对于TCP协议不是面向连接的，也是不可靠的，因此UDP套接字编程在思路上和TCP套接字编程很不一样。 普通的UDP套接字sentto函数和recvfrom函数sentto函数和recvfrom函数比面向连接（稍后并不仅指TCP）的send和recv函数多了flag和表示送达和接收地址的SA。容易看到这两个函数是适合UDP这样的无连接协议的。对于客户端来说，相当于将connect函数功能去掉，然后每次都显式传地址。对于服务端来说，它也不需要accept函数，每次recvfrom过来，它都可以取到这是从谁发过来的。甚至recvfrom的SA参数可以设为nullptr，这样表示我接受所有信息，不管是谁发的。注意recvfrom传入的最后一个长度参数必须是已经初始化后的。否则UDP函数返回的地址和端口都会是0。 普通的UDP套接字存在的问题异步错误上面这样的设计看起来似乎很好，但考虑当服务端进程未开启，那从客户端过来的UDP包是送不到的，这时候recvfrom阻塞了。UNP书中给出了echo服务的例子，需要注意的是在Ubuntu的终端中我们可以仍可以输入，但实际上线程是阻塞的。但是对客户端来说并不是这样，因为sendto函数是立即返回的（不返回也没有意义啊，毕竟无连接的，并不能指望对方一定会回复）。但对系统来说，这个包并不是就这么杳无音信的，因为服务端会发一个端口不可达的ICMP过来，可惜这个不会被客户端的进程接受（原因稍后论述）。并且这个ICMP是具有时延，所以它也不能被立即返回的sendto接受。这样的错误称为异步错误。BTW，注意ICMP本身也是不可靠的，可能会被丢掉。所以客户端存在收不到ICMP的情况，这可能是因为数据报根本没发过去，也可能是对方主机回复的ICMP丢了。TCP甚至有个专门的Duplicate ACK机制来解决“是发过去的包丢了还是返回的ACK丢了”的问题。 为什么对应进程收不到端口不可达的ICMP考虑刚才的recvfrom函数，假如说给recvfrom函数设置一个超时（Ch14.2），那么它就不会在端口不可达时永远陷入阻塞，此时我们考虑它的行为。假设一个多宿的UDP套接口（它可向多个IP发送数据包）向另外3个服务器发送了数据包，然后阻塞在reccfrom上等待回应。这三台服务器中前两台开启了相应的端口并给出了回应，但是第三台服务器是端口不可达的，因而对端回复了ICMP报文。按照直截了当的思路，内核应当把源IP和端口等信息写到recvfrom的SA * from参数里面，然后设置errno = -1，这样recvfrom就可以超时返回了，客户端对应进程也就能知道刚才的的一个sendto失败了。作者指出从逻辑上就是不现实的，这是因为在recvfrom函数的返回值里面不能知晓是自己发送的3个UDP包中发向哪个服务器的包出现了问题，导致自己收不到回应，因为返回的errno无法承载IP地址信息。不过讲得并不清楚。这是由于sendto函数调用后，它是立即返回的，此时内核已经释放了和对端套接字相关的数据结构，当端口不可达的ICMP过来时，内核无法追踪出对应的套接字了，所以它无法通知上层的应用。基于上面的两点原因，最好不要重复利用UDP套接口，也就是说将它连接到一个对端。因此对UDP也有了connect函数。重新考虑上面的问题，在connect的情况下，内核中记录了这个五元组(源IP, 源port, 宿IP, 宿port, 协议)的状态。如果对端传来了ICMP消息，内核可以取出ICMP中的端口号，然后根据记录的五元组找到相应的进程。因此进程就能收到这个错误，虽然还是异步的。 “连接的”套接字一个不面向连接的UDP套接字不能收到它引发的异步错误，除非它已经被connect。但这里的connect和TCP中的并不一样，它没有TCP中三次握手的过程，事实上它仅仅在内核中注册了一下，并未和对端服务器进行交互。此时应当使用write、send来代替sendto（硬要用sendto需要将第5个参数即宿地址设为nullptr），用read、recv、recvmsg来代替recvfrom，这是因为connect声明了我们的套接口只和某个ip:port进行交互了。已连接的套接字会忽略其他IP或端口传来的数据报。同理，断开UDP的“连接”也不需要进行四次挥手，而是直接用AF_UNSPEC参数再次调用connect函数即可。对于不同的POSIX系统，还有其他各不相同的方法。]]></content>
      <tags>
        <tag>网络</tag>
        <tag>UDP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据挖掘简易复习]]></title>
    <url>%2F2017%2F11%2F21%2F%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AE%80%E6%98%93%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[《数据挖掘》课程简易复习提纲，主要根据PPT整理。时间仓促，不排除存在部分内容爆炸。 IntroData Mining: process of semi-automaticlly analyzing large databases to find patterns that are: Valid: hold on new data with certainty Novel: non-obvious to the system Useful: should be possible to act on the item Understandable: humans should be able to interpret the pattern Data Exploration数据具有属性(attribute/feature)，属性可以分为Norminal、Binary、Ordinal或者Numeric的，也可以分为连续的或离散的。 度量数据度量中心度量中心的方式包括Mean平均数，Medium中位数和众数Mode。根据这三种数的位置关系可以分为symmetric和asymmetric(Positively skew和Negatively skew)两种 度量离散程度Quantile，常用的有四分位数，把Q3-Q1定义为IQR(Interquartile range)。在作业中还提到了absolute deviation，表示到中心点（median、mean、mode）的度量，等于$$\frac{1}{n} \sum^{n}_{i = 1}{|x_i - m(X)|}$$ 数据可视化包括直方图、Box Plots、散点图、康托图、Parallel Coordinates、Star Plots、Chernoff Faces Box Plots包含Upper/Lower Extreme、Upper/Lower Quartile、Median、Outlier和Whicker。Outlier离群点在后面会有专门一章讨论 Parallel Coordinates平行坐标将高维数据映射到一个N个纵坐标轴的折线，用于高维数据。类似的有Star Plots。 Dissimilarity matrix相异度矩阵 对Nominal而言$$d(i, j) = \frac{total - match}{total}$$ 对Binary而言令$q = (1, 1), r = (1, 0), s = (0, 1), t = (0, 0)$，分别表示对象$A$、$B$中属性值出现的四种对应情况的计数。 $$dissimilarity = \frac{r + s}{total} \\asymmetricBinaryDissimilarity = \frac{r + s}{q + r + s} \\Jaccard = 1 - asymmetricBinaryDissimilarity$$原因是$(1, 1)$和$(0, 0)$有时不能同等看待，例如有时$(1, 1)$非常罕见。 对Numeric而言曼哈顿距离（L1范数）和欧几里得距离（L2范数）分别是k为1和2的闵可夫斯基距离。$k \to \infty$是切比雪夫距离。 对Ordinal而言首先进行排序，得到$x_{i, feature}$对应的排行$rank_{i, feature}$（从1开始），然后把排行归一化。$$z_{i, feature} = \frac{rank_{i, feature} - 1}{total_{feature} - 1}$$ 混合属性$$d(i, j) = \frac{\sum_{feature}{exsit_{i, j} d_{i, j}}}{\sum_{feature}{exsit_{i, j}}}$$其中$d_{i, j}$：对Numeric是，相当于做个归一化$$\frac{|x_{i, feature} - x_{j, feature}|}{max_h(h, feature) - min_h(h, feature)}$$对Nominal是根据$x_{i, feature}$和$x_{j, feature}$是否相等取0或者1对于Ordinal是先根据排名进行标准化，再按照Numeric的方法计算 Data Preprocessingdata cleaning、data integration、data reduction和data transformation是数据预处理的基本任务。数据清洗包括缺失值、噪声、离群点和不一致问题的处理。数据集成包括对多种来源数据进行合并（实体识别），并处理其中的非一致和冗余数据。数据归约包含对维数和数量的归约。数据变换包括归一化、离散化和Concept Hierarchy Generation。 数据清洗处理缺失值忽略、人工填充、常数、填入全体中位数或均值、填入同类的中位数或均值、使用最可能的值填充（回归、贝叶斯算法等）。 处理噪声根据分箱(binning)、回归、聚类（检测离群点）分箱要求首先对数据排序，再划分为等频的箱，然后选择使用均值光滑（用均值替换箱中所有点）、边界光滑（用离自己最近的边界值替换）、中位数光滑等。这些光滑噪声的手段常也被用作离散化和数据归约。 数据集成可以通过相关性分析来检查数据冗余，例如对Nominal数据有$\chi^2$检验，对于Numeric数据有协方差和相关系数 $\chi^2$检验卡方检验可以描述两个向量$A[1..m]$和$B[1..n]$的相似程度。卡方检验的第一步是有一个数据集矩阵$M$，$M$中的元素$M_{ij}$，表示同时满足$A_i$和$B_i$性质的样本个数将矩阵填入一张表中，在表的最右端和最下端扩充一列/行，用来记录对应行/列的总和 首先计算$e_{ij}$，也就是对应的列和乘以行和除以总数$$e_{ij} = \frac{sum(B = b_i) * sum(A = a_j)}{sum(all)}$$ 将它填在括号里面，再对于矩阵中所有的单元格计算 $$\chi^2 = \sum_{m}{ \sum_{n}{ \frac{(x_{ij} - e_{ij})^2}{e_{ij}} } }$$ 皮尔逊相关系数协方差可以衡量两个变量的总体误差，方差可以看做两个变量相同时协方差的特例对于实数$X$、$Y$，定义协方差为$$Cov(X, Y) = E((X - \mathbb{E}(X))(Y -\mathbb{E}(Y)))$$对于向量$A$、$B$，定义协方差为 $$Cov(A, B) = E((A - \bar{A})(B - \bar{B})) = \frac{\sum_{i = 1}^{n}{(A_i - \bar{A})(B_i - \bar{B})}}{n} = E(A * B) - \bar{A} \bar{B}$$ 皮尔逊相关系数为 $$r_{A, B} = \frac{Cov(A, B)}{\sigma_A \sigma_B}$$ 注意这里分母标准差和分子期望中的$n$被约掉了，取值范围为$[-1, 1]$，等于0时变量独立，大于0时正相关，小于0负相关。注意相关性不暗示因果性。 数据归约小波分析主成分分析选取的主成分对应的坐标轴应当追求方差尽可能大 规范化数据 计算$k$个正交向量，即主成分。该过程可以对协方差矩阵求特征值和特征矩阵。 取出对应特征值最大的k个向量 标准化方法 min-max： $$ v’_i = \frac{v_i - min_A}{max_A - min_A} (newMax_A - newMin_A) + newMin_A $$ Z-score： 这里$\bar{A}$也可以替换成medoid或者mode等中心度量值，$\sigma_A$也可替换成absolute deviation$s$等离散程度度量值 $$ v’_i = \frac{v_i - \bar{A}}{\sigma_A} $$ demical scaling： $$ v’_i = \frac{v_i}{10^j} \quad where \\ \underset{j}{\mathrm{argmin}}(max(|v’_i|) &lt; 1) $$ Frequent ItemsetsFrequent Pattterns are patterns that appear frequently in a datasetsupport：$A$和$B$同时出现的概率$p(A \cap B)$，可以是绝对的即出现次数，可以是相对的，再除以事务数confidence：$p(B|A)$ = $c(A \cap B) / c(A)$频繁项集指的是支持度满足最小支持度阈值$min_{sup}$的项集闭频繁项集：$X$的任意超集$Y$的支持度不等于（小于）$X$的支持度极大频繁项集：$X$是频繁的，并且没有任何$X$的超集$Y$是频繁的 下面使用Apriori算法和FP-Growth算法来发现频繁$k$项集，注意我们不关注频繁$k+1$项集，尽管在过程中我们可以作为一个子问题得到它。 Apriori算法Apriori算法基于Apriori性质：频繁项集的子集一定是频繁的 使用Apriori生成频繁项集使用频繁项集生成关联项集 对于所有的频繁项集$l$，生成$l$所有的非空子集 对于$l$的每个非空子集$s$，输出规则$s \rightarrow (l - s)$，如果满足$p(l|s) \ge min\_conf$ Apriori优化方法 Hash-based itemset counting：hash到多个桶里进行初步删选 Transaction reduction：删去不包含任何$k$项集的事务 Partitioning：任何在DB中可能频繁的项集，至少在一个DB分区中是频繁的 这个性质很有意思，假设将数据集$D$分成了$n$个不重叠的部分$D_1, .. D_n$，下面证明任何在$D$中频繁（相对最小支持度为$s$）的项至少在$D$的一个部分$D_i$中频繁。 使用反证法证明。设有一个项集$x$在$D$中频繁。则有 $$ support\_count(x \in D) / |D| \ge s $$ 而$x$在$D_1, .. D_n$都不频繁，则有 $$ \frac{ support\_count(x \in D_i) }{ |D_i| } \lt s $$ 有 $$ \sum_{i = 1}^{n}{ support\_count(x \in D_i) } \lt s \, \sum_{i = 1}^{n}{ |D_i| } $$ 即 $$ \sum_{ i = 1 }^{ n } { \frac{ support\_count(x \in D_i) }{ |D| } } \lt s $$ 上面的式子就是 $$ n * support\_count(x \in D) / |D| &lt; n * s $$ 与假设矛盾 Sampling：在给定数据集的子集中挖掘，降低支持度要求，并采用一些方法确定其完整性 Dynamic itemset couting： FP-Growth利用FP-Tree生成频繁项集在建成FP-Tree后，从后往前生成频繁项集。以《数据挖掘：概念与技术(第3版)》为例，考虑最后的节点$I5$： 构造$I5$的条件模式基(prefix path sub-tree ending in $e$) 首先从$I5$的所有节点（可以是叶子节点也可以是内部节点，这里$I5$就都是叶子节点，而$I1$就有一个内部节点）往树根找到一条树链，将树链上的所有节点的支持度改为等于叶子节点$I5$的支持度 12&lt;I2, I1, I5 : 1&gt;&lt;I2, I1, I3, I5 : 1&gt; 接着提取出前缀路径，即条件模式基 12&lt;I2, I1: 1&gt;&lt;I2, I1, I3 : 1&gt; 使用条件模式基构造条件FP树 $I5$的条件FP树可以看做是原事务集中含有$I5$的所有项组成的集合，然后把里面的$I5$全部去掉 因此可以使用和构造FP树相同的办法 1&lt;I2, I1: 1&gt; 注意此时$I3$被去掉了，因为它在条件FP树上的的支持度为1，不满足2的最小支持度。实际上指的是$(I2, I3, I5)$这个项集的支持度不足。 查看$I5$是否是频繁项集（可以由简单计数得到） 如果$I5$是频繁的，找到所有以$I5$结尾的频繁项集 Basic Classification基本概念训练集、测试集 决策树决策树分为树枝，表示对特征测试的结果，由此产生子节点。子节点分为内部节点和叶子节点，叶子节点展示所属类的标签，内部节点展示被测试的特征决策树不需要领域知识和数值参数，能够处理多维数据，学习结果直观在设计决策树算法时需要考虑：如何确定特征测试条件（二类划分还是多类划分等）从而获得最佳切分（考量homogeneous/purity），什么时候可以终止切分（同类、早停）如果决策树的一个节点下只有一个类，这个节点就是pure的 节点的信息熵假设数据集$D$可被分为类$[1..n]$，定义节点$t$下的数据属于类$j$的条件概率是$p(j|t)$，即$$P(X = j) = p(j|t)$$由此可以定义信息熵为$$info(t) = entropy(t) = H(t) = -\sum_{j = 1}^{n}{p{(j|t)}\,log\,p(j|t)}$$ 信息熵能够描述节点的homogeneity，当熵最大（$=log\,n$）时意味着随机性越大，信息也就越少；当熵最小（=0）则相反。所有数据从根节点可以通过所属的类分为$n$部分，这种关于类别的信息熵称为数据集的经验熵，如果不利用特征建立决策树，我们只能根据经验熵得到一个数据所属类别的概率。 $$H_{j}(D) = - p(j)\,log\,p(j) \\H(D) = \sum_{j = 1}^{n}{ H_{j}(D) }$$ 也可以定义关于特征$A$的信息熵，其中特征$A$取值为$[1..n_A]$ $$H_{A}(D) = \sum_{j = 1}^{n_A}{ H_{j}(D) }$$ 信息增益、信息增益比和基尼指数决策树生成是一个递归的过程，通过测试父节点$t$的特征$A$，将其划分为$k$个子节点，其得到的经验条件熵要小于等于父节点集合的经验熵，产生的差值为信息增益。这是符合直觉的，特征$A$的信息应当能够减少分类的不确定程度。其中$n_i$表示特征$A$取值为第$i$种时对应的数据集大小，也可写作$|D_i|$，显然$D_1 + D_2 + .. + D_n$ $$Gain_{split} = H(t) - \sum_{i = 1}^{k}{\frac{n_i}{n} H(i)}$$ 不过信息增益容易将结果分为很多个小类，因此提出了信息增益比的概念 $$GainRatio_{split} = \frac{Gain_{split}}{ H_{A}(D) }$$ 基尼指数是用来度量impurity的，例如在节点$t$上。基尼系数熵之半的函数图像差别不大，但是计算要简单很多，所以很常用 $$Gini = 1 - \sum_{j = 1}^k{p(j|t)^2}$$ 使用基尼系数分类具有相似的规则，同样是为了使得“增益最大”，所以可以求下面式子的argmax $$Gini_{split} = Gini(t) - \sum_{i = 1}^{k}{\frac{n_i}{n} Gini(i)}$$但通常而言是直接求argmin $$Gini_{split} = \sum_{i = 1}^{k}{\frac{n_i}{n} Gini(i)}$$ 当数据是均匀分布在所有类上时，基尼系数取最大值$1-1/n$，当数据值集中在一个类上时（更为有趣的信息），基尼系数取最小值0。 决策树训练由周志华教授的《机器学习》P77，当信息增益出现平票时可以任意选择。此外还有一种情况，当最后没有其他属性，只能进行多数表决时，出现平票也是随便选。 欠拟合与过拟合欠拟合表现为模型太简单，训练集误差(Re-substitution errors)和泛化误差(Generalization errors)都很大。过拟合表现为模型对新数据的泛化能力较弱，模型过于复杂。为了估算泛化误差，可以使用Reduced error pruning方法，即使用验证集来估算。奥卡姆剃刀法则，复杂的模型有更大的几率是拟合了数据里面的误差，因此在选择模型时应当考虑模型复杂度。常用的解决过拟合的办法有早停策略，对于决策树来说可以在决策树彻底生成前停止算法，即预剪枝；还可以在决策树生成后进行处理，例如后剪枝。 缺失值处理贝叶斯分类器朴素贝叶斯算法相对决策树和部分神经网络算法要快，对于大数据更准确，基于贝叶斯定理$$P(H|X) = \frac{P(X, H)}{P(X)} = \frac{P(X|H) P(H)}{P(X)}$$ 其中$X = (x_1, …, x_n)$是数据集中的一个向量，$H$是有关分类的假设，例如$P(C_i|X), i \in [1, m]$表示$X$为类$C_i$的概率。$P(H|X)$是后验概率，$P(H)$是先验概率。对于未知向量$X$，朴素贝叶斯算法要求找到最大化$P(C_i|X)$的类$C_i$$$P(C_i|X) = \frac{P(X|C_i) P(C_i)}{P(X)} \quad for \, i \in [1, m]$$其中$P(C_i)$来自先验假设或根据数量统计得到，$P(X)$也是先验的，是个常数，所以有的时候并不考虑这个分母。在Class conditional independence假设下，$P(X|C_i)$计算变得简单很多，只需要对$X$中的每个属性$x_k$分别计算即可$$P(X|C_i) = \prod_{k = 1}^{n}{P(x_k | C_i)}$$例如计算$P([rain, hot, high] | Yes)$，就可以计算$$P(rain | Yes) \, P(hot | Yes) \, P(high | Yes)$$然后可以得到$$P(Yes | [rain, hot, high]) \propto (P(rain | Yes) \, P(hot | Yes) \, P(high | Yes)) P(Yes)$$ 分类评估我们定义$TP$、$TN$、$FP$、$FN$分别为真正例、真反例、假正例、假反例。这里$T$、$F$表示预测和真实值是否相同，$P$、$N$表示我们的预测结果是正例还是反例。令$U = TP + TN + FP + FN$为样例总数由此可以派生出一系列评价指标：accuracy/recognition rate是所有的$T$比上总数$U$；error rate是所有的$F$比上总数$U$。衡量了整个分类器在正反例上的准确度。查准率precision是$TP$比上预测结果中所有的$P$($ = TP + FP$)，也就是所有预测的正例中正确的比率。查全率、敏感度recall为$TP$比上真实情况下所有的$P$($ = TP + FN$)，也就是所有正例中被预测出的比率specificity是$TN$比上真实情况下所有的$N$，也就是所有反例中被预测出的比率$F_1$值为precision和recall的调和平均 Holdout方法包括交叉验证和留一法 Alternative Classification支持向量机神经网络Lazy Learning集成学习Basic Clustering聚类分析包含Partitioning、Hierarchical、Density-based和Grid-based方法。 k-meansk-means的目的是最小化簇内方差$$E = \sum_{i = 1}^{k}{ \sum_{p \in C_i}{EuclideanDistance(p, c_i)^2} }$$这个问题是NP难的，k-means使用的贪心的方法不保证最优解，其步骤是： 选择$k$个簇的中心 将数据点分配到距离最近的中心对应的簇 使用每个簇中点的均值更新中心 重复2-3直到收敛 初始值确定一般可以取$k = \sqrt{n/2}$，或者使用Elbow method$k$值确定后可以使用Sampling或Pick “dispersed” set of points（选择到已选点最小距离最大的点）方法来取出$k$个中心点 由此可以看出k-means方法对初始化很敏感。并且有的数据是没有定义均值的，这时候可以选择使用k-modes。此外k-means对离群点和噪音和敏感。 对于大数据集，可以采用采样、micro-clusters、additional data structure来实现scalability k-medoids和PAM方法由于k-means对噪声很敏感，所以引入了k-medoids，它并不是用均值，而是用数据集中的一个代表点来表示集群的中心 $$E = \sum_{i = 1}^{k}{ \sum_{p \in C_i}{EuclideanDistance(p, o_i)^2} }$$如上式，$o_i$是簇$C_i$的代表点。该算法流程如下： 选取$k$个代表点 尝试使用非代表对象$o_{random}$替换代表点$o_1 .. o_k$，假设正在替换某代表点$o_j$，则更新其代价函数 对于所有的对象重新进行分配，并计算交换总代价。如果总代价小于0，则接受这次替换，否则维持$o_j$不变 对于大数据可使用CLARA、CLARANS等方法 agglomerative clusteringdendrogram图，类似一个从底部构建的二叉树。Hierarchical Clustering的优点是不需要预测簇的数量，并且往往能和一些分类学的知识建立联系。agglomerative方法是自底而上地不断merge，divisive方法是自定而上的不断split基础的算法应用一个proximity matrix描述两个簇之间的相似度 agglomerative的方法也有缺陷，例如簇之间merge的结果不能取消，没有像kmeans一样针对目标函数优化，三种簇间距离的度量方法各有缺陷 度量两个簇之间的距离 两簇间最相近的两个元素的距离：对噪声和离群点敏感 两簇间最相异的两个元素的距离：减少了集群半径的增加，容易打破大的集群 每个点对间距离的平均：对噪声和离群点不那么敏感，Biased towards globular clusters divisive clustering和最小生成树DBSCANDBSCAN是基于密度的方法，将所有的点分为三类 Core 在集群中，且neighborhood是dense的（Eps-MinPts条件） Border 在集群中，但neighborhood不dense Outlier 不在集群中 可以做出下面的讨论 从$q$直接密度可达$p$ 当$p$在$q$的Eps-neighborhood内，并且$q$是一个Core 从$q$密度可达$p$ 存在对象链$p_1, .. , p_{n-1}, p$，其中$p_{i+1}$直接密度可达$p_i$ $p$和$q$密度连接 存在一点$o$从$p$和$q$都密度可达 因此算法流程如下： 标记所有节点为未读 选取随机未读节点$p$并标记 如果$p$是一个Core，则包含所有密度可达$p$点的点$p’$建立一个新的簇 如果$p’$未访问，把$p’$加入簇，并递归。 如果$p’$已访问，但不属于任何簇（之前被标记为噪音了），把$p’$加入簇。 通过以上的两点可以保证点$p’$如果在Eps-neighborhood内有一个Core点$q$，那么即使$p’$本身不是Core，在一开始被划为Noise，最后也能正确地被分到对应的簇中。 否则标记$p$为噪声 DBSCAN对参数取值敏感 OPTICS聚类评估Clustering Tendency数据集是否根据一个均匀分布产生的Hopkin Statistics Cluster Quality外在方法外在方法通过把聚类(cluster, $C$)和基本事实(catagory, $L$)比较 Cluster Homogeneity：簇的纯度 Cluster Completeness：如果在基于基本事实，两个对象属于同一catagory，那么他们应当属于同一个簇 Rag bag：翻译叫碎布袋，即一个异类的对象最好放入碎布袋中，而不是放入纯的簇中 Small cluster preservation：将小catagory再分成碎片是非常有害的，因为它使得这些小簇可能成为噪声 BCubed precision： Correctness：等于1如果$L(o_i) = L(O_j) \Leftrightarrow C(o_i) = C(O_j)$ BCubed recall BCubed precision 内在方法内在方法通过比较簇之间分离的优劣轮廓系数Silhouette coefficient，定义$a(o)$为对象$o$到所属簇中其他对象之间的平均距离，定义$b(o)$为$o$到$o$不属于的所有簇的最小平均距离。则$$s(o) = \frac{b(o) - a(o)}{max(a(o), b(o))}$$ Alternative Clustering高斯混合模型在Fuzzy clusters和Probabilitic-model based clustering中，一个对象可以属于多个簇，按照对应的概率。高斯混合分布属于生成模型，它可以描述数据是如何从模型中产生的。 EM算法：E步骤EM算法：M步骤Biclustering对于高维数据，传统的基于距离的方法，例如基于欧几里得距离的方法是不可信的，容易被多个维度的噪音所掩盖。因此高维数据的聚类常常是用一小组属性来定义的。常见有两种高维聚类的方式，第一类是Subspace clustering methods，在高维数据的一个子空间里面搜索聚类，常见的有Biclustering；第二类是Dimensionality reduction approaches，构造一个更低维数的空间，并且在那个空间里面搜索聚类，例如Spectral Clustering Clustering with constraintsOutlier Analysis离群点，相对于normal/expected data，是指距离其他对象显著远的对象。离群点不是噪音，噪音是没有研究价值的，类似于random error或者variance离群点分为全局离群点（相对于其余数据）、情景离群点（相对于某些特定context的数据）和集体离群点。对集体离群点来说，里面的点单个考虑可能就不是离群点了。 统计学方法参数法之Univariate Outlier DetectionUnivariate Outlier Detection假设数据仅对一个指标服从正态分布。然后就可以使用3$\sigma$原则来检测一维离群点了（不过为啥要用极大似然估计呢）。还可以使用之前学过的box plot来进行可视化估计，认为在$Q1 - 1.5 \, IQR$以下和$Q3 + 1.5 \, IQR$要上的点都是离群点还可以使用Grubb’s检验（最大标准残差检验），与z-score有关 参数法之Multivariate Outlier DetectionMahalanobis距离方法$\chi^2$统计量 参数法之混合参数分布非参数法之直方图非参数法之Kernel Density Estimation(KDE)基于邻近性的方法距离方法网格方法密度方法MapReduceCluster Computing架构：backbone between racks和rack between nodesMapReduce是一种批处理算法，核心思想是Bring computation to data和Store files multiple times for reliability。 Mining Streaming data流处理查询主要有两种类型：Ad-hoc查询和Stading查询 流数据取样Bloom Filter我记得之前柳晗就和我讨论过这个算法。布隆过滤器用来检测一个数是否在集合中，对于确定性的方法而言，这通常意味着对$log(n)$的时间复杂度进行常数优化，或者对哈希函数和哈希方法进行优化。但无论如何，空间开销是免不了的。布隆过滤器牺牲了准确性，他可能造成FP假阳性，即可能认为没出现过的数出现过，但换来了空间性能的提高。算法思想很简单，将$n$个输入送给$k$个哈希函数$h_1, .., h_k$，哈希函数的计算结果将依次按位或到一个长度为$n$的bitset中，因此这个bitset中的某一位只能从0变成1。例如，假设此时bitset为$b_i$，现对于新输入$x$，判断是否出现过。然后把$x$依次送入$k$个哈希函数，如果$h_j(x) = a$，则将第$a$位设为1。注意到如果此时第$a$位为0，则说明$x$肯定没出现过，但反之不一定成立。 例如，假设此时bitset为$b_i$，现对于新输入$x$，判断是否出现过。创建一个新的bitset为$b_{i+1}$，并memset为0，然后把$x$依次送入$k$个哈希函数，将哈希的结果按位或到$b_{i+1}$上。接着比较$b_i \&amp; b_{i+1}$。如果不等于$b_{i+1}$，那么肯定没有出现过。但是如果相等，并不一定就真的出现，可能两个数对$k$个哈希函数的输出都一样。 Bloom Filter算法分析Bloom Filter时间空间复杂度相对于数据规模是常数，因此主要分析出现FP的概率。FP的概率与1的密度有关，显然1越多，越容易出现碰撞，因此可以表示为$a^k$，其中$a$表示此时1占的比例，不过碰撞概率是要略低于这个值的。我们还可以这样理解，把FP的概率近似看做对元素$x_i$哈希后输出的$k$个位置上都是1的概率$p_1$（当然有可能是重复了）。为了方便计算，我们实际考虑截至$x_i$，某一位仍然是0的概率$p_0 = 1 - p_1$。将任意一位从0变为1的概率相当于将$d$和飞镖随机扔向$t$个目标，这里的$d$相当于所有的$n$个输入通过$k$个哈希函数得到的$nk$个结果，$t$相当于bitset。目标$T_i$被指定飞镖集中的概率是$1/t$，因此所有的$d$个飞镖都没有击中目标$T_i$的概率就是$(1 - 1/t)^d$，由于$t$通常很大，可以将其改写为$e^{-d/t}$（重要极限）。 Bit Counting和DGIM算法对一个01串，在线回答问题最近的$k &lt;= N$位中有多少个1。朴素的方法需要$O(N)$的空间，每次查询需要花费$O(k)$的时间。DGIM算法能够只储存$O(log^2N)$位，在$O(log N)$的时间复杂度内给出一个大概的值，误差在50%以内，并可以进一步缩小到任意eps。算法思路是维护一个容量为$N$的线性队列，从队尾到队头按照1的个数将其划分为$m \approx O(log_2N)$个桶，每个桶中分别有$2^0, 2^1, .., 2^m$个1（0的数量不考虑）。为了方便讨论，定义桶的大小是桶里面1的数目。因此我们容易看出这个线性队列具有下面的性质： 每个桶的最右（靠近队尾）端总是1 所有的1都在某个桶中；但是0不一定，可能在桶间 每种大小的桶最多容忍有两个 下面使用该线性队列回答开始的问题：通过比较每个桶两端的位置与$k$的大小，找到$k$值所在的桶$b$，累加$b$右边所有桶的大小及桶$b$的一半大小，即为估计值。下面考虑如何维护该线性队列，考虑接受一个新比特时 首先弹出队头，并更新队头所属的桶（如果属于某个桶的话），如果此时桶里已经没有1了，就删除这个桶 如果新比特是0，则不做任何处理 如果新比特是1，则从右至左检查是否破坏性质每种大小的桶最多容忍有两个，并进行合并处理 DGIM算法分析首先可以看到我们实际上不要将整个线性表存下来，我们只需要记录每个桶两端的坐标即可，这样的坐标有$O(log_2N)$个。对于每个坐标，他的值域是$[0, n)$，因此我们需要$O(log_2N)$比特来表示它。注意由于$N$很大，所以不能理解成一个坐标用一个$O(1)$的常数空间（例如int）就好。下面分析DGIM误差的上下界 流数据聚类和BDMO算法Recommendation SystemContent Based方法注意物品的属性，协同过滤方法注意物品与用户的关系 TF.IDF$f_{ij}$为term$t_i$在文档$d_j$中出现的频率定义$TF_{ij} = f_{ij} / max_k(f_{kj})$$n_i$为出现term$t_i$的文档数定义$IDF_i = log \frac{N}{n_i}$由此可以计算得到$TF.IDF = TF_{if} * IDF_i$ Content FilteringContent Filtering首先对每一个item建立profile，这里的profile指的是一组属性。使用余弦相似度衡量user profile$c$和item profile$s$。$$u(c, s) = cos(c, s) = \frac{c.s}{|c||s|}$$这种方法的缺点是过于专门化，它从来不推荐在user’s content profile外面的item，并且人们可能具有多个兴趣爱好。此外需要有效的办法去查找high utility的items，也就是相似度高的profile，这时候可以借助于Locality Sensitive Hashing。 Collaborative Filtering协同过滤算法的基本思路是对于用户$c$，找到其他用户组$D$和$c$的对所有item的交集给出的评分相近，然后对于新的item，基于$D$的评分估计$c$的评分。设$x$的评分向量为$r_x$，那么$x$，$y$的相似度可以用余弦相似度衡量$cos(r_x, r_y)$，也可以计算$sim$的的皮尔逊相关系数（仅对$x$、$y$都评分项计算）下面使用协同过滤算法进行预测$c$给item$s$的打分。在给item$s$打分的用户里面找出$k$个最接近用户$c$的用户，令为$D$。则$$r_{cs} = \frac{1}{k \sum_{d \, in \, D}{r_{ds}}} \\r_{cs} = \frac{ \sum_{d \, in \, D}{sim(c, d) \, r_{ds}} }{ \sum_{d \, in \, D}{sim(c, d)} }$$协同过滤算法的计算$D$是比较昂贵的，对于每个用户，需要线性的时间。此时我们可以同样借助Locality Sensitive Hashing。此外可以使用MapReduce来计算协方差矩阵，我记得当时参加第一节云计算大赛的时候的技能题就有一条是这个。刚才的算法是基于用户的，user-user协同过滤，也有item-item协同过滤，对于item$s$，找到相似的items，当然这里还是使用对相似item的rating而不是对用户的rating，因此可以使用相同的矩阵和预测函数。在实践上item-item的常优于user-user的。 Locality Sensitive Hashing在之前提到的两种算法中提到了Locality Sensitive Hashing这个算法可以用来快速的找到高相似度的向量对（例如各种profile）Locality Sensitive Hashing属于一种Approximate Nearest Neighbor Search方法Locality-sensitive family是一组可以组合起来将向量按相似度区分开的函数。这些函数在统计上是彼此独立的。他们的速度要比遍历所有向量对来得快，并且能够被组合起来解决FP和FN问题。 $(d_1, d_2, p_1, p_2)$敏感表示： 如果$d(x, y) \le d1$，则$h(x) = h(y)$的概率至少为$p1$ 如果$d(x, y) \ge d2$，则$h(x) = h(y)$的概率至多为$p2$ AND、OR of Hash functions给定family$H$，从$H$中选择$r$个函数构造family$H’$。对于$H’$中的$h = [h_1, .., h_r]$： $h(x) = h(y)$当且仅当对于任意的$i$都存在$h_i(x) = h_i(y)$ 这是AND构造，指的是这$k$个哈希值里面要全部相同，才会被投影到相同的桶内 AND操作能够使得保持$p1$较大时$p2$更小，即降低FN 相应的定理是如果$(d_1, d_2, p_1, p_2)$敏感的，那么$H’$是$(d_1, d_2, p_1^r, p_2^r)$敏感的 $h(x) = h(y)$当且仅当对于存在一个以上$i$使得$h_i(x) = h_i(y)$ 这是OR构造，指的是这$k$个哈希值里面有一对以上相同，就会被投影到相同的桶内 OR操作能够使得$p1$较小时$p2$更大，即降低FP 相应的定理是如果$(d_1, d_2, p_1, p_2)$敏感的，那么$H’$是$(d_1, d_2, 1-(1-p_1)^r, 1-(1-p_2)^r)$敏感的 Amplify LS family考试内容2017 列出数据的种类（Nominal等）。解释Mean、Medoid等。 简述缺失值处理方法。简介PCA。 简述支持度等概念。证明Apriori性质。 比较Apriori和FP-Growth的性能。使用Apriori计算频繁项集。 为什么Naive Bayes是Naive的。如何基于Gini系数构建决策树。 使用BP计算神经网络 k-means有哪些缺点。DBScan。什么是dendrogram，如何度量两个簇的距离 协同过滤和内容过滤的区别是什么。什么是$(d_1, d_2, p_1, p_2)$敏感。证明（类似Excecise 2）。]]></content>
      <tags>
        <tag>数据挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Kickstart 2017 Round C题解]]></title>
    <url>%2F2017%2F11%2F14%2FKickstart2017C%2F</url>
    <content type="text"><![CDATA[C轮感觉比校招笔试轮次的DE要简单点了，这次有四道题都很有意思。 A. Ambiguous Cipher题目就是要解一个模意义下的线性方程。由于加减乘对模运算是封闭的，所以可以直接解。注意解下来的结果还要模一下26。用numpy搞了一波，特判下奇异矩阵，对应无穷多解的情况。AC代码 B. X Squared一开始找规律觉得只要除了允许其中一行和一列拥有一个叉，其他的每个行列必须有且只有两个叉。结果果断WA了，对拍下看看 5 .X..X ...XX XX... ..X.. X..X. 上面的这个样例输出POSSIBLE，但实际上却是IMPOSSIBLE的，看来我的条件只是必要条件。还能加上啥条件呢？初等变换得到的矩阵都是等价的，不过看来这性质用不上。然后发现之前的性质挖掘不彻底，事实上矩阵在任意行列互换后位于同行/列的元素依然位于同行/列，于是矩阵中一定存在两行中的两个X的距离是相等的。果断又WA了，后来发现不仅距离要相等，而且是要平行的。AC代码 C. Magical Thinking小数据$N=1$，感觉是送分啊。直接看大数据，$N \le 2$。想了一会儿方程，发现是DP。其实思路很简单，$dp[i][r1][r2]$表示到第$i$个题目前同学1对了$r1$条且同学2对了$r2$条时自己可能获得的最多分数。根据$N$取值可以分别分4、2种。而得分$s[0..1]$的作用就是当$r1 \ge s[0]$时他这条就不能再对了。但是代码在小数据上都卡了很久。最后发现原因是出现了dp[2][6]这样的值，为什么进行到2的时候能对6个呢？将里面r1的循环改成了r1 &lt;= min(s[0], i)，就AC了。AC代码 D. The 4M Corporation]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>codejam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++内存对齐与多态]]></title>
    <url>%2F2017%2F11%2F08%2FC%2B%2B%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[最近在看Inside the C++ Object Model，一种日经面试题，求sizeof(A)12345678910struct A&#123; char c; int i; long long ll; int j; virtual void f()&#123;&#125;;&#125;;struct B&#123;&#125;; 这种题目其实考的知识点很多，包含了虚函数虚继承、内存对齐等一系列C++的语言特性。 普通情况下的align和padding首先，int长度是不固定的，与编译器和平台有关，所以首先可以回答“不知道”。但假设是按“通常情况来计算”，于是埋头苦算。恩，出现了虚（包括构造、析构）函数就要创建虚表，在对象中会储存一个虚指针vptr，根据指令集字长定。这里可以考虑为4。但下面不能简单相加了，在实际输出下，答案是32。究其原因是C++的内存对齐机制，对齐要求来自于一些CPU的架构、编译器或者系统设计上的考虑，在对齐的存储下，有些存储操作是原子的，所以可以很快。根据标准，对齐应该遵守下面的规则： 每个成员应该对其到它的大小，即开始位置应当能够被其size整除 整个struct按最大成员大小进行对齐在对齐的情况下，对象的大小也会改变。根据Inside the C++ Object Model Ch1.3中的注解，一个class object的大小包括其non-static data members的总大小，加上保持alignment时需要padding上去的空间（在members之间以及在objects之间），以及维持虚函数等的开销。因此上面的结构等价于12345678void * vftable; // 4char c; // 5char gap[3]; // 8int i; // 12char gap[4]; // 16long long ll; // 24int j; // 28char gap[4]; // 32 根据Inside the C++ Object Model Ch3.1，一个空的struct仍有1字节，这是为了保证其实例化得到的所有对象能在内存上拥有自己独有的地址，我们发现这里没有为这个空的struct加上padding。但正如下面即将看到的一样，这个1字节在使用虚继承时可以被去掉。 虚继承下的align和padding下面我们看看复杂一点的虚继承。为了避免在菱形继承中A出现两份的X拷贝，进而出现二义性的问题，可以使用虚继承。虚继承中对于给定的虚基类，无论该类在继承体系中作为虚基类出现了多少次，只继承一个共享的基类子对象，这样菱形继承中的二义性问题也能够解决了（但普通多继承并没有解决）。下面看看Inside the C++ Object Model上的这段菱形继承代码，它的大小如何？1234class X&#123;&#125;;class Y: public virtual X&#123;&#125;;class Z: public virtual X&#123;&#125;;class A: public Y, public Z&#123;&#125;; 作者指出应当为1 8 8 12，但也同时指出有些编译器（译者指出例如MSVC）会产生1 4 4 8。首先X有1的开销这是毫无疑问的。下面的Y大小为8。首先Y虚继承了X，所以还需要一个4字节的指针，指向虚基类的X大小为1字节的子对象。这是类似于vftable指针的机制，称为vbtable指针。然后X的1字节的占位符也被继承下来到了Y对象中，这里译者的图应该错了，不然没有办法解释后面A也能算空类，为啥不给A加上1字节。最后，我们为已有的5字节加上3字节的padding，总共有8字节。考虑A，它拥有12字节，这包括Y和Z的子对象中除X以外的部分，各4字节（注意不是8字节，由于X被共享了，这也是虚继承的核心思想）。现在在加上被共享的X的1字节，共9字节，加上padding共12字节。Inside the C++ Object Model指出此时A自己的大小是0字节。MSVC优化掉了空类X占用的1字节开销，这样Y最后的3字节的padding也不需要了，因此只保留了一个指针。 虚函数+虚继承虚函数和虚继承可能同时出现。 控制对象对齐方式对齐要求源自CPU的一些指令需要传入的地址满足能整除某个值。 C语言中的规定有的时候我们需要禁用对齐功能，例如我们需要将某个struct按照二进制格式进行传输或者存储，这时候我们需要严格的、紧缩的大小，而不是加上一个和具体对齐方式有关的padding占用空间。在g++中可以通过__attribute__((__packed__))来禁止编译器进行优化对齐。packed属性可能是不安全的，因为它会导致非对齐访问。注意这里要区分packed和aligned，aligned(x)强调的是我对象所在的地址应当至少以x字节对齐，为了对齐会导致padding的加入，从而改变内存布局。packed会禁用padding。因此会产生__attribute__((packed, aligned(4)))这样的奇怪用法。 C++11标准中的规定C++11提供了一系列控制对齐的功能std::alignment_of是标准库对alignof的封装，具有size_t类型12345template&lt;class _Ty&gt; struct alignment_of : integral_constant&lt;size_t, alignof(_Ty)&gt; &#123; // determine alignment of _Ty &#125;; 指针与对齐考虑一个多继承的情况12345678910111213141516171819202122struct BA&#123; int a;&#125;;struct BB&#123; double b;&#125;;struct D : public BA, public BB&#123;&#125;;int main()&#123; D d; D d2; D * pd = &amp;d; B1 * pb1 = &amp;d; B2 * pb2 = &amp;d; int * pi = reinterpret_cast&lt;int*&gt;(&amp;d); pd == pb1; // true，指向同一对象 pb1 == pb2; // CE，虽然指向同一对象，但两个指针类型都不等于对象类型（即使有继承关系） pi == pd; // CE，虽然指向同一对象，但两个指针类型都不等于对象类型&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Kickstart 2017 Round E题解]]></title>
    <url>%2F2017%2F11%2F06%2FKickstart2017E%2F</url>
    <content type="text"><![CDATA[E轮是Google的校招笔试轮次了。 A. Copy &amp; Paste求通过三种操作构造一个字符串S的最少操作次数 在生成串尾部添加一个字符 将生成串的一个子串拷贝到剪贴板 将剪贴板中的内容添加到生成串尾部 可以贪心么？考虑$abcabcabab$，复制$ab$其实和复制$abc$再复制$ab$一样好（之前算错了），所以尽可能地多复制即可。即在位置$i$处时，尝试在$[0, i)$中找到最长的$[j, j+len)$等于$[i, i+len)$。然而这个思路是错的，考虑下面的$’a’*11$字符串，最好的方法是等到3个再复制，比上面的按2的幂复制要少1次。正确的解法是DP，表示字符串完成状态需要一维数组，如何表示剪贴板的状态呢？再加两维数组。$dp[i][ps][pl]$表示完成第$i$个字符时，剪贴板的内容为$[ps, ps + pl]$时至少需要多少操作。Naive的方法是根据不使用剪贴板、使用当前剪贴板、更新剪贴板并使用三种情况进行讨论。由于更新剪贴板需要一个二重循环，所以在认为字符串判等是常数时间下，复杂度为$O(n^5)$。为了降低复杂度，可以使用另开一个数组，或者使用$dp[i][0][0]$来表示所有$dp[i][ps][pl]$的最小值。因为我们肯定是使用最小值来更新的。这样复杂度就变成了$O(n^3)$了。AC代码 B. Trapezoid Counting梯形(trapezoid)是有且仅有一条平行边的凸(convex)四边形(quadrilateral)，等腰(isosceles)梯形是两非平行边长相等的梯形。有一堆木条，要求从中选4个拼成一个等腰梯形，问有多少组方案。注意长度相等的两根木条仍然被认为是不同的木条。很straightforward的题目了，首先梯形成立条件是短三边和大于最长边。然后讨论三种情况$2i+1j1k$、$2i+2j$（不可行由于是矩形）、$3i+j$。小数据挂了一发，因为$3i+j$没有判断梯形成立条件。AC代码后来看别人的题解发现其实$O(n^3)$是可以被卡掉的（Google还是比较仁慈的，毕竟不是ACM）。 C. Blackhole用三个半径相等的球如何将三个点覆盖。the total set of points covered by at least one sphere must form a single connected area这句话是啥意思？小数据由于只在一条线上，直接除以6就可以了。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>codejam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Scala进行Spark-GraphX编程]]></title>
    <url>%2F2017%2F11%2F06%2F%E4%BD%BF%E7%94%A8Scala%E8%BF%9B%E8%A1%8CSpark-GraphX%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[GraphX是基于Spark实现的一个图计算框架，能够对图进行建模。GraphX内置了一些实用的方法，如PageRank、SCC等，同时也提供了Pregel算法的API，我们可以利用Pregel来实现自己的一些图算法。目前GraphX似乎还没有实用的Python API，比较方便的是借助Scala。Scala和Kotlin、Clojure等一样是一种jvm语言，传说其复杂度可与C++一较高下。用下来感觉并不舒服，虽然Scala自诩FP，但从中感到更多的是Java的沉闷与拘束。 Scala语言特性概览FP方面柯里化Scala函数都是柯里函数，因此支持链式地调用，也支持偏/部分应用（注意偏/部分应用和部分函数是两个概念） 模式匹配Scala使用case来实现类似guard的机制。 解构绑定Scala可以利用样本类case class来实现对象的解构绑定。case class实际上可以看做对class的语法糖，根据Scala的说明，case class的使用场景就是用来做Structured binding的。 高阶函数使用compose可以实现复合函数 scala&gt; (((x: Int) =&gt; x + 1) compose ((y: Int) =&gt; y * 2)).apply( 11 ) res1: Int = 23 OO方面逆变与协变Spark部分RDDRDD(Resilient Distributed Dataset)，即弹性数据集是Spark中的基础结构。RDD是distributive的、immutable的，可以存在在内存中，也可以被缓存。对RDD具有转换操作和行动操作两种截然不同的操作。 转换操作始终在RDD的Context里面，但行动操作会去掉RDD的Context 例如take是行动操作，返回的是一个数组而不是RDD了，在Scala中可以看到 12345678scala&gt; var rdd1 = sc.makeRDD(Seq(10, 4, 2, 12, 3))rdd1: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[40] at makeRDD at :21 scala&gt; rdd1.take(1)res0: Array[Int] = Array(10) scala&gt; rdd1.take(2)res1: Array[Int] = Array(10, 4) 转换操作是Lazy Evaluate的，直到遇到一个行动操作 GraphX部分]]></content>
      <tags>
        <tag>Scala</tag>
        <tag>Spark</tag>
        <tag>GraphX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Kickstart 2017 Round G题解]]></title>
    <url>%2F2017%2F11%2F05%2FKickstart2017G%2F</url>
    <content type="text"><![CDATA[Google Kickstart 2017 Round G，当时参加了Google招聘的云中讲堂，建议我们刷一刷Round G。然后就被虐了，只过了A和BC的小数据，55分Rk338滚粗。今天重新做了下，发现其实并不是很难，关键还是手速和脑子要快。 A. Huge Numbers首先快速幂算阶乘的时候用了&lt; n，完美地WA了两发，快速幂过了小数据，用祖传的公式过了大数据。$$A^x = A^{x mod \phi(c) + \phi(c)} (mod c) \\x \ge \phi(c)$$后来看题解发现可以将$A^{N!}$展开成$$A^{1^{2^{3…}}}$$的形式，然后递归地来做。AC代码 B. Cards Game有N个卡片，正反各有一个正整数。玩家初始分数0分，每次选两张卡片，分别将其中一张的正面和另一张的反面异或，并将结果加到总分上。结束后将一张卡片丢弃，另一张放回，由此重复一直到只有一张卡片。求最终最小的分数。没有经受住过小数据的诱惑，直接爆搜了下，复杂度$O(2^N * N^2)$。查看题解，题解使用图论的观点来看，由于每次操作都有一张卡片被消去，我们假设卡片$i$被$j$消去，可以看做从$i$到$j$存在一条边。于是恍然大悟，这条就是个最小生成树啊，套个模板就出来了。注意大数据需要用LL。AC代码 C. Matrix Cutting有一个N*M的矩阵，现在按照行或列切分矩阵，每次讲一个大矩阵切分为两个小矩阵，就奖励原矩阵中的最小值对应的分数。整个过程一直以得到N*M个1*1的矩阵为止，求可能得到的最多分数。这条小数据只有一行哎，于是暴搜（都可以不加记忆化）过了小数据。大数据看起来有可以用二维线段树做，不过由于本人还是太弱，所以最后没时间做了。后来发现可以直接套用二维记忆化搜索强行莽掉。AC代码在实际跑的时候，常数太大了，我用VS开Release才能在6分钟左右算完。我打算写一个CodejamSolver来多线程跑，然后再join。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>codejam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell编程实战]]></title>
    <url>%2F2017%2F10%2F17%2FHaskell%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[在学习完Haskell学习笔记后，在使用Haskell编程时需要用到的技巧 调试可以使用import Debug.Trace来调试，他可以加在表达式里面，有点像$的作用。 trace :: String -&gt; a -&gt; a 1solve triangle len i = trace ("i is " ++ show i) zipWith max choice1 choice2 常用的模组模组是类似于库，Prelude是自动import的模组。可以使用import导入其他模组，在GHCI中可以使用:m导入。这类似于Python中的from X import *可以在括号中选择导入某些模组 import Data.List (sort) 使用hiding可以选择不导入某些函数 import Data.List hiding (nub) 或者使用qualified强制使用全部限定名，类似于Python中的import X import qualified Data.Map 也可以为前面的限定名起个别名，类似于Python中的import X as Y import qualified Data.Map as M 动态规划比较方便的是动态规划每次迭代时传入dp数组，并且返回本次迭代后的dp数组 Rank-N types在使用支持了Existential Quantification扩展的Haskell时，查看map的定义，可以看到forall关键字，它表示对于任意的，即∀。 map :: forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10“目录不是空的错误”解决方案]]></title>
    <url>%2F2017%2F10%2F16%2FWin10%E7%9B%AE%E5%BD%95%E4%B8%8D%E6%98%AF%E7%A9%BA%E7%9A%84%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[昨天帮助别人解决了一起在删除文件夹时出现的“错误0x80070091：目录不是空的”的问题。 问题由来使用移动硬盘从电脑上复制了配置好的hadoop文件夹，之后试图删除该文件夹时出现错误。hadoop-2.8.0\share\hadoop\httpfs\tomcat\webapps\webhdfs\WEB-INF\lib目录无法删除，提示以上错误。尽管里面的文件已经清空。 问题解决根据百度经验上的提示，在管理员权限下运行了rmdir命令，但是并没有作用。在资源管理器中结束了持有相关句柄的进程，亦无效。灵机一动，它既然提示不是空的，那我就真让它不是空的，于是填了一个文件进去，该目录遂被删除。]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软2017年预科生笔试第二场]]></title>
    <url>%2F2017%2F10%2F14%2F%E5%BE%AE%E8%BD%AF2017%E9%A2%84%E7%A7%91%E7%94%9F2%2F</url>
    <content type="text"><![CDATA[微软2017年预科生笔试第二场的题目比9月份的校招要难一点。 hiho1497 Queen Attack为了不MLE，需要按点判断，二分即可代码 hiho1498 Diligent Robots这道题目思路也不复杂，首先机器人肯定是越早造越好，因此早期我们投入全部能力造机器人。假设机器人数量为$R$（包括一开始的一个），需要时间 $$T = T_{build} + T_{work} \\T_{build} = q \, \lceil log_{2}R \rceil \\R_{idle} = 2^{\lceil log_{2}R \rceil} - R \\T_{work} = \frac{n-q \, R_{idle}}{R}$$下面就可以枚举$R$，注意由于任务数取值$n$可能到1000000000000，因此单纯的枚举会超时。但事实上可以证明$R$可以只取2的整数幂，即最后一轮的复制也不存在让一群机器人去复制，另一部分去工作的，假设第$X$轮复制时已有$R$个机器人和$n$个任务，如果让所有的机器人参与复制则到全部完成工作耗时$$T_{all} = \lceil \frac{n}{2 \, R} \rceil + q$$让$S$个机器人参加工作$$T_{R - S} = \lceil \frac{n - S \, q}{2 \, R - S} \rceil + q$$特别地，让所有机器人参加工作（此情况等于最后一轮为$X-1$的情况，可以不考虑）$$T_{none} = \lceil \frac{n}{R} \rceil$$通过解不等式，可以发现不管怎么样全复制都是好的。这里说明一下若$\lceil a \rceil &gt; \lceil b \rceil$，那么$a &gt; b$。由定义$[a] + 1 &gt; [b] + 1$，则$[a] \ge [b] + 1 \gt [b] + (\lbrace b \rbrace - \lbrace a \rbrace)$，即$a &gt; b$。代码 hiho1499 A Box of Coins]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数理统计复习]]></title>
    <url>%2F2017%2F10%2F11%2F%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[辨析了数理统计中的一些重要的基本概念与定理。 样本、总体、样本观测值和统计量有什么区别总体记为$X$样本是从总体中通过抽样方法（例如简单）获得的统计量是关于样本的函数，并且不包含任何未知的参数。对样本$X_i$观测产生观测值$x_i$，对统计量$g(X_1, X_2, …, X_n)$观测产生观测值$g(x_1, x_2, .., x_n)$ 样本方差为什么分母是$n - 1$方差可以表示为$D(X)$、$Var(X)$、$\sigma^2$，没有区别。$\sigma^2$常用来表示总体方差首先回顾方差定义$$\sigma^2 = \mathbb{E}[(X_i - \mathbb{E}[X])^2]$$这里$E(X)$也可记作$\mu$，等于总体均值（期望），也等于样本均值的期望。现在我们估计样本均值（期望）$\bar{X}$，显然$$\bar{X} = \frac{\sum{X_i}}{n}$$下面试图估计样本方差$S$，其定义为$$S^2 = \frac{\sum{(X_i - \mu)^2}}{n}$$为什么定义的时候用$\mu$而不是$\bar{X}$呢？主要是这样下来对总体方差$\sigma^2$的估计是无偏的。这时候发现$\mu$还不知道，很自然会想到能不能用$\bar{X}$代替，这种是没有修正过的方差$S_1$，经过计算比较$$\mathbb{E}S_1^2 = S^2 - Var(\bar{X}) \\\frac{\sum{(X_i - \bar{X})^2}}{n} = \frac{\sum{(X_i - \mu)^2}}{n} - (\mu - \bar{X})^2$$可是$\bar{X}$只是样本期望而不一定等于总体期望，所以实际上估计值是要小的。因此在修正后可以得到$$S^2 = \frac{\sum{(X_i - \mu)^2}}{n} = \frac{\sum{(X_i - \bar{X})^2}}{n - 1}$$这两个估计都是无偏的，但使用$\mu$比$\bar{X}$有效 实际上，用极大似然估计来估计$\sigma^2$得到的就是有偏的$\frac{\sum{(X_i - \bar{X})^2}}{n}$ $\chi^2$、$t$、$F$分布到底是做什么的矩估计和极大似然估计有何异同参数估计是指的总体$F(x, \theta)$已知情况下如何通过样本估计出未知参数值$\theta$点估计的思想是构造统计量$\hat{\theta}(X_1, X_2, .., X_n)$，通过其观察值$\hat{\theta}(x_1, x_2, .., x_n)$来估计位置参数$\theta$。包括了矩估计和极大似然估计。矩估计的思想是用样本矩$A_k$估计总体矩$\mu_k$，这是由大数定律得到的性质。$k$表示第$k$阶矩，与未知量$\theta$是有关的。首先回顾一下，期望可以看做一阶原点矩，方差可以看做二阶中心距。于是我们的$A_k = \mu_k$便可以化为关于总体分布中参数$\theta$的值和样本期望、方差等属性的方程。最后就可以用样本期望、方差去表示出要求的$\theta$。但是出于简便考虑，当只有一个未知数时，选用一阶原点矩和样本期望是很合适的，而且方便计算。当出现两个未知数时一般额外选择二阶原点矩，然后可以应用公式$E(X^2) = E^2(X) + D(X)$转换成方差例如对于样本$X_1, X_2, .., X_n$，估计$\mu$和$\sigma^2$ $$\mu = \bar{X} \\\sigma^2 + \mu^2 = \frac{1}{n} \sum_{i = 1}^{n}{X_i^2} \\\sigma^2 = \frac{1}{n} \sum_{i = 1}^{n}{(X_i^2 - \bar{X}^2) }$$而$$\sum_{i = 1}^{n}{(X_i - \bar{X})^2 } \\= \sum_{i = 1}^{n}{(X_i^2 - 2 \, X_i \bar{X} + \bar{X}^2) } \\= \sum_{i = 1}^{n}{X_i^2} - 2 \, \bar{X} \, \sum_{i = 1}^{n}{X_i} + \bar{X}^2 \\= \sum_{i = 1}^{n}{(X_i^2 - \bar{X}^2) }$$因此$$\sigma^2 = \frac{1}{n} \sum_{i = 1}^{n}{(X_i - \bar{X})^2 } = \frac{n - 1}{n} S^2$$ 极大似然估计的思想是小概率事件发生概率也小，因此如果在试验中观测到一次事件发生则这次事件发生的概率就应该最大，由此计算参数的取值。]]></content>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帝国时代AI开发]]></title>
    <url>%2F2017%2F10%2F03%2F%E5%B8%9D%E5%9B%BD%E6%97%B6%E4%BB%A3AI%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[帝国时代2的AI是比较弱智的，因此网上出现了一些比较厉害的AI，例如Barbarian（野蛮人）、The Horde等，甚至出现了一个AI Ladder对市面上的AI进行排行。恰逢国庆，打算首先来研究一下帝国时代AI的原始DSL以及UserPatch补丁修改后增加的功能，并且结合一些著名AI探讨一些常用的手法。 Native DSL简介帝国时代2 AOK（即红帽子）版本的DSL文档可以从这里下载，翔鹰帝国提供了有点奇怪的中文翻译。此外外国一款针对1.0c版本的UserPatch加强了DSL，有了一些新的特性，目前已更新到v1.4，它的官网是userpatch.aiscripters.net。一套ai包含两个文件，.per即personality文件，包含着所有的ai部分，ai文件一般只做占位符类似的作用。如果per文件是空的，那么就会弹出一个错误，并且农民会四处跑，进行牧羊。 def语法总的来说，这份DSL类似于lisp语言，主要由下面的defrule语句构成12345(defrule (some facts) =&gt; (some action takes place) ) 一个defrule可以看做地图编辑器里面的一个触发项。下面的fact/action可以包含若干个条件/动作。rule一旦被定义，系统就会不断轮询检查是否符合facts所描述的条件，如果符合，就执行action语句。脚本不会像C++一样只采用最匹配的规则，如下面两个规则都是适用的，所以我们细化战略时，必须同时写真条件和假条件。1234567891011(defrule (cc-players-unit-type-count any-human-enemy town-center &gt;= 1)=&gt; (chat-to-all "aaa"))(defrule (current-age == dark-age) (cc-players-unit-type-count any-human-enemy town-center &gt;= 1)=&gt; (chat-to-all "bbb")) 对于一些只想执行一次的语句就可以通过最末尾的(disable-self)来禁用这条规则。除了defrule，还有defconst，用来定义常数，defconst可以重复定义（如果值相同）。 load语法这个有点类似于C++中的include了。常常针对各个民族的特点包括陆/海/游/移民等不同形式各写一套ai，然后在一个总的per文件里面针对不同情况来load。 随机加载可以通过load-random指令按照一定比率随机加载per文件，这样可以做到一定程度的随机ai。 条件加载通过#load-if-defined和#load-if-not-defined可以实现条件加载。这两个命令接受System-defined symbols，来自于开始游戏时的设定，例如初始资源选项就有LOW-RESOURCES-START/MEDIUM-RESOURCES-START/HIGH-RESOURCES-START三种，分别对应了游戏下拉列表里面的三个选项。条件加载有点类似于C++中的预处理指令，但实际上帝国时代引擎中没有预处理阶段，条件加载所包裹的指令只是不被load，但会被parse的。不加载一些rule能够有效提高性能，这样轮询的对象就会少一点。 通配符（wildcard）any-和every-可以引导通配符，其中any-引导的需要一个为真，every-引导的则需要全部为真。特别地this-any-里面有any，但实际上它是variable。通配符包括 any-ally、any-computer、any-computer-ally、any-computer-enemy、any-computer-neutral、any-enemy、any-human、any-human-ally、any-human-enemy、any-human-neutral、any-neutral、every-ally、every-computer、every-enemy、every-human、every-neutral根据科技的研究骑士可以升级为重装骑士和圣殿骑士，这时候就需要使用-line是这个通配符，knight-line表示骑士，这样我们就不需要去判断是否研究过cavalier或者paladin了。 facts、actions、parameters、variables和goal事实(facts)一般用作rule的条件。例如military-population这个fact表示自己此时的军事人口。不过我们不能把这个值取出来，只能用一个比较运算符和某个立即量进行比较，形成一个predicate。例如military-population &gt; 10。fact或action的参数称为parameter。this-引导的为变量(variable)，variable的生存空间只存在于当前规则中，并且variable都是由系统隐式定义的，例如this-any-enemy表示选定的任一敌人。那么这个this-any-enemy具体是是怎么决定的呢？这由facts中的通配符来匹配得到，例如在facts中匹配了哥特文明的任意敌人，那么下面的this-any-enemy就指的上面的敌人。123456(defrule (players-civ any-enemy gothic) =&gt; (chat-to-player this-any-enemy "I know you are a Goth") (disable-self)) 需要再次强调的是在这个规则之外，本次匹配得到的this-any-enemy就不能适用了。有没有用户能控制的全局的变量呢？最接近的应该是目标(goal)。goal可以由(set-goal goal-id value)来定义，goal-id范围一般是从1-70（HD版本），为了方便阅读，常使用defconst常数。可惜的是goal的读取很不方便，因为它只能通过(goal goal-id value)来判断是否相等，甚至连比较运算符都不支持。 定时器注意enable之后必须要disable掉当前语句，不然会一直enable导致无法trigger 关系运算符游戏难度的关系运算符是和想象相反的，即easiest&gt;easy&gt;moderate&gt;hard&gt;hardest。 策略sn-引导的为策略。城镇规模town-size指的是一个城镇建筑所覆盖的面积。 escrow预留资源escrow-amount命令可以将某一类的资源预留一部分作为储备，这样所有的资源会被分成两块，便于管理。release-escrow可以取消预留资源 AI基本操作调试我们可以看到大多数时候，变量都是不能直接获取值的，而是通过比较是否相等（goal）或者比较运算符比较（如building-type-count）实现，对这些数值的调试只能写一条defrule然后在里面判断数值输出。但是还有一类sn-开头的strategic-number，这个可以通过chat-trace这条指令输出。 使用taunt调试taunt-detected和acknowledge-taunt这两个可以实现由用户输入某个数字taunt，然后输出相应值的功能。 补人口默认1.5倍时间下，TC造一个农民大概在13秒左右，一个农民造房子大概在15秒左右，所以当人口差两个的时候就需要造房子了1234567(defrule(can-build house)(housing-headroom &lt; 2) (population-headroom &gt; 3)=&gt;(build house)) can-build会检查该building是否符合当前的文明、科技树以及资源量（减去escrow预留的资源）。不过即使不加can-build，电脑也不会在文明、科技、资源量不满足的情况下造，而是作为一次失败的build尝试。一旦一次build失败了，此趟执行的所有build x都不会被运行了，即使后来条件全部满足。类似的还有can-train和can-research，不过这两个还要注意建筑物在研究科技/造兵时被占用的问题。如果不幸卡农民了，可以升级织布机12345678(defrule (current-age == dark-age) (not (can-train villager)) (can-research ri-loom)=&gt; (research ri-loom) (disable-self)) 城镇规模(TSA)进攻一般的进攻有(attack-now)语句，该语句会造成一队士兵以编队形式过来进攻，不过有些问题，例如在编队行进过程中受到进攻也不还手。由于attack-now是一队一队地出发的，所以可以通过改小sn-percent-attack-soldiers然后多次attack-now实现多波的、相互呼应的进攻。TSA即Town Size Attack，相对于(attack-now)的直来直去，TSA进攻更分散、更操作性一点。它通过增加城镇的面积，这样己方就会对城镇面积内的敌人进行攻击。注意要区分TSA和日常随着经济发展的城镇增长，城镇增长相对TSA还要额外扩大sn-camp-max-distance和sn-mill-max-distance用以获得更多资源。为了测试，我们可以做一个场景地图。1234567891011121314(defrule (true)=&gt; (set-strategic-number sn-home-exploration-time 0) (set-strategic-number sn-maximum-town-size 255) (set-strategic-number sn-number-attack-groups 200) (set-strategic-number sn-maximum-attack-group-size 200) (set-strategic-number sn-minimum-attack-group-size 1) (set-strategic-number sn-attack-intelligence 1) (set-strategic-number sn-enemy-sighted-response-distance 200) (set-strategic-number sn-disable-attack-groups 0) (set-strategic-number sn-percent-attack-soldiers 100)) sn-attack-intelligence表示智能进攻系统。该系统尝试在攻击时躲避敌人单位，尝试从多角度进攻。配合sn-attack-coordination设为2能够实现多线作战效果。sn-disable-attack-groups会禁用自动进攻编组，TSA必须不禁用。类似的选项还有sn-disable-defend-groups。结果调试发现，首先所有的兵力沿着城镇方向散开，直到有一个军事单位发现敌人。当战斗单位还存在的时候TSA农民是不怎么参与战斗的，即使设置了123(set-strategic-number sn-allow-civilian-defense 3)(set-strategic-number sn-allow-civilian-offense 2)(set-strategic-number sn-number-civilian-militia 200) 但如果放到一个纯农民的地图里面，农民就都会上去搏。sn-percent-attack-soldiers似乎并不对TSA有作用，它仅针对attack-now命令，指的是进攻士兵占防守士兵的比例。官方说明中提到用它时最好不用sn-number-defend-groups（注意是defend）。sn-enemy-sighted-response-distance指敌人攻击自己时，什么范围内的己方单位会作出反应，为了调试效果，我们把这个值设得非常大。 sn-special-attack-type1(2/3)是个很有用的命令，它设置了首要的攻击目标（单位、建筑等），在UP的注释中却有不同的说明，当它为1时会攻击僧侣。我在论坛上确认了使用UP时UP的注释是正确的，此外原版DSL中更本就没有sn-special-attack-type2和sn-special-attack-type3与之对应的是sn-gold-defend-priority等一系列防守重要性等级策略，从0到7防守力度越来越大。 sn-number-attack-groups、sn-minimum-attack-group-size、sn-maximum-attack-group-size及sn-attack-group-size-randomness是一套指令。 修建围墙围家是帝国时代做经济的一个军事支撑，如果在前方给敌人足够压力可以借助TC和军事建筑，如果想直城或直帝则需要木头墙+石墙围一道。围墙建造第一步是enable-wall-placement这个命令，这个命令会通知将来的建筑离未来的围墙至少距离1格(tile)，因此最好在初始化中就做好。enable-wall-placement带一个参数perimeter，设为1就是小围，2是大围。build-wall是建造围墙命令1234567891011121314151617181920212223242526(defrule (true)=&gt; (enable-wall-placement 1) (disable-self))(defrule (current-age &gt;= castle-age) (stone-amount &gt; 300) (can-build-wall 1 stone-wall-line)=&gt; (build-wall 1 stone-wall-line))(defrule (or (wall-completed-percentage 2 &gt;= 20) (wall-completed-percentage 1 &gt;= 20) ) (or (can-build-gate 2) (can-build-gate 1) )=&gt; (build-gate 2) (build-gate 1)) 小围技术小围技术包含两个方面，一是如何让房子等技术修成圈，另一个是如何让农民在第一个建筑没修完时赶快桥第二个建筑 Native AI赏析之BOOM IIBOOM II ai是一个比较厉害的ai，特点是疯狂爆兵。和他打了几把，它不喜欢杀敌人的农民，后期也不会清理空闲农民（倒是UserPatch里面有个相关的清理命令），多人的时候不太喜欢在后面圈贸易，所以经济有点吃亏，黑暗时代不喜欢拉猪赶鹿可能是AI的一个通病，可能做不到这么细致。 防守塔爆GOAL-DEF-TRUCH指的是防御塔爆（defend tower rush） 塔爆状态流第一步是发现修塔，如果在封建时代前的前期（前1200秒）内探查到敌人修塔，就切换GOAL-DEF-TRUCH到7。(goal GOAL-ADDRESOURCE 1)这个条件我不太明白是怎么回事值得注意的是building-type-count和 building-type-count-total，前一个只计算现存的建筑数，后一个计算包括正在队列（正在建造）中的建筑数。注意摧毁了的建筑不会增加到这个里面。unit-type-count和 unit-type-count-total的区别也在此，不过unit-不仅对建筑用，也可以对军队等单位用。123456789101112(defrule (goal GOAL-ADDRESOURCE 1) (game-time &lt; 1200) (current-age &lt;= feudal-age) (goal GOAL-DEF-TRUCH 0) (players-building-type-count any-human-enemy watch-tower &gt;= 1)=&gt; (set-goal GOAL-DEF-TRUCH 7) (chat-to-player this-any-human-enemy "修塔...") (set-strategic-number sn-maximum-town-size 35) (disable-self)) 第二步是发现塔爆1234567891011121314151617(defrule (goal GOAL-ADDRESOURCE 1) (game-time &lt; 1000) (current-age &lt;= feudal-age) (goal GOAL-DEF-TRUCH 7) (players-military-population any-human-enemy &lt;= 1) (enemy-buildings-in-town)=&gt; (chat-to-player this-any-human-enemy "塔暴?!") (set-goal GOAL-DEF-TRUCH 1) (set-strategic-number sn-maximum-town-size 20) (set-strategic-number sn-camp-max-distance 25) (set-goal GOAL-SPECIAL-AID 1) (disable-timer TIMER-SPECIAL-AID) (enable-timer TIMER-SPECIAL-AID 300) (disable-self)) 首先需要经过第一步GOAL-DEF-TRUCH已经到7，然后敌人的军事人口应该小于等于1（相对于黑快的大于等于4），并且有建筑在城镇范围内部了。这时候切换GOAL-DEF-TRUCH到1，并且调整城镇规模，此外切换GOAL-SPECIAL-AID到1，并启动定时器TIMER-SPECIAL-AID。此外脚本对前置塔攻的情况进行了特殊处理。前置塔攻相比塔爆多了军事人口，更厉害。在处理时切换GOAL-DEF-TRUCH到2，启动SPECIAL-AID一套流程，但不调整城镇规模。第三步，检查敌人是否使用木墙或者石墙围，并根据具体情况不同重置TIMER-SPECIAL-AID为400（前置塔攻490）、900、16001234567891011(defrule (goal GOAL-DEF-TRUCH 1) (players-building-type-count any-human-enemy watch-tower &gt;= 1) (players-building-type-count any-human-enemy stone-wall &gt;= 2)=&gt; (chat-to-player this-any-human-enemy "24你死定了!!") (set-goal GOAL-SPECIAL-AID 1) (disable-timer TIMER-SPECIAL-AID) (enable-timer TIMER-SPECIAL-AID 900) (disable-self)) 下面讨论ai防御塔爆的行为，这在Defend Truch部分有定义。这些防御行为的产生条件是封建时代且GOAL-DEF-TRUCH为1，即防御塔爆状态 首先取消GOAL-FAST-ATTACK计划 如果发现有石矿，造采石场 如果能造塔，并且已造塔数小于4，那么就造塔 注意下面的造塔命令，能够粗略地控制造塔范围 123(set-strategic-number sn-maximum-town-size 12)(build watch-tower-line)(set-strategic-number sn-maximum-town-size 20) 如果每个敌人都没到城堡，如果能造塔，并且已造塔数小于8，那么反塔爆别人 这里用了build-forward命令，即前置造建筑物。 当自己到了城堡之后，如果塔还没清掉（估计是石墙搞了一波农民搏不掉），那么就造BK（siege-workshop）。下面不用多说，造攻城车（battering-ram-line）。然后就等着攻城车自己清理吧。 最后是防御塔爆的结束条件： 城堡时代、农民数大于50 时间超过1020，塔全部被清理，农民数大于28 前置塔攻就不详细讨论了，下面的是在成功防御前置塔攻之后的行为。1234567891011121314(defrule (game-time &gt; 900) (goal GOAL-DEF-TRUCH 2) (or (goal GOAL-FORCE-COMPARE 3) (goal GOAL-FORCE-COMPARE 4)) (players-building-type-count any-human-enemy watch-tower &lt;= 0)=&gt; (chat-to-player this-any-human-enemy "11") (set-goal GOAL-DEF-TRUCH 0) (set-goal GOAL-FAST-ATTACK 1) (set-goal GOAL-SPECIAL-AID 2) (disable-timer TIMER-SPECIAL-AID) (disable-self)) 防守TC暴TC暴（Douche）是种比较恶心的塔爆，玩家在黑暗自爆自己的TC，然后农民跑到对家的基地附近建TC，然后TC对射和对方耗。BOOM II对TC暴有着绝妙的应对方法，那就是不打TC暴、、、12345678910(defrule (game-time &lt; 900) (goal GOAL-PVP 1) (current-age &lt;= feudal-age) (cc-players-unit-type-count any-human-enemy town-center &lt;= 0)=&gt; (chat-to-player this-any-human-enemy "不会吧？TC暴？") (set-goal GOAL-DEF-TRUCH 3) (disable-self)) cc-players-unit-type-count是一个作弊命令，相对于不加cc-的命令，它获取玩家某一种类建筑的数目，不管自己能不能看到。这里判断如果在黑暗时代TC的数量变成0，那么对方很可能就是TC爆了。将GOAL-DEF-TRUCH改成3表示当前是TC爆。1234567891011(defrule (goal GOAL-DEF-TRUCH 3) (goal GOAL-TOWN-SIZE-ATTACK 0) (enemy-buildings-in-town) (town-under-attack) (players-building-type-count any-human-enemy town-center &gt;= 1)=&gt; (chat-to-all "不打TC暴！") (set-goal GOAL-RESIGN 1) (disable-self)) 城快进攻UserPatch v1.4简介我们发现帝国时代内置的ai命令还是比较弱的，我们很难实现一些逻辑。简单地说，删除所有闲置的农民就难以实现。为此使用UserPatch提供的增强版Scripting是个不错的选择。 UP的安装在网站userpatch.aiscripters.net上下载，里面包含一个Reference文件夹和一个exe程序。Reference里面Scripting文件夹里面的per文件是需要load进去的常量，另一个Reference.html与网上在线的Guide相同。此外，网站的论坛也能提供更详细的资料。 UP基础语法变量在Native DSL中goal的值既不能直接拿出来，也不能直接比较，UP改善了这个特性。首先引入了三个类型运算符c:、g:、s:。c:表示作为常数值，g:表示作为goal值，s:表示作为sn值。举一个例子12345678(defconst gl-slot0 100)(defrule (true)=&gt; (set-goal gl-slot0 77) (up-chat-data-to-all "gl-slot0 key is: %d" c: gl-slot0) (up-chat-data-to-all "gl-slot0 value is: %d" g: gl-slot0)) 以上rule的结果是 gl-slot0 key is: 100 gl-slot0 value is: 77 可以发现现在goal可以真正地作为变量使用了，在定义变量的时候，我们通常以gl-为前缀，这样的gl-类似于一个整型指针（只不过由我们自己规定地址），g:可以将它解引用。但是注意不能在set-goal里面用g:1(set-goal gl-slot1 g: sl-slot0) 替代方案是使用up-modify-goal。 get系列函数既然goal可以作为变量使用，那么我们肯定希望用它来保存一下有用数据，up-get-系列函数能够将我们需要的一些数据取到变量中。 get fact系列up-get-fact是最基础的get fact函数。在先前，我们不能获取military-population的值，我们只能拿它进行比较，如(military-population &gt; 10)。但现在我们可以将它保存在gl-data中了。遗憾的是似乎这个函数只能获取UserPatchConst中定义的fact，另外的一些，例如villager-hunter之类的就没办法获取。1234567(defconst gl-data 101)(defconst military-population 31)(defrule (true)=&gt; (up-get-fact military-population 0 gl-data)) 但是UP还可以为我们做更多，我们可以获得某些玩家（由every/any通配符指定）事实集合中的最大/小值以及和，如12345678910111213141516(defconst gl-my-civ-sum 101)(defconst gl-ene-civ-sum 102)(defconst gl-cmp 103)(defconst civilian-population 32) ;any(defrule (true)=&gt; (up-get-fact-sum any-enemy civilian-population 0 gl-ene-civ-sum) (up-get-fact civilian-population 0 gl-my-civ-sum) (up-modify-goal gl-cmp g:= gl-my-civ-sum) (up-modify-goal gl-cmp g:/ gl-ene-civ-sum) (up-chat-data-to-all "me is: %d" g: gl-my-civ-sum) (up-chat-data-to-all "ene is: %d" g: gl-ene-civ-sum) (up-chat-data-to-all "comparation of ene and me is: %d" g: gl-cmp)) 这个可以输出敌人的农民人口与自己的农民人口的比值，可惜是整数，这里因为我们没有探测到敌人的家，所以gl-ene-civ-sum值是0或-1，结果是0。 成本函数up-reset-cost-data将四种资源成本全部置零，例如12345678910(defconst gl-military-cost-food 111)(defconst gl-military-cost-wood 112)(defconst gl-military-cost-stone 113)(defconst gl-military-cost-gold 114)(defrule (true)=&gt; (up-setup-cost-data 1 gl-military-cost-food) (disable-self)) 当第一个参数为1的时候，将所有的成本设置为0，真是够奇葩的，为啥不搞个memset一样的呢？为什么第二个参数是gl-military-cost-food呢？因为可以把gl-military-cost-food到gl-military-cost-gold看成一个四个元素的数组，而gl-military-cost-food相当于传入了一个头指针。在使用up-reset-cost-data，其他的成本函数都是对当前选定的“数组”进行操作了。下面的代码往总成本上加了两份军事成本（每份成本包含一个骑士）123456789101112131415161718(defrule (true)=&gt; (up-setup-cost-data 1 gl-military-cost-food) (up-add-object-cost c: knight-line c: 1) (up-setup-cost-data 1 gl-cost-food) (up-add-cost-data gl-military-cost-food c: 2) (up-chat-data-to-all "wood is: %d" g: gl-cost-wood) (up-chat-data-to-all "stone is: %d" g: gl-cost-stone) (up-chat-data-to-all "food is: %d" g: gl-cost-food) (up-chat-data-to-all "gold is: %d" g: gl-cost-gold) (up-chat-data-to-all "mit wood is: %d" g: gl-military-cost-wood) (up-chat-data-to-all "mit stone is: %d" g: gl-military-cost-stone) (up-chat-data-to-all "mit food is: %d" g: gl-military-cost-food) (up-chat-data-to-all "mit gold is: %d" g: gl-military-cost-gold) (disable-self)) up-add-object-cost第一个参数表示单位id，第二个参数表示数量，相对up-setup-cost-data还有科技研发成本up-add-research-costup-setup-cost-data第一个参数表示一个goal，第二个参数表示份数up-get-cost-delta计算当前资源与建造成本的差值，负的表示不够。这个值与escrow无关。12345678910(defrule (true)=&gt; (up-setup-cost-data 1 gl-cost-food) ;(up-modify-escrow wood c:= 100) (up-add-object-cost c: archer-line c: 200) (up-get-cost-delta gl-delta-food) (up-chat-data-to-all "delta is: %d" g: gl-delta-wood) (disable-self)) 坐标代数UP提供的坐标代数能实现高级AI的精细控制，如此篇帖子。为了表示坐标，首先定义一个点对。类似于上面up-reset-cost-data操纵资源的方式，点对的地址应当是连续的（形成一个二维数组），如下面的100和101，这样gl-point-x可以看做指向该点对的指针。12(defconst gl-point-x 100)(defconst gl-point-y 101) 我们可以将gl-point-x点对设为目标点，供如up-build等命令使用1(up-set-target-point gl-point-x) up-lerp-percent和up-lerp-tiles这个用来计算坐标偏移，将第一个点对作为基点，第二个点对作为位移值进行偏移。up-lerp-tiles会偏移固定的格数，up-lerp-precent则按百分比。 up-cross-tiles我写了段代码测试了一下，并没有看出来有啥用，应该结果保存在第一个点 流程控制在同一个文件里面rules的执行可以看成是从上至下的，因此可以利用up-jump-rule来实现选择或者循环结构，但注意#load块可能影响位置。 直接寻的系统find过滤器过滤器由up-filter-distance、up-filter-exclude、up-filter-garrison、up-filter-include、up-filter-range构成注意以下命令中-1表示忽略此过滤条件 选择目标点周围10个内单位：(up-filter-distance c: -1 c: 10)，其中两个参数分别为最小距离和最大距离 派出具有某个编号的单位：(up-filter-exclude cmdid-trade -1 -1 -1)，其中四个参数分别表示命令编号、行动编号、执行编号和类别编号。例如(up-filter-exclude -1 actionid-explore orderid-relic warship-class) 选择驻扎了至少5个单位的建筑：(up-filter-garrison c: 5 c: -1)，两个参数同样是最大值和最小值 up-filter-include这个和exclude是相似的，不过第四个参数改为了是否在主大陆上 一般重置需要同时重置search结果和过滤器，即12(up-reset-search 1 1 1 1)(up-reset-filters) 使用直接寻的系统找到的对象可以利用up-set-target-object设为目标，然后通过up-object-data等语句对目标进行操作，下面的语句摘自拉猪部分12(up-set-target-object search-local c: 0)(up-object-data object-data-hitpoints &lt; 40) 人员控制包括驻扎、巡逻、删除冗余人员 驻扎up-gather-inside可以指定建筑生产集合点是自己本身。这在操作的时是很有用的一个特性，一方面敌人不容易观察你到底生产了什么，第二个单位不至于瞎跑，或者被泼粪车泼到。1234567891011(defrule (true)=&gt; (up-gather-inside c: dock c: 1) (disable-self))(defrule (unit-type-count warship-class &gt;= 10) ; warship-class = 922=&gt; (up-gather-inside c: dock c: 0)) 直接驻扎的命令是up-garrison，如1(up-garrison battering-ram c: infantry-class) ; infantry-class = 906 将所有步兵驻扎到工程车中，注意指定建筑不能使用battering-ram-line这种带wildcard的。 up-guard-unit UserPatch AI赏析之BruteforceBruteforce是一个适合新手练习的AI。 AI概览AI预定义了定义了一些城堡时代的打法，有些英文属于可以查询网站，对应着各个per文件。1234567891011121314151617(defconst sn-castle-age-strategy 182)(defconst xbow 1)(defconst end-game 2)(defconst krush 3)(defconst EAGLE-RUSH 4)(defconst fast-castle 5)(defconst eagle-rush 6)(defconst conquistadors 7)(defconst naval-fun 8)(defconst klew 9)(defconst castled 10)(defconst booming 11)(defconst lsr 12)(defconst PIKEMAN 13)(defconst DRUSH 14)(defconst RUN 15) ; https://youtu.be/mw2kKyJu9gY?t=2m11s end-game应该表示此战术已失效xbow是打弩手。Krush指的是城快马爆，28p升封建。Scrush是打肉马（配合弩手和散兵），24p到封建。Skirm是打散兵（掷矛战士），24p到封建。GenericAra是通用阿拉伯，以打弓箭为主，23-24p升封建。KLEW(Kidd’s Lightning Eagle Warrior Rush)是美洲民族的打法，主张直城，然后雄鹰快攻，24p到封建，卖石头点城堡。Booming是暴经济直帝，30p到封建PIKEMAN是长枪兵。TRASH是垃圾兵（长戟和掷矛）。MAA是打装甲步兵。HCA是打骑射手。Sling是打进贡。CASTLED(Castle Drop)是打前置城堡。 开局现在选择我最喜欢的蒙古民族，在阿拉伯地图上进行开局。我们看到蒙古民族会随机加载一些策略文件。123456789#load-if-defined MONGOL-CIV#load-if-defined UP-POCKET-POSITION(load "Brutal2\Krush")#else(load-random 45 "Brutal2\GenericAra" 52 "Brutal2\Scrush" 3 "Brutal2\Krush")#end-if#end-if UP-POCKET-POSITION指的是玩家是否坐中，那1v1的时候玩家始终坐中，于是就用马爆策略。 造房子123456789101112131415#load-if-not-defined CHINESE-CIV(defrule (up-gaia-type-count c: livestock-class == 0) (building-type-count-total town-center &gt;= 1) (population-headroom &gt; 0) (housing-headroom &lt; 3) (up-pending-objects c: house &lt; 1) (building-type-count-total house &lt; 1) (up-can-build 0 c: house)=&gt; (up-assign-builders c: house c: 2) (set-strategic-number sn-placement-zone-size 1) (up-set-placement-data my-player-number villager c: 1) (up-build place-control 0 c: house)) up-gaia-type-count用来表示尚存的的自然资源的数目，例如(up-gaia-type-count c: livestock-class &gt; 6)表示是否还存在超过6只绵羊或火鸡。与之对应的是up-gaia-type-count-total，表示所有曾经发现过的自然资源的数目，但是对鹿和羊来说没有相关数据，所以其实返回的是up-gaia-type-count的结果。注意，看到的羊可能还是灰色，并不等于自己拥有的羊。看自己的羊应该用up-object-type-count，并且羊被杀了之后up-object-type-count会减少，而不是吃完会减少。population-headroom指的是游戏设置最大人口和目前住房提供人口的差额。housing-headroom指的是目前住房提供人口和实际人口的差额。上面这段是造第一个房子，由于中国城镇中心提供10个人口，所以中国不需要造第一个房子。up-assign-builders为指定类型建筑分配农民数，由于一开始就只有一个人口富余，容易卡房子，所以分配两个农民造。有意思的是up-build命令，它的第二个参数可以取place-normal、place-forward、place-control、place-point。这里的place-control是与up-set-placement-data配合使用的。例如1(up-set-placement-data my-player-number -1 c: -25) ; home town center = -1 表示在主TC后面25格。本段代码的意思即在村民旁边建造房子。而place-point则是利用up-set-target-point储存的地点。sn-placement-zone-size在place-forward、place-control这两个选项时。下面是另外一个造房子的条件，在开局的时候并没有被触发。由于这两个行为是全部一样的，所以其实我感觉做简单一点，这两个可以合为一个。123456789101112131415(defrule (game-time &lt; 7) (up-gaia-type-count c: livestock-class &gt; 0) (building-type-count house &lt; 1) (building-type-count-total town-center &gt;= 1) (population-headroom &gt; 0) (housing-headroom &lt; 3) (up-pending-objects c: house &lt; 2) (up-can-build 0 c: house)=&gt; (up-assign-builders c: house c: 2) (set-strategic-number sn-placement-zone-size 1) (up-set-placement-data my-player-number villager c: 1) (up-build place-control 0 c: house)) 如果房子超过一个了，开局就不会卡农民了，这样将造房子的农民减少到一个。1234567(defrule (building-type-count house &gt; 0)=&gt; (up-assign-builders c: house c: 1) (disable-self))#end-if 注意开局的时候我们一般是造两个房子，一个分配2农民，一个分配1农民，这样会导致超过sn-cap-civilian-builders的默认值2，所以最好在一开始扩大一下，例如设为25。最重要的是sn-enable-new-building-system必须设为1，否则村民只能同时建造一个建筑。 农民调配可以结合这篇帖子和这篇帖子来理解AI的一些思路。123456789101112131415(defrule (up-compare-goal gl-map-style != LAND-NOMAD) (up-compare-goal gl-map-style != NOMAD) (current-age == dark-age) (game-time &lt; civilian-exploration-time) (unit-type-count livestock-class &lt; 1) (strategic-number sn-number-explore-groups != 4)=&gt; (set-strategic-number sn-cap-civilian-explorers civ-explorers) (set-strategic-number sn-cap-civilian-gatherers 100) (set-strategic-number sn-percent-civilian-gatherers 100) (set-strategic-number sn-percent-civilian-explorers 100) (set-strategic-number sn-number-explore-groups civ-explorers) (set-strategic-number sn-total-number-explorers civ-explorers)) 以上部分是早期探索阶段，阿拉伯地图的civilian-exploration-time为60。根据调试，实际上更多运行的是下面这个rule，因为通常农民很快就能找到一个羊群。这时候设置农民探索者最大数量为0，采集者最大数量为100，并且所有的农民都去采集。探索者的队伍容量为1人。这里注意与sn-number-explore-groups和sn-total-number-explorers区别，前者指的是陆地上的探索者数量，后者指的是村民探索者和军队探索者的总和。但是当有军队进行探索的时候似乎不会派村民进行较多的侦查活动。1234567891011121314151617(defrule (up-compare-goal gl-map-style != LAND-NOMAD) (up-compare-goal gl-map-style != NOMAD) (building-type-count town-center &gt; 0) (current-age == dark-age) (or(game-time &gt; civilian-exploration-time) (or(building-type-count-total mill &gt; 0) (unit-type-count livestock-class &gt;= 2))) (strategic-number sn-number-explore-groups != 4) =&gt; (set-strategic-number sn-cap-civilian-explorers 0) (set-strategic-number sn-cap-civilian-gatherers 100) (set-strategic-number sn-percent-civilian-explorers 0) (set-strategic-number sn-percent-civilian-gatherers 100) (set-strategic-number sn-number-explore-groups 1) (set-strategic-number sn-total-number-explorers 1)) 再往后，根据战术的不同，资源调配的方案有很大不同。 sn设置下面是strategy number设置，这里分了几部分是因为rule里面action的条数限制12345678910111213141516171819202122(defrule (true)=&gt; (set-strategic-number sn-cap-civilian-builders 25) (set-strategic-number sn-livestock-to-town-center 1) (set-strategic-number sn-enable-new-building-system 1) (set-strategic-number sn-enable-training-queue 1) (set-strategic-number sn-allow-adjacent-dropsites 1) ;(set-strategic-number sn-dropsite-separation-distance 5) (set-strategic-number sn-disable-builder-assistance 1) (set-strategic-number sn-camp-max-distance 16) (set-strategic-number sn-mill-max-distance 32) ;(set-strategic-number sn-defer-dropsite-update 1) ;(set-strategic-number sn-task-ungrouped-soldiers 0) (set-strategic-number sn-enable-patrol-attack 1) (set-strategic-number sn-maximum-hunt-drop-distance 12) (set-strategic-number sn-maximum-town-size 10) (set-goal gl-new-town-size 10) (set-strategic-number sn-max-retask-gather-amount 10) (set-strategic-number sn-retask-gather-amount 0) (disable-self)) sn-camp-max-distance表示伐木场和矿场和城镇中心最远的距离，不可能说我们的一个伐木放到敌人家门口的，对应有sn-mill-max-distance。BF将这两个值分别设为16和32sn-defer-dropsite-update策略，设为1的时候当新资源放置点建好时才更新dropsite-min-distance，否则刚建造就更新。sn-task-ungrouped-soldiers策略在TSA攻击时比较有用，它设定未编组部队是否分散开并保卫城镇地区。如果说是1，那么非编组军队（可以认为是空闲的军队）就会在城镇范围内散开并“游荡”。sn-enable-patrol-attack为巡逻式攻击命令，可参见heavengames上的说明sn-allow-adjacent-dropsites指的是否将资源放置点建到紧贴资源，这里选择的是1，但是我觉得0更好，这样资源放置点与资源之间会有一格距离，农民和资源放置点之间的接触面会更大sn-enable-training-queue允许在训练队列中pending一个单位。我们实际操作的时候可能喜欢按shift，然后一下子让电脑造5个甚至填满训练队列，这样会预先一次性支出所有单位的训练资源，但好处是防止我们操作不过来延误暴兵。但是电脑没有这方面的烦恼，rule的触发条件满足了，就会造单位，所以没必要把训练队列里面塞满。由于计算机对所有rule的一趟遍历是周期性的，所以这个命令使得，例如前期一个农民造好后能够立刻开始造下一个农民，而不是可能会等1-2秒。1234567891011121314151617181920(defrule (true)=&gt; (set-strategic-number sn-intelligent-gathering 1) (set-strategic-number sn-use-by-type-max-gathering 0) (set-strategic-number sn-gather-defense-units 1) (set-strategic-number sn-military-level 0) (set-strategic-number sn-enemy-sighted-response-distance 0) (set-strategic-number sn-percent-enemy-sighted-response 0) (set-strategic-number sn-percent-attack-soldiers 0) (set-strategic-number sn-enemy-current-age dark) (set-strategic-number sn-dropsite-separation-distance 1) (set-strategic-number sn-local-targeting-mode 1) ;(set-strategic-number sn-ttkfactor-scalar 200) (set-strategic-number sn-percent-building-cancellation 10) (set-strategic-number sn-zero-priority-distance 250) (set-strategic-number sn-initial-exploration-required 0) (set-strategic-number sn-enemy-sling-target-player 0) (disable-self)) sn-intelligent-gathering是智能采集系统，有什么用呢？从论坛上有 If you do up-retask-gatherers without sn-intelligent-gathering on, then the villagers will lose their load. If you do it with sn-intelligent-gathering then you don’t lose the load. sn-military-level并没有在UP或者原生DSL中出现，从gist上的这份源码，应该是自己的军事力量越强，sn-military-level就被设得越高sn-initial-exploration-required是修建建筑前最少的探索地图比例，由于农民直接在身后拍房子，所以应当为0。注意它的默认值不是0！所以一定要显式地修改回0。1234567891011121314151617181920(defrule (true)=&gt; (set-strategic-number sn-percent-attack-soldiers 100) (set-strategic-number sn-minimum-attack-group-size 1) (set-strategic-number sn-preferred-trade-distance 255) (set-strategic-number sn-consecutive-idle-unit-limit 0) (set-strategic-number sn-attack-winning-player 0) (set-strategic-number sn-attack-winning-player-factor 0) ;(set-strategic-number sn-placement-fail-delta 1) ;(set-strategic-number sn-placement-to-center 1) (set-strategic-number sn-blot-exploration-map 0) (set-strategic-number sn-blot-size blot-size) (set-strategic-number sn-escrow-level 0) (set-strategic-number sn-allow-direct-unit-control 0) (set-strategic-number sn-maximum-fish-boat-drop-distance 5) (set-goal gl-slain-deer 0) (up-setup-cost-data 1 gl-cost-food) (disable-self)) sn-preferred-trade-distance偏好贸易距离，由于贸易越长越好，所以设为255. 1234567891011121314(defrule (true)=&gt; (set-strategic-number sn-archer-threat 0) (set-strategic-number sn-infantry-threat 0) (set-strategic-number sn-cavalry-threat 0) ;(set-strategic-number sn-disable-trade-evasion 1) ;(set-strategic-number sn-disable-villager-garrison 1) ; 2 affects towers too ;(set-strategic-number sn-target-point-adjustment 3) ; right (set-strategic-number sn-allow-drush-defense 0) (set-goal temporary-goal12 1) ; player 1 as default. (up-change-name "BruteForce") ; Make it easier for 1.5 (disable-self)) 其中LAND-NOMAD为陆游，NOMAD为游牧。下面这段造农民的代码来自Krush部分。我们实际上看到在主per文件里面也有相应的造农民代码，但这个是互相不冲突的，因为条件写得很严格。1234567891011(defrule (up-compare-goal gl-map-style != WATER) (strategic-number sn-castle-age-strategy == krush) (unit-type-count-total villager &lt; max-civ) (up-research-status c: ri-loom &lt; research-pending) (unit-type-count villager &lt; 10) (can-train villager)=&gt; (train villager) (enable-timer 46 21)) 牵羊小马斥候有时候可能看到羊，但不会多走几步取得这头羊控制权，并将其派回TC，因此需要进行牵羊。 放伐木场、磨坊伐木一般要晚于磨坊。虽然农民一般先狩猎，但当羊比较难找时草料丛就起作用了，还有一点是为了种田的方便，最好让农民先把TC旁边的树木全部伐倒。resource-found语句中food参数特指草料丛，wood参数特指树林（而不是单棵的树）。但有时候（如存档aitest_farwood）即使找到了森林，伐木场依然可能建在单棵树的旁边，解决方案可以是延缓伐木场的建造时间，例如在第一个房子建成后。注意这条命令是一次性的，即使后面树木全部被挖完了，也依然是ture。如何检测是否还有树呢？可以使用下面的命令，如dropsite-min-distance wood &lt; 255在修建完伐木场后，可以检查dropsite-min-distance，dropsite-min-distance是个fact，用来检测从资源点到资源放置点的最少距离。如果说这个值比较大，那么我们的伐木场的效率就不算很高。 为什么农民建完伐木场不呆在伐木场旁边采木头，而是回去牧羊了呢？这时候可以利用up-target-objects命令，强制农民走到伐木场处1234567891011121314151617; Task villagers to lumber-camp(defrule (current-age == dark-age) (building-type-count lumber-camp &gt; 0)=&gt; (up-reset-search 1 1 1 1) (up-reset-filters) (up-find-local c: villager-m-lumberjack c: 240) (up-find-local c: villager-f-lumberjack c: 240) (up-modify-goal temporary-goal s:= sn-focus-player-number) (up-modify-sn sn-focus-player-number c:= my-player-number) (up-find-remote c: lumber-camp c: 1) (up-target-objects 0 action-default -1 -1) (up-modify-sn sn-focus-player-number g:= temporary-goal) (chat-local-to-self "task villagers to lumbercamp") (disable-self)) up-target-objects将被选择的up-find-local以普通模式action-normal（还可以选择action-patrol巡逻模式）指引到(direct against)up-find-remote除此之外，第三四个参数分别为阵型（formation-line, formation-box, formation-stagger, formation-flank）和动作（stance-aggressive, stance-defensive, stance-stand-ground, stance-no-attack） BTW，我在搜sn-intelligent-gathering时意外的发现了相反的问题 拉猪这段代码来自于Bruteforce电脑拉猪一般是用农民拉猪，升级织布机农民能够减少长距离拉猪农民死亡的可能性。1234567891011(defrule (up-research-status c: ri-loom &gt;= research-pending) (or(unit-type-count-total villager &gt;= 11) (game-time &gt; 275)) (strategic-number sn-enable-boar-hunting != 2) (dropsite-min-distance live-boar != -1) (dropsite-min-distance live-boar s:&lt; sn-maximum-hunt-drop-distance)=&gt; (set-strategic-number sn-enable-boar-hunting 2) (set-strategic-number sn-maximum-hunt-drop-distance 32)) sn-enable-boar-hunting设为1是会杀鹿和猪，2则只杀猪。首先当农民数大于等于11的时候，织布机升完了，此时如果猪距小于sn-maximum-hunt-drop-distance就设置sn-enable-boar-hunting为允许。注意特别判断值为-1，即未定义的情况，不然-1恒小于任何数会出错。下面就开始拉第一头猪。12345678910111213141516171819(defrule (strategic-number sn-enable-boar-hunting == 2) ;(dropsite-min-distance boar-hunting &gt; 10) (dropsite-min-distance live-boar != -1) (dropsite-min-distance live-boar != 255) ;(dropsite-min-distance live-boar s:&lt; sn-maximum-hunt-drop-distance) (dropsite-min-distance live-boar &lt; 32) (unit-type-count villager-hunter == 0) (up-timer-status 7 != timer-running)=&gt; (set-strategic-number sn-minimum-number-hunters 1) (set-strategic-number sn-minimum-boar-hunt-group-size 1) (set-strategic-number sn-minimum-boar-lure-group-size 1) ;(up-chat-data-to-self "sn-maximum-hunt-drop-distance: %d" s: sn-maximum-hunt-drop-distance) (chat-local-to-self "Begin luring boar") (up-retask-gatherers food c: 1) (up-request-hunters c: 1) (enable-timer 7 5)) up-retask-gatherers重新指派给定数量的村民收集某种资源。up-request-hunters尝试请求给定数量的猎人加入采集猪肉的队伍，不能保证到达给定的全部数量。villager-hunter是一个在UserPatch之外的常数，表示猎人的数目。经过测试，牧羊人不能称作猎人。下面两个命令容易混淆，sn-minimum-boar-hunt-group-size指的是达到多少个农民就可以开始猎杀野猪（此时猪可能已经被拉到TC下）。而sn-minimum-boar-lure-group-size指的是使用多少个农民拉猪，由于猪只同时对一个农民仇恨，所以一般设为1sn-minimum-number-hunters用来强制至少有多少猎人，一般在杀猪时结合sn-minimum-boar-hunt-group-size和up-request-hunters使用。enable-timer 7 5这个是干什么用的呢？这是为了防止之前杀猪的农民挂了，可以重新拉猪拉猪是拉猪，拉到TC下还要杀猪，下面的rule用来处理杀猪。123456789101112131415(defrule (strategic-number sn-enable-boar-hunting == 2) (dropsite-min-distance live-boar != -1) (dropsite-min-distance live-boar &lt; 5) (or(unit-type-count 122 &gt;= 1) (unit-type-count 216 &gt;= 1)) (unit-type-count villager-hunter &lt; 6) ; 8=&gt; (set-strategic-number sn-minimum-number-hunters 8) (set-strategic-number sn-minimum-boar-hunt-group-size 8) (set-strategic-number sn-minimum-boar-lure-group-size 8) (chat-local-to-self "Request support hunters") ;(up-retask-gatherers food c: 8) (up-request-hunters c: 8)) 这里122指男猎人 ，216指女猎人，当猪离TC很近了（小于等于5），这时候就用猎人来杀猪。下面的规则用来拉第二头猪。经测试“Attempting to lure another boar”、“Injured villager found – search again.”、“Begin luring boar (2)”三条规则依次触发。123456789101112131415161718(defrule (strategic-number sn-enable-boar-hunting == 2) (dropsite-min-distance live-boar s:&lt; sn-maximum-hunt-drop-distance) (dropsite-min-distance boar-hunting &lt; 10) (up-remaining-boar-amount &lt; 195) (strategic-number sn-minimum-number-hunters &gt; 1)=&gt; (set-strategic-number sn-minimum-number-hunters 1) (set-strategic-number sn-minimum-boar-hunt-group-size 1) (set-strategic-number sn-minimum-boar-lure-group-size 1) (chat-local-to-self "Attempting to lure another boar") (up-reset-search 1 1 1 1) (up-reset-filters) (up-set-target-point gl-position-self-x) (up-filter-distance c: -1 c: 10) (up-find-local c: villager-class c: 1) (set-goal gl-boar-lurer-search 1)) up-remaining-boar-amount检查当前猪所剩食物量。只有在另一猪可捕猎时，本数据才有效。否则数据会是65535（似乎65535等于-1，不知道为啥不设为0或者-1），以显示这是最后一头猪。Barbarian野蛮人ai似乎都没有用过这个fact。因为第二头猪通常比较远，而且拉完第一个猪农民会有残血，所以这里检查当前农民的血量是否足够，不够的话会(up-jump-rule -1)回到上面的“Attempting to lure another boar”，重新搜索一个农民。12345678910(defrule (goal gl-boar-lurer-search 1) (up-set-target-object search-local c: 0) (up-object-data object-data-hitpoints &lt; 40)=&gt; (up-reset-search 0 1 0 0) (up-find-local c: villager-class c: 1) (up-jump-rule -1) (chat-local-to-self "Injured villager found -- search again.")) up-object-data检查选定目标物件的特定信息，object-data-hitpoints常数表示生命值。12345678910111213(defrule (goal gl-boar-lurer-search 1) (up-set-target-object search-local c: 0)=&gt; (up-filter-distance c: -1 s: sn-maximum-hunt-drop-distance) (set-strategic-number sn-focus-player-number 0) (up-find-remote c: wild-boar c: 1) (up-find-remote c: javelina c: 1) (up-set-target-object search-remote c: 0) (up-target-objects 0 action-default -1 -1) (chat-local-to-self "Begin luring boar (2)") (set-goal gl-boar-lurer-search 2)) sn-maximum-hunt-drop-distance设置电脑玩家捕猎时资源距离资源放置点的最大距离。这里wild-boar和javelina都表示野猪。下面的这个规则就很有意思了，为啥会有这个条件呢？首先触发条件，主要包括3部分： (goal gl-boar-lurer-search 2) 当”Begin luring boar (2)”对应规则被触发后即满足，也就是说它只发生在拉第二头猪 dropsite-min-distance live-boar &lt; 5 表示当猪足够近的时候 up-timer-status 7 != timer-running 这个条件似乎正常情况下并不会满足1234567891011121314151617181920(defrule (strategic-number sn-enable-boar-hunting == 2) (dropsite-min-distance live-boar != -1) (dropsite-min-distance live-boar &lt; 5) (goal gl-boar-lurer-search 2) (unit-type-count villager-hunter &gt; 0) (up-timer-status 7 != timer-running) ;(unit-type-count villager-hunter &gt;= 8)=&gt; (up-reset-search 1 1 1 1) (up-reset-filters) (up-set-target-point gl-position-self-x) (up-filter-distance c: -1 c: 10) (up-find-local c: villager-class c: 6) (set-strategic-number sn-focus-player-number 0) (up-find-remote c: wild-boar c: 1) (up-find-remote c: javelina c: 1) (up-target-objects 0 action-default -1 -1) (enable-timer 7 10)) 我们看看(up-set-target-point gl-position-self-x)，通过检查前面的代码gl-position-self-x指的是TC的坐标。所以说它的作用是当第二只猪很近的时候，隔一段时间选择6个农民走向它，这是在杀猪么？然而同样触发的是“Request support hunters”，并且可能会触发好几次。 赶鹿下面这条规则是当没有猪时开始杀鹿123456789101112131415161718(defrule (up-research-status c: ri-loom &gt;= research-pending) (unit-type-count-total villager &gt;= 11) (strategic-number sn-enable-boar-hunting == 2) (unit-type-count-total villager &gt;= 20) (up-compare-goal gl-my-boars &lt; 1) (or(dropsite-min-distance live-boar == -1) (dropsite-min-distance live-boar s:&gt; sn-maximum-hunt-drop-distance))=&gt; (set-strategic-number sn-enable-boar-hunting 1) (set-strategic-number sn-minimum-number-hunters 0) ; 4 (set-strategic-number sn-minimum-boar-hunt-group-size 1) (set-strategic-number sn-minimum-boar-lure-group-size 1) (set-goal gl-boar-lurer-search 0) ;(up-retask-gatherers food c: 4) (up-request-hunters c: 4) (chat-local-to-self "No boar in range, allow deer hunting")) 种田空闲的农田初期农田会空闲，这是因为农民要去杀猪和杀羊，如果不去杀动物，那么它们的尸体会慢慢腐烂，食物就浪费了，但是田一旦建好了就不会坏，所以可以先杀动物，再种田。当城镇被攻击后农民会空闲。 升级时代1234567891011121314151617181920212223242526272829303132333435363738(defrule (game-time &gt; 132) (food-amount &lt; 50) (up-research-status c: feudal-age &lt; research-pending) ; current-age &lt; imp (up-pending-objects c: villager &lt; 1)=&gt; (up-drop-resources sheep-food c: 5) (up-drop-resources farm-food c: 5) (up-drop-resources forage-food c: 5) (up-drop-resources deer-food c: 20) (up-drop-resources boar-food c: 7) ; 10)(defrule (game-time &gt; 132) (food-amount &lt; 50) (food-amount &gt;= 44) (up-research-status c: feudal-age &lt; research-pending) (up-pending-objects c: villager &lt; 1)=&gt; (up-drop-resources sheep-food c: 2) (up-drop-resources farm-food c: 2) (up-drop-resources forage-food c: 2) (up-drop-resources deer-food c: 20) (up-drop-resources boar-food c: 2) ; 10)(defrule (current-age == dark-age) (strategic-number sn-enable-training-queue == 1) (up-pending-objects c: villager &lt; 2) (food-amount &lt; 50) (timer-triggered 46)=&gt; (up-drop-resources sheep-food c: 5) (up-drop-resources farm-food c: 5) (up-drop-resources forage-food c: 5) (up-drop-resources deer-food c: 20) (up-drop-resources boar-food c: 10)) 这里up-drop-resources指的是让至少携带若干资源的村民上交资源，例如当初期要断农民或者差一点点封建的时候，就可以使用这个命令争取时间。在黑暗时代农民只能携带10单位的资源，在后面升级了手推车等科技之后农民携带的资源会增多。此外如果让一个携带某种资源的农民去采集另外的资源，那么已采集到的资源会被丢弃，但是如果是去修建筑资源不会被丢弃。也可以通过up-garrison指令让农民进入TC交资源再出来，节省走路时间。 放兵营为啥兵营会放在不前不后的地方？ 侦察敌情一般小马探路只会在家里转，这叫explorer。那么如何让它探对手家里呢？up-send-scout加上position-位置常数可以做到这一点 强行建造征服者的默认AI建造工事的时候，如果被攻击就会立刻取消建筑，事实上这是不完善的，比如有时候我们就想强行肛一个城堡。sn-percent-building-cancellation可以提供这样的功能 建造第二个TC123456(defrule (building-type-count-total town-center &gt;= 1) (building-type-count-total town-center &lt; 2)=&gt; (set-strategic-number sn-town-center-placement mining-camp))]]></content>
      <tags>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苏州无锡连云港游记]]></title>
    <url>%2F2017%2F10%2F02%2F%E8%8B%8F%E5%B7%9E%E6%97%A0%E9%94%A1%E8%BF%9E%E4%BA%91%E6%B8%AF%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[连云港、无锡、苏州虽然是7-9月份不同时间玩的，但都是本省景点，所以合并为一篇游记来记录 连云港当时正值盛夏最热的时候，我们不想待在家里吹空调，出于交通方便的考虑，而且连云港靠山靠海，我们报了一个低价团（400块）前往连云港两日游。一早上到了金融中心乘上了去日照的车，到了老圩收费站我们和直接从泰州过来去连云港的大巴交换了人。上了大巴便感到一股热浪，这空调也太次了点了吧。到了连云港，先去了高速口附近的一个叫云龙涧的地方，导游说连云港的花果山其实属于云台山，是沂蒙山的余脉，云龙涧属于中云台山，花果山属于前云台山，而今天下午要去的东西连岛属于后云台山。云龙涧据说有江苏省落差最大的瀑布。晚上宾馆空调仿佛被大巴车传染了一样，一点用没有。我们去了街对面一家人特别多的饭店吃。这家饭店没有菜单，客人直接去后厨房看食材然后点菜。我们点了鱿鱼汤、一盆小鱼一道素菜，还有一盘饺子才一百多。而且非常好吃。回来洗澡，水像开水一样，非常烫。第二天去了花果山，据说花果山的猴子是非常有意思的多的 无锡我们乘坐神车之一D2281前往无锡，当时正值某会议，所有途径厦门的车辆都要二次安检，到了候车室要上个厕所都得出去。刚出无锡站地下通道便有中铁国旅的人问我们要不要参加他们的一日游，出于节省交通时间的因素我们报了他们的团。他们说这时候想玩鼋头渚和无锡影视基地有点晚，便推荐我们选择一个人一百二，包车去三国城水浒城。去火车站外面的一间小屋签了旅游合同之后我们便上了一辆MPV。这个团是没有导游的团，导游负责买好门票，然后把你带到三国城看完一个表演，然后就给你自由活动了。由于我们是晚上八点多的火车，还是想问问能不能帮我们买一下鼋头渚的票。导游说玩完三国城水浒城已经差不多要两三点了，来不及去鼋头渚，而且鼋头渚的樱花是最好看的，值得每年春上单独来看一下。然后她给我们推荐了蠡园。看完三英战吕布，导游带领我们乘船，她极力向我们推荐30块的交通车，说影视基地很大，走过去太累了，但我们没坐。磨了半天嘴皮子，导游说下午水浒城还有个大型演出，你们不坐车不一定能赶得上。但是从竞技场绕了圈，决定放弃赤壁栈道，上古城墙，古城墙上去的路还有点陡，不过风景比下面的赤壁栈道要好很多。下来就到了七星坛，从七星坛下来我们坐20路公交车来到了蠡园，前面有个旅行团正在走侧门（渔庄）进，我爸OS我偏偏要从正门进，于是我们到正门，交上了导游写过我们的凭条，工作人员便放我们进去了。我爸说之前来过蠡园，说蠡园很小，自己当时一日游玩了七八个景点。同其他的园林一样，蠡园也是内敛的，我们从入口绕了会，经过了百花山房和西施传说廊，眼前才豁然开朗。无锡园林和苏州园林不同的地方在于苏州是假山假水，无锡是假山真水，例如蠡园依靠太湖，远远看去一道长廊沿湖蜿蜒，湖心更有一座小岛。我们进园时已是四点，已经没有游船了。沿着进来的路往南走，蠡园被一道墙分割为西部和东部，西部比较大，里面有很多园艺展览，应该是后来扩建的部分，我们先去的是精华的东部。左手边是一片巨大的荷花塘，一直连通南面的太湖，在荷叶荷花的掩映中、层层叠叠的堤桥间矗立着各式各样的一些亭子，后来看地图知道这是蠡园非常著名的春夏秋冬四座亭子。我们沿着长堤继续往东行走。在大堤引领下我们观赏了一片湖景，往东边望去，有一座摩天轮，这应该就是蠡湖公园，我高三去蠡湖小学参加一个组装机器人的比赛后曾经被带到那里玩过那里。大堤往岸的方向转去，塘两边开始出现黄色的睡莲，前方便是进门看到的长廊，称为千步长廊。长廊里面传来刚才团队的导游的解说声，我说要不然还是蹭导游吧。可是往前走却便是一处四个方向的“立交桥”，下了桥前方便是假山石了，这里有一方泉井，称为洗耳泉。绕过洗耳泉是一座巨大的阴暗的亭子，那边似乎没去过，但是是和千步长廊的反方向，于是我们往回走。往前走右边出现一道墙，应该是千步长廊的墙，导游的声音却从墙那一面传来，尴尬了，我们怎么绕过了这个长廊？继续往前走，左边是一片池塘，池塘中矗立着一座西施的雕像，西施正对着一座拱桥，拱桥的桥洞倒影在波澜不惊的水面上，形成一个圆，宛如一轮明月，这个景点就叫做西施映月。西施映月的映月桥往东，左边有另一篇一片小池塘，池塘对面就是春秋阁。春秋阁后面又是一片池塘，这时候应该已经到达蠡园的边缘了，外面的高楼（湖滨饭店）仿佛紧贴着青山绿水后面拔地而起。这景点称为层波叠影，其实是后来拓建的景区。右手边是一道架立于水上的廊桥，当时没怎么注意，等游完拙政园的小飞虹之后觉得这个挺厉害的。过了层波叠影，再往后面走，出现了最后一片池塘，池塘北面有一座两层黄墙绿瓦的别墅，很是别致。从这里可以上到千步长廊，往东看去是一座五层红墙宝塔（凝春塔），不过这里已是长廊的最东段，一道门阻挡了我们，因此去不到宝塔处，不过通往湖心亭还是可以去的。从湖心亭可以看到湖中的岛，如果早一点我们应该是能够乘船去岛上玩一玩的，不过现在已经四点半了，于是我们沿着长廊往回走。从长廊上下来到春秋阁那里看到有卖烧饼的，我们中午都只是吃的干粮，已经有点饿了，感觉还挺好吃的。从长廊上下来，往北面走了会，回到了洗耳泉，于是我们继续往北走，从西施映月穿过。又看到一座假山，上面有一座亭子，叫归云峰。我往上爬了一段，觉得还有点高，便说不爬了，选了另一条路继续往前走。从归云峰上下来，我们觉得蠡园太乱了，准备回到入口处要张门票。不过如何去到入口也是一个技术活，我们绕了一会儿到了之前导游带队进去的入口。 经过了之前的假山，我已经明白了，它的设计就是只闻其声不见其人，有时候近在咫尺的东西需要绕上一段路才能够到达，于是我果断往反方向走，绕了一个360度的大弯，终于到达了矮墙另一边的石舫。 苏州我们进拙政园是两点四十左右，一进门就是游客服务中心，我发现一个柜台上说有免费的讲解服务，赶快喊上堂高，我们要不跟着讲解走吧，堂高欣然同意。不过排到我们的时候工作说三点钟的讲解刚好排满了，她拿着我们的身份证反复地刷了刷，确定是不行的。便要我们等三点半的，这时候外面还在下雨，于是我们勉强同意了。我顺便去穿了鞋套，回来的时候和堂高说没几分钟就能预约下一班了，我就在这儿等着吧，省得又没排上。发现身后有六个人正在联系收费的讲解服务（80分钟，免费讲解服务只有40分钟），不一会儿有两个人来退免费导游的预约了，我看了看时间两点五十四，快到预约截止时间了，就赶快和工作人员说现在有名额了我们想改成三点的一班。 古代园林中借景这一手法非常常用，报恩塔远香堂是拙政园主人的会客厅。导游指着远香堂对面一座假山后面说这里有一道两米高的木门，虽然十分不起眼，但这是以前拙政园的正门。走过远香堂便到了著名的两个景点小飞虹和香洲。香洲上的牌匾原迹是文征明所作，后来果然又在文革中被摧毁了。中花园是明式的，西花园则是清式的。导游带领我们“别有洞天”的一石拱门穿过，便进入了西花园。卅六鸳鸯馆反面则是十八曼陀罗馆，这就如同一张纸的正反面一样。卅六鸳鸯馆部分建造在水面之上。从卅六鸳鸯馆出来边到了一座铁桥，传说文革时为了避免这座铁桥被破坏，主人将铁桥拆解，然后沉入水底。过了铁桥便到了最后一个景点留听阁，所谓留得残荷听雨声，这阁名便是源自此诗。导游将我们带到盆景园便解散了，这里的盆景并没有之前在虎丘万景山庄的多，也没有蠡园的园艺别致。于是我们开始拙政园景点打卡旅程。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Kickstart 2017 Round F题解]]></title>
    <url>%2F2017%2F09%2F25%2FKickstart2017F%2F</url>
    <content type="text"><![CDATA[Google Kickstart 2017 Round F，当时做了两条就睡觉了，早上把剩下两条也过了。感觉不算是很难，可能也和这场限时24h有关吧。不过提交的时候倒是手忙脚乱，第一条交了三发，第一发是从VS迁移到DevC上是DevC由于之前配了个C++14所以崩了，第二发输出里面是Unicode BOM，WA了，蛋疼。 A. Kicksort找规律发现每次找的pivot的位置是从原数组的中心点（奇）或中心线靠左（偶）开始，如果小于原数组的中位数，则下一个位置是其轴对称，否则是其左边一个位置。这样从数组的中部交替往外移动，结束条件是pivot到达原数组的最后一个元素。由于这个过程中所有选为的pivot都是最大/小值才返回YES，否则直接返回NO，所以只要迭代继续，我们去掉的就一直是最大/小值。因此使用l和r记录此时所有还没被作为pivot去掉的数中的最大/小值，判断新的pivot是否等于l或r。AC代码 B. Dance Battle由于Delay和Truce规则，我们实际上并不需要考虑舞者的顺序问题。我们将舞者的S值从小到大排序，从小端开始Dance，从大端开始Recruit。当在l位置处e不够的时候去Recruit是不亏的，因为虽然在大端位置r处损失了一点honor，但是大端增加的S[r]肯定至少能够干掉S[l]获得一点honor了，除非l = r，这时候应该直接Truce。AC代码 C. Catch Them All有个无向图，N点M边，第i条边要走$D_i$分钟，宠物小精灵以$1/(N-1)$的均匀几率出现在你不在的地方，直到你抓到后另一个小精灵才出现。求抓到P个小精灵的时间期望。首先自然是floyd求一下最短路。然后是一个没有环的概率DP，可以正着迭代掉。 D. Eat CakeLeetcode原题Perfect SquaresAC代码]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>codejam</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记忆化搜索和动态规划]]></title>
    <url>%2F2017%2F09%2F24%2F%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%E5%92%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[记忆化搜索和动态规划常常是两种成对出现的解法。 合唱这道题来自网易2018校园招聘编程题真题集合的倒数第二题。 记忆化搜索偏重于在传统的递归搜索中复用一些中间结果。其框架大致为result = search(start)形式，并且在能够复用前必定已经到达过一次递归底部。对于本题，记忆化搜索是简单易懂的。123456789101112131415161718192021222324252627282930int solve(int i, int j) &#123; if (dp[i][j] == -1) &#123; int next = max(i, j) + 1; if (next &gt; n) &#123; return 0; &#125; int ch1 = i == 0 ? solve(next, j) : solve(next, j) + abs(a[next] - a[i]); int ch2 = j == 0 ? solve(i, next) : solve(i, next) + abs(a[next] - a[j]); dp[i][j] = min(ch1, ch2); &#125; return dp[i][j];&#125;int main() &#123; int T, cas = 0; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;a[i]); &#125; memset(dp, -1, sizeof dp); printf("%d\n", solve(0, 0));#ifdef __ACM system("pause");#endif return 0;&#125; 常可以借助于反向DP来取代记忆化搜索里面的递归。正向DP的方法容易进入一个误区，这里的dp[i][j]并不一定从dp[i - 1][j]和dp[i][j - 1]之间转移得到，例如dp[3][2]完全可以是由dp[3][0]得到的。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 2089 不要62 数位DP]]></title>
    <url>%2F2017%2F09%2F23%2FHDU2089%E4%B8%8D%E8%A6%8162%2F</url>
    <content type="text"><![CDATA[这条题目是典型的求[L, R]区间内满足某性质的整数的数目问题，通常解法是用[0, R]区间的数目减去[0, L-1]区间的数目。数位DP是此类问题常见的解题思路。 数位DP模板数位dp其实类似于中记忆化搜索。数位DP由最深$N$（$N$为$R$的十进制位数）层dfs组成。出于实现方便，数字$123$映射到int nums[]数组中，首尾颠倒变成$[3, 2, 1]$。由于从原数字的最高位往最末位递归，因此记忆化搜索的每次递归pos是从$N-1$递减的。123456789101112LL solve(int x)&#123; memset(nums, 0, sizeof nums); memset(dp, -1, sizeof dp); int ppos = 0; while (x != 0) &#123; nums[ppos++] = x % 10; x /= 10; &#125; // 开始dfs记忆化搜索 LL ans = dfs(ppos - 1, 0, true); return ans;&#125; flag表示在遍历当前pos位时，比pos位低的$[0..pos-1]$位是否有限制，其初始值为true，因为最高位肯定是有限制的。例如数字$234$，在遍历到$cur[2]$为$1$时，$cur[2..1]$能够取遍$[10..19]$，但是当$cur[2]$为能取的上确界$2$时，低位的$cur[1]$只能够在$[0..nums[1]]$的范围里面取了，$cur[2..1]$取值为$[21..23]$。总结规律，只有前缀$[pos+1 .. N-1]$的flag为true（前缀的所有位都取到了上确界），且当前位pos的当前值$cur[pos]$也取上确界$nums[pos]$或$9$时，低位$cur[pos-1]$只能取$[0..nums[pos-1]]$，否则能自由取$[0..9]$。status用来表示状态，这个状态被用来计算当前子问题的结果，例如在这道题目中，status用来记录是否存在62或者4。 子结构一般为$dp[pos][..]..$的多维数组。后面的几维与状态有关，有时候可能还需要进行离散化。从上面可知当flag为true的时候，不能取满$[0..9]$，此时我们就没必要记录下结果，因为显然取满的情况是占绝大多数的。因此dfs的结构如下12345678910111213141516171819202122232425LL dfs(int pos, int status, bool flag) &#123; if (pos == -1) &#123; // 如果到达最深层，check是否继续满足题目中的性质 return check(status) ? 1 : 0; &#125; if (!flag &amp;&amp; dp[pos][status] != -1) &#123; // 如果此层能够取满，那查看能不能复用存储的结果 return dp[pos][status]; &#125; LL ans = 0; int end = flag ? nums[pos] : 9; // 如果flag为true就是不自由的，end只能取到nums[pos] for (int i = 0; i &lt;= end; i++) &#123; int newstatus = ...; // 如果最终结果与前缀的结果满足and或者or的性质，这里还可以剪枝 bool newflag = flag &amp;&amp; (i == end); // 下一层的flag，注意要满足两个条件 ans += dfs(pos - 1, newstatus, newflag); &#125; if (!flag) &#123; // 只保存任何层取满[0..9]的结果 dp[pos][status] = ans; &#125; return ans;&#125; 题解AC代码]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式一致性协议笔记]]></title>
    <url>%2F2017%2F09%2F20%2F%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[在本文中将讨论CAP理论、2PC和3PC协议、RWN协议、Raft协议、Paxos协议。 分布式系统中的CAP理论CAP理论CAP理论提出之后一直广受质疑，但并不影响其成为一套经典理论。CAP理论认为一致性(consistency)、可用性(availability)和分区容错性(partition tolerance)是不可能同时被满足的。 一致性一致性即all nodes see the same data at the same time。这个要求是比较高的，通常称为强一致性，有的时候系统保证在更新操作后的一段时间后，系统能够达到一致性状态，这称为弱一致性。最终一致性是一种弱一致性模型，还可以分为因果一致性、单调读一致性、单调写一致性等。具体地讲，一致性需要满足下面三个条件 agreement 决议需要得到所有节点的认同，通常是首先批准一个多数票的决议，然后进行同步。 validity 决议的值需要满足合法性要求 termination(liveness) 决议过程能够在有限步内结束，并产生结果。 可用性可用性即reads and writes always succeed。这个要求系统能够始终在正常时间内对用户的请求进行响应。当然由于可能出现的一致性问题，这个响应不一定是正确的。 分区容错性分区容错性即the system continues to operate despite arbitrary message loss or failure of part of the system。由于分布式集群中常出现网络分区情况，即集群中的一部分机器与另一部分机器中断连接，这可能是由于网络故障，产生网络分区；也可能是由于某些节点宕机。我们除非设计出一个永远不会出故障的网络，否则我们必须要容忍P。于是C和A便成为了trade-off。由于网络分区的概率比较小，并且是易于探测的，所以C和A大多数情况是能够比较好地满足的，所以说我们要做的不是根除网络分区及其导致的部分失效(partial failure)问题，而是去正确地处理它，这就引入了下面的一些协议。 分布式共识关系型数据库中的事务ACID准则对于关系型数据库，存在ACID原则维护事务的正确可靠性。原子性(atomicity)表现为事务中的所有操作要么全部完成，要么全部不完成（回滚），不会出现中间状态。一致性(consistency)表现为在事务开始前和结束后完整性约束不被破坏。隔离性(isolation)表现为数据库支持多个并发事务同时进行增删改。持久性(durability)表现为事务结束后对数据的修改是持久化的。 前像与后像在关系数据库中常使用Write ahead log(WAL)算法，WAL要求在数据实际写入之前先写日志，这样能够保证在故障发生后能通过日志进行恢复。事务有只有两种完成方式，提交即全做事务中的操作，和回滚即全不做事务中的操作。在事务的中间过程中可能对数据块的值进行修改，但最终这些修改必须要通过提交和回滚来实现持久化。AI（后像，After Image），指的是每次更新时数据块的新值。对于一个已提交的事务，当故障发生时应当REDO它的后像。注意一旦事务提交，就不能UNDO它的前像，会破坏完整性约束；但是事务提交前任意的删改都可以通过UNDO来撤销。事务提交和往数据库写值（执行事务）是两个不同概念。BI（前像，Before Image），指的是每次更新时数据块的旧值。对于一个未提交的事务或提交进行到一半，当故障发生时应当UNDO它的前像。UNDO和REDO操作具有幂等性，即对前像UNDO或对后像REDO任意多次，结果都是相同的。 事务更新的两条规则提交规则后像必须在提交前写入非易失存储器（数据库或运行记录）中。当后像只写入日志而没写入数据库中也可以提交事务，因为出现故障之后可以使用后像REDO进行恢复。 先记后写规则数据库中有先记后写原则，如果在事务提交前将后像写入数据库，则必须首先把前像记入日志。这样做的好处是在事务提交完成前如果出现故障，可以通过日志文件中的该前像进行UNDO，此时即使数据库没有被修改，也只是进行一次多余的UNDO操作。 分布式共识面临的问题分布式事务由于分布式系统中存在多个副本，所以维护这些副本的一致性成为核心问题之一。分布式事务相对于仅涉及单个数据库事务的难点在于其提交或回滚不仅决定于自身，还决定于其他节点上事务执行的状态。从理想考虑，只要有一台节点失效，其他节点就要进行rollback。为了实现这一点，需要一个协调者(Coordinator)来根据所有参与者(Cohorts)的情况判断是否完成提交或终止提交。同时协调者的故障称为单点故障，也就是这个故障能够直接导致集群无法运行，需要特别考虑。 拜占庭将军问题复制状态机复制状态机(RSM)源自Paxos算法。通过同步日志，使得多个节点从相同的初始状态开始，按顺序执行相同的命令，转移到相同的状态。 2PC和3PC两阶段提交协议第一阶段（投票阶段）首先协调者向所有的参与者发出提交请求VOTE_REQUEST，参与者按照事务的标准流程写UNDO和REDO等日志，并在本地执行事务。如果事务执行顺利，则不提交（尽管事务中的全部操作已经正确完成），返回一个VOTE_COMMIT给协调者，表示自己成功执行了事务。如果事务执行出现错误，则返回一个VOTE_ABORT。 第二阶段（执行提交阶段）假设协调者没有宕机，相应会出现两种状态： 成功，发生在所有的参与者节点都返回VOTE_COMMIT 此时协调者向所有参与者发送GLOBAL_COMMIT，参与者收到之后正式提交事务并释放资源，然后返回ACK确认 失败，发生在任意参与者节点返回VOTE_ABORT，或者有的参与者timeout 此时协调者向所有参与者发送GLOBAL_ROLLBACK，参与者收到之后UNDO回前像状态，然后返回ACK确认 协调者宕机情况对一致性的影响OK，刚才协调者没有宕机，看起来很美好，可是如果协调者宕机了呢？首先如果有一台参与者收到来自协调者的信息GLOBAL_COMMIT，那么就能通过某种选举协议作为新的协调者重新掌控大局。可是如果这台参与者也宕机了呢？这就需要分类讨论 假设参与者全部宕机 这时候整个集群“死绝了”，变成平凡情况，由于没人（有能力）commit，所以不一致性不会受到破坏。 假设参与者部分宕机 这时候不一致性是一定遭到破坏的了。虽然未宕机的参与者中可能存在有收到来自协调者消息的，可以选一个新协调者出来，但是宕机的参与者究竟是否提交成功是个量子力学问题了，所以新协调者即使知道原协调者发出了commit指令，也不能断然决定去commit。 二阶段提交协议的不足阻塞2PC协议中，参与者一直是事务阻塞的，因此在事务进行的过程中，系统不能响应第三方节点的访问。这是偏于保守的，牺牲了一部分的可用性。阻塞带来的另一个问题来自于协调者可能的故障。如果协调者挂掉，连接中断，可以重新选一个协调者。但如果协调者宕机，那么所有的参与者会跟着阻塞下去。这和参与者宕机形成比较，协调者对于参与者有timeout机制，但是参与者对协调者没有timeout机制。 不一致我们知道2PC协议通过分出投票阶段能够根据所有节点上事务的执行情况判断执行提交或者回滚。但它在第二阶段依然会出现不一致问题。 第二阶段出现网络分区 假设协调者发出了GLOBAL_COMMIT请求时发生了网络分区，此时有一部分节点收到消息正常commit，但另一部分节点未收到，还处于阻塞状态。 此时协调者仍可以通过最终返回的ACK进行补救。 第二阶段协调者宕机 假设协调者宕机了，并且部分接受到GLOBAL_COMMIT请求的参与者也宕机/分区了，此时不论一致性，单宕机的参与者的事务是否提交都已经是不确定的了 三阶段提交协议三阶段提交协议针对以上2PC的两点不足采取了一些措施：对参与者也引入超时措施，将执行提交阶段拆为两步。 CanCommit阶段这个类似于2PC的投票阶段，协调者发出询问是否可以提交，Yes为可以提交，No相反。 PreCommit阶段需要分为三种情况讨论： 如果上阶段全部为Yes 协调者发送PreCommit请求并进入Prepared状态 参与者接受到PreCommit后确保事务操作全部执行并记录UNDO与REDO，返回ACK 如果上阶段有No 协调者发送abort请求 参与者接受到abort后，REDO，中断事务，发送ACK 例外情况：参与者未收到协调者的消息 这可以认为是协调者的timeout，此时中断事务 注意到这里参与者是可以处理协调者的timeout的 DoCommit阶段这是真正的事务提交阶段，同样分为三种情况 协调者收全上阶段ACK 协调者发送DoCommit请求 参与者接受到DoCommit后提交事务，返回ACK 协调者未收到上阶段ACK 这发生在协调者没有收到一些参与者的ACK（网络分区或该参与者abort） 协调者发送abort请求 参与者接受到abort，使用同上阶段的方式中断事务 例外情况：参与者未收到协调者的消息 这又是一个协调者的timeout，此时提交事务 为什么选择提交事务而不是中断事务？因为此时提交事务成功的可能性非常非常大了，但仍有例外，例如： 进入PreCommit后，协调者发出的是abort请求，如果只有一个Cohort收到并进行了abort操作，而其他对于系统状态未知的Cohort会根据3PC选择继续Commit，这仍然会导致不一致，不过这个概率就显然非常小了 三阶段提交协议的不足相对于2PC，3PC避免了协调者宕机之后可能出现的参与者们陷入状态停滞，群龙无首的情况。但仍然有较小的概率会导致不一致。 RWNRaftRaft协议的设计者们认为Paxos协议非常难于理解，并且需要作出很多修改才能够应用到工程中，因此设计了偏重于实现的Raft协议，这甚至体现在他们的论文标题《In Search of an Understandable Consensus Algorithm(Extended Version)》上。Raft协议主要分为三个模块，Leader election、Log replication和Safety。Raft将服务器节点分为Leader、Candidate和Follower三种，协调者被称为领袖/主(Leader)，参与者被称为群众(Follower)。相对于其他的协议，Raft中的Leader更强，这体现在 Leader是唯一的 Log entries只能从Leader发送给其他服务器，事实上Follower不主动发送，而只响应来自Leader和Candidate的请求 客户端只能和Leader交互，如果客户端首先连上了Follower，那么会被Follower转发给Leader Raft的独特之处还在于其在Leader election的过程中Raft使用了随机计时器进行超时。此外，Raft还提供了一个joint consensus的算法处理Membership changes的问题。 Raft基础概念状态Raft协议要求在每个节点上维护以下的状态： 共有状态 currentTerm 这个在后面的讨论中非常常用，表示了当前服务器已知的最新任期。 votedFor 顾名思义。 log[] 这个是日志，是我们需要维护一致性的对象。 commitIndex 已知的最大的已经被提交的日志条目的index。对Follower来说，这个是根据来自Leader的AppendEntriesRPC中的leaderCommit字段来更新 lastApplied 一旦commitIndex &gt; lastApplied，那么就将[lastApplied + 1, commitIndex]区间里的日志条目依次应用到复制状态机上 Leader专用状态 nextIndex[]：对于每一个服务器，Leader下一个需要发送给它的日志条目的索引值，初始化为Leader最后索引值加1 matchIndex[]：对于每一个服务器，已经复制给他的日志的最大索引值 这两个值是Leader用来同步各Follower的日志的，其功能可以查看Log replication部分。 任期Raft中的Leader具有任期机制，每个节点维护有自己节点上最新的currentTerm，出于网络分区等原因，它不一定是在全局最新的。服务器之间通信时会交换各自的任期号，如果一个节点检查到自己的currentTerm小于对方在RPC中附带的term，则更新到较大的任期值；相对应地，如果检测到自己的大于对方的，则忽略对方的请求。当一个Leader发现自己具有过期的任期时，它会立刻切换成Follower。 日志与日志约束来自客户端的请求被表示成一系列将被应用到复制状态机上的指令，这些指令在Raft集群的所有节点上被记录为日志条目(Log Entries)。在每个日志条目中记录了对应的term以及是否该条目已经被提交。Raft协议下要求日志满足以下的约束，这些约束贯穿Raft整个算法，并且是相互密不可分的。 领导人只附加原则(Leader Append-Only) Leader绝对不会删除或者覆盖自己的日志，只会增加。在后面的讨论中我们可以看到在Leader的生命周期中会通过一个优雅的办法逐步同步Follower的日志，以求达到和自己一致。换句话说，当Leader和Follower不一致时，永远是Follower顺应Leader，此时Follower的日志可能会被Leader覆盖。 日志匹配原则(Log Matching) 如果不同节点上的日志中的两个条目具有相同的index和term，那么这两个条目的内容是一致的。这个特性是由于条目始终是由Leader创建的，而一个unique的条目必然是有某个Leader（因为每个term对应一个领导人，因此可以通过term唯一标识）在某个index创建的，这使得我们可以仅根据index和term唯一标识一个日志条目。这个特性实际上是下面一个特性的必要保证。 如果不同节点上的日志中的两个条目具有相同的index和term，那么这两个日志index前的部分也相同。这是由AppendEntriesRPC这个RPC中prevLogIndex和prevLogTerm两个字段保证的。当一个AppendEntriesRPC命令到达时，Follower会比较自己是否具有prevLogIndex和prevLogTerm所标记的条目，如果没有则拒绝这次添加。因此这个特性得以始终被维护。 领导人完全性(Leader Completeness) 如果某个日志条目在某个term中已经被提交，那么这个条目必然出现在所有具有更大的term的Leader中，在这里已提交是必须的，我们将在Log replication中进行详细说明。这个规定实际上保证了选出的Leader拥有所有已经提交的日志条目，容易看出，我们先前的领导人只附加原则实际上为这个特性提供了条件。Raft的论文提到除了Leader-based的共识算法，其他的共识算法并不保证这个特性，例如Viewstamped Replication算法。 状态机安全特性(State Machine Safety) 如果一个Leader已经提交了给定的index的日志条目，那么任何其他的服务器在这个index不会提交一个不同的日志。 一旦条目被提交，那么它是持久化的(durable)而不会被丢失或更改，并且一定会被所有可用的复制状态机执行。 RPCRaft中定义了两种主要的RPC包，AppendEntriesRPC和RequestVoteRPC。 AppendEntriesRPCAppendEntriesRPC具有心跳包和推送日志的作用，包含以下部分 term 表示领导人的当前任期号。为了表示区别，下面写作rpc_term_id。 leaderId 表示当前领导人的id，这样来自客户端的请求能被Follower转发给Leader。 prevLogIndex和prevLogTerm 表示新日志条目之前的索引值和其对应的任期号，这个是为了实现我们日志匹配原则中的一个特性。 entries entries是一个数组，记录了若干日志条目。这些日志条目被Leader发送给所有的Follower。 leaderCommit 表示Leader已经提交的日志的序号，这样其他的服务器才能知道Leader当前的提交位置，并跟随提交。 Follower在接受到该RPC后会发送回执 term 表示当前的任期号 success 表示是否有效，包括检查prevLogIndex和prevLogTerm这两个条目是否能够满足日志匹配原则，检查如果term &lt; currentTerm则返回false。 RequestVoteRPC term 表示候选人的任期号 candidateId 表示候选人的id lastLogIndex和lastLogTerm 表示Candidate的最后日志条目的index和term，每个投票者会比较对方是否新于自己的，从而进行投票。 投票者在接受到该RPC后会基于term和投票规则进行判定，并发送回执 term voteGranted表明是否同意 Leader election投票过程在2PC中我们看到，参与者必须对协调者有timeout机制，否则整个系统会阻塞，Raft同样有这样的功能。Leader存活时会不停的往所有的节点发送RPC心跳包，考虑一个节点在election timeout时间（随机150ms-300ms，每个节点不同）中没有接到心跳包的情况。站在全局的角度来看，这可能是老Leader挂了，所以得选举出一个新的Leader出来；这也可能是网络延迟/分区的原因，因此可能在选举途中或者结束后老Leader又回来了。但站在这个节点的角度来看，它只能认为Leader已经挂了，因此成为Candidates参加Leader选举。此时它执行下面两个操作： 递增自己的currentTerm 发送RequestVoteRPC消息给所有节点，这时候节点们根据一定规则进行投票 成为Leader需要获得整个集群共$N$个节点中过半数（$\ge N/2+1$）的票，才能成为新的Leader，这是为了保证最多只会有一个候选人赢得选举。投票可能产生三种结果： 自己成为Leader 获得过半数票的节点自动成为Leader，并开始发送心跳包，也就是entries字段为空的AppendEntriesRPC。这样其余的节点发现rpc_term_id比自己的currentTerm大时就可以知道已经选出一个新主了，此时选举结束，Candidate重新变为Follower，并同步自己的currentTerm与新主一致。 假设先前是老Leader发生网络分区从而导致选举的产生，在新Leader产生后网络又恢复了。此时他收到了来自新Leader的心跳包。显然这个心跳包中的rpc_term_id比老Leader自己的currentTerm要大，根据任期的约束，老Leader知道了新Leader的存在，切回Follower状态并更新任期。如果老Leader在发现新Leader依然履行了一次职责，发送了一个AppendEntriesRPC。首先它会被Candidate和已经发现新Leader的节点拒绝，因为它们的任期号肯定比老Leader的要大。 别人成为Leader 对应于第一种情况，此时自己发现了一个任期号更大的Leader传来的心跳，于是自己退出选举。 没有Leader产生 这发生在没有节点获得过半数的票的情境下，例如有很多Follower的timeout时间比较接近，在选举开始时都timeout变成了Candidate，这时候每个Candidate都会投给自己，所以没有Candidate能获得大多数。此时认为currentTerm + 1届的任期以没有Leader告终，节点们开始下一轮的election timeout。由于每个节点election timeout时间都是随机的，所以下一次出现timeout时间接近的可能性并不高。 投票原则在上一节中我们提到收到RequestVoteRPC请求的节点会根据一定规则进行投票，事实上这是非常重要的，因为我们需要维护领导人完全性的原则。在Raft原论文中，这一部分是放到Safety章节来说明的，因此有必要在阅读此部分时首先查看Log replication章节。首先，我们已经知道在投票的时候一个Candidate必须得到过半数的节点的支持，这是因为每一个已经提交的日志条目必然存在在至少一个这样的节点上。我们上面断言的正确性来自在下面Log replication部分的一个规则：当Leader创建的某日志条目被成功复制到过半数的服务器上时，Leader可以提交该条目。下面我们进行另一个断言：如果两份日志最后的条目的term不同，那么term大的日志新。如果两份日志最后的条目term相同，那么日志比较长的那个就新。如果一个候选人的日志和大多数的节点一样新，那么它一定持有了所有已经提交的日志条目。 Log replication一旦由当前Leader创建的某日志条目被成功复制到过半数的服务器上时，这个Leader可以提交该条目及自己日志中该条目之前的所有条目，此后Leader会告知客户执行的结果。这里至少要过半数的原因是为前面的投票成功进行提供了保障，而不需要全部成功复制的原因会在Safety中进行论证。有意思的是即使先前的条目可能是由其他Leader创建的，但这也不影响提交，事实上在下面的讨论中我们可以看到，这种方式实际上是唯一的可以提交较旧的term的日志条目的方法。 下面的一张图展示了当前Leader对具有较旧的term的日志条目进行提交时的一种情况，其中一个已经被存储到大多数节点中的较旧的日志条目（c）也会被未来的Leader（d）覆盖掉，从而说明这样做是行不通的。这也是在提到领导人完全性原则时我们强调了已提交三个字的原因。我们首先查看a阶段，此时S1是Leader，生成一个黄色块的条目并复制给S2，此时由于未超过半数，所以S1不能进行提交。紧随后在本阶段我们看到S1未能继续复制黄色条目而崩溃了，此时S5透过S3、S4和S5的选票成为Leader（此时S1已挂，而S2的lastLogIndex和lastLogTerm会让它反对S5）。S5紧接着创建了一个蓝色块条目放到了索引2处，此时如果S5继续复制它的蓝色方块，那么S1和S2的黄色方块肯定会被覆盖掉，不过在这个例子中S5都没来得及复制就挂掉了，这时候S1恢复了，这时候它的term最大，因此成功竞选。现在到了c阶段，这时候S1继续它复制黄色log的未竞伟业，同时创建了一个红色块。S1将黄色log继续复制给S3，这时候按照我们先前的可以提交较旧的条目的假设，它已经可以提交黄色块了，但是它又挂了，因此没能成功提交。此时到了d阶段，S5恢复了，此时它的term最大，因此通过S2、S3、S4当选，这时候它稳定了，于是覆盖了所有的黄色和红色log。为了解决这个问题，Raft禁止提交一个较旧的term的条目，即使它已被复制到大部分节点。 在AppendEntriesRPC中，Leader还通过leaderCommit字段来告知所有的Follower自己当前的提交位置，每个服务器会试图在本地提交直到commitIndex的日志。注意到有的服务器可能在本地并没有这个commitIndex的日志，因此它只能提交到自己最新日志条目的index位置。在更新完后，每个节点会试图将新的commitIndex后面的日志条目应用到复制状态机上，并更新lastApplied。下面我们关注Leader的复制请求的结果。在正常情况下，Leader的日志始终是和Follower的一致的，所以来自Leader的AppendEntriesRPC始终会是成功的，但一旦Leader或者Follower出现崩溃或者网络发生脑裂，日志就会处于不一致状态，例如有些Follower会比Leader少条目或多条目，这时候就违背了日志匹配原则，导致失败，我们稍后看到这个失败实际上会被用来进行恢复一致性的工作。多条目看起来不可思议，但如下图所示，f就是一种情况，多出来的三个term为2的条目，这是可能是由于它是term为2时的Leader，并且添加了一些日志，但是在提交前崩溃了。 对于这种不一致的状态，Raft有简单粗暴的方法来处理，就是强制Follower直接复制自己的日志，这同时也是领导人只附加原则的要求。根据领导人完全性原则，我们的Leader在选举时是具有完全的日志的。在这个同步过程中，nextIndex[]和matchIndex[]就派上了用场。nextIndex[]维护了Leader下一个需要发送给Follower的日志序号，当Leader刚选举成功时，它是不知道各个Follower的日志相对于自己的情况的，因此默认nextIndex[]都为自己最后一条日志加一。但这样发出去的日志可能不会被接受，原因是根据之前提到过的日志匹配原则，如果Follower没有Leader的最后一条日志，那么它必然不能匹配Leader发送的AppendEntriesRPC中的prevLogIndex和prevLogTerm所标记，因此它会返回给Leader一个拒绝，此时Leader就会减小对应的nextIndex并重试。我们需要特别注意的是在这个过程中Follower的日志是有可能被Leader覆盖的。容易看到这里其实是可以进行优化的，但是Raft论文指出这个优化并不是很必要的，因为现实中失败很少发生，而且也不大可能会造成很多的日志不一致的问题。容易看出，这种算法是非常优雅的，因为它把恢复一致性的过程和正常增加日志的过程统一起来了，我们不需要对恢复一致性过程额外进行设计，可想而知这个额外设计是相当麻烦的，因为我们还要考虑在回复一致性过程中出现失败的情况。 Safety这一部分的论述对应了原论文安全性论证部分，证明了上面的Leader election和Log replication的算法是可靠的。 有关领导人完全性的论述现在我们利用反证法证明领导人完全性。首先我们提出反命题，即存在一个term为T的Leader提交的日志条目没有被其后的term为U的Leader所拥有。因此我们进行下面的推导 根据领导人只附加原则，这个记录在U竞选时就就不存在。 考虑到这个日志条目已经被提交，所以Leader T一定已经把它复制到过半数的集群上了；同时考虑到Leader U当选，所以它也收到了过半数的票。因此至少有一个节点它既拥有Leader T的日志条目又投票给了Leader U。我们考虑这个投票者。 这个投票者必然在投票给Leader U前接受了来自这个Leader T的日志。如果它在投票后才接受到来自Leader T的AppendEntriesRPC，那么它肯定会拒绝这条RPC，因为当收到来自Leader U的RequestVoteRPC时，这个投票者就已经更新自己的currentTerm了，因此现在它的currentTerm肯定大于RPC中的rpc_term_id。 这个投票者在投票时也保留了这个来自Leader T的日志。这是由于经过所有中间term的Leader都保有这个日志条目（我们假设中U是第一个没有这个日志条目的任期）。而Follower只有在日志和Leader冲突时才会丢日志。 既然这个投票者给Leader U投票，那么Leader U的日志必然不会比投票者的日志要旧。我们接下来从index更大和term更新两种情况来讨论。 首先假如投票者和Leader U当前的term是相同的，那么Leader U就会拥有更大的index，也就是日志更长。既然如此Leader U应当具有投票者当前所有的日志。 其次，另一种情况下，Leader U的最后一条日志的term要比投票者的最后一条日志大，并且要大于T。这是因为投票者的最后一条日志的term至少是T，毕竟投票者拥有一条在Leader T任期内提交的日志。而根据我们的假设，Leader U之前的Leader也拥有这样的一条日志。那么根据日志匹配原则的要求，Leader U也应当包含这个日志条目。 脑裂（网络分区）的处理由于某些节点的失效，部分节点的网络连接会断开，并形成一个与原集群一样名字的集群，这种情况称为集群脑裂(split-brain)现象。这个问题非常危险，因为两个新形成的集群会同时索引和修改集群的数据。Raft协议能够解决由于网络分区导致的脑裂。我们知道每一届的Leader都有一个term， 特别地，当网络分区多于两块的时候，会不会存在有两个分区中都选出了新的term相同的Leader呢？我认为应该是不可能的，因为成为Leader必须达到全局的多数$N/2+1$张票，最多只能有一个。所以当分区较多的时候，很可能无法选出新Leader。另外某节点也不容易去“获得当前分区的多数票”，因为它也无法界定当前分区的范围。 PaxosPaxos将网络中的节点分为proposer、acceptor和learner三种类。其中proposer即提案的提出者，acceptor对提案经投票，投票的最终结果交给learner进行同步。]]></content>
      <tags>
        <tag>分布式</tag>
        <tag>raft</tag>
        <tag>paxos</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黄山游记]]></title>
    <url>%2F2017%2F08%2F20%2F%E9%BB%84%E5%B1%B1%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[黄山之行屡屡被耽搁，终于在第四次勉强成行。 D0黄山分为屯溪区、徽州区和黄山区，其中黄山风景区位于中间的汤口镇。南京只有到黄山市区的K字头，为了避免麻烦的中转，我们选择了直达黄山风景区的客车。上午宵哥来到龙江，我们在新城市广场吃了午饭，又去金润发买了点吃的。中午在家里休息了会便前往车站。到了小红山车站检票时发现这辆车还要到一个叫泾县的地方。上车发现人很少，坐我旁边的也是一个搞土木的，现在工地轮休，他放了一个月假，便出来玩玩。我们天南地北地聊了一阵，他是徐州人，公司是做地铁的，现在主要在做前期地质勘探之类的任务。这辆车和我们预想的路线一样，到了芜湖南便下了高速，不过下面的G205居然修得不错，还是高架的快速路，外面阳光普照。这时候大概四点半不到，小猪说她已经到了。不过后来发现是太平镇，她还需要转车到黄山风景区。不过过了南陵县进入了宣州路况便越来越差。可能是泾县没有客人，我们并没有停靠车站，过了泾县，便进入了两车道的盘山公路，天也渐渐阴了下来。五点半时炜哥和小猪都到了，这时候黄山风景区开始下雨了。 D1早上五点半起，在宾馆吃了十块钱一碗的鸡蛋面，老板驱车把我们送到黄山南门。购买了19元的新国线班车到达云谷寺索道站，买完票差不多已是七点一刻。索道非常长，但也非常得快，上下车时缆车由一个转动缓慢的轮盘牵引，然后又过渡到一个转动迅速的轮盘上出发。一路上风飕飕地吹，远处的云海若隐若现。没一会我们就到了白鹅新站，下了索道跟着路牌就可以到达第一个景点始信峰。旅店老板给的登山拐杖刚度太高，我斜敲了敲地面下面一截就断了。 参观完始信峰路过连理松可以走到黑虎松，这里是个三岔路口，从在这里应该往下走，便能到达北海宾馆。途中我们能够看到梦笔生花景观。最容易发现的是笔架峰，它像一个手掌五个指头，顺着笔架峰往右看可以发现一个长瘦的孤峰，上面长有一棵松树，这便是梦笔生花。 到达北海宾馆后有一个岔路，可以去看猴子观海、清凉亭等景点。清凉台是一个崖壁上向外伸出的一条长桥，我开始以为这只是黄山上常见的一个供拍照的设施，下了山才知道这就是曙光亭。 从北海宾馆继续前行便进入了西海大峡谷地界，路上我们可以看到团结松，原来这棵松被称作多子多孙松，后来出台了计划生育政策，遂改名团结松。据说这松有56枝，代表着团结的56个民族。从这里往西看去可以看到高处的“飞来石”（不确定）和一个电视塔。 过了西海饭店，便进入了西海地界。据说为了保护原始环境，西海的栈道都是附着于崖壁之外，螺旋地往下延伸，往上看可以清晰地看到深深嵌入山体的外伸梁以及其承载的阶梯，往下看，一道五彩斑斓的蜿蜒的人流如同排列整齐的蚂蚁群一般，为我们标记了前方拥挤的道路。阶梯开始变得越来越窄也越来越陡，人却渐渐变得很多，我们前后都被旅行团包围了，时而不时反方向往上的游客也越发增加了我们前行的难度。我们脚下一直是壁立千仞的深切峡谷，可惜我们去的时候天气很好，并没有什么云雾缭绕的景象，我们甚至可以远远地看见谷底宛如一道轻轨一样的地轨缆车。往对面看还可以看到光明顶上的球和左边的电视塔。峡谷有点像图片上的张家界一样，矗立着许多石柱，还有一片片的山脊，如同刀锋一般，宛如骆驼的头与驼峰。 这时看向地轨缆车，我们发现轨道是有相当的坡度的，而车身则顺应这坡度成平行四边形状。由于是单轨，所以应该只有一辆缆车来回带客。 终于我们顺着队伍从石阶下到了平地地轨缆车售票处，往前已经被栏杆画成一块一块的迷宫，工作人员走出了售票亭，沿着迷宫站着，游客们纷纷伸出手，向他们买票。终于我们坐上地轨缆车。到了天海站，赶快去上了趟厕所。天海站有一片观景台。 俗称爬上光明顶看个球，原来光明顶上还真有个球，也就是气象雷达。光明顶的最高处是一个气象站，气象站下面还有一个直升机停机坪。从光明顶往南望，是一片云雾缭绕，旁边的导游在给团员解说，雾气之后便是黄山第一高峰，海拔1864的莲花峰。光明顶是黄山前后山的分界，还是安徽境内长江和新安江的分水岭，以北的河流汇入长江，以南汇入新安江。爬上光明顶，日落还有一段时间，一看飞来石只有700m，我便想去飞来石逛一逛。大家比较累，走到一半发现飞来石还有一公里，霄哥看去三岔口的另一端的群峰顶只要0.1km，便建议我们去群峰顶看日落。群峰顶非常好爬，而且的条件比光明顶要好很多了，没有树木的遮挡。我站在群峰顶上往飞来石看去，发现这一公里的路竟然出奇得短，于是便自己爬下群峰顶飞奔去看飞来石。 从天海往光明顶方向走不了多远就是白云宾馆。为了以防下雨，我们奢侈地住了300块钱一张床位六人间而不是帐篷，这里一个标准间要2400，一个套房要5800，惊人的房价着实吓了我一跳。我们的六人间并不在富丽堂皇的大厅，而是在靠近天海的1号楼北楼二层。白云宾馆不同于青年旅社的地方是男女分宿，我们到了房间后床位还余四张，而且都是可能闻臭脚的位置。 晚上回来，炜哥下铺是一个苏州来的老爷爷（瞬间发现苏南上海这边的老人真是老当益壮啊，上次去敦煌也是遇到一队上海的老人），问了我们去了哪些地方，我们说在西海大峡谷混了两个小时，他便问我们有没有坐地轨缆车。当然有啊，还真感谢坐了这缆车，老人知道了莞尔一笑，你们要趁人少的时候去啊，周五人已经开始多了。原来老人家已经是第七次来黄山了，他基本上每年都要来次把次黄山，他又为我们解惑，如果我们不坐地轨缆车，那就得没到谷底的时候就走岔道去，到谷底就迟了。后来他听到我们吐槽宾馆贵，告诉我们周日到周四这里一张床只要170块，同样是周五会贵一点。黄山最好看的时候反而是冬天，老爷爷说，虽然说西海大峡谷和天都莲花 D2早上四点半起床硬是拖到五点才出发，匆匆抢爬光明顶，右手边已是红光一片。到了光明顶上往炼丹峰方向走有一个很大的平台，上面已经乌央乌央站了好多人。看完日出已是六点左右，我们往玉屏楼方向走没多远便看到一片视野极好的观景地，坐在石头上可以毫无遮拦地观赏日出。我们在那里歇息了一会，吃了点早饭，天上开始飘起毛毛雨，身后挂起一道彩虹，与蔚蓝的天空相映成趣。上了百步云梯便到了莲花峰登临起点。此时我们的水已经消耗一空了，炜哥还是忍不住了，在联华超市买了两瓶水，这里的价格已经涨到了10元。往下走一段有一个岔路，问路人玉屏楼和厕所都是往左边走，我和徐炜往左走到一半发现人不见了，徐炜说小猪往右边走说有个莲花洞景点，于是我折返过去寻找他们。那是依着崖壁建造的有顶石廊，凌空看去，对面风光尽收眼底，不一会我们下到了莲花洞，莲花洞洞门巨大，但往里走却仅有一条狭窄的短通道，穿了过去傻眼了，前面正是登百步云梯时遇到的那一个岔道。于是我们又哼哧哼哧爬了上来回到三岔口往左走，过了金龟探海景点走不了多远便到了厕所，这个厕所很有意思，它需要走一段楼梯到达下面一层才能进去，我差点都没发现。上完厕所刷了刷朋友圈，居然看到了法的留言，他说他今天早上刚好也到了黄山，天呐果然是2017与法同行，法真是无处不在。聊了聊，原来法正好今天陪着（政治任务）爸妈和邻居一起过来玩。天都峰是黄山的第三高峰（爬上去从手机上看是高1840），却是最险峻的一座。在玉屏楼看完迎客松后顺着步行下山到慈光阁的牌子下山，瞬间人便少了很多，我们前面只有一个老外。我们从玉屏峰顶继续往下走，经过一个叫蓬莱三岛的地方，那就是三座石柱山，若是云雾缭绕，确是犹如仙境一般。可惜我们去的时候是晴空万里，更能看见远处天都峰的上山台阶犹如一头巨龙一般蜿蜒盘旋，上面有着星星点点的人群。这里是个四岔路口，往上（玉屏楼）有两个岔道，往下（天都超市）也是两个岔道。往上的岔道间刻着一“好”字，我们笑道，估计等爬上天都峰上面还有一“傻”字。往下走腿已经开始酸了（都怪刚才看什么莲花洞），霄哥们首当其冲探了左边的道，在下面徘徊了很久，不会不通吧，我和炜哥很犹豫，有有点窃喜，便和大多数人走了右边的道。不过左边的也是通的，我们在下面汇合了。再往下走，越来越见天都峰登山石阶的陡峭，旅馆老板说的75度一点都不过分。难道这一条长龙就是鲫鱼背？从蓬莱三岛往下走了几段石梯，迎面出现一副摩崖书法，往右边看便是蒲团石。从玉屏楼上下来便是天都超市，这里有免费的行李寄存（如果原路返回的话可以考虑）。我们在这里歇息了很久，并吃了一些东西，然后向着天都峰前进。一上天都峰感觉就不一样，石阶变得十分粗糙，似乎是直接打磨出来的，而不是浇筑的混凝土，每一级的台阶也是高，走在上面有一种就要仰头滚落下去的心惊胆战之感。一路上石阶连绵不断向上，仅有几个侧边的平台可供停顿休息。为了确保安全，我们手都尽力地扶着旁边的缆绳，登山杖倒显得无用了，在一个休息平台上我看到了丢弃的两根拐杖。前方出现一段由山崖间树木遮蔽成的通道，据路过的人说爬到这里一半还没到而且前面这一段是最陡的，又有人说还要半小时能登顶，但是到了顶上还要往上登一段。宵哥惊讶，前面最险的应该就是鲫鱼背了吧，那人说鲫鱼背反而不险，现在都有护栏了（卧槽以前没有么），就在上面的大正方体石块那儿，我们看了看高度表，离天都峰海拔还有不到200米了。于是我们就近在这个平台进行了休息，吃东西喝水以求减负。期间遇到了一穿拖鞋爬山的大佬，据说已经是毕业十年了，看起来却还如大学生一般，还有一帮老年人背着单反，他们都休息了一会儿便嗖嗖嗖上去了。再往上台阶果然越来越陡，变成交错的三段，突然路往左转了个弯，树木渐稀，阳光探了进来，往对面看蒲团石、玉屏楼和迎客松清晰可见，远远地还能望见光明顶的球，原来我们已经走了这么远啊！这时很多人从上面下来，我们在台阶山勉强与他们错开，真是对平衡能力的极大挑战。毕竟我们虽在靠右的山体一侧，但我们除了崖壁却没有什么可以攀扶，而对面下山的人则有缆绳可扶，并且崖边的孤石和山松遮挡视线，倒也不觉恐怖。路过的人都是已经经过鲫鱼背登上天都绝顶好汉，可是都纷纷说到从对面下太难了，选择了走回头路。终于眼前豁然开朗，前方出现平路了，从崖壁向右看可以看到汤口镇，向左看玉屏楼和光明顶也尽收眼底。我们往前来到一片长约十米，两边由巨石的走廊上，风在耳边猎猎地吹。走过这段平缓路段便重新开始了上坡，坡度较之前缓了一些，两边又出现了一些树木。不过再往前什么都没了，这里便是在山脊上开凿出来的路了，路两侧的山松怪石陪伴着我们，左右看去，群峦尽收眼底，耳畔是呼呼的风，我穿着衬衣，竟也感到一阵凉意。突然前方开始堵车，有一个人说前面太险了不敢走便要下来，我们看旁边有一处伸出崖面的观景平台，便走上去拍了照片，感觉手机都要被风吹掉了。继续往前，我们选择从左边的一条路，这是明智的，爬上去后我们看了下右边上来的道，那垂直落差简直吓死人。再往上走人慢慢变多，一道石桥架立于万丈深壑之上，旁边有一名牌，谓之为天桥。这石桥位于转弯处，又十分窄，都不到旁边的护栏那里，走的时候是胆战心惊，三步并两步就过去了。从天桥往上便到了著名的鲫鱼背了。从前我们以为鲫鱼背是像田埂一样，或者是刚才上来的移到近乎九十度的石阶长龙。但实际上鲫鱼背宽一米不到，长约十余米，高低起伏，两边狂风阵阵，幸好两侧有扶手，我们需要弯着腰小心翼翼地攀着扶手才能敢过。过了鲫鱼背选择左边的一条路可以到达天都绝顶，右边的一条路（或者拍照点）是在崖壁上开凿的一条险路，我们没敢过去往下走，不知道通哪里。左边的一条路则通向天都绝顶，我们需要弯腰侧身从石缝间经过。中途在山洞里面我们还遇到了之前那穿拖鞋的人和他的同伴，他们已经在顶上呆了好久了，准备从原路下山去玉屏楼。天都峰顶上游三条岔路，一条是我们从鲫鱼背过来的路，另一条是从半山寺上山的道路，在这条道路左边有第三条往上大概50米的斜坡，通往天都峰的最高点天都绝顶，这条路上排了长长的一条队伍等着拍照。不过实际上拍下来的效果并不好，因为别人是站在低处往高处拍，取景受到限制。在下山时，我们选择了传说中更难的另一条路，也就是从半山寺到慈光阁乘车点的路线。第一段下山的石阶就是下马威，这段台阶临崖壁修建，外侧的石栏由水泥浇筑而成，根本没有扶手的地方，更没有缆绳，由于台阶过高，下到一半我的书包就卡在上面一级台阶上，往下即感觉一股力量急急往前推。无奈只好选择在台阶上转体一百八十度，倒着走下去。下山的路不停刷新难度，有的地方由于太险，上路和下路分成了两条。最险的一处是由两块巨石形成的石缝，仅容一人通过。我们当时正准备往下走，忽然发现最前方的小猪停了下来，前面好吓人。往前一看是一段阴暗无比的连续石阶，这段石阶深不见底，完全看不见其尽头。我们小心翼翼地扶着两边潮湿的崖壁往下走，暗自祷告着跟在后面的一群大爷不要脚滑一个呲溜。石阶路往下向左拐了点，我们看到下方出口的光线，此时有人试图从我们的路上来，被我们高声喝住。 离半山寺大概还有三四段台阶的地方我们遇到了攀山上来的法。先前法一直在和我们联系，问我们怎么爬比较好，说自己带了大人。 从黄山风景区回南京有三点和五点的车，回杭州是四点半的车，据说都是从屯溪发来的正规车，在这里带客。旅店老板帮我们联系好了车后，炜哥和宵哥买了点包子和西瓜，我们坐下来掼了回蛋。五点五分车来了，我们坐上车，发现还挺空。随着车在汤口镇花了半小时晃了一圈带客，我们上高速真正离开时，车已经一个空位都没有了。 车过了芜湖便开始下起了暴雨。]]></content>
      <tags>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manacher算法]]></title>
    <url>%2F2017%2F08%2F11%2FManacher%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我们知道优化非启发性算法的方法常常包括使用定理、利用计算机的架构特点、使用恰当的数据结构以及动态规划等。而动态规划的核心理念就是减少重复计算。对于回文串问题的Manacher算法来说，我们要重用0..(i-1)的结果，那怎么重用呢？假设i和j关于p(i &gt; p &gt; j)对称，那么R[i]便可通过R[j]求得。计算最长回文串的暴力算法是O(n^2)，而马拉车算法能够在O(n)时间内解决问题。 Manacher算法我们使用$ R[i] $表示$ i $位置处的回文半径，即字符串$ aba $中$ b $字符的回文半径为2。我们现在使用$ i $从左开始遍历字符串求$ R[i] $，为了能够DP，我们假设有一个合适的$ p \lt i $，我们把$ i $关于$ p $做对称得到$ j $。注意到$ R[j] $、$ R[p] $是已求得的，待求$ R[i] $。此时字符串坐标轴上出现了五个刻度：$p$、$j$、$i$、$j+R[j]$、$p+R[p]$，我们需要讨论他们的位置关系。由假设有$j &lt; p &lt; i$，可是$j+R[j]$、$p+R[p]$关系不好确定，为了方便讨论，我们可以假设这个“合适的”$p$满足$p+R[p] &gt; j+R[j]$。这是因为在后面的讨论中我们发现要使得$p+R[p]$尽可能大，假如$p+R[p] &lt; j+R[j]$，也就是以$j$为中心的回文串的右边界比以$p$为中心的右边界还要靠右，那么我们与其取$p$，不如直接取$j$，而且$j$也是在$p$前面被遍历。现在我们可以得到三组位置关系 $$\begin{equation}\begin{split}j &amp;&lt; j + R[j] &lt; p + R[p] \\j &amp;&lt; p &lt; p + R[p] \\p &amp;&lt; i \\\end{split}\end{equation}$$ 可以看出只有$j + R[j]$与$p$、$i$和$p + R[p]$这两个位置关系尚未确定。在下面的讨论中，我们发现只有这两个都满足一定关系时，才能够重用结果。 $p + R[p]$和$i$的位置关系当$i &gt;= p + R[p]$时，$i$已经在$p$为中心的回文串外面了，以$i$中心的回文串看来是借不了这个$p$的东风了，我们需要重新找一个“回文边界”更靠右的$p$。所以我们直接维护一个$p’$，使得$p’+R[p’]$始终是最大的，如果这最大还不够大，即这边界最靠右的$p$都包不住$i$，那$i$便只能自力更生暴力一波了。 $j + R[j]$与$p$的位置关系根据上节讨论，$i &gt; p + R[p]$时只能暴力，并且$j$有可能越界到小于0，所以只有$i &lt;= p + R[p]$是才会执行这一步。$j+R[j]$与$p$的位置关系决定了$i+R[j]$和$p+R[p]$的位置关系。 在内部 当$j+R[j] &lt;= p$，则$i+R[j] &lt;= p+R[p]$，这就相当于以$i$至少有一个以$R[j]$为半径的回文串，并且在以$p$为中心的回文串的内部。预示我们只需要从$R[j]+1$开始检测$i$是否具有更大范围即可。 在外部 当$j+R[j] &gt; p$，则$i+R[j] &gt; p+R[p]$，这就相当于$j$中心回文串的边界在$p$中心的回文串的边界之外，所以我们只能重用$j$中心回文串在$p$内的对称部分，其半径为$2 \times R[j] - R[p] + j - p$，然后从这个半径向外开始暴力 偶数长度的回文串这个时候就没办法定义“半径”这个概念了，有一个巧妙的方法是将其变为奇数长度的回文串，也就是在头尾以及每个字符中间加入一个特殊字符。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不动点组合子Y-Combinator]]></title>
    <url>%2F2017%2F07%2F28%2F%E4%B8%8D%E5%8A%A8%E7%82%B9%E7%BB%84%E5%90%88%E5%AD%90Y-Combinator%2F</url>
    <content type="text"><![CDATA[python中的lambda用起来还是很爽的，不过坑也有很多，比如说这个early binding和late binding的问题，或者lambda中只能有一个语句（实际上是表达式）。不管怎样，可以把lambda当做一个匿名函数来看待，那么这个匿名函数如何在递归调用的时候引用自己呢？Haskell B. Curry给出了Y不动点组合子(Y Combinator)可以解决这个问题 Y Combinator当然不是那个著名的公司啦，事实上，如果f(x) = x那么x是f的不动点考虑计算阶乘，python可以很容易写出下面的代码：1fac = lambda x: 1 if x &lt;= 1 else x * fac(x - 1) 不过对于某些其他的语言，例如C-Sharp，就没那么轻松了，于是我们希望有一个类似this指针的东西，能够在lambda函数体中用来表示自己 lambda演算首先需要简单了解lambda演算(Lambda Calculus)。lambda演算是图灵完备的，邱奇利用lambda演算证伪了可判定性问题。 形式化定义lambda演算文法非常简单，只由下面三个lambda term组成 引用标识符(Variable)$a$ 定义函数(Abstraction)$(\lambda x. M)$，括号可省略。此时变量$x$被绑定到了这个lambda表达式，而这个绑定的作用域便以括号为界。 应用函数(Application)$(M \, N)$在lambda演算中函数作用是左结合的，即$s\,t\,x$实际上是$(s\,t)x$。例如$\omega$组合子$\lambda x.x\,x$，它可以被看做$(\lambda x.x) (x)$，而不是$\lambda x.(x\,x)$ 括号lambda演算中的括号在无歧义的情况下是可以省略的。因此式子$(\lambda x.x \, x)(\lambda y.y)$可以写成$\lambda(x.x\,x) \lambda y\,y$。式子$\lambda x.((\lambda x.x)x)$和式子$(\lambda x.(\lambda x.x))x$并不能作为同一个lambda term。其中第一个式子中外面的lambda是返回的一个值，而第二个式子中外面的lambda是返回的一个lambda。 绑定一个合法的lambda函数不应当出现自由变量。如$\lambda x.(x\,y)$中，$x$是被绑定的，但是$y$没有被绑定到在表达式中的任何一个$\lambda$上。 lambda演算规则首先定义$E[V:=W]$，这表示一个表达式$E$，这个表达式中的所有$V$的自由出现都替换成$W$。 α-转换(Alpha equivalence)这个变换的意义是被绑定变量的名称是不重要的，所以我们可以用任何的其他名字来替换，其定义为$\lambda V.E = \lambda W.E[V:=W]$。当然，前提是首先要是被绑定的，我们看前面的一个例子$\lambda x.x\,x$，它相当于$(\lambda x.x) (x)$。这里面有两个$x$，但这两个变量却不是一个变量，因为只有前一个变量被绑定到了$\lambda$上，而后一个是自由变量 β-归约(Beta reduction)这个类似于C等语言中的传参，或者数学里面的代入。其定义是$\lambda x.t$能够归约成$t[x:=s]$，这个beta reduce过程表示为$(\lambda x.t)s -&gt; t[x:=s]$。这个过程必须要确保$E’$再替换后仍然是自由的。例如$\lambda z.(\lambda x . x + z)(x + 2)$，和我们在α-转换中看到的例子一样，$(\lambda x . x + z)$中出现的$x$是绑定的，但是$x + 2$中的却是自由的，因此我们不能直接把这个自由的$x$代入到绑定的$x$里面去。如对于任意的“自变量”$s$，有$(\lambda x.x)s \rightarrow x[x:=s] = s$，因此该函数是个恒等函数。又如$(\lambda x.y)s \rightarrow y[x:=s] = y$，这说明$\lambda x.y$是个常量函数。beta可归约式(redex)具有以下的形式$((\lambda x.A(x))t)$。例如$(\lambda x.x\,x)(\lambda y.z) \leftarrow (\lambda y.z)(\lambda y.z)$对于无类型的lambda演算来说，这个规约过程还可能是无法终止的。考虑下面的$\Omega$算子$\Omega = (\lambda x.x\,x)(\lambda x.x\,x)$ $$\begin{equation}\begin{split}&amp; (\lambda x.x\,x)(\lambda x.x\,x) \\\rightarrow &amp; (x\,x)[x:=\lambda x.x\,x] \\= &amp; (x[x:=\lambda x.x\,x])(x[x:=\lambda x.x\,x]) \\= &amp; (\lambda x.x\,x)(\lambda x.x\,x)\end{split}\end{equation}$$ η-变换(Eta conversion)η-变换体现了外延性(extensionality)的思想，即两个数学对象是相等的，如果没有区分它们的检验。对于lambda中的函数来说，如果两个函数对于任意的输入都能产生相同的行为（即返回相同的结果），那么可以认为这两个函数是相等的。η-变换的一个用途是$\lambda x.f\,x$和$f$是等价的（注意它们不一定性能相同，详见Haskel里有关where的一个例子），只要$x$不是$f$中的自由出现。]]></content>
      <tags>
        <tag>Haskell</tag>
        <tag>lambda</tag>
        <tag>combinator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神器Continuation]]></title>
    <url>%2F2017%2F07%2F24%2F%E7%A5%9E%E5%99%A8Continuation%2F</url>
    <content type="text"><![CDATA[Continuation、Coroutine和Generator是异步编程中的一些概念。通过Continuation能够实现Coroutine和Generator。 Continuation常有两种实现，一种是以call/cc(call with current contination)为代表的语言级别的实现；另一种对于不能原生支持Continuation的语言但是支持闭包（函数作为一等公民）的语言，可以使用CPS(continuation-passing style)来实现Continuation。 Continuationcall/cc以维基百科上面的一个例子来说 (define (f return) (return 2) 3) (display (f (lambda (x) x))) ; displays 3 (display (call-with-current-continuation f)) ; displays 2 其中(define (func_name arg1 ... argn) exp)表示定义函数。查看第一行调用，display打印得到3，这是由于f始终返回最后一个表达式的值3。无论return是个什么，哪怕return是个回调函数，f的计算结果也是3。查看第二行调用，display打印得到2。这是由于在调用call-with-current-continuation时，首先Lisp会把当前的环境打包成一个叫Continuation的东西，并且以它作为参数调用f Continuation。查看f的代码，下面我们要执行return 2，也就是Continuation 2。而call-with-current-continuation打包的Continuation这个东西可以看做一个的函数，调用Continuation就会f会退出，程序上下文返回到调用call-with-current-continuation时的状态，并且(call-with-current-continuation f)会被替换成Continuation的参数2，于是实际上运行的是display 2。 还可以这样理解，在本来程序是要执行(display xxx)的，Lisp一看xxx原来是一个call/cc f，那就把现在的状态（下面要运行display啦）打包成一个Continuation，然后程序就不往下面运行了display了，而是立即跳转去执行f函数。那这个f函数有点特别，他会被系统喂刚才得到的Continuation参数return，函数通过调用return就相当于从f函数中退出，并继续执行调用f前要执行的display，这里display需要一个参数，所以调用return 2，这里可以近似理解Continuation参数return就是下面要执行的display函数的别名。 CPS对于没有call/cc这机制的语言，可以使用闭包进行模拟。 callback通常的语言如C++中，常使用return命令返回结果，例如1234int add(int x, int y)&#123; return x + y;&#125;int result = add(1, 2); 其中int result = add(1, 2);语句将result与add函数的返回值return x + y进行了绑定。这样的方式对我们屏蔽了绑定的细节。我们需要通过额外的了解能够得知，并且还要取决于具体的代码和编译环境。例如一般int返回值会被放入eax中，再调ret，而有些时候浮点数会被放在FPU或XMM上返回。当然也许会说编译语言没必要去讨论它的目标代码，不过至少我们只有通过把函数的返回值和某个名字进行绑定这一种默认的处理返回值的方式。对于有些异步的需求，常常有回调函数的概念。函数接受一个额外的回调函数作为参数callback。1234567template &lt;typename F&gt;void add(int x, int y, F f)&#123; return f(x + y);&#125;add(1, 2, [&amp;] (int result) &#123; &#125;); 将这段代码与上面的代码进行对比，我们发现实际上我们返回的是一个函数，而不是一个值。 CPS functionContinuation和callback都是可以调用的，不同的是在A里面调用一个callback B后，程序进入B然后从B返回到A继续执行；而在A里面调用一个Continuation B后，程序立刻进入B运行，并且不会在B再返回到A。因此对于没有call/cc这样的first-class Continuation的语言可以通过callback实现CPS function。方法如同上面的add函数一样，add函数通过在函数结尾调用该回调函数，自己的计算结果传给该回调函数，来完成返回操作。这样的回调函数方案借助了尾递归（在函数的末尾调用另一个函数）。此时，函数实际上将自己的剩余部分作为callback（此时该callback称为continuation），该函数即CPS function。相对于命令式语言的if/else、do/while/break/continue、try/catch/finally、goto等控制语句，CPS function的好处是能够更灵活地操作control flow，因为下一步要做什么不是根据你是顺序结构/选择结构/循环结构，而是你在continuation里面写了什么。这样还会带来一个好处是程序可以任意被中断（此时只需要保存回调函数的指针f），然后从中断的地方调用f开始继续执行。于是常常使用Continuation/Coroutine代替多线程（毕竟线程的开销还是很高的）。]]></content>
      <tags>
        <tag>多线程</tag>
        <tag>Continuation</tag>
        <tag>Coroutine</tag>
        <tag>CPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贵州游记]]></title>
    <url>%2F2017%2F07%2F11%2F%E8%B4%B5%E5%B7%9E%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[一直以来，贵州一直出现在卓林的自黑之中。什么江苏六州、南京四省省会，和伟哥那段“贵州山水甲天下”、“贵州简称赣”的梗更是屡屡被提起。于是今年暑假在他的热情邀请下，我们去贵州进行了一次非常幸运与快乐的旅行。主要行程包括镇远-凯里-安顺-麻尾-荔波。 B1 Jul.3 南京原计划我们需要在7月3号坐D655+K495一波24的火车到镇远。早在7月1号的时候，就看到群里说7月2号的K495由于湖南的水害取消了，当时十分高兴，毕竟自己的7月3号精准地避开了这次调图。不料三号下午3点钟，我东西打包好，连方便面都买好了，短信过来了说K495取消了，顿时群里乱成一锅粥。最先安顿好的是小姐姐们，她们换了一列和刘鹏一样的K473列车。我们就很伤了，湖南似乎成了我们越不过去的障碍，从南京到镇远附近的火车，甚至是高铁都处于取消和无座状态，大家建议我们考虑4号的K495或K111，我们觉得这样就有可能耽误大家的行程。在比较了南京飞贵阳的机票（这机票在10分钟内涨了80）后，加上考虑了飞机场与火车站的距离，我们接受了卓林的建议，选择HO1657(12:55-14:45)赶K495(16:58)和刘鹏他们会合。不过考虑到南京和张家界的天气，真不知道明天飞机回延误成什么样子。 D0 Jul.4 南京-张家界-镇远今天我们实施昨天的南京-张家界-镇远HO1657+K473空铁联运计划。我们早上七点多就起来了，和法9点钟在地铁站会合前往机场。到了机场，没下雨，不多云还是挺多的，天气预报说降雨概率60%。前序航班是从大连飞南京的，大连天气也不好，起飞晚了12min，在我们的祈祷中，这架飞机不负使命，提早了4分钟降落。不一会儿，飞机就开到了我们登机口的廊桥了。我们看看外面云还是挺多的，不过天还是亮的，也不下雨，本以为这次应该是不会延误太久的，不过机场广播不停传来的“很抱歉地通知您”还是给了我一点不安的感觉。看到延迟未定的时候我们是绝望的，我们已经准备张家界一日游了。法开始有点懊恼了，觉得他这次没空参与，行程就安排成这样了，买飞机票亏了不到500块。我也觉得南京-镇远和安顺-麻尾的行程看起来非常地不靠谱。我们估计来不及吃晚饭了，便请刘鹏哥帮我们带点泡面。刘鹏说张家界现在是大晴天，到张家界应该不会延误了。有着急的大哥问登机口的工作人员啥时候能飞，答曰飞行员还没上呢。感情我们白对着廊桥外的飞机大眼瞪小眼了。一点半的时候，飞行员终于上飞机了，打开航旅纵横，依然是流量管控延误。我也感觉这次去贵州成行机会不大了，不想去赶那班到镇远的火车了，劝法计划下张家界-凤凰的游览线路。飞机在14:36起飞，中间很瓜皮地只发了水和三明治，旁边阿姨看我饿得，把自己的三明治给我吃了，我后来又要了两个还给阿姨。飞机不久便到达了张家界，在降落的时候我们看到了远处天门山上的天门洞，和脚下的张家界火车站（真想直接跳下去）。飞机四点整停靠了廊桥，我们估么着去火车站还来得及，便赶快出机场。张家界是大太阳，感觉自己快热化了，我和法叫了辆不打表的出租车30块把我们送到了火车站。想着董董一直想来未成行的张家界，而我在出租车上“一日游”了，我给她发了她一条定位。到了火车站才16:25，我们取完票和刘鹏哥汇合了。刘鹏和他的弟弟坐了火车的硬卧，上了车发现小姐姐们也是和我们一辆车，她们刚在凤凰玩，正好从吉首上车与我们汇合。上了车赶快发说说感慨一下这波紧张刺激的空铁联运。由于我们是从五点到十一点半将近六个多小时的硬座，机智的法出了去餐车休息的馊主意。一到餐车坐定便见到桌上的牌子上明码标价，并分为四个时段早餐午餐晚餐夜宵，夜宵还特意注明30块包含荤素饭汤各一。不一会儿乘务员便来了，“牛肉鸡肉带鱼排骨”她很不耐烦地说道。法计算了一下，15块的晚饭在这里卖40，划一个座位25块钱，可以歇到22点，其实是比软座划算了。吃完晚饭感觉本来不舒服的肚子彻底爆发了，还有一点发烧，把衬衫穿上。这时候两位小姐姐们从吉首上来了，于是开始打掼蛋。我和欢欢姐把法政和团长组合秒了两把23333。打牌打到十点，乘务员把我们从餐车赶了回去，我们回到人声嘈杂的硬座。在厕所旁，已经有人铺开凉席就地睡着了，有一位妇女将小孩背在小背篓里面，在车厢里来回走动。我的位置似乎已经被人占了，我想着自己肚子还是有点闹腾，倒也不介意。不过走到车厢临头发现居然还有若干座位，于是我坐到了一个应该是农村妇女身边。车子在不停地颠簸，手机信号忽有忽没，车厢里的人也都看起来行色疲惫，也没见到有上次从常州回来时的一秒脱裤带的表演。对面的小孩醒了并开始哭闹，于是他的母亲替他解开裤子，便朝地板上把尿。将近十一点的时候，身边的那位妇人突然拿出手机，然后操着一口浓厚的口音，开始对我讲话。结果几次沟通，我搞明白了她在问我现在几点了，又问我下一站是什么，于是便回答了她。紧接着她拿出自己的火车票，我看有两张，第一张上面写的是怀化-昆明，第二张则是到涪陵的票，她说她火车做错了，要在下一站下车。到了晚上将近11:25时，火车窗外突然一亮，我们仿佛进入了千与千寻的世界，两边吊脚楼上的灯光勾勒出一道穿越古城的蜿蜒的河，在更高处有闪着光的四个大字“名城镇远”。下了火车，帮大家把箱子扛下火车站，打了两辆车去旅店。 D1 Jul.5 镇远今天我们简单地逛了镇远古城。早上起来出了一身的汗，感觉烧是退了，但肚子依然是照拉的。硬撑着出去和法、刘鹏在对面的瘸子饭店吃了肉末粉。接着我和法沿着河南岸翻过新大桥进入镇远古街，往祝圣桥方向漫步。沿河畔走，是真的明白什么青山绿水是真的一点不假，这里的绿水其实不是富营养化或者工业污水造成的，而是水中的矿物质遇到阳光吸收不同波长产生的。镇远古城里面的路都是石板路，比较窄，但也能容纳轿车和公交车的通行。镇远（以及我们后面去的同时黔东南的雷山西江苗寨）商业化还是比较浓的，而且每一家店面门前都会有一幅镇远公安的二维码，我想可能是用来投诉的吧。我们顺路打听明天的漂流、晚上的游船以及去苗寨的车，一路上问下来发现高过河漂流基本都是统一价，是景区规定的，接送258，不接送220。而舞阳河的游船（画舫）晚上是80元。一路上我们找一个叫歪门斜道的景点，后来才知道歪门斜道就是描述的镇远古镇的格局，镇远城依山而建，里面的道路错综复杂，故有歪门斜道称呼。到了祝圣桥边有经营50元的船，不过那船可以说非常简陋，就是一个小艇上搭的棚子。我们在祝圣桥下面的水关拍了照片，法不小心手被仙人掌划伤了。再往前走有一个女人在炎帝庙前拉客，只要一块钱便可以参观景点，于是我们进了。从炎帝庙出来，我们去爬石屏山。我们是走东边的口子买票进入的，石屏山学生票是15元，但是可以逃票，方法是从西边的一条叫四方井的巷子上去，这条巷子可以通过地图上唯一的公厕来定位。爬石屏山简直去了我半条命，爬一路，肚子是闹一路，气涨着胃，想从食道涌出。爬石屏山沿路并没有什么风景，我们路过了“名城镇远”几个大字中的“远”字。山顶上崖边建有一个亭子，在那里可以俯瞰镇远全城，在亭子进口处有一卖水的老妪，右眼睛好像受过什么创伤，变成一个鲜红的圈，很恐怖。我们在上面吹了一会儿凉风，眺望镇远全景。㵲阳河从峡谷间蜿蜒而来穿过镇远城，流向远方，远远地是我们过来时的铁路湘黔线，可以看到火车通过。从亭子出来往上走有一段古城墙，不太清楚为啥要在这么高的山上建城墙。下山时，我们在山腰的三岔路口选了另外一条道，于是从不要门票的四方井巷子出来。四方井就是一个正方形的井，里面的井水据说从前供全镇远的人使用。在四方井旁有一个壁龛，里面有上着很多香。在我们爬山时，另外的人去玩了青龙洞，据说非常没意思。我们在祝圣桥上汇合，然后去大众点评上的一家袁家豆腐。袁家豆腐据说也是上过舌尖上的中国的，他家的豆腐不说多香，但巷子一定是深的，我们从大街上拐进一个小巷，七拐八拐往上爬了好几段台阶才找到。上来的是他们家特色的豆花，桌子上配了五六瓶的佐料，有花生碎、酱油、糖、醋、辣椒粉、辣椒等。我觉得贵州辣椒好，就吃酸辣的吧，妈的难吃死了，汤汁倒是特别酸，这豆花却一点不入味，吃起来一口酸辣一口寡淡，简直受不了。于是换成了甜的，咱当布丁吃行不行结果更差了，半碗豆花大都没吃完全倒了，不过他们家的苗家老豆腐是挺好吃的，外面就像油炸干一样，里面又包了层嫩豆腐。何卓林点了一道贵州特色的折耳根，又叫鱼腥草想让我们尝尝。应该是类似鱼香肉丝之类的东西吧，于是上来一盘像豆芽菜一样的东西，我想着便尝了一口，妈的妥妥的黑暗料理，这是一种特别冲的腥味夹杂着特别冲的草药味，我挣扎着嚼了两口，结果硬是没咽下去还是吐了出来。吃完饭我们就去我们联系了几家上午看到的接送高过河漂流的旅行社，他们漂流项目未成年儿童必须也得买成人票，感觉就有点坑了。然后我们考虑到赶时间去凯里，想早一点结束漂流，就和他们约早一点接，比如9:30接。但是他们说要根据景区的安排，10:30去是正好，有时候即使去了早了也没得漂。回来的路上法想买双拖鞋，我们想看看有没有泳裤，于是我们路过超市，不过并没有找到，于是回到宾馆休息。醒来之后我发现自己的水杯丢在袁家豆腐了，从百度地图上找到电话问问老板，他问了问她妈说不在。晚上，我们在舞阳河边的一家苗人饭店吃了烤鱼和酸汤鱼，可能是酸汤鱼曾经出现在舌尖上的中国吧，这路边的每一家店的招牌都是舌尖上的中国。欢欢嗓子不太舒服，去了附近的医院看病，没有来吃。我们点了一矿泉水瓶的米酒，它不同于我们在兰州吃的醪糟，或是我们自己的米甜酒，带有固体物质，而是纯液体的酒。我觉得喝起来口感并不好，非常的涩。卓林还请我们吃了一个叫冰凉粉的东西，它出人意外是甜的，有芝麻的香味。我觉得如果能够冰镇一下会很好吃。河边不时有驻唱歌手唱着改编的镇远版《成都》，还不时教我们点歌。结账一看，648元，吓尿了，讲了下价，520成交。结完账林欢也找来了我们吃饭的地方，她去了医院看了嗓子，医生特别好，知道她没有医保后就给她开了处方，要她到药房去买，这样会便宜一些。我们走过新大桥，小姐姐听到我们坐游轮的计划，说游轮一定要还价，自己在重庆把两百多块钱还到了五十多块钱。卓林从中午就一直唠叨着什么长江语系和珠江语系（在我们看来都是西南官话），自己是珠江语系，和这边的话不一样，说刘鹏的方言可能要更接近点。于是最后遵义的小姐姐上去侃了半天，上来还价到20，不过可能这是政府搞的东西吧，最后没成功。 D2 Jul.6 镇远高过河-凯里西江苗寨今天是最刺激的高过河漂流了。搞笑的是接送的车一早9:20车就到了天主堂，于是我们饭都没来得及吃，慌忙地收拾东西。我们首先要去高过河漂流的游客服务中心，我们走了有将近一个小时的盘山公路，刘鹏的弟弟还给搞吐了。在游客中心，20块钱可以买一个寄存的蛇皮袋，还附送一个瓢和一个防水袋。刘鹏弟弟身体不适不漂流了，我们共八个人四艘船进行漂流，于是另买了5块钱的两个瓢。后来发现，这两个瓢的作用是非常大的。高过河漂流是不能穿拖鞋的，据石头可能会划伤脚，于是我们换上了景区提供的白球鞋，并套上了护膝和护腕，然后我发现我的毛巾掉到了旅馆没拿。在寄存完东西和换完衣服后（等的司机不耐烦了），我们又坐上包车来到起漂点。高过河漂流耗时是非常长的，由许多起伏和起伏间较为漫长的平缓河段组成。我们从起漂点遇到的第一个起伏就把我们的衣服全部打湿了。既然都湿了，那大家就干水仗吧。拉起瓢一舀水，瓢的把手断了，幸亏邻船的人捡了送还给我。刚准备继续攻击，我们的船就搁浅了，这次是因为一块石头比较高，我们的船直接开到这块石头上面了，加上右舷还有一块石头挡着。我们在这里耗了很久，最后靠撑附近的石头得以出来。高过河共有11个急流，每个急流前都会有一块牌子说明。船经过急流总会激起比头还要高的浪，然后船会灌进好多水。于是我们在遇到急流前后都会疯狂地拿着瓢将船里面的水舀出去。每次进过急流前都要死命地用腿夹着或者压着瓢，生怕它跑掉。到了后半段这基本不灵了，就是一个小起伏，我们的船都会进半船水，遇到一个急流，我们基本就是水比船高了，后来发现我们的船并不漏气，所以也不会沉下去，舀不舀水倒无所谓了。而且，但凡我们的船进了急流，那便是被浪裹挟着地往下冲，等到碰到岸边或者中央的石头，便会反弹并旋转，冲到了最下面便会被一道大浪狠狠迎面打来，船也会用力往下一挫，刚才辛辛苦苦舀的水也白舀了。这时如果你是背对着浪，那是最好的，顶多是被吓一跳，若是正面硬肛那大浪，那便是要被那冷水浇个一身了（人正面更怕冷）。不过最惨的是侧面迎水，这样耳朵基本上都是水。经过了一两段急流，加上拼命划船，我们赶上了之前甩下我们的小伙伴，又开始愉快的水仗。水仗之猛烈，我们瓢都搞丢了，其他三条船笑尿了，觉得我们必须失去战斗力了。我心想不能啊，没瓢这帮小逼崽子还不搞死咱们，于是拼命地用木棍划船，最后靠一个筏子360的转弯抓到了瓢，站起来舀起一瓢水就泼了过去。高过河漂流大多数是纯天然的，我们大多数时候在山谷中漂流，两边的高崖边长满了绿色植物，石头上也有苔藓。我们路过的一些地方两边还有一米高的小瀑布。但对于比较险要的地方，景区就会直接建一个滑道，船从这个滑道上嗖地滑下去，船最后重重挫入水中，摔起一团浪花。比较好玩的是，中间有一个滑道急流，救护员钩过我们的船问我们两个是谁重，还问了两次，默默吐槽，这还要问？不是显然的么？后来想想其实有道理，我们可能是重量太不均衡才会搁浅的。一般经过急流后，总会有一段比较长的平缓河段供休息调整（当然对于我们来说这意味着和搁浅的漫长搏斗），这时候我们会疯狂舀出船里的水，或者划到岸边的浅滩上稍作调整。浅滩上上通常有买食物的商贩，也有帮船打气的。有的时候水流速度比较快，需要死命扎着水才能划到岸边，岸边的人会伸出竹竿拖你上岸。上了岸想抬起船把水倒掉，发现船垫子里面也进了水，特别重，往往需要两个人合力才能翻过来。但并不仅是急流，非急流同样也会让人很难受，法和学义的船就在一个地方翻船了。我没有看清楚具体情况，便见到法跌倒顺流向右侧的在一块礁石上，学义在法后面几米的对岸的浅滩上。我们将船划靠岸，走上前看学义的伤势。他半跪着，捂着腿，面部表情痛苦，再看对岸的法正在脱开护膝，他似乎膝盖被磕破了。后来据法说，当时自己脑子里面一片空白，只想抓着一块东西，于是被船拖拽着往下游走。当时岸边的救生员从岸上拉着安全绳探身下去，硬是抓了他两次还没抓着。即使是平缓的地方也不好过，我的船经常搁浅，于是得十八般武艺都用上，用木杆撑，使劲往下面扎着划水，几番下来，腰都快断了。可是到了后来，搁浅的姿势也是百花齐放，常常我们的船是被两块石头夹着，必须要下来推。有次我们的船没走社会主义的阳关大道，而是拐进了旁边资本主义的羊肠小道里面，我下船推了半天也没用，最后是我们两人全部下船，走到岸上（幸亏搁浅到的左舷石头离岸边近），硬是把船拖上了岸。当然最恶心的还是在进入险滩前被搁浅，生怕推多了船飘走自己跟不上，腿都是在抖的。随着漂流的进行，我们觉得越来越冷，特别是船半进水的时候，恨不得站在船上，这时候瓢的作用又显示出来了。距结束还有两公里的地方，我们拉着横贯水面的绳索上了岸，岸上的小马哥提供免费的生姜茶，我们都喝了若干杯，感觉身上重新开始暖洋洋的了。一问原来之前又是进水又是翻船又是搁浅的我们才过了三公里，只有刘鹏那一艘已经远远超过我们。于是大家相约都快点结束，而且真是冻得受不了了。不过我们还是遇到一个大一点的摊子就停下来倒水。到了最后一个险滩前，老板说可以等玩完再用微信支付，于是我们上岸吃了一点粉（妈的里面有折耳根），法和卓林点了糍粑和干子，总共居然花了70块钱，我们顺便叫老板给船充了气。到了最后一个急流时，当时欢欢和我已经冻得不想玩了，我感觉自己肚子又在抽搐了，心里数了数，觉得前面就是最后一个古耳洞瀑布，于是都想快点过完这个急流早点结束，也不愿意舀水了。刚开始时这个急流并不是很急，水都没怎么进我们船里面，突然水流变快，我们被裹挟着往下进入一个S型的道。伴随着船的碰撞，我左右转动身体使得正面对着前进方向以免耳朵进水。正当我看到船已经要落至最低点，深吸一口气准备承受那一击时，突然感觉船碰了一个东西，下一刻自己已经在水里面了，惊慌失措地踩了两下水，好像没踩到下面的石头，不过得亏穿着救生衣，我很快浮上来并看到自己的船从左上方迅速飘走，我本能地想抓住船，不过又想起法的遭遇，便放弃了。喊了下发现欢欢就在我旁边，我赶快抓住她防止被两人冲散。这时救生员和我说到岸边上岸走吧，这是最后一个急流了，前面就到终点了。我摸摸眼镜发现还挂在脖子上，看来这次绳子立大功了，戴起眼镜发现抬脚发现右边就是有几块礁石露出水面，我们跨过石头来到岸边，又顺着崖边长满青苔的石头爬上岸上的栈道。到了岸上往下走才发现我们船翻在了第一道落差上，后面至少还有100米的急流，最恐怖是有一个高接近两米的瀑布，不禁暗暗庆幸自己不是在那里翻的船。遇到小伙伴们，一见面就说，果然是你们的船翻了，原来我们的船先我们到了终点，大家甚至就是不是我们的船还产生了一些争论……然而我们还是不辱使命，追随者我法的脚步翻了船。高过河漂流结束，看了看，时间也不早了，我们遂要求包车司机走高速直接把我们送到了镇远火车站。贵州高速常常是两车道的，并只有非常窄的紧急停车道，在某些路段会设有紧急停车带，我甚至看到了一条避险车道。我们坐着深深伤害了我们的K495来到了凯里，火车上居然遇到了一个高邮在兴化打工的人，他和另外一个昭通人一起从上海乘火车准备到遵义，据说是为了做生意，我们在火车上吹了好一会牛逼。到了凯里，刘鹏说自己老师找他，还要顺便回家歇两天，便先走了，我们乘坐联系好的SUV前往西江苗寨。SUV就是好，空间宽敞，我们虽然行李箱特别多，但是全塞后面居然还撑得下。在火车站，司机和我们讲待会儿出去不要说我们给钱，而是说酒店接客，一路上司机侃侃而谈，于是我们被贵州人的热情好客吓到了。司机说自己是西江人，之前和凯里的出租车司机为接客人打了起来，他觉得是自己接自己的客人理所应当，于是一个人干翻了三个司机。后来凯里出租车司机看到凯里的牌照都要抬一杠子。我们去西江苗寨也是直接走的高速，不过司机开的特别快，问问才得知这里的高速基本上超速都没人查的。一路上是各种隧道，什么脚勇隧道、摆底隧道，据说都少数民族的语言。路上学义在纠结去成都的事情，。到了苗寨，发现这里的门禁很严格，我们的车被保安拦住了，我们游客需要在另一个入口验票进入苗寨才行，于是司机只能先把我们送到那个入口，然后自己进来开过来接我们。我们在千户苗寨住的是吊脚楼一样的房子，爬上一段室外的石阶，才是“一楼”，也是我们住的标准间，从刚才的石阶再往上爬一段，便是二楼。二楼往里走有一个大客厅，里面居然还有三国杀。客厅往里走左边有个厨房，里面煮了一锅超级多的杨梅汤。厨房隔壁是厕所，这间厕所也是有个性，朝外还有另一扇虚掩的门，处理个人问题的时候门外可以看到人影攒动，生怕风或人把门推开。厕所对面是一段室内的楼梯，往上走第三层的露台+阁楼，在上面走啪啪的脚步声和木板的吱呀吱呀声从楼下的客厅听得一清二楚，感觉用点力楼板就要塌下来一样。小姐姐们的三人间便在这层上。我们找老板分配房间的时候，学义在一楼门口的花坛上看到了一条蛇。安顿好了，我们便出发准备逛逛苗寨的夜景。从我们的宾馆去观景台需要朝着苗寨博物馆的方向走，穿过一座桥再往上爬一段路。观景台是一个大的平台，平台两边还有一些店铺，一块石头上书天下西江。晚上回来，考虑到要送欢欢去机场，我和法打算研究一下黄果树的宾馆，尽可能地早点结束，我们也总算把张家界刘鹏买的泡面吃完了。 D3 Jul.7 凯里西江苗寨-关岭-黄果树景区今天我们在千户苗寨，经过了一天的漂流，大家都很累，于是早上其实就废了。我法早上出去吃早饭了，我随即出去买了条毛巾，不过此时天上微微下起了小雨，于是就回去收衣服，一看发现衣服都被淋湿了，于是和宾馆老板借了个电吹风，吹了一上午的衣服，可惜漂流时穿的那个踢设是棉的，一早上都没吹干。于是我放弃了，去苗族文化博物馆逛了下，其实苗族的一些生活用具比如面盆架，织布机或者各种厨房用具以及农具和我们汉族都是很相像的，据说早上的是有表演的，不过我们都错过了。中午我们去卓林之前计划上的西月火塘吃正宗的酸汤鱼。讲道理这次的酸汤鱼和米酒比前天吃的要好吃太多了！吃完酸汤鱼我们还意犹未尽地喝了酸汤汤底。去西月火塘吃完，便走到西江边上逛，这时候太阳出来了，感觉先前吹了一上午衣服也是不够机智。大概四点四十左右，昨晚送我们来的大哥来接我们了，将我们送到了安顺西站，我们乘坐高铁前往关岭。贵州的高铁也是瓜皮，感谢盛高祖，原先的350高铁变成了250，动车组好的时候能开到220了不得了，要是进了隧道或者其他的一些情况就只能开到80几，只有靠近贵阳的一段能开到280。关岭有著名的花江狗肉，到了关岭，是一个瘦猴儿司机开着他的破MPV来接我们。我们咨询他从黄果树到龙宫的事情，他便开始说不靠谱什么的，要花两个多小时什么的，但是我们查了下走高速只有30-40分钟左右。到了宾馆，我们在附近的一个小饭店吃了晚饭，我们惊讶的发现这里的菜不仅略贵，而且是政府定价的，也许就是为了防止景区及附近的饭馆疯狂涨价吧。吃完，我卓林和法一起找景区车和售票处，大家在黑漆马虎的地方绕了好一段路，法还把我们甩掉了，最后我和卓林通过查看百度地图在发之前找到了售票处，原来之前我们走过头了，从宾馆到售票点真的很近。 D4 Jul.8 黄果树景区-龙宫-安顺今天我们7点钟便起来前往黄果树瀑布景区。外面下的是小雨，还没出宾馆，我们就被各种卖雨衣和鞋套的人包围了，在宾馆里，大家勉强买了六件雨衣。然后到进口附近吃了点粉，期间有买鞋套的还一直追我们到店里。黄果树景区的寄存是承包给外人收费的（敦煌的是免费的），但放到宾馆在回来拖又太累了，于是我们还是花了这钱。在寄存行李的时候，有人来来生意说50元一人包车，这个价格和景区观光车一样，但是就不要我们等了。商量完，我们就去对面的游客中心买票，然后得知今天天星洞、水上石林、水帘洞都不开了。黄果树瀑布从北到南分为陡坡塘、大瀑布、天星桥，我们首先参观的是最近的陡坡塘瀑布。陡坡塘瀑布是黄果树瀑布的上游，是《西游记》电视剧片尾曲的拍摄地，比下游的黄果树大瀑布还要宽。其实后来我们发现从陡坡塘走到大瀑布景区是非常近的，可能是为了渐入佳境的缘故吧，我们先去了天星桥景区，也就是黄果树景区的最下游。相比于陡坡塘和大瀑布单纯的壮美，天星桥更偏向于秀美。天星桥的美景主要集中在后半段，例如银练坠潭瀑布和星峡飞瀑等。在出发前司机提醒我们不要跟着旅行团在高老庄的地方提前出。进入天星桥首先便是一道从崖壁上坠落的瀑布————马尾瀑布，我们必须打着伞才能保证通过。顺着栈道往下走便是数生步景点，数生步由366个石阶组成，领着我们在水潭与石洞之间上下穿行，每一块石子都是表示一年366天中的一天，有些石头上面刻着出生在这天的伟人的生卒年份。再往前有侧身石、寻根岩和美女荣等景点，有需求的朋友们→_→可以去玩玩。再往前走眼前豁然开朗，这里便是天星湖。天星湖在群山环抱之间，往上看，青山笼罩在一片云雾之间，敢问那高山之上是否有仙人常驻呢？环湖一圈便到了半程出口高老庄，出于赶时间，我们在这里并没有久留，据说这里就是猪八戒娶亲时的高老庄，也是巧了，我们在敦煌的时候也见过一个高老庄呢，感情这猪八戒不只娶了一个老婆呀？过了高老庄继续往前走是一道万丈深壑，顺着吊桥往前走便到了桥上桥上桥景点，这其实就是一道悬崖上的桥，这个“桥”实际上两边伸出来的石壁组成的，但中间一块石头像个锲子一样钉入石壁之间形成了一道独特的石桥。从桥上桥上桥往前应该是进入天星洞参观，但由于下雨的水位的原因，天星洞关闭了，我们只能顺着山侧的栈道往下走。到了谷底，渐闻水声隆隆，原来河水在天星洞时便进入了地下暗河，于是整个天星洞范围便形成了一座大桥，也就是桥上桥上桥的最后一个桥字。而这暗河的出口便是冒水潭这个景点。自此从上游流下来的河流又重见天日，奔涌向下，直到银练坠潭瀑布，这这波澜壮阔的景象有个恰如其分的名字：跌浪飞雪。 瀑布下端似乎是个无底洞一般吞噬了上方翻滚着的汹涌一片，水流经过短暂的驰骋又重新进入了暗河，我们顺着栈道向上走便到了水上石林景区，可惜也关闭了。在大瀑布外吃了德克士，44元的汉堡套餐，配有原味鸡，还送一个装满可乐的杯子，感觉相比16块钱一个的汉堡也不是不划算了。最爽的是站在犀牛潭了，由于水帘洞和第五观瀑台的关闭，这里实际上是离瀑布最近的地方了。黄果树瀑布倾泻而下，蒸腾起漫天水雾。离开的时候太阳出来了，不禁有点后悔，如果现在在瀑布下面，一定是能拍到彩虹的吧。大瀑布的人越来越多了，我们也赶时间去下一个景点。还没出黄果树景点，我们就和司机打了电话，要他赶过来接我们，可是等我们到了之前吃德克士的广场上，他还没来，打电话也是敷衍，我们一直等了半小时。这瓜皮一定是中途又带客了，由于他违反了约定，所以我们也没按照约定给他钱，只给了300，所以我觉得黄果树景区还是坐大巴好。贵州的旅游其实做的并不好，就拿安顺来说吧，从安顺西高铁站就没有直达黄果树的班车，如果不想打车，就只能到安顺东站坐车。而欢欢要在今天飞回南京，所以昨天大家就行程商量了下。卓林提议可以由他送欢欢去机场，我们其余的去龙宫，大家都同意了。不过欢欢今天觉得这样太麻烦卓林了，可能还有点事生他的气，所以就自己一个人坐了去安顺的大巴。卓林送完欢欢回来，流鼻血了当司机把我们从大瀑布景区接回来时已经差不多两点了，而龙宫景区在五点半之前停止售票。想从黄果树到龙宫，发现这趟班车今天并没有开（难道现在还不算旺季么），于是重又联系昨天的司机，司机带我们去龙宫，并送我们到安顺站，司机要价280。到了龙宫景区大概花了35分钟，我们一进售票厅便看到告示说连日下雨，二进龙宫不让进了。其实我们这次很多溶洞都没有看到，例如今天上午的天星洞，这次也不例外。进了龙宫，迎面而来一个小瀑布，不禁莞尔，我们刚去过黄果树瀑布好不好。但当转了一个弯后我们就被眼前之景吓到了。只见眼前是一个大山洞，山洞里弥漫着雾气，传出隆隆的声响，仿佛有仙人降临一般，这便是龙门飞瀑。龙门飞瀑正对面有一座桥，从桥上走过去有一个平台可以更近距离地观赏瀑布，我们争相到平台处和瀑布合影，短短几秒钟的时间，衣裤竟然全部湿透，可见水汽之盛。从这个平台还有石阶可供攀登，登临到离飞瀑更近的地方，不过我们没人敢去。从龙门飞瀑旁边可以坐观光电梯上去（要钱）也可以走电梯旁边的溶洞走上去，推荐还是走溶洞，还挺长的，走一走蛮有意思的。法一直心心念念龙宫的龙字田，想停在那里拍照。还在南京计划行程的时候，卓林就说之前看到过晚上有一班安顺到麻尾的列车，但却找不到了，唯一能用的是K1222这趟耗费一个上午的火车，因此他计划我们在安顺开个KTV，或者做个大保健，一直到早上乘车去麻尾。不过司机说安顺大保健还比较贵，可能要三四百的那种。司机把我们送到了安顺火车站边上，我们觉得他人挺实在的，就没跟他讲价，给了他280。我们在附近马鞍山路的一家餐馆吃了晚饭，这是一家很脏的餐馆，有点像室内版的大排档，垫桌布上面有着厚厚的油渍。吃完饭外面下起了蒙蒙小雨，我们想走到应该是位于黄果树大街上的一家KTV，可是刚走上过街天桥，雨突然刷得就变大了，我们只得匆匆下了天桥，顺这路边找有麻将房的宾馆。我们在麻将房里打了一会贵州（贵阳）麻将，贵州（贵阳）麻将感觉很是奇特，我搞了半天还是不怎么玩的起来。首先它牌非常少，没有我们这边的花啊东南西北风啥的，其次它的胡牌也很有特点，例如有小七对、大七对和清一色这样的胡法。小七对指的就是对对胡，而大七对就是三张的胡。对于除此之外的其他胡法必须要有杠之后才能胡牌，否则只能自摸。另外，麻将中的一条（幺鸡）是一张特殊的牌，如果别人你听牌了，那么可以根据手中的幺鸡数量赢筹码。特别地，如果你先前打出这张幺鸡，那么你的胜负筹码会加上一番，如果恰巧你是第一个打出这张牌的，那么你的胜负筹码会加上三番。打了一会儿法可能嫌我们有点吵了，就出门了。躺在床上玩手机传照片，突然学义喊了下我，一只虫子从我床上爬过，钻到不知道什么地方，我们挪了挪法的行李箱，发现它从床底又钻了出来，我怕它是臭虫，没敢踩。后来看清楚是蟑螂，学义一觉将它艹飞了，我拿了一个拖鞋把它打死。我们打算把三张床其中的两张搬到一起，这样我们三个男生可以合起来睡两张床。把边上床一挪，好家伙又是一只蟑螂，我们又开始灭蟑行动。这时法来消息说自己找了一个118的大保健，管饭还包夜，发了个定位在2km以外。果然跟着我法还是得吃啊。 D5 Jul.9 安顺-麻尾今天的任务主要是从安顺到麻尾。我们一早从麻将房起来准备赶去麻尾的火车，打法电话，法不接。心想这小子不会真去做“大保健”了吧，过了一会儿法和学义通了电话，原来真是睡着了。到了车站，法吐槽说自己做完按摩之后人家“体贴”地把他手机收起来了，导致他没听到起床闹钟，幸亏自己每天有五点多起床的习惯，才不至于误了车。火车晚点了一个小时十分钟。上车后，我们三个三个在不同的车厢。据卓林说，从都匀到麻尾要过58个洞，最长的一个洞要五分钟。具体多少个洞呢我是没数，但手机是根本用不了。躺在床上，上铺和下铺是一对母子，两个孩子睡在上铺，不停地在卧铺上爬上爬下，我是很担心他们会摔着。到了麻尾，卓林带我们来到了他家。是一栋三层的自建房。中午卓林爸妈请我们吃了牛肉牛杂火锅，和自己酿的葡萄酒（一汽油瓶）。那个葡萄酒真是特别的好喝，相对于市面上葡萄酒，更类似于葡萄汁，感觉没什么单宁，而是特别得甜。卓林爸爸非常热情，我们喝了好多杯。饭吃完投昏昏的，这葡萄酒后劲还是有的。酒醒了已经是六点多了，天还亮着，我们布依风情园是来不及去了，于是我们就简单地在镇子上逛了逛，顺便看看卓林家还没有装修的新房子。晚饭是喝茅台酒。 D6 Jul.10 麻尾-荔波小七孔-麻尾卓林的叔叔将我们从麻尾送到小七孔进行游玩。麻尾到小七孔有麻驾高速，不过这是噩梦的开始。刚下高速的地方是小七孔西门，那里在修路，黄埃散漫，路是非常地颠，我们不得不绕一个大圈从东门的服务中心进去，花了不到一个钟头的时间。小七孔东门离大七孔非常地近，但是卓林说大七孔实际上很瓜皮，所以只玩小七孔，在旅客中心买好了门票，我们去坐观光大巴到小七孔的一个临时入口，大家走过悬索桥，看到一个三孔桥“小三孔”，戏谑地说这小七孔还有四孔在哪儿呢？过了桥，下到地面，又得坐大巴，这趟大巴直接把我们送到了靠近西门的卧龙潭处，然后我们往回游览，最后回到东门。在乘坐大巴的过程中，我们匆匆看过68级水跌瀑布、拉雅瀑布等景点，还有一道瀑布从我们车上经过，越过盘山公路直接注入左边的河中。卧龙潭是一个半环的瀑布，在见过黄果树和龙门飞瀑之后，其实这个瀑布并没有引起我的惊艳，它近乎完美的半圆形有点让我觉得有点人造的。反倒是在瀑布前硬堵着莫名其妙载歌载舞的大妈们引起了我的反感。从卧龙潭可以选择50元的漂流到下面的鸳鸯湖景点，不过我们还是选择了乘坐大巴前往。在等车的时候，我们顺便到对面的坡上参观了娃娃鱼。到了鸳鸯湖，不禁吐槽这特么太坑了，两个项目鸳鸯湖划船(30)和天钟洞(8)都要付费。否则几乎没办法观赏鸳鸯湖的景色，在经过商量之后我们决定六个人正好划一艘船。事实上这波体验还是比较充实的（主要是累得）。我们拿到的桨有的是木头的，比较重，有的是合金和塑料的，比较轻，划起来很爽。由于我们的划力不对称，而且预判做的不好，我们的船经常方向调整过当，在湖里面转圈子。划船的时候我们又遇到了之前载歌载舞的大妈们，她们分了三四条船在湖中浪荡，唱和着（走调的）青藏高原。我和卓林便也和他们起哄，唱起了（完全不在调上的）《我的祖国》、《天路》，并很快与大妈们拼起了嗓门。排队坐车从鸳鸯湖到翠谷瀑布时，队伍正好截断了，我和卓林只能等下一趟大巴。从翠谷瀑布出来到水上森林我们没有坐车，我也脱掉了鞋套，换上了拖鞋。事实证明是我是对的，水上森林应该是小七孔最有意思的一个景点了，他和我们这边的水上森林不一样，湍急的水流从生长在乱石上的树木中流过，发出哗哗的声响。从水上森林出来坐上车，越过石上森林、拉雅瀑布等景点直接把我们送到了小七孔桥。为了看上游的68级水跌瀑布、拉雅瀑布等，我们又往上走。公路很窄，并且经常有大巴车从我们身边经过，在临崖面上有些地方已经修好了人行栈道，不过更多的地方还正在修，我们可以看到很多工程设备，工人们站在外伸梁和脚手架上在忙碌。我们看完那道越过盘山公路的瀑布后往回走，来到最后的景点小七孔桥。小七孔桥下面的河水叫做响水河，当它经过上游的大大小小的68级水跌瀑布来到小七孔古桥身前时，却是静的可怕。碧绿色的湖水犹如一面镜子一般，静谧的不想打破。据说小七孔古桥是清朝时黔南通往广西的交通要道，过了桥便到了广西地界。晚上，卓林爸妈请我们吃了狗肉、排骨、口条、大肠以及当地的小螃蟹小虾。狗肉是火锅的主料，非常的香，是卓林爸妈走很远的地方买过来的。排骨是预先炸好的，鲜红鲜红的，有点老了，但是非常好吃。大肠有点像机油渣子了，焦油味特别浓，但是有嚼劲，挺好吃的，不过我知道是大肠后就没怎么吃了。酒依然是之前的葡萄酒，我们最后把一汽油瓶的酒全部干完了。 D7 Jul.11 麻尾-贵阳-南京昨晚葡萄酒又喝醉了，吃晚饭一直睡到十一点多，洗了个澡继续睡，早上小轿车把我们送到火车站。路上司机和我们介绍说那个葡萄酒其实是用米酒泡葡萄的，我们觉着后劲非常大。这里必须吐槽一下贵阳的交通了，我们从火车站出来，走过一个天桥，到了遵义路上，希望能够找到空港巴士。到达机场发现还有个从福州过来的前序航班，估计又要延误了，不过后来换成从济南过来的一架飞机。临走时，卓林送了一些锅巴给我们，吃起来又油又甜，不过却非常酥脆，还是挺好吃的，午饭就吃这个了！飞机到了万州机场经停，我们在飞机上等待，空姐发放了贵州都市报，打开一看，这两天龙门飞瀑水量为十年来最大值，看来我们真是运气好，虽然二进龙宫没看到，但是那个瀑布着实还是震撼。从万州机场起飞后，天气一直很好，飞机有段时间沿着长江走，可以从飞机上我看到了三峡。 总结心得贵州是一个多民族的省份，在旅行过程中，卓林也一直和我们介绍贵州的风土人情。卓林是布依族人，据他介绍，布依族和广西的壮族（北壮）基本一致，可以认为在贵州境内称为布依族的，在广西境内就称为壮族，这时候他通常又会教我布依语，什么萌得了骨，古德亚梦啥的。贵州的行政区划也很有意思，例如少数民族比例比较高的铜仁被划为了地级市（之前是地区），而比例较低的黔东南则划为自治州。各地级区划上也是犬牙交错，如更亲近于贵阳的贵定被划入了黔南州。 当前的我国维稳第一，在我们的教育中，只讲要团结少数民族，但具体怎么个团结法呢？我们只能看到通过利益输送笼络各少数民族，而主体民族也容易产生反感，实际上这会产生不利于民族团结的结果。例如，在主体民族中，常常就会把各少数民族进行脸谱化，这是非常不好的。无论是团结或者尊重，都要始于了解。 贵州旅行建议贵州的交通是非常瓜皮的，由于山多，快速列车只能开到最高90km左右，而动车也就最高220km，同时如黔桂线是单线铁路，让车也会耗费较多的时间，因此贵州的铁路交通会耗费较多时间，比汽车要慢，而且不够舒适。此外，贵州交通的配套也做得很奇葩，例如荔波现在没有铁路，公路也很瓜皮（只有通麻尾的高速），但偏偏就有一个机场，而安顺到荔波却没有直飞的航班，因此去荔波的路就非常难走。此外铜仁也是比较尴尬的一个地方，它的铁路和湘黔线是两条平行的线，因此我们直接忽略过去了，事实上铜仁更适合放在张家界-凤凰-铜仁线上。在本身交通并不便利的情况下，景区为旅游也没有过多地去打算。此外在贵州走路要十分当心，贵州的很多路是不使用红绿灯的，取而代之的是他们的减速、停车让行比较严格，不过难免可能碰上冲的司机，所以还是小心为上。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>贵州</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔方公式总结]]></title>
    <url>%2F2017%2F06%2F09%2F%E9%AD%94%E6%96%B9%E5%85%AC%E5%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[基本规律 x, y, z系操作后不影响面的转动方向 例如对于公式y’ U’ (R’ U R)，经过y’后变为U’ F’ U F，只有转R变成了转F，但方向是不变的 常用手法 fsc1: R U R’ U’ 将当前槽起到顶层 fsc2: U R U’ R’ fsc1的反操作 s: U’ F’ U F t: U R U’ R 层先法底层底层只需要记住底面分别在前(fsc2)、上(R U’ R’ U’2 R U R’)、右(R U R’)的三个公式即可。 第二层比较好记的是五逆五顺。在右面对成3x3的倒T，向顶面棱块顶面颜色相同的方向转，顺时针就用五顺公式，反之五逆。还有一种使用s和t公式，方法是和五逆五顺一样对齐，然后根据起手U’或U使用s-t或t-s。起手往要归位的相反方向转动顶层。 顶部十字一个公式F(R U R’ U)F’，分别是点、左上角小L和一字形态，其中后两种可以不回F’连转。 顶部角块R2 F2 R’ B’ R F2 R’ B R’，注意B’ R的方向不要转反掉 简单的CFOPCrossCross要抓准面的相对位置关系，不需要直接与侧面四个中心块对齐。当白面朝上时，逆时针依次是红-蓝-橙-绿，当黄面朝上时，逆时针依次是红-绿-橙-蓝。推荐转的时候黄面朝上，以红色为基准，口诀是男(蓝)左女(绿)右。 F2L以魔方小站上的公式为准，一共有两类基础情况，这两类基础情况中角和棱都在顶层。 顶层异色 第一类情况其特点是顶层异色，最基础的一种是可以通过一步R(RUR’)或F’(F’U’F)能够将角块和棱块的相对位置做正确。 对于其他的底色块在角块侧面的情况，可以转化为以上的格式。这时候需要将R(‘)或L(‘)将角转下去“藏”到底面，转动顶层使得相对位置变为基本情况。这个操作会将你要藏角的槽的对面的槽转上来，所以特别注意不要破坏已经对好的槽，比如可以借用（也就是把这个槽起上来，角块藏下去，再还原底层十字）自己的槽，这可以借助U/U’或者d/d’实现。这里d/d’实际上是更好的一种做法，对于新手能够避免频繁的xyz操作。 顶层同色 另一类情况是角块和棱块相对位置已经正确了，但是全部在顶层，还未归如槽位，根据不同情况有U’F’UF和URU’R两种公式。 对于剩余的顶层同色的情况，可以转化为以上的格式。这时候需要将F或将角转下去“藏”到侧面，转动顶层使得相对位置变为基本情况。同样特别注意不要破坏已经对好的槽。注意这里空间位置要难一点，可以区分白色块在前侧面和右侧面（需要先U一下把右侧面的角转到前侧面处理）进行记忆。 白色块在顶层 将白色块转到侧面，按照1或2处理 OLL首先，鱼头和层先法是一样的。对于十字有两种情况。对于缺两角有三种情况。 PLL记住三棱换公式F2 X M’ X2 M X F2，其中X为恢复方向，取U或U’。记住四棱换公式： 十字对换 M’2 U M’2 U2 M’2 U M’2，M’即中间块向前转。可以发现这是一个关于(M’2 U)2的对称公式 平行对换 这里的平行对换指的是左上对换、右下对换，公式是 (M’2 U M’2 U) (M’ U2) (M’2 U2) (M’ U2)，记法考虑除了(M’2 U2)，其余都是M’2，U就转1次 CFOPF2L常见的非基本情况有角块底面（一般为白色）色块朝上、棱不在顶层、角块在底层。 1. 对于角和棱在一个槽里面，且白色块朝侧通过把棱起上来的可以将它转化为基本形式。在起的时候要注意尽量不要把白色小块转到朝上（因为这肯定不是标准形式）。其实这部分被公式更为快，因为不需要小心翼翼将棱起上来，并花费时间观察了。根据相对位置的不同，可以根据是否有颜色相同的侧面和与两侧中心块的位置关系（槽两边中心块的相对位置存在正反两个方向）分为四种情况。有的时候棱块角块位于错误的槽中，但假设我们按一个方向旋转这个槽，总可以将这个槽转对，所以与两侧中心块的位置关系只有两种情况 对于这四种情况有如下的套路：对于同侧面同色的情况，将角块逆时针转到侧面并旋转侧面藏下角块，此时棱块被起上来了，则向靠近角块的方向旋转，做正相对位置。对于同侧面异色的情况，这时候角块只有一个面是与中间棱块的位置是正确的，那就要用U或者U’使得角块上的这个面转到和棱块上的对应颜色位于相同的旋转盘上，然后通过向下藏角起棱的方式将棱转到（U或U’）合适地方，这样就能做到顶层异色的基本情况。如果转反了很容易想到会造成顶层同色的情况。在转动的时候为了不破坏转好的棱，常使用d转动下面两层，然后U’起上来的就是自己的槽了。 2. 对于角和棱在一个槽里面，且白色块朝上相对方向正确的话直接起上来即可。相对方向不正确，3次fsc1即可 3. 对于角和棱位于顶层且相离，且白色块朝上这时候应该藏棱（顺时针和逆时针对应两种情况），转动顶层使得角块与棱块对齐。 4. 对于角块在底面有的情况角块不在顶层，而在底层 对于角和棱在一个槽里面，白色块朝下 用公式(R U’2 R’ U)2将它们起上来，并且做对相对位置]]></content>
      <tags>
        <tag>魔方</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Word用法]]></title>
    <url>%2F2017%2F05%2F20%2FWord%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[微软Office产品的特点是看上去非常弱智，但实际用起来各种棘手。比较麻烦的有自动添加引用文献、设置多级标题、自动续表等工作。这里介绍以下我的方法。 自动添加引用文献网上描述的脚注的work around不是最好的方法，最好的方式是直接使用插入引文，然后对样式进行配置。配置方法参考我的Github项目 设置多级标题设置多级标题是为了实现这样的效果方法是先实现一个多级列表这里需要注意几点： 编号之后不能添加制表符，否则样式会乱掉 选择正规形式编号 对于每一级的列表，选择将它链接到样式 设置为左对齐，对齐位置0厘米 自动续表选择标题行，在表格属性中选择“在各页顶端以标题行形式重复出现” 使用主次坐标轴右击需要设置坐标轴的折线，选择设置系列格式 设置页眉从某一页开始设置奇数偶数页眉 在页面布局下方的分隔符菜单中选择“下一页”分隔符，则可以单独设置这页以下页面的页眉 选定需要设置的页眉，取消“链接到前一条页眉” 选定第一个奇数页眉，添加固定文本 选定第一个偶数页眉，添加StyleRef域分别选中和不选中插入段落编号各一次]]></content>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[明史之太祖本纪]]></title>
    <url>%2F2017%2F05%2F20%2F%E6%98%8E%E5%8F%B2%E4%B9%8B%E5%A4%AA%E7%A5%96%E6%9C%AC%E7%BA%AA%2F</url>
    <content type="text"><![CDATA[去敦煌玩回来的时候，卓林兄说其实明史是写的不错的，建议我读读。 一朱元璋籍贯濠州钟离（安徽凤阳），排行老小。出生时自然是天降异像，长大后自然是资貌雄奇。朱元璋十七岁的时候父母和（长）兄因为饥荒都死掉了，朱元璋只能进入皇觉寺当僧人。当时盗贼四起，刘福通供奉韩山童（红巾军），假称自己是宋朝的后裔，在颍地起兵。徐寿辉（红巾军天完政权）僭越称帝，在蕲地起兵。李二彭大赵均用（响应刘福通起义）在徐州起兵，方国珍早已在海上起兵。十二年春二月，郭子兴和孙德崖起兵濠州，元将彻里不花惮不敢镇压，只能欺负老百姓，朱元璋占卜决定投奔郭子兴造反。郭子兴看重他，又因为每战必胜，所以将至交马公的女儿许配给他，后来成了皇后。郭子兴和孙德崖不合，朱元璋经常从中调解。至正十二年九月，元军收服徐州，李二死于逃跑图中，其余两人投奔孙德崖。郭子兴礼遇彭大却轻视赵均用，孙德崖和赵均用于是合谋，在郭子兴外出时拿下，准备干掉他。这时候朱元璋在淮北，知道后赶回告诉彭大，彭大非常生气，和朱元璋一起率兵救出郭子兴，背着回来，郭子兴这才免于一劫。这年冬天，元将贾鲁围兵濠州，朱元璋和郭子兴共同抗击。到了第二年春天，贾鲁死了，包围解除了。朱元璋回家乡招募了七百人为兵，郭子兴非常高兴，让他当了镇抚。这时候彭赵两系比较跋扈，朱元璋就把兵权给其他将领，自己和从家乡招募的少时伙伴徐达、汤和、费聚等人进攻南方的定远，用计招降了驴牌寨的三千民兵，在横涧山夜袭元将张知院营地，收了两万兵，路上遇到李善长，（与之交流平定天下之术，）聊得很开心，于是和他一起攻下滁州。至正十三年的时候张士诚（江苏兴化人）在高邮自称诚王，到了十四年十月，元朝丞相脱脱在高邮大败张士诚并包围六合。朱元璋认为六合一旦攻破，滁州就不能免于灾难，于是和耿再成在瓦梁垒救援，将老弱病残护送回滁州。元军进攻滁州，朱元璋设伏击击败了元军。朱元璋（揣）度元军士气旺盛，肯定会再来，于是认了怂，归还缴获的马匹，让父老答谢元军，并说我是在守护城池防备其他反贼，为何要舍弃大盗而来追杀良民呢？元兵离去，滁州城得以保全。脱脱由于攻破张士诚，气势大盛，却中谗言，突然（遽）失去兵权，导致江淮更加混乱。至正十五年，郭子兴采用朱元璋的计策，派遣张天祐（郭子兴妻弟）占领和州（安徽和县），檄命朱元璋带领和州的部队。朱元璋将领们各不相让（不相下），于是先不公开檄文，等到第二天早上（旦日）再说。当时坐次以右为尊，将领们先进入，都坐在右边，朱元璋故意后到，坐在左边。到了讨论军机要事（比视事）的时候，朱元璋分析头头是道，大家都瞠目结舌，开始渐渐拜服（稍屈）。讨论分工筑城，约定三日，朱元璋做完了，其他将领都落后。朱元璋于是拿出檄文，朝南而坐，说“我奉命统领你们的兵权，现在筑城只是都落后了，按照军法要如何处置？”，将领们都惶恐谢罪。朱元璋于是将军队劫掠的有夫之妇搜出放回家，民众非常高兴。元军十万兵马进攻和州，朱元璋守城三个月，食物将要（且）吃完，然而太子秃坚、枢密副使绊住马等人在新塘等地断绝粮道。太祖率领大军大破元兵，元兵渡江逃走。三月份郭子兴死了，当时刘福通在亳州迎立韩山童的儿子韩林儿（小明王）建国号为宋。檄令郭子兴儿子郭天叙为都元帅，张天祐、朱元璋为左右副元帅，朱元璋慨然说“大丈夫怎么能够受制于人呢？”于是不受。但是考虑到韩林儿势盛可以依靠，于是用他的年号来率令军中。四月份常遇春归顺。五月份朱元璋想渡江却没有船，正好（红巾军）巢湖帅廖永安等人带领千艘船来归顺（附），朱元璋非常高兴，前往安抚。元中丞蛮子海牙扼守通程闸等关隘，巢湖舟师无路可出。忽然天降大雨，朱元璋说真是天助我也，于是趁着水涨，从小港乘船出来。趁机（因）在峪溪口击败海牙。于是定下渡江之计，众将领请求直捣集庆，朱元璋说要攻下集庆必须经过采石，而采石是重镇，防守一定坚固，而牛渚面临大江，难以防守，可以去攻下它。六月乙卯，乘风直达牛渚。常遇春先登陆攻克。采石元兵也溃逃，于是沿（缘）江各个堡垒全部（悉）归顺。众将领因为和州饥荒，争相去粮食准备回去。朱元璋和徐达说“渡江侥幸成功，如果舍弃回来，江东就不归我了”，于是将船缆全部断掉放在急流中（以断绝退路），和将领们说“太平（马鞍山当涂）此地比较近，我和你们一同攻取”，于是乘胜攻克太平，抓获（执）万户那哈出来。总管靳义透水自杀，朱元璋说这是义士啊，以礼埋葬他。朱元璋宣布禁止剽略，有士卒违背命令，斩首示众（徇），军中肃然。改路曰府，置太平兴国翼元帅府，自领元帅事，召陶安参幕府事。这时候太平四面都是元兵，右丞蛮子海牙等堵截姑孰口，陈聎先（陈野先？）的水军统帅康茂才率令数万人攻城，朱元璋派徐达、邓愈、汤和逆等人正面迎战，另外派将士潜入其后夹击，擒获野先，降其众，阿鲁灰等人逃跑了。九月份，郭天叙（郭子兴儿子）和张天祐等人进攻集庆，野先背叛了，两人都战死，于是郭子兴部将都归顺朱元璋。野先不就被民兵所杀，他的从子兆先收服他的部众，屯兵方山，和海牙掎角以窥太平。十二月壬子，释纳哈出北归。十六年春大破海牙于采石。三月癸未（2.25日），进攻集庆，擒获陈兆先，降其众三万六千人，他们都疑惑害怕不能保全自己。朱元璋选择五百人当守卫，解甲酣寝达旦，众心开始安定。庚寅，再败元兵于蒋山。元御史大夫福寿，奋力战斗，为之而死，蛮子海牙逃遁归顺张士诚，康茂才投降朱元璋。朱元璋进入城池，召集官吏父老说：“元朝政治腐败，干戈四起，我来为民除乱，请各位安于职守。贤士我以礼相用，旧政不便者除之，官吏不能贪暴殃及我的百姓。”民乃大喜过望。改集庆路为应天府，征召（辟）夏煜、孙炎、杨宪等十余人，葬御史大夫福寿，以表彰它的忠心。那时，元将定定扼镇江，别不华、杨仲英屯宁国，青衣军张明鉴据扬州，八思尔不花驻徽州，石抹宜孙守处州（浙江丽水一带），他的弟弟石厚孙守婺州，宋伯颜不花守衢州。而池州已为徐寿辉将所据，张士诚从淮东攻陷平江（今苏州）后，转掠浙西。朱元璋已经平定集庆，考虑到张士诚、徐寿辉实力强大，江左、浙右诸郡都被他们吞并，于是派遣徐达攻克镇江，定定战死。夏六月，邓愈攻克广德。秋七月己卯，诸将拥护朱元璋为吴国公，置江南行中书省，自己总领省事，设置官僚协助。朱元璋送（贻）文书给张士诚，张士诚不回复（报），却引兵攻镇江。徐达击败张士诚，进军包围常州没有攻下。九月戊寅，朱元璋前往（如）镇江拜谒孔子庙。派遣儒士告谕父老要勤于农桑，不久朱元璋回到应天。十七年春二月，耿炳文攻克长兴。三月，徐达克攻常州。夏四月丁卯，朱元璋亲自率兵攻克宁国（安徽），别不华投降。五月，上元、宁国、句容献瑞麦。六月，赵继祖攻克江阴。秋七月，徐达攻克常熟。胡大海攻克徽州，八思尔不花遁逃。冬十月，常遇春攻克池州，缪大亨攻克扬州，张明鉴投降。十二月己丑，释囚。第二年，徐寿辉的将领明玉珍占据重庆路。十八年春二月乙亥，朱元璋任命康茂才为营田使。三月己酉，审查囚犯（录囚）。邓愈攻克建德路。夏四月，徐寿辉率领陈友谅派遣赵普胜攻陷池州。第二月，陈友谅占据龙兴路。五月，刘福通攻破汴梁，迎接韩林儿在此建都。当初，刘福通派遣将领攻破山东、秦晋、幽蓟，使得中原大乱，太祖因此得以依次（次第）安定长江沿岸（江表）。朱元璋所过之处不杀百姓，收召有才之人，因此人心日益归顺。冬十二月，胡大海久攻不下婺州，太祖亲自率兵前往。石抹宜孙派遣将领率战车从松溪赶来来援，朱元璋说“道路狭窄，车战是在自取其败”。于是命令胡德济在梅花门迎战，大破婺州。婺州投降，执石厚孙。在攻克前一天，城中人望见城西五色云如车盖，认为是异象，到现在才知道那里是朱元璋驻兵的地方。朱元璋进入城中，发粮食赈济贫民，改婺州为宁越府。征召（辟）范祖干、叶仪、许元等十三人分直讲经史。戊子，派遣使者招抚方国珍。十九年春正月乙巳，朱元璋谋取浙东，却没有攻克各路。他告诫各个将领说“用武力攻克城池，用仁义平定战乱（戡乱）。我等到（比）进入集庆的时候，秋毫无犯，所以能一举而定。每次听到各个将领攻下一座城池却不妄杀，就会喜不自胜。军队行洞如火，不（控制）戢就成燎原之势。作为将令能够以不杀为武，不知国家能得到利益，更能够造福子孙”。庚申，胡大海攻克诸暨。第二月，朱元璋命令宁越知府王宗显设立郡学。三月甲午，赦免除大逆之罪以下的罪犯。丁巳，方国珍想要献出温州、台州、庆元（浙江宁波），派遣其子关为质，朱元璋不接受。夏四月，俞通海等收复池州。当时耿炳文守长兴，吴良守江阴，汤和守常州，都几次击败张士诚的兵。朱元璋借故久留宁越，巡视浙东。六月壬戌，返回应天。秋八月，元朝的察罕帖木儿收服汴梁，刘福通和韩林儿退保安丰（安徽寿县）。九月，常遇春攻克衢州，擒宋伯颜不花。冬十月，派遣夏煜授予方国珍行省平章，方国珍以疾病为由推辞。十一月壬寅，胡大海攻克处州，石抹宜孙遁。时元守兵单弱，并且听闻中原大乱，人心离散，因此江左、浙右诸郡，朱元璋的兵只要到达都能攻克，朱元璋于是向西进发，与陈友谅相邻。二十年春二月，元朝福建行省参政袁天禄以福宁降。三月戊子，征刘基、宋濂、章溢、叶琛到任。夏五月，徐达、常遇春败陈友谅于池州。闰月丙辰，友谅陷太平，守将朱文逊，院判花云、王鼎，知府许瑗战死。没多久，陈友谅谋杀自己老大徐寿辉，自称皇帝，国号汉，拥有江西、湖广地，与张士诚相约合攻应天，应天城内非常震惊。诸将商议先收复太平来牵制，朱元璋说“不行，张士诚他们占据上游，舟师十倍于我，难以收复。”有人（或）请求朱元璋亲自（自将）出击，朱元璋说“不行。他们用小部队（偏师）牵制（缀）我，而大军前往金陵，顺流半日即可到达，我们步骑难以及时返回，百里趋战，兵法所忌，这不是良策”。于是飞马告知胡大海攻打信州牵制他们的后方，命令康茂才（陈友谅的旧友）欺骗（绐）陈友谅，让他赶快来（进攻）。陈友谅果然领兵东进。于是派遣常遇春在石灰山设伏，徐达在南门外设阵，杨璟在大胜港屯兵，张德胜等率领舟师出龙江关，太祖亲自在卢龙山督军。乙丑，陈友谅至龙湾，大家想开战，朱元璋说“天色将要（且）下雨，催促（趣）吃饭，乘雨攻击他们。”须臾，果然下大雨，士卒竞奋，雨止合战，水陆夹击，大破陈友谅军队。陈友谅乘船走。于是朱元璋收复太平，攻下安庆，而胡大海也攻克信州。当时，太祖命令康茂才欺骗（绐）友谅，李善长对此很不解。朱元璋说“二寇联合，我首尾受敌，只有让他先来从而攻破他，那么张士诚就会闻风丧胆了”后来（已而）张士诚终于（竟）还是没有出兵。丁卯，设置儒学提举司，设置宋濂为提举，派遣自己的儿子朱标学习（受）经学。六月，耿再成在庆元（浙江宁波）打败石抹宜孙，石抹宜孙战死，遣使祭之。秋九月，徐寿辉旧将欧普祥以献上袁州投降。冬十二月，再次派遣夏煜以书传谕方国珍。二十一年春二月甲申，朱元璋设立盐茶课。己亥，设置宝源局。三月丁丑，改枢密院为大都督府。元将薛显以泗州降。戊寅，国珍遣使来谢，饰金玉马鞍以献。却之曰：“现在应当经营（事）四方，需要人才和粟帛，宝玩不是我所喜好的”。秋七月，陈友谅部将张定边攻克安庆。八月，朱元璋遣使去访问元平章（官名）察罕帖木儿。当时察罕平定山东，降服田丰，军声大振，故朱元璋与他通好。恰好（会）察罕方攻益都没有成功，朱元璋于是亲自率领舟师征讨陈友谅。戊戌，攻克安庆，陈友谅部将丁普郎、傅友德迎降。壬寅，到达（次）湖口，在江州追击战败的陈友谅，攻克其城，陈友谅奔逃武昌。朱元璋分别巡行（徇）南康、建昌、饶、蕲、黄、广济，所到皆攻克。冬十一月己未，攻克抚州。二十二年春正月，陈友谅江西行省丞相胡廷瑞献出龙兴（南昌）投降。乙卯，朱元璋到（如）龙兴，改为洪都府（南昌）。拜谒孔子庙，告谕父老，废除陈友谅的苛政，取消诸军需，抚恤贫无依靠（告）者，民大悦。袁、瑞、临江、安相继下。二月，朱元璋返回应天。邓愈留守洪都。癸未，归降之人蒋英杀金华守将胡大海，郎中王恺因此而死，蒋英叛降张士诚。处州归降之人李祐之闻变，亦杀行枢密院判耿再成并谋反，都事孙炎、知府王道同、元帅硃文刚因此而死。三月癸亥，归降之人祝宗、康泰谋反，攻陷洪都，邓愈出走应天，知府叶琛、都事万思诚因此而死。当月，明玉珍在重庆称帝，国号夏。夏四月己卯，邵荣收复处州。甲午，徐达复洪都。五月丙午，朱文正（朱元璋侄子）、赵德胜、邓愈坐镇洪都。六月戊寅，察罕帖木儿写书信来通报，留我使人不送回（遣）。察罕不久被田丰所杀。秋七月丙辰，平章（官名）邵荣、参政赵继祖谋逆，伏诛。冬十二月，元遣尚书张昶航海至庆元（浙江宁波），授朱元璋江西行省平章政事，朱元璋不接受。察罕的儿子扩廓帖木儿致书归使者。二十三年春正月丙寅，朱元璋派遣汪河回复（报）扩廓帖木儿。二月壬申，命令将士屯田积谷。这月，陈友谅部将张定边攻陷饶州。张士诚部将吕珍攻破安丰，杀死刘福通。三月辛丑，朱元璋亲自率兵救援安丰，吕珍败走，和韩林儿归滁州，朱元璋于是回到应天。夏四月壬戌，陈友谅大举兵围洪都。乙丑，诸全守将谢再兴叛，归顺（附）于士诚。五月，朱元璋建筑礼贤馆。陈友谅分兵攻陷吉安，参政刘齐、知府硃叔华为此而死；攻陷临江，同知赵天麟为此而死；攻陷无为州，知州董会为此而死。秋七月癸酉，朱元璋亲自率兵救援洪都（南昌）。癸未，达到（鄱阳）湖口，先在泾江口和南湖觜设下伏兵，遏制陈友谅的退路，檄令信州（江西上饶）兵守武阳渡。陈友谅听闻朱元璋来了，解了洪都的围，逆战于鄱阳湖。陈友谅兵号称有六十万，联巨舟为阵，楼橹高十余丈，绵亘数十里，旌旗戈盾，望之如山。丁亥，遇于鄱阳湖的康郎山，朱元璋分军十一队以御之。戊子，合战，徐达击其前锋，俞通海以火炮焚其舟数十，杀伤略相当。陈友谅骁将张定边直犯太祖舟，朱元璋的船在沙中搁浅，不得退，十分危急，常遇春从旁射中张定边，俞通海也（复）来援助，舟骤进，水涌进朱元璋的船里，这才得以脱身。己丑，陈友谅悉巨舰出战，诸将舟小，仰攻不利，大家都面有惧色。朱元璋亲自指挥，大家仍然不敢前进，斩退缩者十余人，人皆殊死战。到了下午三到五点（晡，申时），大风起东北，乃命敢死士操七舟，把火药放在芦苇里面，用火烧陈友谅的船。风烈火炽，烟焰涨天，湖水尽赤。陈友谅兵大乱，诸将鼓噪乘之，斩首二千余级，焚溺死者不计其数（无算），陈友谅彻底泄了气（气夺）。辛卯，复战，友谅复大败。于是陈友谅敛舟自守，不敢更战。壬辰，太祖移军扼左蠡，友谅亦退保渚矶。相持三日，其左、右二金吾将军皆降。陈友谅势益蹙，忿甚，尽杀所获将士。而太祖则悉还所俘，伤者傅以善药，且祭其亲戚诸将阵亡者。八月壬戌，友谅食尽，趋南湖觜，为南湖军所遏，遂突湖口。太祖邀之，顺流搏战，及于泾江。泾江军复遮击之，陈友谅被流箭射中而死。张定边带着（以）陈友谅的儿子陈理奔武昌。九月，朱元璋回到应天，论功行赏。先前，朱元璋想要救援安丰，不听刘基的劝阻。现在对刘基说“我不应当去安丰。使得陈友谅乘虚直捣应天，大事去矣。乃顿兵南昌，不亡何待。陈友谅死了，天下就不难平定了。”壬午，亲自征讨陈理。当月，张士诚自称吴王。冬十月壬寅，朱元璋围攻武昌，分徇湖北诸路，皆下。十二月丙申，朱元璋回到应天，常遇春留督诸军。二十四年春正月丙寅朔，李善长等率群臣权朱元璋当皇帝（劝进），朱元璋不同意。在众人坚持下，才即吴王位。建百官。任命李善长为右相国，徐达为左相国，常遇春、俞通海为平章政事，谕之曰：“立国之初，当先正纪纲。元氏暗弱，威福下移，驯至于乱，今宜鉴之。”立子标为世子。二月乙未，朱元璋再次亲自率兵征伐武昌，陈理投降了，汉、沔（湖北仙桃）、荆、岳皆下。三月乙丑，回到应天。丁卯，设置起居注（官位）。庚午，罢诸翼元帅府，置十七卫亲军指挥使司，命中书省辟文武人材。夏四月，建祠，祀死事丁普郎等于康郎山，赵德胜等于南昌。秋七月丁丑，徐达攻克卢州。戊寅，常遇春徇江西。八月戊戌，收复吉安（江西吉安），遂围赣州。达徇荆、湘诸路。九月甲申，下江陵（湖北荆州），夷陵（宜昌）、潭、归皆降。冬十二月庚寅，徐达攻克辰州（湖南怀化），遣别将下衡州。二十五年春正月己巳，徐达下宝庆（湖南邵阳），湖湘平。常遇春克赣州，熊天瑞降。遂趋南安，招谕岭南诸路，下韶州、南雄。甲申，如南昌，执大都督硃文正以归，数其罪，安置桐城。二月己丑，福建行省平章陈友定侵略处州，参军胡深击败之，遂下浦城。丙午，张士诚部将李伯升攻诸全之新城，李文忠大败之。夏四月庚寅，常遇春徇襄、汉诸路。五月乙亥，攻克安陆。己卯，下襄阳。六月壬子，朱亮祖、胡深攻建宁，战于城下，胡深被抓获（执），死之。秋七月，令从渡江士卒被创废疾者养之，赡养死者的妻儿。九月丙辰，建国子学。冬十月戊戌，下令讨张士诚。是时，张士诚占据的地方，南至绍兴，北有通、泰、高邮、淮安、濠（安徽凤阳）、泗，又北至于济宁。乃命徐达、常遇春等先规取淮东。闰月，围泰州，克之。十一月，张士诚寇宜兴，徐达击败之，遂自宜兴还攻高邮。二十六年春正月癸未，张士诚窥江阴，太祖自将救之，张士诚遁，康茂才追败之于浮子门。太祖还应天。二月，明玉珍死，子升自立。三月丙申，令中书严选举。徐达克高邮。夏四月乙卯，袭破士诚将徐义水军于淮安，徐义遁逃，梅思祖以城降。濠、徐、宿三州相继下，淮东平。甲子，如濠州省墓，置守冢二十家，赐故人汪文、刘英粟帛。置酒召父老饮，极欢，曰：“我离开家乡十多年了，艰难百战，乃得归省坟墓，与父老子弟复相见。今苦不得久留欢聚为乐。父老幸教子弟孝弟力田，不要去远的地方从上，淮河两岸的郡县尚苦于寇掠，父老善自爱。”令有司除租赋，父老乡亲们都顿首谢。辛未，徐达攻克安丰，分兵败扩廓于徐州。夏五月壬午，至自濠。庚寅，求遗书。秋八月庚戌，改筑应天城，作新宫钟山之阳。辛亥，命徐达为大将军，常遇春为副将军，帅师二十万讨张士诚。御戟门誓师曰：“城池被攻克的时候，毋杀掠，毋毁庐舍，毋发丘垄。张士诚母葬平江城外，毋侵毁。”既而召问徐达、常遇春，用兵当何先。常遇春欲直捣平江。太祖曰：“湖州张天骐、杭州潘原明为张士诚臂指，平江穷蹙，如果这两人悉力赴援，我们难以取胜。倒不如先攻湖州，使敌人疲于奔命。羽翼既披（靡），平江的势力孤单，就可以攻破矣。”甲戌，朱元璋败张天骐于湖州，张士诚亲率兵来援，复败之于皁林。九月乙未，李文忠攻杭州。冬十月壬子，遇春败士诚兵于乌镇。十一月甲申，张天骐投降。辛卯，李文忠下余杭，潘原明降，旁郡悉下。癸卯，围平江。十二月，韩林儿卒。以第二年为吴元年，建庙社宫室，祭告山川。所司进宫殿图，朱元璋命令除去雕琢奇丽者。是岁，元扩廓帖木儿与李思齐、张良弼构怨，屡相攻击，朝命不行，中原民益困。 二十七年春正月戊戌，谕中书省曰：“东南久罹兵革，民生凋敝，吾甚悯之。且太平、应天诸郡，吾渡江开创地，供亿烦劳久矣。今每家每户都很空虚（比户空虚，比：挨着），有司急催科，重困吾民，将何以堪。其赐太平田租二年，应天、镇江、宁国、广德各一年。”二月丁未，傅友德败扩廓将李二于徐州，执之。三月丁丑，始设文武科取士。夏四月，方国珍暗中（阴）遣人联系扩廓帖木儿和陈友定，移书责之。五月己亥，初置翰林院。是月，朱元璋因为干旱减膳素食，复徐、宿、濠、泗、寿、邳、东海、安东、襄阳、安陆及新附地田租三年。六月戊辰，大雨，群臣请复膳。太祖曰：“虽雨，伤禾已多，其赐民今年田租。”癸酉，命朝贺罢女乐。秋七月丙子，给府州县官之任费，赐绮帛，及其父母妻长子有区别（有差），书面写出为规章制度（著为令）。己丑，雷震宫门兽吻，赦罪囚。庚寅，遣使责令方国珍贡粮。八月癸丑，圜丘、方丘、社稷坛成。九月甲戌，太庙成。朱亮祖帅师讨方国珍。戊寅，诏曰：“先王之政，罪不及孥。自今除大逆不道，毋连坐。”辛巳，徐达克平江，执张士诚，吴地平。戊戌，遣使致书于元主，送其宗室神保大王等北还。辛丑，论平吴功，封李善长宣国公，徐达信国公，常遇春鄂国公，将士赐赉（lai，赠送）不一（有差）。朱亮祖克台州。癸卯，新宫成。冬十月甲辰，遣起居注吴琳、魏观以币求遗贤于四方。丙午，令百官礼仪尚左。改李善长左相国，徐达右相国。辛亥，祀元臣余阙于安庆，李黼于江州。壬子，置御史台。癸丑，汤和为征南将军，吴祯副之，讨国珍。甲寅，定律令。戊午，正郊社、太庙雅乐。庚申，召诸将议北征。太祖曰：“山东则王宣反侧，河南则扩廓跋扈，关陇则李思齐、张思道枭张猜忌，元皇位（zuo，祚）将亡，中原涂炭。今将北伐，拯生民于水火，何以决胜？”常遇春对曰：“以我百战之师，敌彼久逸之卒，直捣元都，破竹之势也。”太祖曰：“元建国百年，守备必固，悬军深入，馈饷不前，援兵四集，危道也。吾欲先取山东，撤彼屏蔽，移兵两河，破其籓篱，拔潼关而守之，扼其户槛。天下形胜入我掌握，然后进兵，元都势孤援绝，不战自克。鼓行而西，云中、九原、关陇可席卷也。”诸将皆曰善。甲子，徐达为征虏大将军，常遇春为副将军，帅师二十五万，由淮入河，北取中原。胡廷瑞为征南将军，何文辉为副将军，取福建。湖广行省平章杨璟、左丞周德兴、参政张彬取广西。己巳，朱亮祖克温州。十一月辛巳，汤和克庆元，方国珍遁入海。壬午，徐达克沂州，斩王宣。己丑，廖永忠为征南副将军，自海道会和讨国珍。乙未，颁《大统历》。辛丑，徐达克益都。十二月甲辰，颁律令。丁未，方国珍降，浙东平。张兴祖下东平，兗东州县相继降。己酉，徐达下济南。胡廷瑞下邵武。癸丑，李善长帅百官劝进，表三上，乃许。甲子，告于上帝。庚午，汤和、廖永忠由海道克福州。 二洪武元年春正月乙亥，祀天地于南郊，即皇帝位。定有天下之号曰明，建元洪武。追尊高祖考曰玄皇帝，庙号德祖，曾祖考曰恒皇帝，庙号懿祖；祖考曰裕皇帝，庙号熙祖，皇考曰淳皇帝，庙号仁祖，妣皆皇后。立妃马氏为皇后，世子标为皇太子。以李善长、徐达为左、右丞相，诸功臣进爵有差。丙子，颁即位诏于天下。追封皇伯考以下皆为王。辛巳，李善长、徐达等兼东宫官。甲申，遣使核浙西田赋。壬辰，胡廷瑞克建宁。庚子，邓愈为征戍将军，略南阳以北州郡。汤和克延平，执元平章陈友定，福建平。是月，天下府州县官来朝。谕曰：“天下始定，民财力俱困，要在休养安息，惟廉者能约己而利人，勉之。”二月壬寅，定郊社宗庙礼，岁必亲祀，把这作为常态。癸卯，汤和提督海运。廖永忠为征南将军，朱亮祖副之，由海道取广东。丁未，以太牢祀先师孔子于国学。戊申，祀社稷。壬子，诏衣冠如唐制。癸丑，常遇春克东昌，山东平。甲寅，杨璟克宝庆。三月辛未，诏儒臣修女诫，戒后妃毋预政。壬申，周德兴克全州。丁酉，邓愈克南阳。己亥，徐达徇汴梁，左君弼降。夏四月辛丑，蕲州进竹簟，却之，命四方毋妄献。廖永忠师至广州，元守臣何真降，广东平。丁未，祫享太庙。戊申，徐达、常遇春大破元兵于洛水北，遂围河南。梁王阿鲁温降，河南平。丁巳，杨璟克永州。甲子，幸汴梁。丙寅，冯胜克潼关，李思齐、张思道遁。五月己卯，廖永忠下梧州，浔、贵、容、郁林诸州皆降。辛卯，改汴梁路为开封府。六月庚子，徐达朝行在。甲辰，海南、海北诸道降。壬戌，杨璟、硃亮祖克靖江。秋七月戊子，廖永忠下象州，广西平。庚寅，振恤中原贫民。辛卯，将还应天，谕达等曰：“中原之民，久为群雄所苦，流离相望，故命将北征，拯民水火。元祖宗功德在人，其子孙罔恤民隐，天厌弃之。君则有罪，民复何辜。前代革命之际，肆行屠戮，违天虐民，朕实不忍。诸将克城，毋肆焚掠妄杀人，元之宗戚，咸俾保全。庶几上答天心，下慰人望，以副朕伐罪安民之意。不恭命者，罚无赦。”丙申，命冯胜留守开封。闰月丁未，至自开封。己酉，徐达会诸将兵于临清。壬子，常遇春克德州。丙寅，克通州，元帝趋上都。是月，征天下贤才为守令。免吴江、庆德、太平、宁国、滁、和被灾田租。八月己巳，以应天为南京，开封为北京。庚午，徐达入元都，封府库图籍，守宫门，禁士卒侵暴，遣将巡古北口诸隘。壬申，以京师火，四方水旱，诏中书省集议便民事。丁丑，定六部官制。御史中丞刘基致仕。己卯，赦殊死以下。将士从征者恤其家，逋逃许自首。新克州郡毋妄杀。输赋道远者，官为转运，灾荒以实闻。免镇江租税。避乱民复业者，听垦荒地，复三年。衍圣公袭封及授曲阜知县，并如前代制。有司以礼聘致贤士，学校毋事虚文。平刑，毋非时决囚。除书籍田器税，民间逋负免征。蒙古、色目人有才能者，许擢用。鳏寡孤独废疾者，存恤之。民年七十以上，一子复。他利害当兴革不在诏内者，有司具以闻。壬午，幸北京。改大都路曰北平府。征元故臣。癸未，诏徐达、常遇春取山西。甲午，放元宫人。九月癸亥，诏曰：“天下之治，天下之贤共理之。今贤士多隐岩穴，岂有司失于敦劝欤，朝廷疏于礼待欤，抑朕寡昧不足致贤，将在位者壅蔽使不上达欤？不然，贤士大夫，幼学壮行，岂甘没世而已哉。天下甫定，朕愿与诸儒讲明治道。有能辅朕济民者，有司礼遣。”乙丑，常遇春下保定，遂下真定。冬十月庚午，冯胜、汤和下怀庆，泽、潞相继下。丁丑，至自北京。戊寅，以元都平，诏天下。十一月己亥，遣使分行天下，访求贤才。庚子，始祀上帝于圜丘。癸亥，诏刘基还。十二月丁卯，徐达克太原，扩廓帖木儿走甘肃，山西平。己巳，置登闻鼓。壬辰，以书谕明升。 二年春正月乙巳，立功臣庙于鸡笼山。丁未，享太庙。庚戌，诏曰：“朕淮右布衣，因天下乱，率众渡江，保民图治，今十有五年。荷天眷祐，悉皆戡定。用是命将北征，齐鲁之民馈粮给军，不惮千里。朕轸厥劳，已免元年田租。遭旱民未苏，其更赐一年。顷者大军平燕都，下晋、冀，民被兵燹，困征敛，北平、燕南、河东、山西今年田租亦与蠲免。河南诸郡归附，久欲惠之，西北未平，师过其地，是以未逞。今晋、冀平矣，西抵潼关，北界大河，南至唐、邓、光、息，今年税粮悉除之。”又诏曰：“应天、太平、镇江、宣城、广德供亿浩穰。去岁蠲租，遇旱惠不及下。其再免诸郡及无为州今年租税。”庚申，常遇春取大同。是月，倭寇山东滨海郡县。二月丙寅朔，诏修元史。壬午，耕耤田。三月庚子，徐达至奉元，张思道遁。振陕西饥，户米三石。丙午，常遇春至凤翔，李思齐奔临洮。夏四月丙寅，遇春还师北平。己巳，诸王子受经于博士孔克仁。令功臣子弟入学。乙亥，编《祖训录》，定封建诸王之制。徐达下巩昌。丙子，赐秦、陇新附州县税粮。丁丑，冯胜至临洮，李思齐降。乙酉，徐达袭破元豫王于西宁。五月甲午朔，日有食之。丁酉，徐达下平凉、延安。张良臣以庆阳降，寻叛。癸卯，始祀地于方丘。六月己卯，常遇春克开平，元帝北走。壬午，封陈日煃为安南国王。秋七月己亥，鄂国公常遇春卒于军，诏李文忠领其众。辛亥，扩廓帖木儿遣将破原州、泾州。辛酉，冯胜击走之。丙辰，明升遣使来。八月丙寅，元兵攻大同，李文忠击败之。己巳，定内侍官制。谕吏部曰：“内臣但备使令，毋多人，古来若辈擅权，可为鉴戒。驭之之道，当使之畏法，勿令有功，有功则骄恣矣。”癸酉，《元史》成。丙子，封王颛为高丽国王。癸未，徐达克庆阳，斩张良臣，陕西平。是月，命儒臣纂礼书。九月辛丑，召徐达、汤和还，冯胜留总军事。癸卯，以临濠为中都。戊午，征南师还。冬十月壬戌，遣杨璟谕明升。甲戌，甘露降于钟山，群臣请告庙，不许。辛卯，诏天下郡县立学。是月，遣使贻元帝书。十一月乙巳，祀上帝于圜丘，以仁祖配。十二月甲戌，封阿答阿者为占城国王。甲申，振西安诸府饥，户米二石。己丑，大赉平定中原及征南将士。庚寅，扩廓帖木儿攻兰州，指挥于光死之。是年，占城、安南、高丽入贡。 三年春正月癸巳，徐达为征虏大将军，李文忠、冯胜、邓愈、汤和副之，分道北征。二月癸未，追封郭子兴滁阳王。戊子，诏求贤才可任六部者。是月，李文忠下兴和，进兵察罕脑儿，执元平章竹贞。三月庚寅，免南畿、河南、山东、北平、浙东、江西广信、饶州今年田租。夏四月乙丑，封皇子樉为秦王，晋王，棣燕王，橚吴王，桢楚王，榑齐王，梓潭王，巳赵王，檀鲁王，从孙守谦靖江王。徐达大破扩廓帖木儿于沈儿峪，尽降其众，扩廓走和林。丙戌，元帝崩于应昌，子爱猷识理达腊嗣。是月，慈利土官覃垕作乱。五月己丑，徐达取兴元。分遣邓愈招谕吐蕃。丁酉，诏守令举学识笃行之士。己亥，设科取士。甲辰，李文忠克应昌。元嗣君北走，获其子买的里八剌，降五万余人，穷追至北庆州，不及而还。丁未，诏行大射礼。戊申，祀地于方丘，以仁祖配。辛亥，徐达下兴元。邓愈克河州。丁巳，诏开国时将帅无嗣者禄其家。是月旱，斋戒，后妃亲执爨，皇太子诸王馈于斋所。六月戊午朔，素服草屦，步祷山川坛，露宿凡三日，还斋于西庑。辛酉，赉将士，省狱囚，命有司访求通经术明治道者。壬戌，大雨。壬申，李文忠捷奏至，命仕元者勿贺。谥元主曰顺帝。癸酉，买的里八剌至京师，群臣请献俘。帝曰：“武王伐殷用之乎？”省臣以唐太宗尝行之对。帝曰：“太宗是待王世充耳。若遇隋之子孙，恐不尔也。”遂不许。又以捷奏多侈辞，谓宰相曰：“元主中国百年，朕与卿等父母皆赖其生养，奈何为此浮薄之言？亟改之。”乙亥，封买的里八剌为崇礼侯。丙子，告捷于南郊。丁丑，告太庙，诏示天下。辛巳，徙苏州、松江、嘉兴、湖州、杭州民无业者田临濠，给资粮牛种，复三年。是月，倭寇山东、浙江、福建滨海州县。秋七月丙辰，明升将吴友仁寇汉中，参政傅友德击却之。中书左丞杨宪有罪诛。八月乙酉，遣使瘗中原遗骸。冬十月丙辰，诏儒士更直午门，为武臣讲经史。癸亥，周德兴为征南将军，讨覃垕，垕遁。辛巳，贻元嗣君书。十一月壬辰，北征师还。甲午，告武成于郊庙。丙申，大封功臣。进李善长韩国公，徐达魏国公，封李文忠曹国公，冯胜宋国公，邓愈卫国公，常遇春子茂郑国公，汤和等侯者二十八人。己亥，设坛亲祭战没将士。庚戌，有事于圜丘。辛亥，诏户部置户籍、户帖，岁计登耗以闻，著为令。乙卯，封中书右丞汪广洋忠勤伯，御史中丞刘基诚意伯。十二月癸亥，复贻元嗣君书，并谕和林诸部。甲子，建奉先殿。庚午，遣使祭历代帝王陵寝，并加修葺。己卯，赐勋臣田。壬午，以正月至是月，日中屡有黑子，诏廷臣言得失。是年，占城、爪哇、西洋入贡。 四年春正月丙戌，李善长罢，汪广洋为右丞相。丁亥，中山侯汤和为征西将军，江夏侯周德兴、德庆侯廖永忠副之，率舟师由瞿塘，颍川侯傅友德为征虏前将军，济宁侯顾时副之，率步骑由秦陇伐蜀。魏国公徐达练兵北平。戊子，卫国公邓愈督饷给征蜀军。庚寅，建郊庙于中都。丁未，诏设科取士，连举三年，嗣后三年一举。戊申，免山西旱灾田租。二月甲戌，幸中都。壬午，至自中都。元平章刘益以辽东降。是月，蠲太平、镇江、宁国田租。三月乙酉朔，始策试天下贡士，赐吴伯宗等进士及第、出身有差。乙巳，徙山后民万七千户屯北平。丁未，诚意伯刘基致仕。夏四月丙戌，傅友德克阶州，文、隆、绵三州相继下。五月，免江西、浙江秋粮。六月壬午，傅友德克汉州。辛卯，廖永忠克夔州。戊戌，明升将丁世贞破文州，守将硃显忠死之。癸卯，汤和至重庆，明升降。戊申，倭寇胶州。是月，徙山后民三万五千户于内地，又徙沙漠遗民三万二千户屯田北平。秋七月辛亥，徐达练兵山西。辛酉，傅友德下成都，四川平。乙丑，明升至京师，封归义侯。八月甲午，免中都、淮、扬及泰、滁、无为田租。己酉，振陕西饥。是月，高州海寇乱，通判王名善死之。九月庚戌朔，日有食之。冬十月丙申，征蜀师还。十一月丙辰，有事于圜丘。庚申，命官吏犯赃者罪勿贷。是月，免陕西、河南被灾田租。十二月，徐达还。是年，安南、浡泥、高丽、三佛齐、暹罗、日本、真腊入贡。 五年春正月癸丑，待制王祎使云南，诏谕元梁王把匝剌瓦尔密。祎至，不屈死。乙丑，徙陈理、明升于高丽。甲戌，魏国公徐达为征虏大将军，出雁门，趋和林，曹国公李文忠为左副将军，出应昌，宋国公冯胜为征西将军，取甘肃，征扩廓帖木儿。靖海侯吴祯督海运，饷辽东。卫国公邓愈为征南将军，江夏侯周德兴、江阴侯吴良副之，分道讨湖南、广西洞蛮。二月丙戌，安南陈叔明弑其主日熞自立，遣使入贡，却之。三月丁卯，都督佥事蓝玉败扩廓于土剌河。夏四月己卯，振济南、莱州饥。戊戌，始行乡饮酒礼。庚子，邓愈平散毛诸洞蛮。五月壬子，徐达及元兵战于岭北，败绩。是月，诏曰：“天下大定，礼仪风俗不可不正。诸遭乱为人奴隶者复为民。冻馁者里中富室假贷之，孤寡残疾者官养之，毋失所。乡党论齿，相见揖拜，毋违礼。婚姻毋论财。丧事称家有无，毋惑阴阳拘忌，停柩暴露。流民复业者各就丁力耕种，毋以旧田为限。僧道斋醮杂男女，恣饮食，有司严治之。闽、粤豪家毋阉人子为火者，犯者抵罪。”六月丙子，定宦官禁令。丁丑，定宫官女职之制。戊寅，冯胜克甘肃，追败元兵于瓜、沙州。癸巳，定六部职掌及岁终考绩法。壬寅，吴良平靖州蛮。甲辰，李文忠败元兵于阿鲁浑河，宣宁侯曹良臣战没。乙巳，作铁榜诫功臣。是月，振山东饥，免被灾郡县田租。秋七月丙辰，汤和及元兵战于断头山，败绩。八月丙申，吴良平五开、古州诸蛮。甲辰，元兵犯云内，同知黄理死之。九月戊午，周德兴平婪凤、安田诸蛮。冬十月丁酉，冯胜师还。是月，免应天、太平、镇江、宁国、广德田租。十一月辛酉，有事于圜丘。甲子，征南师还。壬申，纳哈出犯辽东。是月，召徐达、李文忠还。十二月甲戌，诏以农桑学校课有司。辛巳，命百官奏事启皇太子。庚子，邓愈为征西将军，征吐番。壬寅，贻元嗣君书。是年，琐里、占城、高丽、琉球、乌斯藏入贡。高丽贡使再至，谕自后三年一贡。 六年春正月甲寅，谪汪广洋为广东参政。二月乙未，谕暂罢科举，察举贤才。壬寅，命御史及按察使考察有司。三月癸卯朔，日有食之。颁《昭鉴录》，训诫诸王。戊申，太阅。壬子，徐达为征虏大将军，李文忠、冯胜、邓愈、汤和副之，备边山西、北平。甲子，指挥使于显为总兵官，备倭。夏四月己丑，令有司上山川险易图。六月壬午，盱眙献瑞麦，荐宗庙。壬辰，扩廓帖木儿遣兵攻雁门，指挥吴均击却之。是月，免北平、河间、河南、开封、延安、汾州被灾田租。秋七月壬寅，命户部稽渡江以来各省水旱灾伤分数，优恤之。壬子，胡惟庸为右丞相，八月乙亥，诏祀三皇及历代帝王。冬十月辛巳，召徐达、冯胜还。十一月壬子，扩廓帖木儿犯大同，徐达遣将击败之，达仍留镇。甲子，遣兵部尚书刘仁振真定饥。丙寅，冬至，帝不豫，改卜郊。闰月乙亥，录故功臣子孙未嗣者二百九人。壬午，有事于圜丘。庚寅，颁定《大明律》。是年，暹罗、高丽、占城、真腊、三佛齐入贡。命安南陈叔明权知国事。 七年春正月甲戌，都督佥事王简、王诚、平章李伯升屯田河南、山东、北平。靖海侯吴祯为总兵官，都督于显副之，巡海捕倭。二月丁酉朔，日有食之。戊午，修曲阜孔子庙，设孔、颜、孟三氏学。是月，平阳、太原、汾州、历城、汲县旱蝗，并免租税。夏四月己亥，都督蓝玉败元兵于白酒泉，遂拔兴和。壬寅，金吾指挥陆龄讨永、道诸州蛮，平之。五月丙子，免真定等四十二祎府州县被灾田租。辛巳，振苏州饥民三十万户。癸巳，减苏、松、嘉、湖极重田租之半。六月，陕西平凉、延安、靖宁、鄜州雨雹，山西、山东、北平、河南蝗，并蠲田租。秋七月甲子，李文忠破元兵于大宁、高州。壬申，倭寇登、莱。八月甲午朔，祀历代帝王庙。辛丑，诏军士阵殁父母妻子不能自存者，官为存养。百姓避兵离散或客死，遗老幼，并资遣还。远宦卒官，妻子不能归者，有司给舟车资送。庚申，振河间、广平、顺德、真定饥，蠲租税。九月丁丑，遣崇礼侯买的里八剌归，遗元嗣君书。冬十一月壬戌，纳哈出犯辽阳，千户吴寿击走之。辛未，有事于圜丘。十二月戊戌，召邓愈、汤和还。是年，阿难功德国、暹罗、琉球、三佛齐、乌斯藏、撒里、畏兀儿入贡。 八年春正月辛未，增祀鸡笼山功臣庙一百八人。癸酉，命有司察穷民无告者，给屋舍衣食。辛巳，邓愈、汤和等十三人屯戍北平、陕西、河南。丁亥，诏天下立社学。是月，河决开封，发民夫塞之。二月甲午，宥杂犯死罪以下及官犯私罪者，谪凤阳输作屯种赎罪。癸丑，耕耤田。召徐达、李文忠、冯胜还，傅友德等留镇北平。三月辛酉，立钞法。辛巳，罢宝源局铸钱。]]></content>
      <tags>
        <tag>历史</tag>
        <tag>文学</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[敦煌游记]]></title>
    <url>%2F2017%2F04%2F25%2F%E6%95%A6%E7%85%8C%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[三月份，我法发现去敦煌非常实惠，于是招贤纳士，最终克服重重阻碍，确定4月19日前往兰州，20日晚从兰州前往敦煌，4月21日和22日在敦煌游览两天并在23日前往嘉峪关，23日晚从嘉峪关到兰州，并于24日晚从兰州返程。 D1 兰州早上醒来法同学已经来到了我们住的太空舱旅馆（神了怎么找到的），给我们带来了兰州特色的醪糟和包子。退房后我们来到兰州站寄存行李。寄存行李是火车站最为实用的功能了，我之前都不知道，往往会浪费很多精力在背负行李上。在法同学的带领下我们打算前往参观黄河景观带。不得不说兰州的交通真是很差，大多数路是双向四车道，而且红绿灯大多数只有两个灯，因此从非机动车道左转过十字路口很难，甚至直行过马路也不容易，好几次绿灯过马路右拐车还加速的。加上兰州本身是一座挣扎在河谷中的城市，南北发展受到非常大的限制，感觉交通实在需要加强！到了兰州必须得吃牛肉面，兰州管牛肉面叫牛大，外面的兰州拉面大多数是青海人开的。临近中午我们骑到位于大众巷的一家马子禄牛肉面。马子禄牛肉面是兰州非常正宗的一块牌子，我们吃的家更为特殊，过了下午两点就不开了。进了这家店确实奇怪，没有洗手间，没有免费餐巾纸，我们吃得满嘴是油还擦不了很尴尬。店门外一位流浪汉一直在逛来逛去，后来发现他在店里领了一碗面坐到对面台阶上心满意足地吃了起来。兰州是唯一被黄河横穿的省会（济南为啥不算啊）城市。从马子禄出来走不了多远就到了黄河边上。说起黄河，不得不提《黄河钢琴协奏曲》，黄河钢协有四个乐章《黄河船夫曲》、《黄河颂》、《黄河愤》、《保卫黄河》组成，其中我最喜欢的是第二乐章《黄河颂》。《黄河颂》讲述的是我们先辈在这片土地上辛勤劳动、保家卫国、艰苦卓绝、生生不息的民族气节。乐章采用大提琴奏出引子，低沉而宏伟的旋律是黄河宛转曲折、奔流不息的浩荡。由钢琴奏出的主题铿锵有力，壮美而深情，充满着华夏儿女对脚下这片土地的热爱。接着我们来到了兰州著名的黄河铁桥。这座桥已经有一百多年的历史了，造型很像上海的外白渡桥。我们在桥首拍完照片，法同学就回去考试了，我们继续游玩桥对岸的白塔山公园。从白塔山下来我们坐的是黄河索道，这索道挺老的，每经过塔柱时都要晃一晃，然后我的心也晃一晃，跨黄河时我们看到下面的羊皮筏子，感觉挺有意思的，于是下了索道就去问价钱，一问不得了，一个人80块，那人还追着我们半天，价钱砍到60块单程才罢休。最后我们一路西进，在上游一个地方人家60块羊皮筏子去快艇回，感觉很棒，便真正体验了一下黄河船夫的生活。不过真正上了筏子可不像曲子里面那么豪迈啦。法第一个上了筏子，一脚踏在洞里面，鞋光荣地湿了。到了河心，一趟快艇驶来，心里暗道不好，果不其然，妈的下面全湿透了。羊皮筏子顺流而下把我们带到离中山桥不远的一处石矶上，没多久快艇来了。快艇相比我们在厦门的那次环鼓浪屿要逊色很多了，但是还是挺爽的。我们在码头的凉棚里面歇了会，这时候裤子也干了，但是我法的鞋子依然湿漉漉的，做为能给我法提鞋的人，我帮法晒了鞋子，大家都很羡慕。我们顺便定了敦煌第二天的跟团游。在逛完黄河母亲像后已经是四点了，我们准备骑酷骑去火车站前往敦煌，却正好碰上他们服务器宕机，整个街上没一辆车能扫码打开。试图转而骑小黄，所及之处小黄三五辆已不算少，然而要么轮胎没气，要么号码被涂，更有胜者遇到一辆内胎被拽出，脚蹬子也少了一只。当时已经是四点十分，路上已经开始堵车了，我们变得十分着急，最后还是法提出还是乘公交车吧，我们一咬牙还是同意了。路上看到甘肃省政府位于酒泉路和张掖路的交叉口，感觉很有深意，张掖称甘州，酒泉称肃州，两者合起来便是甘肃省的由来，非常有底蕴。到了车站已是五点，我们打算去吃开封菜，排队一看，妈的最便宜的汉堡套餐要48块，心想算了，正好旁边有一家德克士，一个汉堡16块钱，勉强吃得起。顺便去火车站的超市买明天的早饭，我们去敦煌的火车叫Y667，没错，Y代表游，这是一趟旅游列车，叫敦煌号。火车的过道上都是铺的地毯，卧铺的墙壁上有敦煌的景点介绍。不过设备虽然好，我们车票却定晚了，余票14的时候定的，果断一车厢全是上铺。出了兰州很快进入河西走廊，火车上播放敦煌的介绍和各种歌曲，往北看可以看到丹霞地貌。河西走廊分隔青藏高原和蒙古高原，狭窄的地方仅有几千米。这种大自然的鬼斧神工只有身临其境才能感受得到。没过一会儿，东哥说他的手机不见了，我们慌乱找了一会还是没找到，于是喊了乘警。不过其实我是不慌的，毕竟我们车厢大部分都是单位组织从上海过来的游客，他们是没道理偷一部华为手机的。过了会找到了，原来夹在作业本里，当时这位准清华学子还在疯狂学习。七点三十七分左右，在出了一段非常长的隧道后，我们第一次看到了远处的祁连雪山。祁连山又叫南山，在河西走廊的西南面。接近八点时天已经暗了下来，车厢中广播在8车的酒吧（没错居然有酒吧）有舞蹈表演。走了过去，发现居然不要买东西就能坐下，大受感动点了一瓶黑啤78块。拿到手发现这拉环咋拉不开，东哥还为此英勇负伤，最后我法又一次显示其“法力无边”，用餐巾纸把拉环按下去了，我们又一次体会到“有法可依”的重要性。灯熄了后，大家睡觉，迷迷糊糊中听到卓林在问我要餐巾纸，第二天早上起来才知道气候太干，他流鼻血了。 D2 敦煌第一次遇到火车早点，提前20分钟抵达敦煌站。六点二十我们出站，正好看到敦煌的日出。敦煌，敦者大也，煌者盛也。敦煌是汉武帝设立的河西四郡凉甘肃沙中的沙州，位于河西走廊的最西段，是中国的旱极。莫高窟位于三危山的岩壁上，据传有一个叫乐尊的和尚到敦煌，在傍晚太阳要落山时看到三危山的岩壁上光芒万丈，乐尊和尚觉得这是佛光，是佛祖在显灵，于是在三危山上开凿了第一个洞窟，在洞窟中坐禅修行。从北魏开始，统治者迷信佛教，莫高窟开始快速发展。我对莫高窟的最初了解并不是语文课本，而是来自于徐迟先生的报告文学《祁连山下》。莫高窟是神圣的，但是我觉得这神圣的从来都不是什么菩萨或是神仙，而是人。常书鸿放弃了在法国优越的生活条件和工作环境，甚至牺牲了家庭，毅然决然回国来到条件极其艰苦的敦煌，在敦煌过着他的“。无期徒刑”进入莫高窟，讲解员为我们发放了专门的耳麦，进入后我们跟随自己的讲解员参观了10个洞窟，我们仅在每个洞窟停留两分钟左右。我们分别参观了094/096/100/148/244/251/259/335/16/17窟。最后我们又跟着另一个导游看了71窟，然而人太多，我们又没有耳麦，所以最后还是放弃了。094窟在清代被翻新过，并且前面还加了一座道士的塑像，据说这和当年驻守这里的王道士有关，这个窟和下面看到的窟不太一样，它不是传统的中心塔柱形式，缺少中间的柱子，将天花板的重量分到四面墙上。讲解员说别看这里空间看起来很小，到了旺季这里容纳200人并不为过。地下的砖头据说是西夏时期的原砖头，讲解员说另有凹下去的是后期仿制的。096窟即九层楼，里面是莫高窟第一大佛像，中国第三大佛像（第一大是乐山大佛），中国第一大室内佛像。原来只有七层楼，后来为了整个盖住佛像，修了九层。据讲解员说，每年四月初八，莫高窟都会开放石窟内的围栏，敦煌的市民能够绕着柱子转一圈。为了方便行走，在这个佛的座下修了两个正方形的孔以透光。100窟是一个家族窟，属于当时驻守这里的曹家，进了甬道之后可以发现两边有很多女子的画像，前三位衣着黑色（不知道是被氧化了还是就这样）分别是回鹘国的公主和嫁到回鹘国的女儿，到了第四个女子才是家族的女主人。讲解员说到这么做是为了体现对他国的尊重，当时曹家镇守敦煌，远离京城，有能力自立为王，但是却能够镇守这里150年，并和周边搞好关系，让人十分敬佩。讲解员说莫高窟中的大多数窟都是敞开的，墙和铝合金门都是建国后后加上去的。但是这个窟在平时都设有木门封闭，曹家有专门的人看守，只有到了家中重大事情发生时才会开启。148窟里面有一座卧佛，画的是释迦摩尼圆寂时的场景。释迦摩尼身边有72位徒弟，面部表情又哭又笑，和修为深浅有关。讲解员说这些徒弟是清代加上的，是仿照孔子门下七十二仙人所作。讲解员指向我们身后的墙，我发现上面有很多乱涂乱画的内容，如“信士XXX一家XXX”的。除了这些乱涂乱画，墙上还有一些黑色的矩形方块，讲解员说这里原先写着画中人物的名字，但是由于时间太久，画中的字已经看不清了。244窟建于隋代，在左中右有三座佛雕像，分别是过去佛、现在佛和未来佛。这里的佛像已经更接近于唐朝，而不是隋朝流行的头大肚圆造型。作为装饰的飞天也由V字形逐渐变成一字形。251窟开凿于北魏时期，这个窟和我们之前见到的窟有很大的差异，首先它是中心塔柱式的，但是在窟的前部是人字顶，并且正对着窟内的佛像有一道明窗（现在已经被封了），当太阳升起时会照到佛的脸上。这里的佛像和之前看到的也不一样，衣着要朴素地多，并且穹顶上也不是各种小佛像，而是三个点和一个圈。259窟建于北魏，特点是双佛同坐，据法华经记载，多宝佛说如果有人讲法华经能比自己讲得好，就会给他一座宝塔，于是当释迦摩尼讲法华经时，地上凭空出现一座宝塔，多宝佛显圣和释迦摩尼一同讲经。塑像的手大多数都没了，露出了用来作为框架的木头。335窟是一副经变图。经变指的是将经中的内容通过画表现出来。此窟主要表现的是维摩诘和文殊菩萨辩法经变。传说维摩诘是个特别吊的神仙，他虽然是佛教中人，但是却花天酒地，纸醉金迷，简直浪翻了。偏偏此人佛法高深，别人论辩法都辩不过他，于是大家对他敬而远之。维摩诘不爽了，他想和别人辩法虐别人，于是托病在家，由于他很有声望，于是大家都得来看他。文殊菩萨来了，一眼就看出他在装病。于是指出了这点，可是维摩诘不以为然，他说不是自己病了，而是他看到天下人仍然生活不甚幸福，心中烦忧。在壁画的下面两角，中国的皇帝和番邦的皇帝都来看两人斗法。16/17窟即王道士的藏经洞。17窟其实很小，里面放着一尊真人像，后面画上是一株菩提树，树上挂着一直单肩包，很有现代风味。那位高僧就在树下打禅。据说宋代人们把这幅塑像移开，在这里面塞进了四万本经书。后来这个洞窟被风沙所埋藏，一直到王道士清理泥沙时才发现（至今墙上还有当年被风沙覆盖位置的一道道斜痕迹）。看完莫高窟，我们乘坐公交车前往敦煌市区。我们在沙洲夜市下车，准备前往位于党河边的旅社。中途我们吃了敦煌著名的驴肉黄面，驴肉黄面是拌面，口味并不突出，感觉驴肉和牛肉口感差不多。由于甘肃普遍不习惯使用支付宝和微信，我们的现金很快用完了，于是我和法去取钱，居然还要收手续费。下午一觉睡到四点出门准备前往鸣沙山，等了半天三路车放弃了，旁边的敦煌公共自行车也扫不开，最后分两辆滴滴过去。敦煌的司机特别热心，还喜欢给我们名片。鸣沙山被看做库木塔格沙漠的最东段。鸣沙山的门票十分便宜，我们的半价票只需要30块，但是里面项目一点不便宜，骑骆驼100块，带你去鸣沙山走一圈，最后到月牙泉附近下；越野摩托有三种线路，最便宜的120块，你可以自己开到山上，再由那边师傅带你下来。越野摩托附近有直升机和滑翔机体验项目，我们囊中羞涩，直接放弃了，晚上出园时我看了一下价格，乘坐滑翔机要480块，直升机1280块，还是最便宜的，真是吓人。虽然骑骆驼时间比较长，要40分钟左右，但是因为能够直接到月牙泉，我们听从东哥的建议，放弃了越野摩托，骑了骆驼。骆驼一队整好五人，但老板不肯把我们凑到一队，所以我们拆成两队，我和法一队。驼队有一个师傅在前面步行牵着沿着鸣沙山走。中途师傅向我们每人收取20元帮我们拍摄照片，他放下缰绳，教我用脚踹骆驼，让骆驼往前走，可是每次我踹骆驼总是爱理不理的，非常懒。倒是我后面法骑得骆驼像劳模一般，总想着超车。骑完骆驼我们脱掉鞋子，奔跑着去看月牙泉，从热气蒸腾的沙漠中走到月牙泉边，温度突然就变化了。滑沙费用15元，非常有意思，有点像漂流，但是速度要略快，而且中间不会有起伏。我们首先顺着竹梯爬到山腰指定地点（好难受，踩沙子踩不稳，踩竹梯又磨脚），然后那边人员将一块长方形略带有弧度的筏子背了上来，我们坐在上面，双脚分开顶住木筏前端，双手抓紧，工作人员就把你给推下去了。筏子很快加速到一个最大速度，只感觉风在耳边嗖嗖飞过，有一种喘不过气的感觉。到了接近山脚的时候，坡度渐渐变缓，筏子速度减慢并停下。我是最后一个滑的，还算成功，东哥非常悲惨，他的筏子一开始就偏离航线了，虽然试图用脚控制，但是由于失去了一开始的加速机会，很不过瘾。敦煌的日落比兰州还要晚半个小时，到八点半太阳才下山，感觉敦煌真是一个适合学习的地方，最适合我们这种晚上不睡早上不起的人。日落后，法提出大家一起去看上灯了的月牙泉，并比赛微信运动里面的步数。大家像傻逼一样在月牙泉边的栈道上原地踏步走来走去，我们发现沙漠中的温度电话非常敏感，我们在栈道上经过一个路灯都能发现那边的温度明显比这边要低。从月牙泉回来的时候，天色已黑，我们发现找不到回去的路了，遂穿沙而过。沙地上分布着骆驼屎，我们必须小心翼翼走一些被踩硬的地方才能避免沙子进鞋里面以及踩到骆驼屎。到门口发现没车了，联系之前给名片的司机，说自己不方便。最后我们在景区门口挤了一辆黑车去了敦煌夜市，司机满不情愿的收了我们的讲价，说要是被警察查到超载，自己实际上就亏了。到了敦煌夜市准备吃饭，刚走进去两步就被一群热心的民族同胞拦住了要我们吃饭，摆脱之后我们打算到别的地方。在找了一家火锅（很贵）后，我们最后去了一家川菜馆。法显得很不高兴（不能吃辣），偏偏我们点了都是辣的菜。 D3 敦煌西线在兰州时在携程上报了今天的团，早上九点半车来接我们，司机大伯开起来五六十岁的样子，等到市区晃完一圈接完客，他停车起来自我介绍，他叫老马班长，经营这条旅游线路已有十余年，这十年里他一人身兼司机、导游、“保姆”数职，自我要求要打造“航空品质”的旅游服务。事实也证明，他的团在充实度、舒适度、趣味性各方面都非常好。一路上老马班长给我们普及历史，先从莫高窟介绍起，莫高窟得名有两重意思，第一取“漠高”之意，表示在沙漠中建在高处的窟，第二重指天地间没有比佛祖更高大的形象。没过多久到了第一个景点，敦煌古城。这个景点其实挺没意思的，就是一个影视基地，什么天将雄狮神探狄仁杰啥的都在这拍过。讲解员讲解的超级不负责，直接就去念门上的对联。影视城有体验射箭的地方，10块钱10箭。这时候法又很吊了，第一箭直接八环，第二箭稍差，但也没有脱靶。我们其余的四个人就比较惨了，除了东哥还中一箭，其他人人脱靶，卓林还秒射，笑死了。到了西千佛洞老马班长与我们约定参观40分钟，因为西千佛洞的规模比较小，并且一次只能进15人，我们感觉进去的希望不大，但是我还是坚持大家去买票参观，果然最后讲解员带着我们浩浩荡荡的“15”人参观团进入窟区了，其实中间还有个小插曲，东嫂拿着票四处走动时成功把票根搞丢了，最后只好拿着小小的一张副券进门，还好讲解员没怎么阻拦。西千佛洞比莫高窟还要早，它和莫高窟的都有在原画上重画的情况，但是莫高窟会先在原画上敷上一层泥再重新画，但是西千佛洞直接重新画了，在某些窟中能够看到下层壁画的颜料。讲解员补充道对于这样的壁画是很难复原得到下面一层的壁画的。听了讲解员的讲解我才知道在莫高窟看到的西魏的天花板周围不断出现的黑色的三个点和一个圈实际上是莲花的造型，只是因为有些颜料经过长时间的氧化已经变得稀薄，唯独这三个点和一个圈仍然“健在”。讲解员用手电筒照了点和圈之间的部分，果然我们能够看到水印一样的东西，讲解员说过几年这个水印也看不到了。我们参观了8/9/11/6/7五个洞窟。6号窟和7号窟也是连在一起的，6号窟中我们看到了两块哈达，6号窟进门左手边的7号窟里面什么都没有，据说是打坐修禅用的。在某个窟中我们还看到一座尚未修完的塑像。第11窟的壁画中出现一副被称作“东方的蒙娜丽莎”的女子，讲解员用手电筒从上方和下方分别打灯，可以看到“蒙娜丽莎”会出现时隐时现的双下巴，时而像一位害羞的少女，时而像一位安静的夫人。隋朝的历史虽然短小，但是却留下了非常多的洞窟。隋代的洞窟，工匠们已经开始大胆地给塑像的人物穿上华丽的衣服了。辨别隋代的窟也很简单，其穹顶的佛有四种，沿对角线的佛都是一样的。值得一提的是西千佛洞中已经体现出伊斯兰文化的影响了，在一个洞窟中，佛身后的宝座采用的伊斯兰清真寺穹顶的造型。在莫高窟中更有道士形象出现。其实中华文明自古以来就是宽容、博采众长、兼容并蓄的，反之一个固执的、不愿意接纳外物、融入现代社会的“文明”是不可能长久的存在的。出了西千佛洞，我们继续向西，穿过一片大漠，到达南湖乡。老马班长说这是仅次于敦煌市区的第二片绿洲，也是出敦煌以后的最后一片绿洲，而前方便是罗布泊和塔克拉玛干大沙漠。要到南湖乡的路上，司机提醒我们右边即将路过西游记中猪八戒被收服的高老庄。在南湖乡老马班长组织我们吃了农家乐，每人35块，九菜一汤，其中包括新疆大盘鸡、羊肉和南湖鱼。据说南湖鱼是由祁连山上的雪水供养的，肉质非常鲜嫩可口，不过实际吃来其实一般，倒是他们的番茄汤一点汤都没有，和我们的番茄炒蛋一模一样。和我们一桌的是一群上海过来的老人，其中一个我印象特别深，不仅仅是他一直在说的上海话，而且之前在西千佛洞时他为了不误老马班长设定的时间，没有参观最后一窟，直接翻闸门跑回去了。饭桌上他说他是1949年生人，我不禁为他身手之矫捷赞叹。他们从上海坐火车两天两夜过来（据说是有个人坐不了飞机），准备接着去玩新疆。从农家乐出来走没多远就是阳关，老马班长介绍说我们现在常说的“关照”就是来源于阳关通关的关照，类似于现在的护照和签证一样，有了它就可以走出国门，（然而几天后碰巧在知乎上看到，其实关照这个词是明朝才有的，指的是“通嘉峪关口照会”。一进入阳关，便是一尊张骞铜像。阳关有专门的讲解员带领我们参观阳关博物馆，博物馆中陈列着一些青铜器铁器等文物，记录着仰观昔日的辉煌。出了博物馆再往前，经过一些仿古建筑和兵营，便到了阳关都尉府，这里卖所谓的阳关通关文牒，游客们先手写一封“敦煌阳关都尉府关照申报书”（不让你拍照带走），然后由穿着官袍的官爷为你写一个通关文牒，讲道理还是挺有纪念意义的。劝君更进一杯酒，西出阳关无故人。出了阳关都尉府后，大家都装着不认识对方。不过马上就要去阳关烽燧了，一共有三种方式，骆驼、驴车和电瓶车，其中电瓶车是不要付钱的，断选择的电瓶车。在阳关烽燧上极目远眺，一片雪山矗立眼前，便是甘肃和新疆的界山阿尔金山。在阳关往玉门关的车上，老马班长提醒我们注意看前方，只见公路左侧是一片绿洲，绿洲前面有一汪水塘，水塘上甚至还有游船的倒影，老马班长说这就是海市蜃楼，他又领着我们看向公路的尽头，那里湿漉漉的，宛若刚下过雨，还泛着光，那也是海市蜃楼。老马班长说等到七月沙漠里变热后，这种现象会更加明显。回想起在阳关时，我在阳关烽燧后的塔亭上往西远眺，能看到一片绿洲外有一汪水像极了月牙泉，当时没在意，估计那也是海市蜃楼吧。那位上海老人听到海市蜃楼，立马跑到车辆最前方副驾驶座位拍摄，感觉非常可爱。玉门关和汉长城相距不远，可能由于地处无人区，并没有像阳关那样建立了博物馆、观景台等设施。“明月出天山，苍茫云海间。长风几万里，吹度玉门关。”玉门关在古时候是商旅通行的要道，古时候这里甚至还有水源，但后来水源枯竭了，现在玉门关所在地是一片戈壁保护区，我们只能沿着划定的路线参观（跨越围栏罚款500）。玉门关又称为小方盘城，据说从前西域和田地区的人在朝见汉武帝的路途中来到这里后生了重病，问了当地人后，在这城上献上美玉，第二天果然病都好了，于是后来人路过这里都要往城墙上献上几块美玉，所以玉门关得名。参观完玉门关差不多五点半了，老马班长有点着急，我们得赶六点半到雅丹坐最后一班车。于是我们匆匆赶到汉长城。汉长城其实很是简单，感觉像是一个个沙包叠起来的，倒是那边有个老马班长说的“五星级厕所”，让我们一定得上一上。进去一看其实挺普通的，倒是有很多是卖东西的。参观完汉长城时间已经不早了，一路向西前往敦煌雅丹。在路上我们跨过了疏勒河大桥，然而桥下并没有任何水。疏勒河是中国少有的从东往西流淌的河，敦煌的母亲河党河是它的一条分支。手机很快陷入了无服务状态，老马班长告诉我们我们左手边是我国导弹的一个靶场，某次演习时甚至可以看到导弹的拦截，亮如白昼，而右手边是河西走廊北山之一的马鬃山，他将一直伴随我们直到雅丹。过了一会儿左边出现了第二尊卧佛，它是由几座山组成的，随着汽车的不断移动，卧佛的体态越来越明显。最激动的一刻莫过于看到北面的马鬃山余脉渐渐消失，最终汇入一片大漠之中，此时打开地图，发现自己身处甘肃和新疆的边界处，河西走廊走到了尽头，老马班长告诉我们罗布泊就在前方。罗布泊是一个神秘的地方，据传外星人在这里建有基地，自从上世纪科学家彭加木在这里失踪后，更有传说甚嚣尘上。敦煌雅丹位于罗布泊的风口，俗称魔鬼城，而雅丹这个名字源自维吾尔语里面的亚尔当，据说这里磁场非常强烈，人容易迷失方向，前些年一个安徽学生打算横穿雅丹时迷失方向，虽然最后拨通报警电话，但仍不幸身亡，从此景区禁止进入木牌之后的区域。一路上我们手机都在无服务状态，到了景区瞬间4G满格，朋友们纷纷想发一张在罗布泊的定位，我也打开微信，可惜上面明明白白还是酒泉市。老马班长说看完阳关是一个小土堆，看完玉门关是一个大土堆，看完雅丹是一个土堆接着一个土堆。这句话的意思是雅丹地貌是风的杰作，而在世界的很多地方都有这样的地貌，都称为雅丹。敦煌雅丹比较独特的是这里的沙漠是黑色的，但是被风侵蚀的石头却是黄色的。到了景点我们赶上了景区的最后一趟电瓶车，应该是有赚钱和是怕你下来瞎走。不过我在车上看到一个赴新疆车辆检查站，难道这条路还是可以供自驾游走的。观光车经过一个由两个石柱组成的大门，讲解员说过了这个门，就意味着进入了荒无人烟的新疆罗布泊地界，而一段艰苦的旅程就即将开始了。我们的第一个景点是金狮迎宾，下了车讲解员告诉我们不能走过景点牌子后面，所以其实我们只能简单地逛一逛拍个照就上车了。第二个绩点狮身人面也是这样。到了第三个景点孔雀回眸，随车讲解员告诉我们可以乘坐越野车去雅丹未开发的南区游玩，那里有雅丹的制高点，可以观看全景，不过吉普车太贵了，而且只能坐4个人。这个节点我们终于可以往里面走走了，我们顺着沙地上护绳围住的通道往里走，很快到了脚下。这是一块在一个浅坑中送立的巨石，犹如一只优雅傲立的孔雀。我们在最后一个景点西海舰队（舰队出海）是已是邻近落日，我们在马路上拍了很多照片，此时我心里就萌生了一个想法，好希望能够去马路的另一端，罗布泊，以至更深的新疆去探索一下啊，那里一定有更奇特的风景！观看落日，这应该是雅丹之行最美丽的风光了。敦煌雅丹的日落从八点左右开始，天空被一片红霞笼罩。西北是干燥的，西面的天空被一层薄薄的云笼罩，被染成金红一片，却丝毫阻碍不了太阳最后的光芒。从雅丹回来后，老马班长已经为我们准备了晚饭，有面包牛奶火腿肠酱蛋之类的东西，让我回想起之前打ACM现场赛的日子。最后一站，老马班长将车开到无人区，我们夜观星象。不同于我的想象，夜空中并没有出现绚烂的银河，但是星星却是十分明亮。当晚正值流星雨，西方天空有一道道流星划过，不过它们不一定都是流星，也可能是飞掠而过的人造卫星。仰望天空，七颗星星组成勺子形状，这就是北斗七星，北斗七星位于大熊座，其实非常好观测，因为七颗星星的亮度十分相似。猎户座是冬天天空最耀眼的星座，我们的时候刚从天边升上来一半，顺着猎户座，很容易找到冬季大三角，也就是参宿四、天狼星、南河三组成的等边三角形，这也是我在家中唯一能够辨认的星星。顺着大三角向上看可以看到双子座，顺着双子座所在的黄道继续往上，可以发现我的狮子座。由狮子座逆时针转九十度，在天空的中部，有一颗星非常耀眼，它就是大角星，其实我非常奇怪，毕竟天狼星是天空第一亮恒星，但是大角星明显比它亮很多，即使老马班长开始指出的火星甚至都没有天狼星亮。从大角星继续逆时针转，到星空的另一面，可以看到织女星和天津四，然而牛郎星还没有升上来（还是已经落下去了？），于是夏季大三角并没有看到。我们试图用手机拍下星空的照片，可一直是黑乎乎的一片，老马班长说得用单反+三脚架进行长时间的曝光才行，但是我们只有一个数码相机。最后机智的法将数码相机放到地上往上拍，终于拍到了清晰的照片。最后在车上，那位可爱的老人和我们合了影，他说最喜欢看我们年轻人，这让他感到特别有活力。晚上卓林又开始流鼻血，他一宿没睡，把晚上在车上看的《继父》电视剧看完了。第二天他和我们诉苦，说自己不适合在西北生活，到贵州就不会流鼻血了（真的么？）。 D4 嘉峪关早上九点我们告别敦煌，乘坐K369到达嘉峪关市。由于买的是硬座，加上昨天浪了一天，我们本来以为是艰苦的行军，没想到车上人特别的少，以至于我们一个人躺在三连排的硬座上狠狠地睡了一觉。到了站，法钦点去天下第一墩，关城由于只能买通票有点浪费，所以我们打算就在外面看看。嘉峪关的旅游氛围明显比不上敦煌了，门口的出租车都透露着一股黑车载客的样子。于是我们选择滴滴（等了好久），而东哥情侣组打了出租车，往天下第一墩进发。在车上东哥打电话说长城第一墩不出售单独票，必须买160的通票，大家很疑惑，不过也只能叫他买。到了景区发现先出发的东哥不在，而且售票处分明注明票价21元优惠票11元（原来四舍五入是这么算的），通票120元，东哥是走错了吧。打电话扯了半天，最后定位一看，东哥确实错了（估计是被司机坑了），于是东哥很绝望地又打车过来。到了嘉峪关的一路上祁连山一直在我们的身边，但是只有进了景区才真正感受到祁连山的雄姿，据说从这里去祁连山需要4个小时，爬山需要2个小时。这个景区其实说是天下第一墩，但是我们完全被一道深深的峡谷吸引住了注意力。下了观光车，可以走进一个依壁雕凿（确实是建在峡谷两侧的峭壁里面的）的地下展厅，里面主要介绍了嘉峪关地理地貌的起源，各地的长城，我看到一个外国人从嘉峪关顺着长城一直走到山海关，还有一个滑索，可惜并没有开放。地下展厅的最里面往外伸出一个玻璃地板观景平台，这张照片也是在那里拍摄的，站在玻璃板上其实还挺吓人的，不过很快我们就发现了更刺激的，也就是图上的那道悬索桥。走悬索桥要先从观景平台回到地下展厅，然后反方向走很远绕过去。我们于是往悬索桥走，路上顺便可以拍长城第一墩的照片。第一墩也有一个一个滑山的地方，居然要收30块。我们拍会车照片耽搁了一会儿，东哥已经下到峡谷了。我们从一段阶梯走下峡谷，我们的右侧是一片兵营，里面有红衣大炮，往左侧沿着路走就到了悬索桥了，如果再往前走还可以走下峡谷，不过却被拦了起来，禁止我们翻越。上了铁索桥看河谷两岸风光，可能是春季的原因吧，水量不是很充沛，但是水却是非常地清澈。走过悬索桥，东哥已经不见踪影。原来是顺着土坡爬到了前面的高地上。我们顺着坡爬上去，上面很是荒芜，到处是各种硌脚的碎石与拦路的大石块。又走了一段，我们觉得还是从悬索桥回来比较靠谱，卓林一听脸又绿了，这小子原来恐高啊。这下大家又可以整卓林了，东哥故意在铁索桥上来回跺脚，卓林铁青着脸强行装不怕，然而腿已经在抖了，于是我和东哥便不再继续搞他。出了第一墩，东哥过来的两辆车准备把我们拉到关城外面拍拍照片，到了关城，司机说有个北门可以带我们进去一道关卡，在里面可以看到关城的城墙，也就是第二道关卡。可是到了那里保安说现在太晚了，这个门已经不开了，于是我们简单地一起拍了张照片就走了，也是蛮遗憾的。我们请司机帮我们拉到了嘉峪关的老城区，这一趟下来连等带走花了一部车60块。晚上在附近的夜市里一个叫小党烧烤的地方吃了烤串，上烧烤时各种短斤少两，由于我们串串都是平分的，所以立刻被发现。餐桌上我们和法比党性，法很生气，说我们的认识是错误的，我们是坏的群众，我非常生气，实践才是检验真理的唯一标准，为什么这么说我们。吃完临走时服务员拿着纸巾盒让我也顺便带走。出了烧烤店，路过一家名叫“周六黑鸭”的烤鸭店，我们找到了一直想喝的杏皮水。昨天老马班长提到这里的杏子称为李广杏，是李广将军从中原带来栽种的，像蜜糖一样甜，当地老百姓非常感谢李广将军，便把它叫做李广杏。卖完杏皮水还没喝，肚子开始痛了，慌忙找了商城下面的一家开封菜去“蹲黄”，不仅很钦佩20分钟前烧烤店服务员的未雨绸缪，让我带走餐巾纸。坐嘉峪关的公交车到了火车站，终于可以喝杏皮水了，感觉酸酸甜甜的，有点像酸梅汤，但是香气会更浓一点。大家相继蹲完之后时间也不早了，上了公交车直抵火车站。 D5 兰州昨夜我们乘坐T6602前往兰州，这辆车比来的Y667敦煌号要难受好多，晚上先是特别热，夜里又被冻醒，下了车一个2车软卧的乘客说软卧特别冷，他已经去投诉了。到了兰州大家都特别不舒服，果断去锦江之星开了一间钟点房，六个人洗了一轮澡。差不多呆到中午了，法的同学也来了。他带我们到兰州的“王府井”去吃那里的鸭爪干锅。这家鸭爪干锅挺有意思的，首先是鸭爪和鸭翅一起做的干锅，分量还挺大的，吃完之后锅子收走还可以当成火锅继续吃，有点像我们这里龙虾的烧法。吃完鸭爪干锅，大家准备去兰州一家著名的咖啡店“放哈”咖啡店喝茶。“放哈”是兰州有名的咖啡店，原来叫“放下”，因为商标保管不力，被别人侵权了，遂改名兰州话“放哈”。我点了一杯大杯甜胚子柠檬茶11元，拿到手瞬间被它的剂量震撼了，这何止是杯，我看得叫桶了吧！从放哈出来，大家准备去水车园，我们兵分两路，我和法、法同学一起骑车过去，路上我们经过一条路名叫读者大道，猛然想起这本著名的杂志总部也就是在兰州。到了水车园，看到东哥他们早已到达（卧槽一路堵成这样还早到），东哥很是着急，书包又掉了，据他回忆，很可能是掉在之前的放哈咖啡店里面，我们打美团上的电话给店里面，回复说没有。大家都很焦急，想一起回去找店家。这时候法挺身而出说这是放心，交给我。法在法律知识和维权意识上确实非常强，我们都很信任他，于是他带着东哥和他女票去了放哈咖啡（叫我看看有啥水车的纪念品）。与此同时，法的同学也没有闲着，她在微博上发了一条寻物启事，并at了店主。没多久她兴奋地说店主回复了，确实有个包在店里面。过了一会儿我们打电话和确认。出水车园的时候发现一家纪念品店，便和法一起去，一看小水车都要两百多块，法想想还是不买了。兰州机场离市区特别远，据说是离市区最远的机场了，有C字头的高铁从兰州站过去，于是我们机智的买了高铁票过去。过安检的时候法被拦了下来，说买的啥水晶球里面有煤油，不能携带，也不能托运。可怜的法只好花了30块又寄了回去，虽然他买的水晶球才值20块。我们乘坐的ZH9584是个经停西安的飞机波音737，一路上颠得要死。我们0:40才到南京机场，那时候机场大巴只有城东线了，城东线到终点站南京站已经是两点了。东哥和他女朋友就很机智地去开房了，法也机智地订了个青旅。我本来是想带卓林回去挤我租的房子的，不过后来听法说这么晚会宿舍也不好，加上我们回去肯定要洗澡的，于是想想还是和卓林去麦当劳刷夜了。真的是困得一笔，麦当劳里面还遇到一个民科，南京本地人，喋喋不休，一个劲给我吹牛逼。说自己是啥英国硕士毕业，要移民到美国，然后自己和好几个诺贝尔奖获得者谈笑风生过。然后掏出他的英文词典和世界地图说自己在背单词啥的。后来我抓狂了，就冲卓林发了顿火。 总结去了河南，能够感受到华夏民族的源远流长；去了南京，能够感受到华夏民族的艰苦卓绝。去了河西走廊，我感受到了华夏文化的博大精深、中华民族的兼容并蓄和从古至今历代戍守苍凉的河西走廊的人民的无私奉献。与此同时，我更强烈地意识到中华民族的成长是伴随着巨大的苦难的，我们的历史就是一部我们的前辈靠着自己勤劳的双手，从苦难中挣脱，创造出无数物质财富与精神财富的血泪史。我们中国之所以能够屹立于世界民族之林，靠的是这些前辈们的无私奉献和伟大牺牲。 反观现在很多所谓的“小粉红”，以“腹黑流氓兔”为骄傲，沾沾自喜甚至觉得是一种可以大肆发扬的正能量，心里怀着的是一种将国运当儿戏心态，丝毫没有意识到上下五千年历朝历代的先贤们勤勤恳恳为国捐躯，为的是强大的国家、挺直腰杆的人民，而不是让一群从小娇生惯养的熊孩子玩过家家。又譬如很多的“公知”，以反对政府为荣，天天宣扬着“西吃草”、“国等民”的理论，是一种不负责任的表现，也是可悲的，这些人不过是那些娇生惯养的熊孩子被社会狠肏一遍之后的形态罢了。所以虽然他们看似对立，但实际在思想上如出一辙：因为不爱思考，所以热爱站队；因为不学无术，所以不明事理；因为娇生惯养，所以妄自菲薄。要成为真正的爱国者，首先必是自爱的。在充分认识了自己后才能够悦纳自己，在充分了解了国家民族的历史文化后，才能真正爱国家。在那些嘴里口口声声喊着的，都不是真正的爱国者，他们少数是坏，多数是蠢。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>敦煌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multiprocessing模块用法]]></title>
    <url>%2F2017%2F04%2F18%2Fmultiprocessing%E6%A8%A1%E5%9D%97%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[由于一些历史原因，我们常用的CPython具有全局解释器锁(GIL)机制，这把全局大锁导致Python的多线程性能非常糟糕，为了解决这个问题，一种方案是使用多进程来取代多线程。multiprocessing和multiprocessing.dummy是python下两个常用的多进程和多线程模块 常用函数multiprocessing和multiprocessing.dummy分别为多进程和多线程模块，但是两者的调用方式基本相同 进程池/线程池multiprocessing.Pool(processes = pop_size)和multiprocessing.ThreadPool(processes = pop_size)可以创建不同大小的进程池和线程池。这两个函数还可以传入initializer和initargs两个参数，用于进行初始化。默认情况下Pool会创建process数量的进程/线程，但是maxtasksperchild参数可以控制一条进程/线程最多处理的任务数，当超过这个数量时会重新启动一个新的进程/线程。 调用并取回结果以多进程为例12345678910111213141516task_size = len(tasks)ans = [None] * task_sizeresult = [] multiprocessing.freeze_support()pool = multiprocessing.Pool(processes = task_size)for (i, task) in zip(count(0), tasks): run = pool.apply_async(callee, args = (task, i)) result.append( (i, callee) )try: pool.close() pool.join() for res in result: ans[res[0]] = res[1].get()except Exception, e: print ereturn ans 其中对于多进程，multiprocessing.freeze_support()语句在windows系统上是必须的，这是因为windows的API不包含fork()等函数。apply_async表示异步调用，此时各进程在运行完毕后pool.join()回到主进程，主进程通过res.get()函数获得callee返回结果。 multiprocessing和subprocess为了提高计算效率，可以编写一段主程序，用它来启动若干个外部程序，并把总的计算任务拆分发送给这些外部程序并行计算。运行外部的可执行程序可以使用subprocess模块，主程序通过PIPE和该外部子程序进行通信，这样的通信会阻塞主程序，不能达到并行的效果。为了能够异步地对多个subprocess进行通信，可以使用multiprocessing的多进程，每条进程中调用subprocess，subprocess在进程结束后取回输出，并交回给主进程合并。这样的方法对于n个任务需要启动n个外部程序，如果外部程序的初始化成本比较大，这样的设计方案成本是划不来的，Windows系统下有不能直接fork。比较好的方法是预先初始化m个外部程序作为进程池，然后进程池中的每个外部程序依次处理[n/m]个任务，外部程序和外部程序之间是并行的。实现这种方案最好使用multiprocessing的多线程。多线程的方案和多进程的方案是类似的，由子线程负责和外部进程进行通信。这样子线程是彼此并行的，而主线程可以阻塞起来，等所有的线程计算完毕join回来即可。虽然说Python自带的GIL给多线程的带来阻碍，但是主要的计算工作主要存在于subprocess所调用的外部程序中，因此性能损失有限。并且采用多进程由于不能共享内存，因此很难将初始化好的外部程序的句柄交给相应的子进程。 初始化外部进程对于这样的多线程方案，首先通过以下语句启动proc_size个外部进程，并且注册proc_size个线程负责和各个外部进程进行交互。主线程使用join函数等待所有子线程返回结果，123456for index in xrange(proc_size): subproc = subprocess.Popen(['XXX.exe'], stdin = subprocess.PIPE, stdout = subprocess.PIPE , stderr = subprocess.PIPE, bufsize=1, close_fds='posix' in sys.builtin_module_names) t = Thread(target = initial_method, args = (index, subproc, call_back)) t.daemon = True ths.append(t) 如果Popen时需要传参数，不能将参数直接和程序名写到一个字符串里面，而是把每个参数放到单独的字符串中append到程序名所在的数组里面。Popen的stdin等参数用来重定向子程序的三个标准流，常见选项是subprocess.PIPE和None。使用None继承父进程的标准流，例如当shell = False时则所有父程序的输入会被转发给子程序，但当shell = True时会先启动一个shell再运行程序，这时候实际上是接受的shell的标准输入。使用subprocess.PIPE则和子程序之间建立管道。可以调用Popen.communicate(input)来通过管道向子进程传递信息，之后程序会阻塞在communicate上，直到从子程序传回信息。与communicate方法对应的是Popen.stdin.write()方法，这两个有一些区别。此外communicate会默认调用stdin.close()，这相当于向对方发送一个EOF。所以当需要多次向子程序写数据时，并且子程序侦测来自主程序的EOF作为结束提示时，应当使用stdin.write。在写ATP时我还遇到程序子程序无法获得stdin.write()写入的数据的情况，这是需要设置shell=True。这里的t.daemon = True表示该线程是主线程的守护线程，守护线程会在主线程退出时自动退出。对每个线程调用start方法，线程才会启动，这时候线程使用给定的args参数调用target参数传入的initial_method方法。1234for i in xrange(proc_size): ths[i].start()for i in xrange(proc_size): ths[i].join() 调用外部进程计算由于n远大于m，因此对每一个外部进程需要使用互斥锁threading.Lock()维护。将线程i按照模m分组，同剩余系的线程共享一个进程。线程取得进程资源后调用lock.acquire()为进程资源上锁，这时候如果其他线程再次调用lock.acquire()则会陷入阻塞状态，直到获得锁的线程调用lock.release()释放资源。]]></content>
      <tags>
        <tag>python</tag>
        <tag>并行计算</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[毕业实习报告]]></title>
    <url>%2F2017%2F04%2F14%2F%E6%AF%95%E4%B8%9A%E5%AE%9E%E4%B9%A0%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[为期五天的毕业实习，我们参观了位于溧水的宁溧城际铁路交通路地铁站TA08标段、苏州虎丘塔、上海青浦区金泽水库、上海石洞口无水处理厂、无锡雪浪山边坡治理工程、南京双子楼及南京眼。 Day 1今天我们前往溧水参观了某地铁站的施工，这并不是我们第一次参观地铁站，去年的实习我们曾经参观过南京地铁四号线草场门车站的施工，不过这一次我们得以近距离观察盾构机施工。南京至高淳城际轨道禄口机场至溧水段土建工程施工TA08标段共包含团山站至溧水站区间、溧水站、溧水站至中山东路站区间。其中团~溧区间位于郊区，采用明挖施工，包含明挖敞开段和明挖暗埋段。溧水站为地下两层的单柱双跨（部分为三跨）岛式站台。溧~中区间采用盾构施工，分为左右线。我们首先参观了地铁站的基坑，接着我们下到站台层，参观已浇筑的主体结构。接近中午的时候，有老师率领大家前往盾构机内部参观，不过我漏了队伍，所以没进成，据说里面特别狭窄闷热。上图是地铁站的一个出口，可以发现此处施工采用灌注桩来挡土，由于钻孔灌注桩挡水性能较差，在浇筑钻孔灌注桩放模板前，会加上止水帷幕。我们在参观时，发现靠灌注桩上有一根比较细的水管，不明白它的用途，问了工程师后了解到原来就是用来排水的、我们在地铁站旁的鱼头馆吃了午饭（并没有鱼头），饭后我们来到项目部参观，看到tacs GmbH的一个检测软件，感觉特别高端。工程师们为我们讲解了盾构机的原理。其实盾构机的刀盘和泥土仓前面我们也是进不去的，而一个螺旋运输机负责将渣土送到皮带机上，并由渣土车排出。 Day 2今天我们从南京出发前往苏州虎丘公园。虎丘在古代就是著名的景点，有“吴中第一名胜”之誉。山丘上及附近有多处古迹，其中最古的距今已有2500多年历史，宋代苏东坡曾有“到苏州不游虎丘乃憾事也”的赞誉。虎丘塔又称云岩寺塔，从公元959年开始建造，到961年建成。虎丘塔是一座仿木结构楼阁式大型砖塔，塔身为八角塔，高七层，共47.7米。与杭州雷峰塔合称为“江南二古塔”虎丘塔基岩走向南高北低，它的自重是的北部的填土层压缩产生不均匀沉降，导致塔整体向北倾斜。明代1638年进行修葺时，发现塔身向东北方向倾斜，于是在重建第七层时采取了补救措施，将第七层的重心南移。虎丘塔身结构为套筒结构，由外筒和内筒组成，加上塔砖独特的砌筑方式，塔体上下左右结合紧密，起到了互相牵制的效果。此外六个梯洞的实际是塔的重心南移，增加了塔体的安全程度二十世纪后继续整修，已经控制了倾斜的问题。我们在虎丘公园进行了简单的游玩。 Day 3上午我们参观了位于上海青浦区太浦河旁江浙沪三省市交界处的金泽水库。过往我们参观的水库往往承担调洪蓄水功能或者抽水发电的功能，但是金泽水库的主要功能是为上海西南五区（青浦、金山、松江、闵行、奉贤）金泽水库属于黄浦江上游水源地工程项目，总投资88亿元，日供水规模大351万立方米。金泽水库有乌家荡和李家荡两个天然湖泊构成，设有一个取水口和一个泵站。取水口位移太浦河北岸，从太浦河取水。取水口设有五道污染物屏障。闸门前是一条十几米的栅栏和拦油网，接着是回转式格栅清污机，经过这两个处理太浦河的水通过取水闸门，进入引水河河道，引水河两岸，各安放了15台微纳米充氧设备，起到混合增氧作用，可以促进水中的富营养物质的降解。通过引水河后，水流经李家荡库区，李家荡库区设置一道导流潜堤，进一步净化水质。我们从坝上走到位于水库中的导流堤上，注意到水面上分布种植有许多水生植物。接下来我们上车来到泵站参观，泵站是金泽水库的唯一出口，负责将水库中的水泵入管道中送给上海市区。参观完水库，汽车开了好一段，带领我们来到项目部，金泽水库所处的金泽镇是一个传统的农业镇，且被列入作为泄洪通道。在2016年的汛期，金泽水库的水位一度达到4.7m，逼近5m的最高水位。但是金泽水库本身不作为蓄洪功能，其通常水位为2.4m左右。当洪水来临时或者太浦河水质受到污染时，金泽水库会紧急关闭太浦河取水口，利用自身的储备可以支持三天左右的供水能力，这三天中可以通过控制上游水库，将污染物冲走，恢复供水能力。金泽水库贮存的水经过连通管工程输送到上海西南五区，金泽水库连通管工程起点为金泽水库输水泵站，终点与闵奉支线工程衔接，并与松浦原水厂相连，总长度约41.8公里。连通管全线采用顶管技术施工，以最大程度降低项目实施对周边环境的影响。工程采用直径4米的超大口径钢顶管，全线顶管施工，最长单段顶距长达1667米，在长距离高压原水输送领域尚属国内外首次。工程沿线穿越了多条河道和高速公路，并在列车全速运行的条件下穿越了多条铁路运输干线，施工工期紧，沉降控制要求高。 下午我们参观了位于上海东北角的宝山区石洞口污水处理厂，路途也十分遥远，一路赶来大家饥肠辘辘，虽然走到蕰川公路临近污水厂的时候空气中传来一股恶臭，但是架不住没吃中饭，好在工地给我们发了酸奶和蛋炒饭，大家一抢而空，又一人吃了一桶泡面。石洞口污水处理厂承担了北上海三个区的污水处理，其改造工程主要提升了污水处理的工艺，先前的工艺有一个缺陷是每3小时的工作周期中都有20分钟是不能正常工作的。这20分钟内出的水称为混水，混水的微生物数量是不达标的，要作废打回重新处理；此外对于“比较干净”的雨水，微生物往往不能完美地降解。因此，石洞口污水厂改造使用了新的解决方法，将这20分钟的水打入综合池AB中进行处理。现阶段的雨污混流现象也是值得重视的，旱季的石洞口污水厂一般有不到40万吨的来水，但是到了雨季，来水会变到44-48万吨左右。雨水中有机物比较少，用来分解有机物的细菌吃不饱，导致水质不达标。为了解决这个问题，设置了综合池C池。感觉这个工地是我们毕业实习参观下来比较好的一个工地，整个工地布满了摄像头，设有一个监控中心，监控中心中可以看到各个摄像头的数据。此外工地上的每个设备都有一个二维码，通过扫描二维码可以联系设备负责人、验收等工作。在项目部有一个工地安全体验处。那是一个两层的集装箱，一层展示了防护服、灭火器、安全帽等等防护设备，还提供了模拟电击、高空摔落、安全绳等体验项目。其中高空摔落非常有趣，我们爬上集装箱的二层，从两米高出往下跳，摔落在塑料球和软垫上。虽然整个过程毫无危险，但是我们也感受到了落地时的巨大冲击力，要是直接撞在水泥地上非得摔断腿不可。 Day 4今天我们离开上海，前往无锡雪浪山边坡治理工程。横山寺位于雪浪山山脚下，始建于北宋淳化年间，共占地60亩，横山寺殿宇庄严，香火鼎盛，常年“红烛高照香火旺，钟声不断佛事忙”。由于长年滥采滥开，2013年雪浪山边坡被列为地质灾害隐患点，管理工程项目于2014年12月2日正式出场施工。共三个管理分区：横山寺北坡（I区）、横山寺西南坡（II区）、香草园西坡（III区）。2015年底，横山寺西侧山体边坡前缘出现长50-60米、深10-20米、最宽处达3.5米的裂缝。雪浪山边坡是江苏省内仅次于南京牛首山的第二大边坡。由于牛首山的边坡太过陡峭，工人得挂着安全绳吊在空中打入锚杆。由于坡体在在土坡挖方后产生了滑动，因此进行了一期治理和二期治理，在一期治理过程中边缘的坡体再次被联动，这是因为滑坡方向并不是沿着最高点向下滑动，而是一个侧向滑坡，而前期地质勘测没有做到位。在打入边坡锚杆时因为都是垂直于之前认为的滑动面，因此实际上是平行于滑动面的，因此没有起到作用，严重威胁到山脚的寺庙和居民区。汽车顺着盘山公路把我们带到山顶，我们需要沿着很陡的边坡一直走到山脚下（其实挺刺激的）。边坡治理采取了逐级放坡的方法，越下层的边坡，越是滑坡面越深。每一级边坡之间都有排水沟隔断沿途的边坡采用了若干种加固的方式，例如格构梁、锚杆（8m、10m、15m，越往下越深）、植物。上层边坡的每块格构梁中间都种植了植物作为美化。同时还要做好施工期监测（水平位移、纵向位移、锚杆内部受力），但是实际上由于仪器收到较大的扰动影响，所以实际上只测了锚杆的内部受力。下图是一个锚杆检测器，使用了光纤传感器。随着逐渐往下走，土质也产生了较大的变化，我们看到一些工人在坡体上钉入木钉，用来固定铁丝网，由于铁丝网是柔性的，因此可以挂住坡体。下山后，我们进入横山寺，来到寺庙的背后，据说在那里需要安放一个卧佛。因此在此处采取了灌网分家的措施，设置很多铁丝网。山下可以看到有很多明显的地质构造。 Day 5这是实习的最后一天，我们参观了南京双子塔和南京眼。一路上的风是特别的大，也非常地冷。由于时间限制，我们只是短暂地参观了江苏大剧院和双子塔。然后我们绕路到江心洲，下车行走了一千多米，来到了南京眼下方。南京眼并不是摩天轮，而是一座连接主城和江心洲的供行人行走的桥。该桥为主跨240米的双塔双索面钢塔钢箱梁斜拉桥。]]></content>
      <tags>
        <tag>实习</tag>
        <tag>土木工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用tensorflow训练神经网络]]></title>
    <url>%2F2017%2F04%2F02%2F%E4%BD%BF%E7%94%A8tensorflow%E8%AE%AD%E7%BB%83%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[tensorflow是一个采用数据流图(data flow graph)的机器学习平台，其特征在于用点和线来表示状态和计算过程。 tensorflow配置tensorflow最方便的配置方式是在Ubuntu下直接使用pip安装wheel包。对于使用Windows的需求，可以选择Python3的版本，但是Windows下没有Python2的tensorflow版本，所以使用虚拟机或者Docker等容器或者Win10自带的Linux子系统是个可能的选择。 基本概念 Tensor 张量tf.python.framework.ops.Tensor是tensorflow的基础，表示一个多维向量，在Python中，Tensor就是numpy.ndarray类型。一个Tensor其接受若干个Tensor的输入，并产生若干个Tensor的输出。这称为一个操作op(operaton)。 tf.Tensor.op 产生这个Tensor的Operation tf.Tensor.consumers 使用这个Tensor的Operation的列表 tf.Tensor.graph 这个Tensor所属的图 tf.Tensor.name 这个Tensor的名字 tf.Tensor.get_shape()和tf.Tensor.set_shape(shape) 这个Tensor的形状，是一个TensorShape类型 Operation 操作tf.python.framework.ops.Operation是tensorflow计算流图中的一个节点。Operation可以通过调用op constructor（例如tf.matmul）或 tf.Graph.create_op()来产生，并通过tf.Session.run()或op.run()（tf.get_default_session().run(op)）来执行。 张量和操作的区别似乎是模糊的，根据Quora，可以把Operation对象当做一个void函数，例如a = tf.initialize_all_variables()返回的a是一个Operator。而Tensor对象是一个返回若干个Tensor的函数。 Graph 一张Graph由若干个Operation组成，用来描述数据流图的运算，还由若干个Tensor组成，表示在各个Operation之间传递的数据。一个op constructor 产生的Operation是属于默认Graph的，例如对于c = tf.constant(4.0)，调用assert c.graph is tf.get_default_graph()可以确认。通过with g.as_default()，可以将with作用域的默认Graph设为g。 Variable 神经网络是有多个感知机(perceptron)组成的，其中的例如W和b参数是训练的目标，随着迭代过程被优化，因此使用tf.Variable来表示它们。Variable是代表一个可修改的张量。 Session 通过定义op，定义的是计算流图的计算过程，但在未执行Session.run()前这操作并不会被执行，可以理解tensorflow中的op是“懒”的。 下面的代码相加两个tensor：op1和op2 123456789101112import tensorflow as tfimport numpy as npop1 = np.array([1, 2])op2 = np.array([3, 4])res1 = op1 + op2res2 = tf.add(op1, op2)print res1print res2with tf.Session() as sess: result = sess.run(res2) print result res1使用加法运算符，这等价于相加两个numpy.ndarray，因此立即输出[4 6]结果 res2使用tf.add方法，此时得到了一个tensorflow.python.framework.ops.Tensor类型的Tensor(&quot;Add:0&quot;, shape=(2,), dtype=int64) 之后使用Session.run()方法计算res2节点的值，得到了[4 6]的结果 根据StackOverflow上的这个回答，tf.add和+的具体使用区别是，只要两个操作数中有一个是tf.Tensor，那么tf.add和+是等价的，都是创建一个新的tf.Tensor。当需要给新创建的Tensor显式的名字的时候，一般会选择tf.add，否则重载了的+会更简便。 Session.run Session.run()的第一个参数接受一个或一组（以list表示）需要被计算的op节点，并返回这些节点之后的计算值： 对于下面的代码： 1234567891011input1 = tf.constant(3.0)input2 = tf.constant(2.0)input3 = tf.constant(5.0)intermed = tf.add(input2, input3)# tensorflow 1.0.0 release notes:# tf.mul, tf.sub and tf.neg are deprecated in favor of tf.multiply, tf.subtract and tf.negative.mul = tf.mul(input1, intermed)with tf.Session() as sess: result = sess.run([mul, intermed]) print result result返回list类型的[21, 7]，分别是mul节点和intermed计算值 由于Variable也是一个tensor，所以也需要通过Session.run()来获得它的值 特别地，session.run(tensor)也可以写成with语句中的tensor.eval()，这两个写法是等价的 placeholder和feed 在使用op建立整个网络的数据流图之后，我们希望这个模型能够接受不同的输入进行训练，所以相对于上面直接相加两个tensor的方法，可以使用placeholder和feed在Session.run()时指定输入 1234567891011import tensorflow as tfimport numpy as npop1 = tf.placeholder(tf.int64, [2])op2 = tf.placeholder(tf.int64, [2])res2 = tf.add(op1, op2)with tf.Session() as sess: i1 = np.array([1, 2]) i2 = np.array([3, 4]) result = sess.run(res2, feed_dict = &#123;op1:i1, op2:i2&#125;) print result 在上面的代码中，首先并没有op1和op2直接赋值为numpy.ndarray，而是指定了作为placeholder，在Session.run()使用feed_dict参数将op1和op2传入。 数据类型 在调用tf.matmul时常出现类型错误，需要注意tf.matmul等函数要求严格的类型，例如tf.float32并不能直接和tf.float64相乘，而应该在相乘前使用tf.cast函数进行转义。例如tf.cast(a, tf.int32)返回一个取整了的a的拷贝。 共享变量 训练神经网络常常是分批的，因此需要将初始化各权值和使用给定训练集训练这两个操作分成两个函数，调用一次初始化各权值操作，然后将训练集分成若干批，对每批数据进行训练。显然这两个函数之间需要共享权值这个tf.Variable变量，相对于使用Python提供的global，tensorflow提供了tf.variable_scope()和tf.get_variable()来实现这一点。 get_variable用来引用一个带名字的变量（如果不存在，则创建该变量）： tf.get_variable(&lt;name&gt;, &lt;shape&gt;, &lt;initializer&gt;): 其中initializer指定初始化方式，可以选择： tf.constant_initializer、tf.random_uniform_initializer、tf.random_normal_initializer等，对应着random_uniform(a, b)、Constant(value)、truncated_normal(mean, stddev) variable_scope指定命名空间： tf.variable_scope(&lt;scope_name&gt;) 这个语句常和with搭配使用，这样在该with作用域内的所有get_variable是针对这个variable_scope而言的了。这很类似于C++中的namespace的概念。 使用神经网络进行拟合训练样本分批tensorflow在优化目标函数的时候常使用SGD梯度下降的方法SGD分为三种方法：batch gradient descent方法一次更新使用全部样本，具有比较慢的收敛速度stochastic gradient descent方法一次更新使用1个样本，梯度下降波动太过随机综合考虑选择mini-batch gradient descent方法，一次更新比较小的batch 选择传输函数 sigmoid、tanhsigmoid和tanh更适合解决分类问题，且其值域是[0, 1]，容易产生saturation的情况，当函数的输入绝对值比较大的时候函数输出无限接近于1。此外sigmoid恒为正，所以常使用sigmoid(x) - 0.5或tanh(x) = 2*sigmoid(2x) - 1比较好的方法是根据具体数据规模在里面除个东西或开个根号来控制数据范围，或者可以选择归一化（如softmax）输入 purelinpurelin作为一个值域正负无穷的函数，也不适合作为激活函数，对于一般的数据，如果学习速率比较大很容易算到inf relurelu是没有负值的purelin，定义为max(0, x)，同样不能使用过大的学习速率，否则容易让神经元die，也就是权值变成0 softmax当问题是多个不相交的多类分类的问题时，使用一个softmax分类器比若干个logistic分类器要好 选择损失函数常用的损失函数有均方误差、交叉熵和log-likelihood等 选择Optimizer在之前一直使用的是SGD梯度下降(mini-batch gradient descent)的方法tf.train.GradientDescentOptimizer，这个方法是固定学习速率的，而且容易收敛到局部最优点或者鞍点如果需要自适应的学习速率或者使用动量等方法可以使用其他的Optimizer。所有的Optimizer继承自tf.train.Optimizer特别地，如果不要求在运行时可变学习速率，可以将learning rate作为一个placeholder保存，并feed给session.run() 可视化可以将训练的过程写成summary到文件，并使用tensorboard --logdir=&lt;path&gt;来可视化，得到的结果在http://localhost:6006显示主要步骤是先注册要记录的对象1234567with graph.as_default(): for value in [scalars]: tf.summary.scalar(value.op.name, value) for value in [tensors]: tf.summary.tensor_summary(value.op.name, value) summaries = tf.summary.merge_all() 注意到可能会发生叫”tags and values not the same shape”这个错误。这是因为试图summary一个张量，对于一个标量，例如loss函数的值，应当使用tf.summary.scalar(value.op.name, value)，但是对于一个权值矩阵，应当使用tf.summary.tensor_summary(value.op.name, value)tf.summary.scalar接受第一个参数表示在TensorBoard中显示的名字；第二个参数是一个仅有一个数字的Tensor在训练时12345with tf.Session(graph=graph) as session: summary_writer = tf.summary.FileWriter('log_simple_stats', session.graph) computed_summaries = session.run([summaries]) for step in xrange(num_steps): summary_writer.add_summary(computed_summaries, step) FileWriterFileWriter可以创建一个event文件，并且把summary和event添加进去。FileWriter具有下面的方法： add_summary(summary, global_step=None) add_session_log(session_log, global_step=None) add_event(event) add_graph(graph, global_step=None, graph_def=None) 模型保存可以使用tf.train.Saver保存模型123456with tf.Session(graph=graph) as session: saver = tf.train.Saver() # 从已保存的模型中恢复 saver.restore(session, "save/ada.ckpt") # 保存到指定模型 saver.save(session, "save/ada.ckpt") No variables to save错误出现这个错误是因为saver = tf.train.Saver()出现在with块外部了]]></content>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coq学习笔记]]></title>
    <url>%2F2017%2F03%2F12%2Fcoq%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[因为没找到比较好的Coq中文学习资料，所以主要根据官方doc和tutorial-nahas等国外的教程来学习 预备知识 形式证明 首先了解形式证明(formal proof)，可以通过下面的链接进行了解 http://en.wikipedia.org/wiki/Intuitionistic_logic http://en.wikipedia.org/wiki/Curry-Howard_correspondence http://en.wikipedia.org/wiki/BHK_interpretation 注释 使用(* COMMENTS HERE *)进行注释 分隔符 每个Coq命令都要加上.表示结束 IDECoq有自带的CoqIDE，另有命令行程序coqtop和Emacs扩展Proof General hello worldmy_first_proofCoq应该是少数的不能输出Hello, World的编程语言之一了。而对应于HelloWorld的是一个简单的命题 for all things you could prove, if you have a proof of it, then you have a proof of it. 它的证明是这样的 Theorem my_first_proof : (forall A : Prop, A -&gt; A). Proof. intros A. intros proof_of_A. exact proof_of_A. Qed. 首先通过Theorem（还可以使用Lemma(引理)、Remark、Fact、 Corollary(推论)和Proposition(命题)，它们的含义是相同的）来声明一个定理my_first_proof：(forall A : Prop, A -&gt; A)下面的Proof表示证明开始，Qed（还有Admitted、Defined它们的含义是不同的）表示证明结束。 vernacular、tactics和GallinaCoq中有三套不同的语言： vernacular 用来处理定义，使用大写字母开头，例如Theorem、Proof、Qed tactics 用作证明过程，以小写字母开头，例如intros、exact Gallina 用来描述定理，例如(forall A : Prop, A -&gt; A) 查看证明过程Coq是可以查看证明的中间过程的，在菜单栏或者工具栏选择GoTo Cursor即可。现在将运行到intros proof_of_A这行上，可以发现右上角输出如下 1 subgoal A : Prop proof_of_A : A ______________________________________(1/1) A 在水平线上的称为假设(hypotheses)或上下文(the context)，在水平线下的是要证明的东西，称为the current subgoal我们要证明的定理(theorem)称为goal，而subgoal指的是我们在证明过程的任意一点需要证明的东西 tactic首先回到开始状态 1 subgoal ______________________________________(1/1) forall A : Prop, A -&gt; A 可以看到目前context啥都没有，goal是要证明的theorem。这里的A : Prop表示一个具有Prop类型的A。类似的有0 : nat表示一个自然数0，true : bool表示一个布尔值true。-&gt;是for all的缩写，A -&gt; A表示(forall something_of_type_A : A, A)。证明开始，首先遇到第一个tacticintros，intros等于assume，作为我们的假设。于是现在假设有一个任意的假设A，它在可能情况下要和subgoal中的变量同名 1 subgoal A : Prop ______________________________________(1/1) A -&gt; A 在运行完intros A.后，subgoal变成了A -&gt; A，在context中我们有了一个Prop类型的A下面运行第2个intros]]></content>
      <tags>
        <tag>coq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用deap实现遗传算法]]></title>
    <url>%2F2017%2F03%2F02%2F%E4%BD%BF%E7%94%A8deap%E5%AE%9E%E7%8E%B0%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近在做毕业论文，其中涉及到一项是检验某个为有限元程序优化参数的遗传算法的正确性。deap是Python上的一个遗传算法库，主要封装了和遗传算法相关的生成population、select、mutant这些相关的操作。比较方便的是deap框架允许自定义个体类型、种群生成方法、评价函数等，所以灵活性比较高 任务简述可以把有限元程序想象成一个有六个参数的黑箱函数f(X | args)，现在对于数据X计算得结果Y = f(X | args)和实际值T有偏差，现在希望通过参数优化（参数值必须在一定范围内）使得计算值尽可能接近实际值。不考虑泛化能力等问题， deap框架前期工作安装deap，pip install一如既往地失败了，幸亏还可以通过setup.py安装。 creator和register这两个模块起到语法糖的作用 creator基于给定的类创建一个派生类，生成的类通过creator.ClassName访问 不同于creator，register创建为一个函数创建别名，并且可以绑定其中的一些参数，生成的函数通过tools.func_name访问1toolbox.register("select", tools.selTournament, tournsize=3) 表示注册一个tools.select作为tools.selTournament的别名，并绑定tools.selTournament的参数tournsize为3 评价函数定义评价值类我们希望用一个scalar或者一组scalar来量化对个体的评价，它的值由评价函数tools.evaluate计算得到。在使用deap时，评价值应当继承自base.Fitness，这个类包含一个values字段，它是一个tuple，实际上是评价值。下面创建一个评价值类1creator.create("FitnessMin", base.Fitness, weights=(-1.0,)) 这里的weights表示每个scalar的权重，当weights=(-1.0,)时说明评价值是一个scalar，并且值越小，评价越高。所以我们看到不直接使用元组，而选择继承封装元组的的Fitness类是为了更方便地比较评价值 评价函数使用均方误差作为评价函数。整个评价函数的实现流程应当是： 使用当前参数值调用有限元程序（fortran77） 获得有限元程序中返回结果 计算均方误差由于整个源程序是5000+行的比较乱的fortran77代码，还要外部link一个obj文件，所以无论是强行转换到C++还是在上面继续实现都比较麻烦，所以使用Python通过管道来调用fortran77程序中的有限元函数，并获得返回结果。 定义初始化个体一个个体应该包含若干数量的基因，也就是我们要优化的参数，通常可以用一个list来存储，类似于Fitness类的方法，我们不直接使用这个list，而是通过creator来创建一个继承自list的类 creator.create(“Individual”, list, fitness=creator.FitnessMin)这个类包含有fitness字段，也就是它的评价值下面我们使用这个类生成若干个体，这可以分解为两步： individual函数为某个个体的基因提供随机的初始值 可以使用tools.initIterate函数，这个函数在/tools/init.py中定义如下 12def initIterate(container, generator): return container(generator()) 其中container就是你定义个体的类Individual generator是一个生成器来提供初始值。假设一个个体有6个基因，可以参照以下代码 123def f(): for gene_index in xrange(6): yield random_value_for_gene_index population通过调用若干次individual函数生成种群 方便起见可以使用/tools/init.py钟提供的另一个tools.initRepeat函数： 12def initRepeat(container, func, n): return container(func() for _ in xrange(n)) 这个函数将func执行n次 运行遗传算法在deap的文档中，可以下载到deap_onemax的源码这份代码使用了定义的四个函数，分别是evaluate、mate、mutant、select，分别对应计算评价值、交配、突变、选择等四个原子操作下面给出的是遗传算法的主程序，在修改时需要注意其中的突变函数toolbox.mutate(mutant)，如果不希望突变，应该把这里注释掉，否则应该手动实现一个自己的突变函数，否则容易随机出无效值。特别地，在deap_onemax的源码中，这个函数时是直接01取反，所以新的程序中出现除0错误很可能是这个原因。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354pop = toolbox.population(n=20)CXPB, MUTPB, NGEN = 0.5, 0.2, 4# Evaluate the entire population# fitnesses = list(map(toolbox.evaluate, pop))fitnesses = []for (i, ind) in zip(count(0), pop): mse = toolbox.evaluate(ind) fitnesses.append(mse)for ind, fit in zip(pop, fitnesses): ind.fitness.values = fit # print(" Evaluated %i individuals" % len(pop))print "Start GA Loop" for g in range(NGEN): print("-- Generation %i --" % g) offspring = toolbox.select(pop, len(pop)) offspring = list(map(toolbox.clone, offspring)) # offspring是个体组成的`list` for child1, child2 in zip(offspring[::2], offspring[1::2]): if random.random() &lt; CXPB: toolbox.mate(child1, child2) del child1.fitness.values del child2.fitness.values for mutant in offspring: if random.random() &lt; MUTPB: toolbox.mutate(mutant) del mutant.fitness.values invalid_ind = [ind for ind in offspring if not ind.fitness.valid] fitnesses = map(toolbox.evaluate, invalid_ind) for ind, fit in zip(invalid_ind, fitnesses): ind.fitness.values = fit # print(" Evaluated %i individuals" % len(invalid_ind)) pop[:] = offspring fits = [ind.fitness.values[0] for ind in pop] length = len(pop) mean = sum(fits) / length sum2 = sum(x*x for x in fits) std = abs(sum2 / length - mean**2)**0.5 print(" Min %s" % min(fits)) print(" Max %s" % max(fits)) print(" Avg %s" % mean) print(" Std %s" % std) best_ind = tools.selBest(pop, 1)[0]best_ind = tools.selBest(pop, 1)[0]print("Best individual is %s, %s" % (best_ind, best_ind.fitness.values))return best_ind]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell学习笔记]]></title>
    <url>%2F2017%2F02%2F28%2Fhaskell%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Channel 9上有个非常好的介绍Haskell和函数式编程的视频，这个视频是根据Programming in Haskell这本书讲述的。Slides和Codes可以在http://www.cs.nott.ac.uk/~pszgmh/上下载，不过后面几章会和实际的课程内容有出入。此外Learn You a Haskell上的教程，以及Wikipedia上有关Haskell的词条也是非常有用的。相对于其他的一些Haskell的教程，通过这本书/视频进行学习能够了解Haskell的好处以及设计原理 Ch0先吐槽一下教授的口音。。。 配置Haskell环境使用sublime text 2，可能会出现一些问题 Decode error - output not utf-8 在Haskell.sublime-build里面把encoding改为cp936（也就是GBK）即可 Not in scope: main Perhaps you meant min (imported from Prelude) 这是因为编译命令行默认调用runhaskell，它会自动调用main程序，所以把命令行改为ghci即可现在可以愉快地写Haskell啦 end of file &lt;stdin&gt;: hGetLine: end of file 这是Haskell的一个bug，参考StackOverflow上这篇回答 Ch1 IntroductionHaskell大法好！函数式大法好！ 现代软件危机： 如何处理现代程序大小和复杂度问题 如何减少程序开发的时间和代价 如何提高程序可靠性 解决方案： 更清楚、简明、高度抽象的代码 可重用的组件 形式证明(formal verification)的使用 rapid prototyping 函数式编程(functional language) 是一种把函数应用到参数(application of function to arguments)作为基本运算的编程风格 Alonzo Church：lambda演算 John McCarthy：Lisp John Backus：FP，high-order functions and reasoning about program，类似于Linq Robin Milner：ML，type inference and polymorphic types Peter Landin：ISWIM，没有赋值的纯函数式编程语言 David Turner：lazy evaluation SKI组合子演算(Haskell Curry等人提出) 一个非原地的快速排序，类似于Linq(where语句)或派通(Python，神奇的口音)一行版本的写法。 Ch2 First Steps首先是讲了一堆Prelude大法好 列表处理在Ch4中会看到部分函数，例如head、tail是如何实现的 获取列表片段 返回移除列表首元素的新列表，类似car 12&gt; head [1,2,3,4,5]1 返回移除列表首元素的新列表，类似cdr 12&gt; tail [1,2,3,4,5][2,3,4,5] 返回移除列表前n个元素的新列表 12&gt; drop 3 [1,2,3,4,5][4,5] 返回前n个元素组成的新列表 12&gt; take 3 [1,2,3,4,5][1,2,3] 返回列表第n个元素 12&gt; [1,2,3,4,5] !! 23 连接两个列表 12&gt; [1,2] ++ [3,4][1,2,3,4] 列表属性 获得列表长度 12&gt; length [1,2,3,4,5]5 获得列表和/积 12&gt; sum/product [1,2,3,4,5]15/120 翻转列表 12&gt; reverse [1,2,3,4,5][5,4,3,2,1] 生成列表 注意生成的是中括号区间 12&gt; [1..5][1,2,3,4,5] 而 1&gt; [1..] 生成一个无尽的列表，类似python中的生成器count，不同于python，Haskell的实现是因为它是lazy evaluation的 判断元素属于列表 12&gt; 1 `elem` [1..5]True 三种编程语言的比较 C#(OOP) [1,2,3].drop(3) receiver.method(arguments) 这里receiver和arguments不是等价的参数，一切围绕receiver对象为基础 Haskell drop 3 [1,2,3] method receiver arguments 这里receiver和arguments是等价的参数，可以更方便地match每个参数的特定值 F# [1,2,3] -&gt; drop 3 函数调用 使用空格而不是括号+逗号来分离函数名以及参数 函数调用比其他运算符，如+具有更高的优先级（毕竟你连括号都没有），因此比较好的书写习惯是，如果都是函数调用，需要把内层参数括起来Mathematics : f(g(x)) Haskell : f (g x) Mathematics : f(x, g(y)) Haskell : f x (g y) Mathematics : f(x + 1, y - 1) Haskell : f (x + 1) (y - 1) 这样写有最少的语法噪音 $运算符 $运算符实际上表示“应用”的意思。常常可以用来改变运算顺序，从而省略括号，它可以看做id函数对函数的特化 id :: a -&gt; a id x = x ($) :: (a -&gt; b) -&gt; a -&gt; b -- -&gt;是右结合的 ($) :: (a -&gt; b) -&gt; (a -&gt; b) ($) = id f $ g x，即($) f (g x)，等价于f (g x) 如果不加上$，那么g和x都会被当成一个二元f的两个参数，可以参照下面的例子理解： Prelude&gt; (+) 1 (+2) 1 error Prelude&gt; (+) 1 $ (+2) 1 4 type class这里的a称为类型参数，注意这里面的类型参数是静态的而不是动态的，编译器/解释器会自动进行类型推导a是什么的。如对于double函数 double :: Num a =&gt; a -&gt; a 这里出现在=&gt;符号前的Num a作用是给类型参数a加上类型约束，称为类型类，或type class、type/class constraint、context(?)。当有多个类型约束时，用小括号括起所有的类型约束。虽然type class和type都是大写字母开头的，但两者是不一样的，type class通过class等语句定义，type根据type、data等语句定义。type class类似于C#中的接口interface，在功能上也有点类似于C++中的concept123T quadruple&lt;T&gt; (T x) where T:INumeric&lt;T&gt;&#123; return double(double(x));&#125; 类型类通常通过class语句来定义，下面是一个最简单的示例 class BasicEq a where isEqual :: a -&gt; a -&gt; Bool isNotEqual :: a -&gt; a -&gt; Bool 有关类型类的更多细节会在Ch10探讨。 instance然后我们可以用instance语句来创造这个类型类的实例类型(instance type)，也就是a。首先我们需要区分几个类似的用法：第一个是上面见到的函数定义中的Num a，这是type constraint，说明函数中的类型变量a应当满足给出的type class。第二个是马上要见到的foldr中的t a，这是由一个type constructor产生的concrete type（简称type）。下面的语句定义了一个Bool的类型，它实现了BasicEq的constraint或者说type class。 instance BasicEq Bool where isEqual True True = True isEqual False False = True isEqual _ _ = False isNotEqual True True = False isNotEqual False False = False isNotEqual _ _ = True 不过我们发现同时定义两个明显互补的函数是浪费而不美观的。Haskell中允许我们通过定义默认实现的方式来避免这个 class BasicEq a where isEqual :: a -&gt; a -&gt; Bool isEqual x y = not (isNotEqual x y) isNotEqual :: a -&gt; a -&gt; Bool isNotEqual x y = not (isEqual x y) composition我们可以通过double来定义一个四倍函数 quadruple x = double (double x) double x = x + x 更Haskell一点的方法，使用composition(fusion, pipe to) quadruple = double . double (f . g) x = f (g x) 这里的.类似于数学里面的复合函数，可以写出它的签名 &gt; :t (.) (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c 例如 length = sum . map (\_ -&gt; 1) 由于Haskell是lazy的，所以看到map时，并不立即计算map .运算符和$运算符的比较.运算符的作用是 (f . g) x :: f (g x) $运算符的作用是 f $ g x :: f (g x) 看起来他们具有相同的作用，但实际上两者具有差别。.的作用实际上是生成一个新的函数，比如f . g是合法的，但是f $ g就不合法了。$的作用实际上是消除一些括号，于是haskell不会像lisp一样骚。 将函数作为操作符123factorial n = product [1..n]average ns = sum ns `div` length nsmain = print (average [1,2,3,4,5]) 这里的div实际上是一个函数，加上`后变成了一个运算符，这称为gave accent或backquote，有点类似于fortran中的.op.运算符。相反地，可以在运算符两边加上小括号(op)将其作为柯里函数使用，称为prefix notation或者operator section，这将在后面讲到 :reloadHaskell使用:reload命令通知GHC重新加载hs文件 命名规则 Haskell的函数或者参数名字必须以小写字母开头 类型名必须以大写字母开头 通常列表以s结尾 layout rule 为了省略大括号，Haskell并列语句不能随意缩进（对的游标卡尺），并且缩进只能用空格，而不能够用tab a = b + c where b = 1 c = 2 d = a * 2 的大括号(explicit grouping)形式是 a = b + c where {b = 1; c = 2} d = a * 2 再次说明Haskell消除了不必要的冗余语法 对Haskell缩进规则的补充 如果写过Python，一定知道冒号后面要缩进，tab缩进和空格缩进是不同的，并且每个缩进的长度一定是与层级有关的，但是Haskell并不是。 主要原因是Haskell不强制在“冒号”后面换行。例如在do语句中，如果按照Python的语言习惯，do后面就该直接换行了。但是Haskell可以将do结构里面的第一个语句写到do的同一行，这时候下一行的语句应当和第一个语句是并排的，例如 putStrLn&apos; xs = do putStr xs putChar &apos;\n&apos; 注意putStr的p和putChar的p是并排的，又比如 f x = case x of 0 -&gt; 18 1 -&gt; 15 这里面的0和1也是要对齐的 但是如果我们偏偏在关键字处换行呢？那至少要缩进一个空格，例如 putStrLn&apos; xs = do putStr xs putChar &apos;\n&apos; 和 f x = case x of 0 -&gt; 18 1 -&gt; 15 Ch3 Types and Classes表达式的类型如果一个表达式e的计算得到类型是t的结果，那么称为e具有类型(has type)t，写作 e :: t 由于Haskell是静态类型的(static typed)，所以编译器能够通过类型推导(type inference)得到所有表达式的类型 :t或:type使用:t或:type可以获得参数的类型 Haskell的基本类型Bool | 布尔 Char | 字符，字符直接量用单引号括起 String | 字符串，字符串直接量用单引号括起，也可以看做Char的List Int | 固定精度整数 Integer | 任意精度整数 Float | 浮点数 [t] | 类型t的列表 (t1, ..., tn) | 元组 特别地，使用中括号括起数据生成列表时，中括号起到data constructor作用，括起类型生成列表类型时，中括号起到type constructor作用 函数的类型函数也就是映射，Haskell中使用t1 -&gt; t2表示函数将t1类型映射到t2类型我们可以用type form去“声明”函数，这就是先前看到的e :: t这样的语法。我们也可以使用value form直接来“定义”函数，我们还可以使用lambda表达式来定义一个函数，做法是在最前面加一个反斜杠，\x -&gt; y。特别地，lambda表达式也可以拥有多个参数，可以写成\x y -&gt; x + y由此看出，由于Haskell的类型推导机制，函数的type form在具备value form是并不是强制的（但并不总是可以省略），这和C++等强制性声明函数类型(function type)是不一样的。当然在C++模板编程中可以推导部分参数的类型/返回值，但在编译器层面，每个重载/特化版本的函数签名也是确定的。在实际书写Haskell程序时，先写一遍type form来限定来限定参数的类型、规定函数的签名写出来是一个非常好的习惯，这被称为类型驱动开发（Type Driven Development）。 unit()称为unit，类似于void，会在monad中用到 柯里化对于一个多元函数，例如div，设想它的类型是这样的 add :: (Int, Int) -&gt; Int add = \(x, y) -&gt; x + y 但实际上它的类型是这样的 &gt; :t div div :: Integral a =&gt; a -&gt; a -&gt; a 事实上这是因为add x y实际上接受一个参数a，并返回一个一元函数（闭包），这个函数的类型是a -&gt; a。这个一元函数的作用是将自己的参数b和add的参数a相加，这样的函数称为柯里函数因此实际上div的类型是 div :: Integral a =&gt; a -&gt; (a -&gt; a) 注意到Haskell中的-&gt;符号是右结合的，因为柯里化是从左边开始的，所以可以省略括号写成a -&gt; a -&gt; a使用lambda可以写为 add = \x -&gt; (\y -&gt; x + y) add x = \y -&gt; x + y 多态函数typeclassHaskell中的函数默认可以接受任意类型的参数，但有时需要限定类型，例如sum函数，去接受一个Bool类型是没有意义的，所以使用sum :: (Num a) =&gt; [a] -&gt; a来为a提供类型约束，称之为type class，类似于C#中接口(interface)，这在Ch2.5自定义函数一节中已经提到过。不过相比interface，我们看到typeclass中可以定义具有ad-hoc多态类型的值的，不过我们也注意到其实Haskell中的值也可以看成一种特殊的函数：123class TypeClassWithValue t where plainValue :: t functionValue :: t -&gt; t 此外typeclass中定义的函数也是可以具有所谓的类型多态（见最后的专题讨论）的，例如典型的Monad12class Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 这里的Monad是一个typeclass，m将来是用instance产生的实例类型，也是一个type constructor，而m a则是由type constructor产生的具体类型(concrete type)。具体可查看instance与type的相关章节常用的type classes有 Eq：表示能判断相等的类型 Num：表示数字，不继承Ord。Num没有(/) Real：实数，继承了Ord Integeral：整型 Ord：表示能比较大小的类型 特别注意，Ordering是一个类型，包含GT、LT、EQ三个constructor Show：可以被转成字符串的类型，Haskell中除了函数都能被表示成字符串 Read：可以从字符串被读取的类型 Enum：能被枚举的类型 Bounded：有界的类型 Fractional：具有除法的数字类型类(/) Floating：浮点 Existential Quantification作为拓展，必须介绍Existential Quantification这个Haskell类型系统中的重要概念，Haskell借助于此实现类似OOP中的多态。 Ch4 Defining FunctionsifHaskell中的if语句和其他语言的并无二致 if cond then exp1 else exp2 但是else分支是必须的，毕竟是强类型语言 guarded equations这个名字还挺熟悉的，原来是在《程序设计语言原理？这本书上看到过，当时翻译成守卫。这里的guard指的是|符号，注意|在list comprehension另有用途。guarded equations是Haskell比较独特的一种表示条件分支的办法，有点类似于数学公式里面的条件，或者说其他语言中的select case的用法 abs n | n &gt;= 0 = n | otherwise = -n 偏函数应用与部分函数不同于Scala，Haskell中的部分函数，相对于全函数(total function)是不被鼓励的。一个部分函数类似于div、(!!)，它并不是对于指定类型的所有值都有定义。以head为例，它的参数是所有的列表，可是对于一个空列表应用head会抛出一个异常。 Prelude&gt; head [] *** Exception: Prelude.head: empty list 在Haskell中，偏函数应用(partial application)和部分函数(partial function)是两个不同的概念。偏应用在随后会有介绍。 where语句这里补充一下where，这是一个类似占位符placeholder的语句，让我们的代码更漂亮一点，同时能够在guard、do这样的结构中复用一些结果。 f x | cond1 x = a | cond2 x = g a | otherwise = f (h x a) where a = w x 可以看出来where的缩进应当与其所在的结构下属的语句相同，而不是与所在的结构平齐。并且where作为一个结构，其下属语句也需要缩进。where也可以通过模式匹配来定义函数 fib = (map fib&apos; [0 ..] !!) where fib&apos; 0 = 0 fib&apos; 1 = 1 fib&apos; n = fib (n - 1) + fib (n - 2) 此外go惯用法里面也常用到where where的作用域根据stackoverflow上的这篇回答对于下面的这个式子 someFunc x y | guard1 = blah1 | guard2 = blah2 where {assignments} {assignments}域中只能够访问x和y，但guard1、guard2、blah1、blah2都能访问{assignments}。 where存在的问题一个不恰当的where语句会导致性能的降低，比较一下下面的两段代码12345678910111213-- 1fib = (map fib' [0 ..] !!) where fib' 0 = 0 fib' 1 = 1 fib' n = fib (n - 1) + fib (n - 2)-- 2fib x = map fib' [0 ..] !! x where fib' 0 = 0 fib' 1 = 1 fib' n = fib (n - 1) + fib (n - 2) 这两种写法互为eta-conversion(η-conversion)。eta-conversion是lambda演算中的一种变换，指\x -&gt; f x和f这两种写法在语义上是等价的。但实际上第一段代码要比第二段代码要快，这是因为第一段代码满足了Constant applicative form(CAF)，因此编译器默认会进行优化，而对于第二段代码由于x不确定，所以对于每个x，编译器都要重新计算一遍fib&#39;函数。使用GHC的float-in/float-out能够进行优化。 where、let in与let的区别首先let和前两者是非常不同的。 pattern matching模式匹配(pattern matching)可以用来进行解构绑定(deconstruction binding)借助于Haskell的模式匹配还可以实现下面的写法。 not :: Bool -&gt; Bool not True = False not False = True 这可以借助OOP中的虚函数(dynamic dispatch)实现，例如下面的C#伪代码12345678910111213class Bool&#123; Bool Not();&#125;class True : Bool&#123; Bool Not()&#123; return new False(); &#125;&#125;class False : Bool&#123; Bool Not()&#123; return new True(); &#125;&#125; 特别地，下划线_表示可以匹配任何参数，称为wildcard。例如 True &amp;&amp; b = b False &amp;&amp; _ = False lazy evaluationlazy evaluation相对于eager evaluation有相当的好处，阐明这点将贯穿整个课程，这里讲了一个比较具体的例子 f x = 4711 于是可以有下面的求值方案，这里X是某个任意值 f(True &amp;&amp; X) = f(X) = 4711 这样的好处是避免了对X的求值（注意这里X没有被逻辑与短路），因为X可能是不可计算的：假如定义并求值X = X或者X = head []，那程序是不能终止(non-terminating)的，在Haskell中是通常的一种错误(Error)形式。但是f(X)是可以计算的。采用eager evaluation的大多数其他语言会在True &amp;&amp; X表达式时就对X求值，而这时会造成问题的。此外，lazy evaluation无论对于什么样的求值顺序结果都是不变的，这是由于Haskell语言本身（除了Monad）不会造成副作用。例如对于上面的例子可以直接根据f x = 4711归约 f(True &amp;&amp; X) = 4711 pattern具有优先级对于这个例子中，值永远是False，因为第一个规则的优先级更高 _ &amp;&amp; _ = False True &amp;&amp; True = True 所以我们在写规则的时候，会把更特化的规则写在前面，这是非常需要重视的一点。 重复的名字不能出现在pattern中此外还需要注意重复的名字(patterns may not repeat variables)，例如下面的代码是错误的 b &amp;&amp; b = True 会输出错误 ? Conflicting definitions for ‘b’ Bound at: F:\Codes\Haskell\3.hs:2:1 F:\Codes\Haskell\3.hs:2:6 ? In an equation for ‘Main.&amp;&amp;’ 这是为什么呢？其实这样的东西称为nonlinear pattern。理想情况下，我们希望通过使用同一个字符b来限定&amp;&amp;的左操作数和右操作数是相等的。但是这是不可能实现的，因为当左右操作数出现lambda时，是没有一个统一标准判断lambda是否相等的 list pattern和:运算符:(cons)可以构造列表，下面的第一行代码称为list constructor，我们常喜欢用的第二行可以看做第一行的语法糖。 1:(2:(3:[])) [1,2,3] 然而它还可以用在pattern matching中，例如实现head和tail head :: [a] -&gt; a head (x:_) = x tail :: [a] -&gt; [a] tail (_:xs) = xs 注意点： 用x:xs去pattern matching空list是未定义行为 x:xs一定要用括号括起来，因为函数调用(application)的优先级比:的优先级要高 注意区分**(x:y)**和**[x:y]** [x:y]匹配具有一个参数的list，这个参数满足匹配x:y (x:y)匹配具有x作为head和y作为tail的list 总之，[]匹配是固定个数的，可以利用这个来匹配终结条件，例如 product [] = 1 product (x:xs) = x * product xs 或 product [x] = x product (x:xs) = x * product xs as sign(@) 有时候会见到这样的代码ps@(x:xs)，这时候我们可以同时给列表、列表中的第一个元素、列表的剩余部分同时命名。 有办法去pattern matching列表的最后一个元素么 为什么要去这样做呢？我们要注意到haskell中的列表是lazy evaluate的，也常是无尽列表，而无尽列表是不存在最后一个元素的。 integer pattern 这是一个类似数列递推公式的pattern，可以使用n + k这样的形式使用。这时候n是一个变量，而k是一个常数 pred :: Int -&gt; Int pred (n + 1) = n fib :: Integer -&gt; Integer fib 0 = 1 fib 1 = 1 fib n = fib (n-1) + fib (n-2) main = print (fib 5) 函数调用(application)的优先级比+等代数运算的优先级要高，所以同样要用括号括起来 lambda在上一Chapter中通过add的例子讲到Haskell如何通过柯里化让一个函数返回另一个函数，而使用lambda可以更清晰地表现出一个函数究竟是返回的一个值还是另一个函数。例如 const :: a -&gt; b -&gt; a const x _ = x 也可以写成柯里形式，接受一个参数，返回一个接受一个参数的函数 const x = \_ -&gt; x 使用lambda同时还可以声明一个匿名函数，然后避免定义这个只用一次的具名函数。对于多元的lambda表达式 \x -&gt; \y -&gt; f x y 可以简写为 \x y -&gt; f x y section与偏函数prefix notation是Haskell独有的特性，即之前(Ch2.6)上在运算符两边加上小括号(op)将其作为柯里函数的用法。因为在Python中要不自己定义一个lambda x,y: x + y要不传一个operator.add注意到既然是柯里函数，意味着说我们还可以这样写，这称为section1234&gt; (1+) 23&gt; (+2) 13 而不要写成lambda x: 1 + x 作为补充，提及一下。类似于(1+)的写法称为偏函数应用(partial function application)。偏函数是对于柯里化来说的，类似于C++中的偏特化，其目的是固定一个多元函数中的某几个函数的值，产生一个新函数。例如对于add函数 add :: Int -&gt; (Int -&gt; Int) add x y = x + y 我们可以特化出一个addOne函数 addOne :: Int -&gt; Int addOne = add 1 在定义偏函数应用的时候，要注意我们partial的是application而不是function。例如偏函数应用也能对下面比较复杂的高阶函数奏效 comp2 :: (a -&gt; b) -&gt; (b -&gt; b -&gt; c) -&gt; (a -&gt; a -&gt; c) comp2 f g = (\x y -&gt; g (f x) (f y)) 现在我们试图特化g为add，可以记住一条简单的规则偏应用的定义式右部必须出现原函数，例如addOne函数的右部出现了add函数。因此尝试comp2&#39; f = (\x y -&gt; add (f x) (f y))是不对的，它实际上定义了一个新的函数，而正确的偏应用应当为 comp2&apos; f = comp2 f add Ch5 List Comprehensions顾名思义，这章讲的是Haskell的列表生成器 [x + 1 | x &lt;- [1..5]] 这个最近的C++标准/草案中也有类似的range可以生成笛卡尔积 &gt; [(x,y) | x &lt;- [1,2,3], y [(x,y) | y &lt;- [4,5], x [(x,y) | x &lt;- [1..3], y &lt;- [x..3]]它还可以做 concat :: [[a]] -&gt; [a] concat xss = [x | xs &lt;- xss, x &lt;- xs] 这类似于派通(Python，老外奇妙的口音)中的 [item for sublist in [[1,2], [3], [4,5,6]] for item in sublist] 还可以加上guard [x | x &lt;- [1..10], even x] 下面是一个质数暴力筛程序 factors :: Int -&gt; [Int] factors n = [x | x &lt;- [1..n], n `mod` x == 0] prime :: Int -&gt; Bool prime n = factors n == [1,n] primes :: Int -&gt; [Int] primes n = [x | x &lt;- [2..n], prime x] zip常用函数不解释 zip :: [a] -&gt; [b] -&gt; [(a, b)] Haskell中的zip函数同样是不要求两个list长度匹配的，于是可以写出这样的代码 &gt; pairs xs = zip xs (tail xs) &gt; pairs [1,2,3,4] [(1,2),(2,3),(3,4)] zip的反函数是unzip unzip :: [(a, b)] -&gt; ([a], [b]) stringstring是Char的list Ch6 Recursive Functions 介绍Why Functional Programming Matters这本书 为什么lazy和pure的functional programming很重要 证明 product [1..n] = recfac n 递归的作用 容易 自然 能够使用数学方法induction lazy evaluation和purity 这块讲得比较抽象，实际上就是不同的函数有一些相似点可以提炼成一个大操作，这个大操作中包含着若干实现不同的小操作（初始条件，迭代更新规则），由于小操作是不互相影响的(purity)，所以可以只实现提炼出的大操作，然后对于每个函数实现对应的小操作。这些在下一章会有详细说明 多元函数的递归 zip :: [a] -&gt; [b] -&gt; [(a,b)] zip [] _ = [] zip _ [] = [] zip (x:xs) (y:ys) = (x,y) : zip xs ys drop drop需要处理两个初始条件 drop :: Int -&gt; [a] -&gt; [a] drop 0 xs = xs drop _ [] = [] drop n (_:xs) = drop (n-1) xs quick sort 下面是出现在整个课程开头的快速排序 qsort :: Ord a ⇒ [a] -&gt; [a] qsort [] = [] qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger where smaller = [a | a &lt;- xs, a &lt;= x] larger = [b | b &lt;- xs, b &gt; x] Ch7 Higher-Order Functions上一章讲了如何使用递归来实现某些函数，这章学习通过高阶函数如map、filter、foldr来实现它们高阶函数(Higher-Order Functions)指的是接受一个函数作为参数，或者返回一个函数的函数（然而Haskell天生自带Currying，所以参数大于等于2就一定是高阶函数了啊）首先介绍一些关于Combinator的书 高阶函数用途 common programming idiom 写出更短小精炼的程序 DSL 可以方便地定义领域特定语言(DSL)，例如一个简单的加法器的语法 data expr = value = add expr expr 可以发现这和我们常用来描述文法的BNF是非常类似的，而下面需要parse的话可以实现一个eval函数 eval :: expr -&gt; Int Haskell相比C++方便多了，要是C++的话可能会想着自己撸个逆波兰式或者LL/LR解释器啥的 另外Haskell的模式匹配也减少了大量的代码 algebra properties 高阶函数具有一定的代数性质可以进行宏观变换，而不要担心实现细节，类似于上一章讲到的分为大操作小操作 mapmap接受一个函数和一个列表，将这个函数应用到列表中的每个元素中，并返回一个列表 map :: (a -&gt; b) -&gt; [a] -&gt; [b] 注意不要错写成 map :: a -&gt; b -&gt; [a] -&gt; [b] 在一些函数式编程语言中还可以见到flatMap这个函数，它和map有本质的不同，它的签名可以写为flatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]。当作用在一个[a]数组时，可以理解成它首先生成[[b]]数组，再将这个数组拍平成[b] filter可以通过guard或者list comprehension来实现filter foldHaskell或者C++17中的fold expression，类似于python等语言中的reduce函数。这两者的区别在reduce只能处理一个相同类型（fold前），但是fold可以处理两个不同类型（fold前和fold的结果）Haskell中分为foldl和foldr，其中foldr比较常用，将归约到的值作为运算f的右操作数 foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b foldr f v [] = v foldr f v (x:xs) = f x (foldr f v xs) 它接受三个参数： (a -&gt; b -&gt; b)：一个接受a和b类型参数并返回b类型参数的函数 b：归约到的类型 t a：这个表示一个t a的类型。这里t表示一个Foldable的类型。 在C++中有叫模板参数的东西，例如std::vector&lt;int&gt;表示一个用int特化的向量表vector。Haskell中的t a类似于这个，其中t对应着类模板vector，a对应着类型int。 因此可以理解成一个叫t的函数，接受一个类型变量(type variable)a作为参数，产生了一个新的类型t a。这里的t称为type constructor，而a是一个concrete type。 一个concrete type是具有值的，例如Int之类的，它通常是由data声明的；但一个type constructor function必须接受一个type parameter才能成为一个concrete type，例如，当t为list时，t a就是[a]，这里[a]是一个语法糖，等价于[] a。type constructor通常是由class声明的并可以由instance提供实现的，例如instance Applicative []。这里注意，这里的t并不一定是容器类型，例如它不局限于list、tuple这样的东西，所以我们不能局限地认为fmap是“对于某个容器里面的所有元素都进行XX操作”。 =&gt;：我们之前见过在=&gt;左边的Num a，这个称为类型约束。而=&gt;右侧的函数签名部分，称为type form。 因此这个函数可以理解为 foldr f 当前/初始归约的结果 用来归约的列表 reduce可以用fold来实现，例如Python中的 print reduce(lambda x, y: x + [y], [1,2,3,4], []) 可以用foldr实现为 main = print (foldr (\x -&gt; \y -&gt; [x] ++ y) [] [1,2,3,4]) 类似的有foldl函数 foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b 上面的reduce可以用foldl实现为 main = print (foldl (\x -&gt; \y -&gt; x ++ [y]) [] [1,2,3,4]) foldl和foldr的区别从定义上看，这两个函数的区别在第一个参数f上，这实际反映了运算顺序的不同。查看定义 foldlX f acc [] = acc foldlX f acc (x:xs) = trace (&quot;acc == &quot; ++ show acc) foldlX f acc&apos; xs where acc&apos; = f acc x foldrX f acc [] = acc foldrX f acc (x:xs) = trace (&quot;acc == &quot; ++ show acc) f x (foldrX f acc xs) 执行结果 &gt; main = print $ foldlX (+) 0 [1..5] acc == 0 acc == 1 acc == 3 acc == 6 acc == 10 15 &gt; main = print $ foldrX (+) 0 [1..5] acc == 0 acc == 0 acc == 0 acc == 0 acc == 0 15提炼出来 foldl = foldl f(x, acc) xs foldr = f x foldr(acc, xs)可以发现foldl是从左到右计算的，但foldr是从右到左计算的。由此导致的foldl会产生一个尾递归（右递归），foldr产生一个左递归。由于编译器可以针对尾递归优化，所以foldl可能会快一点。此外，利用strict特性（详见Ch12 strict application）的foldl&#39;能够减少空间。那么foldr的优势在于处理无穷列表的时候，考虑 myAndL = foldl (&amp;&amp;) True myAndR = foldr (&amp;&amp;) True &gt; myAndL (repeat False) &gt; myAndR (repeat False) 那么foldr由于f = (&amp;&amp;)的性质被短路，所以能够返回。但是foldl的f在内部，而foldl本身不具备短路原则，会陷入无限的尾递归 部分内容来自文章进行说明 使用fold实现函数fold是被提炼出的一种“大操作”，利用foldr可以实现很多函数，之前这些函数往往要递归地通过guard、if或者list comprehension来实现 sum = foldr (+) 0 这是因为 sum [1,2,3] = foldr (+) 0 [1,2,3] = foldr (+) 0 (1:(2:(3:[]))) = 1+(2+(3+0)) 类似地可以定义 product = foldr (*) 1 or = foldr (||) 1 and = foldr (&amp;&amp;) 1 对于length函数可以如此定义 length = foldr (\_ n -&gt; 1 + n) 0 length = sum . map (\_ -&gt; 1) 对于reverse函数可以如此定义 reverse = foldr (\x xs -&gt; xs ++ [x]) [] 这是因为 reverse [1,2,3] = reverse (1:(2:(3:[]))) = (([] ++ [3]) ++ [2]) ++ [1] 所以可以看到foldr接受a类型的x和b类型的xs，然后反向地去连接xs和[x]，最后得到的是另一个列表，这和上面的length函数是不一样的特别地，可以重新定义++ (++ ys) = foldr (:) ys 这是因为 (xs ++ ys) = foldr (:) ys xs 这表示把Foldable类型的xs中的每个元素:到ys的前面，这就相当于 foldr (:) ys [1,2,3] = foldr (:) ys (1:(2:(3:[]))) = (1:(2:(3:[ys]))) 继续改写 (xs ++ ys) = (++) xs ys -- 这里原版写的是(++) ys xs但是我觉得应该是(++) xs ys = foldr (:) ys xs 因此可以得到 (++) ys = foldr (:) ys = (++ ys) = foldr (:) ys fold的作用 有些递归函数用foldr更容易实现（可以从之前的讨论中看出） 有些函数的性质可以通过foldr的代数性质推导得到，例如fusion规则和banana split规则 fusion fusion(composition)是之前讨论过的.运算符，用来实现复合函数，其具有类型 (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c) banana split 这个会在后面提及 使用foldr而不是递归，可以方便进行优化 unfoldrunfoldr为foldr的对偶函数，定义为 unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a] 一般可以理解为a为生成的list里面的每一项，而b是下次迭代的时候的b，类似于for循环中的更新规则 unfoldr具有性质 unfoldr f&apos; (foldr f z xs) == xs scanlscanl和foldl非常相似，只不过它是“扫描”获得列表，而不是将列表“折叠”起来 (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a] 更多的高阶函数all、any、takeWhile（常常被用来读无尽列表）、dropWhile fmapfmap与Functor息息相关，Functor在下章会进行补充。首先比较一下fmap和map的定义 Prelude&gt; &gt; :t fmap fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b Prelude&gt; &gt; :t map map :: (a -&gt; b) -&gt; [a] -&gt; [b] fmap接受一个(a -&gt; b)函数，这个函数负责将一个f a转换为f b。这里注意f是一个type constructor。如果我们把fmap的f替换成[]，便可以发现map实际上是fmap对list即[]的特化。 instance Functor [] where fmap = map Ch8 Functional Parsers在官网上下载的PPT中第8章是Declaring Types and Classes，但实际上这章在课程中被放到了第10章。本章是Functional Parsers，会讲授重要的概念Monads，于是教授穿了件自己设计的（密集恐惧症）衣服这一章会有点突兀，有比较多的没学过的东西，在我学习的过程中，最让我感到困惑的并不是Monad本身，而是教授讲授时定义的复杂的类型，例如即将看到的IO a和Show a这样的类型，有时这会导致运行教授讲授的代码存在困难，不得不说是课程的一个缺憾。首先要补充一个控制结构，对于下面的guard f 0 = 18 f 1 = 15 f 2 = 12 f x = 12 - x 这种写法又称为piece-wise version，因为实际上定义了4个f函数。如果用case，可以写作 f x = case x of 0 -&gt; 18 1 -&gt; 15 2 -&gt; 12 _ -&gt; 12 - x 课程开始，照例讲了点别的，介绍Functional Portal Parser Type在本章中，我们要实现一个类型Parser，通过实现这个Parser，我们也就实现了Monad的核心部分。很自然地，在Haskell中，用函数来表示Parser type Parser = String -&gt; Tree 但是有时候Parser只处理输入串String的一部分，所以Parser也要返回未使用的String type Parser = String -&gt; (Tree, String) 有时候输入串String不能生成语法树Tree，于是Tree并不是一定有的，是一个optional值，这在Haskell中可以用Maybe来表示 data Maybe a = Nothing | Just a Maybe在Haskell中用来处理optional值，它是一个Monad，data语句在第10章会有介绍，Nothing和Just a是Maybe a的两个constructor，它们看起来像为C++中的enum，但实际上更类似于C++中的构造函数。Maybe一个类型可以从Nothing构造，但返回一个非Nothing的值a时就需要返回Just a。Nothing很好理解，类似于其他语言中的null、None、nil在没学习Ch10 Declaring Types and Classes时，Just是个比较奇怪的概念。首先查看它的定义 Just :: a -&gt; Maybe a 从定义中可以看到Just返回的是Maybe a对象，这有点类似于函数重载或者SFINAE的意味，我们可以理解为调用了Maybe不同的构造函数，并且Nothing可以表示另一个构造函数，不过这个构造函数不接受参数罢了。如果我们把data语句当成了enum，这里就不好理解了。教授认为出于方便考虑，并不需要使用Maybe这东西，用一个简单的list就可以了 type Parser = String -&gt; [(Tree, String)] 因此这个list要不是一个单元素的列表(singleton list)，要不是个空列表最后，Parser并不一定返回一个语法树，所以加上一个泛型 type Parser a = String -&gt; [(a, String)] 总结一下，现在我们已经知道了list的作用是为了实现optional，tuple的作用是辅助类似于遍历字符串的一个指针。事实上这个Parser是一个Monad雏形。注意如果使用附带的代码Parsing.hs会发现视频隐藏了Parser的一些关键定义，这会导致直接键入并运行视频中的代码可能会出现错误（接下来会看到）。视频中给出上面这样的Parser定义是为了方便理解的考虑，实际上也是实现了一个Monad的type class。 一些简单的语法分析器item这个Parser在输入为空是fail，否则读取输入的第一个字符，下面根据type Parser a = String -&gt; [(a, String)]来推导item的类型 item :: Parser Char :: String -&gt; [(Char, String)] :: [Char] -&gt; [(Char, [Char])] 下面查看item的定义 item = \inp -&gt; case inp of [] -&gt; [] (x:xs) -&gt; [(x,xs)] failure和名字一样，这个语法分析器总是失败 failure :: Parser a failure = \inp -&gt; [] return这个语法分析器的定义不太一样了，它返回一个接受任何输入的一个语法分析器，这个语法分析器对于任意输入返回v。 return :: a -&gt; Parser a return v = \inp -&gt; [(v, inp)] 我们分析一下返回类型 Parser a :: String -&gt; [(a, String)] :: [Char] -&gt; [(Char, String)] 原来返回的是个函数，测试一下 main = print $ (return &quot;123&quot;) &quot;xxx&quot; 发现结果是&quot;123&quot; return关键字的辨析Haskell中的return的和大多数语言中return关键字名字相同，也都经常出现在语句的末尾。但两者的意义却完全不同。Haskell中也不需要什么return，语句自身就是返回值，所以不要把两个混淆在Haskell的Prelude中定义有类似以上代码实现的return函数 &gt; :t return return :: Monad m =&gt; a -&gt; m a 实际上return是Monad里面的一个非常重要的运算，在后面即将讲到。 +++这个语法分析器类似于一个选择结构，实际上它是一个存在的运算符&lt;*&gt;的重新实现。它表现得像语法分析器p，如果p能succeed，否则表现得像语法分析器q (+++) :: Parser a -&gt; Parser a -&gt; Parser a p +++ q = \inp -&gt; case p inp of [] -&gt; parser q inp [(v, out)] -&gt; [(v, out)] parseparse是个很重要的语法分析器，如果实际运行附带代码里面的Parsing.hs，就会发现 print (item &quot;123&quot;) 是会报错的，正确的方式是运行 print (parse item &quot;123&quot;) 这类似return的问题，这是因为Parser的定义不同导致的，在现阶段应该使用视频中给出的代码再看一下parse的定义 parse :: Parser a -&gt; String -&gt; [(a, String)] parse p inp = p inp 值得注意的是parse函数将这个语法分析器（再次强调根据type Parser定义，Parse实际上也是一个函数）p应用(apply)到inp上。它的作用是让代码更清晰 检验上面的语法分析器检验上面的语法分析器需要Parser类型的定义。 item&gt; parse item &quot;&quot; [] &gt; parse item &quot;abc&quot; [(&apos;a&apos;, &quot;bc&quot;)] failure&gt; parse failure &quot;abc&quot; [] return&gt; parse (return 1) &quot;abc&quot; [(1, &quot;abc&quot;)] +++&gt; parse (item +++ return &apos;d&apos;) &quot;abc&quot; [(&apos;a&apos;, &quot;bc&quot;)] &gt; parse (failure +++ return &apos;d&apos;) &quot;abc&quot; [(&apos;d&apos;, &quot;abc&quot;)] Sequencing到目前为止，我们都是使用递归来描述一系列的操作的，借助list comprehension或者高阶函数也可以实现循环操作，借助if、guard或者case实现选择语句。但是顺序操作，这个命令式语言最常见的操作却一直没有办法实现，事实上由于Haskell的lazy特性，其更倾向于是并举的。而Monad正是解决这个问题的 do可以用do来表示顺序操作，do能够作用在任意的monadic类型上 p :: Parser (Char, Char) p = do x &lt;- item item y &lt;- item return (x, y) 注意：这段代码需要通过附带的代码Parsing.hs运行，因为Parser类型实际上要实现Monad类型类，才能够使用&gt;&gt;=、&lt;-等运算符如果仅仅使用type来定义 type Parser a = String -&gt; [(a, String)] 简单地推导下可以发现 :: Parser (Char, Char) :: [((Char, Char), String)] 但是在错误信息中发现编译器实际上推导出的(x, y)是 :: [(([(Char, String)], [(Char, String)]), String)] 同样，在Parsing.hs运行下面的代码可能会报错，因为使用了newtype定义的类型和[(a, String)]是两个完全不一样的类型了，所以要在前面加一个P。可以参考Parsing.hs里面的item和parse函数。 在下面两节将要介绍&gt;&gt;=运算符，这个运算符和do同样可以描述序列化的操作，而序列化是Monad的一种用途。 Select和SelectMany在了解&gt;&gt;=前，教授提到了C#中的Select方法和SelectMany方法，其中Monad类似于SelectMany方法，因为Monad可以控制如何返回结果。1234567891011121314151617181920212223242526static void Main(string[] args)&#123; List&lt;string&gt; animals = new List&lt;string&gt;() &#123; "cat", "dog", "donkey" &#125;; List&lt;int&gt; number = new List&lt;int&gt;() &#123; 10, 20 &#125;; var select1 = number.Select(num =&gt; animals); var select2 = number.SelectMany(n =&gt; animals); foreach (var x in select1) &#123; foreach (var y in x) &#123; System.Console.WriteLine(y); &#125; &#125; System.Console.WriteLine("-----------------------------"); foreach (var x in select2) &#123; System.Console.WriteLine(x); &#125; System.Console.WriteLine("-----------------------------"); var zipped = number.SelectMany(n =&gt; animals, (n, a) =&gt; new &#123; n, a&#125;); foreach (var x in zipped) &#123; System.Console.WriteLine(x); &#125; System.Console.ReadKey(true);&#125; 输出值是 cat dog donkey cat dog donkey ----------------------------- cat dog donkey cat dog donkey ----------------------------- { n = 10, a = cat } { n = 10, a = dog } { n = 10, a = donkey } { n = 20, a = cat } { n = 20, a = dog } { n = 20, a = donkey } 可以看到，SelectMany能够将结果“拍平”成一维数组。并且可以多接受一个函数，表示如何返回结果。 >>=这个操作称为bind，是Monad中最重要的一个运算符，在C#中称为SelectMany，先查看它的定义 (&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b 【注】实际上在Haskell源码（在安装目录下的doc文件夹）中，该运算符是以如下形式出现的(&gt;&gt;=) :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b。forall关键字来自Existentially quantified types这个扩展，并且作为默认的选项，这里可以直接忽略。因为Parser是一个Monad，为了直观一点，所以对应到Parser类型 (&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b 这个运算接受一个参数Parser a，将它给一个函数(a -&gt; Parser b)，随后得到结果Parser b。于是我们产生了几个问题： 这看起来就是提供了一个策略，能通过a -&gt; Parser b实现函数m a -&gt; m b能实现的功能，感觉没什么了不起的，为什么不能直接定义一个m a -&gt; m b的函数呢？ 首先在m a -&gt; m b的函数里面，Haskell无法从m a类型把a提取出来，这样就不能完成需要直接操作a的运算了。 如果我们把m a想成有副作用的a，那能不能把m a当成a来操作，这样定义了a -&gt; b相当于也定义了m a -&gt; m b呢？答案是也不能的，因为还有一个具有另外含义的Monad，如list, Maybe 这个操作有点类似于前面见到过的复合运算(.)，或者($)，他们之间有什么关系呢？ 事实上($)、(&lt;$&gt;)(fmap)、(&lt;*&gt;)(apply)、(&gt;&gt;=)(bind)四个运算符有着相似的性质，在下面的。 为什么要专门拿出来这个操作大书特书呢？ 其实这和Haskell需要实现的纯洁性有关。在看完&lt;-的介绍和下章的内容后会有更深的体会。 Monad根据Wikipedia，Monad具有两个操作，第一个是之前看到的return，另一个是上面的bind return return操作又称为unit，从一个普通类型a构造一个具有类型M a的monadic value bind 这个操作接受一个M a的monadic value，将a从M a类型的变量里面拆出，并传给函数(a -&gt; M b)来，输出具有类型M b的另一个值。有点类似linux里面的管道命令。 此外，之前看到的failure其实都可以作为Monad的一部分，除此之外还有第四个运算符&gt;&gt;。这个运算符实际上是&gt;&gt;=的一个简化版本 (&gt;&gt;) :: m a -&gt; m b -&gt; m b 这个操作的意义实际上也是合成两个操作，起到语法糖的功能，例如a &gt;&gt; b实际上等价于a &gt;&gt;= \ _ -&gt; b，也就是对于任意的a返回常量b。其实do操作也可以看做&gt;&gt;的语法糖 do action1 action2 action3 可以写成 action1 &gt;&gt; action2 &gt;&gt; action3 不过由于没有&gt;&gt;=，do中必须通过下面的&lt;-来从Monad中“提取”值 List Monad和&lt;-在list comprehension中出现了&lt;-这个运算符，例如在下面的例子中，&lt;-从[a]中“提取(feed)”了a： [x | x &lt;- xs] 但是对于do中的x &lt;- item，item是语法分析器，类型Parser Char，而通过&lt;-得到Char类型，这是为什么？其实这和Monad中的&gt;&gt;=是一个道理。在do语句中，&lt;-运算符称为single assignment operator，或binding operator。这个被用作在monadic computation中提取一个值。准确一点说，&lt;-将Monad内的一个计算结果和一个名字绑定，或者可以说&lt;-类似于赋值的等号。例如这里的item是一个Parser a，在提取后得到一个a。这有点类似于C#中的装箱拆箱操作，如果把return当做一个“装箱”，那么&lt;-就可以看做一个“拆箱”。但是必须记住的是，Parser或者后面提到的IO这样的Monad，拆箱操作必须只能通过&gt;&gt;=或等价的do语句执行，这样保证了Haskell语言本身的无副作用性。在&gt;&gt;=里面不需要&lt;-，因为“拆箱”操作由被隐式地实现。观察&gt;&gt;=的第二个参数a -&gt; Parser b，这个a从第一个参数m a中被隐式地提取出来了。而对于do中，我们必须要用&lt;-来显式地提出。 作为补充，提及一下list monad。从上面的讨论中我们可以发现list comprehension和monad中的do语句有着异曲同工之妙。事实上list也是一个monad，我们可以用do来实现list comprehension。 [(i,j) | i &lt;- [1,2], j &lt;- [1..4] ] 对于上面的list comprehension，我们可以使用do来改写 do i &lt;- [1,2] j &lt;- [1..4] return (i,j) Maybe Monad之前提及的Maybe也是一个Monad，我们可以给出如下的定义 return :: a -&gt; Maybe a return x = Just x (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b (&gt;&gt;=) m g = case m of Nothing -&gt; Nothing Just x -&gt; g x 结论再一次说明，可以看出，这四行首先调用item获得一个x，然后再次调用item，获取并discard掉一个结果，然后再次调用item，获得一个y。最后返回一个tuple(x, y)这类似于Linq中的from-select notation from x in item from dummy in item from y in item select new {x, y} 最后关于Monad，推荐一篇文章 Monad与Continuation从这里开始是我的一些补充。Monad和CPS有一些类似之处，事实上这篇文章中提及了两者之间的关系。 Continuation简介单独列了一篇文章 Continuation MonadFunctor在上章的fmap部分我们了解了函子(Functor)。Functor是一个type class，实际上Functor和fmap是紧密联系的，一个能被mapped over(即能够fmap)的类型即是Functor，我们定义一个Functor f class Functor f where fmap :: (a -&gt; b) -&gt; f a -&gt; f b (&lt;$) :: a -&gt; f b -&gt; f a (&lt;$) = fmap . const 其中fmap有对应的操作符 (&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b 这里f a称为上下文中的值(in context value)，因为a被f包装了起来。从定义中可以看出，fmap把Functor f a从上下文中的东西拿出来，然后交给一个函数(a -&gt; b)，函数处理完又封装进contextf b中。此外，由于我们的函数是柯里函数，并且-&gt;是右结合的，所以fmap还可以理解为 fmap :: (a -&gt; b) -&gt; (f a -&gt; f b) 即接受一个(a -&gt; b)类型的函数，并返回一个函数f a -&gt; f b，这个函数接受一个Functor f a并返回一个Functor f b，例如 fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a Maybe Functor之前看到的Maybe也是一个Functor instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing Function Functor不过首先来看一个运算符-&gt;，对，就是用来定义函数的。r -&gt; a可以写成(-&gt;) r a。由于type constructor能且只能接受一个参数，所以(-&gt;)不是Functor，但是(-&gt;) r即(r -&gt;)是Functor。既然函数-&gt;是Functor，那就得定义它对应的fmap啊，于是 instance Functor ((-&gt;) r) where fmap f g = (\x -&gt; f (g x)) f (g x)看起来很眼熟，不禁联想到前面的 (f . g) x :: f (g x) 我们是不是可以直接给出如下定义？ instance Functor ((-&gt;) r) where fmap = (.) 于是我们再直接代入一下看看 f :: (-&gt;) r fmap :: (a -&gt; b) -&gt; f a -&gt; f b :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b) :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; a) (.) :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b) 可以发现这个((-&gt;) r)其实等价于composition(.)。 fmap的性质fmap具有下面的性质 fmap id = id fmap (p . q) = (fmap p) . (fmap q) 第一条看起来很简单，第二条讲的是fmap对.有分配律。对于第二条，我们假设另一个Functor X fmap (f . g) X = (fmap f) . (fmap g) X 不妨令f :: b -&gt; c，g :: a -&gt; b首先看左边 fmap (f . g) X :: fmap (a -&gt; c) X a -&gt; X c :: X a -&gt; X c 再看右边 (fmap f) :: f -&gt; X b -&gt; X c (fmap g) :: f -&gt; X a -&gt; X b (fmap f) . (fmap g) X :: (X b -&gt; X c) . (X a -&gt; X b) :: X a -&gt; X c 因此等式成立。在推导的时候需要注意，里面的fmap和.都是函数应用而不是函数定义，带入定义式是不对的。 ApplicativeApplicative定义如下，这里省略了(*&gt;)和(&lt;*)的默认实现 class Functor f =&gt; Applicative f where pure :: a -&gt; f a (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b (*&gt;) :: f a -&gt; f b -&gt; f b (&lt;*) :: f a -&gt; f b -&gt; f a 先看一看这个东西怎么用吧 &gt; [(2*),(5*),(9*)] &lt;*&gt; [1,4,7] [2,8,14,5,20,35,9,36,63] 在这个例子里面Applicative((&lt;*&gt;))想计算笛卡尔积一样，将一列表的函数应用到另一个列表的整数上，然后列表的长度改变了。首先class Functor f =&gt; Applicative f where，我们知道这里出现在=&gt;前的Functor f是type constraint，所以一个Applicative也是是Functor。这意味着Applicative类型（List、Maybe等）不仅可以当成Functor来用，还具有Functor没有的一些用法。 &gt; (+3) &lt;$&gt; (Just 5) Just 8 &gt; Just (+3) &lt;*&gt; (Just 5) Just 8 &gt; Just (+3) &lt;$&gt; (Just 5) pure可以参照理解成Monad里面的return，相当于我们把一个a打包放到了一个Applicative Functorf a里面。&lt;*&gt;的定义就有意思了。首先查看第一个参数f (a -&gt; b)，这是把一个函数作为type parameter给f。从前我们的Functor里面包含的是值，不过这次里面包含着Function，例如本节开头的例子中，f是List，f (a -&gt; b)便是一个List的Num a =&gt; a -&gt; a函数，所以f (a -&gt; b)在这里被称作上下文中的函数(in context function)。如果把这个函数从上下文中拿出来一看，原来就和fmap的第一个函数一样了。第二个参数是一个Functor f a。然后(&lt;*&gt;)做的事情是把Function从Function Functor中“提取”出来，fmap到第二个Functorf a上，这个fmap就和Functor一致了。为了观察具体流程，下面的代码对比实现了Maybe的Functor和Applicative instance Applicative Maybe where pure = Just Nothing &lt;*&gt; _ = Nothing (Just f) &lt;*&gt; something = fmap f something instance Functor Maybe where fmap f (Just x) = Just (f x) fmap f Nothing = Nothing 首先我们看到(Just f)似乎通过pattern match提取出了f，而Nothing里面并没有任何的函数可以被提取，如果我们第一个参数的类型不是f (a -&gt; b)而直接是a -&gt; b，那我们就不能传入Nothing这样的参数了。可以发现，Applicative的特点是&lt;*&gt;运算符的两边都可以使Applicative，而Functor的特点是fmap/&lt;$&gt;只有第二个参数能够是Functor。 Applicative还有一个性质是Sequencing，也就是我们在本章看到的Monad所具有的性质。它的表现是Applicative Style，也就是对于一个多元的普通函数，也可以通过&lt;*&gt;来应用到多个带上下文的参数中。 pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ... fmap f x &lt;*&gt; y &lt;*&gt; ... f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; ... 注意到pure f、fmap f x、f &lt;$&gt; x是等价的。例如 &gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5 [8.0,10.0,2.5] 在本节开头，我们接触了List Applicative，[(2*),(5*),(9*)] &lt;*&gt; [1,4,7] = [2,8,14,5,20,35,9,36,63]，下面我们看看居停的定义 instance Applicative [] where pure x = [x] fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs] Monoid幺半群(Monoid)即带有单位元的半群，因此幺半群满足封闭性、结合律、单位元 import Data.Monoid class Monoid m where mempty :: m mappend :: m -&gt; m -&gt; m mconcat :: [m] -&gt; m mconcat = foldr mappend mempty Monad和Functor以及ApplicativeMonad是一个Applicative，而Applicative是Functor，所以所有的Monad都是Functor(因为Applicative都是Functor)。这三者有着类似的定义，和各自的独特之处 class Applicative m =&gt; Monad m where (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b (&gt;&gt;) :: m a -&gt; m b -&gt; m b return :: a -&gt; m a fail :: String -&gt; m a 如果把(&gt;&gt;=)的参数掉个个成=&lt;&lt; (=&lt;&lt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (m a -&gt; m b) (&lt;*&gt;) :: Applicative m =&gt; m (a -&gt; b) -&gt; (m a -&gt; m b) (&lt;$&gt;) :: Functor m =&gt; (a -&gt; b) -&gt; (m a -&gt; m b) 可以发现fmap的返回值都是(m a -&gt; m b)，三者差距在于“定义域”的不同。其中Functor能够接受任意函数，但是(&lt;*&gt;)能接受m (a -&gt; b)（其实这都不一定是个函数），而(&gt;&gt;=)只能接受(a -&gt; m b)。从fmap到(&lt;*&gt;)再到(&gt;&gt;=), 我们对于值的控制力和计算的灵活性逐渐增加, 但这是以结果性质的弱化为代价的。这里的控制力和灵活性取决于是我们传入的函数对m的信息有多少。即使这三个操作符会再接受一个m a值的参数，但m a这个值对其实际的操作者，即传入的函数来说是一个黑箱。 对于fmap来说，我们传入的(a -&gt; b)一点都接触不到m这个东西，m是List，抑或是Maybe，我们的函数根本不需要去考虑，m a的拆箱和结果的装箱，Functor m已经包办了，你自己是一点主都做不了的。 但是对(&lt;*&gt;)来说，我们的函数和值f a一样都是in context的，因此在函数里面我们是知道“容器类型”m是个啥的。例如我们可以知道(&lt;*&gt;)包装的是列表还是Maybe (&gt;&gt;=)比Applicative更进一步的是，它可以自行制定如何将结果包装成m b类型，而这在Applicative都是由具体的instance来规定的。 Derived Primitive 一个判断一个Char是否满足给定谓词(Predicate)的语法分析器 sat :: (Char -&gt; Bool) -&gt; Parser Char sat p = do x &lt;- item if p x then return x else failure 使用sat digit :: Parser Char digit = sat isDigit many :: Parser a -&gt; Parser [a] many p = many1 p +++ return [] many1 :: Parser a -&gt; Parser [a] many1 p = do v &lt;- p vs &lt;- many p return (v:vs) 还有若干代码，这里先告一段落 Monad的性质 All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor. 幺半群(Monoid)在前面已有介绍自函子(Endofunctor)即一个将范畴映射到自身的函子(Functor) do do {e} -&gt; e 一个操作用do包裹起来等于它自己 do {e; es} -&gt; e &gt;&gt; do{es} 这就是前面的&gt;&gt;的语法糖 do {let decls; es} -&gt; let decls in do {es} 这里面用到了let和let...in两个不同的结构块。 &gt;&gt;= return a &gt;&gt;= f = f a 这个性质相当于是将一个普通值a穿上Monad的衣服，传给一个函数f，相当于直接调用这个函数f a m &gt;&gt;= return = m 这个性质是因为对于一个Monad m，m &gt;&gt;= return动作相当于先通过&gt;&gt;=把衣服脱掉，然后在通过return重新穿上Monad的衣服 f &gt;&gt;= (\x -&gt; g x &gt;&gt;= h) ≡ (f &gt;&gt;= g) &gt;&gt;= h Monad相关函数操作Liftingfmap是一个lifting操作，lifting操作一般作用于一个函数，并把它变为另一个相关的函数。 Ch9 Interactive Programs上一章讲了什么是Monad，并了解了一些常见的Monad。通过将Functor和Applicative和Monad比较，我们能看出Monad使用的方便之处。这章进一步讨论了IO Monad，并以此体会Monad的独特之处。IO和上一章见到的Parser一样，都是Monad。我们将只在开始接受所有输入、只在最后返回所有输出的程序称为批处理程序batch program，如果这个程序能够在运行时从键盘等设备获取输入，并将结果写到屏幕上，这样的程序称为交互式程序interactive program。交互式程序是有副作用的，是顺序操作，因此使用Haskell实现交互式程序的难点在于Haskell作为纯函数式语言是没有副作用的（也可以看做是优点），类似于数学函数和批处理程序。为了能够引入IO操作，Haskell借助了Monad这个抽象来描述IO操作，很容易发现Monad带有的Sequencing特性非常适合。Monad将副作用排除在了“纯函数式”之外的另一个世界，我们从代码角度来看，整个IO过程“投射”在Haskell代码的部分是纯函数式，无副作用的，而将副作用投射到另一个“里世界”中，Monad成为了这两个世界之间沟通的桥梁。考虑最简单的一个情况，一个纯交互式程序是没有返回值的，对于“没有返回值”，可以将其定义为IO ()，()在先前提到过，称为unit，是一个空的tuple，类似于C++中的void。这样你就可以在不破坏无副作用的情况下到另一个次元做坏事了。下面我们看看具体的一些函数 基本函数getChar :: IO Char，从键盘读取一个字符，显示到屏幕上，并且作为返回值输出。在C++中，它可能对应着int ::getchar(void)函数，但在Haskell中它的定义并不是一个函数，例如可以写成getChar :: () -&gt; IO Char。教授讲解由于Haskell是lazy的，所以上述的函数形式虽然显得更熟悉一些，但是并没有必要写成这样。在Scala中，函数就是对象，但在Haskell中，我们可以感受到“对象”就是函数，在下面的章节中，我们很快就会看到邱奇编码的概念，展示了如何用函数（lambda演算）来表达数组、元组、整数等常见的数据结构。IO是一个Monad typeclass的实现，它“封印”了IO操作中和副作用相关的部分。putChar :: Char -&gt; IO ()将一个Char打印在屏幕上，不返回值。return :: a -&gt; IO a，接受一个a类型，并返回一个IO a类型。 Sequencing前面提到do语句可以将多个操作合并成一个复合操作。考虑下面的一个do语句 a :: IO (Char, Char) a = do x &lt;- getChar getChar y &lt;- getChar return (x, y) 根据上面的分析，其中x和y是Char类型，return将(x, y)的tuple转变为一个IO tuple类型。这样的do也可以通过&gt;&gt;=来写（在上一章已经了解了怎么用&gt;&gt;来改写do） getChar &gt;&gt;= \x -&gt; getChar &gt;&gt;= \_ -&gt; getChar &gt;&gt;= \y -&gt; return (x, y) Derived Primitives可以从getChar定义getLine getLine = do x &lt;- getChar if x == &apos;\n&apos; then return [] else do xs &lt;- getLine return (x:xs) Haskell中，字符串就是Char的list，下面是和字符串有关的函数 putStr&apos; :: String -&gt; IO () putStr&apos; [] = return () putStr&apos; (x:xs) = do putChar x putStr&apos; xs putStrLn :: String -&gt; IO () putStrLn xs = do putStr xs putChar &apos;\n&apos; 同时我们可以使用foldr来定义putStr函数，这里同样用&gt;&gt;=来代替do表示顺序操作 putStr2 :: String -&gt; IO () putStr2 = foldr (++++) (return ()) where x ++++ p = putChar x &gt;&gt;= \_ -&gt; p 下面是一个求字符串长度的函数 strlen :: IO () strlen = do putStr &quot;Enter a string:&quot; xs &lt;- getLine putStr &quot;Length is&quot; putStr $ show $ length xs 可以看出，Haskell程序解决副作用的方法是将副作用放在执行IO ()时了，但是这个语句对于Haskell本身而言，是pure functional的。注意IO对象是不能够被print的 a = do x &lt;- getChar return x main = print a 这个代码中a通过return返回了一个IO，因此是有副作用的，如果print能够处理，那副作用就“蔓延到”无副作用的代码里面了。所以可以认为IO这样的Monad是有传染性的。如果要实现这样的操作应该借助于&lt;-运算符 f = do x &lt;- getChar return x main = do x &lt;- f print x 或者&gt;&gt;=运算符 f = do x &lt;- getChar return x main = f &gt;&gt;= print Hangman游戏Haskell语言是一个非常好的脚本语言。使用Haskell实现一个猜单词游戏。 Ch10 Declaring Types and Classes观察Monad m a中的m，在这里被用作type constructor，所以m可以是Parer可以是IO，这种higher kinded polymorphic并不是使用type parameter，而是使用一个从type到type的函数(type function)来实现。这种Higher Kinded Types实现的方式是Haskell的一个特别的性质。在Haskell中，我们可以定义具有&gt;&gt;=bind运算，就可以被称作Monad，但是在C#等语言中，没有这样的概念(notion)，有这样的模式(pattern)。 有关type function我们知道普通的函数，例如a -&gt; b表示从类型a的值到类型b的值的一个映射。而type function中，把类型本身当做了“操作数”，即a -&gt; b是类型a到类型b的映射，我们甚至可以把a -&gt; b看做(-&gt;) a b。这两者的概念有点类似type constructor和data constructor的区别。类似于对于普通函数的type(:t)我们可以使用kind(:t)来描述type function。容易理解type的kind是*，而Functor/Monad这些类型类的的kind就是* -&gt; *。有趣的是-&gt;也有kind，即* -&gt; * -&gt; *。 Type Declarationstype语句为一个已有类型提供别名，类似于C/C++中的typedef或using。 type String = [Char] type语句可以拥有参数，所以我们可以把它看做类型上的一个函数，可以发现type level和value level上的函数形式上非常相似 type Pair a = (a, a) pair a = (a, a) 下面是一个mult函数的定义 mult :: Pair Int -&gt; Int mult (m, n) = m * n 很多其他的函数式语言完全模糊了这两者的界限，如Agda、Cayenne这两个类似Haskell的语言，和有关函数式编程本质有关的Coq语言等。还有一个替代的方案叫做lambda cube。介绍Phil Watler（音）的论文。 Type Declaration是可以嵌套的，下面的代码是正确的： type Pos = (Int, Int) type Trans = Pos -&gt; Pos 但是递归是不可以的，显然这会得到一个无尽的定义 type Tree = (Int, [Tree]) Data Declarations使用data语句可以定义一个新的类型 data Bool = False | True 这类似于C#中的抽象类（为什么不是enum哦），或者用来描述上下文无关文法的BNF。 abstract class Bool {} sealed class True : Bool {} sealed class False : Bool {} 这表示我们定义了一个Bool类型，其中True和False是具有一个Bool类型的值的constructor。True和False还可以被称为subtype。在定义类型的时候，type constructor和value/data constructor的名字都应该以大写字母开头。由于True不是类型，所以定义函数的时候不能写成 f :: True -&gt; ... 而只能 f :: Bool -&gt; ... 然后True等constructor可以用来做pattern matching，这称为deconstructing。这看起来像C++中的downcasting f True = ... 使用data定义的类型的值(values)和内置类型的值使用方式是类似的 data Answer = Yes | No | Unknown answers :: [Answer] answers = [Yes, No, Unknown] 注意answers类似于上章遇到的getChar，可以看做一个接受0个参数的函数。在定义type的时候constructor也可以拥有参数（所以上面会理解成抽象类）。如下面的代码所示，我们可以在Shape的定义外部对Circle和Rect进行“特化”。 data Shape = Circle Float | Rect Float Float square :: Float -&gt; Shape square n = Rect n n 由于Haskell很难添加一个subtype到已有的type中，例如想要给Shape加上一个Polygon的subtype是不容易的，但是用上面这种“虚函数”的方式确实简单的。这和C#等OOP语言是截然相反的，OOP的语言往往继承是容易的（假设去掉sealed），但是给一个写好的类里面增改一个虚函数确实不容易的。这是一种难以两全其美的问题，有许多论文研究这点。上面的代码中，Circle和Rect被看做类型Shape的“构造函数”(constructor functions)。特别注意，Circle和Rect是constructor，但不是类型，他们构造出的是Shape类型。 Circle :: Float -&gt; Shape Rect :: Float -&gt; Float -&gt; Shape constructor functions和普通函数的区别是前者不用=来定义(no defining equations)。 同样地，data语句也可以带参数，例如经典的Maybe： data Maybe a = Nothing | Just a 这里教授又讲授了一遍自己prefer list to Maybe的理由，然后其实Maybe和list都是Monad，其实看到这里我还是挺惊讶的。于是不妨推导一下为什么list是Monad：首先介绍一个concat函数，其定义为 concat :: Foldable t =&gt; t [a] -&gt; [a] 为了理解这个定义，可以把Foldable t看做它的一个特例，也就是[]，那么concat就是将一个二维数组拍平 concat :: [[a]] -&gt; [a] 而list的&gt;&gt;=运算，即list &gt;&gt;= f可以理解为等价于concat (map f list) 特别地，对于仅有一个constructor的、一个field的类型，可以使用newtype替代data关键字 data/value constructor和type constructor作为扩展，解释一下data/value constructor和type constructor之间的联系与区别。这其实在stackoverflow上讲得很清楚。两者区别是： data/value constructor可以看做一个返回值的函数 例如本章讲的Circle和Rect，它们都能够返回一个Shape类型的值。 type constructor可以看做一个返回类型的函数 如fmap定义中的f，Monadm a中的m，实际上是产生了一个新的类型。这个有点类似于C++中的模板类，不过Haskell在这方面要更加深层次，我们将在最后的多态性专题进行讨论。 两者联系以data Tree a = Tip | Node a (Tree a) (Tree a)为例。 等式左边的Tree称为type constructor。而Tree a是一个type。 等式右边具有两个data/value constuctor，因此这个data type是多态的。 instance、type和data语句的区别instance根据class定义的type class来产生一个type constructortype用来从一个type constructor产生一个具体类型concrete typedata用来为一个type constructor提供一系列data/value constructor得到value Recursive types使用data语句定义的type可以是递归的。例如我们可以定义一个自然数类型（邱奇数） data Nat = Zero | Succ Nat 这里的Nat是一个新类型，Nat有两个constructor，它们分别具有类型Zero :: Nat和Succ :: Nat -&gt; Nat，由Ch3中学习过的，这里的::表示“具有类型”。于是我们实际可以得到这样的一个无尽序列 Zero Succ Zero Succ (Succ Zero) ... 我们看看能不能输出它 Prelude&gt; (Succ Zero) &lt;interactive&gt;:15:1: error: ? No instance for (Show Nat) arising from a use of ‘print’ ? In a stmt of an interactive GHCi command: print it Prelude&gt; print $ (Succ Zero) 可以先转换成Int nat2int :: Nat -&gt; Int nat2int Zero = 0 nat2int (Succ n) = 1 + nat2int n 然后输出 print $ nat2int (Succ Zero) 下面实现自然数类型的加法，对于C++来说，这意味着定义operator+ add :: Nat -&gt; Nat -&gt; Nat add m n = int2nat (nat2int m + nat2int n) 上面是一个很直截了当的做法，先转换成Int，加完后再转回Nat，有没有不需要借助Int的方法呢？ add&apos; :: Nat -&gt; Nat -&gt; Nat add&apos; m Zero = m add&apos; m n = (iterate Succ m) !! nat2int n 首先想到的是add m n等于n次Succ m，不过这种方法还是需要转换，于是有下面的方法 add Zero n = n add (Succ m) n = Succ (add m n) 我们把n看做常数，将add转换为一元函数g，Succ类比做+1，这就有点类似数学归纳法的味道： g (x + 1) = (g x) + 1 Church encoding和Scott encoding刚才我们看到了邱奇编码的一个常见形式，即邱奇数。邱奇数使用lambda构成的高阶函数来描述自然数。事实上邱奇编码可以用来描述一些很基本的结构，例如布尔值、元组、列表和tagged unions。以邱奇数为例，可以将0表示为\f x.x，1为\f x. f x，2为\f x. f(f x)，因此n可以表示为n F x = ($) f^n x，可以看成一个递归的函数。下面可以借助已有的邱奇数实现加法函数plus(m, n) = m + n，plus = \m n f x. m f(n f x)。这里用到了性质f^(m+n) x = f^m f^n x。 Arithmetic Expressions下面我们来为代数运算的“AST”实现一套类型系统 data Expr = Val Int | Add Expr Expr | Mul Expr Expr 注意我们将所有的代数运算定义到一个Expr类型里面，这是一个“比较Haskell”的写法。我们的代数式可以写成下面这样，从计算一个“函数”变成了构造一个Expr“对象” Add (Val 1) (Mul (Val 2) (Val 3)) 我们使用eval来计算这个Expr，可以写成 eval :: Expr -&gt; Int eval (Val n) = n eval (Add x y) = eval x + eval y eval (Mul x y) = eval x * eval y Binary Tree二叉树由叶子(Leaf)和节点(Node)构成 data Tree = Leaf Int | Node Tree Int Tree 定义了occur用来查找具有某个值的节点 Ch11 The Countdown Problem这次换了一位讲师 Countdown游戏介绍Countdown游戏中使用若干个正整数（每个数最多使用一次），使用四则运算来计算得到一个指定值，其中所有的中间结果也必须是正整数。 Haskell建模首先我们把运算定义成一个Op类型 data Op = Add | Sub | Mul | Div 然后定义一个apply，apply将一个Op作用到它的两个操作数上。 apply :: Op -&gt; Int -&gt; Int -&gt; Int apply Add x y = x + y apply Sub x y = x - y apply Mul x y = x * y apply Div x y = x `div` y 由于游戏中有正整数的限制，所以使用valid来判断某运算是否可以执行 valid :: Op -&gt; Int -&gt; Int -&gt; Bool valid Add _ _ = True valid Sub x y = x &gt; y valid Mul _ _ = True valid Div x y = x `mod` y == 0 下面定义Expr data Expr = Val Int | App Op Expr Expr 相比上一章看到的Expr，这里将Add、Mul等constructor合并成了App(application)constructor。例如1 + 2可以写成 App Add (Val 1) (Val 2) eval函数能够计算一个Expr的值 eval :: Expr -&gt; [Int] eval (Val n) = [n | n &gt; 0] eval (App o l r) = [apply o x y | x &lt;- eval l , y &lt;- eval r , valid o x y] 虽然eval返回的是一个列表，但到最后列表里只会有一个数，除非出现问题列表里一个数都没有。这里eval匹配了Expr的两个data constructor。在第二个pattern matching条件中使用到了Ch5中讲到的list comprehension，特别地，valid o x y称为guard。注意到在eval (App o l r)中，list comprehension右部给出了三个条件，这三个条件只要有一个不满足，这个list就会变成空的。 Brute force solution定义values函数，列出一个表达式中所有用到的数定义exprs函数，得出一组Int能够构造出的所有Expr，这是一个关键的函数 exprs :: [Int] -&gt; [Expr] exprs [] = [] exprs [n] = [Val n] exprs ns = [e | (ls,rs) &lt;- split ns , l &lt;- exprs ls , r &lt;- exprs rs , e &lt;- combine l r] 对于空列表和单元素列表(singleton list)这是显然的。对于多元素有序列表，我们进行divide and conquer。可以用split ns将列表ns进行分划，对于长度为l的序列，我们有l - 1中分划方案。然后我们对于每一个分划(ls,rs)，对其左右部分别递归调用exprs。于是定义split函数，列出一个列表所有的分划得到l::Expr和r::Expr，最后将这两个列表分别合并，得到App Add l r等四个结果。于是可以定义combine函数 combine :: Expr -&gt; Expr -&gt; [Expr] combine l r = [App o l r | o &lt;- [Add,Sub,Mul,Div]] 其中 perms :: [a] -&gt; [[a]] perms [] = [[]] perms (x:xs) = concat (map (interleave x) (perms xs)) 现在我们可以解决这个问题了，我们对于exprs构造出的每个expr，使用eval expr == [n]即可filter出所有可能的结果。注意到我们不一定要用尽给定的数，也不一定这些数就按照从小到大等特定的顺序排列，所以我们需要尝试给出的数的所有子集。于是可以定义choice函数，列出一个列表所有的子集 choices :: [a] -&gt; [[a]] choices = concat . map perms . subs 现在我们可以列举出所有的结果了 solutions :: [Int] -&gt; Int -&gt; [Expr] solutions ns n = [e | ns&apos; &lt;- choices ns , e &lt;- exprs ns&apos; , eval e == [n]] 此外我们还可以判断某输入能否构成一组解 solution :: Expr -&gt; [Int] -&gt; Int -&gt; Bool solution e ns n = elem (values e) (choices ns) &amp;&amp; eval e == [n] 剪枝优化考虑到valid的计算式时很少的，所以可以通过earlier rejection策略进行剪枝。 Ch12 Lazy Evaluationlazy evaluation是Haskell的一个独特的性质 求值顺序以自增函数inc为例，inc (2*3)有两种求值顺序。第一种是intermost call-by-value，先对2*3求值为6，然后计算inc 6；第二种是outmost call-by-name，先计算inc (2*3) = (2*3) + 1，然后再计算6 + 1。接着和C#中的带副作用的impure运算进行比较，说明的求值顺序不同的影响。 下面是一个Church-Rosser证明的定理，如果a可以归约为b和c，那么一定有一个d，b和c可以归约到d。 下面介绍带lambda的情况，如mult (1+2) (2+3)可以归约为mult 3 (2+3)、(\y -&gt; 3 * y) (2 + 3)、(\y -&gt; 3 * y) 5。这里教授讲了一个lambda只有在被apply的时候，才会对其内部的东西进行计算，也就是no evaluation under lambda。 call-by-value容易造成陷入无限循环，因为它必须做完所有的求值。例如fst (0, inf)，设inf = inf + 1，很显然call-by-value并不能结束(terminte)，而call-by-name能够将inf“短路”掉返回0。此外，我们还可以想到之前的无限列表。call-by-name相比call-by-value效率就会低一点了，它需要稍多一点的步骤。 综合两种求值顺序的优点Lazy evaluation通过call-by-name和sharing的方式综合了两者的优点。例如square (1+2)，可以归约为(1+2) * (1+2)，由于这里重复了(1+2)，所以可以使用late binding的原理，进行下面的归约 square (1+2) =&gt; let n = (1+2) in n*n =&gt; let n = 3 in 3*3 =&gt; 6 lazy evaluation依赖于改变计算先后不影响计算结果 bottom下面比较两个函数 filter (&lt;=5) [1..] takeWhile (&lt;=5) [1..] 这两个函数有什么区别呢？在GHCI中运行第一个函数，发现lazy evaluation并没有发生，其结果可以表示为 1: (2: (3: (4: (5: _|_)))) 这里的_|_即⊥，称为bottom，在之前的课程中也出现过，表示something that won’t terminate。而第二个函数则能够正常结束 1: (2: (3: (4: (5: [])))) strict application可以用($!)，称为strict application运算符来强制计算函数的参数 f $! _|_ = _|_ f $! x = f x 对于有多个参数的情形，可以按照以下方法 (f $! x) y -- 强制计算 x (f x) $! y -- 强制计算 y (f $! x) $! y -- 强制计算 x和y 有的时候强制计算的eager evaluation反而是更好的，例如 -- lazy sumWith v [] = v sumWith v (x:xs) = sumWith (v+x) xs -- strict sumWith v [] = v sumWith v (x:xs) = (sumWith $! (v+x) ) xs 这两者的计算结果都是6，但是中间过程会有区别。事实上，strict版本会更加节省空间，因为如果我们对lazy版本展开会发现存在以下两步的推导过程 sumwith (((0 + 1) + 2) + 3) [] ((0 + 1) + 2) + 3 所以在每一步计算中，我们都要维护一个逐渐增长的列表。但是如果使用strict版本，我们实际上维护的只有一个累加值。 Ch13 Reasoning about programs总结与专题论述Haskell的特性 柯里化和高阶函数（包括section） 惰性求值 模式匹配和guard（包括where） 类型系统和多态（包括泛型、类型类、抽象代数类型(ADT)、higher kinded polymorphic、type defaulting等） 具体特性的部分解释可以查看这个网站 Monad（包括ST Monad） 强类型、静态类型 有关多态多态(polymorphism)在C++/Java等面向对象语言中常指子类多态(Subtype polymorphism)，也就是在继承关系中子类可以修改或者扩展父类中的方法，但此时在包含关系上它也被视作是父类型的对象。例如在C++中调用虚函数时会根据当前this的类型查阅虚函数表从而选择正确的函数，这个多态是在运行期的。在Real World Haskell一书中指出Haskell虽然不具有子类多态，但它有类型多态和参数多态。类型多态是我们之前提过的higher kinded polymorphic，比如Haskell中的列表[]就是类型多态的，因为我们常常可以见到如map这样的函数中出现[a]，也就是说我们不关心a到底是什么，这里的[]也被称为一个type constructor。与此同时我们称map :: (a -&gt; b) -&gt; [a] -&gt; [b]为参数多态(Parametric polymorphism)，因为map接受的参数可以是符合某些规则的任意类型的。特别地，函数重载也被视为一种Ad-hoc多态，一个例子是12345678// https://www.jianshu.com/p/b641cf2908cfclass BasicEq a where isEqual :: a -&gt; a -&gt; Boolinstance BasicEq Bool where isEqual True True = True isEqual False False = True isEqual _ _ = False 备注在学习完这本书后，能够对Haskell的关键概念有比较清晰的理解，但是如果需要应用Haskell编程还有一些困难，这时候可以再看看另一本很好的书《Haskell趣学指南》此外，我这个笔记其实有部分的碎碎念，这导致笔记的逻辑可能不太连贯。但是我还是记录下这部分，如果有和我一样在某些地方钻了牛角尖的，至少我这里能给出我的一些见解。 【未完待续】]]></content>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++右值]]></title>
    <url>%2F2017%2F02%2F11%2FC%2B%2B%E5%8F%B3%E5%80%BC%2F</url>
    <content type="text"><![CDATA[C++11标准开始引入了右值引用的概念，容易产生下面的问题： 右值、右值引用之间有什么区别 重载决议中右值引用、左值引用、通用引用有什么区别 右值、(N)RVO之间的关系是什么 移动语义在哪些地方可以提高性能 右值与右值引用左值是不能绑定到右值引用的，如下面的代码是错误的123456789101112// code 1int i = 42;int &amp;&amp; ir = i; // error// code 2int test(int &amp;&amp; ir)&#123; // ...&#125;int main()&#123; int i = 42; test(i); // error&#125; 正确的做法是使用std::move()函数将它转换成一个右值。查看下面的代码，发现编译错误，为什么？1234int main()&#123; int &amp;&amp; i = 42; test(i); // error&#125; 42是右值，但i是个右值引用，右值引用并不等于右值，它和引用类型、指针类型一样，属于一个新的类型。这时候i是个具名对象，是个左值。C++11标准引入了右值引用的概念，但右值的概念是在之前的版本中就有的。在引入右值引用概念后，左右值也被分为左值(lvalue)、将亡值(xvalue)、纯右值(prvalue)。其中将亡值和左值合称为泛左值，将亡值和纯右值合称为右值。左值例如字符串字面量纯右值例如整型字面量将亡值包括由函数返回的右值引用或由std::move强转来的右值引用。 函数返回右值与(N)RVO什么是RVORVO不能解决callee内部的临时对象的问题，考虑下面的代码12345678X fun()&#123; X x1; // ... return x1;&#125;int main()&#123; X _x = fun(); // RVO&#125; RVO的目的是fun()的返回值在main中不会产生一个临时对象，但并不会优化掉fun中的x1。 什么是NRVO12345678X &amp;&amp; fun()&#123; X x1; // ... return x1; // NRVO&#125;int main()&#123; X _x = fun();&#125; 别忘了编译器并不一定会进行NRVO，例如编译器遵循下面一些规则： return的类型和函数签名中的返回值类型相同 return的是局部变量 条件语句返回时会抑制NRVO 使用移动语义从函数返回12345678X &amp;&amp; fun()&#123; X x1; // ... return std::move(x1);&#125;int main()&#123; X _x = fun();&#125; 这似乎“替编译器做了”RVO同样的工作，这是一个比较好的实践么？事实上这是大错特错的。首先x1是一个自动变量，它在栈上，它的生命周期到fun函数结束就终止了。std::move将x1强转成X &amp;&amp;返回，然而到了调用者main那里，x1对象早已被析构了，这个右值引用X &amp;&amp;和相应的左值引用X &amp;、悬挂指针X *一样，对该对象的生命进程是无能为力的。因此不要返回局部变量的右值引用。在StackOverflow上有关于Best Practice的讨论唯一能正常运行的代码是这样的12345X fun()&#123; X x1; // ... return std::move(x1);&#125; 在这段代码中，从函数签名上来看，我们返回的不是右值引用，而是一个对象了；但是从return语句上看，我们返回的是一个右值引用，因此阻止了编译器执行NRVO。因此这个std::move除了潜在地暗示编译器不要进行NRVO外并没有任何作用。在上面的讨论中我们知道x1自动变量并没有得到续命，我们返回的是通过X的移动构造函数创建的一个新临时变量X{std::move(x1)}。如果要返回的对象定义了一个良好的移动构造函数，那么使用这种方式返回一个非局部变量尚可一议，否则最佳的实践是直接依赖编译器提供的NRVO。12345X fun()&#123; X x1; // ... return x1;&#125; 使用移动语义提高性能如果要根据一个对象创建另一个对象，传统的方式是调用复制构造函数12X a&#123;b&#125;; // orX a = b; 让我们重新考虑之前的代码1234567891011121314151617X fun()&#123; X x1; X()&#123; puts("default constructor"); &#125; X(const X &amp; _x)&#123; puts("default constructor"); &#125; ~X()&#123; puts("destructor"); &#125; // ... return x1;&#125;int main()&#123; X _x = fun();&#125; 现在我们知道，由于(N)RVO的存在，这段代码中实际上值调用了一次默认构造函数。 虽然右值引用的“光辉”常被(N)RVO掩盖，但其能够对资源移动行为进行更精细化的定义。进一步来看，像std::move或者X &amp;&amp; fun()这样的函数，他们返回的是一个右值引用，这样的右值引用称为将亡值。将亡值是一个即将被销毁的对象。既然它马上要被销毁，而我们又要创建一个它的副本，那为什么不在销毁前把它里面的东西直接掏出来给副本呢？移动构造函数和移动赋值运算符就是做这样的事情。123456789101112struct A&#123; A(A &amp;&amp; a) : p(a.p) &#123; a.p = nullptr; &#125; ~A() &#123; delete p; &#125; int * p;&#125;; 查看上面的代码节选，移动构造函数将第一个参数将亡值A &amp;&amp; a持有的指针a.p直接取来，然后将其设为nullptr。这一步是即为重要的，因为如果不设为nullptr，在a销毁时会执行delete p，那么this好不容易从a那里掏来的p就会被销毁，this-&gt;p会变成悬挂指针。这样，将亡值a里面的东西通过了this的皮囊得到了续命。而this也避免了调用一个拷贝构造函数的开销。现在我们能够理解为什么将亡值属于泛左值，又属于右值了。属于泛左值是由于将亡值作为右值引用是具名的，这和纯右值（如字面量）不一样，所以被视为左值。作为右值是由于将亡值具有可移动性。而将亡值之所以又具名又能移动，是因为它要死了。类似地我们可以写出这样的代码1234X fun()&#123; &#125;int &amp;&amp; x = fun(); fun返回值的生命在x中得到了延长。但在cppreference的value_category词条上我看到了这样的阐述：右值可以用于初始化右值引用，这种情况下该右值所标识的对象的生存期被扩展到该引用的作用域结尾。由于将亡值也是右值，所以是不是下面的代码中也存在续命呢？1234567891011// case 1X &amp;&amp; fun()&#123; X x1; return x1;&#125;int &amp;&amp; x = fun();// case 2X get_x()&#123; return X&#123;&#125;;&#125;int &amp;&amp; x = std::move(get_x()); 首先看case 1，x1的什么有没有通过x得到延长呢？就算是延长了，也是延长了fun()的返回值的寿命，而不是fun里面的x1得到了延长，作为自动变量，x1是肯定要在栈上被销毁的。如果我们加上了一次隐式转换，可以发现这和之前在NRVO讨论的情况是一样的，自动变量只会被销毁。此外，在StackOverflow中我找到了答案，它阐释了cppreference的论点，因为有一种叫dangling reference的东西，如果将xvalue绑定到rvalue reference上就可能会产生这个。这也说明了为什么函数返回T&amp;&amp;是危险的。对此SOF上还有进一步的讨论。综上所述，当fun返回一个prvalue时，用T &amp;&amp;来续命是合法的。 注意，我们虽然定义了移动构造函数可以从old_x构造new_x，但是old_x和new_x在地址上仍然是不同的，例如被移动对象指针被其他对象持有的话，同样会发生错误。这是因为move语义并不是单纯的“移动”，而是通过默认或自定义的移动构造等函数掏空对象的过程。 拷贝构造函数与移动构造函数的关系如果一个程序中显式定义了拷贝构造函数，编译器便不会合成移动构造函数。这会造成下面的效果，如果程序中没有定义移动构造函数，那std::move会调用拷贝构造函数。 将移动构造函数声明为noexceptnoexcept在C++17标准中成为了函数类型的一部分。通常来说应该将移动构造函数声明为noexcept。特别是当你的类型会和STL中的容器一起用时，如果移动构造函数不是noexcept的，那么容器会调用复制构造函数。一个类似的考虑是是否需要将拷贝构造函数设为noexcept。 标准库容器中的右值在C++11后，诸如std::vector&lt;T&gt;的容器的push_back方法也能接受右值了，这样他们会直接移动我们传入时创建的临时对象。不过更有效的方式是使用另一个添加的emplace_back的方法。这个函数直接免去了创建临时对象的成本，而直接在原地进行构造，一如我们的placement new的行为一样，它调用std::allocator_traits::construct这个函数来创建对象。 通用引用和完美转发这一部分是针对模板变成来说的。]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode解题报告]]></title>
    <url>%2F2017%2F02%2F09%2FLeetCode%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相等(Problem 14)，std::map查找元素(Problem 1)的复杂度为1，感觉这并不是很严谨的，后来在Google Codejam/Kickstart的官方题解上也看到类似的算法，只能说这是一种计算方式吧。在刷Leetcode的时候，取得Accepted通常是容易的，但是如果能够翻翻Submissions里面速度靠前的答案，看看人家是怎么在同复杂度下进行常数优化也是很有必要的。 1. Two Sum$O(n^2)$要T的，正解对任意的i，判断target - i是否在集合s中，如果不在，把i加到集合s中。注意因为Python中dict用散列表实现，所以查询复杂是$O(1)$的，这和C++中的std::map（RBT实现）不一样。另外考虑如果给定数列是有序的，还可以使用二指针来做，这个在下面的3Sum等中非常常用了，因为sort的复杂度是$O(nlogn)$，可以直接忽略不计了。测试了一下，如果对这道题先sort一下，居然速度要快十倍。 2. Add Two Numbers链表比较麻烦，注意在两个链表全部遍历完毕后检查是否还有进位 3. Longest Substring Without Repeating Characters计算最长不重复子串从头开始遍历字符串S，记录字符S[i]出现位置到ex中。若ex[S[i]]已存在，即字符S[i]在ex[S[i]]（前出现）和i（后出现）出现过，这时候我们的最长长度便不能继续增长了，尝试用字符串S[start, i - 1]来更新最长字符串，并令start = ex[S[i]] + 1，即从S[i]前出现的下一个位置开始重新计算最长长度。这时相当于把字符S[i]从前出现移到了后出现，因此ex[S[i]]需要被更新到当前的i。有个注意点，在更新start的过程中，我们实际上重复利用了[ex[S[i]] + 1, i]这段肯定不重复的序列，包括它们的ex值，但同时我们也舍弃了[start(原), ex[S[i]]]这区间，因此在下面的遍历过程中如果字符ch对应的ex[ch]值出现在这段区间中，那实际上应该等同于它未出现处理。 4. Median of Two Sorted Arrays见文章 5. Longest Palindromic Substring马拉车算法模板题 6. ZigZag Conversion对模numRows * 2 - 2讨论 7. Reverse Integerpython转成string在转回int强行干 8. String to Integer (atoi)看图说话题 9. Palindrome Number通过整除和取余算出倒过来的数，比较和原来的数是否相等 10. Regular Expression Matching编译原理复习题，撸个DFA。这里注意一下对.规则的处理，虽然NFA比DFA多了ε规则，但是NFA对于一个某个输入符号的下一个状态是确定的。而对于.*c这样的规则，如果读取到c，那么可以仍然在本状态，也可以通过c到下一个状态，因此是冲突的，要向前看一个字符。在本题中因为字母表就在[a-z]上，于是添加26条规则就可以了。实际上可以DP搞 11. Container With Most WaterWA了n次，原来是和HDU1506直方图中最大的矩形面积搞混掉了，这个不要求连续。不会O(n)算法，看了答案发现也是DP。主要原理是对于令i, j分别为数组的左右边界，显然这样的容器最宽。把i, j相对移动，要想还比它容积大，就要比它高。于是对于任意的ii, jj，如果height[ii] &lt;= height[i]或height[jj] &lt;= height[j]那就不行了。注意不是height[i + 1] &lt; height[i]，这样遇到两个都不满足的情况就死循环了。 14. Longest Common Prefix看名字想到后缀数组，然而并不是。直接O(nm)暴力就可以了，也可以用二分，还不如直接暴力 15. 3Sum乍一看以为是01背包，然而并不是，看题目应该是和第一条类似，暴力就行了。于是照搬第一条撸了个$O(n^2)$的交上去，居然T了，看了一下T在倒数第二个点，卧槽还卡常啊。查看题解，把对j的循环和仿照2Sum的使用dict查k去掉改成双指针夹逼法。这个方法在于遍历每个i，然后对剩下的两个数j和k从j = i + 1，k = n - 1开始相向搜索。不过这次还是还是超时，根据这里的解释：But according to my submissions, this way will cause you double your time consuming almostly.，可能是我取unique拖慢了（然而排序后求unique是O(n)的啊）放一张图 16. 3Sum Closest这k-Sum的题目没完没了了。这道题也是先排序，然后双指针相向移动，同时用update函数维护一个best表示最优解。 17. Letter Combinations of a Phone Number问手机九宫格键盘上的若干数字总共能构成哪些字母，直接暴力模 18. 4Sum先放这儿吧。。 19. Remove Nth Node From End of List链表的基本操作，维护[before, begin, end]三个指针即可，注意head被删除的情况。 20. Valid Parentheses开一个栈维护就行了，注意pop的时候要先判断是不是空栈 21. Merge Two Sorted Lists归并两个数列，手残忘了cur = cur.next，然后又RE了，原来是注释的预定义部分自己不要附上去 22. Generate Parentheses卡塔兰数C(n)也表示所有在n*n格点中不越过对角线的单调路径的个数，所以直接递归搜索就全部能列出来。 23. Merge k Sorted Lists一开始是硬上21条的解法，结果T了。假设n个列表中总共有p个元素，那么外层的while循环一次添加一个元素，共O(p)次，内层的for循环是一趟n次。这种算法复杂度上限是O(p*n)。Leetcode上的top解法是(C++)调用n-1次的MergeTwoList，归并一次的复杂度是两个列表长度之和，所以这种复杂度上限依然是O(p*n)。以上两种做法Python全被卡常卡掉了（而且卡在最有一个样例，那你告诉我为啥你不也把C++卡掉）。正解是二分分治对这k个List归并，这样可以优化到O(p*logn)的复杂度。另外也有大佬直接上堆排了，我也是服 24. Swap Nodes in Pairs又是链表题，直接记录[before, begin, end]交换就行了。标算是递归，我用的迭代，迭代在更新end时要注意begin为None的情况 25. Reverse Nodes in k-Group链表逆置问题 26. Remove Duplicates from Sorted Array两个指针，i用来遍历，j用来维护插入位置即可，注意到i始终是要比j快的，所以不会产生覆盖的问题 27. Remove Element同26 29. Divide Two Integers不使用乘除和模实现整数除法，这里也不使用加减法 使用位运算实现整数加减法两个比特$x (b)$和$y (b)$相加，结果需要两个比特来盛放，可能为$00 (b)$、$01 (b)$、$10 (b)$。注意到高位的比特值为$x \, and \, y$的结果，而低位的比特值为$x \, xor \, y$的结果，于是整个结果是$(x \, xor \, y) \, or \, (x \, and \, y)$ 减去一个数等于加上这个数的补码 使用加减运算实现整数除法这里需要使用快速幂的思想，减去小于被减数$a$的尽可能大的$b \times 2^n$。这里注意的是Python中的Integer是没有范围的，所以不能使用补码等运算，对于溢出的情况也要专门判断。 1return min(max(-2147483648, res), 2147483647) 31. Next Permutation在我的某篇文章里讲过直接求nth perm的做法这道题目首先是找规律，还是挺有意思的。我们从倒数第二个数开始倒序取i，不断尝试把nums[i]与其后面满足nums[j] &gt; nums[i]的最小的nums[j]交换。实际上我们要一个在尾部的最长的下降序列[i-1, end)。我们应当从尾到头找，因为i位置后数列一定是降序的，否则i + 1位置时算法就应当结束了。交换完后，我们将i位置后的序列片段按升序排列好（这时候该片段是最小的）便得到了最终答案。如果没有的话我们令i--继续循环。 此外，Python2里面的list切片是返回的一个新list而不是引用，写代码的时候被坑了次。 32. Longest Valid Parentheses好像17年哪个公司的笔试题里面出现过这一条的。简单的思考了下，这条是DP。我们令dp[i]表示字符串在i位置最长括号串的左边界，初始化为dp = range(i)。因此对于每一个s[i] = &#39;)&#39;，我们从j = i - 1开始根据dp[j]往前跳转，直到dp[j] == j，此时我们看s[j]是否为&#39;(&#39;即可。注意最后还要根据dp算一个ans，否则()()这种情况就是2而不是4了。写的时候很粗心，WA了n次。 33. Search in Rotated Sorted Array先二分一次找到第一个比arr[0]小的点，也就是唯一一个下降点，以此点将串一分为二，对两边数组分别进行二分 34. Search for a Range同样是二分两次，第一次找到最左边边界，第二次找到最右边边界 35. Search Insert Position简单的二分 37. Sudoku Solver使用回朔法求解，代码修改自我的github在修改代码时类back_solver方法和里面的solve_iter在返回结果res时出现了为None的问题，后通过改为self.res解决。 39. Combination Sumdfs即可 40. Combination Sum II解法类似，这次每个数只能使用若干次 41. First Missing Positive在一个无序列表中找第一个没有出现的正整数。这是一个很有意思的桶排序的题目。遍历数组，使用$h(x) = x - 1$将值为$x$($0 &lt; x &lt; length$)的数与$x - 1$位置上的数进行交换，这样经过$O(n)$后数组便会变成有序的。 42. Trapping Rain Water看上去类似于第11题。首先先想naive的$n^2$解法，对于每一个位置i，分别寻找其左右侧最高的柱子l[i]和r[i]，那么i处水柱的“海拔”是min(l[i], r[i])。显然我们发现寻找左右侧最高的柱子这个过程可以DP。下面使用HDU1506直方图中最大的矩形面积的方法进行dp优化。其原理是如果j+1处水柱比j处的高，那么它肯定比r[j+1]处水柱高。 44. Wildcard Matching类似第10题，可以通过DFA来做。这里使用DP来做 45. Jump Game II青蛙跳，给定数组nums，nums[i]表示在i位置能跳的最远距离，求达到最后坐标跳的最小次数。不禁想起悲惨的LCM Walk推公式题。记到i点的最少步数是l[i]，这条naive的方法自然是对于每一个i，用它来尝试更新自己的跳跃距离范围[i, i + nums[i]]内的所有的l[j]，这样是个$O(n^2)$的复杂度，会超时。查看题解，实际上这是一个贪心问题，我们使用l记录跳s步达到的最远距离，这说明数组整个[0..l]片段至多s步便能到达。使用r记录跳s + 1步达到的最远距离，显然r &gt; l。下面我们对于每一个i，查看它需要用几步才能到达，期间需要同步更新l和r： 正常情况如果说i小于等于l，这说明i肯定是能够在s步内达到的。下面我们要尝试更新r。i位置能够达到的最远范围是nums[i] + i，这说明如果我们在s + 1选择在i位置跳，那么能够覆盖[i, i + nums[i]]这段距离。因为i &lt; l，所以在i位置跳能够覆盖[0, i + nums[i]]这段距离，我们用它和r取大值来更新r，如果需要记录起跳点p[s + 1]，这时候也应当同时使用i比较更新。 额外情况如果i大于l，即跳s步肯定不能达到了，就必须多跳一步了，此时总步数变为s + 1。这种情况是可能发生的，虽然我们遍历i是一次一格，跳是一次若干格，但遍历到i时可能已跳次数s远少于i。我们来看看跳完这s + 1步后能够达到的最远距离是什么呢？答案是i - 1位置时的范围[0, r]，起跳点p[s + 1]在小于等于i - 1的某处。如果r &lt; i的话，那么终点便是不可达的，但题目中保证了终点可达。所以我们用r来更新l。接下来，i小于等于l，我们按照正常情况继续处理。 46. Permutations47. Permutations II我这里使用了字典来维护重复的数，在Leetcode里面我看到了一个较为巧妙的处理重复的方法1234for(int i=0;i&lt;nums.length;i++)&#123; if(used[i]) continue; // 在同一个循环里面，如果i位置的值和i-1位置的值相同，而i-1位置的数没有被使用，那么i位置肯定也不会被使用 if(i&gt;0 &amp;&amp; nums[i-1]==nums[i] &amp;&amp; !used[i-1]) continue; 48. Rotate Image这让人联想到$O(1)$空间转置矩阵的题目，但本题是顺时针旋转而不是转置。由旋转公式得$ \begin{bmatrix} x \\ y \end{bmatrix} $变成$ \begin{bmatrix} y \\ -x \end{bmatrix} $。如果把这个变换看成两个变换的组合，第一个是关于次对角线的对折，第二个是关于横轴的对折，那么代码会更容易写，因为不要想inplace矩阵转置一样需要考虑一个链的问题了。这里注意一下python的列表生成器可以使用两个循环变量，如[(x, y) for x in xrange(m) for y in xrange(m - x)]，但注意x一定要在使用前有定义。本题也可以使用矩阵转置的方法来做。以3行3列的矩阵为例，将其按行展开为一维数组。得到三条变换链：0-2-8-6-0、1-5-7-3-1、4-4。容易发现对于每个链，我们用前一个位置的值给后一个位置赋值即可，如2号位的新值为0号位的旧值。不过我们还要防止重复遍历链，例如我们首先以0号位为链头遍历完第一条链，以1号位为链头遍历完第二条链，但是位置2已经在第一条链中遍历过了。为了解决这个问题，我们在位置i处要确定是否要以这个位置作为新链的链头，例如我们以2位链头开始遍历，发现在2-8-6-0-2的序列中出现了位置0是小于2的，这种情况是不可能的。容易发现每条链的链头都是这条链中位置号最小的元素，这是因为我们是从0开始按顺序以每个位置作为链头的。 49. Group AnagramsAnagrams指的是将原单词或短语字母打乱顺序，形成新的单词或短语，如“Tom Marvolo Riddle”变成“I am Lord Voldemort”这道题将单词的每个字母sort作为key，然后用dict记录每个key拥有的所有单词，最后遍历输出即可。 50. Pow(x, n)快速幂模板题 51. N-Queens在Submission里面看到有人用位运算（因为Python里面int无限大所以都不需要bitset）来搞的 52. N-Queens II受上题影响这次用位运算搞一波首先同样是按行搜索，每一行尝试放一枚棋子，递归深度$O(n)$。 53. Maximum Subarray这是一个经典的动态规划问题。由于在每一点i都可以选择继续延伸之前的串（其和为acc）或者打断重新开始。明显当acc + nums[i] &gt;= 0时保留之前的串是有增益的，否则就打断重来。使用m维护历史上最长的串的长度。 54. Spiral Matrix这条题目我思路不够清晰，主要是找规律发现数列+(n-1), +(m-1), -(n-1), -(m-2), +(n-2), -(m-3), -(n-3), ...，对第0项特别处理，然后x、y往下递推即可。查看题解发现思路更便捷一点，它的想法是依次循环将最上、最右、最下、最左的行/列添加入ans数组中，每次添加完后更新指针。终止条件是上下界或者左右界溢出。在discuss里面还看到一个骚气的Python解法，这个感觉就像我们把梨子拿在手上一边转一边削梨子一样。其中zip(*matrix)实际上转置了矩阵，如[[1,2,3], [4,5,6]]变成[(1, 4), (2, 5), (3, 6)]。而zip(*matrix)[::-1]实际上逆时针旋转了矩阵。12def spiralOrder(self, matrix): return matrix and list(matrix.pop(0)) + self.spiralOrder(zip(*matrix)[::-1]) 这里似乎在Python二维数组切片上遇到了坑，对二维数组a进行数组切片a[1:2][0]返回的是一个二维数组，而不是一维数组。由此我们看出，在写题时要是能做到先动脑，再动手，那么是事半功倍的 55. Jump Game同45，这次只要输出能否到达。 56. Merge Intervals首先是区间合并的原理，假设两个区间$(l, r)$和$(l2, r2)$，令$l2 \ge l$，则当$r \ge l2 \ge e$时区间能够合并。因此，首先对intervals数组按照左边界大小排序，然后从头开始遍历该数组，每次试图运用上面的规则合并区间。如果不满足上面的规则，那么先前已合并了的区间就是最大的区间了，将其添加入结果数组中，并对下面的数组重新开始运用该规则。 57. Insert Interval58. Length of Last Word简单题，注意要strip下 59. Spiral Matrix II这条是简单的模拟，分为4个方向，长度从l - 1到0，注意0是一个合法状态。 60. Permutation Sequence类似next_permulation函数，见POJ 1037这篇文章 61. Rotate List链表题，看图说话 62. Unique Pathsm - 1个向右和n - 1个向下自由排列共有$\frac{(m + n - 2)!}{(m - 1)! (n - 1)!} $中方案 63. Unique Paths II二维dp模板题注意初始化二维数组时不要犯[[0] * 5] * 3的常见错误，最好用列表生成器 66. Plus One处理一下进位即可 67. Add Binary见29 69. Sqrt(x)二分即可，注意取整 70. Climbing Stairs第i级可以从第i - 1级过来，也可以从第i - 2级过来 72. Edit DistanceDP是肯定的，定义数组dp[m][n]，dp[i][j]表示word1[1..i]和word2[1..j]的编辑距离，从1开始方便后面边界。首先要先确定添加、删除和替换三个操作对应到状态转移上，这容易想到对于word1来说，删除i位置意味着忽略i位置对结果的dp[i][j]的影响，所以是 dp[i-1][j] + 1，其中+ 1是删除的成本。其他两个操作可依次得出。当word1[i-1] == word2[j-1]时dp[i][j] = dp[i-1][j-1]不能漏掉。然后还要确定递归边界，不只是dp[0][0] = 0了，也要设定dp[i][0]和dp[0][j] 73. Set Matrix Zeroes根据Follow up的要求，一个使用$O(mn)$的方法是遍历一遍matrix，然后将0的格子全部填好，最后and下一个使用$O(m+n)$空间的方法是遍历一遍matrix，然后对每个0格子，标记其行号和列号，最后把所有的被标记行列全部置零最好的是$O(1)$方法，把这$O(m+n)$的空间移到matrix的第0行和第0列上。注意整个过程不是迭代的，如果一个格子被设为0，它不可以再将自己所在行列设为0。特别是第0行列的清空工作一定要在最后完成。 74. Search a 2D Matrix按行二分 75. Sort Colors根据Follow up要求，需要一趟遍历搞定。解法如26题，这里使用三个指针，i负责遍历，l维护0值区间$[0,l)$，r维护2值区间$(r, length-1]$，注意到整个过程中$i \gt l$且$r \ge l$。使用多指针维护插入位置是一个常用的方法，在三向快速排序中也有用到。题解给出了四种方法 76. Minimum Window Substring感觉有点像3，不过这道题需要考虑每个字符的数量，如minWindow(&quot;a&quot;, &quot;aa&quot;)结果是&quot;&quot;不是&quot;a&quot;这一条的思路是先找到T的匹配，然后试图移动窗口的左边界，使得匹配最小当d[ch] == cd[ch]而不是d[ch] &gt;= cd[ch]时自增计数器，这样能够保证每个不同字符在达到规定数量时刻只会被统计一次（由于先保证有匹配，再保证匹配最小，所以每个字符数量一旦达到规定数量后就会一直保持在规定数量之上）。 77. Combinations这条递归容易写T，不能新建list，题解使用了里面数组生成器，涉及到它的一些的性质。 78. Subsets此题有非递归解法123res = [[]]for i in nums: res.extend([[i]+x for x in res]) 此外对于C++可以借助于位运算的性质来做123for(int i=u; i; i=(i-1)&amp;u)&#123; // bit map i to array&#125; 84. Largest Rectangle in HistogramHDU1506老题新做 85. Maximal Rectangle这似乎是我做过的NUAA-HHU的一条赛题啊，典型的二维DP，不过实际上细节还是比较多的。思路就是从左、右、左上角三个位置DP，其中左右是最优化最长的宽为1的“条”，左上角向下拓宽是要同时考虑dp[i-1][j-1]形成的矩形的左边界以及i行的左边界取大值，向右拓宽同理。题解是借助于Largest Rectangle in Histogram的思路做的，可以参考 86. Partition List简单题 87. Scramble String一开始觉得这道题可以形成所有的排列，于是统计字符数量1WA。后来重新理解了题意，原来是树只能建一次，然后可以不停调换。显而易见这种变换有一个性质，如果我们选择一个分割点，我们便能够将其分为左右儿子，之后的调换顺序只会改变左右，不会影响分组，于是我们想到递归地枚举所有的分割点，这样可以先递归判断子树是否是Scramble的。将原问题分解为子问题（子树）的时候需要考虑两种情况，即如果我们对s1枚举到分割点为i时，那么对应到s2可以在i和len - i处分割。这条击败的不多，常数优化有待完善。 89. Gray Code格雷码，公式忘了，可以用三位找规律，注意格雷码是不唯一的 91. Decode Ways觉得很好的一题，建议先写一下练习一下搜索。Corner case是特别特别地多。这道题的正解是DP。 97. Interleaving String暴力复杂度是$2^{min(len_1, len_2)}$，为了减到多项式复杂度，通常就是上DP，和LIS啥的一样，也是二维DP。首先看最优子结构，显然在每一步，我们要么选择s1（从dp[i-1][j]过来），要么选择s2（从dp[i][j-1]过来）。然后还要与s3建立联系，于是我们定义dp[i][j]为最远可以达到的s3边界交了一发，只击败了10%。。。这常数可以的，看了看题解，还有用dfs做的 98. Validate Binary Search Tree从这题开始有一堆二叉树的题目验证一个二叉树是否是二叉搜索树，注意二叉树需要左子树上所有的节点都小于根节点，所以这条也是递归地。 99. Recover Binary Search Tree困难的地方是需要保持二叉树的原先结构 102. Binary Tree Level Order Traversal层次遍历，就是把指针形式的二叉树转成数组形式 109. Convert Sorted List to Binary Search Tree将一个有序链表转成平衡二叉搜索树。这道题应该就是不停找中点。 110. Balanced Binary Tree平衡二叉树高度差不能大于1。于是就是判断每个子树的高度差，注意还要检查子树是否递归地满足平衡性质 113. Path Sum II一个基本的遍历 115. Distinct Subsequences注意边界条件是dp[0][1..j] = 0和dp[1..i][j] = 1，不能全为0。 120. Triangle动态规划模板题 121. Best Time to Buy and Sell Stock在扫描时维护一个当前的最小值和当前的最大利润即可（一开始还想复杂了，是Easy提醒了我）。这种方法比较常用，在求最大权子矩阵中也会用到。 122. Best Time to Buy and Sell Stock II相比上面的题，我们可以进行任何次数的交易，但是不能engage in multiple transactions。只要知道(b-a)+(c-b)=(c-a)这道题目就很简单了，能赚就卖，不能赚就进 123. Best Time to Buy and Sell Stock III由于不能engage in multiple transactions，首先想到的是枚举断点，将本题转成两个Best Time to Buy and Sell Stock问题。不过显然$O(n^2)$是超时的，得DP下。所以仿照前面直方图的思路，维护一个$[0,i]$的解和一个$[i,length-1]$的解。然后再一遍扫描。这条也常数也比较大，只击败了20%左右 124. Binary Tree Maximum Path Sum说实话Leetcode的链表题和二叉树题我都不喜欢做，它的表示方法让人感觉很蛋疼，因此我写了两个辅助调试的函数，详见Github上的代码。这道题就是两次dfs，第一个dfs是求出从某个节点往叶子方向权最长的一条链，类似于求和最大的子串一样。第二次dfs连接一个节点的两个儿子，看是否能得到一个更长的链。写的时候粗心得一腿，各种漏考虑条件。有很大的常数优化空间，可以优化成一个dfs 125. Valid Palindrome这个题目挺没意思的，这里Python有个方法.isalnum() 126. Word Ladder II这道题，一看就是个bfs搜索。不过它一定要输出全部结果的全部路径，这就很麻烦。一开始写了个程序不仅T了还会M。此外“Note that beginWord is not a transformed word”并不意味着beginWord不会在wordList里面出现。最后还是T了，这条有点麻烦。 127. Word Ladder在接受了上一条T的教训后这次改用了双向BFS搜索，虽然还是T，但是点从Case22变成了Case29。后来用C++重写了一遍才过。这里先说明一下这条双向BFS写法上注意点，首先介绍一个很好的双向BFS的模板。我们首先对模板进行改进，首先如果点c被正向bfs所发现，则将vis[c]标记为1，若是反向bfs，则标记为-1。然后我们定义一个bfs(q, flag)函数，flag表示我们现在是搜正向队列还是反向队列。那么在搜索过程中，一旦我们遇到一个vis[mat[c][i]] == flag，这就说明了我们的双向bfs相遇了，于是就返回。下面的问题就是如何记录搜索深度，一开始我的想法在两个队列q1和q2中记录当前节点c的访问深度，例如正向搜索首次发现了c节点连通的子节点mat[c][i]，那么就向正向搜索队列q1中增加(mat[c][i], d + flag)，其中d是c节点的搜索深度，容易得到起始节点的搜索深度是1，紧接着的正向队列的深度依次取2、3、4等。终点的搜索深度是-1，紧接着的反向队列的深度依次取-2、-3、-4等。与此同时使用deep1和deep2来分别维护正向和反向bfs达到的最大深度。但是在提交时发现这是不对的，例如当反向队列与正向队列相遇时，相遇点不一定是正向队列最深的点。例如从cat到fin可以有下面的搜索路径，我们看到走cat -&gt; can &lt;- fan &lt;- fin是最优解，但是如果按照维护的最大值的话，我们会算上pat -&gt; paw这没用的一步。 q1 1: cat -&gt; pat q1 1: cat -&gt; can ================= q2 -1: fin -&gt; fan ================= q1 2: pat -&gt; paw ================= q2 -2: fan -&gt; can 所以我们将deep1和deep2去掉，而借助于vis[c]数组记录访问到c节点时的深度，这样我们就可以精确地知道相遇节点被正反向队列锁访问的时间了。 128. Longest Consecutive Sequence这条我是用反查字典+并查集实现的，不过其实可以直接用反查字典。 129. Sum Root to Leaf Numbers水题 130. Surrounded Regions一个DFS了，比较取巧的是可以从边界先把能保留的O筛出来，然后将剩下的O清空。 134. Gas Station首先只要gas和cost的sum至少相等就可以实现，可以用归纳法证明。其次，发现题意要求一个从唯一解起始节点i起经过所有节点的油量都大于零的性质，我们要找这个起始节点。进而可以发现从哪个节点开始找是无所谓的，因为每个节点总要经过一次。所以我们可以从例如0节点开始，在满足性质的情况下将序列向左右扩展，直到遍历玩所有的节点。一个具体的方法为首先尽可能往右移动左边界l，当l不能移动时则往左移动右边界r，直到l可以再次往右移动 135. Candy一上来就理解错误，只有当严格大于的时候才要求糖数多，例如5 5 5 5这种，每个人可以分糖2 1 1 2（当然最优解是1 1 1 1啦）然后就是硬写，首先将原数组分成上升段、平行段和下降段，如1 2 3 | 3 3 | 4 5 | 4 3。标记每一段的长度为segs[i]，每一段最后一个人的糖果为last_candy[i]个。上升段一定是从last_candy[i-1]+1开始以1为公差的等差数列。下降段末项一定是1，为了尽可能小，所以是以seg[i]为首项，-1位公差的等差数列。但如果last_candy[i-1]小于等于seg[i]，那整个下降数列放不下，所以此时要提升last_candy[i-1]到seg[i]+1（注意只要改前一个数列的末项哦） 136. Single Number老题新做 137. Single Number II这道题同样可以用异或来解决（当然也可以借助于set）。在上一题中，我们通过异或的性质，实现了值相同的数两两相消。在这一题中，我们希望出现三个相同的数才相消。 123456ones = 0twos = 0for x in nums: ones = (ones ^ x) &amp; ~twos twos = (twos ^ x) &amp; ~onesreturn ones 考虑一个比特位的情况。观察上面的代码，对于序列1 1 1能够得到(ones, twos)的值分别是(0, 0), (1, 0), (0, 1), (0, 0)。这里的&amp; ~twos用来表示进位，当twos = 1时说明目前已经出现了两次，于是我们归零ones。 139. Word Break要根据字典进行分词。看起来是一个Trie的题目，题目也没规定大小写怎么说，而且也没说是否存在唯一表示。花了很久尝试用AC自动机做，不过失败了。 141. Linked List Cycle这种链表题一般都要考虑快慢指针的解法。首先只可能有一个环，所以直接搞。 142. Linked List Cycle II比上面的一题要求找到环的起始点的位置。可以发现若第一次快慢指针交于点X，则环的长度$c$等于下次快指针追上慢指针时慢指针走过的距离。设链表头到环起点距离$s$，环起点到交点X距离$a$，交点X到环起点距离$b$，有$a + b = c$。且$2(s + k_1 \, c + a) = s + k_2 \, c + a$，有$s + a = k \, c$，即$s = kc + b$。则将两个指针分别置于链表头和交点X，其交点就是环的起始点。 144. Binary Tree Preorder Traversal前序遍历，xjb写了个非递归版本 145. Binary Tree Postorder Traversal经典的二叉树后序遍历问题，xjb写了个非递归版本 146. LRU Cache在$O(1)$复杂度下，免不了Hash。但是为了能够方便进行排序，我们又要采用一个双向链表组成队列。于是就用一个dict来定位链表里面的各个Node。 147. Insertion Sort List链表的插入排序，一开始写砸了，后来发现其实分成两个链表，从未排序的free list不停往排好序的sorted list插入元素。这道题Python居然T了、、、我也是服气。 148. Sort List写了几个辅助函数用来调试。这条就是按照CLRS上的思路写的快排，可参照第215条。居然T了 149. Max Points on a Line这是一条神经病题目，两个相同位置的点居然算不同点。所以我是不知道它怎么解释$[[1,1],[1,1],[1,1]]$输出3，$[[84,250],[0,0],[1,0],[0,-70],[0,-70],[1,-1],[21,10],[42,90],[-42,-230]]$输出6的？所以说这些相等的点互相组成直线，但是和任何其他直线都不共线是吧、、、那你告诉我为什么TestCase31输出25而不是56。。。我最后HardCode了$[[1,1],[1,1],[1,1]]$才AC的。 151. Reverse Words in a String这题有一点无理取闹的地方是要先将连续的空格合并成一个，然后就是一条经典的题目。原地解法是翻转每一个单词，再翻转整个字符串，代码只有很骚的一行1return ' '.join(map(lambda x: x[::-1], filter(lambda x: x, s.split(' '))))[::-1] 152. Maximum Product Subarray注意这条是子串而不是子序列。这个不同于最大和，可以维护一个全局最大和当前最大来做。Bruteforce的做法是$O(n^3)$的，遍历所有可能的数组，并累乘。一个动态规划的思路是维护$dp[i]$作为一个累乘序列，这样的话是复杂度是$O(n^2)$。注意遇到0之后可能认为当前数组结束了，0后面的作为一个新数组处理。不过正解是$O(n)$的，相比先前的最大和，它的转移方程考虑三个分支，分别是使用前一个dp的最大值、最小值（因为存在负数翻转的现象），或不使用。 153. Find Minimum in Rotated Sorted Array旋转数组求最小元素，这是一道经典的二分搜索题目。 154. Find Minimum in Rotated Sorted Array II一个恶心的题目，要是能一遍做对就很厉害了。这题告诉我二分法在查找更新的时候不能激进地r = mid + 1，也要考虑下r = mid这样。一般能确定mid肯定不对，那就用前者。由此严格地来做，我们可以将二分分为两种类型，F/T…TTT和TTT…F/T型，由于我们始终是要找第一个T。对于前者，如果我们fail了mid，那么我们就要更新l到mid + 1，否则更新r到mid，注意我们不能激进地更新到mid - 1，因为mid可能是第一个T。对于后者我们就要更新r到mid - 1，否则更新l到mid。下面我们考虑mid的求法时需要做到极限情况下不陷入死循环，以区间[3,4]为例。假设mid = (l + r) / 2，即mid = 3。对于前一种情况，我们OK之后会更新到[3,3]，这时候l == r，我们可以成功返回结果。对于后一种情况，我们OK之后会更新到[3,4]，这时候死循环发生了。由此我们对于后者应该做mid = (l + r + 1) / 2的更新 160. Intersection of Two Linked Lists找到两个链表的交点。注意一下链表的相交，在没有环的情况下一定是Y型而不是X型的，在有环的情况下那么两个链表一定最后进入同一个环。本题是没有环的情况，容易发现将headB的链表头接到headA的尾巴后面，那么就能把本题化为第142题。下面讨论有环的情况，首先判是否相交，根据上面的性质，我们只要找到A环上的一点，判断在不在另一个链表的环上就行了。链表相交常被用在求普通二叉树的最近公共祖先上。 162. Find Peak Element裸二分吧 164. Maximum Gap这题是求一个未排序数列的有序形式相邻两个数的最大差，要求线性复杂度。不会，Related topic显示还是sort，难道是考桶排序？xjb写了个，然后面向OJ二分桶大小就过了、、、但是这条还是需要改一下的，自己做法其实很慢，只击败了2%的人。看了一下题解，首先他根据鸽笼原理求出最大差值的下界，即$(mx - mi) / (n - 1)$，我们把它作为桶的大小，这样的好处是我们的最优解肯定不在某个桶内求得，而一定在桶间。 169. Majority Element一个很有趣的Brain teasing，要求找到出现超过floor(n / 2)次的元素 174. Dungeon Game这一条是倒推的动态规划，我们将原数组改为从1开始的数组，用need[i][j]表示从(i, j)到达公主所需要的最少HP，那么need[n][m]显然为1，我们要求need[0][0]。容易看出递推式为need[i][j] = min(need[i][j + 1] - mat[i][j + 1], need[i + 1][j] - mat[i + 1][j])。当need[i][j] &lt;= 0时，也就是说从need[i][j]往下走还会盈余HP，但是我们不能结算给(i, j)前的位置，这是由于在过程中的任何时候HP都不能小于等于0，因此不能先欠再还。实际上我们的need[i][j]必须始终大于等于1。 179. Largest Number在贪心时我们需要考虑一个问题，即类似[76, 7621]和[76, 7698]的情况，这两种情况下最优解分别为76 7621和7698 76，但是考虑[7676, 76, 98]和[7676, 76, 54]的情况就难以处理了。但其实这种情况不会存在，因为98一定会在7676前面被去掉。写了一份提交，发现死在了219Case上，简化一下发现[2, 213, 2281]这个样例，原因是2281还是比2大的。这个判断太麻烦了！后来发现还不如在两个字符串不相等时把两个字符串两种组合s1 + s2和s2 + s1都试一下看哪个大呢。在第321条中我们发现了类似的归并的问题。 187. Repeated DNA Sequences暴力dict一波？ 188. Best Time to Buy and Sell Stock IV相比III，现在我们最多可以执行k次而不是两次交易。首先想了一个xjb搞的算法，将所有的连续上升串找出来，然后排序并尝试提取出差最大的k个，这里注意如果不足k个的话也不影响，因为性质(a - b) + (b - c) = a - c。但是发现WA在了2, [1,2,4,2,5,7,2,4,9,0]，因此当我们的串的个数大于k时，我们需要尽量把这些区间合成到k个。上面的想法想了半天不知道怎么搞，于是从Best Time to Buy and Sell Stock With Cooldown那条下手，用两个数组sell和buy分别表示第i天（从1开始）做至多j个任务的最大收益。写了一个O(nk)的算法，TLE了。most_trans表示第i天最多能做(i + 1) / 2个交易。1234567for i in xrange(1, n + 1): # at day i most_trans = min((i + 1) / 2, k) for j in xrange(1, most_trans + 1): # this is j-th transaction buy[i][j] = max( buy[i - 1][j], sell[i - 1][j - 1] - prices[i - 1] ) for j in xrange(1, most_trans + 1): # this is j-th transaction sell[i][j] = max( sell[i - 1][j], buy[i - 1][j] + prices[i - 1] ) 用C++改写了一下，发现k可能非常大，虽然后来将buy和sell优化成滚动数组，但还是开不了这么大的数组。于是发现当k &gt; n时这道题实际上退化为Best Time to Buy and Sell Stock II，于是可以$O(n)$时间，常数空间解决。题解里面用最大堆的那个没有看懂。 191. Number of 1 Bits这里使用n &amp; (n - 1)去掉末尾的0，或者使用x &amp; -x取到末尾的0 198. House Robber简单的动态规划 200. Number of Islands一看应该就是条DFS裸题，转念一想像这种可以用搜索解决的集合分划问题也能用并查集搞。 206. Reverse Linked List特别经典的链表反转问题，迭代方法借助prev和cur指针。题目还要求使用递归方法。 207. Course Schedule判断一个有向图中是否存在环，拓扑排序。有关拓扑排序的内容，具体可见我的一篇博客。这边额外说一下有向图和无向图判环的方法。首先补充一下DFS的相关知识，一个无环的有向图当且仅当DFS中没有后向边，关于这个推论可以查看我的一篇博客，因此我们只要做一次DFS搜索（使用黑白灰标记），并观察是否出现后向边即可。相对于有向图，无向图还有一些额外的判环方法。首先是并查集。 208. Implement Trie (Prefix Tree)我先研究了Word Break那条，写了个AC自动机，没过，于是先把这条给水掉 210. Course Schedule II看起来是个拓扑排序 213. House Robber II相比前一条，现在要求在环上DP了。当时觉着能够化为前一条来做，不过没怎么搞明白。其实给一个Hint就是第一个和最后一个房子不能同时被抢，所以问题就分解了。 215. Kth Largest Element in an Array快排模板题，居然卡了（天哪噜，原来是两种常见写法混起来用了），既然如此就来介绍一下快速排序的两种常见方法吧。快速排序的一种经典写法挖坑法是先取p = arr[fr]为支点元素，然后我们一定要先从arr[to]开始遍历，这么做的目的是将第一个不符合的arr[j]直接赋值给arr[fr]（注意不需要交换了）。注意一些错误的算法的实现总是不能有效地将arr[fr]移动到中间位置，所以我们必须得先把arr[fr]的槽空出来。建议在写快排时每次递归始终是在[fr, pos - 1]和[pos + 1, to]递归，并且arr[pos]放支点元素。我们还要考虑把等于的放到哪边，一般来说，如果我们取arr[fr]为支点，那么我们就要把等于支点的放到右边，这样才能够先把arr[fr]空出来，在下面的一个算法中，我们看到它使用fr, l, r, to将数列分为了四个部分，从而能在最后找到arr[fr]所放置的位置。但是对于上面的挖坑法来说，这是不必要考虑的，因为它保证了将第一个换掉arr[fr]。此外，在手写快排时写完一定要查一下当第一个元素是最小时是否成立，一般算法错就错在这里。另一种方法，也是算法导论中介绍的，是仿照三路快排来做的。这种方法的主要特点是不再在数列两端来维护了，而是根据CLRS P96的那张图来维护，并且在最后唯一一次移动arr[fr]到准确位置。注意如果说要找出前K个的话，可以使用$O(n)$建一个最小堆，然后做$k$次$O(lg \, n)$的弹出。此外对这一题我还实现了一个堆排序，堆排序要稍微简单一点，我们主要注意在pushDown交换的时候，我们应当选择两个son最大的那个进行交换 218. The Skyline Problem这题实际上就是插线问点的问题，首先就是想到用离散化+线段树/树状数组来做。 221. Maximal Square这条比之前的第85条多了是正方形的条件，我们当时应该是做的这条，比矩形要简单很多 228. Summary Ranges这个我是维护每一个[fr, to]的区间，然后对每一个x二分出index表示x应该在index前面，接着查看能否将x贴到index - 1或者index上。最后查看能否合并index - 1和index。不过其实这道题很简单，因为是排好序的，所以直接xjb跑一下就完了。 230. Kth Smallest Element in a BST随便写了一下，常数应该比较大，居然还击败了66%。用一个函数index求一个节点下的count。接着用函数dfs递归，首先看左儿子的节点数是否满足k &lt;= cntl，注意k == cntl时答案不是左儿子，而是左子树中的最大值。看到一个很简洁的答案，其思路就是不停地递归左儿子，并在k上减掉已经遍历过的数量n，并返回n处的值x。容易看到当k == 0时，要求的值在左子树上，k == 1时要求的值是根，否则递归右子树。1234567891011121314151617181920int kthSmallest(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = kthSmallest(root-&gt;left, k); return !k ? x : !--k ? root-&gt;val : kthSmallest(root-&gt;right, k); &#125;&#125;int kthSmallest(TreeNode* root, int&amp; k) &#123; if (root) &#123; int x = kthSmallest(root-&gt;left, k); if(k == 0)&#123; return x; &#125;else if(k == 1)&#123; k --; return root-&gt;val; &#125; else&#123; k --; return kthSmallest(root.right, k); &#125; &#125;&#125; 233. Number of Digit One可以用数位DP硬刚，设置状态status为高位上1的数量（之前以为不需要设的）。当然这道题也有神奇的解法，具体还没研究123456int countDigitOne(int n) &#123; int ones = 0; for (long long m = 1; m &lt;= n; m *= 10) ones += (n/m + 8) / 10 * m + (n/m % 10 == 1) * (n%m + 1); return ones;&#125; 236. Lowest Common Ancestor of a Binary Tree经典的求LCA的题目。一个straightforward的做法是计算得到两个链然后求交。一个通常意义的解法是离线的tarjan。Python的Hash啊，简直蛋疼，又不能自定义数据结构，解决不了并查集的问题。用C++写了发终于过了，这里提醒一下，Leetcode的全局变量一定每次计算时要清空。 239. Sliding Window Maximum如果说需要查任意区间的最大值那么线段树是比较好的办法，不过这道题要求是用$O(n)$时间解决。这道题做完之后我看题解上是用了啥deque，但我自己做的时候直接维护了窗口两端的指针，然后分类讨论。居然击败了96% 258. Add Digits求数x0的数位和得到x1，重复上一过程直到得到个位数。要求$O(1)$复杂度。打表发现规律1 + (num - 1) % 9，然后发现其实可以用数学归纳法证明这个规律的。 260. Single Number III老题新做 263. Ugly Number没啥好说的 264. Ugly Number II想一开始用筛法预处理打个表，然而TLE了。也没发现能够从各因数的幂上发现子结构。解决方案还是从$O(n^2)$的筛法上下手，原筛法是对第$i$个丑数，看看能从先前的丑数中进行更新得到的最小值。容易发现这个过程存在很多冗余计算。例如在计算$ugly[i]$时，我们需要知道满足$x * 2 &gt; ugly[i - 1]$的最小的$x$，显然我们不需要在所有$ugly[1..(i-1)]$遍历$x$。不过我们发现每次使用$* 2$规则生成新丑数时，我们的$x$是严格递增的。递增很简单，因为新丑数比就丑数大，所以$x$要大。严格是因为所有的丑数都是偏序的。 279. Perfect Squares点开Playground看一下它附加的后台代码，发现我们打表不能打在Solution对象的__init__上，而应该打在全局。1234line = lines.next()n = stringToInt(line)ret = Solution().numSquares(n)out = intToString(ret) 282. Expression Add Operators一开始打算二分，砸了。后来打算dfs，这道题的话我们可以将算式看为若干个乘积式的加和 295. Find Median from Data Stream299. Bulls and Cows很有趣的xAyB的猜数字游戏，一道小模拟。注意有易错点11和10是1A0B而不是1A1B，因此要用dict来统计一下overlap的个数 300. Longest Increasing Subsequence最长上升子序列模板题 301. Remove Invalid Parentheses这道题要输出所有结果，那考虑考虑暴力咯。仔细查看样例，我们发现不能简单地消除能够匹配的括号。看了题解，这道题和之前的某道题一样，就是挨个从原字符串中去掉1、2、3个字符，直到形成一个合法串，然后把相同长度的都列出来。注意为了加速使用一个set来做记忆搜索。 309. Best Time to Buy and Sell Stock with Cooldown首先要思考的是如何维护DP的状态，我觉得可以直接用一个二维数组来表示，因为每一天有三种行为，买、卖和不买不卖，分别导致三种状态，因此我们可以设置数组dp[n][3]，紧接着在推导公式时我们发现一个问题，我们计算不买不卖这个状态很有难度。看答案才知道其实是想复杂了。首先它只设两个变量buy[i]表示第i天买彩票能获得的最大利润，sell[i]表示在第i天卖彩票获得的最大利润。下面我们考虑计算sell[i]，最容易想到的是如果第i - 1天买了，那么利润就是buy[i-1]+prices[i]，但是如果我第i - 1天不买不卖呢？那我们就直接使用第i - 1天的结果sell[i - 1]。计算 315. Count of Smaller Numbers After Self我是从逆序对的经典问题出发找到这条题目的，这一条朴素解法是$O(n^2)$的，但似乎不太好套逆序对的模板，因为需要求每个位置的结果，而中途的sort会改变位置。一个straightforward的做法是线段树/树状数组神器，不过常数是比较大的。但是还有一种思路，我们可以理解成从最后一个元素开始构造一个新的数列，对于每一个元素bisect_left查找它的插入位置，这就是解，搞了一发T了。通过查看Related topics我发现了二叉搜索树(BST)其实就是用来做这个的，它能够进行动态插入。这里注意一下，不要用数组来实现二叉树，容易爆内存，而且要在每个节点上维护count，否则会爆内存 319. Bulb Switcher【这道题直接打表解决了】解释一下题意，灯有1表示开、0表示关两个状态。一开始都是1，之后选择%2=1的所有灯切换状态，之后是所有%3=2的灯，一直到%n=n-1的灯。问到最后有多少盏灯是亮的。写了一个O(n^2)的T了，那应该是推一个很容斥原理一样的公式了吧？然后我打了个表。。。发现答案是3个1、5个2、7个3、、、原来是个等差数列，求和公式也忘了，直接打表和表然后二分AC 321. Create Maximum Number这一条目前还是T的状态这道题目一开始的思路就是枚举$k$，然后分别对nums1和nums2生成最大的数，最后进行归并。下面我们考虑子问题，从nums数组中取出按顺序的req个数使得组成的数最大。写了一个错误的思路是首先取ans = nums[0..req-1]，然后对于从req开始的每个数，我们找到它能替换ans的最小index位置和最大长度，例如[8,5,3,6,7]中[6,7]能够替换[5,3]。不过这个思路是错的，例如[9,7,9,1]，显然[9,1]不能替换[9,7]，但是第2个9可以替换第一个7。此外也不能从req位置开始，而应该从1位置开始。在归并时，我们要注意当nums[i]和nums[j]相等时需要向下比较，如果当其中一个数列耗尽还没比较出来大小，那就选择另外的数列为大，因为另一个数列可能下面的元素就大了。例如[0]和[0, 6]。 322. Coin Change这是一道完全背包的问题。 324. Wiggle Sort II 这道题比前面的Wiggle Sort去掉了可以相等的条件。平凡解法依旧是$O(n log \, n)$的，使用排序之后一头一尾接着取，也能AC。题目要求的$O(n)$时间复杂度和$O(1)$空间复杂度就有难度了，首先DP肯定不行了。一个初步的策略是首先算出中位数，这个有一个$O(n)$的第k大数的算法std::nth_element，然后将大于中位数的放在奇数位，小于等于的放在偶数位。注意当数列为奇数个时，中位数放在偶数位作为一头一尾。因此我们必须新开一个数组，造成$O(n)$的空间开销。题解用了一个很巧妙的思路，首先将原数列映射成[1, 3, 5, ... , 0, 2, 4, ...]的形式，然后考虑这个“新数列”。它的前半部分都大于中位数，后半部分都小于中位数。这又回到了之前的快速选择的问题上。不过这个做法还是有问题，例如[1, 3, 2, 2, 3, 1]的结果是[1, 3, 2, 2, 3, 1]。正确答案需要三向快排来处理相同值的情况。与二向划分不同的是，三向划分虽然拥有l、r、eq三个指针表示小于等于大于三个边界。但它只使用一个循环，即用eq指针从前到后遍历数组，而不是使用两个指针相向移动。当遇到大于pivot的数的时候，就把它扔到r指针位置，并更新r。当遇到小于pivot数的时候就把它和l指针互换，保证l左边都是小于pivot的数 326. Power of Three一道很有趣的题，要求不使用循环和递归来判断一个数是否是3的整数幂。我能想到是log，还有一个蹩脚的二分搜索。一个应该是最优解使用int范围内最大的3的幂1162261467来模这个数看是否能整除。这里用log+python的is_integer写了一发，发现math.log(243, 3).is_integer()返回False，所以还是要自己用eps判定下。 329. Longest Increasing Path in a Matrix这道题挺有意思，Topic有拓扑排序、DFS和记忆化搜索在里面。这道题同信封那条一样是天生偏序的，所以我们不需要vis数组，所以可以通过非常基础的DFS解决。题解中还提到了可以借助于拓扑排序来做，原理也很简单，因为矩阵中相邻节点的偏序关系可以类比成有向边，因此拓扑序一定存在。 337. House Robber III这贼真是辛苦啊，这次是带权二叉树，同样不能相邻。感觉是树形DP模板题吧，一搜POJ2342。我们使用dp[i][0/1]表示是否抢劫第i个节点的情况，那么可以得到 dp[i][0] = max(dp[lson(i)][0], dp[lson(i)][1]) + max(dp[rson(i)][0], dp[rson(i)][1]) dp[i][1] = value[i] + dp[lson(i)][0] + dp[rson(i)][0] 容易看到这个DP可以用一次DFS求得 332. Reconstruct Itinerary这道题之前好像在哪个微博上看到的，我还评论了一种可能的拓扑排序的做法。不过这道题目并不能这么做，因为我们可能重复到达某个机场（例如case2），因此并不存在一个特定的拓扑排序。那这道题就是一个简单的DFS么？也不是，虽然我们要求出发机场相同时按字符串大小选择目的机场，但这一切要建立在整个行程单存在的情况下！例如[[&quot;JFK&quot;,&quot;KUL&quot;],[&quot;JFK&quot;,&quot;NRT&quot;],[&quot;NRT&quot;,&quot;JFK&quot;]]就应该选择先去NRT而不是KUL。 338. Counting Bits这条虽然可以按191的思路做，不过更好的方法是DP，以0011b为例，它中1的数目ans[0011b] = ans[0011b &gt;&gt; 1] + (0011b &amp; 1) 343. Integer Break经典的整数划分问题。这道题我记得看过推导是分成$N/e$个数为妙，不过我最后还是做了下记忆化搜索解决的。注意因为题目要求至少分两块，所以我们要存两个dp，一个是必须要分的，一个是可以不分的。这里额外说一下几个常见的整数划分问题： 将n划分为若干整数之和 12// 这里k表示不超过k的整数dp[n][k] = dp[n - k][k] + dp[n][k - 1] 将n划分为若干不同整数之和 12// 这里k表示不超过k的整数dp[n][k] = dp[n - k][k - 1] + dp[n][k - 1] 将n划分为k个整数之和 12// 其中第一项为划分中不包含1的情况，第二项为划分中包含1的情况，注意不是dp[n][k - 1]dp[n][k] = dp[n - k][k] + dp[n - 1][k - 1] 354. Russian Doll Envelopes这题很好用记忆化搜索做，因为信封之间是偏序的，即如果信封A能dfs到信封B，则信封B肯定不能dfs到信封A，因此dfs的时候不需要维护状态。不过撸了个Python版本的，超时了。后来发现要$O(nlogn)$才能保证过，不过C++又没卡住$O(n^2)$的复杂度。后来发现这道题可以转化为LIS来做，把w看成横坐标，h看成纵坐标，我们实际上是要找h的最长的上升子序列。注意为了处理横坐标相等的情况，需要在此时将纵坐标从大到小排列，以便bisect_left能够定位到准确位置。 357. Count Numbers with Unique Digits又到了我喜欢的数位DP时间。又被算公式的大佬虐了，由于这条的区间很整，所以算公式反而简单。 363. Max Sum of Rectangle No Larger Than K这道题到现在还是T的状态。这道题和前面的Maximal Rectangle有点像，这次我们来看一个不一样的DP方法，也就是将其转化为一维DP问题来做。这条的复杂度应该是$O(X^2 \times Y \, logY)$，其中$X, Y$分别为矩阵的长和宽之间的较小/大值。前面的O(X^2)很简单，可以仿照红书上的最大权自矩形来做。假设这个矩阵列数很多，我们维护一个列的累加和sum 1 1 1 1 1 1 1 1 1 =&gt; 2 2 2 1 1 1 3 3 3 然后我们枚举所有的(up, down)，例如当枚举到(1, 2)时，我们计算一个sub表示所有上底为第1行下底为第2行的“棍状数列”的和。接下来我们采取同样的办法计算sub的累加和arr sub = (3-2) (3-2) (3-2) = 1 1 1 arr = 1 2 3 于是我们的任务就变成了在arr中找到$l &lt; r$，使得$arr[r] - arr[l]$是满足小于$k$最大的数。因此我们可以从i开始遍历arr，然后在一个数据结构内花$O(log n)$查询最接近$arr[i] - k$的值，然后再花$O(log n)$将$arr[i]$放到这个数据结构里面。显然我们可以用一个二叉树来维护，但是我T了，不知道为啥这里说明一下题解上有人用bisect.insort()，注意这个复杂度是$O(n)$的，我之前写的代码效率不高，所以被卡常了。倒是C++里面的set和map啥的有lower_bound。使用二叉树之后反而更垃圾了。 368. Largest Divisible Subset第一眼看到，觉得是一个LIS的题目。结果也确实就是这么简单，$O(n^2)$直接过了 375. Guess Number Higher or Lower II简单写了个dfs结果T了，加了个二维的记忆化搜索就AC了。。。注意数组要开到1000。 376. Wiggle Subsequence一开始的想法是仿照直方图那一条，对于每一个位置i，找到它前面的up和down位置，然后统计lenup和lendown，但这个思路是错的，因为我们不一定会从前一个位置开始。现在我们考虑能不能将这道题转化为最长上升子序列LIS来做。用up[i]表示长度为i的最后为上升序列的末尾元素的值，而down[i]为最后为下降序列的末尾元素的值。不过后来发现这个不能做到是有序的，所以没办法二分。因此实际上我们只要从尾部开始遍历即可。然后发现题目要求是$O(n)$的，看了题解，这道题有一种很妙的贪心方法。1234567891011121314151617def wiggleMaxLength(self, nums): """ :type nums: List[int] :rtype: int """ p = 1 q = 1 n = len(nums) if n == 0: return 0 for i in xrange(1, n): if nums[i] &gt; nums[i - 1]: p = q + 1 elif nums[i] &lt; nums[i - 1]: q = p + 1 return min(n, max(p, q)) 377. Combination Sum IV看起来这道题目要求一个完全背包有多少组解。不过后来发现，我们要求的是排列数而不是组合数。这反而简单了，事实上这类似之前的整数划分问题。我们用dp[i]维护和为i有多少种方案，则我们对于所有i，尝试对所有的nums[j]，更新dp[i + nums[j]] += dp[i]。这类似于之前算平方数的解法。 378. Kth Smallest Element in a Sorted Matrix这道题很简单，直接模拟归并排序就行了，我用了堆来简化。二分答案应该也可以做，没有试。 390. Elimination Game这道题和经典的约瑟夫和问题看起来有点像。当时觉得每次的起始值难算，所以就简单模拟了下，T了。继而我们发现对于任意偶数n，n + 1的答案和n肯定是相等的。看来需要$O(logn)$的复杂度了。于是觉得确实可以把每次扫描数列作为一个子问题，但是我们现在对某个子问题不生成新数组，而是在原数组上进行操作。于是我们维护了s和e，表示我们的起始点和期望的结束点（也就是现在子数列的最末端），设置step为当前的公差。如对1 2 3 4而言，s为1、e为4（不是3），而step为2。容易发现由于我们是偶数项，所以我们只能遍历delta = 2项，并没能遍历到4。我们发现规律，我们每次遍历，要不能遍历到e要不我们能遍历到actual_e，并且actual_e和e相差step / 2。于是我们能够得到新的起点的位置12345if actual_e != e: news = e // Or news = actual_e + step / 2else: news = e - step / 2 392. Is Subsequence求串s是否是串t的子序列，s范围到500000。朴素做法就是贪一下，$O(n^2)$。【这道题还有Follow Up】 396. Rotate Function一看这道题想到的第一就是排序不等式，不过这道题只能rotate而不是任意shuffle，所以不能直接套排序不等式。一个直截了当的办法，根据Topic中Math的提示，我们需要推一个公式。首先我们设首项$X_0 = \sum^{n - 1}_{0}{i \times a[i]}$，则$X_k = \sum^{n - 1}_{0}{((i + k) \% n) \times a[i]}$，发现减不了。不过如果直接找规律的话，我们发现$X_i$就是将第$(-i) % n$项置为0，然后其他项都自己加上自己下。因此递推公式很好求了$X = X - (n - 1) * A[(-i \% n)] + s - A[(-i % n)]$ 397. Integer Replacement一开始我的想法是能/2就/2，因为除法始终能减少一位，而减法只有在2的整数次幂的时候才会减少一位。下面要考虑的就是当低位为k个0的时候我们如何选择是+还是-。显然如果低位只有一个连续的1，那么肯定选择-，如果低位只有两个连续的1，我们分别计算，如果选择+，那么最快的转化是0b11 -&gt; 0b100 -&gt; 0b10 -&gt; 0b1，如果选择-，则最快的转化是0b11 -&gt; 0b10 -&gt; 0b1，因此选择-。同理我们发现当7时两者相等。不过这种解法WA在了1234，我的答案是17，而标准答案是14。后来发现把if n &amp; x == x写成了if n &amp; x，不过10000WA成了17。于是对拍了一下，发现59（0b111011）这个点WA了，正确答案应该是8，应该首先变为0b111100，这样前面就变成了4个1了。这是因为末三位011的策略被选为了-，而正确的策略应该是+。因此我们发现先前的最优策略建立在不考虑高位的情况下，而这对于3来说是不适用的。现在我们综合考虑高位有1的情况，如1011/10011等，我们发现这种情况下应当选择+。12345678910// ACelif (n &amp; 3 == 3) and (n != 3): n += 1else: n -= 1// WAelif n &amp; 7 == 7: n += 1else: n -= 1 403. Frog Jump有n个石头，坐标给定。青蛙在第一个石头上，希望能到最后一个石头上。青蛙第一次只能跳一格，假设第i次跳了k格，那么青蛙第i + 1次能跳[k - 1, k, k + 1]格，注意青蛙只能往前跳。问青蛙能否做到。记搜一波呗，T在Case 34，后来加了个剪枝，A了，不过只打败了3.9%。题解给出了一种更好的办法，也就是用int key = pos | k &lt;&lt; 11;做key，然后hash，而不是用二维数组。 407. Trapping Rain Water II这次是二维的问题了，然后我们要注意边缘没有“墙”，也就是四周无法盛水。一开始想的是假设从点$(x, y)$往下倒水，那么水最多能流到哪里，后来发现不好操作，因为每一点的水位高度取决于其周围的方块高度，而这个是递归的。后来发现我们不考虑灌水而考虑漏水，可以将场景看成亚特兰蒂斯，然后水从边缘逐渐退去。我们用level[x][y]表示点$(x, y)$处的水位，我们查看从$(x, y)$能不能放跑其周围方块$(nx, ny)$中的水，这体现在$(x, y)$处的水位level[x][y]低于$(nx, ny)$的水位。我们注意要保证$(nx, ny)$的水位是至少heightMap[nx][ny]的，这样就相当于没有存水。但是我们却不能一开始就设置level[nx][ny] = heightMap[nx][ny]，这样我们就无水可漏，倒是在边缘的level要这么设，因为他们一定不能存水。然后发现其实一开始的思路也可做，不过我们首先需要按高度从低到高选取方块。为了实现这个顺序，我们需要进行优先队列+BFS。每次我们从优先队列中取出水位level（注意不是heightMap）最低的方块，然后查看它是否可以存放更多的水。这里有两种情况，第一种是该方块的四个邻居严格高于自己，这样我们可以补齐该方块的水位。第二种是出现了水位相同的邻居，这时候我们需要用一个dfs来搜一下。 410. Split Array Largest Sum将长度为n的串分为m块，要求最小化最大的块的和。能贪么？想了想[2, 5, 6]分两块，贪的话就[2]、[5, 6]了。用DP做，发现我们要求的是min-max在i位置在第j块的和。这道题的DP做法我们同样是维护dp[i][j]为前i个数字分成j组的最小的子数组最大和。计算dp[i][j]时我们可以考虑将它放到前一块中去，或者新开一个块，因此递推方程是dp[i][j] = min(max(dp[i - 1][j - 1], nums[i]), dp[i - 1][j] + nums[i])。但这个递推式是错的，连题目给的样例都通不过。这是因为我们不能断定在i - 1时就是最优子结构，因此我们需要遍历所有的dp[0..(i-1)][j - 1]才行。题解还说原来这条可以二分答案。。。。因为是非负整数。。。。唉，果然二分答案和记搜是拯救DP苦手的神器啊！ 413. Arithmetic Slices给定一个序列，问有多少个子串是等差的。感觉很简单啊，因为是子串而不是子序列嘛，直接统计一下完事了。 416. Partition Equal Subset Sum背包问题不解释 421. Maximum XOR of Two Numbers in an Array要求在线性时间内找到数组中两个元素的异或的最大值。看看相关Topic，居然是Trie？想了想确实有道理，整个过程类似于在Trie树上递归，对于Trie树的某个节点有0个或1个孩子的情况都很好处理。但当某个节点具有两个孩子时就比较麻烦，我们需要跨两个树进行比较，看来我们不应该在树上递归。这道题目挺难的，我直接看题解了。首先我们尽可能地希望高位是1，然后对后面的位我们迭代解一个子问题，迭代次数是和字长相关的常数。因此在第i次迭代中我们希望能够用少于$O(n^2)$的时间来判定当前i - 1位是最优的情况下，第i高位是否能取到1。以样例3, 10, 5, 8为例，其二进制[0011, 1010, 0101, 1000]。首先查看这四个数的最高位[0, 1, 0, 1]，我们需要检测是否有两个数满足$a \hat{} b = 1$，这同样是个$O(n^2)$得到过程。为了能够减少复杂度，我们可以运用异或的性质$a \hat{} b = x \Rightarrow a \hat{} x = b$，将问题转变为是否存在$a, b$满足$1 \hat{} a = b$，因此我们只要维护一个Map或者Dict对于任意的$a$，寻找Map或者Dict是否存在$1 \hat{} a$，总复杂度可以降为$O(n)$或者$O(n \ lgn)$。在实现的时候，我没有用Map或者Dict，而是用了Trie，这样做前缀比较方便。【这道题还有其他的解法】 424. Longest Repeating Character Replacement允许替换X次，求最长的Repeat子串。这道题我们要注意必须向两边搜，例如BAAAB，不能以开头的B为主元。因此朴素是$O(n^2k)$的，我们需要枚举向两边搜的长度。然后我想到能否二分答案，对于每一个可能的长度length，我们找到所有的s[i:i+length]，来验证它们是否可行。这样的验证是平凡的，我们只需要找到数量最多的元素，看看它的数量加上k能不能大于等于length即可。这个方法是$O(n^2 lgn)$的，T了，这是因为check函数是$O(n^2)$的，我们可以优化掉一个$n$，但这仍然是T的。后来我发现其实完全没有必要二分答案啊，我们将k移到不等号的右边。 446. Arithmetic Slices II - Subsequence首先来一波暴力的dfs，果断T了。看看能不能改成记搜，这里的麻烦之处是状态很难解决，因为公差和末项可能很大，难以存储。然后我想到$N$只有1000，所以可以离散化公差是一个思路，不过好像还是会超空间。通过题解，发现可用数列的末两项（用首两项也行）来离散化首项+公差，不过这次T在了69/101，比之前的39/101稍有进步。后来给l == 1也加上记搜，发现就WA了，后来想想居然也不知道为啥l == 2情况记搜就能过，先放这儿把。不过发现都不能记搜l == 1的情况，否则结果都会被置为0（如果先搜不选的情况的话）。以末两项[2, 4, 6]为例，考虑我们2不取，这时末两项为(4, 6)且l == 2，不能构成等差数列，那么搜索会记dp[1][2] = 0，仔细考虑这种情况，是因为我们没有将l`纳入考虑。再考虑首两项的情况也类似。 这道题之前一直尝试记忆搜索，不过一直没搞定，后来发现直接DP反而更简单。不过后来发现O(n^3)会T在78/101。后来看了题解知道由于可能的差是很少的，所以我们可以维护一个反查的dict。 449. Serialize and Deserialize BST由于是BST，所以根据中序遍历就行了，但是这道题我用Python写在最后一个点MLE了。。。 451. Sort Characters By Frequency简单题。 452. Minimum Number of Arrows to Burst Balloons有若干起点和终点的horizontal线段，问最少用多少条vertical直线才能全部与它们相交。这道题并不是问若干直线最多能经过多少条线段，而是需要全部相交，那么方法就很明显了，按照起点排序然后贪心。 453. Minimum Moves to Equal Array Elements操作只能是对n-1个元素进行自增。我们注意到对n-1个元素自增相当于对唯一一个元素自减。 462. Minimum Moves to Equal Array Elements II相比上一题，这道题允许选择任意元素+1或者-1。一开始我觉得是尽量往平均数靠拢，但Case[1,0,0,8,6]会WA。其实这道题是求绝对值距离最小，通过Google，这其实是最小一乘法的一个结论，应当选取中位数。Leetcode上还提供了一个类似贪心的解法，也就是先排序，然后每次选取一个最高分一个最低分，让他们相等，然后去掉。 464. Can I WinAlice和Bob轮流从[1..maxChoosableInteger]中取数字加到一个总和上，不能重复取，最先达到或者超过desiredTotal的就胜利。问先手能不能胜利，maxChoosableInteger小于20，desiredTotal小于300。先来个AlphaBeta剪枝（原理见486），WA了，10 40的样例我输出true。去掉剪枝，连dfs都是错的，反省一下自己的思路，我是直接dfs，然后当和大于desiredTotal，就更新self.best，这是错误的，因为没有考虑对手的optimal选择。其实来一波记搜就好了。注意记搜不要和AlphaBeta剪枝一起使用。 486. Predict the Winner两个人轮流从数组两端取数字，和最大的胜利。数组最长为20。本题可以用AlphaBeta剪枝来做，Python会被卡掉，但是C++能过。AlphaBeta剪枝的主体仍然是一个dfs，并且我们需要一个评价函数来评估目前的局势。Alpha指的是在自己的回合（MAX节点），自己能确保的最利于自己的值。Beta指的是在对手的回合（MIN节点），对手能确保的最不利自己的值。MINMAX博弈假设对手拥有完全信息，总是能做出完美决策，所以对手要最小化评价函数的增益。容易发现初始情况下取Alpha/Beta为-Inf/+Inf，由于我们还没进入游戏，所以这是可能的最高/低分。容易发现我们的目标是尽可能提高Alpha值。现在考虑DFS的过程，我们首先以一个MAX节点作为根往下遍历，我们首先递归地计算其第一个MIN子节点的Beta值（MIN节点的计算将在下面论述），这时候根节点取该Beta值为自己的Alpha值。从目前看，结果不会比它更坏，但是我们不能就此停住，而是要接着遍历，看看有没有更好的结果，即我们取所有的Beta值里面最高的作为我们MAX节点的Alpha值。在计算完第一个节点后，我们递归计算第二个MIN节点，在计算开始时，我们要通知这个MIN节点当前的Alpha值。下面我们来跟踪这个MIN节点计算自己的Beta值的过程，MIN节点的子节点是MAX节点，所以这个MIN节点需要取自己所有子节点的最小的Alpha值作为最终的Beta值。ALphaBeta剪枝认为此时不需要遍历所有的节点，因为一旦我们发现当前的Beta值低于父MAX节点所通告的Alpha值，那么我们在父MAX节点肯定不会选择我们当前的MIN节点了，于是可以剪枝，即我们不需要算完这个MIN节点了。同理，以某个MIN节点为根向下遍历，也是先选取第一个子MAX节点的Beta值，然后通告给第二个子MAX节点。由于根节点MIN要选择尽可能小的，所以如果子MAX节点的Alpha值大于通告的Beta值，也进行剪枝。对于本题，剩下的工作就是选取一个适合的评价函数，这里选取两者和的差即可。 493. Reverse Pairs这是一个变种的逆序对，即现在逆序对不仅是nums[i] &gt; nums[j]，而要满足nums[i] &gt; 2*nums[j]。一般逆序对可以借助于树状数组和分治法来做。这条如果用树状数组来做的话，需要离散化。在离散化的同时需要处理好找不到的两种情况。 494. Target Sum这是一条变种的01背包，我们需要求一个和为(S + sum(nums))/2的子集。 495. Teemo Attacking这道题就是说在技能冷却的时候放技能不能重复统计技能有效时间，数组是有序的，因此我们直接维护一个边界r，每次根据起始时间是否与r重叠讨论，最后更新r即可。 498. Diagonal Traverse对角遍历矩阵。这道题其实不难了，遍历就两个方向交替，主要就是越界时改变方向需要想几个样例找规律即可。总结下来就是一般出格时只需要将导致出格的那个速度分量保持不动，另外一个坐标直接+1。不过还有一个特殊情况就是在矩阵四角，两个速度分量都会导致出格。 547. Friend Circles统计连通分量了，和之前一条海岛的题目挺像的，直接DFS。 552. Student Attendance Record II这道题当时想直接推个公式，但是好像比较难。然后我决定分两部分来考虑，首先不考虑缺席A的情况。那么问题变成计算不能超过连续两个迟到L的方案数。这是一个简单的DP。我们分别用P[i]和L[i]表示第i天选择出勤和迟到的方案数，则递推关系如下。1234# 第i天出勤则第i-1天可以出勤或者不出勤P[i] = (L[i - 1] + P[i - 1]) % M# 第i天不出勤，要么第i-1天出勤，要么第i-2天出勤，不能两天都不出勤L[i] = (P[i - 2] + P[i - 1]) % M 下面我们考虑缺席A就很简单了，假设一次不缺席，问题退化成上面的解答。假如缺席一次，我们就枚举缺席的那一天，然后题目变为了两个上面的情况。 554. Brick Wall556. Next Greater Element III这个类似Next Permutation那条，直接找到第一个上升型，然后用它之后的大于它的最小数来交换。注意要判断爆int的情况，WA了好几次。 657. Judge Route Circle弱智题 712. Minimum ASCII Delete Sum for Two Strings字符串编辑距离的魔改版，挺简单的。注意dp[i][0]和dp[0][j]要作为边缘条件提前算好。 714. Best Time to Buy and Sell Stock with Transaction Fee现在买卖股票需要缴手续费了。相比Best Time to Buy and Sell Stock II，我们需要知道并不是交易越多越好了，例如[1,3,7,5,10,3], 3。一开始我打算生搬硬套Best Time to Buy and Sell Stock IV的办法，然后T了。然后发现这道题和交易次数没关系，所以将内层循环去掉了，就过了。 719. Find K-th Smallest Pair Distance这个并不是最近点对，因为它是一维的。这道题解法挺多的，我建议最后都看一下题解。主要思路是二分答案gap，然后有两种方法来算有多少个点的距离小于等于gap。第一种方法我们维护lt_cnt[v]表示小于等于v的点的数量，那么我们就可以用lt_cnt[nums[i] + gap] - lt_cnt[nums[i]]来计算对于点i有多少个点j和自己的距离小于等于gap的。然而这是错的！因为我们还要考虑到i重复值的情况。因此我们需要用strk[i]来维护下连续的i的个数。我们注意下这种方法彻底避免了其他的办法陷入重复统计的困扰，因为它值使用一个指针i。第二种方法是使用滑动窗口来直接算，这个方法需要小心避免重复计算的情况。 738. Monotone Increasing Digits找到小于等于n的单调递增数（不一定要是严格地）。 739. Daily Temperatures直方图那条吧，水题 780. Reaching Points按照(x, x+y)或(x+y, y)的规则走路，问是否能够从(sx, sy)走到(tx, ty)。这道题挺有意思的，让我想到LCM Walk这道题。LCM这道题是按照LCM(x,y)来更新的，实际上是一道数论题。这道题更简单，肯定也是用数学做，当然你爱用矩阵搞事情也行、、、这一道题的简单之处在于我们不需要证明从终点往起点走的唯一性，因为数都是大于0的。这里注意一个细节，为了不t，我们会批量减，但是我们要注意减去的tx和ty最少要是1个，最多不能使得到的差小于sx和sy，否则会丢失结果。 790. Domino and Tromino Tiling问用2x1和短L型方块铺满2xN的板子有几种方案。这道题是一个有趣的动态规划，我们可以设dp[i][0]为刚好填满第i个槽的方案数，设dp[i][1]为填满第i个槽但是在第i + 1个槽鼓出来的方案数。我们可以对五种情况进行讨论，具体可以见我代码里面的注释。在写的时候WA了几次，都是方案没有考虑周全。 801. Minimum Swaps To Make Sequences Increasing咋一看因为是逆序对。不过这个是在两个数列对应位置之间进行交换。这个直接xjb动态规划了，按照套路设S和NS两个数组表示是否交换i位置，然后根据是否交换i - 1地推即可。 823. Binary Trees With Factors这道题要求用数组A中的数组成二叉树，要求二叉树的父亲等于两个儿子的乘积，问有几种方案。这题显然就是dp了，我们首先sort一下，然后用dp[i]表示第i个节点为根的二叉树有多少种排布方案。我们只需要枚举[0, i)区域内节点作为lson，然后查看是否存在rson即可。 835. Image Overlap]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去除reimage repair恶意广告软件]]></title>
    <url>%2F2017%2F02%2F08%2F%E5%8E%BB%E9%99%A4Reimage%E6%81%B6%E6%84%8F%E5%B9%BF%E5%91%8A%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[今天发现自己的Chrome上超链接被篡改了，在点击这样的超链接时，会打开一个独立窗口并跳到某个广告页面然后窗口自动消失，并且扩展程序页面chrome://extensions打不开了。后来发现这是一个叫reimage repair plus的恶意广告软件导致的 这几天发现超链接被篡改了，之前以为可能是某些网站自己的行为，后来发现Google也被篡改了，所以怀疑是恶意软件。跟踪了几个网址，发现经常转到www.reimageplus.com这个地方，搜一下，原来是个臭名昭著的软件。网上推荐了AdwCleaner，使用这个软件扫描了下，出现了一堆腾讯XX盒子、百度XX、迅雷XX的东西。可能是这些软件更毒吧。因为AdwCleaner没有用，继续搜索发现zhihu上有同样的问题，那人还说“扩展程序处 一点页面就会一闪然后自动关闭了”，这不就是我Fiddler安装之后的问题么？我马上联想到我最近安装了Fiddler，这个软件之前之前抓包的时候把我的IE给搞了（后来发现好像是加了个代理啥的，不能怪它）前几天为了抓包又装了Fiddler，没过一会儿他就自动升级成Fiddler4了。Fiddler抓包的时候需要重置默认代理，于是我把Proxy SwitchyOmega关掉，抓完之后（妈的不是HTTP包，还是用WireShark吧）想把Proxy SwitchyOmega再开下来，发现chrome://extensions打不开了。于是设置里面重置浏览器，然后就可以打开了。没想到余孽并没有被清除。于是我卸载掉Fiddler，并重置Chrome，于是这问题就不再发生了。 此外给一个删除Chrome的扩展的小Tips，有的时候我们发现自己移除扩展之后重启Chrome又出现了，这是由于Chrome的同步机制，将设置-同步-扩展程序/应用取消掉再重启即可。]]></content>
      <tags>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode4 Median of Two Sorted Arrays]]></title>
    <url>%2F2017%2F02%2F04%2FLeetcode4_Median_of_Two_Sorted_Arrays%2F</url>
    <content type="text"><![CDATA[LeetCode第4题，求两个数组nums1和nums2的中位数，要求对数复杂度。这个思路很清晰，就是二分。一开始想的lower_bound比较一波，算一下偏移，然后两段去掉相同数目的元素，构成一个子问题。不过实现的时候被字符串常见的边界情况和上下中位数困住了，想了好久，后来发现其实自己想复杂了，这就是一个求第k个数的问题，直接二分答案就好了。设nums1[m1]和nums2[m2]为两个数列nums1[0..n1-1]和nums2[0..n2-1]的中位数（长度为奇数）和上中位数（长度为偶数），显然当nums1[m1] = nums2[m2]时为一个结束条件，此时按照奇偶长度判断一下即可。当nums1[m1] &lt; nums2[m2]时，显然m2取大了，m1取小了，此时中位数应该位于nums1[m1..n1-1]和nums2[0..m2]里面，注意中位数仍然可能取m2的，例如nums1 = [1, 2, 3, 4]、nums2 = [1, 3, 4]的情况，同理中位数也仍然可能取m1。但是如果单独拿出这两个片段来更新，仍然得不到子问题，因为中位数虽然在这两个片段内，但是这两个片段的中位数并不一定等于原数组的中位数。因此产生了两种想法：第一种做法试图去掉相等数量的最小值和最大值，形成依然“对称”的数组；另一种做法是不追求切完的数列依然对称，而是直接记录去掉了多少个最小值，因而新的数列中还需要去掉多少个最小值，实际上转化为求第k个小数的问题。在实现上第二种方法是高效而简单的。 对于第一种方法。假定nums1[m1] &lt; nums2[m2]，令j = lower_bound(nums2, nums2 + n2, nums1[m1])，其中lower_bound二分搜索可以使用python中的bisect.bisect_left代替，显然j &lt; m1，所以如果按照(m1, j)来分割，则小端变少了m2 - j个，因此nums2的分割点应该位于[j + 1, m2 - 1]这个区间内。同理，令i = upper_bound(nums1, nums1 + n1, nums2[n2])，nums1分割点应该在[m1 + 1, i - 1]这个区间内。一个比较简单的想法是，分别对于两个数列直接去掉min(n1, n2) / 2个元素，这样是为了保证两个数组都有足够的元素可以取。此外要注意min(n1, n2) / 2 == 0的情况程序会陷入无限递归的情况，这是由于某一个数组的长度为1导致的，所以预先判定下数组长度为1的情况，写下来代码是这样的但是这样会WA，Leetcode可以直接告诉你哪一个点WA了，于是发现对于数据[1, 4], [2, 3]是不正确的。其实这个程序每次去掉的未必是最小的数，因为最小的数未必在中位数小的数列中。 下面我们查看第二种方法，这里选择直接二分值而不是下标。对每个二分出来的值，再在两个数组中找到它的插入位置i和j，并比较i + j和k的大小，如果大了，说明中位数取大了，取左区间继续二分。附上代码这里注意两点，第一是lower_bound(nums1, nums1 + len, mid)始终返回是nums1中mid上确界的下标，如果mid大于nums1中所有数，下标是nums1.end()，直接取值会造成nums1越界，例如[1, 2], [3, 4]的情况。出现这种情况是因为mid取小了，而nums1整体小于nums2，lower_bound从nums1末尾借用了一个数导致下标越界。第二是两个数列中都没有mid这个数，当i + j == k时，取到的是两个数组对mid的上确界，如[1, 1, 3, 3], [1, 1, 3, 3]中第一轮取k = 4, i = 2, j = 2, mid = 2 &lt; nums1[i] = nums2[j] = 3。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中编译器优化导致的一个问题]]></title>
    <url>%2F2017%2F01%2F27%2FC%2B%2B%E4%B8%AD%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96%E5%AF%BC%E8%87%B4%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在MSVC2015上在用for遍历std::vector&lt;T&gt;时遇到一个Access Violation错误，关键代码如下1234for (auto i = v.size() - 1; i &gt;= 0; i--)&#123; // ...&#125; 原因是C语言中一个符号数和一个无符号数进行运算时首先要将符号数转为无符号数，所以编译器会自动推导i的类型为auto = size_t。而对于无符号整数，编译器认为i &gt;= 0是一直成立的，如果循环体中不使用i，编译器很可能会优化成死循环。但即使编译器不做优化这个代码也不正确，当v.size()为0时，无论是有符号的减法还是无符号的减法，i的二进制表示都会是0xffffffff。而0xffffffff在无符号数里面是UINT32_MAX，而在有符号数里面是-1.于是将代码改成下面这样子后运行就正常了。12345int vsize = v.size(); // 转换为有符号数for (auto i = vsize - 1; i &gt;= 0; i--)&#123; s.push(make_pair(v[i], deep + 1));&#125; 在使用无符号类型时需要特别注意溢出问题，还有一个常见的错误来自于从有符号数到无符号数的narrowing conversion，在CSAPP2.2.8中给出了一个getpeername中的漏洞以说明窄化转换造成的非法读取。其实在使用auto时坑还是比较多的，一个常见的就是std::vector&lt;bool&gt;的问题。众所周知std::vector&lt;bool&gt;被全特化了，是个超级大坑。全特化原因很容易理解，节省空间嘛，搞成一个动态的bitset。由此带来的影响是reference类型不再是bool &amp;而是一个代理类，在MSVC2015中是_Vb_reference，通过_Vb_reference重载的opertor=和operator bool进行读写。这时候用auto &amp; = vec[0]就会报错，原因是不能将左值引用绑定到右值上（不过MSVC2015很著名地允许这种写法）。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>auto</tag>
        <tag>编译器优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fortran数组的C++实现]]></title>
    <url>%2F2017%2F01%2F18%2FFortran%E6%95%B0%E7%BB%84%E7%9A%84C%2B%2B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++14的工具，其中涉及到使用C++为Fortran实现一个数组库。总的来讲，Fortran90的有些语言特性在编写和编译上都让人不是很舒服。比如没有头文件和前置声明，这导致了许多额外的代码和解析工作，比如INTERFACE块因此而生（但其实也是一个比较好的解决方案，和前置声明也差不多）。又比如Fortran兼容老标准的问题，这个写C++的同学也应该深有同感，C++为了保持和C的linkage做了不少擦屁股的事情，像什么POD、函数指针/函数对象啥的。Fortran老标准中允许隐式声明变量，而且可以通过名字推断变量的类型，而且由于COMMON块的存在还要兼容一些奇妙的用法。这使得处理变量声明的工作要延迟到处理函数体时。Fortran90还可以直接根据Attribute specification statements给变量加属性(ISO/IEC 1539 : 1991 ch5.2)，加上隐式声明的情况，实际上类似于INTENT、PARAMETER、DIMENSION这样的语句需要考虑是生成一段新变量声明还是修改老声明，这同样会延迟处理变量声明的工作，还会要求建立符号表。此外各种impied-do结构，虽然可以完全展开成for循环，但是为了保持Fortran源语句的抽象，最好还是做成一个表达式。还有Fortran77里面的nonblock DO construct非常恶心，从语法上完全无法解析了，最偷懒的办法就是先用start condition给flex开洞，再#define YYLEX给bison开洞。不过后来token级的continuation迫使我直接手写词法分析了，果然偷懒还是要不得的。此外Fortran的传参机制也很特别，类似于宏的形式，基于引用，具体类型和限定要在函数体中才能看到。为了能够兼容语义，我全部使用了右值作为参数限定关于C++元编程的部分可以参考C++模板编程这篇文章中，关于使用flex/bison进行语法分析的部分我放到了flex和bison使用，其他的部分放在这里。 Fortran数组简介Fortran语言的实现常常要比C快，其中数组是功不可没的。在C语言中，数组常常会被decay成指针来处理，而这会在优化时造成pointer aliasing的问题。一方面C/C++编译器遵循strict aliasing规则，即不同类型的指针绝不会指向同一块内存。具体的说下面的情况被视为相同类型： 被signed/unsigned/const/volatile所修饰 被一个聚合或联合所包含 继承自一个基类 类型char*和void**可以alias任何其他类型这样当你写出这样的神奇代码的时候，编译器至少能有个warning123456789101112int a;int f(float *b)&#123; a = 1; *b = 0; return a;&#125;int main()&#123; printf("%d\n", f((float*)&amp;a)); return 0;&#125; 在另一方面，我们还是无法容易得知道两个相同类型的指针是否alias，即指向同一块内存。这时候Pointer aliasing的问题会阻碍编译器进行优化，虽然restrict关键字可以一定程度上减少这个问题。Fortran数组就彻底没有这样的烦恼。 for1array&lt;typename T&gt;一开始的想法是实现一个for1array&lt;T&gt;，一个一维的数组。可以理解为对C++原生数组的一个包装，使得数组能够自定义上下界，和列优先的存储模式。事实上这种嵌套(nested)数组在实现Fortran的内在函数时存在相当大的麻烦。例如将初始化序列按列映射到一个嵌套的数组for1array&lt;for1array&lt;...for1array&lt;T&gt;...&gt;&gt; farr中，如果通过通常的递归来做，那么就要自结构最里面从内而外for1array&lt;T&gt;进行递归创建这个数组，但这难于实现。一个可能的解决方案对于嵌套的for1array数组按照通常一样从外到内进行递归遍历，而计算farr[a1][a2]...[an]时对应的一维序列中的位置。对于farr数组中的第k层的指针增加1，实际上相当于一维序列中向后移动size[1] * size[2] * ... size[k-1]，其中size[i]为farr中第i层的大小。但是对于transpose这样的函数使用嵌套数组实现的代价就相当大了，特别地，Fortran90标准对转置秩大于2的数组并没有规定行为： 13.13.109 TRANSPOSE (MATRIX)Description. Transpose an array of rank two.Class. Transformational function.Argument. MATRIX may be of any type and must have rank two. 因此实际上对于一个N维/秩数组$X$，假设第$i$维的取值范围是$[0, n_i]$，定义转置$X^T$，满足$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$。 farray&lt;typename T, int D&gt;Fortran90标准中数组的维数，上下界都是确定的，称为显式形状数组(explicit-shape)。此外，除了动态数组(deferred-shape)，即使出现的可调数组(automatic explicit-shape)（类似于C99中的VLA）、假定形状数组(assumed-shape)（仅给出维/秩数）和假定大小数组(assumed-size)（最后一维的上下界是不定的）也是作为哑元（形参的）。Fortran77标准更是使用完全静态环境(fully static environment)的运行时（《编译原理及实践》§7），因此都不支持递归调用。因此Fortran多维数组并不需要锯齿数组，也不需要实现类似动态表的自扩，所以内部可以通过一个一维的线性表data来保存数据。相对于C的数组而言，Fortran中数组是按照列优先顺序(column-major order)存储的。在实现数组时，应当考虑空间局部性的问题，将同列的元素尽可能一同存储（注意C++是行优先顺序）。在Fortran数组的内部实现中如果出现嵌套循环、递归，也应当保证内层循环/递归处理同一列，对于多维数组则是遍历最左边下标。 编译期维护数组各维度上下界的尝试因为要尽可能保证和源代码一致性，所以不能将上界统一改为0开始，在设计时需要使用在对象中维护每一维的上下界。于是自然想到是否可以在编译期进行上下界的相关计算，一个很挫的思路是将每一维的上下界放入模板参数里面，然后通过parameter unpack提取出来。另外还有想法是借助constexpr而不是模板，例如使用constexpr构造函数（注意目前使用的MSVC2015无法编译，原因是尚不支持Extended Constexpr）。但事实上即使能编译，constexpr也不是一个强制性声明，编译器仍然可以选择将其放到运行期完成。其实constexpr也被用来“糊弄”编译器。StackOverflow上的这篇回答解释了这样做的原因。回答列举了一个希望使用for遍历std::tuple的例子，我们知道C++是静态类型的且std::tuple的参数包中可能包含不同类型，所以for (const auto &amp; x : my_tuple)这样的做法就是在和C++标准过不去；但使用一个index来“遍历”std::tuple中的元素也是不行的，例如for (constexpr i = 0; i &lt; 10; ++i)，程序员完全可以将这个i作为std::get的非类型模板参数来构造出可能属于不同类型的变量。通过答主的这个例子可以知道一个constexpr的for对当前的C++来说是不切实际的，事实上我们可以采用一些方法可以实现编译期的循环结构，比如变循环为递归，把index放到模板参数里面。对于C++14，可以借助于index_sequence来辅助进行包展开，对于C++17可以去fold一个index_sequence。 实现transpose现在实现transpose函数，transpose函数主要是通过变换$n_i$和对应的一维序列，满足上面式子。对于原矩阵$X[a_1][a_2]…[a_n]$，可以映射到$X$对应的一维序列的第$\sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$项，令$\prod_{N + 1}^{N}{} = 1 $；对于转置后的矩阵$X^T[b_1][b_2]…[b_n]$，令其每一维大小为$n’_i $，可得$n’_i = n_{N + 1 - i}$，可以映射到$X^T$对应的一维序列的第$\sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$项，其中令$\prod_{1}^{0}{} = 1 $。根据$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$，带入$b_i = a_{N + 1 - i}$，可以得到映射规则$X: \sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$ $\Rightarrow$ $X^T: \sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$ = $\sum_{i=1}^{N}{(a_{N + 1 - i} \times \prod_{j = i + 1}}^{N}{n_{N + 1 - j}})$。以上是对于C-style的数组讨论的，对于Fortran-style的数组，将$\Sigma$的上下界改成$0 .. i - 1$此外，对于2维非方阵矩阵转置有$O(1)$空间的方法，主要是按照序号从小到大遍历矩阵中的每个元素，希望能够找到以它开始的环。容易看出一个环没有被遍历过当前仅当当前序号是环中最小的序号。 slice数组片段fortran中的slice是by reference的，对slice的修改也是对原数组的修改，于是要实现一个forslice函数，其返回的slice应当是数组片段的引用。对于这种情况，首先可以考虑使用std::vector&lt;std::shared_ptr&lt;T&gt;&gt; data来实现内部的线性表data，但是这样会产生不必要的空间开销。因为虽然每一个slice是不一样的，没办法对std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data，但是每个slice的data部分是作为一个整体的。所以还是使用的裸指针RAII，对于从forslice函数构造的farray&lt;T&gt;，在构造时加一个tag，析构时不释放指针即可，类似view的行为。考虑到Fortran77标准本身的完全静态环境（Fortran90可能是基于栈的），所以不会出现悬挂指针导致的AV错误。此外fortran中还允许使用(/ /)这样的Delimiters来具体指定位置组成数组片段，例如A((/1,2/))表示选取A中的第1和第2个元素。要实现这个功能只需要给slice_info做一些修改，加一个迭代器即可，考虑到这个功能并不常用，所以并没有实现。 数组的秩此外fortran中有使用到数组的秩作为参数（通常参数名为dim）的函数，要注意秩是从1开始计算的。 farray&lt;typename T&gt;fortran有一个slice操作，它返回的维数是不固定的，例如a(:, 1, 1:2)返回一个2维的数组，但是a(:, 1, 1:1)返回一个三维的数组，虽然这两个数组所承载的数据是一样的。这给实现带来了困难，因为返回类型是根据slice_info的初始化列表来决定的，为了追求语法尽可能简单，贴近fortran源码，对slice_info这样的工具类模板开洞是不太好的，因此决定将维数参数也移出模板参数。因此将farray&lt;T&gt;的数据分成两块，第一块是有关形状的元数据，通过reset_array来设置；另一块是数据本身，通过reset_value来设置。在数组声明（构造函数）时，可以确定数组形状，可以顺带赋值；在数组（operator=）赋值时只能赋值，而不使用目标右值的形状。再一次说明，这样带来了额外的空间开销lb用来存储上界，sz用来存储大小。由于fortran数组是按列存储，越往后的下边周期越长，因此预先计算delta也就是第d维是i时数组的长度，用来辅助运算。可以看到是把整个数组的运算都放到了运行期，而这些东西完全是编译器决定的。显然我们可以在把fortran编译到C++的阶段处理这些东西，但是要不这让生成的代码因为带上这些附加的数据显得非常难看，要不就会损失掉fortran原来的语义，例如将fortran的数组整合成上界始终是0，按行存储的数组。所以唯一的办法是利用元编程，让C++编译器在模板阶段处理这些东西。 fortran数组的内在函数处理dim参数minloc、maxloc、all、any等函数可以传dim参数。这个dim参数实际上就是数组的秩(rank)。fortran中数组的秩类似于C++中数组的维数(dimension)，但是秩是从1开始算的（可是参数叫dim呢）。在fortran90标准中并没有签名为RESULT = MAXLOC(ARRAY, DIM [, MASK])，从gfortran的文档中了解到这个函数时从95标准后新增加的。在实现这个函数的时候产生了困惑，对于高维数组，这个maxloc函数到底返回什么呢？gfortran文档中只给出： if the DIM argument is supplied, determines the locations of the maximum element along each row of the array in the DIM direction.If DIM is present, the result is an array with a rank one less than the rank of ARRAY, and a size corresponding to the size of ARRAY with the DIM dimension removed. 后来我在这里找到了一个例程：1234567891011integer :: i6(6) = (/-14,3,0,-2,19,1/)integer :: i23(2,3) = reshape((/-14,3,0,-2,19,1/),shape(i23))write(*,'(2i4)') i23 ! writes -14 3 ! 0 -2 ! 19 1write(*,*) maxloc(i6) ! writes 5write(*,*) maxloc(i23) ! writes 1 3write(*,*) maxloc(i23,dim=1) ! writes 2 1 1write(*,*) maxloc(i23,dim=2) ! writes 3 1write(*,*) maxloc(i23,dim=1,mask=(i23 &lt; 10)) ! writes 2 1 2 maxloc(a, dim=1)这个函数返回的是[lb[dim], sz[dim]]构成的dim-1维数组，令剩下来的维数取遍所有组合，对于每一种取组合，给出取得最大值时候对应原数组第dim维的下标，即$ \underset{i_{dim}}{\arg\min}(b(i_{dim})), \forall b = a(i_1, …, i_{dim - 1}, :, i_{dim + 1}, …, i_n)$这个例子中，列是第一维，行是第二维。于是对于此类函数可以抽象成reduce函数，对于不带dim参数的重载版本，这是对于原数列的reduce操作；对于带dim的版本，这是对于一个rank-1的数组中的每个元素（是一个一维数组）进行reduce操作。 处理mask参数minloc、maxloc、all、any等函数还可以传mask参数。这个参数是一个逻辑表达式，实际上类似于一个谓词，并且这个谓词需要使用当前作用域内的变量。至此为止用实现一个[&amp;](){/* expressions directly translated from fortran */}的lambda表达式即可。比较麻烦的是这lambda的函数体内部直接使用数组名，而谓词是作用于数组的元素上的。并且在整个函数调用的可见范围内，无法判断lambda函数体中的变量究竟是数组还是标量，例如下面的情况：1234integer,dimension(8)::N1, N2integer::N3print *, maxval(N2, mask = N1 &lt; 5) ! N1 is arrayprint *, maxval(N2, mask = N3 &lt; 5) ! N3 is scalar 由于编译器实际上并没有建立符号表，在处理maxval(N2, mask = N1 &lt; 5)这个调用时并不能知道N1，N2，N3的类型与定义位置。所以也就无法将数组改为对应的元素形式了。有两种方法解决这个问题：第一种，将这个谓词作为表达式来计算，最后返回一个布尔值数组。这需要重载运算符和fortran的内在函数。第二种，是实现一个模板函数formap(F f, T x)和重载版本formap(F f, farray&lt;T&gt; x)，然后对于所有的变量x，用formap(predicate, x)包一下就好了 fortran数组中的运算符重载fortran中数组可以对同样长度的数组和标量进行算术运算和比较运算等，所以需要实现一系列重载函数 数组声明数组声明注意点比较多。首先给出fortran中声明(declare)和定义(define)的区别 The term declaration refers to the specification of attributes for various program entities. Often this involvesspecifying the data type of a named data object or specifying the shape of a named array object.The term definition is used in two ways. First, when a data object is given a valid value during programexecution, it is said to become defined. This is often accomplished by execution of an assignment statement orinput statement. Under certain circumstances, a variable does not have a predictable value and is said to beundefined. Section 14 describes the ways in which variables may become defined and undefined. The seconduse of the term definition refers to the declaration of derived types and procedures. 简而言之，声明(declaration)，指的是设置变量的type或者attribute，而定义(definition)是给变量初始化。 下面考虑数组的声明方式。首先fortran77中可以使用下面的方式声明123REAL A(10,2,3) ! 类型说明（常用）DIMENSION A(10,2,3) ! DIMENSI0N语句（常用）! COMMON fortran90中可以使用下面的方式声明12345REAL，DIMENSION(2,5):: D ! 类型说明中的DIMENSION属性（最常用）REAL，ALLOCATABLE:: E(:,:,:) ! 类型说明中的ALLOCATABLE属性REAL，POINTER:: F(:,:) ! 类型说明中的POINTER属性POINTER C(:,:,:) ! POINTER语句ALLOCATABLE B(:,:) ! ALLOCATABLE语句 根据fortran90标准section5 R501 type-declaration-stmt is type-spec [ [ , attr-spec ] … :: ] entity-decl-listentity-decl is object-name [ ( array-spec ) ] [ char-length ] [ = initialization-expr ] or function-name] [ char-length ] 其中array-spec就是dimension()语句括号中的东西，表示数组的形状。注意： 声明中并不一定要出现double colon separator::，但是当有初始化语句initialization-expr时，必须要有这个分隔符这在语法分析时可能出现语义冲突导致二义性文法，原因是integer、real等既可以作为类型限定符，也可以作为函数名，所以实际上要去掉callable_head规则，将它统一合并入callable规则 char-length仅允许给字符串指定长度，由于实现上使用的是std::string，所以可以直接去掉这个，我们只需要对变量声明中出现的*号进行特判处理即可。 考虑到可以通过REAL R(10) = (/1,2,3,4,5,6,7,8,9,0/)声明数组，所以不能在扫描完type-spec和attr-spec就确定类型，而要根据每一个entity-decl后面是否出现( array-spec )来决定。123integer::Zdimension:: Z(10)! dimension(10)::Z 注意这样的语句是不行的 这样的说明也是允许的，考虑到fortran还有隐式声明，事实上第一行还可以直接去掉。所以说即使整个声明语句读下来，仍然不能决定具体的类型是什么： 5.1.2.4 DIMENSION attributeThe DIMENSION attribute specifies that entities whose names are declared in this statement are arrays. Therank or the rank and shape are specified by the array-spec, if there is one, in the entity-decl, or by the array-specin the DIMENSION attribute otherwise. An array-spec in an entity-decl specifies either the rank or the rank andshape for a single array and overrides the array-spec in the DIMENSION attribute. If the DIMENSION attributeis omitted, an array-spec must be specified in the entity-decl to declare an array in this statement.为了解决这个问题，变量的声明必须要在整个变量声明语句块结束之后才能确定（fortran的命令语句必须在所有声明语句后面）。所以只有在program或者function_decl规则中才能对其中的suite规则中的变量名生成定义和初始化语句。这里还要注意一点，变量的隐式声明和隐式类型(implicit type indicated by the first letter)还不一样，后者指的是在声明变量的时候不指出变量的类型，这时候根据变量名的第一个字母来决定是实型还是整型。当然隐式声明和隐式类型是可以同时存在的。 数组初始化和赋值使用数组构造器Fortran中的数组构造器(array constructor)我认为是一个很方便实用的功能，根据Fortran90标准，数组构造器使用下面的语法 array-constructor is (/ ac-value-list /)R432 ac-value is expr or ac-implied-doR433 ac-implied-do is ( ac-value-list , ac-implied-do-control )R434 ac-implied-do-control is ac-do-variable = scalar-int-expr , scalar-int-expr [ , scalar-int-expr ]R435 ac-do-variable is scalar-int-variable 数组构造器始终是一个一维的数组，不能使用数组构造器直接初始化高维数组，而应该使用reshape函数。又注意数组构造器在赋值和构造时都可能用到，所以比较方便的方法是对(/ /)直接生成一维的farray实体而不是将它直接生成代码到构造函数中作为一个brace-init-list的参数： An array constructor is defined as a sequence of specified scalar values and is interpreted as a rank-one arraywhose element values are those specified in the sequence. 因为farray的构造函数用来确定数组的形状（顺带赋值是可选的），而赋值放到farray&lt;T&gt;::operator=去做。在实现时因为farray&lt;T&gt;::operator=仅仅是复制内部的线性表data，并不改变形状，可以在不同维数之间给数组赋值。 implied-do在上面的定义中ac-implied-do是个特别有意思的东西，与之类似的还有io-implied-do（用于read等io语句）和data-implied-do（用于data语句），称为隐式Do循环(Implied Do Loop)。标准中对循环的特性做出了这样的规定 If an ac-value is an ac-implied-do, it is expanded to form an ac-value sequence under the control of the ac-do-variable, as in the DO construct (8.1.4.4). 以ac-implied-do举例，隐式Do循环的的语法通常为 ac-value ::= expr | ac-implied-do ac-implied-do ::= ( ac-value-list , scalar-int-expr , scalar-int-expr [ , scalar-int-expr ] ) 在转换中为了保留隐式DO循环的结构，所以我们尽可能避免将这个Implied Do展开为C++中的for循环语句。第一个思路是把整个嵌套的Implied Do深度优先到底，得到最里面的表达式放入一个[&amp;](int do_variable1, int do_variable2, ...){...}里面，然后借助于farray里面的map函数喂给这个lambda块各层do-variable的值。不过由于ac-value-list可能包含不止一个表达式，所以这个方法实际上麻烦。于是有了第二个思路，就是按部就班一层一层处理。但这种方法仍然是要在Implied Do的上下文中处理，因为内层Do的循环过程需要依赖于外层Do对应的do-variable的当前取值。 使用DATAdata语句可以用来初始化数组，可以采用下面的语法1234data a1/1.,2.,3.,4./, a2/2.,3.,4./data b/3*1.,4*2.,3*3./data c(1),c(2),c(3),c(4)/1.,2.,3.,4./data (d(j),j=1,4)/1.,2.,3.,4./ 其中值得注意的是第二条语句中的*并不是二元算术运算符，而是表示该元素的重复次数 使用WHERE生成AST会碰到这样的问题，例如翻译上面的数组生成器，可以生成一个NT_ARRAYBUILDER节点，所以NT_ARRAYBUILDER也是一个NT_EXPRESSION节点，而数组生成器是可以出现的等号右边构成表达式，于是也可以作为赋值式归约成NT_EXPRESSION节点。所以问题存在于直接将NT_ARRAYBUILDER立即归约成表达式NT_EXPRESSION节点还是当NT_ARRAYBUILDER和新的串构成例如赋值式时再归约成表达式。对于第一种方法，会在AST的深度方向产生较多的不确定深度的节点，例如在NT_FUNCTION_ARRAY会被归约成NT_EXPRESSION。出现这种问题主要是我在列表方面有点偷懒，只设置了一个paramtable，一般非终结符必须要归约成NT_EXPRESSION才行，此外，只要列表中含有slice，所有元素都被promote成slice；进一步地，只要列表中含有键值对，所有的元素都被promote成键值对。如果修改语法，可能也要修改语义处理程序。其次是因为对于所有的运算符（除了赋值），我都将其设置为一个NT_EXPRESSION节点对于第二种方法，容易在单独使用NT_ARRAYBUILDER的时候出现问题，例如使用if(X == NT_EXPRESSION)筛选NT_EXPRESSION节点时会因为NT_ARRAYBUILDER != NT_EXPRESSION造成被误筛掉 总结Fortran数组相对于C++数组还是有很大的不同的，正因为如此，Fortran数组具有比C++要稍好的（数值计算）性能（如果能够正确使用的话）。例如Fortran的数组模型非常适合编译器针对处理器做矢量优化，而到了C++中数组往往会退化成一个指针，这可能会妨碍编译器了解内存布局，从而进行优化。此外就指针本身，Fortran也没有C++的Pointer Alias的开销。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>fortran</tag>
        <tag>编译原理</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中static关键字的用法]]></title>
    <url>%2F2017%2F01%2F02%2FC%2B%2Bstatic-usage%2F</url>
    <content type="text"><![CDATA[C++中static关键字具有很多迥然不同的意义与用途，常在不同的情景下出现。例如声明局部静态变量、声明静态函数、声明类的静态成员。这三种用法的背后分别对应着不同的linkage。本文还将static与inline、extern等存储类指定符进行简单的比较，以期了解C++编译阶段和连接阶段的行为。 声明局部静态变量此时static作为五种存储类指定符storage duration specifiers(auto, register, static, extern, thread_local)中的一种，static声明的静态变量（称为local static）相对于auto(C++11标准后auto关键字另作他用)声明的自动变量，它的生存空间是从所属模块（编译单元）开始全局的，并且能够保证在函数调用之前被初始化构造完成。但是相对于直接使用全局变量，将static置于全局函数内部并返回引用可以保证在任何访问该静态对象的时候，该对象都已完成初始化（可参见Effective C++），由此可以实现单例模式，称为Meyers’ Singleton。从C++11标准开始，Meyers’ Singleton是线程安全的，这是因为新的标准规定了当一个线程正在初始化一个变量的时候，其他线程必须得等到该初始化完成以后才能访问它，而在之前的标准中可能会产生多次初始化的结果。其他的单例模式还包括使用atomtic，和std::call_once，可以访问http://www.cnblogs.com/liyuan989/p/4264889.html来了解。 静态变量和匿名名字空间注意到在C++中声明局部变量还可以通过匿名名字空间来实现，例如12static int _func();static int _var; 可以写为1234namespace&#123; int _func(); int _var;&#125; 但是匿名名字空间还适用于修饰类型的情况如1234namespace &#123; struct _struct &#123; &#125;;&#125; 但匿名名字空间和static变量还是不同的，匿名名字空间具有外部链接性（但是不知道具体名字），而static变量具有内部链接性 声明静态函数/变量在这里，static表示该函数/变量名字只能在该编译单元内部使用，而不导出。例如在不同的编译单元中使用static关键字允许出现多个同名的变量/函数。因此可以利用static实现在头文件中直接给出函数定义，也就是使用static修饰。但这是非常不好的做法，正确的做法应该是分情况使用constexpr或者inline。static常和const一起搭配用来声明一个编译期常量。 声明类的静态成员/成员函数C++标准只允许static const的integral/enumeration类型(integral types)在class声明中初始化。注意在《STL源码分析一书中》指出在CB4对在类外部初始化如static int成员的支持有限，见有关组态__STL_STATIC_TEMPLATE_MEMBER_BUG的部分。在C++中禁止以下两种初始化，原因详见Stackoverflow 禁止在声明时同时初始化非const的static类成员 禁止在声明时同时初始化const的非literal的static类成员这是由于C++ requires that every object has a unique definition. That rule would be broken if C++ allowed in-class definition of entities that needed to be stored in memory as objects linkage链接性(linkage)指的是一个名字在整个程序或某个编译单元中是否会绑定到同一个实体(entity)上。在上面的用法中，static都限定了一个名字的链接性，然而这三种情况下的链接性都不一样。函数中的static限定了名字只在某个函数内可见，是没有链接性的，因为它既不是全局可见，也不对当前的编译单元可见。没有链接性的实体包括局部变量和函数的形参。一个static的函数具有内部链接性，即对当前编译单元可见，而在全局不可见，即对链接器而言不可见。具有内部链接性的实体包括声明、名字空间中static的自由函数（不带上下文的函数，相对于成员函数）、友元函数、变量和const常量（特别地在C++中单独的const也是内部链接性的，除非是extern const，这和C语言不一样）、enum、inline自由函数和非自由函数、class/struct、union。一个static的类成员/成员函数具有外部链接性。具有外部链接性的实体包括非inline的函数（包括非static自由函数、类非static成员函数和类static成员函数）、类的static成员和名字空间（不包括无名命名空间）中的非static变量。 static和inline的区别单一定义原则(ODR)我们首先查看C++中重要的单一定义规则(ODR)，该规则不允许同名的强符号(strong symbol)，但允许同名的弱符号(weak symbol)。根据CSAPP，strong symbol包含了函数和已初始化的全局变量，而weak symbol包含未初始化的全局变量*。当weak symbol和strong symbol出现冲突时，链接器选择strong symbol。当没有strong symbol，而各weak symbol间产生冲突时，链接器选择占用空间最大的一个。选择占空间最大的原因在于在编译期时并不能决定这些未初始化的全局变量实际的占用大小，因为作为一个弱符号，它有可能在某个编译单元内被定义为某个4字节的长度然后在另一个编译单元内被定义为8个字节的长度。如果出现这样的情况，那么程序有大概率是出错的，但是在未开启fno-common选项时GCC并不会输出警告。但是链接期的时候链接期需要为这个弱符号在.bss注册大小，为了能够适应所有编译单元中的空间需求，所以只能取最大的一个。作为用户，为了保证weak symbol间不出现冲突，必须保证所有的声明都是一样的。特别地对于同名的重载函数，我们需要理解对于编译器和链接器，其处理的函数名字并不是其本名，而是经过mangling变成一堆乱码一样的东西以保证唯一性，这导致同一个函数通过C或C++编译出来的符号是不一样的。 inline function相对于C89标准，C++引入了inline函数。为了了解其作用，我们首先考虑一个static的函数具有internal linkage，当这个函数位于头文件中被多次包含时，编译器会生成对每个编译单元生成一个独立函数（也有可能进行内联优化），编译器不保证所有编译单元中生成的所有函数是一样的。容易发现，static会导致生成的binary变大。C++的inline关键字提供了另一个更好的方案，inline并不会保证一定会被编译器内联（可以使用__forceinline或__attribute__((always_inline))提高内联的几率），当编译器没有真正内联该函数时，就可能出现重复定义的情况（例如当这个inline定义被多次包含时），而这违背了C++重要的单一定义规则。为了解决未进行内联下的符号问题，编译器为这些inline函数创建了weak symbol。 inline variableC++17引入了inline variable，因此inline现在也可以用在变量定义上了。由于C++禁止in-class initialization of static data member of non-literal type，又禁止重复定义，需要借助下面的Workaround，通过模板的实例化阶段来获得一次“重新定义的机会”。12345678910template&lt;class Dummy&gt;struct Kath_&#123; static std::string const hi;&#125;;template&lt;class Dummy&gt;std::string const Kath_&lt;Dummy&gt;::hi = "Zzzzz...";using Kath = Kath_&lt;void&gt;; // Allows you to write `Kath::hi`. 在C++17后可以写作123456struct Kath&#123; static std::string const hi;&#125;;inline std::string const Kath::hi = "Zzzzz..."; // Simpler! 当然如果在一个编译单元内我们需要使用另一个编译单元中定义的变量时，我们还可以用extern int x;来声明，但注意extern int x = 1;是个定义。 static的可访问性static和thread_local是可以从闭包里直接访问而不需要捕捉的，使用[&amp;]形式的捕捉可能造成问题]]></content>
      <tags>
        <tag>C++</tag>
        <tag>static</tag>
        <tag>inline</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++初始化方式]]></title>
    <url>%2F2016%2F12%2F30%2FC%2B%2B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[C++新标准之后对初始化方式有了很多的变动，现在的初始化方式主要可以分为五种来讨论，分别是list initialization、aggregate initialization、zero initialization、default initialization、value initialization。本文根据标准以及cppreference上的相关资料论述了这五种初始化方式，并讨论了POD、成员初始化列表、new关键字等方面的问题。 下面是个总的例子 123456789101112// Value initializationstd::string s&#123;&#125;;// Direct initializationstd::string s("hello");// Copy initializationstd::string s = "hello";// List initializationstd::string s&#123;'a', 'b', 'c'&#125;;// Aggregate initializationchar a[3] = &#123;'a', 'b'&#125;;// Reference initializationchar&amp; c = a[0]; 博文中总结了C++11标准下的一些初始化的简要规则，但在C++14/17/20标准中，这些规则又出现许多变动。 direct initialization和copy initialization直接初始化包括 12345678910111213141516// 列表初始化T object ( arg );// This code can't be shown, or it will cause errorT object &#123; arg &#125;;// This code can't be shown, or it will cause error// 初始化纯右值T ( other );// This code can't be shown, or it will cause error// 使用static_cast初始化纯右值临时变量static_cast&lt; T &gt;( other )// 使用非空的new// This code can't be shown, or it will cause error// 使用initializer list// This code can't be shown, or it will cause error// 在lambda表达式中复制捕捉// This code can't be shown, or it will cause error 复制初始化包括 12345678T object = other;// C++11后归入列表初始化T object = &#123;other&#125; ;f(other)return other;throw object;catch (T object)T array[N] = &#123;other&#125;; 复制初始化调用复制构造函数，注意到复制初始化不是赋值，例如std::string s = &quot;hello&quot;;是（先cast再）复制初始化，std::string s; s = &quot;hello&quot;;后一句是赋值。虽然通过copy elision技术编译器可以省略复制初始化时创建临时对象的开销，但是复制初始化和直接初始化具有显著的不同。例如当复制构造函数或移动构造函数都delete时，无法进行复制初始化，典型的例子是atomic类型（不过VS2015可以编译）1std::atmoic&lt;int&gt; = 10; list initialization花括号初始化器在C++11标准中，花括号初始化器的功能被增强了。注意到在C++11前，初始化和函数声明需要区分，例如std::vector&lt;int&gt; X()既可以被看做一个变量定义，也可以被看做函数声明，这被称为Most vexing parse。Most vexing parse会造成二义性的问题，一个int f(x)，既可以被看做使用变量type_or_var来构造的对象f，又可以看做一个接受type_or_var类型的函数，这从某些方面也是不别扭的，如果将构造函数看成一类特殊的函数的话。例如在下面的语句中，TimeKeeper和Timer都是用户自定义的类型，1TimeKeeper time_keeper(Timer()); 那么time_keeper既可以按照我们希望的那样被看做一个变量定义，也可能被看做一个函数声明，这个函数返回一个TimerKeeper，接受一个参数，一个匿名的返回Timer的函数指针。对于这种二义性，C++标准指出按照第二种方式来解释。为了解决这个问题，在C++11标准前可以通过加上一组括号来强制按照第一种方式解释TimeKeeper time_keeper( (Timer()) )，但是对于具有0个参数的constructor，我们不能写成A (())的形式，StackOverflow详细论述了这一点。我们要不写成复制初始化的形式A a = A()，要不就需要写成一种很丑的办法。例如对于内置变量写成A a((0))，对于非POD写成A a利用其默认初始化特性等。在C++11后，可以通过称为uniform initialization syntax的方法，使用花括号初始化的形式std::vector&lt;int&gt; X{}，通过list initialization的决议，最终完成value initialization。 列表初始化list initialization是使用braced-init-list（花括号初始化器）的初始化语句。尽管aggregate initialization被视为一种初始化聚合体的list initialization，但aggregate initialization有着自己的特点，例如aggregate initialization直接不允许有用户定义的构造函数。但是对于非aggregate的list initialization，如果提供了相应构造函数，还可以花括号列表作为一个std::initializer_list对象传给对应函数。当一个类定义了从std::initializer_list的构造函数后，对于使用{}语法将调用该构造函数，例如std::vector&lt;int&gt;(10)创建10个元素并对每个元素进行zero initialization，std::vector&lt;int&gt;{10}创建一个值是10的元素。下面的几种场景下会导致list initialization，这里根据上面的直接初始化/复制初始化分为两种。 direct-list-initialization 12345678910// 使用花括号初始化器（空或嵌套的）初始化具名对象T object &#123; arg1, arg2, ... &#125;; (1)// 初始化匿名对象T &#123; arg1, arg2, ... &#125;; (2)// 在动态存储上初始化对象new T &#123; arg1, arg2, ... &#125; (3)// 不使用等号`=`初始化对象的非静态成员Class &#123; T member &#123; arg1, arg2, ... &#125;; &#125;; (4)// 在成员初始化列表中使用花括号初始化器Class::Class() : member&#123;arg1, arg2, ...&#125; &#123;... (5) copy-list-initialization 1234567891011121314// 比1多个等号T object = &#123;arg1, arg2, ...&#125;; (6)// 函数参数function( &#123; arg1, arg2, ... &#125; ) ; (7)// 作为函数返回值return &#123; arg1, arg2, ... &#125; ; (8)// 作为`operator []`的参数object[ &#123; arg1, arg2, ... &#125; ] ; (9)// 赋值object = &#123; arg1, arg2, ... &#125; ; (10)// 强转U( &#123; arg1, arg2, ... &#125; ) (11)// 相对于4使用等号Class &#123; T member = &#123; arg1, arg2, ... &#125;; &#125;; (12) narrowing conversionC++11开始，list initialization不再允许narrowing conversion。narrowing conversion是下面的隐式转换。关于隐式转换的详细规则，可以参见我的文章《C++模板编程》。 从浮点数到整数 从浮点到整数会导致向0舍入。此外，值也有可能溢出成未确定的值。 从高精度到低精度 包括从long double、double和float三种类型之间从高到低的转换，除非是不溢出的constexpr。从高精度到低精度可能导致舍入和溢出（为Inf）。 从整数到浮点，除非是能够精确存储的constexpr 从相同字长的整数到浮点虽然不会溢出，但会被舍入 从整数或无作用域枚举类型到不能表示原类型所有值的整数类型，除非是能够精确存储的constexpr 例如从-1到(unsigned char)(-1) 下面是一个简单的例子，下面的代码都是不能编译的123vector&lt;int&gt; a&#123;1.0, 2&#125;;vector&lt;int&gt; b&#123;1.0, 2.0f, 3&#125;;vector&lt;float&gt; c&#123;float(1), 2.0f&#125;; 在Effective Modern C++中举了下面的例子12345678class Widget &#123; public: Widget(int i, bool b); Widget(int i, double d); Widget(std::initializer_list&lt;long double&gt; il); operator float() const; // convert … // to float&#125;; 这段代码在使用braced initialization时，使用Widget w{10, 5.0}初始化会调用带std::initializer_list&lt;long double&gt;的构造函数，因为优先级高。但是考虑将构造函数改为std::initializer_list&lt;bool&gt;，那么Widget w{10, 5.0}就会导致narrow conversion导致无法编译。 list initialization主要规则list initialization会按照从上到下的顺序执行。 如果初始化器列表有一个元素 如果T是聚合类型，初始化器列表包含T的相同/导出类型的单个元素，则使用该元素进行复制/直接初始化 如果T是char []，初始化器列表为一个literal string，那么使用这个string来初始化 对于其他情况，遵循下面的规则 如果初始化器列表是空的 如果T是个aggregate聚合类型，那么进行aggregate initialization 否则，如果T是class、有默认构造函数，那么进行value initialization 这里注意先后顺序，在C++14前，顺序是相反的。 考虑是否能构造std::initializer_list 如果T是std::initializer_list的特化，则从花括号初始化器列表依赖语境直接初始化或复制初始化T。 考虑T是否存在接受std::initializer_list的构造函数 首先检查所有接受std::initializer_list作为唯一参数，或作为第一个参数但剩余参数都具有默认值的构造函数。进行重载决议。 如果无匹配，则T的所有构造函数参与针对由花括号初始化器列表的元素所组成的实参集的重载决议，注意narrow conversion是不被允许的。若此阶段产生explicit 构造函数为复制列表初始化的最佳匹配，则编译失败。 如果T是一个枚举类型 如果T不是类类型 如果T是一个应用类型 在最后，如果T使用了空的{}，则使用值初始化 以下规则来自cppreference的notes部分 花括号初始化器列表不是一个表达式，所以没有类型，因此模板类型推导不能直接推导出来。auto关键字会将所有的花括号初始化器列表推导为std::initializer_list。 std::initializer_list除了在上面的list initialization使用，std::initializer_list还可以被绑定到auto，从而有下面的用法12345for (int x : &#123;-1, -2, -3&#125;) // auto 的规则令此带范围 for 工作 std::cout &lt;&lt; x &lt;&lt; ' ';std::cout &lt;&lt; '\n';auto al = &#123;10, 11, 12&#125;; // auto 的特殊规则std::cout &lt;&lt; "The list bound to auto has size() = " &lt;&lt; al.size() &lt;&lt; '\n'; aggregate initializationaggregate initialization是list initialization的特例。聚合初始化指的是可以使用一个花括号初始化器(braced-init-list)来初始化聚合对象，类似于C的初始化风格。1std::pair&lt;int, int&gt; p = &#123;42, 24&#125;; 在C++20标准草案中出现了指代初始化器，这里暂时不讨论。 aggregate（聚合）类型聚合类型包括 数组 特定的类 没有private或protected非静态成员 没有用户提供的构造函数 注意从C++11标准开始，用户可以提供=delete或者=default型的构造函数。在C++17中又限定了聚合类型也不能有inherited或者explicit的构造函数。 在C++11前转换构造函数必须是单参数非explicit的，但C++11后只要是非explicit的都是转换构造函数。 没有virtual、private或protected的基类 注意这个性质是从C++17开始的，在前面的标准中，聚合初始化必须没有基类。我觉得这个规定应该早一点出来，毕竟从C++11开始 没有虚成员函数 可以看出POD一定是聚合类型。注意聚合类或者数组可以包含非聚合的public基类和成员。 aggregate initialization规则 对于每个直接public基类、数组或者非静态成员（静态成员和未命名的位域被跳过），按照声明顺序或者下标顺序，使用initializer list中对应的initializer clause进行copy-initialization 注意直接public基类的初始化支持在C++17标准起开始支持，参照下面的这个形式 1234// aggregate in C++17struct derived : base1, base2 &#123; int d; &#125;;derived d1&#123; &#123;1, 2&#125;, &#123; &#125;, 4&#125;; // d1.b1 = 1, d1.b2 = 2, d1.b3 = 42, d1.d = 4derived d2&#123; &#123; &#125;, &#123; &#125;, 4&#125;; // d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4 如果对应的clause是个表达式，可以进行隐式转换（参见list-initialization） 在C++11标准开始，narrowing conversion的窄化隐式转换不被允许 如果对应的clause是一个嵌套的braced-init-list（这就不算是表达式了），使用list-initialization进行初始化这个成员或者public基类 注意public基类同样是在C++17标准开始的 未知长度的数组的长度等于初始化时的braced-init-list的长度 static成员和无名位于在聚合初始化中被跳过 如果braced-init-list的长度超过了要初始化的成员和基类数，是ill-formed，并产生编译错误 长度不足的情况 1.（C++11前）剩下来的采用value-initialization 2.（C++14）对于剩下来的member，如果该member的class提供default-initializer，采用default-initializer，否则采用空列表初始化（和list-initialization一样） 特别地，如果里面有引用，则是ill-formed 花括号消除value initialization下面的几种场景下会导致value initialization1234567891011121314// 使用小括号initializer创建一个匿名临时对象T(); (1)// 使用小括号initializer在动态存储上创建一个匿名临时对象new T (); (2)// 使用成员初始化列表(member initializer)初始化对象的非静态成员Class::Class(...) : member() &#123; ... &#125; (3)// 使用小括号initializer创建一个具名对象T object &#123;&#125;; (4) (since C++11)// 同1T&#123;&#125;; (5) (since C++11)// 同2new T &#123;&#125;; (6) (since C++11)// 同3Class::Class(...) : member&#123;&#125; &#123; ... &#125; (7) (since C++11) value initialization的效果是： 当一个class没有默认构造函数（或delete了默认构造函数）、具有 user-provided构造函数，default initialization这个对象 当一个class具有为delete的默认构造函数，并且没有 user-provided构造函数，首先zero initialization。如果有non-trivial的默认构造函数，再调用该默认构造函数进行default initialization。这段可以和zero initialization参照，如果默认构造函数是trivial的，则意味着编译器并不需要做任何事，这等价于只zero initialization。 数组中的每一个元素被值初始化 否则对对象进行zero initialization 引用不能被值初始化 注1：这里的 user-provided指的是用户定义的且没有显式=default的构造函数注2：由于T object();声明了一个函数，所以在C++11允许使用T object{}前，应当使用T object = T()。这种方式会导致复制，但常常被编译器优化掉 zero initializationzero initialization（如果发生）发生在其他初始化前，下面的几种场景下会导致zero initialization1234567891011// 具有static和thread\_local存储期的具名变量，包括全局变量、函数中static变量等，应当执行zero initialization// 注意常量变量应当遵循常量初始化static T object ; (1)// 作为下两种value initialization**一部分**，注意不包括default initialization// 1. 非class类型（例如primitive type） // 2. 无构造函数的对象的成员T () ; (2) (since C++11)T t = &#123;&#125; ; (2) (since C++11)T &#123;&#125; ; (2) (since C++11)// 字符数组初始化时未初始化部分被zero initializationchar array [ n ] = ""; (3) 需要特别说明，C++中的全局变量也属于静态存储期的具名变量，下面的代码中，x是一个未初始化的全局变量，它将被存储在bss(Block Started by Symbol)段中，根据CSAPP，bss段会在运行开始前被初始化为0。1int x; zero initialization效果是： 当T是一个scalar type标量类型，用0值来初始化 如果T是一个非联合(union)的class，所有的基类和非静态成员被zero initialized，所有padding被初始化为zero bits，如果有构造函数，构造函数会被忽略 如果T是一个union，第一个非静态成员用0值初始化，所有padding被初始化为0 如果T是一个数组，数组中的每个元素被zero initialize 如果T是一个引用，不做任何事情 default initializationdefault initialization发生在当一个变量未使用initializer(the initial value of a variable)构造，特别地，从C++11标准以后空的圆括号不算做未使用initializer。详情可以参照下面的初始化语句下面的几种场景下会导致default initialization 123456// 声明auto、static、thread_local变量时（还有两种是register和extern）不带任何initializer（比如小括号initializer）T object ; (1)// 在动态存储上创建对象且不带任何initializer时，特别地，C++11标准后使用空圆括号（类似`std::vector&lt;int&gt; a()`）不算做默认初始化new T ; (2)new T () ; (2) (**until c++03**)// 当基类和非静态成员不在某个构造函数的construct initializer list（类似`:a(_a), b(_b), c(_c)`）中时 default initialization效果是： 对于类类型，构造函数根据重载决议在默认构造函数中选择一个为新对象提供初始值。 注意，在C++11前的标准中中，POD的初始化是特殊的，例如new A和new A()是不一样的，new A并不会对成员进行初始化。 对于数组类型，数组中的每一个元素被默认初始化。 对于其他情况（包括基础类型），编译器不做任何事情。例如此时的自动变量被初始化到不确定的值。使用这个值会导致UB，除非一些情况。 例如标准不要求在堆和栈中的变量定义附带进行zero initialization，我们需要显式memset一下。12345void func()&#123; int x; int x[100]; int * px = new int[100];&#125; 而下面的代码则会蕴含执行一次zero initialization的语义12345void func()&#123; int x &#123;&#125;; int x[100](); int * px = new int[100]();&#125; 但是根据zero initialization的定义，具有static和thread_local存储期的具名变量，包括全局变量、函数中static变量，应当执行zero initialization，常量型应当执行constant initialization，详见zero initialization章节。 constant initialization下面的几种场景下会导致constant initializationconstant initialization会替代zero initialization（C++14标准前不是替代而是接着）初始化static和thread-local对象。发生在所有初始化前 12static T &amp; ref = constexpr; (1) static T object = constexpr; (2) 初始化方式与PODPlain Old Data是在C++03标准的一个概念，表示能和C兼容的对象内存布局，并且能够静态初始化。POD常包括标量类型和POD类类型。C++11通过划分了trivial和standard layout，精确化了POD的概念，这有点类似于C++将C风格的类型转换分为了reinterpret_cast等四个转换函数。在精化之后，POD类型即是trivial的，也是standard layout的。虽然C++11修订了POD相关内容，但是POD这一“兼容C”的特性在为C++带来人气的同时却仍然是一个巨大的包袱（虽然其他的例如C linkage也没好到那里去），有很多库都对对象的POD性质有有要求。 trivialtrivial类型首先是trivially copyable的，也就是说它能通过memcopy进行拷贝。通过简单的思考可以得知为了能够达到这样的效果，它必须具有trivial的复制、移动构造函数和操作符和析构函数。以复制构造函数为例，一个trivial的复制构造函数必须不是用户提供的，并且它所属的类没有任何虚函数（包括虚析构函数）和虚基类，并且每个数据成员都是trivial的。此外trivial的默认构造函数内部不能初始化非静态数据成员。可以发现trivial主要是对为了兼容C式的初始化、拷贝和析构行为来规定的。 standard layout成员初始化列表根据Inside the C++ object model：在构造函数体中的“初始化”实际上是对默认初始化后的该成员的进行赋值，因此浪费了一次初始化的开销对于reference、const、有一组参数的base class构造函数、有一组参数的member class构造函数这四种情况，必须使用初始化列表进行初始化。一般地，初始化列表中的初始化顺序是按照成员在类中的声明顺序而不是在列表中的顺序，构造函数体内代码会在初始化列表“执行”完毕后开始工作。但在初始化列表中使用成员函数仍然是不好的。 委托构造函数在成员初始化列表中还可以出现委托构造函数（在新标准中），如12345678class X &#123; int a; X(int x) &#123; &#125; // 1 X() : X&#123;42&#125; &#123; &#125; // 2 X() : X(42) &#123; &#125;&#125;; 但是注意，下面这种写法是错误的1234567class X &#123; int a; X(int x) &#123; &#125; X() &#123; X(42); &#125;&#125;; 这实际上不是调用了构造函数，而是创建了一个X的右值对象。 new我们对new的使用经常以new X和new X()的形式出现。但是在标准库中还存在着new函数，具体如下12345void *operator new(size_t);void *operator delete(void *);void *operator new[](size_t);void *operator delete[](void *); 这里的::operator new等是一系列标准库函数而不是运算符，它们和std::malloc等一样，用来分配未初始化的内存空间，之后可以在这段内存空间上使用placement new构造对象。而我们常用的new关键字实际上也都是在底层先调用operator new申请内存，然后在调用构造函数创建对象的。特别地，这种先分配内存再构造对象的思想也被用到了STL的allocator模块中，例如某些allocator实现会定义allocate()和deallocate()用来管理内存空间，而构造、析构则使用::construct()和::destroy()。在Effective C++ 要求运算符new和delete需要成对使用，原因是new []时会额外保存对象的维度，例如它会在申请的内存的头部之前维护一个size_t表示后面有n个对象，这样可以知道在delete []时需要调用几次析构函数，显然我们的operator new系列也是要成对使用的。当然硬要说例外也有，如果说我们初始化了一个trivial类型的数组如new int[20]，我们实际上是可以直接通过delete而不是delete []进行删除的，原因是delete最终还是会调用::operator delete释放分配的内存块，而trivial类型没有自定义的析构函数。同样的，我们可以通过观测STL的allocator模块来了解这个过程，以PJ Plauger的实现为例_Destroy_range(_FwdIt _First, _FwdIt _Last)函数会先判断is_trivially_destructible&lt;_Iter_value_t&lt;_FwdIt&gt;&gt;()是否成立，在成立的情况下就不会逐个元素地调用_Destroy进行删除了。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>POD</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++模板编程]]></title>
    <url>%2F2016%2F12%2F22%2FC%2B%2B%E6%A8%A1%E6%9D%BF%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[模板编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的（STL）。C++11标准以来，C++在泛型编程方面引入了许多新的特性。本文讨论了围绕C++模板的诸多技术与编程方法。包括traits 各种traitstraits是C++ STL中的重要组成成分 数值部分 判断是否是整数：std::is_integral&lt;T&gt;::value 判断是否有符号：std::numeric_limits&lt;T&gt;::is_signed 迭代器部分判断迭代器种类以及内容：std::iterator_traits。这个trait实现很有意思，为了兼容指针和常指针这两个最原始的“迭代器”，这里使用了SFINAE123456789101112131415161718192021222324252627282930313233343536373839404142434445template&lt;class _Iter&gt; struct _Iterator_traits_base&lt;_Iter, void_t&lt; // 这里的void_t使得不具有下面五个成员的两种指针失配 typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference &gt; &gt; &#123; // defined if _Iter::* types exist typedef typename _Iter::iterator_category iterator_category; typedef typename _Iter::value_type value_type; typedef typename _Iter::difference_type difference_type; typedef typename _Iter::pointer pointer; typedef typename _Iter::reference reference; &#125;;template&lt;class _Iter&gt; struct iterator_traits : _Iterator_traits_base&lt;_Iter&gt; &#123; // get traits from iterator _Iter, if possible &#125;;template&lt;class _Ty&gt; struct iterator_traits&lt;_Ty *&gt; &#123; // get traits from pointer typedef random_access_iterator_tag iterator_category; typedef _Ty value_type; typedef ptrdiff_t difference_type; typedef _Ty *pointer; typedef _Ty&amp; reference; &#125;;// 注意 const _Ty *要单独拿出来偏特化，如果用上面的偏特化的话，我们得到的是const _Ty而不是_Tytemplate&lt;class _Ty&gt; struct iterator_traits&lt;const _Ty *&gt; &#123; // get traits from const pointer typedef random_access_iterator_tag iterator_category; typedef _Ty value_type; typedef ptrdiff_t difference_type; typedef const _Ty *pointer; typedef const _Ty&amp; reference; &#125;; 对象行为部分C++新标准中使用了is_...able&lt;&gt;函数代替了之前的has_...函数 reference_wrapper显然std::vector是不能存放T &amp;的，如果不希望放指针进去，可以使用std::reference_wrapper，不过这东西用起来也并不舒服，例如C++不能重载operator.，虽然最近有一些草案正在提到这一点，所以必须得get()一下。std::reference_wrapper常用于std::bind、std::thread等函数/类上。它们为了保证传入的参数在自己的生命周期中是持续存在的，决定始终通过传值的方式接受参数，即始终拷贝一份，因此此时如果要传递引用，就得使用std::ref包装一下了。 operator重载operator=、operator()、operator[]、operator-&gt;、operator T不能作为non-member function，这是因为担心与自动合成的operator=出现行为不一致的问题。其实还可以更深入地考虑这个问题，例如对于比较大小的运算符operator&lt;123456789101112struct A;struct B;struct A&#123; operator&lt;(const B &amp; b)&#123; return true; &#125;&#125;;struct B&#123; operator&lt;(const A &amp; b)&#123; return true; &#125;&#125;; 这显然是不符合逻辑的 const不是编译期常量在C++初始化方式中已经提到常量const是不能在构造函数体中初始化的，但可以在初始化列表中可以进行初始化，对于常量数组或者标准库的std::vector等容器，现在可以使用花括号{}进行初始化。需要额外说明的是const甚至不能作为模板参数等编译期常量使用。例如在MSVC2015中，下面的代码是无法通过编译的123456789101112struct C &#123; const int x; C(int _x) :x(_x) &#123; &#125;&#125;;int main() &#123; const C c(1); int a[c.x]; system("pause");&#125; 原因是在C.x虽然是常量，但是要到运行期才能知道，这里应该使用的是static const或者constexpr，const修饰符实际上的意义更接近于readonly。如果说const能够“节省空间”，那是由于其不可变，所以发生拷贝时，const对象实际上并不发生复制，但只const修饰的类成员仍然是占空间的。 特化using与函数相同，C++中的using也不能直接特化，如12345template &lt;typename T&gt;using wrap&lt;T&gt; = T;template &lt;&gt;using wrap&lt;int&gt; = int; 必须需要借助类来workaround1234template &lt;typename T&gt;struct wrap&#123; using type = T;&#125; 函数模板的特化与函数的重载为了实现函数的“多态”，常有借助模板类偏特化和重载两种方式。 借助重载实现函数的“偏特化”虽然函数模板不能偏特化，但函数本身就有重载，因此我们可以在每个不同的函数末尾加上一个tag来达到根据某些traits进行“分类讨论“的效果。例如最常用的std::true_type和std::false_type。在STL的实现中使用了很多这样的_tag来控制行为，例如控制std::advance()函数在接受五种不同迭代器时的更新行为，或者原子库中使用tag标记六种内存模型。即使当我们要“偏特化”的是非类型模板参数时，也可以直接利用重载而不是“偏特化”，这时候我们可以在类里面用enum或者static constexpr int将这个值封装起来，也可以直接借助于标准库的std::condition等函数。在下面的例子中，我们需求模板函数的行为根据std::is_same&lt;T, C&gt;::value进行分类讨论。1template&lt;typename T, typename U&gt; when_eq(T x, U y); // 1 在没有constexpr if的情况下，用函数重载来做是一种直截了当的方案。但是重载是对类型而言的，而if只能判断true/false值，非类型模板参数又不能使用整型以外的类型。所以必须要有个机制来将整型值包装成类型，这里可以借助标准库提供的std::integral_constant&lt;typename T, T val&gt;，或者也可以自己实现一个Int2Type或者Int2Type2。这个思路可以解决很多问题，例如对成员函数的偏特化。12345678910111213141516171819202122232425262728293031template &lt;int I&gt;struct Int2Type&#123; enum &#123; value = I &#125;;&#125;;template &lt;int I&gt;struct Int2Type2&#123; static const /* or constexpr */ int value = I;&#125;;struct X&#123;&#125;;struct Y&#123;&#125;;template &lt;typename T, typename U&gt; void when_eq(T x, U y, Int2Type&lt;1&gt;)&#123; puts("eq");&#125;template &lt;typename T, typename U&gt; void when_eq(T x, U y, Int2Type&lt;0&gt;)&#123; puts("neq");&#125;template &lt;typename T, typename U&gt; void when_eq(T x, U y)&#123; when_eq(x, y, Int2Type&lt;is_same&lt;T, U&gt;::value&gt;()); &#125;int main()&#123; when_eq(X(), Y()); when_eq(X(), X());&#125; 这里特别提一下enum的性质，根据标准在使用enum E {V1, V2}的值V1、V2时是不需要加上E::限定符的。此外其具体类型可以使用std::underlying_type获得。 借助类模板实现偏特化还可以使用类模板“偏特化”函数，如果需要上下文，那么可以重载operator()的方式实现一个仿函数，如果不需要上下文，可以在里面定义一个static函数。如果一定需要偏特化，考虑在一个偏特化类中实现static函数。这又带来一个新的问题，考虑要偏特化一个类中成员函数，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考这里的说明 普通函数、函数模板和全特化模板函数之间的决议在这一章节中，我们将讨论重载的普通函数、函数模板和其特化函数之间的决议顺序。模板函数一旦全特化，它就和普通函数一样成为一个strong symbol，我们应当使用inline，static，extern关键字防止重复定义。但是对于全特化的函数模板，它和不加template&lt;&gt;的普通函数还是有着很大区别的？根据C++ Premier中的说明 当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的 上面的话是说明template&lt;&gt;特化函数模板比普通函数的匹配要求更高，这是因为普通函数还能接受传入参数的隐式转换。我们在多个函数之间进行决议时总是选择最为精确的函数。 在这个例子中，a是int，显然主模板0能够精确匹配，于是决议到0，输出&quot;template&quot;。 1234567891011121314// #0template&lt;typename T&gt;void promotion(T x) &#123; puts("template");&#125;// #1void promotion(double x) &#123; puts("function");&#125;int main() &#123; int a = 1; promotion(a); // template&#125; 这个例子就是一个经典的SFINAE用法了，我们知道一个数组的大小只能是整数而不能是浮点数，所以当T是double时，char(*)[T()]就是ill-formed。根据SFINAE，我们不把它作为错误，而是转而寻求次优解。 1234567891011121314// #0template&lt;typename T, typename = char(*)[T()]&gt;void promotion(T x) &#123; puts("template");&#125;// #1void promotion(double x) &#123; puts("function");&#125;int main() &#123; int a = 1; promotion(a); // function&#125; 但我们必须要考虑一个特例，也就是当有多于一个函数能精确匹配的情况，这时候优先级的顺序是普通函数、全特化、主模板 普通函数先于全特化 1234567891011121314151617// #0template&lt;typename T&gt;void promotion(T x) &#123; puts("template");&#125;// #1void promotion(double x) &#123; puts("function");&#125;// #2template&lt;&gt;void promotion(double x) &#123; puts("template&lt;&gt;");&#125;int main() &#123; promotion(1.0); // function&#125; 全特化版本先于主模板 1234567891011121314// #0template&lt;typename T&gt;void promotion(T x) &#123; puts("template");&#125;// #1template&lt;&gt;void promotion(double x) &#123; puts("template&lt;&gt;");&#125;int main() &#123; promotion(1.0); // template&lt;&gt;&#125; decay 1234567891011121314// #0template&lt;typename T&gt;void promotion(T &amp; x) &#123; puts("template");&#125;// #1void promotion(int x) &#123; puts("function");&#125;int main() &#123; int a = 1; promotion(a); // function&#125; 考虑可访问性C++中的可访问性包括private、protected和public三类，可访问性是针对类而不是对象而言的。C++中重载决议是在可访问性检查之前进行的 考虑隐式类型转换在日常编程中，我们我们常常把字符串直接量当做std::string使用，但其实字符串直接量的类型是const char[]，这其中涉及到隐式构造函数或者隐式类型转换。这导致在进行重载决议时出现“不合常理”的情况。 普通情况在知乎的这篇问题中，我们看到Test中定义了两个成员函数。123456789101112131415class Test &#123;public: void find(const string &amp;first_name, const string &amp;last_name); void find(const string &amp;name, bool retied);&#125;;void Test::find(const string &amp;first_name, const string &amp;last_name)&#123; cout &lt;&lt; "find 1" &lt;&lt; endl;&#125;void Test::find(const string &amp;name, bool retied)&#123; cout &lt;&lt; "find 2" &lt;&lt; endl;&#125; 现在考虑下面的调用，我们发现是调用的find 2版本的函数。这是由于const char[]被decay成了const char *，然后隐式转换成了bool。 Test().find(&quot;a&quot;, &quot;b&quot;); 隐式类型转换的顺序类型隐式转换具有下面的顺序： 精确匹配 这里对应着四种的decay，即T[] -&gt; T*、T&amp; -&gt; T、F(...) -&gt; F (*)(...)、T const -&gt; T 无转换 lvalue到rvalue、数组到指针、函数到指针 限定符转换 我们可以为任意类型加上CV限定符。对于多重指针来说，前面的重数的限制要高于后面重数的限制，如 123char** p = 0;const char** p1 = p; // error: level 2 more cv-qualified but level 1 is not constconst char* const * p2 = p; // OK: level 2 more cv-qualified and const added at level 1 类型提升转换(promotion) 即Numeric promotions，包含Integral promotion和Floating-point promotion 这里注意，非promotion的整数之间转换都作为conversion，如char -&gt; int 标准转换 包含Numeric conversions，如Integral conversions、Floating-point conversions、Floating–integral conversions、Pointer conversions、Boolean conversions 用户自定义转换 这就包括了std::string中定义的从const char *的转换了 注意能进行隐式类型转换并不意味着类型相同，所以使用std::is_same进行的判断都是false，例如下面的代码输出都是false。12std::cout &lt;&lt; std::is_same&lt;int, int &amp;&gt;::value &lt;&lt; '\n';std::cout &lt;&lt; std::is_same&lt;int, const int &amp;&gt;::value &lt;&lt; '\n'; 考虑传参时decay的特殊情况紧接着上面的讨论，我们查看下面的一段代码，这时候输出就变成true了，究其原因是因为123456789template&lt;typename T, typename U&gt;bool check(T x, U y)&#123; return std::is_same&lt;T, U&gt;::value;&#125;int main()&#123; int a = 1; const int &amp; b = a; std::cout &lt;&lt; check(int(), a) &lt;&lt; '\n';&#125; 同样是类型转换问题，在文章中提到了一个特别的情况123456789101112template &lt;typename T&gt;int compare(const T&amp; a, const T&amp; b)&#123; std::cout &lt;&lt; "template" &lt;&lt; std::endl; return 0;&#125;int compare(const char* a, const char* b)&#123; std::cout &lt;&lt; "normal" &lt;&lt; std::endl; return 0;&#125; 现在调用 compare(&quot;123456&quot;, &quot;123456&quot;); 请问是调用了那个函数呢？有意思的是，对于不同编译器，结果还不一样。作者指出对G++/clang来说是调用了模板版本，而我使用VS2015发现调用的是普通版本。调用模板版本的原因是T = const char [6]相比退化后的const char *更精确。但是调用普通版本的原因是数组传参时要decay成对应的指针。因此对于模板函数和普通函数实际上都不是精确匹配的（都要经过一次类型转换）。根据C++重载决议原则，如果调用具有二义性，则优先选择调用普通函数。在本篇结尾，作者引用陈硕的观点，认为G++/clang的实现是符合标准的，但是这属于标准的bug。其原因是模板实参推断(template argument deduction)时，除了产生新的实例化之外，编译器只会执行两种转换 const转换：接受const引用或指针的函数可以分别用非const对象的引用或指针来调用，无须产生新的实例化。也就是可以传一个非const到需要const参数的函数。 数组或函数到指针的转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针，函数实参当作指向函数类型的指针。 由于模板参数使用了数组的const引用类型，所以按照标准应该不将数组向指针进行decay。 考虑继承SFINAE在C++中常常出现一些ill-formed的代码，这些代码在函数体或者其他地方出现编译器都是要报错的，SFINAE(Substitution Failure Is Not An Error)规定，当推导模板参数失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。我们需要注意，这样的替换发生在下面四种情况下： (Type SFINAE)所有用于函数的类型，包括函数的返回值与参数的类型 (Type SFINAE)所有用于模板参数的类型 (Expression SFINAE)所有用于函数类型中的表达式 (Expression SFINAE)所有用于模板形参声明中的表达式 这些常被使用的ill-formed代码包括下面的形式： 试图实例化含有多个不同长度包的包展开 试图创建void的数组、引用的数组、函数的数组、抽象类类型的数组、负大小的数组或零大小的数组 例如之前提到过的char(*)[0.5]，还有char [0]、void [3]等 试图在::左侧使用非类或非枚举的类型 比如int::field是错的 试图使用类型的不存在的成员 比如vector&lt;int&gt;::abcdefg是错的，因为它肯定没有这个字段 试图在错误的地方是用类型的成员（类型、模板、非类型如literal等） 试图创建指向引用的指针 试图创建到 void 的引用 试图创建指向T成员的指针，其中T不是类类型 这个常常可被用来判断T是否是类类型，代码如下所示。这里C::*表示一个指向类C中某int类型成员的指针，说明了这个指针带有C的上下文，而...相当于一个兜底的东西。 12345678910111213141516template&lt;typename C&gt; bool test(int C::*)&#123; return true; // C是类&#125;template&lt;typename C&gt; bool test(...)&#123; return false;&#125;struct X&#123; double x; &#125;;int main() &#123; cout &lt;&lt; test&lt;int&gt;(0)&lt;&lt; endl; // false cout &lt;&lt; test&lt;X&gt;(0)&lt;&lt; endl; // true&#125; 试图将非法类型给予非类型模板参数 这个SFINAE将在后面std::void_t中被广泛使用 试图进行非法转换 试图创建拥有形参类型void的函数这个SFINAE对应于前面的“试图将非法类型给予非类型模板参数” 试图创建返回数组类型或函数类型的函数 试图创建参数类型或返回类型为抽象类的函数类型 自然而然地想到如果我们需要判定某个实体是否具有某种性质，我们就可以构造一种没有这种特性就会造成ill-formed的表达式或者类型（分别对应Expression SFINAE和Type SFINAE），然后通过函数重载或者模板类的偏特化来进行分类讨论。在使用函数重载时，我们常常在函数最后放一个可能会ill-formed类型的指针。 使用SFINAE判断是否存在成员SFINAE分为两种，通常见到的是Type SFINAE。关于Expression SFINAE，可以参考这个回答 模板偏特化是相对原型/初等/主(primary template)模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板。例如对模板类型参数T而言，T*、T&amp;、const T &amp;等是它的一个偏特化。通过偏特化我们可以进行分类讨论。1234567891011// 终止条件template&lt;typename Cont&gt;bool handle_container(Cont &amp; cont) &#123; puts("not a container");&#125;;template&lt;typename Cont&gt;bool handle_container(Container&lt;Cont&gt; &amp; cont) &#123; puts("container"); handle_container(cont[0]); &#125;; 偏特化可以用来检查一个类中是否具有某个成员123456// https://www.zhihu.com/question/34264462template&lt;typename Cont, typename = void&gt; struct has_push_back : std::false_type &#123;&#125;;template&lt;typename Cont&gt;struct has_push_back&lt;Cont, std::void_t&lt;decltype(&amp;Cont::push_back)&gt;&gt; : std::true_type &#123;&#125;; 始终对std::vector&lt;int&gt;断言失败。后来查看SoF，当时以为是MSVC2015对std::void_t的支持有问题。后来在SoF的另一篇博文上发现如果我们的push_back不是成员函数而是数据成员就可以通过。去SoF上问了一波，这是因为std::vector&lt;int&gt;::push_back有多个重载版本，于是应该还要匹配函数签名，因此我们可以写成下面的形式，我们显式构造了vector.push_back(vector::value_type())这个表达式，看它是不是合法。123456789// https://www.zhihu.com/question/34264462/answer/58260115template&lt;typename Cont, typename = void&gt;struct has_push_back : std::false_type&#123;&#125;;template&lt;typename Cont&gt;using ValueType = typename Cont::value_type;template&lt;typename Cont&gt;struct has_push_back&lt;Cont, std::void_t&lt;std::declval&lt;Cont&gt;().push_back(declval&lt;ValueType&lt;Cont&gt;&gt;())&gt;&gt; : std::true_type&#123;&#125;; 注意到我们这里都是用类的偏特化来实现的，我也尝试了下使用函数搞一搞12345678template&lt;typename Cont, typename = void&gt; bool has_push_back() &#123; return false;&#125;template&lt;typename Cont, typename = std::void_t&lt;decltype(&amp;Cont::push_back)&gt;&gt; bool has_push_back() &#123; return true;&#125; 这样会出现函数模板已经定义的错误。在cppreference中给出了说明 A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal. 此外在SoF 上给出了如下说明 SFINAE only works for deduced template arguments 判断模板参数是否是广义函数目前广义函数包括函数、std::function、lambda、仿函数，其中std::is_function只能识别函数。C++17标准添加了std::is_invokable(即之前的std::is_callable)，用来表示可以INVOKE的类型。 实现member function的const版本有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据stackoverflow，可以直接const_cast this指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去 推导lambda的类型根据StackOverflow上的这个答案，lambda是函数对象而不是函数，但是可以被转换(convert to)成std::function，这是由std::function的可以有所有能被调用的类型构造，也就是说这可以这么写std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };。但是类型推导是另一回事，因为lambda并不是std::function，我们只能用auto来声明一个lambda表达式，所以编译器不能通过一个lambda去推导std::function的参数。BTW，Effective Modern C++指出使用auto关键字相对于使用显式声明是比较好的。具体得来说他可以避免default initialization的变量、难以表示的类型、避免可能造成的类型截断问题。特别地，标准指出一个不捕获lambda表达式可以被转成一个函数指针，但是将这个lambda表达式转成函数指针需要一些技巧，如借助lambda表达式和不借助lambda表达式。特别地，函数指针可以看做函数的入口点，它是全局的，而一个函数对象如std::function可以携带context，所以是不能转换为一个函数指针的。在这里还需要将函数签名与函数指针区分开来，一般在使用函数签名的场合常需要考虑C linkage。因此比较好的解决方式是直接使用template&lt;typename F&gt;，所以说现在的问题是如何得到F的返回值类型。这时候可以借助std::result_of来推导typename F的返回类型，注意这里要写成decltype(lambda_func)()，而不是decltype(lambda_func)1234auto lambda_func = []()&#123; return 1 + 2;&#125;;using lambda_func_t = std::result_of&lt;decltype(lambda_func)()&gt;::type; 此外，经测试可以推导函数对象的返回类型，不能推导C原生函数的返回类型。1234567891011121314151617181920int native_func(int a) &#123; return 0;&#125;struct object_func &#123; int operator()(int a) &#123; return 0; &#125;&#125;;template&lt;typename F&gt;auto call_func(F f)-&gt; std::result_of_t&lt;F(int)&gt; &#123; return 0;&#125;int main() &#123; typename std::result_of&lt;object_func(int)&gt;::type x; // Yes typename std::result_of&lt;native_func(int)&gt;::type y; // No object_func of; call_func(of); // Yes call_func(native_func); // Yes system("pause");&#125; 参考了StackOverflow上的答案，这是因为原生函数并不是一个type，但是std::result_of&lt;F(Args...)&gt;中的F必须要是一个类型，合适的解决方法是直接使用decltype+declval，decltype(native_func(std::declval&lt;int&gt;()))，而不是用std::result_of。此外，在C++17标准之后，可以使用std::invoke_result来替代std::result_of。此外，从这个回答可以看到，可以实现一个function_traits。这个类型类似pattern matching，能够同时处理函数对象和函数的指针的情况，并且能够推导出参数和返回值。1234567891011121314template &lt;typename T&gt;struct function_traits : public function_traits&lt;decltype(&amp;T::operator())&gt; &#123;&#125;;template &lt;typename ClassType, typename ReturnType, typename... Args&gt;struct function_traits&lt;ReturnType(ClassType::*)(Args...) const&gt;&#123; enum &#123; arity = sizeof...(Args) &#125;; typedef ReturnType result_type; template &lt;size_t i&gt; struct arg &#123; typedef typename std::tuple_element&lt;i, std::tuple&lt;Args...&gt;&gt;::type type; &#125;;&#125;; 在类模板中声明友元函数模板在一个模板类farray中声明一个友元函数123456789template&lt;typename T&gt;struct farray&#123; // ... friend farray&lt;bool&gt; operator&lt;(const farray&lt;T&gt; &amp; x, const T &amp; y);&#125;template &lt;typename T&gt;farray&lt;bool&gt; operator&lt;(const farray&lt;T&gt; &amp; x, const T &amp; y)&#123; // ...&#125; 可能会报error LNK2019: 无法解析的外部符号 “struct for90std::farray __cdecl for90std::operator&lt;(struct for90std::farray const &amp;,int const &amp;)” (??Mfor90std@@YA?AU?$farray@_N@0@AEBU?$farray@H@0@AEBH@Z)错误原因是T是类模板farray的模板参数，随着类模板特化。所以应该给友元函数operator&lt;独立的模板参数，改成这样就好了1template&lt;typename U&gt; friend farray&lt;bool&gt; operator&lt;(const farray&lt;U&gt; &amp; x, const U &amp; y); 详细可以参考这篇答案 通用引用根据Effective Modern C++ Item 24的规定。函数签名中的T&amp;&amp;，如果T是需要推导得来的，这样的T表示通用引用(universal/forward reference)。通用引用是C++通过引用折叠(reference collapsing)表现出的一个特性，一个通用引用可以绑定到任何由cv修饰的引用上。容易混淆的通用/右值引用包括1234567891011121314151617181920// 以下属于rvalue referencevoid f(Widget&amp;&amp; param);Widget&amp;&amp; var1 = Widget();// 通用引用定义必须是T&amp;&amp;或者auto&amp;&amp;的形式template&lt;typename T&gt;void f(std::vector&lt;T&gt;&amp;&amp; param)class vector&lt;T, allocator&lt;T&gt;&gt;&#123;public: // 通用引用中必须发生类型推导 void push_back(T&amp;&amp; x);&#125;;// 以下属于universal referenceauto&amp;&amp; var2 = var1;template&lt;typename T&gt;void f(T&amp;&amp; param); 如果对于参数包不加上通用引用Args&amp;&amp;，那这个参数包就不能接受一个左值。1234567891011121314151617181920212223template &lt;typename T, typename ... Args&gt;void test_pack_lvalue(T &amp; x, Args ... args) &#123; x = 1; test_pack(forward&lt;Args&gt;(args)...);&#125;template &lt;typename T, typename ... Args&gt;void test_pack_lvalue(T &amp; x) &#123; x = 1;&#125;template &lt;typename T, typename ... Args&gt;void test_pack_clvalue(const T &amp; x, Args ... args) &#123; test_pack_clvalue(forward&lt;Args&gt;(args)...);&#125;template &lt;typename T, typename ... Args&gt;void test_pack_clvalue(const T &amp; x) &#123;&#125;int main()&#123; int a = 0, b = 0, c = 0; test_pack_clvalue(a, b, c);&#125; 常用术语参数包：parameter pack类型限定符（const, volatile）：qualification adjustment返回类型后置：trailing return type函数签名：signature模板类型推导：template argument deduction聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释非类型模板参数：non type template parameter包扩展：pack expansion花括号初始化器：brace-init-list省略号(…)：ellipsis符号扩展、零扩展：sign/zero extension可变参数模板：Variadic Templates pack展开模式：pattern决议：resolution]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ICPC CHINA-FINAL小记]]></title>
    <url>%2F2016%2F12%2F11%2FICPC%20CHINA-FINAL%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[退役之战 正式赛赛题热身赛虽然是GCJ或者APAC的题目，然而特意刷了一遍的我并没有什么映像啊。第一题是求2的多少进制都是1，推出一个等比数列，套求和公式，然而发现爆long long就WA了，于是我建议遍历位数，二分底数，zyyyyy很快敲了一发WA了，后来他发现还是会爆long long，于是又敲了一发又WA了。然后我看他的代码发现他的算B的n+1次幂Sn+1的时候使用Sn * B &lt; 0来判断溢出，然而只有加减法才可以这么用，于是我让他改成LONGLONG_MAX/B来判溢出，结果1A了。一进门首先发现午饭已经发了。。。Google出题一般一头一尾是水题，zyyyyy直接过掉了A，L我们在找规律，zyyyyy直接dfs过掉了，下面就是搞D和H 感受 熟悉的shu，熟悉的体育馆，熟悉的安检，熟悉的烂键盘，熟悉的小屏幕，熟悉的沙滩椅，熟悉的羽绒背心，熟悉的80元卡（终于可以挂在脖子上了） 热身赛结束的时候陈老师居然找到我们后面的sjtu退役队玩（后来发现是是叉姐的队！我们居然没认出来！），然后我们求合影，然后发现杜老师也在，酸酸地说粉丝要和你合影，于是我们和两位老师合了影（好像还是叉姐帮我们拍的照片，啊~~） 图书馆下面的超市居然这次不收税了！于是我们九张卡扫荡了一波，晚饭直接零食解决了，然后大家都好污啊。。。 抓娃娃机好坑啊 热身赛遇到了几个巴基斯坦学生 上大旁边的一条街真是无敌了，什么吃的都有 我认为对于一个努力的人来讲，他自己到最后不一定在意这个结果了，因为他自己的进步本身就是对自己的认可了。但对于我来说，我有过痛苦的经历，我希望每一个努力的人都能获得一些外界的认可，就算他自己不在乎。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>现场赛</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NUAA-HHU联赛小记]]></title>
    <url>%2F2016%2F12%2F04%2FNUAA-HHU%E8%81%94%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天参加NUAA-HHU联赛，拿了1030分，第六，出了9条。这是排行榜 正式赛赛题一进机房发现妈的旁边的都是触屏的大屏幕，就我们是小屏幕。机器是windows，只带devc。发题目之前看了I，觉得比较难搞，纸质题目发下来我从后向前切，zzzyy从前向后，zyyyyy调完devc看了A有思路说我们不要看了，敲完1A，这时候我已经放弃了ML两条，K题面样例有问题，我和zzzyy吐槽了，于是zzzyy去看，我看J觉得是dp，推了一下有了结果，给zzzyy讲了他觉得有道理，不过这时候zyyyyy过了C在做比较麻烦的D，于是我先压着，看一看榜B过的很多，看B卧槽不就是NOI2016那条膜蛤题么，知乎上看到过的，zzzyy觉得H能做就是找出两个只出现一次的数（其他出现两次），于是搞了一波nlogn算法T了，zyyyyy说有O(n)的算法，于是他去搞D，然后我想n的算法，zyyyyy1A了D之后（我们第一了）我突然灵光一现想到只有一个出现一次的数就xor就行了，两个不知道是否可以，问zyyyyy觉得是有方法的，于是我偷着百度一下发现可以按照lowbit出来的那一位分成两组分别异或这样就是两个重复的数了。交了T，妈的有常数解法？我觉得判题有问题，于是问了贴气球（在墙上）的人，他们说没有多组样例，妈的去掉while != EOF就1A了，结束后发现nlogn也能过，真是醉了。然后搞完BH，zyyyyy写I，看榜发现GEFK有人在搞，G最多，推了一会儿G没结果，然后zyyyyy的I wa了两次然后他发现了问题准备想怎么解决。于是我说我来想你先把我有思路的J敲了呗，于是J1A了，还是一血，我很高兴于是上了个厕所，然后在厕所我突然想到可以从边界的O开始DFS，这些O肯定不会被消掉，其他的O肯定会被消掉，回来很兴奋告诉zyyyyy，zyyyyy觉得是对的，改了一下A了。所以说上厕所还是很关键的。后来zyyyyy就决定xjb搞G，直接预处理以下就过了。这时看到好多人E拿了90分估计是T了，F也有若干的过了，LM各过了一个，于是我建议zyyyyy线段树搞一下E水个90，然后我们研究下FLM，zyyyyy交了一下E发现90分不错，但是是没有错误提示的RE，赛后告诉我们90分就算A了。这时候我都在推L，首先floyd是肯定的，然后我觉得就是一个01背包，不过我以为k是定值（实际上人家是k_i），所以状态转移推错了。然后我就建议zyyyyy搞一搞F，用不等式缩小一下范围，zyyyyy上了个二分的优化居然搞出来60分，K暴力一波40分。然后搞M大模拟，zyyyyy用pq实现了一波，但是样例没过，于是换sort水了40分，后来觉得应该是平衡树，于是上map红黑树，卧槽这次只有30分了，于是放弃。后来发现其实一开始的思路是对的，只是在分蚯蚓的时候加上(i-1)q就行了。 感受 晚上吃了北京烤鸭，在那边9+1玩了狼人杀，我当了两次预言家三次警长。感觉有些人玩的挺好的，有些人是新手所以有不少漏洞可以钻。第一局大家都太水了。第二局我是预言家和警长，第一轮测了zyyyyy狼，发言的时候我先评价了别人的发言点了一下我怀疑的几个人然后归票zyyyyy，虽然我之前说了我已经我归票的人我认为狼面是最大的，不过大家显然不太适应我的套路于是把我投死了（其实我直接跳预言家得了），于是我把警徽撕了，到最后sxm的猎人被杀了，但是她忘了带人了。最后剩zyyyyy一条狼，不过最后zzzyy的解药可能因为上帝hj没提到吧没有用在自己身上所以神都死光了，所以狼居然赢了。第三局sxm上帝，我是平民，然后zzzyy（平民）选了警长，不过他第一轮就被杀了，然后他点了三个人觉得是狼（无敌了全中）就把警徽给我了（卧槽为啥这么信任我）。发言阶段wdf没说话，zjt附和zyyyyy，于是我归票wdf，只有zqh投了zjt。第二轮平安夜，hj表示很奇怪因为她是女巫然后她觉得她没救sxm，然后事情就很明显了，我甚至有点怀疑我上局杀错了wdf，因为大家毫不犹豫就投了wdf（后来发现是狼放弃铁狼了）。不过zys说怀疑zzzyy是狼，不过我觉得他要是狼完全可以把警徽给狼队友。因此我归票zjt，这时候预言家还不跳，zqh我觉得又不是预言家，不过这时候女巫和未跳的猎人（zyyyyy），所以我有点担心是不是zzzyy预言家强行装平民。第三天天黑了然后女巫毒死了最后一头狼，游戏结束。 OJ交题各种等，气球发不全，没打印服务只好强行手机调试。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2016宁波总决赛小记]]></title>
    <url>%2F2016%2F11%2F28%2FCCPC2016%E6%80%BB%E5%86%B3%E8%B5%9B%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CCPC2016宁波总决赛小结，唉dalao太多了，这场就是去膜的。 正式赛赛题Google出题一般是一头一尾水题，就像热身赛喜欢出GCJ或者招聘笔试题一样，首先zzzyy从头开始切，我从尾巴开始切，zyyyyy调配置。我看最后的L的题目夏令时便觉得能做（之前有人在群里发白皮黄点的气球觉得这条是金牌题），简单推了下就把模板给了zyyyyy。这时候zzzyy也发现了A的规律，之前WA了一片的A后来又重测过了许多，于是先交A1Y，然后zyyyyy慢慢敲L，我切J题，讲的就是icpc出线调参的事情，就是暴力枚举一下Y。过了L之后zyyyyy敲J，不过他犯了两个低级错误，所以到了11点才写完，这时我们3Y，已经在铜末了。对面的tju一队还不如我们，后面的河南大学软件学院的老朋友（他们合肥站在我们对面）还是1个气球（话说他们热身赛第一条拿了一血），他们对面的q神已经5Y了。在zyyyyy敲J的时候我在看B，zzzyy在看H。我想了想B觉得只有洗衣机的情况那就是贪心最早结束的方案，现在再加了一个烘干机，应该还是宜早不宜迟，因为衣服尽早洗完可以再等。所以我觉得就使用一个pq来维护洗每件衣物时每个洗衣机/烘干机的结束时间选最早的就行了。zyyyyy觉得这个想法也是可以的，但是他用了一个比较复杂的线段树来实现。这时候我和zzzyy看H题，之前zyyyyy觉得是网络流，但仔细看了之后觉得这个是互斥的，所以用不了网络流，应该是个dp，我推了一会儿觉得有点问题，如果取dp值为方案数的话实际上可以有很多个最优的选择，因此具体选哪个还需要继续搜索。而zzzyy那边的搜索思路他觉得应该会超时。后来马上要封榜了我们还是卡BH，然后我就建议zyyyyy强行刚一波H，然后我和zzzyy再想点B的样例。zyyyyy不负众望在还有20分钟的时候用状压dp过了，复杂度1e10也过了。与此同时zzzyy和我想了很多B的样例结果都是可行的，于是我们觉得可能实现上有问题。比赛结束后我们问了对面天津大学的一队，结果他们用了一个奇妙的二分答案过的，对于我们的想法他们说是过不了2 2 2 5 3 3 5这样的样例的。不过其实官方解法是把烘干机当做洗衣机的逆过程，维护两个pq最后匹配一下。很多dalao陪伴我们死在这条题上，最后I题过的居然比B要多了。 感受 宁波真冷，风太大，比赛组委会居然发的长袖t恤，比赛的时候张老师给我们买了几个暖宝宝贴在肚子上和腿上 我们周五下午去了天一阁、月湖公园和南塘老街，感觉那天宁波烟雨蒙蒙特别漂亮，晚上在南塘老街吃了奉化牛肉面超级大块的牛肉感觉很好吃。 周六上午我们去了宁波博物馆，在宁波历史那边有个大叔讲的特别认真，带我们从河姆渡一直讲到清朝。 学校食堂晚上居然是自助餐，吃的撑死了，最后拿喝饮料的杯子装了三四个鸡翅回去吃 大佬太多了，开幕式和讲题看到了xiaodao，正式赛结束我们还要到了q神的签名。第一名clj队比赛结束后还在搞K题，难怪他们那么强 回南京的路上我们在高铁上和张老师朱老师一起玩你画我猜，然后发现zzzyy居然不知道费列罗（好可怜） 热身赛的时候大家发挥聪明才智测评测机的T，为了避免O2的优化，最后还用了random，后来发现评测机跑的比本地快多了 周五晚上张老师和朱老师请我们吃了12个鸡翅两块华夫饼和饮料，然后拉我们谈了超级久，从ACM队谈到学院的创训。 其实我校ACM起步很晚的，是从13年参加的邀请赛，然后打到南京赛区的名额开始的，据说那场比赛GB就和中国的组委会闹翻了（难怪2014年开始取消中国组委会，2015搞出CCPC）。其实学长不仅搞ACM，而且英特尔杯获得某评委的青睐，然后虽然做得有点离题但还是给了二等奖，说到要注册几个CF或之类账号看看训练情况，要给ACM的队员排名。然后水上明珠BBS居然是张老师上学的时候的一个土豪大神（还是我老乡）同学（后来他创业了）搞出来的，之前还写了好多小游戏，结果有人痴迷于游戏把成绩弄掉了。话说那时候还没有勤学楼，大家只有做课设的时候才有电脑，而且大四的时候有特别多的大课，比如操作系统软件工程啥的（卧槽大三都学啥啊）。大家对创训最后放弃的人进行了吐槽，然后说了说关于专利和写文档的事情。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合博弈]]></title>
    <url>%2F2016%2F11%2F23%2F%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88%2F</url>
    <content type="text"><![CDATA[总结一下网上教程关于组合博弈的部分要点 Nim 博弈Nim游戏的典型形式是假设有N堆石子数量是 $ a_1, a_2 .. a_n $，两人轮流从某一堆取若干个（不能一个不取），最后不能取的人算失败。为了解决这个问题，先定义必败态，也就是先手必败，这里先手必败指的不是游戏开始时的先后手，而是指的当前局面的先后手。必败态的所有的下一步都是非必败态，非必败态存在某个下一步是必败态。因此假设A此时拿到一个必败态，那么无论他如何移动，都会留给B一个非必败态；而B的非必败态经过移动可以留给A一个必败态。可以发现，如果每一堆的石子数的和异或起来为0的话，当前状态是必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = 0 $ 是必败态（Bouton’s Theorem）。这是因为： 不能取时每一堆石子都是0，因此异或的结果还是0，因此是必败态 假设此时A是一个必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = 0 $，假设存在$ a_i $使得取完之后的 $ a’_i $ 也满足异或结果为0。由于异或具有消去律，因此$ a’_i = a_i $ 假设此时A是一个非必败态，即 $ a_1 \ xor \ a_2 \ xor \ .. \ xor \ a_n = k \neq 0 $，总能找到一个 $ a_i $ 使得 $ a_i \ xor \ k \lt a_i $，这样的构造只需要 $ a_i $ 把 $k$ 最高位的1异或掉就行了。这样把 $ a_i $ 替换成 $ a_i \ xor \ k $ 就能得到一个新的异或为0的必败态给对方。 ICG和SG函数由此可以引出ICG和SG函数，刚才的必败态对应于SG函数中的P-position，P是Previous，指的是刚取完石子的那人赢，因为只有两个人玩，所以就是先手输。对应的状态是N-position，N指的是Next。ICG（Impartial Combinatorial Games）指的是公平组合游戏，满足下面的性质： 两名选手轮流行动，每一次行动可以在有限合法操作集合$ f $中选择一个，若轮到某位选手时，该选手的合法操作集合为空，则这名选手判负 游戏的任何一种可能的局面（position），合法操作集合只取决于这个局面本身；局面的改变称为“移动”（move） 任何一个ICG都可以通过把每个局面看成一个顶点，对每个局面和它的子局面连一条有向边来抽象成一个有向无环图。如果 $\langle x, y \rangle \in E$，表示从x局面可以到达y局面。 首先定义mex（minimal excludant）运算，这是施加于一个集合的运算，表示最小的不属于这个集合的非负整数。例如 $ mex \lbrace 0, 1, 2, 4 \rbrace = 3 $，$ mex \lbrace \rbrace = 0 $。对于ICG对应的DAG中的每一个顶点（局面），定义SG函数 $ sg(x) = mex \lbrace sg(y) \mid \langle x, y \rangle \in E \rbrace $。当 $ sg(x) = k $ 时表示 $ \forall i \ , 0 \le i \lt k, \ \exists \ \langle x, y \rangle \in E, \ sg(y) = i \ $ ，也就是说，$k = sg(x)$ 是最小的不属于 $sg(y)$的值，其中$y$是$x$的所有后继局面。下面介绍这个值的具体意义。事实上SG函数拥有和Nim游戏同样的性质，$ sg(x) = 0 $ 对应着必败态，$ sg(x) \neq 0 $ 对应着非必败态，表示通过可选操作 $ k = sg(x) $ 个可以到达一个P状态。以一个较为简单的取石子问题为例，假设有1堆n个的石子，每次只能取1、3、4个石子，先取完石子的人胜利，求各个状态的SG值。现在定义SG函数$sg(i)$为状态i下的石子数，显然有$sg(0) = 0$，设操作$f=[1,3,4]$表示可以取1、3、4个石子。当$x=1$时，可以取走$1$个石子（不能不取），$y = \lbrace 0 \rbrace$，$sg(1) = mex \lbrace sg(1) \rbrace = 1$当$x=2$时，可以取走$1$个石子，$y = \lbrace 1 \rbrace$，$sg(2) = mex \lbrace sg(2) \rbrace = 0$当$x=3$时，可以取走$\lbrace 1, 3 \rbrace $个石子，$y = \lbrace 0, 2 \rbrace$，$sg(3) = mex \lbrace sg(0), sg(2) \rbrace = 1$当$x=4$时，可以取走$\lbrace 1, 3, 4 \rbrace $个石子，$y = \lbrace 0, 1, 3 \rbrace$，$sg(4) = mex \lbrace sg(0), sg(1), sg(3) \rbrace = 2$当$x=5$时，可以取走$\lbrace 1, 3, 4 \rbrace $个石子，$y = \lbrace 1, 2, 4 \rbrace$，$sg(5) = mex \lbrace sg(1), sg(2), sg(4) \rbrace = 3$现在假设A面临5个石子的局面，他选择可选操作“取3个”，将剩2个石子的局面留给B，B发现$sg(2) = 0$，是个必败态，无论他如何取都将不敌A。对于刚才的取石子游戏，可以想象成在A和B一个有向图上从开始的点轮流沿有向边移动棋子，直到到达一个出度为0的点。而SG函数的意义表示一堆石子的个数。而现在有n堆石子，每一堆石子都对应一个SG函数，这个游戏就可以分成n个子游戏。对于这样的情况，有Sprague-Grundy Theorem给出该游戏的和的SG函数值是它的所有子游戏的SG函数值的异或，即 $ sg(G) = sg(G_1) \ xor \ sg(G_2) \ xor \ .. xor \ sg(G_n) $。 例题 POJ 2505题意设p初始值为1，A和B轮流对p乘上一个2和9之间的数，谁先大于等于n谁就获胜]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git rebase 用法]]></title>
    <url>%2F2016%2F11%2F19%2Fgit-rebase%2F</url>
    <content type="text"><![CDATA[随着工程量的提升.git文件夹会变得越来越大。特别是我们只在master一个分支上进行提交，由于里面有很多没用的中间提交，所以希望能够将这些提交删除或者合并，这就用到git rebase这个命令。有的时候我们有若干个branch，对一个branch进行rebase会影响到其他的branch么？这里做了个实验 rebase对branch的影响新建git仓库1234567891011git initecho "1" &gt; test.txtgit add .git commit -m"1"echo "2" &gt; test.txtgit add .git commit -m"2"echo "3" &gt; test.txtgit add .git commit -m"3"git branch 0.1 查看此时log123456789101112131415161718$ git logcommit d299f0788909111c0a9d13dfb756f901092c85ceAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:41 2016 +0800 3commit b601f3c9e5b4b814eefb5889d5110076ec234304Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2commit b6a00666d366a77ab03bac5f79b035a705a9d64cAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 rebase master将master分支的3号commit合并到2号commit上1234$ git rebase -i --root[detached HEAD 00d6d06] 2 1 file changed, 1 insertion(+), 1 deletion(-)Successfully rebased and updated refs/heads/master. 这里选项-i表示使用交互式的修改方法，你可以使用vim等编辑器来进行修改。选项--root表示从头开始，如果只想对最近的n个提交进行修改，可以使用HEAD~nrebase命令如果不跟分支，默认为当前分支。再次查看master的git log1234567891011121314$ git logcommit 00d6d06ef697290483cbab5f5e6324491abb5f85Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2 3commit 55cb8ae13c8cef61c3bf7b89ce3001eac29de630Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 发现已经成功合并。这里额外说明一下，提交2和提交3的备注信息”2”和”3”被合并到了一起作为一个新提交，这是由于squash选项造成的，如果我们选择fixup选项，那么提交2和提交3会直接消失12345$ git logAuthor: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Fri Sep 22 19:01:48 2017 +0800 1 回到我们刚才squash得到的结果，查看0.1分支的git log12345678910111213141516171819$ git checkout 0.1$ git logcommit d299f0788909111c0a9d13dfb756f901092c85ceAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:41 2016 +0800 3commit b601f3c9e5b4b814eefb5889d5110076ec234304Author: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:27 2016 +0800 2commit b6a00666d366a77ab03bac5f79b035a705a9d64cAuthor: unknown &lt;calvinneo1995@gmail.com&gt;Date: Sat Nov 19 18:12:07 2016 +0800 1 发现并没有变化于是结论很显然，git rebase只会影响当前分支。rebase会导致git生成一系列全新的提交，但内容包括时间是保留的。 rebase对annotation tag的影响新建tag按照上面的步骤重新构建了一个git仓库，下面对提交2（a8ede39f9ff56c4a43ee89e80ba30c0aad8f2f26）打tag1$ git tag -a v0.1 a8ede3 切换到v0.1的tag12345678910111213$ git checkout v0.1Note: checking out 'v0.1'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_nameHEAD is now at a8ede39... 2 注意到这里说明现在在一个’detached HEAD’ state，这是因为tag 相当于是一个快照，是不能更改它的代码的，如果要在 tag 代码的基础上做修改，新建一个分支。下面看一下这个detached HEAD的提交历史123456789101112$ git logcommit ed4c38d8247a454b49a97962006ccaa659cae32cAuthor: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 2commit 2b84833dd18c6802893029c7c0dfaa781ec20aa8Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 1 发现提交1还在下面回到master分支，并将master分支压缩成一个分支1234$ git rebase -i --rootpick fea1e3c 1s a8ede39 2s 9b9a18c 3 再次查看log123456789101112$ git logcommit a8ede39f9ff56c4a43ee89e80ba30c0aad8f2f26Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 2commit fea1e3cf0a1939544ae01f1160d2c87c2960e661Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Sun Jan 22 14:49:32 2017 +0800 1 发现tag的log并没有改变 git rebase的合并冲突解决这常发生在试图将一个分支整体与另一个分支合并的情况下首先使用git status查看冲突的文件，解决冲突后git add .，然后git rebase --continue在任何时候如果发现之前的冲突解决错误，可以通过git rebase --abort回滚到rebase前的状态 其他的修改提交的方法amendgit commit --amend指令能够修改最近的一次提交。不过commit id会变amend前123456$ git logcommit 544c674ff6ad80b87d871a1db1fe01a37536804cAuthor: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Fri Sep 22 19:01:48 2017 +0800 1 amend后123456$ git logcommit 32158167b057faacc5c91c1e63451e28612c13f6Author: Calvin Neo &lt;calvinneo1995@gmail.com&gt;Date: Fri Sep 22 19:01:48 2017 +0800 1 不过如果在amend之前将原commit push到远程仓库了的话，那会引起冲突，最省事的办法就是很不优雅地git push origin --force。对于gitlab这样的代码仓库，可能还要将Branch Protect去掉才能强行push。 hard reset]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd求最小环]]></title>
    <url>%2F2016%2F11%2F17%2FFloyd%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[使用Floyd算法求最小环 FloydFloyd算法原理是对于点k = [1..n]，尝试用它来松弛边(u, v)。在实现时维护 $ dist[n][n] $ 数组，用来表示i和j之间可以通过$ 1..k $的最短路径。因此算法复杂度为 $ O(n^3) $ ，能计算任意两点最短路径，能够处理负边。Floyd计算最小环时，考虑k的两个邻居i和j，他们三者可以构成一个至少有三条边的环（其中实际不存在的边边权为无穷大）。事实上查看算法可以发现计算最小环的操作位于Floyd算法k循环松弛操作的上方，也就是在用k松弛i和j前先计算经过k的最小环，这么做是为了防止重复计算经过同一点的最小环。 注意点 一开始定义const int inf的时候不能设太大，不然容易wrap掉 遍历k要放在最外层]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HUSTOJ使用]]></title>
    <url>%2F2016%2F11%2F16%2FHUSTOJ%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[最近给 http://acm.hhu.edu.cn/JudgeOnline/ 出了一点题，总结一下这个OJ使用的一些注意点 添加题目之后题目显示的是reserved状态，这时候普通用户并不能看到这道题目 在加题界面添加的sample input和sample output都会被添加到testdata里面，因此要注意准确性 testdata里面可以存放多个.in和.out文件 此外我写了一些辅助工具一个自动重复测试数据的工具一个自动根据标程生成.out文件并计算运算时间的工具注意使用VS的Debug模式编译可能时间相比实际运行时间长很多，这是因为Debug模式自带很多检查]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>OnlineJudge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[segmentfault 双11光棍节程序猿闯关秀]]></title>
    <url>%2F2016%2F11%2F14%2Fsegmentfault1111%2F</url>
    <content type="text"><![CDATA[双十一segmentfault推出一个双十一解密游戏，不过当时我在前往北京的火车上，于是今天从北京跪回来玩了一下，作为玩过arthurluk的人感觉还是没有压力的。 第一关https://1111.segmentfault.com/全选看到连接 第二关https://1111.segmentfault.com/?k=05f5a5b740dbba332ea21005b7214c44查看源代码发现密码 第三关https://1111.segmentfault.com/?k=c0781e0fb05d15fa6ecb71b324805f9f首先发现这个密钥都很有规律，应该是个md5，于是去www.cmd5.com这个坑比网站上试了，没用，又瞎搞了几个盐也没用，代码里面只有一个amazon的js，应该不是提示。于是猜测是不是在http响应头里面，一看果然是的，密码是The-Key-Is字段。 第四关https://1111.segmentfault.com/?k=a87ff679a2f3e71d9181a67b7542122c这一关就是md5了，响应头里面给了个X-Hit，以为是盐，用坑比网站解密发现是4。然后下一关网址就是5加密，但是怎么都不对，后来发现就是个裸的md5，没有盐，X-hit好像是用来看缓存是否命中的。 第五关https://1111.segmentfault.com/?k=e4da3b7fbbce2345d7772b0674a318d5给了个二维码，扫了之后发现是这东西。根据我玩arthurluk的经验，我把https://1111.segmentfault.com/5.png 和404的那个svg图改成了bmp、jpg、png、svg、php、txt等格式发现都没有用。于是这一关我投降了，查看题解发现要把这个图片下载下来，作为txt打开。可以看到下面的密码。 第六关https://1111.segmentfault.com/?k=bdbf46a337ac08e6b4677c2826519542题目是：f4de502e58723e6252e8856d4dc8fc3b，只能告诉你这么多。首先想到的是这可能是寻找一个二级页面，然后提示在二级页面里面。于是不管三七二十一先去坑比网站上查一下，结果查到了，要付费购买。那去不坑比的网站查一下，http://www.dmd5.com/ 查到了，是2323k14jm，显然这不对。后来发现数字可能是多个char拼起来的，但是考虑下并不是ascii或者unicode。不会了，google下，发现twitter直接给答案，这不怪我咯。 第七关https://1111.segmentfault.com/?k=1573402aa6086d9ce42cfd5991027022好吧，原来是测翻墙技术的。搞了半天，直接把这串填进去就行了 第八关https://1111.segmentfault.com/?k=110a21f15af64b25163fe67799abecda给你一个表单，input填好密码，但是没有submit按钮。查看源码发现123&lt;form method="GET"&gt;&lt;input type="text" name="k" value="cda7ea6afa6ba887e7b8695b9ebac61d"&gt;&lt;/form&gt; 卧槽这method=&quot;GET&quot;欲盖弥彰啊，改成post，过了 第九关https://1111.segmentfault.com/?k=110a21f15af64b25163fe67799abecda （注意带上post的数据）貌似是ascii构成的base64，用python硬搞一波，转成一堆乱码，但是问题是下划线不知道转成什么。仔细看一下觉得也不像π、e之类的常数，于是决定假设_始终代表0和1中得到某一个值。用0试，出现奇妙字符，用1试，是合法的base64。用工具转成文本，得到一堆乱码，于是可能是图片。试了一试也不行。那直接MD5也不行。不会，后来发现原来是保存成文件。我写了个代码在这里，特别注意的是windows有个神坑，当按照文件读写的时候\n(0x10)是默认变成\r\n(0x1310)的，因此压缩包会无法解压，如下图所示（使用Hex Compare比较）：因此应当使用wb而不是w来写文件。 第十关（通关）从解压得到的图片上可以看到通关页面：https://1111.segmentfault.com/?k=e4a4a96a69a1b2b530b3bec6734cdf52]]></content>
      <tags>
        <tag>游戏</tag>
        <tag>双11</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC 2016 北京站小记]]></title>
    <url>%2F2016%2F11%2F14%2FICPC2016%E5%8C%97%E4%BA%AC%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这周六日在北京大学参加了2016年的最后一场ICPC区域赛。我们周五晚上乘坐T66列车从南京站出发，与此同时，平行世界里面同一时间参加ICPC青岛赛区的两队dalao们已经在青岛的海边玩了一个下午了。 赛题首先我先切了D题，看到一半清恒说F水题能做，于是我跳到F题开始敲，调试居然不过样例，原来是operator&lt;比较的时候用了两个this。过了之后清恒给我讲他们D题的思路，认为最大减最小就行了，我觉得他们题目理解错了，这时候我已经有了想法，然后赶快敲完过了。过了队友说K没搞懂什么意思，于是我去切K。接下来我们KE并行搞，E题通过的多，但是K题的通过率达到了惊人的100%。K题意思是问从1到N, N &le; 10100里面有多少个数等于从1到N所有数中数字”1”的个数之和。题目给了样例说明前100000000000个数里面有83个这样的数，其中最大的是11111111110。这道题我一开始觉得是dp，后来发现数字太大了，不太好做，便放弃了。队友们接过K，觉得先打表。过了一阵子他们觉得10100里面也只有83个数，交了一发发现翻了低级错误wa了，改了一阵子过了。这时候我在做E。E题是有个长度为5的由&#39;0&#39;-&#39;9&#39;组成的字符串，可以对这五个数字中任意一个进行乘2（总共3次）、加1（总共2次），和交换（不限次数），问组成”12345”需要的最少操作数，若不能就输出-1。我的想法是打表求出把&#39;0&#39;-&#39;9&#39;变成&#39;1&#39;-&#39;5&#39;需要的最少步数，然后再加上交换的次数。然后把五个数转成五个数的最小步数时候遇到了问题，这并不是一个贪心问题，我打算用bfs硬搞，算了算复杂度可能不行，于是尝试用图论算法（KM匹配）浪费了不少时间，最后时间不够了上bfs然后WA了，这时候比赛也结束了。封榜前我们是106名，想着今年据说Cu线改成605%了，应该能拿个Cu。不过后来发现还是45%的线，于是打铁滚粗。 感受 前面的队名叫latte，最后果然两题拿铁滚粗，这给我们启示比赛的时候不要喝拿铁（然而摩卡巧克力太腻，卡布奇诺有点苦）。 电子科技大学的一队拿到了AK两条的fb，于是怒拿冠军出线。这又一次给我们启示风水和气运很重要。 pku发了一人4张的20元卡（实际上除掉手续费只有16元了）。表示很奇怪为什么这卡要搞三张，难道是一张卡上只有4bit么？后来拿到发现卡上有若干洞，不禁想到多年前看到的matrix67的这篇博文，有空算一算 感觉北大好牛逼，报到的时候送了每人一个纪念U盘和水杯，开幕式和颁奖poucher和GB都出现了（GB口语好差啊），比赛午餐是开封菜，一对辣翅一个汉堡，每人一个大橘子。北大食堂只开放了艺园和农园，据说是比较差的食堂，但是依然是便宜可口。我们比赛的邱德拔体育馆整个还是北京奥运会的装扮，比赛过程和结束主办方一直强调千万不要放飞气球啦~我们很难搞啦。 北京用的hihocoder做的judge，参赛时果然没给我们CB，尿壶也不好用，但是给了个eclipse，我觉得还挺好用的。 晚上在中关村吃了东来顺火锅，因为之前吃过北京火锅的，并不喜欢那种芝麻酱，但是在北京吃到正宗的觉得还是挺好的，关键是不腻也不算太甜。本来准备去全聚德买个烤鸭寄给我姐的，但是实在没时间了 卧槽宾馆好远啊，住在人大那边的如家，而且居然是个家庭房，开暖气好热啊。早上要坐几站地铁才能到。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>现场赛</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5074 Hatsune Miku]]></title>
    <url>%2F2016%2F11%2F09%2FHDU5074%2F</url>
    <content type="text"><![CDATA[HDU 5074 Hatsune Miku 2014 ACM/ICPC AnShan 题意使用$m$种音符组成一个长为$n$的歌曲，定义两个相邻音符$(a, b)$的美丽度是$score[a][b]$，而一个长为$n$的歌曲$a[1..n]$的美丽度是其所有的相邻音符$ (a_i, a_{i+1}) $（共有$n - 1$个）美丽度的和。现在已知在歌曲的某些位置的音符已经被钦定了，问能够达到的最大的美丽度是多少？ 思路代码常规的暴力法就是对每一位枚举并计算美丽度，复杂度是\( m^n \)。但实际上可以dp来做。定义dp[i][j]是第i个音符选j时前i个序列的最大美丽度。然后在dp的时候考虑i - 1和i分别是-1和正数的四种情况： 当i - 1位置和i位置全部已知的时候，dp[i][j]是个定值。 当i - 1位置未知、i位置已知为j的时候，dp[i][j]就是在i - 1位置枚举所有的值取大的更新，继续维护dp数组的性质。 i位置未知时候，问题实际上分解为m个小问题，令j = [1..m]，然后按照2的方法计算。 有一个坑就是最后一个数可能不是-1，所以输出答案的时候先判断是-1了，再比较输出最大的dp[n][j]。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2016%2F11%2F07%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序（英语：Topological sorting）。 每个顶点出现且只出现一次； 若A在序列中排在B的前面，则在图中不存在从B到A的路径。也可以定义为：拓扑排序是对有向无环图的顶点的一种排序，其中如果图中从A到B有边（注意A到B有边那么B到A必然没有边），那么在排序中A出现在B的前面。注意拓扑排序并不一定存在，例如当图中存在环时。 拓扑排序的一种实现方式就是对每个点维护它的入度。我们假设图已经建好，如果从A到B有边，那么我们要把A放到B的前面，容易发现一个点的入度越高，那么它的前置条件也就越多。每次选取任意一个入度为0的点，然后删掉它的所有出边，更新入度。容易看拓扑排序的结果是不固定的，因为可能同时存在若干个点入度都为0，因此在拓扑排序的题型中一般还会有其他的限制条件。这样一般是从大到小或从小到大取，并且采用小顶堆或者大顶堆来形成最终的顺序。 经典题目HDU 5695 Gym Class题意思路代码同上面的，因为前面的要尽可能大，所以使用大顶堆。toposort里面遍历0入度的点应当从大到小。这条题目注意最后的方案要lld输出。 HDU 4857 逃生题意现在需要对[1..n]排序，要求编号小的一定在编号大的前面，但是此外还有若干形如(a, b)的约束条件，要求a必须在b前面。现在输出排序方案（保证一定有解）。 正确的思路代码需要反向拓扑（反向建边），维护一个大顶堆，然后反向输出 错误的思路代码读取(a, b)，对(a, b)建立有向边（正向拓扑），维护小顶堆，正序输出。 错误原因在阅读了这个帖子之后，明白了。考虑下面的例子： 1 3 1 3 1 正确的输出应当是 3 1 2 但是我的程序输出了 2 3 1 按照题意，3应该在1前面，1应该在2前面。但我的实现保证了按字典序排列，2的字典序较小，所以排在3前面，但是这就不满足编号小的在编号大的前面这个限制条件了。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[岩土工程实习]]></title>
    <url>%2F2016%2F11%2F07%2F%E5%B2%A9%E5%9C%9F%E5%B7%A5%E7%A8%8B%E5%AE%9E%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是去年岩土工程实习的实习报告。这是学习岩土工程这一个土木工程学科下面的细分方向之后的第一次实习，也是我们进入土木院后的第一次实习，不同于水工等学科实习得跑到浙江新安江的水坝那边去，南京本身就提供给我们土木工程很多实习的场所，例如最近一直在建的地铁，过江隧道，处处加盖的高楼，以及宁镇山脉的边坡治理等等。这样带来的好处是，有很多地方，我们在之前的例如工程地质实习中已经参观过了，因此有了一定的基础知识，再来理解这一部分就减少了很多难度。此外，对于作为在江苏成长，在南京生活了两年有余的我来说，也多了一次接触认识家乡的机会。从总体的实习安排中可以看出我们这次的实习主要分为三个方面，第一天我们主要感受了两个地基处理的样例，第二天我们参观了一个边坡治理的样例，第三天我们参观了隧道的施工。它们都分别代表着岩土工程的几个不同方面的应用。第一天我们参观了位于中山东路与龙蟠中路交界处东北角的中山东路301项目和位于卡子门大街与汇景北路交界处东北角的复地宴南都项目。这两个都是在做地基处理，两者都是深基础，其中中山东路的项目尚未完成底板，复地宴南都已经完成了。进入中山东路项目的工地，首先看到的便是两个巨大的基坑，这两个基坑分别由钻孔灌注桩拼成的桩墙（A）和地下连续墙（B）围住，起到了挡水挡土的作用。听老师的讲解，钻孔灌注桩和地下连续墙虽然都能够起到这个目的，但是它们的成本和效果差别很大。其中钻孔灌注桩成本小，但是由于施工的原因其表面会有坑坑洼洼的状况，而且钻孔灌注桩只有上部的2/3有钢筋，所以质量相对于地下连续墙差，而地下连续墙是先挖一道“沟”，再往沟里面布筋，灌浆处理而来，成本比较高，在中山东路的项目中，只有靠近地铁二号线的那一侧采用了地下连续墙进行挡土防倒灌处理。接下来在钻孔灌注桩和地下连续墙内部浇筑一些纵横梁起到加固作用，当然，等到底板做好之后，这些纵横梁就失去了作用，到时候可以选择作为地下停车场的顶板或者直接敲掉，这里的项目是选择直接敲掉。当然其实钻孔灌注桩在做好底板之后也可以敲掉，转而有建筑的外墙来承担挡土的功能。由于是一个深基础，地下有好几层，一般采用的是先打好桩，然后做好第一层的纵横梁，接着往下挖出第二层并造好第二层的纵横梁，敲掉露出来的桩，使用钢结构的柱子临时顶上（由于纵横梁最后都要拆掉的，所以没必要再造个柱子出来）。然后再往下面挖第三层。值得注意的是我们发现纵横梁的接近底部处按照一定间距均匀排布的很多细的塑料管，大家都不明白这些塑料管是干什么用的，后来咨询了工地方面才了解到，在浇筑混凝土的时候往往会发生涨模现象，这个时候就要用对螺栓将模板固定好，为了能够重复利用这些螺栓，就用塑料管将它们包起来，这样可以方便地取出，实际上这些小的实用技巧存在于工地的方方面面，往往是书本上面难以学习到的。我们接着有下到工地下面去观察了一下钻孔灌注桩，如同老师所讲的那样，这种桩质量确实不好，往往经常有缩颈（桩的一段的横截面积突然变小）等现象，而且有的装孔灌注桩内侧还有渗水的现象。此外我还发现为了防止外侧水位过高，在桩中间也留了一些水管，方便外部的地下水流出。图中的弯起钢筋的作用是辅助浇筑纵横梁。在工地上，这些“脚手架“一样的建筑往往占了很大的比重。，虽然它们最终都要拆掉，但是这看似浪费成本的办法实际上往往是最合理的。下午我们又参观了位于卡子门附近的复地宴南都项目，卡子门这边的地形浅一点，据说这边已经能够挖到基岩了，而上午的中山东路那边软土层比较厚，往往达几十米，打桩也只能打摩擦桩。这边已经做好了底板和承台（承台是桩与柱或墩联系部分。承台把几根，甚至十几根桩联系在一起形成桩基础），很多台挖掘机在不停的挖土方，监理们在走来走去指挥农民工做事。总体上讲，地基处理的成本往往占到了总成本的40-50%有了一个可靠的地基，才能保证建筑物的安全。这两个项目都是采用的箱形基础，箱型基础是由钢筋混凝土的底板、顶板、侧墙及一定数量的内隔墙构成封闭的箱体。这种基础整体性和刚度都好，适用于作软弱地基上的面积较小，平面形状简单，荷载较大或上部结构分布不均的高层重型建筑物的基础及对沉降有严格要求的设备基础或特殊构筑物，但混凝土及钢材用量较多，造价也较高。但在一定条件下采用，如能充分利用地下部分，那么在技术上、经济效益上也是较好的。对应的还有沉井，又名开口沉箱，对横断面为圆形、方形或矩形，顶底都敞开的井筒，在井筒内挖土，并靠井筒自重下沉后接长井筒，继续挖土和浇筑混凝土建成的基础工程。第二天我们跟车前往南京麒麟科创园青龙山沿线矿山地质环境治理示范工程—永平治理区工程。这边位于宁镇山脉处，我们上学期的工程地质实习就在这里附近的青龙山，阳山碑材附近实习过。在上学期的工程地质实习中我们了解到，青龙山属扬子地层区下扬子分区宁镇地层小区，地层发育齐全，有从最老的志留系至第四系连续完整的分布。构造上地处下扬子台褶带宁镇褶皱束的西南缘，西临南京坳陷，南接宁芜火山岩盆地，构造线总体呈北东向展布，断裂和褶皱均比较发育。区域上岩浆活动比较频繁，但以燕山期为主，具多旋回、多阶段、多形式的特点。我们今天去观摩的，是其中的永平治理区。根据区内地貌成因和形态类型划分，这里位于青龙山山系西南端，地处山体西坡。山体总体呈北东走向，地形纵向切割较深，山脊狭窄，两侧山体坡面较平直，自然坡度一般为20-25°；横向切割较小，冲沟多呈宽缓的“U字型”。周边山体林型为落叶阔叶林和常绿阔叶混交林，植被发育良好。麒麟科创园青龙山沿线矿山地质环境治理示范工程位于主城区东侧的麒麟科创园和东郊风景区范围内，北接仙林大学城、南临江宁大学城。该区域内，早年矿山开采形成的裸露边坡和矿山废弃地，不仅破坏了区域自然景观，与周边绿荫成群的青山绿水极不协调，而且成为京沪高铁、沪宁高速公路、绕城高速公路的视觉污染源，同时矿山存在多处地质灾害隐患。其中永平治理区，就有着江苏罕见的高度的坡体（据说是江苏省最大的单体）。顺着小路上山，我们首先看到的是一个楔形体，这个还没有治理，可以看到楔形体下部到该山体底部有两三道非常粗的黄色痕迹，据老师讲解，这就是因为这两天下雨，流下来的水。此外在山体的两侧，散布着很多碎石砂砾，似乎是从楔形体出崩塌下来的。据老师讲解此处楔形体还没有治理，将来是要被直接挖掉的。边坡加固一般有三种方法，一种是加固，比如说采用预应力锚索，采用锚杆，或者抗滑桩，对于小规模的边坡，可以直接采用格栅内种植植物生态护坡的办法，一般还会配合上剪刀梁，从而防止塌土的现象；还有一种就是直接削坡。永平治理区工程综合利用了这两种方法，而且在很多地方都创造了江苏之最，比如，他们采用竖直向下打方桩（作为抗滑桩），因为方桩的防滑能力好。2.8*1.8米尺寸的方桩，我们并没有见到，但是看到它的箍筋（附照片）的时候还是吓了一跳，这种尺寸，我们很难将它们和箍筋联想起来。显然的，这种桩是很难打进去的，这边采用了人工挖的方法。此外，还有一种方法就是做一个平台，打孔插钢筋，然后往里面灌混凝土，就和地下连续墙差不多的样子。抗滑桩的理想深度（打到最深）大概50-60米左右，这里的抗滑桩大概在50-30米分了六个等级。此外还使用了锚索，锚索的长度大概在50-100多米之间，一根价格往往上万。稍后在项目工地上，我们又阅读了整个项目的工程图纸，可以看出，这是一个很大的项目，目前治理的是其中的一小部分。第三天我们参观了南京地铁四号线草场门站现场和南京纬三路施工项目部，顺路路过了已经建成的纬七路过江隧道和南京长江大桥。这两个都是隧道，但是仔细研究起来还是有很大的不同之处的。首先是草场门地铁站，这个地铁站位于北京西路和虎踞路交界处，周围有比较多的古建筑和高层建筑，此外城西干道草场门隧道下穿北京西路，因此，我们看到这里面大都采用的是地下连续墙，而且是最厚的那种，厚度达到1.2m。中间有很多横梁用来防止两侧墙的位移变形。站在工地的旁边往下看，第一个感觉就是高、深。整个地铁站分为三层，其中第一层到地面之间的水泥层占了大概一个层高。由于南京的软土环境，因此随着盾构机的推进，去加固周围的土层是很重要的。以南京为例，北京东路今年的十月份至十一月份之间就连续发生了五次塌陷。据专家称，北京东路九华山这段路地下是古秦淮河道的流沙层。古秦淮河由南向北纵贯市区，由武定门经大行宫、玄武湖菱洲和樱洲，横穿中央路、福建路，到狮子山东注入长江。古秦淮河河道非常宽，最宽处达1000多米，简直就是浩浩荡荡注水入江。1万多年前的北京东路沿线，是宽敞的河流。当古秦淮河被埋藏时，形成了厚厚的流沙层，这些流沙层中还有一定的水分。地铁挖到七八米深的地下，就会遇到古河道，只要出现裂缝，流沙中的水分流出来，流沙就会跟着水走，造成塌陷。虽然施工方已经调整了施工方案，对没有施工的路段地层进行加固，然后再进行盾构施工。但是即使施工前先对地层进行加固，但也无法完全避免塌陷，毕竟地下的地质构造太复杂了，其中可见地下水对岩土工程的影响之巨大。据工地人员介绍，目前盾构机已经掘进离草场门站两公里处，所以我们是看不到盾构机的，但是随着我们走下工地，到达最深的一层，我们看到了岛式的月台，已经两个车道。其中南侧的部分已经铺上了铁轨，甚至已经有轨道车在上面跑动，在月台的尾端，就是两个巨大的圆形隧道。我们走下月台，走到隧道内，发现整个水泥管道是由很多片宽约半米的弧形的管片（也就是衬砌）围城的，其中中下部的管片靠自重维持原位置，但是上部和底部的管片表面就布满了很多螺丝，这些都是弯螺栓，通过它们将两片管片栓到一起，这样就防止管片的错位了。此外，在底部我们还发现了一些空洞，揭开盖子，我们可以从这里面往管片外部注浆进一步提高周围土的强度。下午我们主要前往纬三路隧道项目部进行参观，在去的途中，我们经过了已经建成的纬七路长江隧道。南京扬子江隧道（即纬三路过江隧道）是双管双层八车道X形隧道，分别经南北两条线路穿越长江，上层为江北至江南方向，下层为江南至江北方向。南线全长7363米；北线全长7014米。两条隧道均为上下两层，每层双向4车道，设计时速80公里，其中S线盾构段长达4.135km，N线隧道长4.936km。具有如下特点：盾构直径超大，开挖直径达到14.98米，隧道最深处到江面约74米（本来还会深五米，但是考虑到上土下岩的问题，因此高了五米）。设计最高静水压力达到7.4bar，盾构一次掘进距离长，S线4140米，N线3533米。江底盾构覆土深度前，N线隧道上方覆土厚度最前处不及1倍洞径。地质条件复杂，需穿过卵石层，泥岩层，砂岩层。纬七路越江隧道要穿过泥层和岩层。对于泥层，我们可以采用刮刀处理，对于岩层，我们可以将滚刀伸出，这样就可以用滚刀处理，减少刮刀的磨损。这些情况都是很好处理的，最难处理的是上土下岩这种情况。这种情况会带来局部磨损，因此必须要带压开仓，通过潜水员来更换刀片。然而这里位于长江江水下70多米深处，潜水员们必须能够承受70米水头带来的压强。一般的方法是往泥浆里面注射一些东西，使得周围泥浆的强度变高，形成泥膜，但是这时候周围的压强转而由空气产生，潜水员同样要承受70m水头的压力。为了能够抵挡这样的压力，就需要潜水员经过三级加压舱的逐级适应，一般要加压到1.6MPa左右，然后在进入这个环境作业。对于纬七路隧道施工是这样做的，但是纬三路隧道施工的过程中，发生了意外，中国方面的一些工人，在更换刀片后再也没有能够回来，因此，中交轨道局（负责到定淮门大街一线，中航负责到扬子江大道一线）请了德国北海公司专业的高压隧道作业人员进行处理，当然价格很高，一周每个人需要支付20万欧，作为比较，这个隧道施工的总经费在204096万。为了配合，我们设计出了一个高压生活舱，平常高压作业的潜水员就直接生活在这个舱内，等到需要作业的时候，就将这个舱运到工作地点。回来的路上我们计算了一下成本，我们发现建隧道的成本其实很大，以盾构机来说吧，首先盾构机本身就分为了前面的刀片部分，后面用来铺设管片的部分，还有三道运输吊车。总长达到了133米，而且刀片一般都是采用的碳化钨制造，一般一片刀片价格就达到五位数甚至六位数，而这样的盾构机往往是不能重复利用的，即使遇到设计尺寸基本相符的工程，也需要花费额外的金钱和人力去更换适合的刀片，以及进行评估。相比之下桥梁的成本就低了很多了。而且一条隧道存在的安全隐患代价都应该远远高于一座过江大桥，所以为什么为什么我们还是要挖隧道而不是建桥呢，城市快速路使用隧道避了扰民，优化了城市的景观，可以理解，但是过江通道为什么不能考虑造桥呢？总结这次的实习，我们将书本上面的知识，在实际中得到了验证，同时，我们也感受到了岩土工程施工一线的环境和气氛，对我们的职业道路的规划起到了重要的指导与启迪作用。]]></content>
      <tags>
        <tag>实习</tag>
        <tag>土木工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ 1037 A Decorative Fence 动态规划解排序计数]]></title>
    <url>%2F2016%2F11%2F07%2FPOJ1037%2F</url>
    <content type="text"><![CDATA[这是在北京大学暑期课《ACM/ICPC竞赛训练》的一道DP的题目。 题意现在要排列长度为[1..N]的N个木棒，要求除了两端的木棒外，每一根木棒要不比左右的都长，要不比左右的都短。现在给定C，要求输出在所有符合上述条件的建法中按照字典序第C种排布方式。 思路这是课程pdf提供的源码（修改后）这是我的代码这道题分成两步，第一步是计算合法排列数量N，第二步是通过N来计算第C个合法排列。第一步，其实可以先写一个递归的方案，然后再改成dp就行了，我觉得比较巧妙的地方是把up方案和down方案区分开来了。第二步，依次对第[1..i]位枚举剩下来的第[1..k]长的木棒，因为已经求得up[i][k]和down[i][k]。这种思想可以用来实现C++里面的next_permutation函数，这里给出了一个实现。 需要注意 c需要用long long去读 在计算up[i][k]的时候，我原先是从k + 1开始算的，但是实际上应当从k开始算。因为up[i][k]指的是所有由i个木棒组成的方案中以这些木棒中第k短的木棒开头的up方案的个数。也就是需要取走第k短木棒kk后的i - 1木棒组成的是一个down方案。注意到取走kk后，应当从比kk长的第一个木棒开始计算，也就是从i根木棒的第k + 1短开始。但是原来i根木棒的第k + 1短变成了现在i - 1根木棒的第k短，因此还是要从k开始搜索。 在排序计数时退出条件应当是c == 1而不是c == 0。 然后注意是n - i + 1或者n - i（看下标上界是0还是1），不是i。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础工程复习]]></title>
    <url>%2F2016%2F11%2F06%2F%E5%9F%BA%E7%A1%80%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这是根据同济大学版的《基础工程设计原理》整理的复习提纲。 绪论 建筑物三要素：上部结构、基础、地基 地基 地基是承受建筑物荷载的地层 所以增加基础材料的强度并不能提高地基的极限承载力 地基可分为持力层和下卧层 第一章 地基模型 地基模型：描述地基土应力和应变关系的数学表达式 最常用的线性弹性地基模型：文克勒地基模型、弹性半空间地基模型、分层地基模型 文克勒地基模型： 假定地基有许多独立且互不影响的弹簧组成，因此地基任一点的压强p之和该点地基变形s成正比，即$ p = ks $，其中k是地基基床系数，表示产生单位变形所需要的压力强度（$ kN/m^3 $）。 这忽略了地基中的剪应力，是一个近似模型，地基越软，土的抗剪强度越低，越接近实际。 地基基床系数可由载荷板实验、室内三轴试验、固结试验获得。 弹性半空间模型： 将地基视作均匀的、各项同性的弹性半空间体。 由此可以使用Boussinesq解：$ s = \frac{Q(1 - v^2)}{\pi E r} $ 实际计算沉降偏大，一般认为是地基压缩层厚度是有限的且地基是分层的，即使同一种土，变形模量随深度增加。 分层地基模型： 我国地基基础规范。地基最终沉降等于压缩层范围内各计算分层在完全侧限条件下的压缩量之和。 地基模型的选择： 主要原则： 土的变形特征，外荷载在地基中引起的应力水平 荷载的种类和施加方式 土层的分布 基础和上部结构的刚度和形成过程 基础的埋置深度 施工过程 时效（考虑到土的固结） 常见形式 沙土、无粘性土、基础柔软、局部集中荷载：文克勒 基础埋深大、土质紧密：分层 粘性土：弹性空间地基模型、分层地基模型 文克勒模型的柔度矩阵： 将地基的面积分成m个$ a \times b $大小的矩形。，假设在j网格中点作用集中力Rj，那么当且仅当$ i = j $时，$ s_{ij} = \frac{R_i}{k_i \times a \times b} $。因而文克勒地基模型的柔度矩阵是个对角矩阵。 第二章 浅基础设计原理 地基基础设计需要考虑的因素： 基础所用材料和结构形式 基础埋深 地基土的承载力 基础的形状和布置，与相邻地下（基础、构筑物、管道）的关系 上部结构的类型、使用要求、对不均匀沉降的敏感性 施工期限、方法、设备 抗震要求 浅基础的类型： 按照所用基础材料的性能：无筋扩展基础、扩展基础、柱下钢筋混凝土条形基础 按照形状和大小：独立基础、条形/十字交叉条形基础、筏板基础、箱形基础、壳体基础 按照刚度：刚性基础（无筋扩展基础）、柔性（扩展基础） 无筋扩展基础 自重大、抗拉抗剪强度不高，一般相对高度较大，不会发生弯曲变形，因此被称为刚性基础 对于荷载大、沉降敏感建筑物，持力层土质差不适宜 钢筋混凝土扩展基础抗拉抗剪强度较高，因此在扩大基础底面积（为了满足地基承载力要求）不需要增加埋深；又称为柔性基础或有限刚度基础。可分为柱下钢筋混凝土独立基础和柱下钢筋混凝土条形基础和十字交叉条形基础。 筏板基础比十字交叉条形基础具有更大的整体刚度，有利于调整不均匀沉降。分为平板式和梁板式。 箱形基础在使用十字交叉基础不能满足承载力要求又不能采用桩基时。比筏板基础有更大的抗弯刚度，可视作绝对刚性基础。箱形基础是补偿基础。箱型基础材料消耗大，还会遇到深基坑开挖带来的困难。 基础埋深： 基础地面到天然地面的垂直距离 影响因素： 建筑物用途和荷载大小性质 对于地下室：承载力、变形、补偿基础的要求 对于高层：稳定性 对于承受水平荷载：满足抗滑要求 工程地质和水位地质 直接支撑基础的土层成为持力层，以下各土层成为下卧层。持力层必须强度足够稳定可靠。 当上层土承载力较低，应将基础埋置在下层较好的土层之中。如果需要深埋，需要和加固上层土或者短桩基础进行比较决定 例如上海某些地方，软土为不良持力层，但表面有2-3m硬壳层，六层以下民居可以利用 易于风化软岩，开挖后立即铺设垫层防止风化 地下水存在时，尽量在地下水位以上；否则要考虑基坑排水，坑壁支护等措施 若持力层下存在承压水，要控制基坑开挖深度，避免引起突涌或者流砂现象 相邻地下（基础、构筑物、管道）的关系 新建筑物埋深不宜深于旧的。否则要保证间距或者采用地连墙、分段施工、加固原有地基等措施。 地基土冻胀和融陷的影响冻结危害：地面不均匀隆起，土体膨胀，使墙体开裂，门窗不能开启化冻危害：土体松软，融陷，强度降低，沉降 补偿基础： 为了减小拟建建筑物的沉降量，除去地基处理或桩基础，还可以选用补偿基础。 箱形基础和筏板基础是补偿基础。由于地下室的存在基础具有大量空间，免去大量的回填土，可以用来补偿上部结构的全部或部分压力。基底附加应力p0公式为：$ p_0 = p - σ_c = \frac{N}{A} - γ_0 \times d $。其中N为作用在基地的荷载（$ kN $），A为基础底面积，d为基础埋深，$ γ_0 $为埋置深度内土重度的加权平均值。 定义当$ p_0 $时候的基础为全补偿基础，也就是建筑物的重力等于基坑挖去的总土量；否则是部分补偿基础。 无筋扩展基础和钢筋混凝土扩展地基的区别 无筋扩展基础是刚性基础，抗压高，拉剪弱 钢筋混凝土基础是柔性基础，抗拉、抗剪强度较高 减小不均匀沉降的措施 建筑措施 建筑物的体型力求简单 增强结构的整体刚度 设置沉降缝 相邻建筑物基础间要有合适净距 调整某些设计标高 结构措施 设计圈梁增强刚度 使用合适的结构形式 减轻建筑物和基础自重 减小调正基地附加压力 增强基础刚度 施工措施 先高后低 施工前使地基预先沉降 注意沉桩、降水对邻近建筑物的影响 基坑开挖保护坑底土 尽可能不扰动土的原状结构 确定地基承载力方法 地基承载力：地基土在同时满足强度和变形两个条件时，单位面积上所能承受的最大荷载的能力 承载力理论公式 现场载荷试验 浅层平板载荷和深层平板载荷实验。 经验方法 计算地基承载力 包含地基持力层承载力验算和软弱下卧层承载力验算。 天然地基上浅基础设计的内容 选择基础的材料、类型，进行基础平面布置 选择基础的埋置深度 确定地基承载力设计值 确定基础的底面尺寸 必要时进行地基变形与稳定性验算 进行基础结构设计（按基础布置进行内力分析、截面计算和满足构造要求） 绘制基础施工图，提出施工说明 第三章 浅基础结构设计 地基反力分布假设 墙下条形基础、柱下独立基础、筏板基础等（持力层土质均匀、上部结构刚度较好、各柱距相差不大、柱荷载分布均匀）：直线分布 弹性地基梁 基础结构设计主要内容 无限长和有限长梁的区分 文克勒模型上有限长和无限长梁内力求解 偏向受压独立基础、条形基础设计 第四章 桩基础桩基础由基桩和连接于桩顶的承台共同组成 桩的种类和优缺点 预制桩（挤土桩） 包含预制钢筋混凝土桩、预应力钢筋混凝土桩、钢桩 噪音大 灌注桩 钻孔灌注桩（非挤土桩） 人工挖孔灌注桩（非挤土桩） 沉管灌注桩（挤土桩） 噪音大 跳打：待混凝土强度足够时再在新桩的近旁施打相邻桩 轴向荷载沿桩身传递方式 开始加荷于桩顶，桩身压缩，桩侧受土的向上摩阻力 桩身荷载和压缩变形随深度递减 荷载增加，桩身压缩量增大，桩下部的摩阻力随之增加，产生桩端阻力 桩端土层压缩加大桩土相对位移，使桩身摩阻力进一步增大 桩身摩阻力达极限，继续加荷，荷载增量将全部由桩端阻力承担。桩端持力层大量压缩并塑性变形，直至桩端阻力达到极限，位移迅速增大至破坏。此时，桩达到其极限承载力。 影响桩侧桩端阻力的因素（荷载传递函数） 与土层性质、埋深、桩径等有关 桩侧桩端分担比还与桩土相对刚度、长径比l/d有关。桩土相对刚度越大，长径比l/d越小，桩端传递的荷载就越大 主特征参数：极限摩阻力$ q_su $ 和极限位移 $ s_u $ 单桩破坏形式 Q-s曲线（桩顶荷载/沉降曲线） 0-1阶段， 1-2阶段，桩侧土弹塑性阶段 当桩顶侧摩阻力达极限时（1点），桩侧进入塑性状态，随荷载增大，桩侧土塑性范围由浅到深发展，直至均达到塑性状态（2点） 2-3阶段，桩侧土完全塑性阶段 新增荷载全部由桩端承担，直至持力层破坏（$ k_s s_l \geq q_bu $），其中$ k_s, s_l, q_bu $ 分别是垂直方向地基反力系数、桩的沉降量和桩端承载力 摩擦型桩 2-3段近似直线，陡降，2点现明显拐点 端承型桩 端阻占比大，2点不现明显拐点，破坏需较大位移，曲线呈缓变型 深度效应 沉桩效应 单桩承载力确定方法 经验参数法 静载荷试验法 静力计算法 静力触探法 高应变动测法 负摩阻力及产生原因 当桩周土体发生下沉切沉降速率大于桩的下沉时，土对桩产生向下的摩阻力，称为负摩阻力。 负摩阻力产生原因有： 桩基附近地面大面堆载，引起地面沉降，产生负摩阻力。如大面积堆放重物的车间、仓库建筑桩基础。 因黄土湿陷、冻土融化产生地面下沉。 打桩，桩周土产生超空隙水压力，停止后桩周土的再固结作用引起下沉； 桩穿过欠固结土层（如填土）进入硬持力层，自重固结下沉； 土层中抽取地下水或其他原因，因自重固结下沉 群桩效应 群桩中任意一根基桩的工作性状都不同于孤立的单桩，群桩承载力不等于各单桩承载力之和，群桩沉降明显大于单桩。 定义群桩效率系数 $ \eta = \frac{P_u}{n Q_u} $。其中$ P_u, Q_u, n $ 分别为群桩竖向极限承载力、单桩竖向极限承载力和桩数。定义沉降比 $ \zeta = \frac{s_n}{s} $。$ n $和$ \zeta $主要取决于桩距和桩数，其次与土质和土层构造、桩径、桩的类型及排列方式等因素有关。 由端承桩组成的群桩，工作性状于独立单桩相近 由摩擦桩组成的群桩，桩顶荷载主要有桩侧摩阻力传到土层中，在桩端平面产生应力重叠。因此在粘性土中的群桩随着桩数增多，群桩效率系数η明显下降。 控制沉桩挤土效应方法：设置防振沟、挤土井、预钻孔、排水砂井、控制沉桩速度以及调整打桩流水 计算题：桩顶荷载和桩身最大弯矩计算 第五章 沉井基础 定义及特点 沉井是井筒状的结构物。它是以井内挖土，依靠自身重力克服井壁摩阻力后下沉到设计标高，然后经过混凝土封底并填塞井孔，使其成为结构物的基础。 沉井优点： 埋置深度大，整体性强、稳定性好 可作为挡土和挡土围堰结构物 施工工艺不复杂 施工时对邻近建筑物影响小 沉井的缺点： 施工周期长 易发生流砂现象，造成沉井倾斜（粉细砂） 大孤石、树干或井底岩层表面倾斜过大，给施工造成困难 沉井基础下沉困难的原因和解决措施 原因： 开挖面深度不够，正面阻力大 偏斜或刃脚下遇到障碍物、坚硬岩层和土层 井壁摩阻力大于沉井自重 井壁无减阻措施或泥浆套、空气幕等减阻构件遭到破坏 解决方案： 增加压重 提前接筑下节沉井 在井顶加压砂袋、钢轨等重物 不排水下沉时，可井内抽水 减小井壁摩阻力 井壁内埋设高压射水管组，射水辅助下沉 利用泥浆套或空气幕辅助下沉 增大开挖范围和深度 必要时还可采用0.1∼0.2kg炸药起爆助沉 沉井下沉突沉的原因和解决方案 原因： 井壁摩阻力较小，当刃脚下土被挖除时，沉井支承削弱 排水过多 挖土太深 出现塑流 解决方案： 控制均匀挖土，减小刃脚处挖土深度 在设计时可采用增大刃脚踏面宽度或增设底梁的措施提高刃脚阻力 流砂出现原因和解决方案 原因：土中动水压力的水头梯度大于临界值 解决方案： 排水下沉时发生流砂，可采取向井内灌水 不排水除土下沉时，减小水头梯度 采用井点，或深井和深井泵降水 沉井基础的施工工序（旱地） 整平场地 制造第一节沉井 制造沉井前，应先在刃脚处对称铺满垫木，以支承第一节沉井的重量 拆模及抽垫 挖土下沉 接高沉井 筑井顶围墙 地基检验和处理 封底、充填井孔及浇筑顶盖 水中沉井基础施工方法 筑岛法 浮运沉井施工 沉井下沉倾斜的原因和解决措施 原因： 土岛表面松软，河底土质软硬不匀 井壁与刃脚中线不重合 抽垫方法欠妥，回填不及时 除土不均匀对称 刃脚遇障碍物顶住而未及时发现 排土堆放不合理，或单侧受水流冲击淘空等导致沉井承受不对称外力作用 解决方案： 在沉井高的一侧集中挖土，在低的一侧回填砂石 在沉井高的一侧加重物或用高压射水冲松土层 在沉井顶面施加水平力扶正 沉井设计基本内容]]></content>
      <tags>
        <tag>土木工程</tag>
        <tag>基础工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC 2015 沈阳网络赛]]></title>
    <url>%2F2016%2F11%2F03%2FICPC2015%E6%B2%88%E9%98%B3%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2015 沈阳网络赛 1006 Fang Fang题意给你一个由小写字母组成的循环字符串S（循环字符串的意思是你可以从任意位置i开始，顺时针经过n回到i-1的位置），问至少需要序列F中的多少项才能组成字符串S。 思路水题，代码 1010 Jesus Is Here1012 Largest Point]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5952 Counting Cliques]]></title>
    <url>%2F2016%2F11%2F02%2FHDU5952Counting-Cliques%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2016 沈阳站 Counting Cliques这道题蛮可惜的，其实就是暴力，不过在现场zyyyyy使用了set实现，实际上用vector就过了。 题意求一个N(N &le; 100)点M(N &le; 1000)边的无向图容量为S的团的个数。已知每个点的度不大于20。 思路如代码所示，进行dfs，dfs维护一个conn数组用来表示一个大小为sz的完全图的所有点。在每层的dfs中每次寻找并添加一个可能的点，这个点必须要满足和已有的完全图能够成一个新的大小为sz+1的完全图（也就是和完全图中的所有其他点的都要有边）。在实现过程中有以下优化： 为了避免重复，只从边号小到边号大建边 为了节约时间，筛掉度小于S-1的边 为了节约时间，第一层dfs完毕后将该点的从图中去掉。 去掉以上两个优化在hdu上还是能过。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visual Studio使用技巧]]></title>
    <url>%2F2016%2F11%2F01%2FVS%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[记录Visual Studio的一些使用技巧，包括创建Snipplet、一些常见错误的解决方案和使用命令行编译的相关方法。 重定向源码路径 调试为了能够顺利进行调试，将 工程属性-调试-工作目录 设为新的目录 添加文件默认的右键工程目录添加文件并不好用，因为每次总是给定$(SolutionDir)$(ProjectName)下的一个地址，因此可以使用插件Add New File，只需要Shift+F2即可 出现符号未定义或者符号重定义的情况这是正常现象，重生成清理都没有用，正确方法是讲涉及的文件移出工程再重新添加即可，一般这种原因是某个函数所声明的h文件曾经被rename过。 使用MSBuild编译C++代码使用命令行编译可以使用MSBuild直接构建vcxproj文件，也可以使用VCVARS32.bat来运行传统的Makefile文件 命令行常见选项及意义目录OutDir这是输出目录，包含ilk、pdb文件的所在地。对应于VS中的常规-输出目录。建议和OutputFile的目录相同，否则会出一个warning。这应当在PropertyGroup选项中配置。默认值为$(SolutionDir)$(Platform)\$(Configuration)\，例12345&lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'"&gt; &lt;LinkIncremental&gt;true&lt;/LinkIncremental&gt; &lt;OutDir&gt;../bin/&lt;/OutDir&gt; &lt;IntDir&gt;../bin/obj/&lt;/IntDir&gt;&lt;/PropertyGroup&gt; IntDir这是编译器生成的obj以及log文件的所在地。对应于VS中的常规-中间目录。这应当在和OutDir相同的地方配置。默认值为$(Platform)\$(Configuration)\，例同上 OutputFile这就是最终生成的exe文件名字。对应于VS中的链接器-常规-输出文件选项。这应当在ItemDefinitionGroup-Link选项中配置。默认值为$(OutDir)$(TargetName)$(TargetExt)，例12345678910111213141516&lt;ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'"&gt; &lt;ClCompile&gt; &lt;PrecompiledHeader&gt; &lt;/PrecompiledHeader&gt; &lt;WarningLevel&gt;Level3&lt;/WarningLevel&gt; &lt;Optimization&gt;Disabled&lt;/Optimization&gt; &lt;PreprocessorDefinitions&gt;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;_SCL_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)&lt;/PreprocessorDefinitions&gt; &lt;AdditionalIncludeDirectories&gt;%boost_dir%;%(AdditionalIncludeDirectories)&lt;/AdditionalIncludeDirectories&gt; &lt;/ClCompile&gt; &lt;Link&gt; &lt;SubSystem&gt;Console&lt;/SubSystem&gt; &lt;GenerateDebugInformation&gt;true&lt;/GenerateDebugInformation&gt; &lt;AdditionalLibraryDirectories&gt;%boost_dir%\stage\lib;%boost_dir%\libs;%(AdditionalLibraryDirectories)&lt;/AdditionalLibraryDirectories&gt; &lt;OutputFile&gt;../bin/$(TargetName)$(TargetExt)&lt;/OutputFile&gt; &lt;/Link&gt;&lt;/ItemDefinitionGroup&gt; LocalDebuggerCommandArguments为了能够让IDE兼容我们的编译结果，我们需要同时修改IDE的配置选项。这个是在IDE中用来调试的命令行，其默认值为$(TargetPath)，也就等于生成的exe的位置 LocalDebuggerWorkingDirectory]]></content>
      <tags>
        <tag>Visual Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC 2016 杭州站]]></title>
    <url>%2F2016%2F10%2F30%2FCCPC2016%E6%9D%AD%E5%B7%9E%2F</url>
    <content type="text"><![CDATA[CCPC2016杭州赛区推出了大中学生对抗赛，于是全场比赛主要看点一是clj封榜前能不能AK，另一个就是看清华学长PK清华学弟。 1001 ArcSoft’s Office Rearrangement题意给定a[1..N]，可以合并相邻两项或者将一项拆开成两项，问是否能够得到b[1..K]且b中每项都相等。 思路我的错误代码代码 1002 Bomb题意平面上给了n个炸弹，引爆其中的炸弹i需要代价ci，一个炸弹爆炸会使得它半径ri内的炸弹爆炸，以此类推。求使得所有炸弹爆炸需要的最小代价。 思路强连通缩点，然后找入度为0的所有的联通块，然后在联通块内找一个花费最小的即可。找联通快和寻找花费最小代价的点可以在tarjan的弹栈操作完成。特别地，寻找入度为0的所有连通块是通过遍历所有的边然后比较(u,v)是否属于同一联通块实现的实现的。此外注意引爆具有有向性。代码 1003 Car题意一辆车保持不减速运动（速度为实数），时间从0开始，在某些整数时刻记录下车的位置（整数递增），求最少需要多长时间达到最后一个记录点 思路这道题目的坑主要是卡精度，求ceil得时候要减去eps=1e-7。或者直接用分数类也能过。代码 1006 Four Operations题意在一个最多20位的整数里面按顺序插入+、-、*、/（整除）四个运算符，要求结果最大。 思路要注意整数有20位，使用long long。代码]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hihoCoder 1392 War Chess 大模拟]]></title>
    <url>%2F2016%2F10%2F25%2Fhiho1392War-Chess%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2016 北京网络赛赛题 War Chess 题意HDU上有一道类似题目链接HDU以游戏曹操传为背景，给定地图N &times; M的矩阵。Gi j表示任人物穿过这个方格的行动值减小量。每个人物有以下属性： 生命值 HP 攻击力 AT 行动力 MV 攻击范围 [AD1, AD2] 起始坐标 (STx, STy) 所在阵营 GR 每个人物可以攻击攻击范围内的敌对玩家，一旦人物的HP小于等于0，将它的移出棋盘。人物可以从当前格子开始向四周移动，在人物移动过程中，当人物从格子(i,j)移到格子(x,y)时，他的行动力减少Gx y。当移动力小于0时移动是非法的。同时，当该人物四周有敌对人物时，该人物移动力变为0。现在给定游戏记录，要求模拟游戏，并判断合法性。 思路需要注意自己局中不能移动他人的棋子，死亡人物不能进行操作。我的不能使用的代码修改后的代码有几点做的不好： 可以开一个数组记录每个格子被谁占领，注意走和被Drive out后要及时更新 Attack前先要检测Attack之后HP是不是会小于等于0，如果是的就不能Attack 其实选择人物的时候并不需要检查Round 中间我还犯了一些错误，比如OC[dx][dy]写成了OC[x][y]，没有设vis[STx][STy]。此外的move时的bfs里面，不能更新Cha[cha].MV，这是一个固有的值，每次走完MV是不变的，所以应当记录走完之后MV用了多少。 比赛的时候用的dfs，这样太慢了，实际上是bfs，用一个优先队列维护mv最大的状态，每次都是贪心从mv最大的状态走。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[emacs学习笔记]]></title>
    <url>%2F2016%2F10%2F24%2Femacs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[鉴于2015年icpc北京站没有cb等ide，来学习emacs。由于本人之前比较习惯使用vim，因此这里将部分地和vim进行对比。不过后来发现有尿壶geany（虽然我觉得很难用，关键是RE直接退出），和eclipse cdt（虽然eclipse我很讨厌但总比没有强吧），所以我决定不学了（VS大法好）。 基本操作在bash on windows下运行sudo apt-get emacs。安装完毕后运行emacs filename可以打开/创建一个新文件。使用Ctrl+X Ctrl+C可以退出emacs，类似vim的:q。 命令说明和vim不同，emacs比较依赖Ctrl，Meta键。Ctrl键是比较寻常的，Meta键有三种作用方式： Alt + X Esc X (先按Esc松开后按X) Ctrl+[ X 注意vim命令常可带数字前缀，例如3fa可以表示当前行第三个a，4yy表示复制四行。 光标跳转 操作 emacs(不使用光标控制键) vim(默认Normal模式) 光标控制键 备注 光标左移 Ctrl+B H ← 光标右移 Ctrl+F L → 光标上移 Ctrl+P K ↑ 光标下移 Ctrl+N J ↓ 上一词首 Alt+B b / vim不会忽略标点符号 上一词尾 ge / 下一词首 w / 下一词尾 Alt+F e / emacs实际移到插入位置，类似vim按a进入插入模式 上一页 Alt+V Ctrl+B Page Up 下一页 Ctrl+V Ctrl+F Page Down 逐行下滚 Ctrl+E 逐行上滚 Ctrl+Y 行首 Ctrl+A 0 Home 行首(忽略前导空白) ^ 行末 Ctrl+E $ End 行末(忽略尾部空白) g_ 句首 Alt+A ( 句子以空行和句号分隔 句末 Alt+E ) 段首 Ctrl+{ { 段以空行分隔 段末 Ctrl+} } 首行 1G, gg 末行 G 置顶当前行 zt 置底当前行 zb 到本行下一个char字符处 f+char 到本行下一个char字符前 t+char 到本行前一个char字符处 F+char 到本行前一个char字符前 T+char 括号匹配 % 插改增删复制黏贴删除删除指令可以主要以d开头，可以在d后面指定重复次数，也可以在d前面指定重复次数。 操作 emacs vim vim(插入模式)或gedit 备注 删除当前字符 x, d+→ del 删除前一个字符 d+← del 删除当前单词 dw 删到行首 do 删到行尾 d$ 删到一行 dd 查找emacs概念]]></content>
      <tags>
        <tag>ICPC</tag>
        <tag>emacs</tag>
        <tag>vim</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC 2016 沈阳站小记]]></title>
    <url>%2F2016%2F10%2F24%2FICPC2016%E6%B2%88%E9%98%B3%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[周六周日参加了icpc沈阳站的比赛。这次出题是doc老师，和去年的合肥一样，沈阳站撇去两条水题是1题铜两题银，我们过了C卡了E，最后以罚时打了铁。 正式赛赛题AB比较水，第一题选两个最大的数相加，第二题求分子质量。C是给出函数$ f(x) = 2 * f(x - 2) + f(x - 1) + x ^ 4 $给定$ f(1) $，$ f(2) $，求$ f(n) $。E是求含有S个点的完全图的数量。一开始我们分配是推C的公式（觉得不像是快速幂），我想的是dfs解决E，用在合肥的方法，但是不太好去重，后来zyyyyy试了一会儿C放弃了，写了另一个dfs试图过E，结果T了。后来我和Song打算搞C的快速矩阵幂，我快速幂记不得了，后来Song给我讲我也没听懂，因为她把矩阵右乘左乘搞反了，不过后来我想到了杨辉三角，构造了一个7阶矩阵：$$M\times\begin{bmatrix}f(n - 2) \\f(n - 1) \\1 \\i \\i^2 \\i^3 \\i^4 \\\end{bmatrix}=\begin{bmatrix}f(n - 1) \\f(n) \\1 \\i + 1 \\(i + 1)^2 \\(i + 1)^3 \\(i + 1)^4 \\\end{bmatrix}\tag{1}$$ 然后就过了。E题一直没过，后来看到旁边南航4题铜牌队过了，一问他们也是搜索，不过他们用了vector来判重的，但是我们是set。这道题的题解专门列了个blog 感受 第一次坐飞机，第一次去东北，表示非常兴奋。东北没有想象中那么冷，但是沈阳风很大，而且喜怒无常，穿上棉毛裤也不感觉暖和一点，不穿也不感觉冷，但是裤子要sa起来，不然确实串风。我们早上比赛的时候要求穿发的比赛服（还要把那个acm的sticker贴在胸前），可是我们到了比赛场馆外面等了好久门都不开，搞的我又把黑棉袄给穿上了。东北菜我觉得不太好吃，但是锅包肉确实特别好吃，我们吃了两次，第二次在饭店里面的还加了柠檬，几乎被我们五个人秒了。此外杀猪菜也很好吃，就是量少，酸菜有点酸，我吃不惯。玉米面烙饼也很好吃。 在东北大学见到了老同学，老同学非常热情，晚上请我们吃了顿饭（PS东北菜不太吃得惯，但是锅包肉真心好吃），第二天还买了特产小梨子送给我们，那个梨子真的挺好吃的，浑身上下传来一股热带水果的味道。乍一看品相也忒差了点了，坑坑洼洼的，但是吃起来很香。 比赛完了我们和老师五人一起玩了南湖公园，南湖公园还挺好玩的，里面有几座桥挺漂亮。晚上我们在南湖公园溜冰，具体就不说了，大家都比较惨，还玩了那个两个脚独立的滑板。溜完冰回来，我和老同学和队友互相普及各地方言。 周日晚上我们开始八卦之夜。大家分享对对方的看法，各种互黑，我也树立了毕业之后去说相声的远大志向。 热身赛是去年的题目，第一题居然是No Input猜一个数字，结果是东北大学的建校的年份。然后有一道题应该用SAM做的，然后我提出就暴力一下，顺便测测T，结果交了一发居然A了。 被质疑的大连海事大学金牌队就在我们对面，而且他们没有来，被我们缴获了他们的密码。 刚下车从机场打车到东北大学，司机东北人非常爱说话，说小萌是歌星（她来的时候带了个帽子），我们是小萌的保镖，又调侃小萌太男孩子（鉴于她最近搞了一个超级丑的头还不承认），过收费站的时候和收费员一个劲的美女的称呼。 这次比赛暴露出了一些问题，因为ACM是一个1+1+1&gt;3的比赛，和OI是不同的。队员实力导致必然每个人有擅长的方面，也有每个人不擅长的方面，但否能够扬长避短考验每个团队的能力。无论是去在有异议时理解和信任别人的想法，还是在别人质疑时有自信坚持和完善自己的想法都是非常考验一个人的。这次比赛我觉得在这些点上，大家都做得不够好，但是相比合肥站，我觉得其实是没有遗憾的，每个人都非常努力地发挥了，并且在互相理解和信任上也进步了很多。因此在我们每一次1Y的时候，我是非常骄傲能在这么一个队里面。这次题目偏难一点，我们之前也没有训练过这种一题铜的比赛，有点猝不及防，最后也是输在了罚时，但是我相信大家将来会越做越好。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>现场赛</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2016合肥小记]]></title>
    <url>%2F2016%2F10%2F16%2FCCPC2016%E5%90%88%E8%82%A5%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天参加了CCPC2016合肥站的比赛。因为z+y的神脑洞，我们没有在规律题上怎么卡，而是死在了图论上，果然Cu到Ag还是算法不行。今天重现赛，我把我改掉那&amp;&amp;短路的代码交了一遍就1A了，考虑到我比赛最后30min一个人在队友怀疑中敲完了自己的思路，而且被短路虽然是低级失误，但我之前真的没遇到过（我平常if, for都是打大括号的，这次实在是赶时间）。我也问心无愧。我不遗憾，只是太可惜了。代码 正式赛赛题我们过了HIEC，卡了A（图论）。I题是位运算，对r先求补，mask掉highbit，然后不停lowbit修改l，比赛的时候zyyyyy写的，这是重现时我写的代码，在实际上写的时候将long long映射到int[64]会比直接的位操作要方便一点。H题要求给定序列a[i]，查询a[l..r]的xor的结果。一开始我样例搞错了，因为我把异或和非异或记反了。E题扫雷，要求是3行N列的矩阵的扫雷游戏，其中第二行的所有格子是已知的且都没有雷。求所有雷的安放的情况的总数。可以发现只要第一列确定了，后面每列的雷数（0, 1, 2）就确定了。这里贴一份网上扒的代码。C题是一道博弈的题目，给定一棵树，树的边权为0或1。对于每个查询，给定一个点作为树根，女生和男生交替选择一条权为1的边，并翻转从这条边到树根路径上的所有边。直到某一方不能找到权为1的边时，另一方就赢了。首先对于一条链来说如果根节点所在的边权为1，那么就可以翻转。一开始我没看懂，因为树的顶点是可以指定的，所以不一定就在最上面。A题，将一个竞赛图拆成两部分P和Q，判断P和Q是否同时都是传递的。当时我们的想法是首先不能有环，其次每条链上都必须是传递的，也就是每两点距离都是1。因此我当时敲的解法是dfs，使用to[u][v]表示能从u到v，假设现在对s进行dfs，首先对所有s连通的点i进行dfs，如果不满足性质则整个都不满足性质，然后检查i的所有能到达的点j，如果从s到j有直接边并且从j到s没有后向边，那么就是满足性质的。不过时间比较紧，我调试的时候遇到了sof（递归爆栈），当时比赛没发现是sof，因为控制台上没有出现任何错误提示，都以为时中途某个代码RE了。后来发现是有一句话把dfs短路掉了，导致最后一个单独的点无法被访问。对这条题目是比较遗憾的，因为当时队内一直希望找到更有效的解法，我自己也不自信，等到最后的半小时的时候我才开始敲我的思路，最后也非常紧张，没调试出来。我们对面的河南大学软件学院的同学是用了SPFA(O(kE), k&lt;=2)求了每两个点之间的最短路（dijkstra的O(V2)说会超时），然后检查是否存在有两点之间距离大于等于2。另有做法是分别添加Q的边和反向边插到P里面，然后拓扑排序判断是否有环。特别注意的是，我们使用PC^2评测的时候，PE是判成WA的，也就是没有PE，在做H还是I题的时候多输入了一个换行符，于是就WA了，浪费了一点罚时（不过也到不了银牌就是了）。PS补充一下CB有的时候是不能直接在Console黏贴的，这是正常的，可以将控制台换成gnome就好。 感受 合肥站的组织继承了ccpc组织优良的传统（虽然这才第二年）。热身赛的时候我们的键盘是大回车，导致backspace很容易按错，结果主办方第二天就换了键盘（虽然这次end键移到右上角，各种误触page up了）。 安徽大学好大啊，而且建筑特别漂亮，环境也好，第一天中午在操场上玩了半天器材，晚上走了半天才从最北边走到图书馆（中轴）。 第一次混进了教练餐（自助餐），感觉挺不错的，宾馆是安徽大学磬苑宾馆，感觉挺好的。安徽大学是发的自己学校的校园卡，80块钱，我们都买了一堆零食，SBzyyyyy给自己买个副耳机也是醉了。 正式赛早上恰逢合肥国际铁人三项，好多人堵在天宫酒店过不来，我们在坐在体育馆的看台上等了好长时间，中间还有志愿者给我们送来热水，期间我们看隔壁icpc大连场大佬们各种神过题（后来那一场4个AK，7题才铜）。最后十一点半比赛才开始，很多人最后都没赶上回去的车。 有幸遇到了初中同桌+6，本来晚上准备找她吃饭的，结果她晚上有个招聘，不过招聘完了晚上大家在宾馆玩杀人游戏，不过真是醉了，每次都是天亮了我死了，唯一一次我没死是因为我是杀手。 热身赛的时候没有比过石河子大学，正式赛报了“仇”。 学弟们都很强，希望他们能够再接再厉，为我校取得更好的成绩。 同沈阳最后一条感受。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串算法学习]]></title>
    <url>%2F2016%2F10%2F14%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[相对于序列，字符串一定是连续的，字符串匹配和查找算法，如KMP、Trie、AC自动机等是比较基础的串算法。并使用摊还分析等方法分析了部分算法的复杂度 KMPKMP算法是一种前缀搜索方法，也就是说在搜索窗口内从前向后逐个读入文本字符，搜索窗口中文本和模式串的最长公共前缀。相对于前缀搜索，还有后缀搜索（Boyer-Moore、Horspool、Sunday）、子串搜索等方法。为了方便阅读，未特别注明情况下统一模式串为P，长m，以j为下标；文本串为S，长n，以i为下标，i和j下标从0开始。(i,j)表示匹配S[i]和P[j]。 KMP对朴素算法的优化 朴素的字符串匹配算法复杂度为O(n*m)，对于长n的文本串S，从位置[0..(n-m)]开始搜索匹配长m的模式串，对于每个位置至多需要m次比较。假设在(i,j)位置发生失配，那么接下来应当从(i-j+1,0)位置开始重新匹配。 容易发现其中有一些比较和回退操作是多余的。例如，假定模式串为P为&#39;ABCDABD&#39;，文本串为S=&#39;ABC ABCDAB&#39;，假设从(0,0)位置开始匹配，在(3,3)位置发现&#39; &#39;和&#39;D&#39;不等。此时朴素算法直接在(1,0)位置重新开始匹配，但实际上在刚才比较过程中可以得到(0..3,0)位置都是不行的，因为&#39;B&#39;、&#39;C&#39;、&#39; &#39;都不等于&#39;A&#39;，因此可以从(4,0)重新开始匹配。 另一个例子，考虑新的S=&#39;ABCDAB ABCDABCDABDE&#39;，在(6,6)处发现&#39; &#39;和&#39;D&#39;不等失配。同时发现P[0..1]和P[4..5]都能匹配S[4..5]（当然S[4..5]和S[0..1]都能匹配P[0..1]的&#39;AB&#39;，但目前我们考虑只移动模式串），由此可以尝试从(4,2)（注意j变成了2不是0）开始重新匹配，容易发现S并没有发生回退，而P右移了4位，用自己P[0..1]而不是P[4..5]的&#39;AB&#39;去匹配S[4..5]了。 因此可以得到KMP算法的思想：如果模式串P在(i,j)处失配文本串S，那么可以知道至少P[0..(j-1)]和S[i..(i+j-1)]是匹配的，既然如此，不妨可以利用已经匹配的这段长度，只回退（将串向右移动）模式串P，不回退文本串S（注意在KMP算法过程中对文本串S的操作只有递增一个）。因此通过KMP算法，假设在(i,j)位置发生失配，那么接下来应当右移符号串j-f(j)长度，从(i,f(j))位置开始重新匹配（注意此时失配前P[0..(j-1)]和S[i-(j-1)..i-1]已经匹配的部分会和P[f(j)-(j-1)..f(j)-1]重新匹配），其中f为next函数，将在下节中详细介绍；特别地，当j = 0时，我们应当从(i+1,0)开始匹配。可以得到这样算法的复杂度为O(n+m)。 KMP算法和next函数首先定义边界的概念，串v是串u的边界表示串v是串u的后缀，也是串u的前缀。我们考虑一下这样的u，它是一个奇妙的字符串，它的最前面一段和最后面一段是可以重叠的。有两类函数可以实现KMP，一种是fail函数fail(j)，对于失配的(i,j)，fail(j)是P[0..j]中最长边界对应的前缀的最后一个元素的下标。另一种是next函数next(i)，对于失配的(i,j)，next(j)是P[0,j-1]中最长边界后面那个元素的下标。这里的定义很奇怪，这是由于我们是从如何计算而不是如何应用的角度来说的。从作用上来讲，next(j)表示在(i,j)失配后rewind模式串（右移），从(i,next(j))重新匹配。fail实现的特点是计算的值会有很多-1，但是next实现只有next(0)是-1。在这里我们采用next函数进行描述。 next函数f(j)指出了查找下一个匹配时的模式串（这里可以理解为P[0..m-1]的子串P[0..j]）的回退距离（模式串P向右移动的距离），或者可以被称作最长边界。用形式方法来描述即，对于模式串P[0..j]来说，f(j) = max(k)，这里k满足P[(j-1)-(k-1)..(j-1)]即P[(j-k）..(j-1)] = P[0..(k-1)]（注意这里是j-1和k-1，在别的定义/实现方式中可能使用j和k）。这里要求是最大的k也就是最长边界，原因是考虑到可能存在多个k，为了不丢失匹配，回退距离应当尽可能小。 特别地，当j = 0时，即对于(i,0)位置的失配，指定f(0) = -1，这意味着我们应当递增文本串S的指针i，从下一位置匹配。 为了计算所有的f(1..m)，可以根据定义进行计算，朴素的方法需要O(m^2)的复杂度。但是可以采用dp实现线性复杂度的算法：令f(j) = k，即已知最大的k满足P[j-k...j-1] = P[0...k-1]，现在求f(j+1)： 如果P[k] = P[j]，则f(j+1) = k+1。 如果P[k]!=P[j]，于是显然P[0..k]显然不是P[0..j]的后缀（注意根据f定义下标分别是到j和k），所以只能在P[0..(k-1)]上寻找P[0..j]的后缀，但是P[0..(k-1)]也不一定就满足条件，当然可以对P[0..(k-1)]的所有前缀判O(k^2)次，但是也有简单办法，那就是利用失配前已经匹配了的结果。请在这里停顿并尝试自己推一下下面的过程，并体会其中的奇妙之处。令k= k2 = f(k)，继续寻找，如果此时P[k2]=P[j]，那就符合了，否则还要继续寻找。为什么说只要比较P[k2]=P[j]就行了呢？前面的k-1的长度不需要比较了么？因为k2是最大的满足P[k-k2..k-1] = P[0..k2-1]（也就是P[0..k2-1]的最长边界长度），而注意到我们发现P[k]!=P[j]，说明至少P[0..k-1]和P[j-k..j-1]是匹配的，因此P[0..k2-1] = P[k-k2..k-1] = P[j-k..j-1]，即我们新找到的P[0..k2-1]也和P[j-k..j-1]匹配。 下面对P=&#39;ABCDABD&#39;构造next函数。根据上文，首先有f(0)=-1。接下来计算f(1)，也就是在(i,j = 1)发生失配。我们需要找到此时P[0..(j-1)]=&#39;A&#39;的某个后缀同时也是P的前缀，显然并不存在。 简单的总结下，我们DP的过程是，假设已经求得P[j]，便尝试通过匹配的P[0..a] = P[b..j]来推导P[0..a+1]和P[b-1..j+1]是否匹配，如果P[a+1] != P[j+1]就可以立马使用前面的P。 求next函数和KMP算法比较KMP算法实际上是求模式串P[0..m]对文本串S[0..n]长度为m+1的边界（如果存在即找到）。next函数实际上是求模式串的某个前缀P[0..j]对P[0..j]长度最大的边界。回想KMP算法，在(i,j)位置发生失配，那么接下来应当从(i,f(j))位置开始重新匹配，因为f(j)是P[0..(j-1)]的最长边界。而在计算next函数f(j+1)时候，如果P[k]!=P[j]，那么可以理解为模式串P[0..k]在匹配文本串P[0..j]时在(j,k)发生失配，因此同样可以利用之前已经匹配了的结果，按照KMP应当从(j,f(k))开始寻找。 相关资料KMP算法有很多教程，每个教程都给出了自己的一套理解方法，没有一个我能够完全看懂。在学习过程中，我参照了Wikipedia的解释，其中适当后缀(proper suffix)，指的是不是自己本身的后缀，也就是“真后缀”。1234567891011121314151617181920212223242526272829303132333435363738// kuangbin模板void kmp_pre(const char P[],int m,int f[])&#123; // f[]：x[j-f[j]...j-1]=P[0...f[j]-1] // f[j]：为满足x[j-k...j-1]=P[0...k-1]的最大k值 // 对应于： // next[j]为满足x[j-z...j-1]=x[0...z-1]的最大z值 // next[j+1]为满足x[j-(z-1)...j]=x[0...z-1]的最大z值 int j,k; k=f[0]=-1; j=0; while(j&lt;m) &#123; while(k!=-1 &amp;&amp; P[j]!=P[k]) k=f[k]; f[++j]=++k; &#125;&#125;int KMP_Count(char P[],int m,char S[],int n)&#123; // P是模式串，S是主串 int i,j; int ans=0; kmp_pre(P,m,next); i=j=0; while(i&lt;n) &#123; while(-1!=j &amp;&amp; S[i]!=P[j]) j=next[j]; i++;j++; if(j&gt;=m) &#123; ans++; j=next[j]; &#125; &#125; return ans;&#125; 我也写了个实现 复杂度分析求next函数具有线性复杂度，考虑到内部有一层while，使用通常方法不易计算。实际的复杂度计算使用了摊还分析。 摊还分析对于一个操作序列，并不是所有操作的复杂度都相等的，例如对于std::vector，push_back()操作是O(1)的，但是当满了之后resize的操作却是O(n)的，仅通过push_back()便认为对std::vector增加一个元素需要常量时间是不恰当的（虽然却是是常量时间）。摊还分析(amortized analysis)是一种分析操作序列中所有操作的平均时间上界的方法。摊还分析主要有聚合法，核方法和势能法。 聚合法聚合法就是求出所有操作加起来最坏情况的总代价，然后除以总操作数。对于std::vector的添加元素操作来说，假设初始大小是1，倍增因子是m，要添加$n$个元素，需要重新分配内存$\lceil log_{m}{n} \rceil$次，第$i$次分配内存需要移动$m^{i-1}$个元素，总共需要$ \sum_{i=1}^{\lceil log_{m}{n} \rceil}{m^{i-1}} = O(n) $次移动操作，另需要push_back $n$次。因此复杂度为O(1) 核方法MIT的算法导论课公开课老师讲这个的时候在黑板上写了2 3 3 3…对这个记忆犹新核方法的原理就是把复杂度低的操作承担一部分复杂度高的操作的代价，从而证明算法复杂度的上界。定义$c_i$为第$i$个操作的真实代价，定义$\hat{c}_i$为摊还代价。在第$i$时刻，定义信用为$\sum_{i=1}^n{\hat{c}_i} - \sum_{i=1}^n{c_i}$，选取的摊还代价要保证信用始终非负，因为一旦信用是负数，那么这个操作实际上是在开销上界内不能完成的上图是一个倍增因子m为2的动态表std::vector，$size_i$表示添加第$i$项时的表达大小，真实代价$c_i$由两部分组成，一部分是添加进表的固定成本（$c_i$第一行），另一部分是把元素复制到新表中的成本（$c_i$第二行），$bank_i$就是信用。对于$m=2$的情况，可以发现$\hat{c}_i$取3即可，这包括自己的真实代价，移动表的前一半的代价，和移动表的后一半的代价。对于普遍的倍增因子m，后面m-1的元素要m个元素的移动代价，加上添加进表的1，摊还代价取$1 + \frac{m}{m - 1}$，特别地$i = 1$时只要支付自己的移动代价，故摊还代价为$1$，于是等式左边$\sum_{2}^{n}{(\frac{m}{m - 1})} + n = \frac{2nm - n - m}{m - 1} $，等式右边$n + \sum_{0}^{\lceil log_{m}{n} - 1 \rceil}{m^i} = n + \frac{n - 1}{m - 1} = \frac{nm - 1}{m - 1}$，发现左边恒大于右边。 势能法势能法和核方法基本上是相同的，区别在于核方法要先假设摊还代价，而势能法先考虑的信用和（也就是势）。对于有的题目势能法比核方法简单。对于上面的$m=2$的动态表，定义势函数$\phi(D_i) = 2i - 2^{\lceil log_{2}{i} \rceil}$，由于$i = 2^{log_{2}{i} }$，所以可以得到式子恒为正。因此满足势函数的基本要求$\phi(D_0) = 0$和$\phi(D_i) \ge 0$。下面计算摊还代价$\hat{c}_i = c_i + \phi(D_i) - \phi(D_{i - 1}) $，其中$c_i = \begin{cases} i \, , \, (i - 1) &amp; ((i - 1) - 1) == 0 \\1 \, , \, otherwise \end{cases}$。通过对$i$的讨论，可以发现每个操作的摊还代价是3，这和前面的核方法形成了印证。下面考虑倍增因子为m的情况，定义势函数为$\phi(D_i) = 2i - m^{\lceil log_{m}{i} \rceil}$，可以进行类似的计算，得到每个操作的摊还代价是$1 + \frac{m}{m - 1}$ 求next函数的复杂度下面使用摊还分析计算求next的kmp_pre函数的复杂度。首先跟踪变量k，因为k出现在了最内层的while中，但是j没有出现。发现对k有两次操作，第一个是k = f[k]，这个操作是当P[k] != P[j]时，利用先前的结果计算f(j+1)。第二个是++k，这个是当(j, k)匹配时，令f[j + 1] = k + 1，并继续外层的while循环循环计算f(j + 2)的值，直到j &gt;= m结束，m是模式串的长度。可以发现外层的j和k每次自增1，并且在等于m的时候跳出循环，这类似于对动态表添加元素的1的代价。特别地可以发现j和k的上界最高就是m。内层while循环是将k不断缩小，很难求出外循环的某次循环中内循环共循环了多少次，但是可以看出内循环体在整个函数中最多被执行m次，这是因为k最多只能加到m，所以最多只能变小m次。将外层循环视为操作序列，内层循环摊还的代价就是$O(1)$。因此这个函数的总代价是线性的。 TrieTrie（/ˈtraɪ/，字典树，前缀树）将多个字符串组成一棵有序树。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。在构造Trie树时，需要用flag数组标记每个节点是否可能是某个字符串的结尾，而不能仅靠“无路可走”来断定，例如对于单词表[b, bb]，b和bb都是合法的单词。 例题HDU 1247是Trie的简单应用，首先把每个字符串添加到Trie树上，然后对于每个字符串，搜索他的每个前缀，对于任意前缀，如果它产生的字符串属于这个单词表（碰到flag为true的节点），那么紧接着继续往下搜索看能不能搜到第二个字符串。这道题注意要搜索每个前缀，考虑下面的样例 ha hat word hatword 如果在实现时，对hatword第一次query到ha即返回，下面从tword开始就无法匹配了，由于第一次query已返回，所以也不会继续搜索前缀hat了。 AC自动机AC自动机（Aho-Corasick automation）能够匹配多个字符串，可以用来在线性时间内解答字符串S中出现了哪些字典D中的模式串的问题。从算法思想上来看，AC自动机结合了Trie和KMP的思路，虽然它的出现甚至要比KMP早。对我来说AC自动机的思想显得比KMP“自然”点，我们在Trie树上走，如果走不下去（失配）了，我们就回退到某个上层的节点。在这点上和KMP很相近，因为KMP也不回退文本串。于是现在我们要高效的求出在失配时是需要回退到的节点，也就是为所有节点生成失配指针。显然我们的高效算法能够利用先前节点的结论，所以我们以BFS的顺序来访问这个树上的所有节点。首先root的失配指针肯定是NULL，root都失配那就无路可走了。我们按照下面的规则生成失配指针，假设从状态S1通过读取字符x可以到达状态S2，我们现在计算状态S2上的失配指针。首先我们查看S1的失配指针指向的状态节点F1，注意F1不一定是S1的父节点，有可能在Trie的另一个分支上，所以我们需要BFS而不是DFS。接下来我们查看F1能不能通过x走到它的一个儿子节点F2，如果能，那么就更新S2的失配指针为F2，如果不能我们就沿着这个F1的失配指针继续网上找。容易看出现在root的前缀指针None显得不太合群了，因为root所有的子节点的失配指针都应当是root，而按照上面的规则会被计算成是自己。 后缀数组字符串S[0..n-1]后缀是指的形如S[i..n-1]的字符串。后缀数组P[0..n-1]给出了S的所有后缀S[i..n-1]经过字典排序后的起始下标i。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>字符串</tag>
        <tag>KMP</tag>
        <tag>AC自动机</tag>
        <tag>Trie</tag>
        <tag>摊还分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大流]]></title>
    <url>%2F2016%2F10%2F14%2F%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[总结一下最大流的各种算法 最大流问题设赋权有向图 $D(V,E,C)$，其中每一条边的权值$c \in C$表示这条边的容量。流$f: V * V \rightarrow R$是对于边$e \in E$的函数。我们定义唯一的开始节点$S$是源，只发出流量；唯一的结束节点$T$是汇，只接受流量。一个流网络具有以下的形式 流入流量取正号，流出流量取负号 每条边的流量$|f(u,v)|$不能超过容量 流经中间节点的流量无损耗 形式化的表述如下$$f(u, v) = -f(v,u) \\f(u, v) \le c(u,v) \\Σf(u, *) = 0, u \notin \{S, T\} \\$$ 特别注意对于条件1，可以得到只要有向边$(u,v)$上存在流$f(u,v)$，那有向边$(v,u)$上必然存在$f(v,u) = -f(u,v)$。特别地该边不存在的情况可以表示成$c(v,u)=0$，但是实际上我们只考虑流量为正的边，所以在一些教程上也只画出了这样的边。最大流问题就是求解通过流网络从源$S$能够流出的最大流量，也就是汇$T$能够得到的最大流量。 Ford Fulkerson方法最大流最小割定理对于网络流$G(V,E)$，以下命题等价： f是G的最大流残余网络不存在增广路径最大流的值就是这个网络的最小割。 残量网络残量网络是一个双向图。定义剩余容量$cv(u,v)$$$c(u,v) - f(u,v) \qquad 若(u,v) \in E$$由cv为权的新有向图称为残量网络。并且当$f(u,v)$为负数时，$cv(u,v)$会大于$c(u,v)$。 增广路径Ford Fulkerson方法的Edmonds Karp实现与朴素Ford-Fulkerson算法不同的是Edmonds-Karp要求每次找长度最短的增广路径，即使用BFS查找增广路径。时间复杂度是$O(n m^2)$，空间复杂度是$O(n^2)$。 Dinic算法SAP算法]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5889 Barricade 最大流最小割+BFS]]></title>
    <url>%2F2016%2F10%2F13%2FHDU5889Barricade%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2016 青岛网络赛赛题 Barricade 题意有图G(N, M)，每条边具有相同的长度和不同的权值。现在有敌人从点N沿最短长度路径到点1。现在要求在部分边上设置障碍，使敌人无论怎么走总能碰到障碍，求这些切断的边的最小权值之和。 思路分析因为敌人走最短路径，所以要建立新图，新图中只能保留死路和最短路径。因为每条路的长度都相等，所以可以采用bfs来寻找最短路径。在建立新图之后对新图用网络流即可。从点N开始使用dis记录到各点最短路。当bfs到点x，尝试使用点x松弛所有相连点i并在新图中添加路径(x,i)；但当bfs到点1并且点当前点x的长度大于dis[i]（广度优先搜索总是最短路的），则不使用该点更新dis。这样得到的图只含有死路（在得到dis[i]前bfs的部分）和最短路径。代码 需要注意的地方有几个地方需要注意： 第一个是使用bfs建立新图时 第二个是这道题源是N，汇是1，是反过来的 第三个因为最短路，所以只要添加单向边就好。 在bfs更新dis的时候我把u和v搞反了。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC 2013 杭州邀请赛]]></title>
    <url>%2F2016%2F10%2F13%2FICPC2013%E6%9D%AD%E5%B7%9E%E9%82%80%E8%AF%B7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2013 杭州邀请赛复现 1010 Shaolin题意少林寺和尚上山需要比武，每个和尚具有id和武力值(k, g)。新和尚在比武时在已经上山的和尚中选择和自己武力值最接近的和尚比武（如果有两个就选择比自己弱的那个），现在给定和尚上山顺序，对于每个和尚计算应该和谁比武。 解答模拟，考虑到set是自动排序的，因此可以使用两个set分别存正序和逆序，然后分别lower_bound，注意处理只有一个武力值最大/最小的情况。代码 1009 Building bridges题意有一个m行n列的矩阵上有C岛H岛和O海洋。现在要在H和C之间建一个曼哈顿距离最短的桥。要求输出选择的H岛的坐标(x1,y1)和C岛坐标(x2,y2)，在曼哈顿距离相同的情况下依次按照x1, y1, x2, y2从小到大进行排序。 解答直接爆搜O(n^2*m^2)。代码 1001 Robot题意有一个1..n的环，从点1开始以均等概率逆时针或顺指针走w步，问进行m次操作后，停在[l,r]区间上的概率。 分析这道题目是概率dp，假设在旋转次m时，落在环上每一点的概率可以由旋转m-1次的概率求得。比较坑的地方是这题卡常数，我的一个算法用((((1 + x) % n) + n - 1) % n) + 1求wrap，多调用了几次mod就挂了。这也提醒我一般mod使用要注意，在我的笔记本电脑上测试1s能跑5.2e7次，乘法能跑1.6e8次。代码]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC 2014 广东现场赛]]></title>
    <url>%2F2016%2F10%2F13%2FICPC2014%E5%B9%BF%E4%B8%9C%2F</url>
    <content type="text"><![CDATA[ACM/ICPC 2014 广东现场赛复现 1011 How Many Maos Does the Guanxi Worth题意有N个点，要求去掉一个点使得不连通（输出Inf），如果不能做到则使得最短路径路径最长（输出该值）。 思路裸的dijkstra，增加del[disable] = true，在判断vis[j]的地方加上判断!del[j]。由于删掉一个节点导致图可能不连通，因此注意红书模板mark==-1的时候要直接return，外循环不要N次。代码 1002 The E-Pang Palace题意有小于30个点，找出两个（必须是两个）不相邻、不相交的矩形。求面积并的最大值。 思路用vector&lt;int&gt; corx，cory记录出现过的坐标，并排序。用bool hit[x][y]表示点(x, y)是否出现过。在corx和cory中枚举出x1, x2, y1, y2（x1 != x2, y1 != y2）。如果点(x1, y1)和点(x2, y2)存在，那么将矩形添加到vector&lt;RECT&gt; vecrect中。接着分别检测相交（矩形1有一个点在矩形2里面）、相邻（横坐标相等，一个矩形纵坐标左边在另一个矩形的两个纵坐标中间）。这里如果实现保证struct RECT中x1 &lt; x2 &amp;&amp; y1 &lt; y2，会比较方便。但是还是WA，后来发现矩形1在矩形2内也算对的。我觉得这就比较坑了，因为题意是圈地分封，如果两个矩形成包含关系怎么分封呢？代码 1009 Little Zu Chongzhi’s Triangles题意有N个长度不等的线段，问能够组成的所有三角形最大面积和是多少，棒子不一定要全部用完。 思路贪心（当然这条数据较小也可以暴力，复杂度(12,3)(9,3)(6,3)）。每次取尽可能长的边。首先对数组a从小到大排序，如果a[i], a[i - 1], a[i - 2]能够组成三角形，那么加上这一组，如果不能，考虑a[i - 1], a[i - 2], a[i - 3]（舍弃a[i]是因为根据两边之和大于第三边，a[i - 3]相对于a[i - 2]肯定更不可以了）。证明：在HDU 5914上我们得到结论一个数列上任意三条边不构成当且仅当该序列是类斐波拉契数列的子数列。代码 1005 Song Jiang’s Rank List题意给水浒英雄排座次，按杀人多少，杀人数相同按照名字字典序排列。阅读理解，水题。代码 1004 Signal Interface题意思路]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西瓜书笔记]]></title>
    <url>%2F2016%2F10%2F12%2F%E8%A5%BF%E7%93%9C%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开始写周志华教授的《机器学习》一书的学习笔记。也包含prml等书的学习笔记。 绪论假设空间]]></content>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长上升子序列(LIS)和最长公共子序列(LCS)]]></title>
    <url>%2F2016%2F10%2F04%2FLISLCS%2F</url>
    <content type="text"><![CDATA[区别于字符串，序列并不一定是连续的。最长上升子序列(LIS)和最长公共子序列(LCS)算法是基础的序列算法。 最长公共子序列(LCS)这是一个经典的dp问题，使用dp[i][j]表示表示序列X的i位和序列Y的j位之前的最长公共子序列的长度。那么如果X[i] == Y[j]，dp[i][j] = dp[i+1][j+1] + 1；否则dp[i][j] = max{d[[i-1][j], dp[i][j-1], dp[i-1][j-1]}。 例题 POJ 1458 Common Subsequence第一次写成这样。应该是这样 最长上升子序列(LIS)$O(n^2)$方法运用动态规划的方法，记录$ l_i $为序列$a_{1..(i-1)}$中前$i - 1$个数中最长的上升序列长度。现在需求$l_i$，考虑将$a_i$插在以$i$前面的某个元素$a_j$的结尾的子序列的后面，那么就是要满足以下条件： $a_i &gt; a_j$ ，这是显然和必须的，否则这个序列就不是上升子序列 $l_j$最长 因此，对于$a_{i+1}$，需要找出最大的$l[m]$并且$a[m] &lt; a[i]$。可以发现复杂度为$O(n^2)$。容易发现，寻找最大的$l_j$可以使用二分法。因此可以得到下面的$O(NlogN)$方法。 区间段问题为了更好地理解下面的$O(NlogN)$方法，可以考虑有若干个任务具有不同的起止时间，在同一时间只能做同一任务，并且该任务完成后才能开始新的任务。现在要求找出能够完成的最多任务数。容易想到这是一个贪心问题。事实上每次选取结束时间最早的任务，这样保证了剩下的时间短尽可能地长，而一个较长的时间段肯定比它的较短的部分的可选工作数要多（至少不会变少）。 O(NlogN)方法这个方法与区间段问题的思想类似，要使得上升子序列最长，就要使得序列上升尽可能慢，因此我们希望每次在序列最后加上的数尽可能小，当然由于数列的长度是有限的，所以不一定这样能得到足够长的LIS序列，所以我们在确定新得到的LIS数列足够长的时候再更新长度。因此我们记录$dp[i]$为长度为$i$的LIS序列的末尾元素的值，使用动态规划依次计算$dp[1..n]$。我们使用$len$记录目前最长LIS的长度，显然$dp[i]$关于$i$是单调不减的。这是因为如果我们假设$dp[i] = 3$、$dp[i - 1] = 4$，那么$dp[i]$还多取一个数，所以也至少应该取到4。当使用$a[j]$更新$dp$时，我们顺着$dp[1]$开始找，一旦发现$dp[i-1] &lt; a_j &lt; dp[i]$，那么可以用$a[j]$更新$dp[i]$，同时如果当前的$i$（从1开始）大于记录的$len$时，用$i$更新$len$。需要注意的是，虽然在原序列中$a[j]$出现在$dp[i]$对应的$a[j]’$之后，如果$a[j]$包含在序列中，那么比$a[j]$大的$a[j]’$显然不会包含在序列中，但是这不影响取得最大值，因为除非从$a[j]$开始的新序列能够去得更长的$len$，否则仍然取得的是当前的序列。此外，在找到$j$之后不要更新后面的$dp[i + 1..n]$，因为每取一个$a$，向后面递推一次$dp$。在寻找时，考虑到dp是一个不降序列，可以使用lower_bound函数（内部采用二分查找）。这个函数将会返回大于等于val的第一个值的指针，如果不存在就返回end指针，在使用时候注意区别upper_bound函数，upper_bound函数返回的是严格大于val的第一个值。注意指针的差值从0开始，但是序列长度从1开始，所以得到的差值转换成长度要加1。 例题 HDU 5532 Almost Sorted Array此题题意要求找出一个序列是否可以去掉最多一个元素形成一个sorted array。因此可以正反（考虑到可能是不升序列也可能是不降序列）求一次LIS（不降子序列），那求出的最长上升子序列的长度至少要大于等于n-1那么就是满足题意的。当然这道题目也可以用O(n)实现。O(n)算法需要注意不能只判断连续情况。 最长公共上升子序列(LCIS)]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>动态规划</tag>
        <tag>序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5914 Triangle]]></title>
    <url>%2F2016%2F10%2F04%2FHDU5914Triangle%2F</url>
    <content type="text"><![CDATA[这道题来自HDU 5914/ CCPC2016 长春现场赛 Triangle这道题目一开始想的是打表的解法，后来发现一直WA。后来找规律发现是斐波拉契数列。 题意有边长[1..n]（n不超过20）的边，问最少去掉几个边才能使得剩下的边不能组成三角形。 证明充分性：斐波拉契数列的任意项$l_i$，$l_j$，$l_k$均不构成三角形。由于任意三角形三边$a$、$b$、$c$，其中（$a &lt; b &lt; c$）均需要满足$a + b &lt; c$。而对于斐波拉契数列中任意的边$l_{k-2} + l_{k-1} = max(l_i + l_j) = l_k, i, j &lt; k$ ，因此不可能存在构成三角形。必要性：在斐波拉契数列中增加任意一项，则可以构成至少一个三角形。假设添加边长$m$在$l_i$和$l_{i+1}$之间，由于$l_i + l_{i+1} = l_{i+2}$ ，因此 $l_i + m &gt; l_{i+2}$，因此至少构成一个三角形。特别地，形如1, 3, 4, 7, 11…或者2, 5, 7, 12…等数列同样具有斐波拉契数列$f[i] = f[i - 1] + f[i - 2]$的性质，但是以$1, 1, …$开始的斐波拉契数列显然“利用率”最大。 打表方法之前有试过贪心打表方法，具体地，对于每个n，枚举出所有的三角形，统计出在三角形中出现最多次数的边（如果次数相等则进行dfs搜索），不断剔除边和，并移除该边对应的三角形，直到所有三角形都被移除。但事实上这种方法是不行的。例如对n=13，算法分别移除9（出现40次）、10（40）、8（39）、11（38）、6（34）、4（25）、12（35）、3（18），但却没有移除13（30）。其构成的1, 2, 5, 7, 13并不是最优的数列。]]></content>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU 5553 Advanced Calculator 表达式求值]]></title>
    <url>%2F2016%2F10%2F01%2FHDU5553Advanced-Calculator%2F</url>
    <content type="text"><![CDATA[这道题来自HDU 5553/ ICPC2015 合肥现场赛 Advanced Calculator，现场赛无人做（那场1题Cu，2题Ag，4题Au）。截至目前HDU上只有三人过这条。我现在还没有过这条，所以想贴出来我的想法、遇到的一些坑和代码http://paste.ubuntu.com/23275313/，也希望有大神能给我一点测试数据什么的。这道题就是表达式求值，运算符有+、-、*、/、(、)、=（可以连等）。操作数分为int和double。同时有唯一输出函数print。通常想到的办法就是逆波兰式。 逆波兰式基本的逆波兰式逆波兰式将中缀表达式转换为后缀形式。首先需要两个栈，表达式栈tok储存后缀表达式结果，栈ops用来暂时存放运算符。遇到变量的时候直接入tok栈。遇到运算符比较当前运算符op和ops.top()运算符的优先级。如果当前运算符op优先级大，则将op直接入栈ops；如果当前运算符优先级小于等于则依次弹出ops栈中运算符并入tok栈，直到栈空。特别地，当ops栈顶是左括号(时候，可以认为左括号优先级最小，因此当前运算符op可以直接入ops栈。在当前符号是右括号)的时候，弹出ops运算符中并入表达式栈，直到看到左括号(。 处理单目运算符有两个单目运算符正号+和负号-，同时他们也身兼二目运算符加法和减法的作用。为了区别这两个运算符，需要增加bool Arity2来记录是否在每个操作符前面出现了操作数，如果出现了，则是二目运算符。特别地，唯一的函数print可以作为一个单目运算符处理，实际上对于逆波兰表达式而言，函数本身就应当作为一个运算符，只是参数数目要以逗号数目确定。 不同数据类型的四则运算首先是数据的存储，对于运算数存储，一种方法是采用union来合并double和int，同时使用type来记录类型信息，不过这里考虑到可能存在的精度问题，以及将变量和常量统一起来，这里采用string val来记录数据，对于常量val为其字面值，对于变量，val为器变量名，对应值查表slots。对于运算符，直接采用char op存储。同时采用struct Item来把运算数和运算符统一，这样方便统一栈操作。 已知的坑不同数据类型的连等号考虑以下代码:1234int a;double b;b = a = 1 + 1.5;print(b); 结果应该a=2，b=2.000000而不是2.500000。 使用double2string转换丢失精度在进行计算的时候，采用sprintf和sscanf进行string和valuetype之间的转换。根据cppreference对sprintf的说明： Precision specifies the minimum number of digits to appear after the decimal point character. The default precision is 6.可以发现从string到double必须人为指定一个较长的数精度，这里指定了30位的小数。 It should be noticed that not all C— programs should contain variable statements变量是可以没有声明的直接引用的，这时候默认变量的值是0。 string::substr这个错误是经常犯的，substr的第二个参数是长度，而不是结束为止。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图匹配]]></title>
    <url>%2F2016%2F08%2F21%2F%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[总结一下二分图匹配的几种算法 定义把图的顶点分为不相交集合U和V，不存在连接U或V内部点的边，这样的图成为二分图（bipartite graph）。二分图有一些性质，如二分图中不存在奇数条边的环（奇圈），因为环必须首尾相接的，奇数条边必定会使首和尾分处于U和V中。匹配是对于边而言的，表示在所有的边中，任意两条边都没有公共顶点。如果一个图中的所有顶点都能够构成匹配，则称这个图存在完美匹配，否则这个图只存在最大匹配，含有尽可能多的匹配边数。一个点被当前匹配饱和指这个点在当前匹配的某个边上。 匈牙利算法算法介绍匈牙利算法试图优化当前的匹配，得到边数+1的匹配。构造的方式是从一个非饱和点（也称为非匹配点，saturated vertex）开始，依次通过非匹配边、匹配边、非匹配边…（这样非匹配边和匹配边交替形成的路径叫做交替路）。容易发现这样的路径总结束于一个到非饱和点的非匹配边，因为到达于一个匹配点，如果轮到走该点关联的那条匹配边，这样要么走完完美匹配，要么到达另一个匹配点。如果轮到走非匹配边，则可能到达一个匹配点（回到上个情况），也可能到达一个非饱和点，但是非饱和点肯定是不能继续走匹配边形成更长的交替路的，于是结束。可以发现，这样走下来非匹配边始终比匹配边多一条，并且除了一头一尾的两个节点，中间节点全部是匹配点，如果反向匹配边和非匹配边，就能够得到边数+1的匹配。因此把这条起点和终点未饱和的交替路称为增广路。可以发现这样的增广路中每个点至多出现一次，因此反向匹配边和非匹配边后不会出现一个点有两个匹配边连接的情况，并且增广路的长度总是奇数，并且总是起于二分图的一端，终于二分图的另一端。根据berge定理，如果图G中不存在对匹配M的增广路，那么该匹配M是最大匹配。 算法实现在实现匈牙利算法时，并不需要显式地去建立交替路，交替路的扩展和反转通过dfs（或者bfs）隐式地表现出来。这样的算法复杂度O(EV)，经过优化的Hopcroft-Karp算法复杂度可达到O(E*sqrt(V))。首先实现寻找增广路径的算法。从节点U（大写表示二分图左部）进行dfs寻找从U开始的增广路（因为从U开始，所以U必然要是非饱和点）。对于U的所有出边(U, v)，假如v是非饱和点，那么可以直接匹配U和v，显然匹配数会增加1。假如v已经和W匹配，但是能够为W在右部找到另一个匹配点x，那么就将U和v匹配。即对于这一种情况，匹配数同样是增加1的，假设原先(W, v)是匹配的，如果现在匹配U和v，则W失去匹配，匹配数并没有增加，但是如果能够找到另一个x能够和W匹配，那匹配数增加1，当然这个过程是递归的（因此匈牙利算法寻找增广路使用dfs实现），x和W匹配同样可能导致x的原配失配，因此这个算法的返回值是个表示是否存在增广路的布尔量，如果在递归的末端存在x的匹配Y不能找到新的匹配，也就是不存在从x开始的增广路，那么也不存在从v开始的增广路。对于其他情况就不存在从U开始的增广路。因此整个算法可以枚举二分图左边的点x，寻找是否存在增广路，从而得到匹配。在实现算法的时候需要注意对于有向图邻接矩阵不能设置m[dest][src]。下表给出了一个匈牙利算法的实例，其中红色点表示已经匹配了的点。增广路搜索始终从左端开始，因此从左侧到右侧是搜索的是不在当前匹配M中的边，从右侧到左侧是在当前匹配M中的边 初始情况 寻找增广路 新的匹配 例题 HDU2063代码 Hopcroft-Karp算法算法介绍匈牙利算法使用dfs寻找增广路，Hopcroft-Karp算法作为改进使用bfs寻找增广路，bfs相对dfs的优势是找到的增广路永远是最短的。因此Hopcroft-Karp每轮按层搜索多条无公共顶点的增广路并全部替换。算法流程如下： 将所有未饱和的左侧顶点作为第0层 对于偶数层顶点，通过不在当前匹配中的边寻找 对于奇数层顶点，通过在当前匹配中的边寻找 当发现未饱和右部顶点，或搜完全部顶点，bfs终止 如果搜到未饱和的右侧顶点，进行反向dfs，搜索回第一层的某个点，这样形成一条增广路。将这条增广路加入匹配，并临时删除这条路上的点和边。重复此步操作直到无法到达第0层。重新开始bfs。 算法实现Edmonds算法以上两种算法只可以在二分图上使用，这是因为二分图不会包含奇圈。 学习资料 Wikipedia 南京大学程龚讲义]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沙盒跳出]]></title>
    <url>%2F2016%2F08%2F21%2F%E6%B2%99%E7%9B%92%E8%B7%B3%E5%87%BA%2F</url>
    <content type="text"><![CDATA[因为参加在上海举办的计算机设计大赛决赛，今天没事所以去了上海科技馆，我们观赏了多个展区之余尝试突破展览馆中计算机展览程序的沙盒，并玩一盘扫雷游戏。首先在物理展区，我们遇到一个运行着全屏课件程序的计算机，只提供了一个鼠标，系统是winxp。在查看多个界面后，我们发现在留言区有一个切换输入法的按钮，于是我们切换成微软全拼输入法，于是屏幕上出现输入法的浮动窗，右击菜单随便选择一个选项，桌面弹出一个窗口，同时出现了任务栏，切换输入法找出软键盘，运行winmine即可。在3d打印区，我们遇到了一个被ClipCursor的win7计算机，提供了一个全键盘，但是功能键（如win键，ctrl+alt键等）全部被锁了。同时展览程序的窗体被持续设置了焦点。对于这台计算机，我们采用了连按5次shift开启粘滞键的方法，对于win7系统，粘滞键启动会导致弹出一个提醒框，点击提醒框中提示即可打开新的窗口并显示任务栏。在体验区，我们遇到了一个全屏的chrome程序，只提供了一个鼠标，我们找到一个有滑动条的页面，右击滑动条选择另存为，再在框中右击选择属性，即可看到桌面。]]></content>
      <tags>
        <tag>沙盒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tarjan算法]]></title>
    <url>%2F2016%2F08%2F21%2Ftarjan%2F</url>
    <content type="text"><![CDATA[有向图的强连通分量是一个极大强连通子图。一个强连通子图是一个节点集合，使得集合中的任意两个点互相可达。本文介绍有向图强连通分量的tarjan算法，并且提供了理解tarjan算法所需要的前置DFS知识。直观上来讲，tarjan算法对有向图建立搜索树，每一个连通分量都是该搜索树的一棵子树。tarjan算法由一个dfs构成，在dfs过程中，将访问过的节点压入一个栈中，栈顶到栈中的的某个元素构成一个极大强连通分量。 DFS相关知识补充相对于先前简单的vis数组，首先要介绍DFS的黑白灰染色法，我们规定当节点未被发现时为白色，被发现后为灰色，在它的所有邻接链表被扫描完毕后为黑色。使用黑白灰染色法能够方便我们进行下面的讨论。tarjan算法基于DFS，我们从任意一点$p$开始遍历，在DFS的过程中会形成一棵树（或者森林），称为DFS树。假如说我们从点$u$访问到一个尚未被访问的点$v$，那么边$(u, v)$是一条树边，体现在DFS上就是$v$是$u$的儿子。同理，紧接着从$v$继续DFS到另一个未发现的点$w$，那么边$(v, w)$也是一条树边。下面我们回到节点$u$，现在我们发现从$u$居然还有一条直接到$w$的边，这里的边$(u, w)$称为前向边，可惜在DFS时所有的前向边都不会体现在DFS树中，这是因为此时$vis[w]$必然为true，因此$w$是$u$的非儿子的后代。我们考虑刚才的前向边$(u, w)$，此时$u$为灰色，因为它访问的$w$节点还没有返回；$w$为黑色，$v$也是黑色，因为它的dfs已经返回了。下面我们考虑在此之前的一个情况，当$w$还是灰色的时候，它应该已经在$u$之前发现过$(u, w)$这条边了，但是这时候$u$和$w$都是灰色，这种情况就和上面之前看到的前向边不一样了，我们称他为后向边。后向边是一个非常有用的东西，它可以用来发现环和计算下面的强连通分量。我们还需要注意到后向边的一个性质，也就是$u.d &lt; w.d$，这是显然的。除此之外，还有一种横向边，不过所幸我们的DFS中只会出现树边和后向边。 算法原理我们容易发现可以把一个强连通分量看成搜索树中的一棵子树。我们在DFS的过程中不断将我们发现的节点加入一个堆栈。算法需要$dfn[u]=1..vertex\_count$记录对节点$u$的访问次序， 对应着算法导论中的属性$u.d$，即该节点从白变灰的时间戳，记录这个次序主要是为了处理后向边。$low[u]$记录节点$u$的最早祖先，它表示$u$或$u$的子树能够追溯到的最早的还在栈中的节点的时间戳，我们在将一个节点由灰标黑时计算该节点对应的$low$值。显然，在遍历前我们要设置初始的$dfn[u]$和$low[u]$等于时间戳$index$。当遍历后仍然是$dfn[u]==low[u]$时，$u$不存在可到达的祖先了，得到极大强连通分量。此时$u$也作为这个子树的根（并查集也有类似的性质）。这时我们考察堆栈，根离栈顶最远，永远在最后被弹出。$low[u]$在三种情况下更新： 当存在树边$(u, v)$时，应当尝试用$low[v]$更新$low[u]$。这种情况发生在节点$u$发现一个白色节点$v$的时候，此时首先会递归地调用dfs来计算$v$节点，当$v$节点的遍历完成也就是变黑后，dfs返回到我们在$u$节点的调用处，这时候我们尝试用$low[v]$和$low[u]$之间的较小值更新$low[u]$。因此$low[v]$总是先于$low[u]$被更新，可以通过$dfn[v]$是否为0判断$v$是否被访问过 当存在后向边$(u, v)$时，当此时$v$还在栈中时，应当尝试用$dfn[v]$更新$low[u]$，这里自环也被认作后向边。注意我们必须要判断在$v$是否在栈中，因为$v$可能已经是个黑色节点了，这时$(u, v)$是一条横向边。因此可以得到$low[i]$的过程123456789def tarjan(u) for each (u ,v) in E if (!dfn[v]) // 注意一定要先进行dfs tarjan(v); low[u] = min(low[u], low[v]) else if(v exist in stack) low[u] = min(low[u], dfn[v]) // 否则v属于另一个连通分量已被弹出 下面是整个tarjan算法12345678910111213void tarjan(int u)&#123; dfn[u] = low[u] = ++index; stack.push(u); update low[u] if(dfn[u] == low[u]) // 注意不要把if写在update的for each循环里面 pop stack to u // 注意是u不是dfn[u]&#125;int main()&#123; zero(dfn); for each u in V if(!dfn(u)) tarjan(u)&#125; 可以看到算法对于每个点都访问一次，由dfn(u)!=0保证，同样，对每个边$(u, v)$都访问一次。 LCA Tarjan这里的LCA Trajan是一种离线算法，它首先先要进行$O(n)$得到预处理。它的思路是第一次找到两个节点的时候，如果记录了他们的最低单亲节点，那么这个单亲节点就是LCA。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++资源管理]]></title>
    <url>%2F2016%2F08%2F05%2Fcpp%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[对Effective C++在资源管理部分的内容进行总结。 C++运行时内存C++运行时内存主要分为常量区、全局/静态变量区、栈区、堆区和自由存储区。其中前两者存在于程序的整个生命周期，栈中的变量由编译器自动分配和清除，所以称作自动变量。堆区由new调用构造函数初始化，由delete调用析构函数回收。自由存储区由malloc分配一块指定大小的内存，由free释放。 RAII可以看出对于动态分配的内存（堆和自由存储）必须能够在适当时机调用delete/free进行释放，否则会造成泄露，也有可能某处代码在先前已经delete/free了，造成悬空指针undefined behaviour。当然可以建立一张表（称为对象池）登记这些指针，当满足一些条件的时候进行删除的手动管理。不过最好的方法是通过RAII借助编译器管理指针。编译器的自动回收机制包含了栈和对象两种。其中栈能够管理自动对象，但是它只会清除指针本身而非指针指向对象。 复制一般对象之间的复制行为分为4种： 浅复制：浅复制也是默认复制构造函数的实现，将源对象中的成员复制到新的对象中。因此如果源对象中存在指针，那么实际上源对象和新对象是共享指针指向的对象的，这并不是一个错误的逻辑，但是问题在于新老对象都没有意识到自己和别的对象共享着资源，如果存在析构函数（除非使用手动管理，否则必然要有析构函数用来释放指针指向对象），那么必然会造成悬空指针。 深复制：需要自定义复制构造函数，在复制行为发生时递归地建立对象成员以及指针指向对象的副本。 资源控制权转移：资源占用具有排他性 资源控制权共享：类似于浅复制，但是这种方案解决了资源释放的问题，对于需要共享的资源设置引用计数，当引用计数变为0时销毁对象，而不再通过构造函数。 深复制在深复制中可能存在一个问题，假设有若干个派生类继承基类Derived_i : public Base，现在有一个Base * d，但是不知道具体类型，现在希望对这个基类进行深复制。直接调用基类的复制构造函数Base p = new Base(d)显然是行不通的，一方面C++没有提供虚复制构造函数。常用的办法是自己定义一个clone函数。同样地，对于其他的构造函数，也是不存在多态的，因此如果需要对于不同的参数返回不同的派生类的指针，可以通过定义一个工厂函数来解决。对于没有使用继承或派生的类型，当然可以定义三个函数（复制、赋值、析构）进行深复制，假设复制对象obj，可以认为复制了一棵树，树中任何节点（成员）的析构都会导致该节点为树根的子树被删除，所以对于这棵树只能修改树根或叶子，否则会造成内存泄露。 复制构造函数和赋值构造函数复制构造函数指的形如T(const T &amp;)的构造函数，涉及到C++的复制初始化。其中复制构造函数常被定义为explicit的，此时必须显式地使用该构造函数。在C++11标准之后扩大了范围，将非explicit构造函数都称为转换构造函数。这里要区分转换构造函数T::T(const U &amp;)和类型转换运算符operator T::U()，前者是从U构造T，后者是从自己T构造U。类型转换运算符有很多的作用，常见的是实现将函数返回值加入重载决议。赋值运算符指的形如T &amp; operator=(const T &amp;)的运算符，指的是赋值而不是初始化操作。]]></content>
      <tags>
        <tag>C++</tag>
        <tag>智能指针</tag>
        <tag>RAII</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex和bison使用]]></title>
    <url>%2F2016%2F07%2F29%2Fflex%E5%92%8Cbison%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[flex/bison是对lex/yacc的开源实现，可以方便地进行编译器构造。MSVC下的flex和bison有着win_flex和win_bison这两个封装，用起来比较方便。本文就使用flex和bison进行编译器构造时出现的一些问题进行说明，并讨论一些进阶技巧，例如重定向输入流，处理大小写不敏感代码串，yymore，代码定位，错误信息及恢复，start condition，扩栈，push parser，glr-parser，%define指令，常见语法和错误处理方法以及flex/bison生成代码分析等。 在VS2015下配置在Sourceforge上下载 win flex-bison插件。下载后解压，将custom_build_rules文件夹按照右击项目-&gt;生成依赖项-&gt;生成自定义-&gt;查找现有的-&gt;选择custom_build_rules文件夹并添加确定。由此可以创建以.l结尾的flex文件和以.y结尾的bison文件。为了能够编译，还需要讲win_flex和win_bison复制到.l和.y所在目录下面。同时工具-&gt;选项-&gt;项目和解决方案-&gt;生成并运行可以选择输出的详细级别，改成普通之上可以得到flex和bison的编译输出信息。 flex使用说明如何重定向输入流yyin可以使用yy_scan_buffer函数重定向输入流，这个函数实际上调用了void yy_switch_to_buffer函数设置static YY_BUFFER_STATE * yy_buffer_stack的栈顶YY_CURRENT_BUFFER_LVALUE下面的语句是一个完整的重定向输入流的模板，也可以参考这里的不使用yacc的模板123456789101112// std::string in_str 被扫别识别的字符串// slen字符串长度YY_BUFFER_STATE buffer = yy_scan_buffer(buff, slen + 2);char * buff = (char *)malloc(slen + 2);// 要以两个'\0'结束memset(buff, 0, slen + 2);strcpy(buff, in_str.c_str());int token = yylex();yy_delete_buffer(buffer);free(buff); 需要注意一点的是，buffer必须以”\0\0”结尾，原因是在生成文件*.flex.cpp中，函数yy_scan_buffer的部分代码如下：123456789101112131415161718YY_BUFFER_STATE yy_scan_buffer (char * base, yy_size_t size )&#123; YY_BUFFER_STATE b; if ( size &lt; 2 || base[size-2] != YY_END_OF_BUFFER_CHAR || base[size-1] != YY_END_OF_BUFFER_CHAR ) /* They forgot to leave room for the EOB's. */ return 0; b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ); if ( ! b ) YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" ); b-&gt;yy_buf_size = size - 2; /* "- 2" to take care of EOB's */ /* 初始化b的其他字段 */ yy_switch_to_buffer(b); return b; 可以看出base[size-2]和base[size-1]是有用途的。顺便看一下yy_scan_buffer返回的typedef struct yy_buffer_state *YY_BUFFER_STATE类型12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct yy_buffer_state&#123; FILE *yy_input_file; char *yy_ch_buf; /* input buffer */ char *yy_buf_pos; /* current position in input buffer */ /* Size of input buffer in bytes, not including room for EOB * characters. */ yy_size_t yy_buf_size; /* Number of characters read into yy_ch_buf, not including EOB * characters. */ yy_size_t yy_n_chars; /* Whether we "own" the buffer - i.e., we know we created it, * and can realloc() it to grow it, and should free() it to * delete it. */ int yy_is_our_buffer; /* Whether this is an "interactive" input source; if so, and * if we're using stdio for input, then we want to use getc() * instead of fread(), to make sure we stop fetching input after * each newline. */ int yy_is_interactive; /* Whether we're considered to be at the beginning of a line. * If so, '^' rules will be active on the next match, otherwise * not. */ int yy_at_bol; int yy_bs_lineno; /* The line count. */ int yy_bs_column; /* The column count. */ /* Whether to try to fill the input buffer when we reach the * end of it. */ int yy_fill_buffer; int yy_buffer_status;&#125;; 可以发现这个结构储存了flex解析上下文。 如何实现迭代读取不同于bison，flex中的yylex函数默认只返回int，用来表示识别出的终结符号的类型。但是我们有时需要返回更多东西，例如终结符号本身，终结符号的位置和长度等。我们不能直接改变yylex的定义，因此可以用next_token封装yylex。假设要实现函数int next_token(std::string in_str, int start)，能够识别非终结符[start, end]，它的长度是内置变量yyleng，所在行是内置变量yylineno。首先必须要能够记录当前读取后的位置。flex是不自带这个变量的，所以必须在每个规则的识别之后自动记录此时的读取位置，方法就是定义一个全局变量pos，并在每次识别后增加yyleng。事实上我们希望next_token能够返回一个结构FlexState，这个结构能够包含识别出的终结符号本身（如+、-、变量名var_name、整数或浮点数0.5之类的），识别出终结符号的类型（META_INTEGER、META_FLOAT等），长度，行号以及位置。我们定义一个FlexState结构来组织这些信息。调用层次如下： next_token调用yylex yylex进行词法分析，如果满足某一模式(pattern)（也就是正则表达式），那么调用规则对应的处理语句（也称为动作(action)，正则表达式对应的大括号内部的C代码） 使用函数int make_term_flex在规则对应的处理语句内构造FlexState并返回。 next_token返回上步构造好的FlexState类型的全局变量flex_state特别地，如果还使用bison，因为bison直接调用yylex而不是自己设计的next_token获得词法分析的结果，所以处理语句必须返回用%token定义的YY_前缀的非终结符记号，由yacc的yyparse来返回你需要的YYSTYLE类型的值。鉴于这种情况，需要额外开一个flex_state的全局单例，在模式的处理语句中定义一个update_flex函数来更新flex_state。 关于bison的说明：bison提供了符号在代码串的定位功能，详见本文的bison部分。 yymoreyymore是一个flag，表明保留当前的结果yytext，等到读入下一个字符串时进行连接。例如当前读到的yytext是a，下一个字符是b，调用yymore以后下一次的读取yytext就会变成ab。调用yymore函数只会设置一个flag，并不立即读取下面的字符并进行拼接。注意区分yymore和没有return的处理语句的关系。首先flex在编译时直接将处理语句大括号内的部分复制到yylex函数中的某个位置，所以return实际上是return的yylex函数。没有return只是yylex函数继续运行，进行下一轮的扫描；但是yymore是设置一个flag，表明不要清空yytext，依旧可以return返回，虽然这样做没有意义。事实上处理语句不return是个相当有用的特性，有了这个并不需要yymore，只需要在全局记录一下本次的yytext到字符串s，在下一次查看yytext是否为空串，如果不是，返回s + yytext即可。而由于不返回了，所以在写处理语句于并不能利用函数来复用代码，而必须使用宏，同一个处理语句既可能return，有可能不return。下面给出一段代码和运行结果以供参考：123456789101112131415161718%&#123;#include &lt;stdio.h&gt;#include &lt;string&gt;%&#125;%option yymore%%"1" &#123; yymore(); ECHO; putchar('\n'); printf("yytext %s\n", yytext); &#125;"2" &#123; ECHO; putchar('\n'); &#125;\n &#123; putchar('\n'); &#125;%%int yywrap() &#123; return(1); &#125;int main() &#123; yylex(); puts("");&#125; 运行结果 111 // 输入 1 yytext 1 11 yytext 11 111 yytext 111 222 // 输入 2 2 2 233 // 输入 2 33 常常希望在bison中使用yymore去处理区分else和else if的情况，然而往往每次的yytext并没有和上次叠加，原因主要有两点：1. 规则中出现了return。2. 空格没有yymore，导致打断。 使用flex处理非正则的文法有一些特殊的词法，例如匹配的括号属于2类文法，flex所依赖正则表达式并不能正确处理这样的文法。而无论是手撸词法分析，或是直接放到语法分析阶段（可能造成归约冲突）并不是一个好办法。对于简单的情况，可以给flex“打洞”，拿出这些特例进行处理。例如可以在识别出某些开始符号后，从当前位置调用某个外部函数进行处理并返回外部函数处理的结果。这样的限制是不能处理比flex单元更小的词法单元，如果flex中有一条匹配[0-9A-Za-z_]的规则，那么要使用这种方法处理[0-9A-Za-z]的规则是不行的，需要配合yyless(n)来回退yylen - n个字符。并且最重要的一点是外部函数处理过的那一段字符串仍然会被flex程序处理，这当然可以通过yyrestart来强行解决，但是有下面更好的办法。根据StackOverflow上的一篇回答，可以通过start conditions这个功能处理这个问题。要使用start condition，首先要使用%s或者%x来声明，其中%s表示使用这个start condition时还可以同时接受普通规则；而%x，x表示exclusive，表示使用这个start condition时忽略所有的普通规则。现在使用%x format定义了名字是format的start condition，可以在规则前加上&lt;format&gt;来说明这个规则属于format condition，那么这条规则只有在使用BEGIN(format)开启format condition之后才能被匹配到。使用BEGIN(0)可以退出当前的condition，回归普通模式。下面给出一个样例：123456789101112131415161718192021222324252627%&#123;#include &lt;stdio.h&gt;#include &lt;string&gt;void do_format();%&#125;%option yymore%x format%%"format(" &#123; BEGIN(format); &#125;&lt;format&gt;[0-9]+ &#123; printf("format: %s\n", yytext); &#125;&lt;format&gt;")" &#123;BEGIN(0); &#125;[0-9]+ &#123; printf("normal: %s\n", yytext); &#125;%%void do_format() &#123; &#125;int yywrap() &#123; return(1); &#125;int main() &#123; yylex(); puts(""); system("pause");&#125; 输出结果是 111format(222)333 // 输入 normal: 111 format: 222 normal: 333 在实际处理fortran的format语句过程中，还遇到了Syntax Error的错误，产生在将整个format语句作为一个YY_FORMAT_STMT终结符return，后来发现这是因为我在word_parse函数中处理format前缀时调用get_flex_external_context().begin_external_scanner(&quot;format&quot;);来开启start condition之后并没有return YY_IGNORE_THIS所致，因为这个format前缀仍然是作为普通规则而不是start condition处理的。加上C++本身的“不是所有路径都返回值”导致的UB错误。 bison的定位功能bison提供了获取终结符行号和光标位置的功能。可以使用@n访问第n个文法符号的first_line、first_column、last_line、last_column属性，所以如果只需要这四个属性，可以不定义自己的struct，而使用bison提供的YYLTYPE。1234567typedef struct YYLTYPE&#123; int first_line; int first_column; int last_line; int last_column;&#125; YYLTYPE; 但是我仍然建议自己处理定位信息，这样的好处是在词法分析阶段就可以对源语言中与目标语言关键字冲突的符号进行转义，而不影响语法分析阶段对代码的定位。例如如果fortran中声明int变量，那会和C++中的int类型声明产生冲突，这个问题宜在词法阶段直接替换解决，但是这会带来长度的变化，因此需要单独维护原来文本的长度。 重命名yylex我们知道bison会调用yylex来获得tokenizer返回的结果，而yylex是有flex直接生成的。有时候我们不希望直接把yylex函数产生的原始结果喂给bison，而是进行加工。这时候我们可以自己定义yylex函数，而给flex自动生成的函数进行重命名 #define YY_DECL int pure_yylex(void) 此时我们就可以自定义yylex函数了，bison会调用我们自定义的yylex函数，而我们的yylex函数可以通过pure_yylex去调用flex进行分析。 特殊情况的处理 读入字符不属于任意规则 如果不加处理，这个字符会被保留，例如,www如果定义了[A-Za-z]规则但没有定义,www规则会直接返回,www,但是匹配长度还是3。虽然可以再次截取出正确的字符，但是显然这是没有必要的。因此可以在最后为任意字符.加上规则。 到达读入字符串尾端 此时yylex函数返回0，这是为了配合bison端的yyparse函数设置的 用正则表达式表达字符串 \&quot;(\\.|[^&quot;])*\&quot; 在flex的正则表达式语法中，方括号内部引号自动转义 yymore_used_but_not_detected 需要在l文件第一部分使用%token yymore显式说明需要yymore函数。 根据manual，可使用一些语法来指定大小写不敏感的规则，但是要求flex的版本要高于2.5.3，配置时，在项目属性页选择Flex Files-&gt;FlexOptions-&gt;Case-insensitive mode 找不到入口点(main函数) 注意要将flex生成的cpp文件添加进MSVC项目中 多条适配规则 当有多条规则的模式被匹配到时，yylex会选择匹配长度最长的那条规则，如果长度相等，则选择排在最前面的规则。 bison使用说明可以参考Bison的帮助文档或者Lex and YACC primer或者YACC文档 部分元素的意义 %left、%right、%token、%nonassoc %token用来声明一个终结符号的类型（META_INTEGER、META_FLOAT等），这个函数将被放到.tab.h文件中供flex程序引用，上文提到的yylex返回的int值，实际上就是在这里定义的。 此外，%left和%right用来描述运算符的优先级和结合性。考虑二义性文法：E : E + E| E - E| E * E| E / E| i，考虑1 + 2 * 3，解析完2之后直接归约或者进行移进产生了冲突。当然我们可以写成以下的无二义性文法避免+-和*/之间的移进归约冲突，当然这样带来了比较多的归约步骤， E : E + T| E - T| T T : T * F| T / F| F F : i 因此我们规定每个操作符的优先级，方法是较上行的%left（%right，%nonassoc）定义比较下行的%left（%right，%nonassoc）定义优先级要低，这样解决了不同操作符的优先级问题，而且相对于引入TF终结符，我们可以少定义一些非终结符和产生式（参加下例）。 但是对于1-2+3，分析程序仍然是不知道按照(1-2)+3还是1-(2+3)归约。因此对于同优先级的符号，用%left和%right来规定结合性。 %nonassoc表示当前操作符op是没有结合性的，也就是说不可能出现x op y op z的这种情况。 yylval，%type，YYSTYLE，%union 前面说到yylex返回值是一个int，这对于语法分析是足够的，但是对于之后的语义分析是不够的。例如对于属性文法E.val-&gt;T1.val + T2.val，我们还需要语法分析时候顺便把属性也提取出来，相比扩充状态栈，yacc提供了一个YYSTYPE类型的全局变量yylval。这个YYSTYPE的类型是个宏，可以自定义，相比flex的yylex函数只能返回int显得方便了很多。 同时，对于不同的属性，bison可以直接给出parse之后的类型。例如对于浮点123.4，yacc能够解析出123.4。这是因为bison通过%union来列出yylval返回值类型，通过%type规定对于什么非终结符返回什么类型。例如， 12345678%union&#123; int intval; double floatval; char word[20];&#125;%type &lt;intval&gt; YY_INTEGER%type &lt;floatval&gt; YY_FLOAT%type &lt;identname&gt; YY_WORD 这里%union实现上就是C++中的联合union。union不同于struct，它的所有成员时分复用存储空间，因此一个union的大小等于所有成员大小的最大值。和reinterpret_cast一样，union可以用来规避C/C++中的类型检查，实现强制转换，使用union相对使用void*避免了较多的reinterpret_cast。 %start %start用来标注开始符号，这是可选的 &lt;&lt;EOF&gt;&gt; 顾名思义，用来匹配文件结尾 bison的二义性问题解决方法bison的默认parser是LR parser，虽然LR文法是不能出现移进归约冲突和归约归约冲突的，但这不意味着bison的LR parser不能处理部分二义性问题。 悬挂if-else问题 bison在处理移进归约冲突的解决办法是默认移进。处理归约归约冲突的办法是默认使用先出现的产生式。因此bison中使用 stat：YY_IF exp YY_THEN stmt | YY_IF exp YY_THEN stmt ELSE stmt 是默认没有问题的当然也可以使用运算符优先级来解决这个问题 %nonassoc IFX %nonassoc ELSE stmt: YY_IF exp stmt %prec IFX | YY_IF exp stmt YY_ELSE stmt else if问题 可以考虑将else if合并成一个YY_ELSEIF终结符 部分语法的翻译方法换行符和空规则bison中的空规则类似下面的形式 nonterminal : non_empty {} | /* empty */ {} 空规则的意义在于必须要在处理语句内{}处理更新$$，不然$$是不确定的，可能是上一次的结果。注意如果没有显式指定处理语句，bison默认情况下把$1的值拷贝给$$。 在许多语言中，换行符用来分开两个语句stmt，而一个语句不一定占用一行，因为一个语句可以是一个表达式exp，也可以是一个复合语句，如if_stmt，do_stmt等。如果不能正确处理换行符，可能会出现各种各样的Syntax Error。比较好的做法是，定义一个suite stmt : /* 在结尾不要带上换行符 */ | /* stmt可以是空语句 */ suite : stmt end_of_stmt suite | stmt 这实际上类似于处理参数表的方法。注意往往还有一种写法是 stmt : exp end_of_stmt suite : stmt suite | stmt program : suite 这样写的坏处是容易出现list : item list这样的语句，这样的语句会给语法带来很大的不确定性，例如上面的产生式中suite是和stmt归约到新的suite还是直接归约到program是不确定的，并且在出现连续的空行的时候往往不能正确匹配。 控制结构可以参照这里提供的例程 终结符对于ascii码表中的字符终结符，如+，*等运算符，这些字符会在yylex以自身ascii码的形式返回（如果定义了相应规则或者.规则）。而一些非字符形式的终结符，例如C++中的生存空间符号::，则需要通过%token(%left，%right)定义。这也是为什么%token(%left，%right)生成的终结符对应的index从258开始的原因（避开ascii表）。当然也可以自己来定义终结符号的类型所对应的值，好处是，我们可以用值的大小表示优先级关系（虽然bison中可以用%left等语句来规定），可以用正负表示一个操作符或者一个操作数或者关键字。出于此，可以直接在%token YY_INT META_INTEGER给YY_INT赋值，而不是由Bison决定。特别注意不要重定义0，这是yylex和yyparse的结束记号。 自定义类型的yylvalyylval的类型是YYSTYPE，可以用它来保存bison中的非终结符，统一起见，flex程序中的终结符也可以封装成YYSTYPE类型。考虑到在解析过程中，bison程序通过直接调用int yylex()方法来从flex程序中获得终结符号，所以flex中程序获得的一些额外信息可以通过yylval向bison程序传递。在自定义类型YYSTYPE为non-trivial类型后，会出现不能自动扩栈等问题，应当谨慎使用。tldp文档提供了两种方案 #define YYSTYPE structXXX 可能出现错误缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int。，经查看，源码中有： 123/* for90.tab.h */// YYSTYPE is not defined, YYSTYPE_IS_DECLARED is not defined #if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLARED 解决方案是不在.y和.l文件中#define，而是在一个.y和.l文件共同#include的头文件中#define。 使用%union将struct包起来 使用这种方案不需要#define YYSTYPE，同样查看源码： 123456789/* for90.tab.h */#if ! defined YYSTYPE &amp;&amp; ! defined YYSTYPE_IS_DECLAREDtypedef union YYSTYPE&#123;/* Line 387 of yacc.c */#line 16 "for90.y" FlexState fs;/* Line 387 of yacc.c */#line 139 "for90.tab.cpp" 在以上步骤之后要确认这个union的定义是有的。 可能会出现如下问题：错误 C2280 “YYSTYPE::YYSTYPE(void)”: 尝试引用已删除的函数。对应代码为: 12345/* The semantic value of the lookahead symbol. */YYSTYPE yylval YY_INITIAL_VALUE(yyval_default);和 /* The semantic value stack. */YYSTYPE yyvsa[YYINITDEPTH]; 这两个函数/数组定义要求union实现构造函数和析构函数，但是这个是不行的。后来发现union中成员必须是trivial的，也就是包含构造函数/析构函数/拷贝构造函数/赋值运算符/虚函数的类成员，在union中都是不被允许的，所以改成union的成员改成对应的指针就可以了。 实现non-trivial的YYSTYPE根据Type-Generation，似乎可以通过%define api.value.type来解决这个问题，但是需要bison 3.0的版本，win_bison似乎并不支持如果使用的是win_bison的话，最好的方法是将YYSTYPE改成对应的指针形式。这可能会带来一些内存管理上的更改，之前的RAII似乎不能够使用了，此外shared_ptr和unique_ptr也不是trivial的（但是是standard layout） 左递归和右递归的选择对一些分析方法（如自上而下的不带回朔的递归下降法）来说，左递归不是省油的灯，例如LL1递归下降分析法直接要求消除左递归。例如LR(1)这样的移进-归约形式的分析方法允许左递归，左递归（产生式右部第一个符号时非终结符）是有弊有利的。右递归文法可能会占用比较大的栈空间，因为首先要将所有的项都压入堆栈里，然后再归约。大多数时候，左递归和右递归可以交换使用。例如处理else if的产生式可以写成：12elseif_stmt : YY_ELSE YY_IF exp YY_THEN stmt | YY_ELSE YY_IF exp YY_THEN stmt elseif_stmt 对于参数表更简单：1234567argtable : exp | argtable ',' exppure_paramtable : keyvalue | pure_paramtable ',' keyvalue | pure_paramtable ',' exp /* 注意这个规则不要丢掉 */ | argtable ',' keyvalue | 它的右递归形式1234567argtable : exp | exp ',' argtablepure_paramtable : keyvalue | keyvalue ',' pure_paramtable | exp ',' pure_paramtable | keyvalue ',' argtable | 这样的文法并不能处理11, a = 2 这样的文法，因为1不是keyvalue但是无论是左递归还是右递归，由于bison不支持EBNF，所以语法分析树总是往深度方向生长的，所以最好的做法是每一次处理item op list这样的规则时，将结果得到的树压平，注意压平操作要分左递归和右递归，否则顺序可能会有问题。不过拍平操作往往伴随着很大的性能损失，所以最好为自己的YYSTYPE写好复制构造函数。 bison常见错误及调试方法使用debug模式调试12#define YYDEBUG 1#define YYERROR_VERBOSE 注意yymsgp是const char*，所以如果重新定义yyerror参数要注意。12345678# define YYSYNTAX_ERROR yysyntax_error (&amp;yymsg_alloc, &amp;yymsg, \ yyssp, yytoken) &#123; /* 以上省略 */ yyerror (yymsgp); if (yysyntax_error_status == 2) goto yyexhaustedlab; &#125; 此外还可以在项目属性页选择Flex Files-&gt;FlexOption或对应的Bison标签页中开启DEBUG模式。 使用output文件分析语法冲突在bison生成的时候可以在输出中看到类似的语句：1231&gt; BisonTarget:1&gt; Process "for90.y" bison file1&gt; for90.y: conflicts: 132 shift/reduce, 33 reduce/reduce 这表明有132个移进归约冲突和33个归约归约冲突，这在二义性部分已经有相关的论述当出现冲突的时候可以使用bison -v xxx.y命令来查看具体的冲突。该命令会生成一个xxx.output文件在output文件中，所有因为冲突无用的产生式会被中括号[]括起，通过分析，可以解决一部分的冲突 m4sugar.m4win_bison: …\data/m4sugar/m4sugar.m4: cannot open: No such file or directory这个文件在和custom_build_rules文件夹同层的data文件夹中，所以注意是否将data文件夹加入路径 yylex identifier not found注意在y文件中第一部分extern yylex声明。 memory exhausted错误首先检查语法是否出现冲突，通常出现在语法嵌套比较深，从而出现间接的无限递归的情况。例如：123456789101112suite : stmt | stmt suite | program : YY_PROGRAM _optional_name crlf suite YY_END YY_PROGRAM _optional_name crlfwrapper : function_decl | program | suitefortran_program : wrapper | wrapper fortran_program 需要去掉wrapper的suite分支其次可以通过扩栈来解决，栈的大小可以通过#define YYMAXDEPTH来指定（默认10000），但是bison只有当确定对象是trivial的时候才会去扩栈： #ifndef YYSTACKEXPANDABLE # if (! defined __cplusplus \ || (defined YYSTYPE_IS_TRIVIAL &amp;&amp; YYSTYPE_IS_TRIVIAL)) # define YYSTACKEXPANDABLE 1 # else # define YYSTACKEXPANDABLE 0 # endif #endif 所以更好的方式是使用#define YYINITDEPTH来规定初始栈的大小（默认200） bison生成代码.tab.cpp分析有的时候会出现可能会导致Syntax Error，检查tab.cpp中的代码，发现123456789101112131415161718192021222324if (yychar &lt;= YYEOF) &#123; yychar = yytoken = YYEOF; YYDPRINTF ((stderr, "Now at end of input.\n")); &#125;else &#123; yytoken = YYTRANSLATE (yychar); YY_SYMBOL_PRINT ("Next token is", yytoken, &amp;yylval, &amp;yylloc); &#125;/* If the proper action on seeing token YYTOKEN is to reduce or to detect an error, take that action. */yyn += yytoken;if (yyn &lt; 0 || YYLAST &lt; yyn || yycheck[yyn] != yytoken) goto yydefault;yyn = yytable[yyn];if (yyn &lt;= 0) &#123; if (yytable_value_is_error (yyn)) goto yyerrlab; yyn = -yyn; goto yyreduce; &#125; 其中yycheck[yyn] != yytoken这个条件是不满足的。这个时候就需要查看bison对.y文件经过编译结果，也就是.tab.cpp文件。其中有一些数组对debug来说比较重要，要了解这些数组的用途，对于LALR(1)文法应当理解。 bison的GLR parser有的时候语法冲突是很难解决的，这时候与其去死扣语法，不如使用bison提供的GLR parser加上%define %glr-parser可以使用GLR parser。]]></content>
      <tags>
        <tag>编译原理</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语法分析实战]]></title>
    <url>%2F2016%2F07%2F22%2F%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[上下文无关文法(CFG, Context Free Grammar)属于二类文法，其能力等价于下推自动机(PDA)。相对于三类文法即正则文法，上下文无关文法能够对非终结符做状态转移。自上而下和自下而上是两种常用的上下文无关文法分析方法。自上而下的方法的难点在于选择哪个产生式进行推导，自下而上的分析方法难点在于在不同的格局下选择移进或归约的矛盾。 上下文无关文法C不是上下文无关语言，因为它们都要求标识符的声明先于引用，并且允许标识符任意长。由于这一点，描述这些语言语法的文法只是用id这样的记号来代表所有的标识符，而在这些语言的编译器中，由语义分析阶段检查标识符的声明必须先于引用。同样VB和Fortran也不是上下文无关语言，因为它们会同时出现数组A(i)和函数A(i)，这同样需要语义分析程序进行处理，在语法分析阶段可以把数组的slice和dimension部分看作一种特殊形式的参数表。事实上，很多需要用更强的文法分析方法的问题可以在语义阶段较轻松地解决。推导，从开始符号推导出和输入串相匹配的句子。最右推导称为规范推导，指每次选择句型最右边的非终结符。归约，用非终结符代替一段文法符号串。通常需要解决两个问题，一是何时进行归约，二是使用哪一个产生式进行归约。称自左向右的归约过程（最左归约）为规范归约。 自上而下的分析方法自顶向下分析方法相对来说比较符合人的思维（我们交谈时一个句子听到一点中能估计到大概的意思，而不是要把一句话听完才能恍然大悟），编译器写起来也方便。自上而下的分析方法分为非确定的和确定的两种，确定指的是根据当前的输入符号，选择用来推导产生式是唯一确定的；对应的，非确定的自顶向下分析可以在关于一个非终结符有多个候选产生式的时候进行回溯，效率较低。确定的分析方法对文法要求较高，例如文法中就不能出现左递归和左公因子。 递归下降法LL(1)预测分析法LL分析（以下出现的LL分析指代LL(1)分析），是一种确定的自顶向下分析技术，确定体现在在推导过程中可以完全按照当前的输入符号（或者再向前看k-1个符号）决定哪个产生式向下推导。一般手写LL分析是很方便的，这是因为在语法分析的同时可以借助于语义分析来避免潜在的语法冲突。而常常借助于程序生成解析器的LR方法并不容易在里面嵌入语义分析模块。FIRST集：FIRST集是对于一个句型α来讲的，得到一个终结符集合。句型是推导过程中生成的产生式，例如在S-&gt;A-&gt;aB-&gt;ab中，A、aB、ab都是句型，特别地，只含有终结符的句型称为句子。FIRST集表示一个句型所有可能的第一个非终结符。注意如果α可推导为ε，则ε也属于FIRST集。可以得到所有文法符号的FIRST(Xi)集的生成方法： 终结符的VT的FIRST集是自己，这是显然的 非终结符的FIRST集包含以下内容： ε 如果该非终结符有ε产生式。 或者该非终结符全部由非终结符组成的产生式，并且这些非终结符全部有ε产生式。例如X-&gt;Y1Y2...Yn，且所有的Yx都能推出ε。 终结符a 如果该非终结符有以a开头的产生式 所有非终结符的FIRST集，但是要除去所有的ε 如果该非终结符全部由非终结符组成的产生式，并且存在一个非终结符没有ε产生式。例如X-&gt;Y且Y能推导出ε，则加入FIRST(Y) - ε。又例如X-&gt;Y1Y2且其中Y1能推出ε而Y2不能推出ε，则加入(FIRST(Y1) - ε) ∪ FIRST(Y2)。这是显然的，因为X-&gt;Y1Y2不能推出ε，但如果写成FIRST(Y1) ∪ FIRST(Y2)，里面就包含了ε。 SELECT集：SELECT集是对于一个产生式A-&gt;α而言的，返回的是终结符的集合。表示在推导A且当前读取位置为a时，对于A的所有产生式A-&gt;α，如果SELECT(A-&gt;α)中含有终结符a，那么使用产生式A-&gt;α推导。显然有且仅有一个这样的产生式，当出错时没有（注意，SELECT(A-&gt;α)集合中可能有多个元素，但是对于相同的非终结符A，同一个终结符a只会在它的一个SELECT集中，即通过键值对&lt;A, a&gt;可以唯一确定一个产生式）。容易发现SELECT(A-&gt;α)有两部分组成，一部分是α不推导为ε时候，是FIRST(α)，一部分是α推导为ε时候，是FOLLOW(α)。 FOLLOW集：FOLLOW集是对于一个非终结符A来讲的。表示所有可能在A后面的非终结符。在计算时，{ # }和所有A-&gt;αBβ产生始终的FIRST(β)的非空元素都属于FOLLOW(B)。当然β可能推导为空，这样的情况下也将FOLLOW(A)加入FOLLOW(B)中。然后反复直到各个FOLLOW集合不再增大。 将非确定的文法转换成确定的LL(1)文法提取左公因子左公因子的存在会导致SELECT集相交，这是显然的。对于显式的左公因子，直接提出来即可，如 A -&gt; αβ|αγ 可以变为 A -&gt; αA&apos; A&apos;-&gt; β|γ 对于隐式的左公因子（即左边以非终结符开头的情况），可以使用关于该非终结符的所有右部以终结符开头的产生式展开，例如 A -&gt; ad A -&gt; Bc B -&gt; aA B -&gt; bB 展开得到 A -&gt; ad A -&gt; aAc // B =&gt; aA A -&gt; bBc // B =&gt; bB B -&gt; aA B -&gt; bB 消除左递归考虑下面的文法 A -&gt; Ab A -&gt; a 可以发现对于非终结符A，并不能确定用来推导的产生式，于是只能采用非确定的递归下降法，寻找最左非终结符，于是会陷入展开A的死循环A =&gt; Ab =&gt; Abb =&gt; Abbb通过改写文法消除左递归后，这就是一个确定的文法了 A -&gt; aB B -&gt; bB | ε 还要注意一点，有些人会将左递归和尾调用等同起来，但这是不同的两个概念 左递归是针对文法而言的。不消除左递归，不能使用确定的自上向下分析 尾调用是对于一个函数调用而言的。当一个函数的最后一个工作是调用自己的时候，这样的调用称为尾递归，例如计算阶乘的某些实现。当这个函数计算仅占用常量的栈空间的时候，特别是对于LISP这样的函数式语言，可以进行尾递归优化(Tail Call Optimization, TCO)，即可以不在调用栈上面添加一个新的栈帧，而是更新它，如同迭代一般。通过尾递归优化，可以将O(n)的栈帧使用变为O(1)，减少部分递归程序的开销 自下而上的分析方法首先需要介绍一下短语、直接短语和句柄的概念。首先这三个概念的范围是依次缩小的。短语指的是一个符号串，根据对定义的解释，一个句型的语法树中任一子树叶节点所组成的符号串γ都是该句型的短语。我们称γ为这个句型相对于A的短语，其中A为该子树对应的非终结符。直接短语相对于短语进一步要求选择的子树不应该含有其他子树，即它的孩子全部都是叶子。值得注意的是这并不意味着这些叶子都是终结符。不同于自上而下的分析，自下而上的分析方法总是等到句柄（最左直接短语）出现后进行归约。分析器在读取输入串的每一个符号时要选择对这个符号是移进还是归约、按那个产生式规约（LR0，SLR1，LR1，LALR1文法的差别体现于此）。但无论如何先要找到句柄，因此引入活前缀的概念。定义活前缀，S&#39;=&gt;αAw=&gt;αβw。假设这里w是终结符串，因此A是最右非终结符，这里是规范（最右）推导过程。如果符号串γ是αβ的前缀，那么γ是S的一个活前缀。根据定义，β是句型αβw相对于非终结符A的短语。γ是规范句型（也就是右句型，最右推导得到的句型）的前缀，而一旦栈中出现αβ，也就是形成了A的句柄，那么就可以按照A-&gt;β归约，因此，只要输入串的已扫描部分可以归约成一个活前缀，那就意味着已经扫描的部分没有错误。LR分析栈中的文法符号总是构成活前缀。LR分析器不需要扫描整个分析栈（状态栈和符号栈）就可以知道句柄是否出现在栈顶（而教科书中显示给出了栈是为了方便理解，在编译器实际处理过程中并不需要访问非栈顶元素），因为栈顶的状态符号包含了确定句柄所需要的一切信息。因此LR分析表的转移函数本质上等同于一个识别整个文法的活前缀和可归前缀的有限自动机。因此最直接的生成分析表的方法是构造一个NFA，其中所有产生式的每个项目都对应于NFA的一个状态，而规定拓展文法的开始符号的唯一产生式所对应的项目S&#39;-&gt;·E为初始状态。然后可以使用子集法把这个NFA确定化为一个DFA。但也可以不通过确定化NFA或正则文法构造分析表，这引入下面的方法。 LR(0)分析表的一般构造方法首先定义项目集规范族。定义项目集I是一组项目的集合，对应着DFA中的一个状态。定义构成识别一个文法活前缀的DFA项目集（状态）的全体称为这个文法的项目集规范族。项目集规范族包含一组项目集。闭包CLOSURE是针对一个项目集I而言的。闭包的求法： I属于闭包 对于闭包中的所有项目，如果圆点右边是非终结符，将该非终结符的所有产生式加入闭包。 如果圆点右边是终结符，那这是一个移进项目，不属于当前状态对应的项目集，不需要加入闭包。 如果圆点右边是什么都没有，那这是一个归约项目，不需要加入闭包。 定义GO(I, X)=CLOSURE(J)，其中I是包含某一项目集的状态，X为终结符或非终结符，J是I中任何型如A-&gt;αX·β的项目。即，如果状态I能够识别活前缀γ，那么状态J能识别活前缀γX。注意GO和GOTO表的意义是不一样的，GOTO(S, X)表示栈顶状态在S时读入文法符号（终结符或非终结符）为X的时候转换到的状态，而转换函数GO用来求出移动圆点之后的新的项目集。对于LR(0)，分析表（GOTO和ACTION）可以按以下方式构造： 终结符移进：如果项目A-&gt;α·aβ属于项目集Ik，并且GOTO(Ik, a)=Ik，当a未终结符时置ACTION(k, a)为S。 终结符归约：如果项目A-&gt;α·属于项目集Ik，则对于所有的终结符a（下面的SLR在这里改进，向前看a从而决定是否移进或如何归约）和#置ACTION(k, a)为rj，j是产生式A-&gt;α的符号。 非终结符移进：如果GO(Ik, A)=Ij，则GOTO(k, A)=j。 接收状态：如果项目S&#39;-&gt;S·属于项目集Ik，则置ACTION(k, #)为acc，也就是接受。 核心项目：所有圆点不在产生式右部左端的项目，初始项目除外。非核心项目相反。每个所需要的项目集都可以由取核心项目集的闭包形成。求项目集规范族的过程为： 对初态求闭包，得到一个完整的项目集（通过对核心项目求闭包始终可以得到所有的非核心项目） 对于得到的项目集中的每个项目，读入一个文法符号，向右移动圆点。读入不同的文法符号会通向不同的新状态/项目集（当然原项目集I中的两个项目在读取同一个文法符号X之后必然属于同一个状态/项目集，即使它们对应的产生式左部不相同，这是由于GO(I, X)是唯一确定的）。对于这些新状态，再求闭包，由此循环。 如果存在规范推导S =&gt; δAw =&gt; δα·βw那么项目[A-&gt;α·β, a]对活前缀δα是有效的。 SLR(1)分析对冲突的解决思想LR(0)文法相对于LL的预测分析法，将归约的时刻推迟到了读完句柄之后。这减少了冲突，但是因为在能归约的地方总是归约，所以仍存在冲突。考虑变量声明的问题吗，以C语言为例通常为t &lt;varname&gt; [,&lt;varname&gt;]，这里省略了赋初值，同时类型标识符作为一个终结符t出现，在上文中解释过这是因为受到上下文无关文法的限制。得到的文法为S&#39;-&gt;S S-&gt;tD D-&gt;D,i D-&gt;i，构造文法的项目集族，容易发现会产生移进归约冲突：S-&gt;tD· D-&gt;D,·i,，也就是说当遇到int i,j这样的情况，编译器现在读到j，已经形成了S-&gt;tD的句柄，可以归约了，但是这样的归约是错误的，因为后面的,j就会被丢掉了。显然解决的办法就是再往前看一个字符，如果是,，就继续移进，如果不是就归约。当然也可以引进分号，修改文法为S-&gt;tD;避免冲突。所以得到以下方案：设I={X-&gt;α·bβ A-&gt;γ· B-&gt;δ·}，则X和A、X和B有移进归约冲突，A和B有规约规约冲突。所以向前读一个输入符号a， 避免移进归约冲突：若a=b则按照产生式X移进 避免规约规约冲突：如果a=FOLLOW(A)则按A归约，如果a=FOLLOW(B)则按B归约。显然FOLLOW(A)和FOLLOW(B)必须不相交（当然不能和所有的移进终结符相交）。 可以发现其实这和LL(1)的预测分析法是类似的思路。只不过LL(1)向前读的是当前非终结符的第一个非终结符，但是SLR(1)读的是“下一个非终结符”的第一个非终结符。SLR(1)算法的分析表（ACTION和GOTO）的构造和LR(0)算法是相似的，不同之处在于读入终结符决定归约时，只对属于FOLLOW(A)的终结符添加ACTION表中记录。 LR(1)分析SLR(1)不能完全避免移进归约冲突。考虑以下的情况： S -&gt; α·aβ A -&gt; α· a∈FOLLOW(A) 显然按照S产生式面临输入符号a时应当移进，但是按照A产生式应当归约。这种情况的产生是因为a∈FOLLOW(A)说明存在有一种符号串Aa，但不是对于所有的符号串A后面都有a的。因为通常运气不会好到所有FOLLOW集都不会出现两个及以上数目的非终结符，于是我们惊讶前面的SLR(1)算法居然也能跑！其实并不是这样，SLR(1)要求表示移进的终结符不在表示归约的终结符集（也就是FOLLOW集）里面，对于上述文法，可以求得a∈FOLLOW(S)，但是根据S-&gt;α·aβ可以看到FOLLOW(S)和{ a }是有交集的，所以SLR(1)在前一步就以移进归约冲突报错了。还可以考虑以下C赋值语句文法的实际意义进一步加深理解： 赋值表达式 S -&gt; V=E|E 左值 V -&gt; *E|id 右值 E -&gt; V 按照SLR分析算法，现在考虑I2项目集S-&gt;V·=E E-&gt;V·，可以计算出=∈FOLLOW(E)，所以句型V=E既可以按照E-&gt;V归约，也可以按照S-&gt;V=E移进，冲突发生了。但是仔细琢磨，其实文法中的信息没有被完全表达出来。一个左值V完全可以出现在等号的右边，但是一个右值是不能出现在等号的左边的，如果按照E-&gt;V归约，那必定会推出V=V形成错误。虽然SLR(1)在前一步就以移进归约冲突报错了。所以解决的方案就非常显然了，既然FOLLOW集太过笼统，那就对每个项目单独给出后继符号，即搜索符。首先给出搜索符的定义：对于项目集A-&gt;α·Bβ B-&gt;·γ，如果使用生成式B-&gt;γ归约，则FIRST(β)即为搜索符。搜索符对β非空的项目[A-&gt;α·β, a]是不起作用的，但对形式为[A-&gt;α·, a]的项目，它表示只有在下一个输入符号是 a时，才能要求按A-&gt;α·归约。因此可以看做是FOLLOW集的对每个项目的特化，LR(1)文法的1同时也意味着搜索符是长度是1的终结符。如果存在规范推导S =&gt; δAw =&gt; δα·βw其中γ=δα且a是w的第一个符号或者w是ε、a是$，那么项目[A-&gt;α·β, a]对活前缀γ是有效的。LR(1)和SLR(1)的流程大致是相同的，首先也要计算CLOSURE函数。因为LR(1)项目集多了搜索符，因此CLOSURE函数需要一些修改。假设项目A-&gt;α·Bβ, a属于CLOSURE(I)，那么对于产生式B-&gt;γ，当β∈FIRST(βa)时，B-&gt;·γ, b也在CLOSURE中。LR(1)算法的分析表（ACTION和GOTO）的构造和LR(0)、SLR(1)算法是相似的，不同之处在于读入终结符决定归约时，只对属于搜索符（是一个终结符）添加ACTION表中记录。 LALR(1)对LR(1)的简化如果两个项目集除了搜索符其他都一样，那么这两个项目集为同心集。合并同心集后不会产生移进归约冲突，但可能仍会产生规约规约冲突。 冲突的解决思想总结我们希望我们的文法分析过程是确定性的。这也就是说，对于LL分析，我们希望当推导时碰到某个非终结符的产生式有多个候选的时候，我们能够唯一确定一个候选进行推导；对于LR分析，我们希望能够唯一确定任何一时刻下的分析器的动作应该是移进还是归约（为了避免移进归约冲突，例如C语言的悬空else情况if(..)if(..)else中，在else位置是移进外层的if，还是归约内层的if，当然这个二义文法已经不算是LR文法了）、按照哪个产生式归约（为了避免规约规约冲突，例如前面所说的VB6语言A(i)可能是一个数组元素，也可能是一个函数调用，特别地，(1+2)和func_name(1+2)也可能导致规约规约冲突）。 因此可以发现事实上LR所能描述的文法是LL(1)预测分析法的真超集。回顾LL(1)预测分析法的流程，LL(1)预测分析法由一个栈S和一个预测分析表M组成。M[A,a]表示推导A时当遇到输入符a时，应当选择的A的产生式，这应当是唯一确定的。也就是说，对于任意的产生式A-&gt;α，如果a在SELECT(A-&gt;α)集合中，那就必须要选择产生式A-&gt;α，如果对于A的所有产生式，它们的SELECT集都不出现a，那就报错。因此，这就意味着选择A的哪一个产生式完全取决于a。例如考虑应用产生式A-&gt;lβ如下推导S=&gt;αAbw=&gt;rlβbw（其中α为符号串，A为最右非终结符，w为终结符串），LL(1)预测分析法需要在看到l时就作出决定选择产生式A-&gt;lβ，但是LR分析法可以在看到b之后再决定是否把lβ规约为A，因此LR实际上获得了更多的信息。同时LL(1)文法还是不能够出现左公因子和左递归的：对于前者可以发现同一个非终结符的所有SELECT集合是存在交集的；对于第二种情况，直接左递归A-&gt;Aβ或者间接左递归可以推出它们的SELECT集也是相交的。有的时候，虽然文法是二义性的，但是语言却可以不是二义性的，这可以通过语义分析解决。 通过重写文法解决二义性stmt: if expr then stmt else stmt | if expr then stmt | other 可以提取公因子，重写为： stmt: if expr then stmt optional_else | other optional_else: else stmt | other 一般来说，对于文法 A -&gt; αη B -&gt; βη 提供一个将η归约为非终结符C的产生式 A -&gt; αC B -&gt; βC C -&gt; η 但是这样的坏处是会引入终结符C，并且这个C可能没有明确的语义作用。 通过设置终结符优先级解决二义性考虑通常的表达式文法， E-&gt;E + E| E * E | (E)| id 对于1 + 2 * 3，能产生两种语法树，产生移进归约冲突，原因在于面临+的时候可以按照E-&gt;E + E归约，也可以按照E-&gt;E * E移进，于是规定*的优先级高于+，所以选择移进。对于1 + 2 + 3，同样能产生移进归约冲突，因此规定+是左结合的，因此对于项目id + id · + id，应当归约，而不是移进。此外，这个文法同样可以通过重写文法来消除二义性，例如E-&gt;E+T|T T-&gt;T*F|F F-&gt;(E)|id，这样的文法产生式的右边会出现单非终结符的产生式，增加了归约的次数。这种方法常用来解决移进归约冲突 通过设置产生式优先级解决二义性考虑排版文法： E -&gt; E ^ E _ E E -&gt; E ^ E E -&gt; E _ E E -&gt; {E} E -&gt; c 其中^表示上标，_表示下标。从定义形式语言的角度来讲，第一个产生式是多余规则，因为用2和3产生式能够得到1产生式可推导出的句子。但是从语义的角度来说它作为一个优先归约的特殊规则存在。例如我们考虑会产生的以下三个排版：ai2 a2i ai2它们的效果（语义）是不一样的，因此单独将第一个产生式列出来，优先级最高，当满足第一个产生式时，不使用后两个产生式进行归约。同样的方法可以用在处理A(args)和(exp)的冲突上面。这种方法常被用来解决归约归约冲突。 使用GLR文法解决二义性有时候冲突是无法避免的，这时候可以选择使用GLR文法分析器，相对于LALR分析，GLR会BFS所有可能的操作。GLR的最坏时间复杂度是O(n3)的，具体取决于冲突的数量 语义分析上的两种分析方法语法树语法树（推导树）的特点是非叶子节点都是非终结符，叶子节点都是终结符。因此从左到右遍历（也就是DFS）语法树即可生成代码。特别地，单趟编译器（one-pass compiler）不先建立语法树后编译。这样的编译器由语法分析带动整个编译流程，在语法分析的同时计算属性值，这样的做法称为语法指导翻译。TCC(Tiny C Compiler)就是这样的一个编译器。属性文法对遵循语法制导语义(syntax-directed semantic)原理的语言最有用，它表明程序的语义内容与它的语法密切相关。 综合属性和继承属性考虑一棵语法树，综合属性总是自下而上传递的，例如2.4+3*4，在语法树的根节点+，得到了结果14.4，注意到类型从int上升到double体现了自下而上的过程。继承属性是在语法树水平或者从上往下传递的，例如C语言中的变量初始化语句int i = 0, j = 0;，容易得到属性文法： T -&gt; int| real T.type = int| real L -&gt; L1, id| id L1.in = L.in; do_symbol_table; D -&gt; TL L.in = T.type 可以发现，属性先从T横向向右传递给L，然后由L向下传给L1。在产生式上来看，综合属性属于产生式的左部非终结符，从产生式右部的文法符号的属性得到（自下而上），继承属性属于产生式右部的文法符号，从产生式左部（自上而下）或者产生式右部该文法符号之前的文法符号（横向）的属性得到。 L属性文法的自顶向下和自下而上分析自顶而下的L属性文法会导致翻译模式，也就是需要在产生式的右部文法符号中间嵌入语义计算动作（yacc中使用花括号{}括起来，里面可以写C++的代码，详情可以参考我的另一篇文章：flex和bison使用）。考虑常见的if..elseif..else..endif文法。 if_stmt : YY_IF exp YY_THEN stmt endif_stmt | YY_IF exp YY_THEN stmt else_stmt | YY_IF exp YY_THEN stmt elseif_stmt elseif_stmt : YY_ELSE YY_IF exp YY_THEN stmt | YY_ELSE YY_IF exp YY_THEN stmt elseif_stmt | YY_ELSE YY_IF exp YY_THEN stmt endif_stmt else_stmt : YY_ELSE stmt endif_stmt endif_stmt : YY_END YY_IF]]></content>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树和树状数组]]></title>
    <url>%2F2016%2F07%2F13%2F%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%92%8C%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[线段树和树状数组是一系列神奇的数据结构的起源，但其本身却十分简洁优雅，是我非常喜欢的两种数据结构。 树状数组(binary indexed tree)考虑求和$A[n]=a[1..n]$，平凡的解法复杂度为$O(n)$，树状数组则是$O(log \, n)$的方法。理解树状数组，可以考虑任何一个自然数$x$可以表示成：$ x = a_0 2^0 + a_1 2^1 + … + a_n 2^n $，其中$a_i$可以取0或1。我们看到这样的以2为底的“科学计数法”能够将加法的计算量减少到$log_{2}n$。同样我们希望把对一个序列的求和计算也降为对数级的，容易想到可以缓存一些连续$2^n$个数的和作为子结构，例如我们可以算出下面的这张表，即T数组： 十进制 二进制 区域和T[i]即a[i..j]的和 1 1b $a[1]$ 2 10b $a[1..2]$ 3 11b $a[3]$ 4 100b $a[1..4]$ 5 101b $a[5]$ 6 110b $a[5..6]$ 7 111b $a[7]$ 8 1000b $a[1..8]$ 9 1001b $a[9]$ 10 1010b $a[9..10]$ 11 1011b $a[11]$ 12 1100b $a[9..12]$ 13 1101b $a[13]$ 14 1110b $a[13..14]$ 15 1111b $a[15]$ 16 10000b $a[1..16]$ 17 10001b $a[17]$ 18 10010b $a[17..18]$ 19 10011b $a[19]$ 下面我们尝试利用上面的表计算$A[13]$，首先把13分解成2的幂的代数和，即$13 = 8 + 4 + 1$。查表，我们发现$A[13] = T[8] + T[12] + T[13]$。而$T[8]$、$T[12]$、$T[13]$区间的长度分别对应了8、4、1。下面是个直观的图。 这张表是如何得出的呢？定义$T[i]$为区间$a[i-lowbit(i)+1 .. i]$共$lowbit(i) = 2^k$个元素的和，也就是说$i$最多能被2的几次幂整除，就从$i$开始往前数几个。下面用程序来描述查表的过程。我们要从“边长”小的方块往大的方块加，即$13 \rightarrow 9..12 \rightarrow 1..8$，即123for (int x = i; x &gt; 0; x -= lowbit(x))&#123; ...&#125; 树状数组不仅能快速查找，还能快速更新。更新位置$i$处的值时，我们按照以下规则更新： 只更新$i$位置后的节点，因为根据定义，$i$前的节点不可能包含$i$。 只更新“边长”为1（即自己）、2、…、$2^n$等2的幂次的节点，有些“边长”可能碰不到，其实这就取决于$i$在2进制表示中1出现的位置了。例如更新了$a[3]$，就要同时更新4、8、16这些位置；更新了$a[7]$就要同时更新8、16、32这些幂次；更新$a[11]$就要更新12、16这些节点1234for (int x = i; x &lt;= maxn; x += lowbit(x))&#123; // 注意是maxn不是a的实际个数n ...&#125; 最后推荐另外一个教程 二维树状数组二维树状数组中比较常见的题型是矩形区域最值/和问题。如刚遇到的hiho1336 线段树(segment tree)基础线段树一个基础的线段树支持单点修改和区间查询 PushDown和PushUp将线段树的各个操作提炼出得到一个模板，这样用户只需要PushUp这个操作和Update的一个终止条件。其中PushUp在Update和Build函数中使用，用来合并两个子区间的性质。 线段树数组的大小MAXN应当至少为4N假设对$[1..N]$建立线段树，其中$2^n &lt;= N &lt;= 2^{n+1}$。容易得到树的底层至少需要$2^{n+1}$个节点，因此整个树需要$2^{n+2}$个节点，也就是必须满足$MAXN \ge 2^{n+2}$ 。把$n$用$N$代替，得到$4N &gt;= 2^{n+2}$，显然对于任意$MAXN \ge 4N$，有$MAXN \ge 2^{n+2}$。 线段树查询1. 为什么需要$fr$，$to$，$l$，$r$四个变量？ 线段树的查询开销在$O(lgn)$。假设我们要求$[fr .. to]$之间的值，我们实际上是找寻若干长度为$2^i$的若干子树，它们的并集能够恰好覆盖$[fr .. to]$区间。由于线段树的结构是二分的，$[l .. r]$表示线段树中我们搜索到的当前节点所表示的区间。我们根据$l$、$r$与$fr$、$to$的关系可以判断出全取$[l, r]$结果，全不取$[l, r]$结果还是继续二分搜索。 2. 开闭区间的问题 首先要注意优先级，`&lt;&lt;`的优先级低于`+`，所以应当写成`(root &lt;&lt; 1) + 1`这样。 3. Modify操作只需要更新（被影响的）一侧 线段树的区间更新可以对线段树进行区间更新，为了保证$log n$的复杂度，显然对每个叶子节点的更新是不可能的了，因此我们使用一个lazy[]辅助数组。当我们的update函数遍历到满足fr &lt;= l &amp;&amp; r &lt;= to时，我们就停止进行update，而设置lazy[root] = tree[root]，其中tree是我们维护的线段树。与此同时我们引入PushDown这个操作。PushDown在Update和Query函数中使用，负责将本层的lazy更新信息传递给下一层。12345678910111213141516void PushDown(int root, int ln, int rn)&#123; // 当具有lazy标记时 if(lazy[root] != -1) &#123; // 注意更新时仍然需要维护区间性质，而不能简单赋值为lazy[root] // 下面的代码维护了区间内最大值的性质 tree[root &lt;&lt; 1] = max(lazy[root], tree[root &lt;&lt; 1]); tree[root &lt;&lt; 1 | 1] = max(lazy[root], tree[root &lt;&lt; 1]); lazy[root &lt;&lt; 1] = max(lazy[root], lazy[root &lt;&lt; 1]); lazy[root &lt;&lt; 1 | 1] = max(lazy[root], lazy[root &lt;&lt; 1 | 1]); // 取消lazy标记 lazy[root] = -1; &#125; return;&#125; 二维线段树下面用二维线段树来解决刚才的问题。这道题目需要写三个update，原因是在使用update2更新完rx行以0为根的所有列构成的子树后，需要更新第i列中以rx行为根构成的子树。如果不更新，那么将来对于任意的第i列，当x为非叶子节点时，tree[x][i]的值都为0。如果暴力一波肯定会T。1234for (int i = 0; i &lt; 4 * n; i++)&#123; tree[rx][i] = tree[rx * 2 + 1][i] + tree[rx * 2 + 2][i];&#125; 所以需要用一个和update2类似的update3来更新代码 zkw线段树普通的递归版本的线段树的常数是比较大的，但有些题目可以考虑使用zkw线段树。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>线段树</tag>
        <tag>树状数组</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT解题报告]]></title>
    <url>%2F2016%2F07%2F06%2FPAT%2F</url>
    <content type="text"><![CDATA[浙江大学PAT(Programming Ability Test) A-level、top-level以及CCCC练习题的部分解题报告。源码在 https://github.com/CalvinNeo/PAT [YN\d]\t(\d+-)+\t([\w ]+)(\d+).* 1001 A+B Format注意判断-999,999的情况 1002 A+B for Polynomials1003 Emergency1004 Counting Leaves1005 Spell It Right比较简单，注意POSIX没有itoa，得用sprintf。特别地，对于二进制数字，可以借助于bitset来输出accumulate第三个size_t参数最好直接设为0，在函数外加上初值。 1006 Sign In and Sign Out1007 Maximum Subsequence Sum思路:1234567891011121314151617if(maxsumto[i-1]+n[i] &lt; n[i])&#123; // re-count maxsumto here maxsumto[i] = n[i]; start[i] = i; if (maxv &lt; maxsumto[i]) &#123; maxv = maxsumto[i]; maxid = start[i]; &#125;&#125;else&#123; maxsumto[i] += n[i]; start[i] = start[i - 1]; if (maxv &lt; maxsumto[i]) &#123; maxv = maxsumto[i]; maxid = start[i]; &#125;&#125; 有一个bug，为了方便计算，输入数据从n[1..k]，定义n[0] = start[0] = 0; 考虑1 -1 1 -1 1 -1 1 -1 1 -1这样的序列，得到结果为1 0 1，但是实际的结果应当是1 1 1。因此start[0] = 1。 HHU1 1003注意LL应当用printf(&quot;%lld&quot;)或者printf(&quot;%I64d&quot;)输出，但是double应当用printf(&quot;%f&quot;)输出。此外，要注意输入3 1 1 4的输出是4而不是1。 HHU2 1001二叉查找树的中序遍历非递归实现使用一个栈，栈中的节点都已经遍历过左子树。比较容易的做法是再开一个vis数组用来记录这N个节点是否全部被遍历过。 HHU2 1002(POJ2823)线段树的大小MAXN应当至少为4N HHU4(HDU5524)这一题问一个$N$节点的完全二叉树一共有多少个节点数不同的子树。这一题的关键在于完全二叉树的性质 二叉树始终有叶子，但是叶子节点只能出现在最下层或者次下层。最下层的叶子应当集中在左侧。 完全二叉树左右子树中至少有一个满二叉树，这个满二叉树的节点个数可以直接由其深度算得，另外一半的非满二叉树继续递归，最终一定能得到一个满二叉树 $N$节点的完全二叉树深度为$ \lfloor log(N) \rfloor +1 $，上$\lfloor log(N) \rfloor$层一定是满二叉树。对于满二叉树，第$i$层有$2_{i-1}$个节点，前$i$层有$2_{i} - 1$个节点。 完全二叉树的数组表示形式是连续的，当index从0开始时，$[0, len/2 - 1]$区间内的节点有孩子，其中$len/2 - 1$是最后一个元素的父节点 注意分清二叉查找树和二叉堆的区别。二叉查找树需要左孩子小于根小于右孩子。而二叉堆是一棵完全二叉树，要求满足递归的堆序性，即根小于等于或大于等于所有的孩子。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>PAT</tag>
        <tag>CCCC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSCPC总结]]></title>
    <url>%2F2016%2F05%2F09%2FJSCPC2016%2F</url>
    <content type="text"><![CDATA[五月八日在南京大学参加了第一届江苏省程序设计大赛。这次破天荒拿了7A。 首先是热身赛，第一条是最基本的dp，第二条是一个pq，第三条是带两个cost的dijkstra。进入正赛，一般这种比赛都是AJ水题。我先切的A，A是摩尔斯电码的翻译，是一条手速题，我看完的时候学弟已经看完B题了。B题是给出二叉树后序遍历的第k项。学弟用了二分，不过讲题的时候说因为数据故意改弱了，所以可以直接建树暴力做。B题WA了下，等到做完我断断续续把A题敲完了，1A过。后来发现I是个水题，就是dijkstra，另外建一个map把站点映射成index就行了，正好可以用刚才热身赛的dijkstra，我写了个框架给zqh填dijkstra，不过这道本以为1A的题目居然卡了很久，最后还是学弟调出来的。中间看了J题，之前学弟第一个切了J，觉得J没见过难，我一看是个人肉pattern recognition：给一段话，要你分析出是English还是Spanish还是Chinese Pingyin。这个主要思路一个是特征词，比如西班牙语特有el，y，e，o，por这种词，另外就是长度判别，中文一定是长度小于6的，因为句子都是选自维基百科等的实际文献，而且长度都大于100个词，所以不要担心会产生误判。不过在写代码的时候WA了两次，有个坑，std::string的find会默认对pattern做trim，而trim之后，“y”也会同样匹配“sky”这样的英文单词了，所以得手写一个find，这里直接对find之后的index首尾直接验证有没有空格。J是倒数第二个A的，之前学弟有A了C和F。这时候zqh在推G题，G题是个类似博弈的题目，但实际上是推一个公式。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winsock/boost::asio笔记]]></title>
    <url>%2F2016%2F04%2F15%2Fwinsock%2F</url>
    <content type="text"><![CDATA[WinSock/boost::asio 编程遇到的一些问题 未归类的配置问题 fatal error C1189: #error: WinSock.h has already been included这个是windows SDK + boost的一个历史问题，解决方案是在最前面#include &lt;WinSock2.h&gt; error LNK2019: 无法解析的外部符号 “void __cdecl func_name(void)” (?func_name@@YAXXZ)，该符号在函数 _wmain 中被引用这种错误一般是因为在头文件里面声明了某个函数，但是却没有实现它。但是仔细检查发现并不是这个问题。使用#pragma messagelog一下发现也不是头文件包含上面出现了问题。后来发现这个函数所声明的h文件曾经被rename过，于是重新添加该文件到工程中，问题就被解决了。事实上很多时候经常出现类似某个符号无法找到或者重复声明的错误，clean build都没有用，这时候常常可以重新添加代码文件即可。]]></content>
      <tags>
        <tag>网络</tag>
        <tag>winsock</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python中的重要科学计算库numpy]]></title>
    <url>%2F2016%2F03%2F06%2Fnumpy%2F</url>
    <content type="text"><![CDATA[本文主要包括numpy，matplotlib以及python在用法上的一些套路和坑。 ndarray复制问题np.array(arr)和np.copy(arr)都可以复制numpy数组，感谢来自评论区的指正。1234arr = np.array([1,2,3,4,5])arr2 = np.array(arr)arr[2] = 999print arr2 以上代码输出：[ 1 2 3 4 5] ndarray去重以下代码可以去除重复的行1234a = rest_points.copy()b = np.ascontiguousarray(a).view(np.dtype((np.void, a.dtype.itemsize * a.shape[1])))_, idx = np.unique(b, return_index=True)rest_points = a[idx] 其中部分函数用法如下： np.ascontiguosarray 12345ref: numpy\core\numeric.pydef asarray(a): return array(a, dtype, copy=False, order=order)def ascontiguousarray(a): return array(a, dtype, copy=False, order='C', ndmin=1) 可见np.ascontiguousarray默认以C模式（而不是Fortran）模式输出数组，ndmin=1是为了保证C模式不出错（数组至少有一维）。 np.ndarray.view 表示用不同的type看这个数组 np.dtype 这是个比较奇特的函数，我还没有搞透彻，这里的意思是把那一行的数组转成二进制来表示，这样就成了一个对应着原来数组行数的一维数组，其中数组每一行的那个数是原数组对应行所有列的二进制表示。 np.unique 这就是找出筛出数组中的唯一项了。 最小二乘法使用from scipy.optimize import leastsq可以做最小二乘法，但是有一点要非常注意：一般我们拟合时，平面方程一般选取1z = -(a*x + b*y + d) 这样的形式。这样去表示一个数组，是可以满足大多数的需要的，但是当我们考虑拟合平面Ax + By + D = 0时，由于固定了C = 1，所以会导致A, B参数数量级过大，而被误认为产生了过拟合现象。 any()和all()用来返回在指定轴上是否存在/对于任意的点都是True ndarray的运算符/内置函数的适配以下函数可以直接适用ndarray： len 一般返回ndarray的行数 zip 同list直接的zip 向量化语句向量化是函数式编程中的一个默认的特性，向量化风格的写法天生直观，并且便于优化以及实现并行计算。]]></content>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GCC和MSVC在pow函数实现和类型转换比较]]></title>
    <url>%2F2016%2F01%2F16%2FC-GCC-VS-pow%2F</url>
    <content type="text"><![CDATA[ACM中常常遇到卡精度的问题，卡精度可能因为取整、比较相等、高精度等多种原因。这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。 问题描述江科大的nomasp同学在刷Leetcode(171:Excel Colmun Number)的时候发现了一个问题。他的代码（简化后）如下：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int solve(string s) &#123; int n = 0, len = s.length(); for(int i = 0; i &lt; len; ++ i) &#123; int c = s[i] - 'A' + 1; n += c * pow(26, len - 1 - i); cout&lt;&lt;"c = " &lt;&lt; c &lt;&lt; endl; cout&lt;&lt;"pow = " &lt;&lt; pow(26, len - 1 - i) &lt;&lt; endl; cout&lt;&lt;"n = " &lt;&lt; n &lt;&lt; endl; cout&lt;&lt;endl; &#125; return n;&#125;int main() &#123; cout&lt;&lt;solve("AAB"); return 0;&#125; 使用Mingw32 GCC/G++(4.7.2)编译(g++.exe cpp_path -o exepath -std=c++11 -g3 -static-libstdc++ -static-libgcc -g3)后，输出如下：使用MSVC140(VS2015)编译后，输出如下：稍有常识的人都会看出，GCC的结果是错误的。 问题分析有同学认为pow函数是个浮点函数，因此应当转成int之后再相加减，但实际试验之后发现这个问题仍然存在，结果是：经过分析，如果手动实现pow函数则GCC的结果是对的。因此定位到调用pow函数这边出了问题。因此取一下测试代码分析。12345678910#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;int main() &#123; float f = pow(26, 2); int i = f; int i2 = pow(26, 2); printf("%f %d %d\n", f, i, i2); //似乎这个版本的GCC不支持%lf return 0;&#125; 在GCC下编译运行得：在VS2015下编译运行得：可以发现对GCC，当使用float变量直接初始化int时发生窄化，不过不影响结果。但是将这个float变量换成pow函数后就会影响结果。谦谦同学指出在GCC520版本下源代码也能正常运行。他进而提出pow函数返回的是double，在转成int的时候需要先转成float再转成int。根据这个意见，我测试了下面的代码，如果说会先转换成float，那么yy的值应当为55，因为从double到float的过程中精度丢失了。12345678910int main()&#123; float x = 54.999999999999993; int y = (int) x; double xx = 54.999999999999993; int yy = (int) xx; long double xxx = 54.999999999999993; int yyy = (int) xxx; printf("%d %d %d\n", y, yy, yyy); return 0;&#125; 不过结果是55 54 54，看来从double到int并不会经过float。不过在他的提示下，我把pow函数改成powf函数，发现返回值正常了。既然如此，我又测试了下面的代码123456789#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;int main() &#123; double f = pow(26, 2); int i = f; printf("%f %d\n", f, i); return 0;&#125; 按照上面的理论，这里应该输出675，但结果却是正确的676。因此现在的差别实际上就来自pow函数，我倾向于是一个RVO问题。为了进一步研究原因，需要比较对pow函数的实现以及类型转换机制。 MSVC对pow的实现MSVC中我们实际上使用的是double pow&lt;int, int&gt;(int _Left, int _Right); 这个重载版本。首先定位到头文件xtgmath.h：123456789101112//xtgmath.h_C_STD_BEGIN// #define _STD ::std::// #define _CSTD ::template&lt;class _Ty1, class _Ty2&gt; inline typename _STD enable_if&lt; _STD is_arithmetic&lt;_Ty1&gt;::value &amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value ,typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;::type pow(const _Ty1 _Left, const _Ty2 _Right) &#123; // bring mixed types to a common type typedef typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type; return (_CSTD pow(type(_Left), type(_Right))); &#125; 可以看到最后调用一个参数是_Common_float_type的pow函数，那这个函数在哪里呢，我们首先来看一下_Common_float_type这个类型。123456789101112131415161718192021//xtr1common.h typedef integral_constant&lt;bool, false&gt; false_type;// integral_constant is convenient template for integral constant types//xtgmath.h template&lt;class _Ty&gt; struct _Promote_to_float &#123; // promote integral to double typedef typename conditional&lt;is_integral&lt;_Ty&gt;::value, double, _Ty&gt;::type type; &#125;; template&lt;class _Ty1, class _Ty2&gt; struct _Common_float_type &#123; // find type for two-argument math function typedef typename _Promote_to_float&lt;_Ty1&gt;::type _Ty1f; typedef typename _Promote_to_float&lt;_Ty2&gt;::type _Ty2f; typedef typename conditional&lt;is_same&lt;_Ty1f, long double&gt;::value || is_same&lt;_Ty2f, long double&gt;::value, long double, typename conditional&lt;is_same&lt;_Ty1f, double&gt;::value || is_same&lt;_Ty2f, double&gt;::value, double, float&gt;::type&gt;::type type; &#125;; 这边说明一下这段代码：std::is_integral用来判断一个类型是否是整数std::conditional有三个参数，其作用相当于_Test? _Ty1: _Ty2，其中_Ty1和_Ty2都是类型，而std::enable_if相对std::conditional省略了假的情况。std::is_same用来判断_Ty1和_Ty2是否相同类型。这个是模板编程里面常用到的元函数。_Promote_to_float用来将integral（整数）类型扩成double类型，如果是浮点数则不变。说到扩展，也挺有意思的，例如char在被爆之后是直接变成int，还有符号扩展和0扩展啥的，可以查看CSAPP P49页。_Common_float_type意思就是123456if (_Ty1 is long double || _Ty2 is long double) typedef type long doubleelse if(_Ty1 is double || _Ty2 is double) typedef type doubleelse typedef type float 用来给浮点数之间运算结果选择适合的精度 下面我们开启调试，跟踪pow函数执行。在调试中，在断点_CSTD pow(type(_Left), type(_Right))处发现type(_Left)和type(_Right)都已经通过_Common_float_type变成了double，继续跟踪发现直接调用了math.h中的pow。特别地，对于c mode，pow实际直接调用了pow(double, double)。此外还注意到&lt;cmath&gt;中有一个的_Check_return_ inline double pow(_In_ double _Xx, _In_ int _Yx)函数，而这个函数实际上调用了&lt;cmath&gt;中的_Pow_int函数，该函数如下： 1234567891011121314151617template&lt;class _Ty&gt; _Check_return_ inline _Ty _Pow_int(_Ty _Xx, int _Yx) _NOEXCEPT &#123; unsigned int _Nx; if (_Yx &gt;= 0) _Nx = static_cast&lt;unsigned int&gt;(_Yx); else _Nx = static_cast&lt;unsigned int&gt;(-_Yx); for (_Ty _Zx = static_cast&lt;_Ty&gt;(1); ; _Xx *= _Xx) &#123; if ((_Nx &amp; 1) != 0) _Zx *= _Xx; if ((_Nx &gt;&gt;= 1) == 0) return (_Yx &lt; 0 ? static_cast&lt;_Ty&gt;(1) / _Zx : _Zx); &#125; &#125; 这段代码主要就是处理指数为int的情况，其使用的是类似于快速幂的方法得到的结果。不过经过测试，这段代码始终没有被调用的情况，为什么标准库不使用这个重载版本，我想附录里面的一段答案应该能够给我们启发。对于以上代码，我想最重要的就是_Common_float_type，它避免了GCC472版本的类型二次转换的错误，直接调用对应类型的重载版本。 MSVC对类型转换的实现为了分析_pow函数，需要先了解一下MSVC对于类型转换的实现方案 double -&gt; int123456789101112131415161718192021222324; int i = pow(26, 2);00E7277E push 2 00E72780 push 1Ah 00E72782 call pow&lt;int,int&gt; (0E71064h) 00E72787 add esp,8 00E7278A call __ftol2_sse (0E71195h) 00E7278F mov dword ptr [i],eax ; int i = pow(26.0, 2.0);00FE277E sub esp,8 00FE2781 movsd xmm0,mmword ptr ds:[0FEAB98h] 00FE2789 movsd mmword ptr [esp],xmm0 00FE278E sub esp,8 00FE2791 movsd xmm0,mmword ptr ds:[0FEABD0h] 00FE2799 movsd mmword ptr [esp],xmm0 00FE279E call _pow (0FE11FEh) 00FE27A3 add esp,10h 00FE27A6 call __ftol2_sse (0FE1195h) 00FE27AB mov dword ptr [i],eax ; double s = 26.0;00D8277E movsd xmm0,mmword ptr ds:[0D8AB98h] 00D82786 movsd mmword ptr [s],xmm0 ; int i = s;00D8278B cvttsd2si eax,mmword ptr [s] 00D82790 mov dword ptr [i],eax 这里我们发现如果pow参数都为int则是调用pow&lt;int, int&gt;，而这个pow&lt;int, int&gt;是通过xtgmath.h中的pow函数实现的：12345678910111213141516171819202122_C_STD_BEGIN;template&lt;class _Ty1,; class _Ty2&gt; inline; typename _STD enable_if&lt; _STD is_arithmetic&lt;_Ty1&gt;::value; &amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value,; typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;::type; pow(const _Ty1 _Left, const _Ty2 _Right); &#123; // bring mixed types to a common type00FE2B12 mov ecx,30h 00FE2B17 mov eax,0CCCCCCCCh 00FE2B1C rep stos dword ptr es:[edi] ; typedef typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type;; return (_CSTD pow(type(_Left), type(_Right)));00FE2B1E cvtsi2sd xmm0,dword ptr [_Right] 00FE2B23 sub esp,8 00FE2B26 movsd mmword ptr [esp],xmm0 00FE2B2B cvtsi2sd xmm0,dword ptr [_Left] 00FE2B30 sub esp,8 00FE2B33 movsd mmword ptr [esp],xmm0 00FE2B38 call _pow (0FE11FEh) 00FE2B3D add esp,10h ; &#125; cvtsi2sd来自SSE2，负责取出最低位的64位整型，并将其转换为一个浮点值，存放到xmm0浮点寄存器中。mmword负责将xmm0内的浮点移到[esp]所以pow&lt;int, int&gt;实现也是先转换成浮点再调用_pow对于__ftol2_sse函数底层是调用cvtsi2sd函数的，相比之下由于double是有符号而且表示范围要大于int，因此需要额外加一些处理。所以实际上通过调用cvttsd2si函数进行了类型转换。 float -&gt; int1234567891011121314151617; int i = powf(26, 2);00C5277E push ecx 00C5277F movss xmm0,dword ptr ds:[0C5AB48h] 00C52787 movss dword ptr [esp],xmm0 00C5278C push ecx 00C5278D movss xmm0,dword ptr ds:[0C5AB4Ch] 00C52795 movss dword ptr [esp],xmm0 00C5279A call _powf (0C51523h) 00C5279F add esp,8 00C527A2 call __ftol2_sse (0C51195h) 00C527A7 mov dword ptr [i],eax ; float s = 26.0;00D5277E movss xmm0,dword ptr ds:[0D5AB48h] 00D52786 movss dword ptr [s],xmm0 ; int i = s;00D5278B cvttss2si eax,dword ptr [s] 00D52790 mov dword ptr [i],eax MSVC对_pow函数的实现下面分析_pow函数首先win7并没有装MSVC 140的库，编译成静态IDA导入不了PDB，都是天书。于是再在win10下面使用ollydbg来调试，然而并找不到_main，只看到_cinit函数包含的_initterm，只好靠调用关系和参数传递硬找。 过程 图片 解释 进入main函数 main函数 pow函数 pow函数 跳转使用SSE指令集计算pow pow函数返回 pow函数返回后准备调用类型转换函数 使用cvttsd2si的类型转换函数 第一行的cmp指令由于不等于0，所以使用cvttsd2si而不是fistp，注意和后面gcc使用fistp进行比较 类型转换的结果 od_win10_vs_after_main_exit 退出main函数 可以看到exit和_cexit函数 GCC对pow的实现GCC版本之间差别比较大，我们这里还以GCC 472(Mingw32)分析。并简化了函数12345678#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;int main() &#123; int i2 = pow(26, 2); printf("%d\n", i2); return 0;&#125; 跟踪pow函数，发现实际调用了/MinGW32/lib/gcc/mingw32/5.7.2/include/c++/cmath中的函数12345678template&lt;typename _Tp, typename _Up&gt; inline _GLIBCXX_CONSTEXPR typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type pow(_Tp __x, _Up __y) &#123; typedef typename __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type; return pow(__type(__x), __type(__y)); &#125; 的重载std::pow&lt;int, int&gt;(__x = 26, __y = 2)汇编代码如下1234567891011 0x00401d20 &lt;+0&gt;: push %ebp 0x00401d21 &lt;+1&gt;: mov %esp,%ebp 0x00401d23 &lt;+3&gt;: sub $0x18,%esp 0x00401d26 &lt;+6&gt;: fildl 0xc(%ebp) 0x00401d29 &lt;+9&gt;: fildl 0x8(%ebp) 0x00401d2c &lt;+12&gt;: fxch %st(1) 0x00401d2e &lt;+14&gt;: fstpl 0x8(%esp) 0x00401d32 &lt;+18&gt;: fstpl (%esp)=&gt; 0x00401d35 &lt;+21&gt;: call 0x401c88 &lt;pow&gt; 0x00401d3a &lt;+26&gt;: leave 0x00401d3b &lt;+27&gt;: ret 其中fildl表示往st（浮点数操作堆栈）栈顶放入一个长整数，fstpl是取出一个长整型数然后调用了crt中的pow函数的汇编代码 12345678910111213141516 0x74cd34b0 &lt;+0&gt;: cmpl $0x0,0x74cf6d84=&gt; 0x74cd34b7 &lt;+7&gt;: je 0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt; 0x74cd34bd &lt;+13&gt;: sub $0x8,%esp 0x74cd34c0 &lt;+16&gt;: stmxcsr 0x4(%esp) 0x74cd34c5 &lt;+21&gt;: mov 0x4(%esp),%eax 0x74cd34c9 &lt;+25&gt;: and $0x1f80,%eax 0x74cd34ce &lt;+30&gt;: cmp $0x1f80,%eax 0x74cd34d3 &lt;+35&gt;: jne 0x74cd34e4 &lt;pow+52&gt; 0x74cd34d5 &lt;+37&gt;: fnstcw (%esp) 0x74cd34d8 &lt;+40&gt;: mov (%esp),%ax 0x74cd34dc &lt;+44&gt;: and $0x7f,%ax 0x74cd34e0 &lt;+48&gt;: cmp $0x7f,%ax 0x74cd34e4 &lt;+52&gt;: lea 0x8(%esp),%esp 0x74cd34e8 &lt;+56&gt;: jne 0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt; 0x74cd34ea &lt;+58&gt;: jmp 0x74ce0249 &lt;msvcrt!modf+9193&gt; 0x74cd34ef &lt;+63&gt;: nop 其中stmxcsr将MXCSR存储到32位寄存器，modf将数分解为整数部分和小数部分。在0x74cd34b7 &lt;+7&gt;处程序进入msvcrt!_CrtDbgReportWV+84。然后在其中某一个modf方法中卡死。于是很奇怪为什么要用到msvcrt!_CrtDbgReportWV这个函数后来我试图用IDA来调试，不过win10 把我的安装程序杀掉了，所以我试图在win7里面用IDA调试，首先装完DevCPP之后进行调试，发现了不一样的光景。crt中pow函数的代码变成了这样！ 1234567891011121314=&gt; 0x7613608f &lt;+0&gt;: cmpl $0x0,0x761b50c0 0x76136096 &lt;+7&gt;: je 0x7613609d &lt;pow+14&gt; 0x76136098 &lt;+9&gt;: jmp 0x76140eb8 &lt;msvcrt!_CIpow+271&gt; 0x7613609d &lt;+14&gt;: lea 0xc(%esp),%edx 0x761360a1 &lt;+18&gt;: call 0x76120c6f &lt;msvcrt!_clearfp+230&gt; 0x761360a6 &lt;+23&gt;: jmp 0x76120c85 &lt;msvcrt!_clearfp+252&gt; 0x761360ab &lt;+28&gt;: movl $0x8,-0x218(%ebp) 0x761360b5 &lt;+38&gt;: jmp 0x7611cf67 &lt;wtoi+1860&gt; 0x761360ba &lt;+43&gt;: cmp %edi,%esi 0x761360bc &lt;+45&gt;: jne 0x7611c269 &lt;wcsncpy_s+30&gt; 0x761360c2 &lt;+51&gt;: jmp 0x7615dbb3 &lt;msvcrt!_ftol2_sse_excpt+114168&gt; 0x761360c7 &lt;+56&gt;: xor %eax,%eax 0x761360c9 &lt;+58&gt;: mov %ax,(%esi) 0x761360cc &lt;+61&gt;: jmp 0x7611c2b8 &lt;wcsncpy_s+109&gt; 反汇编居然不一样了！那到底哪个结果是对的呢？用IDA调试发现GCC编译结果连main函数都不知道在哪里，到处都是sub_xxxx的无名函数，于是使用OD进行调试，至少能看清楚先后调用关系 下面是调试过程 过程 图片 解释 进入main函数 前面要先经过两个jmp 进入pow&lt;int, int&gt;函数 进入CRT中的pow函数的跳转 这里是一个jmp跳转 进入CRT中真正的pow函数 可以和WIN10和WIN7下的DEVCPP的反汇编进行对比 CRT中pow函数返回 注意右边寄存器表中的ST0的值是正确的26**2==676.00 printf前的结果 注意到eax实际上存放着printf的参数int i2，但是变成了整数0x02A3==675而不是676 所以应该是在浮点数变成整数这块出了问题先解释几个汇编指令 汇编 解释 fstcw 存储FPU控制字到一个内存区域 fldcw 逆运算 fistp 存储ST(0)到整数并弹出寄存器堆栈 下面来看main函数中是如何将FPU中的运算结果拿到eax中并提供给printf输出的 过程 图片 解释 从pow&lt;int, int&gt;函数跳出 发现此时运算结果还在ST(0)中，并且fstcw指令从[esp+1e]处存取浮点控制字，fisttp指令将ST(0)存放到[esp+1c]==0x0028ff1c处 运行完fistp检查内存块0x0028ff1c 发现此时结果变为2a3==675，于是应该是fistp指令出现了问题 总结MSVC 140和GCC472(MinGW)使用了不同的汇编指令进行类型转换，导致出现问题。GCC使用了x87 FPU指令而MSVC 140使用了SSE指令集。如果改成这样的方式123456789#include &lt;cstdio&gt; #include &lt;cmath&gt;using namespace std;const double eps = 1e-6; int main() &#123; int i2 = pow(26, 2) + eps; printf("%d\n", i2); //似乎这个版本的GCC不支持%lf return 0;&#125; 输出结果在GCC472版本上也是正确的了 Postscript本文参考了在 cplusplus.com 上guestgulkan给出的这样的解答： This is actually quite interesting and works differently on Microsoft Visual Studio 2008 and Dev C++(using mingw); Microsoft Visual Studio 2008 cmath is basically a wrapper that calls math.h.In math.h if running in C mode you only get one power function pow(double, double).In C++ mode (which we are using) you get the c++ overloaded functions:long double pow(long double,int), float pow(float,int), double pow(double,int) and a few others.So calling pow(int, int) for example pow(3,2) will always fail due to ambiguity whether you include cmath or math.h DEV C++ with MINGWWith this set up, math.h just contains the the usual C functionpow(double, double) - so all the functions work because with pow(int, int) both ints get promoted to double by compiler and all is OKcmath in more than a wrapper for math.h. First it includes math.h and then undefines a whole lot of stuff that math.h defined, and substitutes the c++ versions.This includes the pow function declaration.As the c++ overloaded functions (same as any other c++ compiler), you will get the ambiguity problem - when using pow(int, int).P.S The ambiguity occurs with pow(int, int) because integers can be promoted to floats or doubles, which means that pow(int, int) can fit any of the 6 or so overloaded c++ pow function - so the compiler gets confused. 对于标准库对pow函数的处理，stackoverflow上的enigmaticPhysicist给出了这样的回答： A specialisation of pow(x, n) to where n is a natural number is often useful for time performance. But the standard library’s generic pow() still works pretty (surprisingly!) well for this purpose and it is absolutely critical to include as little as possible in the standard C library so it can be made as portable and as easy to implement as possible. On the other hand, that doesn’t stop it at all from being in the C++ standard library or the STL, which I’m pretty sure nobody is planning on using in some kind of embedded platform.]]></content>
      <tags>
        <tag>C++</tag>
        <tag>ACM</tag>
        <tag>MSVC</tag>
        <tag>GCC</tag>
        <tag>卡精度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brainfuck]]></title>
    <url>%2F2015%2F12%2F26%2Fbrainfuck%2F</url>
    <content type="text"><![CDATA[brainfuck是一个图灵完备的语言，仅有8个操作，晦涩难懂，但能够像图灵机一样完成任何计算。本文主要讨论一下brainfuck的一些编程技巧。 brainfuck由8个操作，输入输出流，一块初始化为0的内存，以及一个全局指针ptr（默认指向内存块的开始）构成。八个操作分别为（这里采用c描述）：12345678&gt; ptr++&lt; ptr--+ *ptr++- *ptr--, *ptr = getchar(). putchar(*ptr)[ while(*ptr)&#123;] &#125; // of while 马上就是新年了，下面这段程序可以输出HappyNewYear1++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++.+++++++++++++++..+++++++++.&gt;++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++.&lt;--.++.&gt;.----.+++++++++++++++++. brainfuck由于语法简单，所以解释器也非常好实现，这里也实现了一个：Calvin’s brainfuck interpreter。由于写bf会导致+-&lt;&gt;比较多，解释器也提供了+(48)表示连续48个加号的糖，同时也可使用%作注释，使用#stk访问变量表。程序可以开启debug模式，可以使用#dbg和#cdb代码块局部开启或关闭debug模式。同时这边也附了一个贪心算法的实现，用比较短的bf代码打印字符串。等我考完试再优化一下ლ(╹◡╹ლ)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# https://github.com/CalvinNeo/brainfuck/blob/master/print_gen.py#coding:utf8import sysdef naive_gen(ascii): code = '' for x in ascii: code += '&gt;' + '+' * ord(x) + '.' return codedef greedy_gen(ascii): current = [] code = '' ptr = -1 for x in ascii: if len(current) == 0: code += '+' * ord(x) + '.' ptr += 1 current.append(x) else: min_dist = 256 min_index = 0 for (index, y) in zip(range(len(current)), current): if abs(ord(y)-ord(x)) &lt; min_dist: min_dist, min_index = abs(ord(y)-ord(x)), index if min_dist &lt; ord('A'): if ord(current[min_index]) &gt;= ord(x): ptr_delta = '-' * ( ord(current[min_index]) - ord(x) ) else: ptr_delta = '+' * ( ord(x) - ord(current[min_index]) ) if min_index &gt;= ptr: ptr_move = '&gt;' * ( min_index - ptr ) else: ptr_move = '&lt;' * ( ptr - min_index ) code += ptr_move + ptr_delta + '.' ptr = min_index current[min_index] = x else: code += '&gt;' * (len(current) - ptr) + '+' * ord(x) + '.' current.append(x) ptr = len(current) - 1 return codeif __name__ == '__main__': ascii = raw_input() print greedy_gen(ascii) 下面介绍一下brainfuck的常用技巧。 数学运算 乘法以下代码实现了两个一位数乘法：123456789101112131415161718,-(48)&gt;,-(48) % read 2 integers[- % while $2-- &lt; % set ptr to $1 [ - % while $1-- &gt;&gt;+ % $3++ &gt;+ % $4++ &lt;&lt;&lt; % set ptr back to $1 ] &gt;&gt;&gt; % set ptr to $4 [ % copy $4 to $1 - % while $4-- &lt;&lt;&lt;+ % $1++ &gt;&gt;&gt; % set ptr back to $4 ] &lt;&lt; % move ptr to $2 and continue]&gt;+(48). % print answer in $3 内存操作 清空存储区这里需要特别强调一下，brainfuck里面没有生存空间这样的概念，也就是它的ptr是全局的单例的，在使用[]嵌套循环的时候，要特别注意这一点。12 语言结构 if语句 switch语句 嵌套循环]]></content>
      <tags>
        <tag>brainfuck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++中for循环的一个用法]]></title>
    <url>%2F2015%2F12%2F22%2FC-for%2F</url>
    <content type="text"><![CDATA[今天发现了C/C++里面for的一个不常见到的用法，来水一篇文章。 今天看到一个技术交流群上面分享了下面这一段代码；12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string s; cin &gt;&gt; s; for(int i = s.size(); i--;)&#123; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 请注意这一行for(int i = s.size(); i--;){ 乍一看循环根本不能跳出，使用g++编译，发现得到了正确的反向字符串。我们使用char[]代替string，并跟踪i，发现i实现了递减，并且当(i--)等于0时，循环跳出。12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char s[] = &#123;'a','b','c','d','e'&#125;; for(int i = 5; i--;)&#123; cout &lt;&lt; i; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; endl; return 0;&#125; 于是得出初步结论，for(A;B;C)语句中，当C为空时，B在更新循环标记的同时起返回值作为循环结束的条件。其作用相当于下面代码中的judge_end函数。12345678910111213141516#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool judge_end(int &amp; i)&#123; return i-- &lt;= 0 ? false : true;&#125; int main()&#123; char s[] = &#123;'a','b','c','d','e'&#125;; for(int i = 5; judge_end(i);)&#123; cout &lt;&lt; i; &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM/ICPC EC-FINAL小结]]></title>
    <url>%2F2015%2F12%2F14%2FICPC-EC-FINAL%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[EC-FINAL是2015年度最后一次ACM区域赛了，这次总共有288个队参加比赛。命题还是Google。 正式赛赛题这次出生点在强队中间，右后方就是本次冠军，唯一的9A，陈立杰的华莱士队，左边是北航的7A，正后方是浙大，右边是广大。热身赛题目是Google一次网试的笔试题。A题Dynamic Grid，直接暴力模拟。B题IP Summarization，要求是给出若干个IP以及他们的掩码，要求输出合并的Normalize之后的所有IP，Google给的思路就是建一颗二叉树。实际做的时候发现这道题要注意一点就是你要先排序，考虑子网和合并的情况。C题Virtual Rabbit，讲的是一个人只能在[W,H)和[B,G)时间段内喂兔子，兔子在X秒内不被喂食就会死去，问喂食的最少次数。正式赛还是比较有难度的。水题是ADLM。A题Boxes and Balls，据说是一个初中数学题，找最大的m，使得m(m+1)/2 &lt; N，解方程的时候用double可能会出精度问题，没清WA了一次，其实也可以用二分去做。M题November 11th，电影院里面Singles不能坐在相邻的座位，且有B个坏椅子的坐标，求最多最少可以坐多少个单身狗。这里要注意只要两个人中间隔两个就不能坐人了，一开始想成了一个。结果是模3有规律，直接硬算找规律。然后就是坑爹的D题，题目的意思是你有A块钱，不过是整的，你现在要买一个自动售货机换得零钱然后去付另外的B块钱，问你最少需要在自动售货机上面卖多少钱东西，其中A,B∈{0.01,0.02,0.05,0.1,0.2,0.5,1,2,5,10,20,50,100}。又看到样例T&lt;=78的时候笑了，这个不就是打表嘛，总共78个样例，于是我们在纸上手算了半天，但是到最后还是没有A出来，出来之后才知道，可以在自动售货机上面买若干次。至于L题，讲的是有一个无限大的乘法表，现在给定一个由数字和问号（相当于未知）矩阵，问这个矩阵有没有可能是这个大的乘法表的一部分。这道题目思路就是只要矩阵中知道两个数，那么我们就可以把整个矩阵的所有值解出来，这样我们就可以一一确定剩下来的值是否符合我们已经确定了的矩阵了。但是我们忽略了一种情况，就是如果只有一个数的话，这个矩阵不一定存在，比如1这个数，他只能出现在第一行的第一列，如果有这样的一个矩阵：123? ? ?? 1 ?? ? ? 那它肯定不是乘法表的一部分，因此我们少一步分解因数，检查每一个数字是否能够出现在这个乘法表中的过程。 感受 上海大学宝山校区好荒啊，我们住在蓝波万酒店感觉名字好屌啊，走到学校好远啊。然而宾馆只有一张大床一张小床，我和良哥阿洁哥一起睡的，纪存哥阿涛和清恒拼在一起睡得，结果他们晚上被阿涛各种挤。 晚上吃了羊蝎子火锅超级逗，一盆饭6块钱，一盘豆芽菜1块钱，阿涛点了六盘豆芽菜，然后大家最后实际上就是在吃豆芽菜 宾馆里面有电脑！于是热身赛晚上张老师让我们写一写热身赛的题目，于是我们只好装做在电脑上写，但是阿涛一直给女票盈盈买衣服，张老师来了也不停，超级逗笔。]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>现场赛</tag>
        <tag>ICPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX学习笔记]]></title>
    <url>%2F2015%2F12%2F02%2FLaTeX%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[目录 Step 0. 使用TeXStudio Step 1. 使用LaTeX做Routine Work Hello, World 带格式的文本 加入数学公式的文本 特殊字符的输入 Step 2. 支持中文 Step 3. 论文编辑的常用元素 一些额外需要注意的配置 数学符号 矩阵 表格 有序列表和无序列表 代码 Step 4. 段落，段落格式和目录 分段 目录和标题 交叉引用 Step 5. 图片 Step 6. 页面设置 Step 7. 模板 Step inf. 额外说明 TeX是由高德纳开发的一款排版引擎，由于纯TeX过于底层，所以很多人选择使用LaTeX，LaTeX是TeX的一个常用宏包。 Step 0. 使用TeXStudioTeXStudio的界面还是比较简单容易操作的。其中配置常出现以下问题： Make sure that you have installed a (La)TeX distribution这是因为没有没有安装LaTeX发行版的缘故，TeXStudio是一个可配置的LaTeX编辑器，我们需要单独安装对应的编译器。有很多LaTeX的发行版，我们这里可以安装使用MikTeX。可前往MikTeX官网 http://miktex.org/ 上下载对应的版本。安装完后应当进入Options-&gt;Configure TeXStudio-&gt;Commands来检查MikTeX路径是否正确 没有错误，但是无法生成文档。这个可能是因为安装了其他LaTeX发行版，比如CTEX整合包的缘故，卸载该整合包，重新安装MikTeX即可。 Step 1. 使用LaTeX做Routine Work Hello, World 新建文档，并输入 1234\documentclass&#123;article&#125; % meta info of the document\begin&#123;document&#125; Hello, World\end&#123;document&#125; 生成文档，预览 带格式的文本 新建文档，并输入 123456789101112131415161718\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent % no indent at the head of this paragraph \textbf&#123;Bold&#125; \newline % use this command to start a new line \textit&#123;Italic&#125; \\ % another way to start a new line \underline&#123;Underline&#125; \begin&#123;flushleft&#125; Left \end&#123;flushleft&#125; \begin&#123;center&#125; Middle \end&#123;center&#125; \begin&#123;flushright&#125; Right \end&#123;flushright&#125;\end&#123;document&#125; 生成文档，预览 其中： \noindent 取消段首缩进 \textbf{your_text} 加粗your_text \textit{your_text} 斜体的your_text \underline{your_text} 带有下划线的your_text \newline 和 \\ 是换行指令 \begin{command} 和 \end{command} 之间是command的scope，其中flushleft, center, flushright表示靠左、居中和靠右对齐 加入数学公式的文本 数学公式和普通文本的格式是不同的，应当使用$和$，\(和\)，\begin{math}和\end{math}将数学公式包起来，如 12345678910\documentclass&#123;article&#125;\begin&#123;document&#125; $a_&#123;1&#125;+b_&#123;1&#125; = c_&#123;1&#125;$ \\ \( a^&#123;2&#125; + b^&#123;2&#125; = c^&#123;2&#125; \) \\ \begin&#123;math&#125; \frac&#123;1&#125;&#123;2&#125; + \sqrt&#123;3&#125; = 0 \end&#123;math&#125;\end&#123;document&#125; 特别地，使用\[和\]或者\begin{displaymath} 和\end{displaymath}能够另起一行显示公式，试比较 123456789101112\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent the equlation \[ 1+2+3+4 = 7 \] is not established the equlation \( 1+2+3+4 = 7 \) is true\end&#123;document&#125; 对于多个方程我们可以使用\begin{equation}和\end{equation}来标记,并且使用\label{name}来标记,使用\ref{name}来引用。 1234567891011121314\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \label&#123;eq:eps&#125; \epsilon &gt; 0 % our formula \end&#123;equation&#125; \begin&#123;equation&#125; \label&#123;eq2:eps&#125; \delta &lt; 0 \end&#123;equation&#125; From (\ref&#123;eq2:eps&#125;), we can ... \end&#123;document&#125; 使用\textrm{xxx}插入普通格式的文本 特殊字符的输入 LaTeX中有一些字符是不能“正常”输入的。 除反斜杠之外的特殊字符，#、$、%、^、&amp;、_、{、}、~，可在前面直接加反斜杠，如\#便可显示# 反斜杠（stroke）：可使用$\backslash$生成。 空格：使用\,强行插入多个空格，注意一般英文文本需要两个\,才能达到理想的单词间距。 日期：可使用\today生成。 引号：用 产生左双引号，用`&#39;&#39;`产生右双引号。用 `产生左单引号，用&#39;产生右单引号。当单引号与双引号相邻时，在两者中间插入空格\,。 取反号和波浪号：用\~{}生成取反号（位置靠上），用$\sim$生成波浪号（位置竖直居中） 角度°：角度是一个上标的圆圈，圆圈用\circ生成，于是10度角就是$10^{\circ}$ Step 2. 支持中文缺少ctex库的情况： 运行 C:\Program Files (x86)\MiKTeX 2.9\miktex\bin\mpm.exe 设置Repository，这里建议选择第一个中科大的资源站，如果不幸40X或者50X的话可以选择翻墙去比如华盛顿大学的（翻墙的话需要配置Connection Settings）镜像站。 选择安装ctex安装过程是这样的（注意进度条结束之后可能还有一个解压过程，不要点Cancel，等安装完毕，Cancel会变成Close） 按照以上方法安装 l3kernel, l3packages, ms, ulem, zhnumber, （cjk, cjkpunct）（PS 亦可通过ftp://mirrors.ustc.edu.cn/CTAN/systems/win32/miktex/tm/packages/ 直接下载lmza文件安装） 测试1234567\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; 蛤蛤蛤蛤蛤蛤\end&#123;CJK&#125;\end&#123;document&#125; Step 3. 论文编辑的常用元素 0. 一些额外需要注意的配置 需要补充安装 amsmath，listings，mptopdf几个包。这几个包的安装方法都可以参照Step2中中文支持包一样安装。 1. 数学符号 希腊字母 123\alpha α; \beta β; \gamma γ; \delta δ; \epsilon ε; \zeta ζ; \eta η; \theta θ; \iota t; \kappa κ; \lambda λ; \mu μ; \xi ξ：\nu ν; \o o; \pi π; \rho ρ; \sigma σ; \tau τ; \upsilon υ; \phi Φ; \chi Χ; \psi Ψ; \omega ω 将首字母大写可以得到大写的希腊字母 空格 在这里提过，可以用\,来生成一个小空格，此外数学公式中还可以用\quad和\qquad生成大小不等的空格。 一般来说，可以使用\来得到一个空格，这个空格比较小，用于词语词之间的分隔；用\@得到一个较大的句子之间的空格，用~得到一个不会在此处换行的空格。 此外，用来在一行中并列排放两个数学变量，用\quad也是一个不错的选择。其实对于空格，有以下的一些比例：\quad 即\hspace{1em}，一个英文字符**M**的宽度 \qquad 即\hspace{2em}，两个英文字符**M**的宽度 \; 5/18个英文字符的宽度 \: 4/18个英文字符的宽度 \, 3/18个英文字符的宽度 \! -3/18个英文字符的宽度 \hspace{长度} 产生指定宽度 \phantom{文本} 产生指定文本的宽度 插入普通文本 在这里 数学符号 对于任意的：\forall 存在：\exists 根号：\sqrt[n]表示n次方根，其中平方根可以省略[n] 括号：使用\big( \Big( bigg( Bigg( 生成不同大小的左（括号 省略号：ldots（位置靠下）和cdots（位置居中） 上标和下标 上标使用^来，下标采用_。特别地，当要将一个式子（而不是字母）作为上标，需要将这个式子整体括起来，如a^{x+y} 可以同时指定上标和下标，如a^{2}_{i} 特殊的上标，如导数符号，使用&#39;获得。例如对f求导，应当输入f&#39;而不是f^{&#39;} 此外，在平均数和估计中常用的hat和bar，可以写作\hat{x}，\bar{x} 修饰符 向量：\vec a，\overrightarrow{AB} 大的数学符号 如sigma，limit之类的数学符号在LaTeX中是相对容易输入的，选择对应的命令，按照上下标的输入方式输入即可。 1234567891011121314\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \label&#123;eq:eps&#125; \epsilon \textrm&#123; simple text&#125; &gt; 0 % our formula \end&#123;equation&#125; \begin&#123;equation&#125; \label&#123;eq1:eps&#125; \lim_&#123;n \to \infty&#125; \sum_&#123;k=1&#125;^n k = \infty \end&#123;equation&#125;\end&#123;document&#125; 数学公式 使用双斜杠换行 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \alpha_1 f_c b x = f_y A_s \\ M_u = f_y A_s (h_0 - \frac&#123;x&#125;&#123;2&#125;) \\ M_u = \alpha_1 f_c b x (h_0 - \frac&#123;x&#125;&#123;2&#125;) \\ \end&#123;equation&#125;\end&#123;document&#125; 方程组的情况： 2. 矩阵 12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;listings&#125; \usepackage&#123;graphicx&#125;\begin&#123;document&#125; \noindent \begin&#123;equation&#125; \begin&#123;bmatrix&#125; -1&amp; 1&amp; 1&amp; 1&amp; -1&amp; \ldots &amp; -1 \\ -1&amp;1&amp;1&amp;-1&amp;-1&amp; \ddots &amp; -1 \\ \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \vdots&amp; \\ 1&amp; 1&amp; 1&amp;-1&amp;-1&amp; \ldots &amp; 1 \\ \end&#123;bmatrix&#125; \end&#123;equation&#125;\end&#123;document&#125; 这里要注意几点：\begin{bmatrix}标记的，不过需要在数学编辑的环境下哦。 第一，\usepackage{amsmath}这个包是必备的，如果没有是无法生成文档的。 第二，&amp;区分矩阵中每一行的元素，\\区分矩阵中的每一行。 第三，&amp;后面的空格不是必须的，但是有了这个空格，源码会显得比较明朗，也易于修改。 第四，\ldots，\ddots，\vdots分别表示横过来的，斜过来的，竖过来的省略号。 3. 表格 首先先生成一个最简单的表格 123456789101112\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|l|c|r|&#125; \hline 1 &amp; 2 &amp; 3 \\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\ \hline \end&#123;tabular&#125; \end&#123;document&#125; 可以看出表格和矩阵时差不多的，&amp;区分矩阵中每一行的元素，\\区分矩阵中的每一行。额外有几点的区别，补充说明如下： 我们使用\begin{tabular}和\end{tabular}来标记一个表格（注意，是tabular不是table哦）。 后面的{|l|c|r|}抽象地表示了一个表格的一行。其中|表示竖向的表格线，从而形成一行表格，当然也可以用||，这样表格线就是双层的啦。里面的l、c、r分别表示在这个格子里面中的文字是靠左，居中还是靠右对齐。特别地，当表格有很多行的时候写起来会比较麻烦，这时候可以采用重复指令*{n}{repeat}，其中*{n}{repeat}表示重复repeat n次，模板如下：*{3}{|c}| 表示一个三列的表格且都是居中。 \hline表示横向的表格线。 下面给表格加上一个标题： 12345678910111213141516\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;table&#125; \caption&#123;My first table&#125; \centering \begin&#123;tabular&#125;&#123;|l|c|r|&#125; \hline 1 &amp; 2 &amp; 3\\ 4 &amp; 5 &amp; 6 \\ 7 &amp; 8 &amp; 9 \\ \hline \end&#123;tabular&#125; \end&#123;table&#125;\end&#123;document&#125; 可以看到，在\begin{tabular}外面又套了一层\begin{table}，这两层是不相同的，我们需要在\begin{table}里面，\begin{tabular}外面用\caption{My first table}指定标题为“My first table”，而下面的\centering指令是让表格居中。 其实我们可以发现\begin{tabular}表示一个表格实体的开始，而\begin{table}表示一个表格连同标题至脚注的开始。 在Word中常常用到“合并单元格”和拆分单元格指令，在LaTeX中可以通过\multirow和\multicolumn来实现。这里\usepackage{multirow}是必备的。 先看一个例子：现有一个4x4的表： 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline 1行1列 &amp; 1行2列 &amp; 1行3列 &amp; 1行4列 \\ 2行1列 &amp; 2行2列 &amp; 2行3列 &amp; 2行4列 \\ 3行1列 &amp; 3行2列 &amp; 3行3列 &amp; 3行4列 \\ 4行1列 &amp; 4行2列 &amp; 4行3列 &amp; 4行4列 \\ \hline \end&#123;tabular&#125;\end&#123;CJK&#125;\end&#123;document&#125; 下面我们合并第一列和第三列。 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline \multirow&#123;4&#125;&#123;2cm&#125;&#123;第1列&#125; &amp; 1行2列 &amp; \multirow&#123;4&#125;&#123;2cm&#125;&#123;第3列&#125; &amp; 1行4列 \\ &amp; 2行2列 &amp; &amp; 2行4列 \\ &amp; 3行2列 &amp; &amp; 3行4列 \\ &amp; 4行2列 &amp; &amp; 4行4列 \\ \hline \end&#123;tabular&#125;\end&#123;CJK&#125;\end&#123;document&#125; 对比代码发现，合并行单元格，我们只要在被合并的单元格的起始单元格调用\multirow命令，然后在被这个大单元格占据的其他地方使用空格代替原来的字符就行了。 这里说明一下\multirow命令的参数，第一个参数，这里是4表示向下合并多少行的单元格，第二个参数，这里是2cm一般取2cm或者*就可以，第三个参数，就是这个大单元格里面的内容了，你可以在里面嵌入其他指令，如textbf用来加粗等。 此外对于合并列，有同样的\multicolumn指令，注意这里第二个参数变成了{c|}这样，用来说明这个大单元格内文本的对齐方式。不过这里需要特别注意的一点就是，在同一行中，我们不需要给被\multicolumn吃掉的单元格占位置了。 1234567891011121314151617\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125; \begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \noindent \renewcommand&#123;\multirowsetup&#125;&#123;\centering&#125; \begin&#123;tabular&#125;&#123;|l|l|l|l|&#125; \hline 1行1列 &amp; 1行2列 &amp; \multicolumn&#123;2&#125;&#123;|c|&#125;&#123;1行34列&#125; \\ \cline&#123;1-4&#125; 2行1列 &amp; 2行2列 &amp; 2行3列 &amp; 2行4列 \\ 3行1列 &amp; 3行2列 &amp; 3行3列 &amp; 3行4列 \\ 4行1列 &amp; 4行2列 &amp; 4行3列 &amp; 4行4列 \\ \hline \end&#123;tabular&#125; \end&#123;CJK&#125;\end&#123;document&#125; 注意这里第10行的\cline{1-4}，试着将它去掉，我们可以发现\multicolumn部分失去了下面的表格构造线。这里\cline{1-4}表示在第1列到第4列画上表格构造线。 如果要实现合并多行多列的单元格可以嵌套使用指令\multirow，\multicolumn。 1234567891011121314% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|ccc|&#125; \hline 1 &amp; 2 &amp; 3 \\ 4 &amp; \multicolumn&#123;2&#125;&#123;c|&#125; &#123; \multirow&#123;2&#125;&#123;*&#125;&#123;&#123;?&#125;&#125; &#125; \\ 7 &amp; &amp; \\ \hline \end&#123;tabular&#125;\end&#123;document&#125; 特别地，\renewcommand用来重定义一个指令，对于\renewcommand{\multirowsetup}{\centering}来说，就是把系统中已有的\multirowsetup重新定义成了使用\centering命令，从而达到强制multirow中内容居中居中的效果。当然还有newcommand用来定义一个之前不存在的命令，如同C++里面的#define一样。 斜线表头。为了能够使用斜线表头，需要\usepackage{diagbox}，\usepackage{pict2e}，\usepackage{fp}包。 1234567891011121314151617% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;booktabs&#125;\usepackage&#123;diagbox&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;|l|ccc|&#125; \hline \diagbox&#123;Time&#125;&#123;Room&#125;&#123;Day&#125; &amp; Mon &amp; Tue &amp; Wed \\ \hline Morning &amp; used &amp; used &amp; \\ Afternoon &amp; &amp; used &amp; used \\ \hline \end&#123;tabular&#125;\end&#123;document&#125; 注意第11行\diagbox{Time}{Room}{Day}表示顺时针的三个Time，Room，Day。 三线表。对于英文论文来说，表格尽量 使用三线表格式。需要 12345678910111213141516% 此例修改自知乎专栏，作者李阿玲。% http://zhuanlan.zhihu.com/LaTeX/19749566\documentclass&#123;article&#125;\usepackage&#123;multirow&#125;\usepackage&#123;booktabs&#125;\begin&#123;document&#125; \noindent \begin&#123;tabular&#125;&#123;ccc&#125; \toprule 2&amp;9&amp;4\\ \midrule 7&amp;5&amp;3\\ 6&amp;1&amp;8\\ \bottomrule \end&#123;tabular&#125;\end&#123;document&#125; 4. 有序列表和无序列表 有序列表enumerate： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;enumerate&#125; \item C \item Python \item Haskell \end&#123;enumerate&#125;\end&#123;document&#125; 无序列表enumerate： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;itemize&#125; \item CSharp \item Javascript \item Rust \end&#123;itemize&#125;\end&#123;document&#125; 带小标题的列表description： 123456789\documentclass&#123;article&#125;\begin&#123;document&#125; \noindent \begin&#123;description&#125; \item[C++] Leaking basin \item[PHP] Best language in the world \item[Perl] WTF \end&#123;description&#125;\end&#123;document&#125; 5. 代码 1234567891011\documentclass&#123;article&#125;\usepackage&#123;CJKutf8&#125;\usepackage&#123;amsmath&#125;\usepackage&#123;listings&#125; \begin&#123;document&#125; \noindent \begin&#123;lstlisting&#125;[language=python] #coding:utf8 import numpy as np \end&#123;lstlisting&#125;\end&#123;document&#125; 这里同样注意\usepackage{listings}包不能丢掉，其中language表示里面显示的是什么语言。 Step 4. 段落，段落格式和目录 分段 LaTeX对分段有着以下几个明确的指令 1234567\section&#123;...&#125;\subsection&#123;...&#125;\subsubsection&#123;...&#125;\paragraph&#123;...&#125;\subparagraph&#123;...&#125;\part&#123;...&#125;\chapter&#123;...&#125; 注意：chapter仅限于report和book类（点击查看详细说明） 前五个命令表示从大到小的5个五级标题，其中含paragraph的一般为段落，前面没有标号，而且需要有实际的内容，不然这个paragraph就不会被显示（试着将含有remove me的行注释掉，注意观察编译结果），编译： 123456789101112131415\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \section&#123;section&#125; \subsection&#123;subsection&#125; \subsubsection&#123;subsubsection&#125; \paragraph&#123;paragraph1&#125; there's some subparagraph \subparagraph&#123;subparagraph1&#125; \subparagraph&#123;subparagraph2&#125; \paragraph&#123;paragraph2&#125; % remove me there's no more subparagraph % remove me\end&#123;CJK&#125;\end&#123;document&#125; 此外，还有一种\section{short_title}{long_title}的写法，在中间的short_title我们指定一个简短的标题名，用来后面生成目录。 下面是part指令，类似于section，不过相比section，part是不带编号的，而且\part{}自动生成类似Part I这样的标题，不需要写成\part{Part I}，所以一般part指令都是用在比较独立的地方，比如用在chapter和section中间。 这边注意一点：请不要用section或者paragraph指令去做有序列表或者无序列表，点此查看专门的方案 1234567891011\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \section&#123;section1&#125; \part&#123;&#125; \part&#123;&#125; \part&#123;&#125; \section&#123;section2&#125; \end&#123;CJK&#125;\end&#123;document&#125; 通过之前的几个例子，我们发现section系是不带编号的，paragraph和part是带编号的。事实上section也可以不带编号，paragraph也可以带编号。事实上这个是可以调整的。 运行一下代码，将\setcounter的最后一个参数从1一直调到5，逐次编译，比较每次的不同。 12345678910111213\documentclass&#123;article&#125;\usepackage&#123;ctex&#125;\begin&#123;document&#125;\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;gkai&#125; \setcounter&#123;secnumdepth&#125;&#123;5&#125; % change this from 1 to 5 %控制显示4层编号 \section&#123;A&#125; \subsection&#123;B&#125; \subsubsection&#123;C&#125; \paragraph&#123;D&#125; D \subparagraph&#123;E&#125; E\end&#123;CJK&#125;\end&#123;document&#125; 对于article文档类来说，\setcounter默认的是3，也就是默认section系的有编号，parag系的没有编号。 事实上，如果我们仅仅只是想去掉一级section的编号的话，可以使用\section*{...}在\section和实际内容之间加上一个*就可以实现了。 目录和标题 先使用\title{}，\author{}和可选的\data{}为文章设置标题。 再使用\maketitle显示标题。 交叉引用 Step 5. 图片Step 6. 页面设置Step 7. 模板Step inf. 额外说明 文档类 文档类一般包括以下几个 12345article 最常用的minimal 最基本的文档类，一般仅用来查错report 较长的报告和论文book 书籍slides 幻灯片 使用\documentclass{...}定义。本文中大多数都是article类型]]></content>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django配置与使用]]></title>
    <url>%2F2015%2F10%2F21%2Fdjango%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在配置Django的时候常常会出现一些问题，比如migrate无效，表单提交valid验证不过等问题，本文给出了一些解决方案 同步数据库的问题根据不同版本有对应以下两种方法同步数据库：1python manage.py syncdb (用于旧版本)12python manage.py makemigrationpython manage.py migrate (用于新版本)其中migrate方法一般要提前建一个空的数据库，但是数据表是自动同步的 自定义数据表一般地，django在数据库中存储的表名为model name，但是可以通过以下方式自定义表名123class MyModel(models.Model): class Meta: db_table = 'xxx' 上传文件问题 上传空文件会导致is_valid不过 不能在如view.py, model.py中正常地import 这些文件的sys.path中的当前目录是manage.py所在目录，一般比这些文件本身所在的目录高一级。所以sys.path.append中的路径应当比实际高一层。 同样因为这个原因，保存文件时路径不能以’/upload/‘开头，而应该直接以’upload/‘开头。在外部程序访问时，应当做一个路径转化。 Migrate问题 RuntimeError: Error creating new content types. Please make sure contenttypes is migrated before trying to migrate apps individually.检查Model.pyContentType 模型对应数据库中django_content_type表，主要用户维护django project中所安装的所有用户模型出现这个问题一定是模型问题，我后来发现我的原因是因为 models.XXXField 里面多了一些参数比如required什么的删掉就好，此外form也要注意之后一定要先drop database再migrate就可以了 file clean之后变成None摘自C:\Program Files (x86)\Python27\Lib\site-packages\Django-1.9-py2.7.egg\django\forms\forms.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def full_clean(self): """ Cleans all of self.data and populates self._errors and self.cleaned_data. """ self._errors = ErrorDict() if not self.is_bound: # Stop further processing. return self.cleaned_data = &#123;&#125; # If the form is permitted to be empty, and none of the form data has # changed from the initial data, short circuit any validation. if self.empty_permitted and not self.has_changed(): return self._clean_fields() self._clean_form() self._post_clean()def _clean_fields(self): for name, field in self.fields.items(): # value_from_datadict() gets the data from the data dictionaries. # Each widget type knows how to retrieve its own data, because some # widgets split data over several HTML fields. if field.disabled: value = self.initial.get(name, field.initial) else: value = field.widget.value_from_datadict(self.data, self.files, self.add_prefix(name)) try: if isinstance(field, FileField): initial = self.initial.get(name, field.initial) value = field.clean(value, initial) else: value = field.clean(value) self.cleaned_data[name] = value if hasattr(self, 'clean_%s' % name): value = getattr(self, 'clean_%s' % name)() self.cleaned_data[name] = value except ValidationError as e: self.add_error(name, e)def _clean_form(self): try: cleaned_data = self.clean() except ValidationError as e: self.add_error(None, e) else: if cleaned_data is not None: self.cleaned_data = cleaned_data 看了半天源码发现，里面的name要和Form里面的name相同 python的小坑python是没有select/switch语句的，为了避免很麻烦的if-elif-else，可以采用{condition:value}[statement]近似替代select/switch语句，这个小坑在于，所有的condition:value都会被求值，所以一方面会降低性能，一方面要考虑副作用的问题了。 字符集的小坑request.GET.get得到的参数是unicode，必须先转换类型才能使用哦 HttpResponse的小坑HttpResponse不能正确处理array object的情况，例如下面的代码是不能得到正确的结果的哦：123456789return HttpResponse([ &#123;'name':'TP', 'value':assessmodel.TP&#125; ,&#123;'name':'TN', 'value':assessmodel.TN&#125; ,&#123;'name':'FP', 'value':assessmodel.FP&#125; ,&#123;'name':'FN', 'value':assessmodel.FN&#125; ,&#123;'name':'P', 'value':assessmodel.P&#125; ,&#123;'name':'R', 'value':assessmodel.R&#125; ,&#123;'name':'F1', 'value':assessmodel.F1&#125; ]) 运行发现前端得到的是这样的数据：解决方案是当遇到对象数组的时候使用json.dump()函数将它转化为json，然后返回application/json格式的HttpResponse，如return HttpResponse(json_stuff, content_type =&quot;application/json&quot;)，当然千万注意前端ajax拿到data之后就不要eval了。 转义Django和Angular等框架合用需要注意转义：openblock { %closeblock % }templatetag openvariable { {templatetag closevariable } }openbrace {closebrace }opencomment { #closecomment # } Angular的问题这边顺便说一下Angular和jQuery混合使用常犯的一个错误：12345678910$.ajax(&#123; url : '' ,data : &#123; &#125; ,async : true ,success : function (data, textStatus) &#123; $scope.data = data &#125;&#125;) 如上代码$scope是不能更新的，因为success函数不在angular的名字空间里面了。 Python urllib2的问题使用以下代码抓取网页123456def getHtml(url): req = urllib2.Request(url) req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0') page = urllib2.urlopen(req) html = page.read() return html 发现报502错，这时候检查一下自己的翻墙软件是不是全局代理，这边我的Shadowsocks开启了全局代理，urllib2就不能抓https://127.0.0.1:8091了，502报错1urllib2.HTTPError: HTTP Error 502: Server dropped connection Django + Nginx + Https这里有一个非常大的坑，如果使用本机调试的话，千万不要选择localhost，而应该选择127.0.0.1.因为localhost可以是[::1]也可以是127.0.0.1，详见 这里 和 这里如果使用了localhost，那么会造成1min左右的加载问题，最初我以为是static files的问题，后来查看了error发现是 *24 upstream timed out (10060: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond) while connecting to upstream, client: 127.0.0.1, server: localhost ，这种问题一般都是写了localhost。–推荐以下blog http://www.ziqiangxuetang.com/django/django-models.html]]></content>
      <tags>
        <tag>python</tag>
        <tag>web</tag>
        <tag>前端</tag>
        <tag>django</tag>
        <tag>angular.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钢筋混凝土学习]]></title>
    <url>%2F2015%2F10%2F20%2F%E9%92%A2%E7%AD%8B%E6%B7%B7%E5%87%9D%E5%9C%9F%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[土木工程这个学科啊，excited。特别是钢混这门课，总是学的有点迷糊（虽然我最后考试满绩）。我觉得钢混这门课学好大概有三件事，第一是理解清楚钢筋与砼这两种关键材料的性质，这些性质决定了我们设计的原则；第二是掌握承载能力的计算方法，对于梁的抗弯、抗剪，柱的抗压等构件的计算方法；第三是理解建筑设计的一般原则，将构件组成结构之后需要注意哪些方面。如果说还有一点就是实际设计截面时要注意一些构造要求，比如说弯起钢筋的排布，或者对钢筋排数和直径的限制。但这些都是次要的，主要的就是三件事情，因为这些原则它们的目的都是统一的，就是为了发挥钢筋混凝土这种材料的最大性能。 材料性质首先是钢筋与砼的性质，有一大串的指标：理解这些很重要。 混凝土部分混凝土的强度混凝土立方体强度等级fcu,k其中下标cu表示立方体，k表示标准值。立方体抗压强度没有设计值，在标准条件测得。标准条件：温度20℃±2℃，相对湿度为95%以上养护20d。这里有一个标准值和设计值的区别要看清楚。 荷载标准值k就是设计时要比它大。荷载设计值就是标准值乘以分项系数γ。一般地，恒荷载γg=1.2，活荷载γQ=1.4。同理，材料强度设计值等于标准值除以分项系数。例如混凝土轴心抗拉强度设计值ft=ftk/γc，其中γc=1.4。 标准试验方法需要注意： 加载速度越快越高 试验方法涂抹润滑剂会导致横向变形更容易，因此更容易破坏 尺寸效应小尺寸测得抗压强度要搞 其他强度fck 轴心抗压强度，和立方体抗压强度fcu,k之间存在公式转换。能更好的反应实际抗压能力。ftk 轴心抗拉强度，通过劈裂实验测量 混凝土的变形变形模量 原点模量（弹性模量）$ E_r $：应力应变曲线上过原点的切线。 割线模量$ E’_c $：应力应变曲线任一点和原点的连线。 切线模量$ E’’_c $：应力应变曲线任一点和原点的切线。 徐变徐变具有两面性： 优点：有利于结构内力重分布，减少外界因素对超静定结构的不利影响，降低附加应力 缺点：引起结构变形增大，导致预应力损失、结构破坏、徐变特点：加载越早、水泥越多、水灰比越大，徐变越大。骨料越坚硬弹性模量越高（对水泥徐变约束大）、养护时温湿度越高（水化充分），徐变越小。受到荷载作用后温度越高湿度越低，构件尺寸越大（失水受限），徐变越小。 混凝土本构关系可参考教材 混凝土的破坏一般混凝土的破坏指达到极限压应变 钢筋部分钢筋破坏有明显流幅（屈服台阶）的钢筋计算时以屈服点作为强度限值，没有明显流幅或屈服点的，取残余应变的0.2%对应的应力作为条件屈服强度标准值。同时对钢筋极限拉应变也有要求 钢筋本构关系钢筋与混凝土协同工作光面钢筋粘结力的形成因素：胶结力（水泥浆体对钢筋表面氧化层的渗透）和摩阻力（混凝土收缩）变形钢筋粘结力形成因素：机械咬合作用 混凝土保护层的作用 防止纵筋锈蚀 火灾情况下减缓钢筋温度上升 钢筋和混凝土更好粘结 梁的正截面承载力设计适筋梁破坏三阶段这个将来会做实验看到 I阶段：混凝土未裂阶段 Ia阶段：可作为受弯构件抗裂度计算依据 II阶段：混凝土带裂缝工作阶段 可作为正常使用阶段盐酸变形和开展宽度的依据 III阶段：破坏阶段 梁的正截面破坏形式此处可以对比柱的五种破坏形式 适筋梁适筋梁的破坏是塑性破坏，始于受拉区钢筋屈服，这时候受压区混凝土还未达到极限压应变。 超筋梁超筋梁的破坏是脆性破坏，始于受压区混凝土的压碎（达到极限压应变），此时钢筋还未屈服。 少筋梁少筋梁的破坏是脆性破坏，始于受拉区钢筋迅速屈服并进入强化阶段。对于这种破坏裂缝往往集中出现一条，宽度和高度都比较大。 梁的抗弯设计梁的抗弯设计相对比较简单。主要是考虑钢筋拉力T，受压区混凝土的均布力C（拉区混凝土相对于钢筋可以忽略不计）和弯矩M的平衡。此外还要避免超筋和少筋破坏。 梁的抗弯设计所做的简化的假定 五个基本假定 平截面假定 不考虑混凝土抗拉 混凝土受压应力应变曲线 注意和前面的本构关系比较，发现两者并不相同 钢筋极限拉应变取0.01 等效矩形应力图 受压区混凝土理论应力图形较难计算，这里等效成矩形，可以方便地得到C的大小和作用位置，同时引入了系数$ \alpha_1 $和$\beta_1$。 常用符号以及解释 符号定义 意义 $ A_s $ 纵向钢筋总截面面积 $ a_s $ 下部受拉钢筋合力点到截面受拉区边缘的距离 $ h_0 = h - a_s $ 下部受拉钢筋合力点到截面受压区边缘的距离 $ \rho = \frac{A_s}{b h_0} $ 配筋率 $ x$ 混凝土受压区高度 $ x_c $ 中和轴高度/受压区理论高度 $ \xi = \frac{x}{h_0} = \rho \frac{f_y}{\alpha_1 f_c} $ 相对受压区高度/配筋系数 $ \xi_b = \frac{x_b}{h_0} $ 界限受压区高度 $ \alpha_1, \beta_1 $ 受压区等效矩形应力图系数 $ f_y $ 钢筋抗拉强度设计值 $ f_c $ 混凝土抗压强度设计值 $ M_u $ 截面受弯承载力设计值 基本方程$$\alpha_1 f_c b x = f_y A_s \\M_u = f_y A_s (h_0 - \frac{x}{2}) \\M_u = \alpha_1 f_c b x (h_0 - \frac{x}{2}) \\$$以上方程可以暴力解 快速计算]]></content>
      <tags>
        <tag>土木工程</tag>
        <tag>钢筋混凝土</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo常出现的配置问题]]></title>
    <url>%2F2015%2F10%2F19%2FHexo%E5%B8%B8%E5%87%BA%E7%8E%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[在配置Hexo的时候常常会出现一些问题，比如hexo d无法部署，tags不自动生成，评论不正常显示等问题，本文给出了一些解决方案 HexoHexo（Hail EXO，好吧这个我瞎编的）是基于nodejs的静态博客构建工具。由于Ruby的蜜汁信仰问题（而且windows下Ruby有点坑），我弃Jekyll投Hexo。配置方法烂大街，这里不提了，可以去https://blog.lmintlcx.com/post/blog-with-hexo.html 这里看看。这次主要说一些可能遇到的问题。 常见错误git问题 常见错误1event.js:72 throw er;// Unhandled &apos;error&apos; event 常见错误2Error: fatal : Not a git repository (or any of the parent directories): .git 解决方法：检查自己的.git文件夹是否在.deploy_git下，否则重新git init tags问题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http://www.calvinneo.com/tags/ 不能正常显示tag 检查是否安装了必须的包 我们可以使用npm ls --depth 0来查看依赖。 1234npm install hexo-generate-index --savenpm install hexo-generate-tags --savenpm install hexo-generate-category --savenpm install hexo-generate-archive --save 检查是否配置了tags页面 检查/.deploy_git/tags下是否有index.html，这个是不会自动生成的，在命令行输入： 1hexo new page tags 该命令/source/tags/目录下新建了index.md。打开文件，键入或修改： 1type: "tags" npm故障 可能会出现如下故障: TypeError: Cannot read property ‘latest’ of undefined hexo 这可能是因为已经安装了以上npm包，所以不需要重复安装了。建议在hexo init后直接npm install即可。 NexT主题问题使用多说由于某些NexT主题使用多说插件有一些小注意点，比如说有些文章“喜欢”之后的分享转进来的链接是yoursite.com这个域下面的。打开duoshuo_shortname.duoshuo.com发现这些文章的地址也是yoursite.com。这个有三点原因： 检查site和theme的两个_config.yml中，是否url字段配置成自己的域名。 一旦同名文章添加进多说，其地址不会再次更改，因此要将多说中的文章先手动删除一下。 还有一种原因是文章的标题变动了，对于这种情况可以先hexo clean，再重新生成并部署。注意这时多说后台会生成一个新的文章，旧的文章并没有被替换。 设置网站的favicon值得一提的是有一个方便的设置favicon的方法： 将所需图片如favicon.jpg复制到source下 在网站的_config.yml下输入1avatar: /favicon.jpg sitemap网站地图12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 可能产生错误： duplicated mapping key at … path: baidusitemap.xml这是yaml的语法问题，比较简单的方法是直接去掉两个path中间的一个，每次只生成google或baidu的sitemap。当然你也可以把path缩进一下，这样就可以了。 Hexo s 命令不能在本地调试首先检查是否安装了hexo-server。其次不要在config里面显式用plugins指定插件。 vendors文件夹无法访问vendors里面主要是脚本等东西，缺少之后网页无法显示。f12看到整个vendors里面的东西都404了。然后我在一个新建文件夹新建了文件/test/1.txt并deploy，发现以下错误：既然确定了是github抽风了，就将网站搞一份到coding.net，可以使用下面配置：12345deploy: type: git repository: coding: git@git.coding.net:calvinneo/calvinneo.git,coding-pages github: https://github.com/CalvinNeo/calvinneo.github.io.git,master 这边特别注意，里面一定要用空格而不是tab缩进。然后更新dns，之前因为github不稳定，我常常使用ss代理访问，但是代理的dns不一定立即更新，鉴于目前在国内网站coding.net重新部署了，可以直接访问www.calvinneo.com2016年11月10日更新：部署到coding之后vendors又被禁了。真是醉了，后来想起来蒲神给我看了这个issue，从github下了最新版本的next，这个问题解决了，FYI，我原来的版本是5.0.0。值得注意的是蒲神也是next，一次没坏过（无敌了）。然后在配置新版本的_config.yml的时候发现现在next可以支持MathJax和busuanzi了，之前我还一直手动的。 管理git文件夹hexo cleanhexo clean语句相当于重新init下git文件夹（这里应该是之前说错了，hexo init是这样的，但是clean只清空缓存，是安全的），所以所有的历史会全部消失，因此需要慎重。如果仅仅是为了清理，可以选择对.git进行rebase等操作 压缩图片如果git中跟踪大体积的图片会导致git文件夹变得很大，而有的托管网站的容量实际上是有限制的，所以应当将图片压缩，软件Antelope是一个简洁易用的压缩图片工具 icon和avataricon和avatar是不一样的，icon是favicon.ico决定的，显示在浏览器标签页的最左边（chrome），avatar是在_config.yml里面指定的，显示在侧边栏。 给Hexo(NexT)加上搜索功能swiftype是大家都推荐的工具，我用了之后各种资源加载不了，而且他还是一个收费的工具，于是我换成了Local Search根据https://github.com/iissnan/hexo-theme-next/pull/694上的介绍可以添加配置，还是非常简单的但是配置完成之后发现并没有弹出搜索窗口，显示的是javascript:;，然而根目录下的search.xml是存在的。后来f12发现是我在站点的配置文件中的swifttype_key字段没有注释掉，于是相当于现在还是使用的swifttype搜索，于是注释掉之后重新hexo g，再hexo s就出现搜索框了 MarkDownMarkDown表格写法12345678&lt;!-- 上面一定要空一行 --&gt;| 表头1 | 表头2 | 表头3|&lt;!-- 下面冒号表示对齐方式 --&gt;|:-|:-:|-:|&lt;!-- 下面开始内容 --&gt;|a|b|c||d|e|f| 效果是这样的: 表头1 表头2 表头3 aaaa bbb cc d ee fff Hexo中md文件转义的问题这可能是某篇文章有字符未转义，出现解析错误 MarkDown存在的Bug有些MD格式会出现Bug，例如在列表项里面的表格因为必须没有缩进，所以会破坏列表项的连续性，表格后的列表项会从1开始重新标号。有的时候一段列表之后的新段会具有和列表项同样的缩进，即使中间插入了若干空行。 MathJax使用MathJax首先要将hexo的_config.yml和next的_config.yml都设置为true。然后next的_config.yml是默认给出了一个cdn去加载，但是我希望能够从本地加载（家里断网了），并且希望能够在用到的时候（流量有限）再加载这个模块。 配置本地的MathJax根据这篇博文，解压下来居然有50M，真是吐血！后来听从博客，放到theme的source目录下面的js里面了。 配置可选的MathJax加载方式根据这篇博文和这篇博文，在/themes/next/layout/_scripts/third-party下面找到了mathjax.swig。swig表示这里是使用的swig模板语言（有的是使用的ejs模板语言）。然后改成这样 123456789101112&#123;% if theme.mathjax.enable &amp;&amp; page.mathjax %&#125; &lt;script type="text/x-mathjax-config"&gt; MathJax.Hub.Config(&#123; tex2jax: &#123; inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true, skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'] &#125; &#125;); &lt;/script&gt; ...&#123;% endif %&#125; 注意swig模板语言不能在\{\% if \%\}块里面嵌入\{\% inlcude \%\} hexo部署本地MathJaxnode内存溢出在配置的时候我一开始是把它放在/source/cdn/mathjax/目录下面的，我以为是这个原因，后来完全去掉这个模块还是不行，生成的db.json有150M炸了。后来发现还真是因为那个文件＋太大了的原因，导致第一次出现了Template render error: (unknown path)错误，然后因为db.json生成太大了，下面再读取这个db.json的时候内存就直接爆炸了。而我移除模块之后，还要再clean一下，把那个超大的json去掉才行。后来发现得放在theme/source/js里面。然后最好还要设置一下hexo的_config.yml里面的skip_render，这个使用来跳过渲染的，否则hexo回自动帮你渲染页面。下面方法来自这里 单个文件夹下全部文件：skip_render: test/*单个文件夹下指定类型文件：skip_render: test/*.html单个文件夹下全部文件以及子目录: skip_render: test/**多个文件夹以及各种复杂情况： 123skip_render: - test1/*.html - test2/** 静态文件过多在把MathJax放在theme/source/js里面以后在windows下hexo s发现：1Error: EMFILE, too many open files 出现以上的错误信息，目前还没有找到解决方法。 Hexo Mathjax转义部分LaTeX符号需要进行转义输入 LaTeX Hexo+LaTeX \ \\ \\ \\\\ _ \_ {, } \{, \} * \* SEO从这里看到可以在百度/谷歌“认领”自己的站点注意在验证时需要将一个html文件放到网站根目录下面，但无论是填写skip_render还是12layout:false--- 都做不到这点，后来发现对于next主题，放到主题的source文件夹下面就可以了。当然也可以走DNS验证，或者修改主题，在上面加上meta标签。]]></content>
      <tags>
        <tag>前端</tag>
        <tag>git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCPC2015小记]]></title>
    <url>%2F2015%2F10%2F19%2FCCPC2015%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这周末(Oct 17-18 2015)，第一次参加了ACM类的比赛，感触颇深，小记一番。 这次比赛是第一届的ACM国赛，充满着对目前ICPC区域赛的怨念（开幕式上各种高级黑）不过也造福了长春赛区的ACMer们（榜惨不忍睹，好可惜我们没有拿到长春的名额啊），和我土力学实验、校庆志愿者、毛概实践课、计算机等级考试都重起来了，一天之内怒请五个假。晚上和张老师去火车站和阿洁哥良哥他们汇合，然后就是不出意料的火车晚点，不出意料的CCPC专列（上海到南阳的K1106），不出意料的上铺很冷，不出意料地发现自己身高不咋地。早上的Face++神牛们的会被我们睡过了，下午开幕式之后直接热身赛，三条题目。A题Googol String（这次比赛Google命题）意思是要找一个特定生成的二进制字符串序列的第Googol项。这条我一开始的思路是把它的每一项理解成一个序列，然后求出他的通项公式。后来良哥找到了循环节 (001 0) (110 0) 顺着这个思路想下去将每组中的第四项提出发现依然具有相同的循环节(001 0) (110 0)。这条AC。B题New Years Eve给出了如下的酒杯排布123456789第1层 1第2层 1 2 3第3层 1 2 34 5 6 这条最后硬上模拟做了出来。第二天是正式赛。12条。签到题两条L和A。L的意思是一串瓶子都相同，里面的东西不同，问如何用最少的瓶子去区分。答案显而易见，就是把瓶子摆成一个对称的形状，这样无论拿正拿反都一样了。如 D-C-B-A-B-C-D 答案就是2n+1。不过因为我们当时题目意思没理解对，导致一直不敢交，白浪费了20min。A题就是两个2x2矩阵 a b e f c d g h 叫你判断旋转之后是否相同，其实只要硬写四个if就好了。当时搞了两个数组，反而复杂了，WA了两次。不过因为这条我体验了一把主敲和现场A题的滋味。爽。下面是H，二阶数独，阿洁哥A了。我和良哥讨论CDG三条。C题是在一个1000长度的串N中找出所有的上升子列，问有多少种方法，这一条现场把case由10个增到了100个，按照朴素的N3算法，达到了1011的计算量，后来良哥又想了个N2LogN的算法，不过还是有109的量，良哥觉得并不能在1s内解决（不过仔细优化下应该还是可以的，我记得当时对面的陕西师范大学的人说这条题目卡常数，应该他们也是这个复杂度类的），不过题解说是N2复杂度就可以了，这具体怎么做，还不是太明白的。D题是一个扩展的背包问题。意思就是把一些线段（golden stick）去覆盖另一条线段（container segment），不过多了一个限制条件，也就是这些golden stick可以有一部分超出container segment的外面，只要整个的重心在里面。如图所示： 这条良哥先提出一个想法，G是这次比赛最蛋疼的一条，因为它真的很简单，我们的思路很清晰，然后中坑的也是这一条，WA了7次。先说题目就是围棋，问走一步能不能吧对方的棋子吃掉。这一条的思路就是BFS/DFS找出所有的连通分量，然后逐个棋子检测有多少个“气”。我们错在后来的优化上面，忽略了多个棋子可能公用一个“气”的情况，直接把每个棋子的“气”加起来看大于不大于1。赛题说完了，谈一下比赛的一些感受。首先是学习到了一些经验，比如说弱队看着榜选题A，比如说ACM的一些专用的调试工具，比如说切题的一些技巧。其次是失败的原因。首先我们学校这方面不是很强，对，不过这次也不至于输的这个憋屈吧？南大女队都比我们高到不知道哪里去了。究其原因我觉得我们还是在简单题上，没有做好，难题，我们确实不会，不过别人也不会，6A就可以上银牌区，4A就可以上铜牌区，而AGHL都属于签到题，CDK也是属于有时间可以想出来的题目，有难题，像BIJ，但是全场AK也就SJTU一个。所以我们差在哪里。签到题L，别人2min过，我们20min才过，为什么呢？只是一个对称的构造，原理很简单，但是我们一直在怀疑自己的判断 。接下来签到题A，WA了三次？为什么呢？代码写错了。为什么代码写错了呢？一个简单问题，用了一个比较复杂的方法来做（用了数组，WA的话可能是wrap上问题）,换成简单的实现就可以了。其实题目没这么难。 最后给出zhihu上面的评价 http://www.zhihu.com/question/36617747?rf=36617203–未完待续–PS 其实我只是先先看看这个模板效果23332016-12-04 我决定不续了，马上都退役了]]></content>
      <tags>
        <tag>ACM</tag>
        <tag>CCPC</tag>
        <tag>现场赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[厦门游记]]></title>
    <url>%2F2015%2F10%2F08%2F%E5%8E%A6%E9%97%A8%E6%B8%B8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这篇游记是在写完敦煌游记之后补写的，原因是和菡姐聊天时她觉得每个人的旅游心态都不一样，她比较喜欢安静闲适地坐着吃吃喝喝，但是我好奇心重精力旺盛喜欢到处跑。我觉得她说的挺对的，每到一个地方我都恨不得长出十双眼睛二十副耳朵去看去听，恨不得一天有三十六个小时让我玩。继而我又发现把自己的见闻记录下来是非常重要的。 这次旅行是在国庆期间，也就注定了其劳民伤财的特性，不过最后算了一算居然只用了3000多块钱。特别幸运的是我们出发前几天天气预报说有台风要经过厦门，可我们玩的几天除了云比较多一直没有风雨，还是特别幸运的。 Oct.1 长三角一日游去的时候是乘坐的动车，车次我现在都记得D3135，在这趟车上足不出户就完成了一次江浙沪闽一日游，因为它从南京经上海到杭州再到宁波，在一路南下到厦门北站，几乎经过长江南岸所有的长三角城市和东部沿海城市。过了宁波之后山开始逐渐变多，用手机上网体验也越来越差，经常忽的列车进了一列隧道。然后蜂窝网和GPS统统没用了，幸亏我在三星手机上下了一些电影，可以看着玩。快经过温州的时候看到下面居然有人建了一个缩小版的天安门广场，非常有意思。不知什么时候上来的一个无座的大叔开始课前面的回家的妹子们聊了起来，大叔是jiangjiu（漳州）人。当列车穿过一条极长的隧道后，前面的妹子们欢呼起来，胡建省到了。福建省感觉比浙江的地形更为“奔放”，而且水变多了。到了厦门北站，茫茫多的人，排了一会队才买到BRT的票。我们坐BRT到第一码头的终点站（中间还被骗在前面一站下车），然后转乘公交前往科技中学站，最后到达位于曾厝垵（后来知道是个景区，卧槽我们居然住在景区里面）的旅馆。厦门的BRT以高架为主，双向两车道专供BRT行驶，感觉很吊。一路上厦门的空气中弥漫着一股热带水果的味道，一个叫鹭江道的地方特别明显，这让我影响十分深刻。我们的旅馆叫三个厦大人客栈。住三晚，共600块钱，从后门出去就是曾厝垵夜市一条街（第二天晚上我们发现其实是夜市一条迷宫）。我们靠着夜市出门吃了厦门著名的沙茶面，沙茶面感觉就和海鲜杂烩一样，里面会有不同的牡蛎、虾、豆腐干子，酸甜酸甜非常好吃。 Oct.2 厦门大学早晨在旅馆门口的饭店吃了顿简易的早餐，和饭店老板租了辆自行车，真他妈贵啊。到了厦大好家伙，进门先要排队，排到途中有人说交多少钱帮我们插队，加上我们有自行车，所以也顺便请他给我们看一下车。交了钱于是他把我们带到一个人稍微少一点的队尾，然后我们继续排队。不过总算是进去了。伴随着逛校园的当然是敲章啦，来厦门玩的年轻人不会错过在各个景点小店敲章的机会，无论在厦门岛上还是鼓浪屿上，无论是商店、景点、KFC、旅馆、邮局、新华书店，只要你能想到的，甚至鼓浪屿上的派出所都有章可以敲。在厦大我们买了一个抓们用来敲章的本子，上面记载了一些明确提供敲章服务的地点，不过还有一些例如派出所是要自己去开发的哦。厦门大学与集美大学同为陈嘉庚先生所创，其建筑风格以中西合璧为特色，也就是俗称的“穿西装戴斗笠”。最为明显的特点就是大量的白色黄冈眼、红砖、橙色大瓦片和海蛎砂浆等具有厦门特色的建筑材料。厦门大学的学生也住在这样精美瑰丽的房屋里面，我们在路上就经过了一栋公主楼，厦门大学的一个女生宿舍。厦门大学最有名的应该就是芙蓉隧道了。有点类似上海交通大学的隧道，隧道两面墙壁上是学生们的各种图鸦，天文地理无所不有，我们看到了大白、雷锋、习总、大圣归来的壁画，还有大一时让我们很蛋疼的工程制图。甚至在墙上还看到一个“禹”字，果断在下面拍了张合照。有意思的是，我发现隧道中有个地下室的大门上写着厦门大学“飞思卡尔智能车”工作室。在芙蓉隧道靠近终点的地方有一个1015咖啡厅，我们可以在店里敲一个芙蓉隧道的专属印章。出了芙蓉隧道居然就是厦大校门了！好意想不到啊，我们只得折返，走一边回头路。中午我们在厦大食堂吃了一餐，厦门大学食堂是对游客开放的，但是我们买会特别特别贵。接着我们去了厦大著名的操场。逛完厦大，我们去了对面超市买了些零食，考虑到在马上要去海边，我额外买了毛巾和拖鞋。从厦大出来已经是三点多了，傍晚我们出发沿着环岛路逆时针骑行。一路上上坡下坡真是累死了，关键是人特别多，有的时候得抱着车上台阶从栈桥上过，栈桥上的一些关卡一次只能通一个人，所幸过了曾厝垵之后人变得少了很多，并且骑行带变宽阔了好多，而且刷上了鲜明的红色。每骑一段路都会遇到服务区（没错，自行车的服务区），可以在这里休息上厕所感受沙滩。我们一直骑行到一个叫椰风寨的地方，然后往回骑行。回到曾厝垵，我们去了昨天看到的一家叫“高烤”的烧烤店，居然客满了，老板把我们带到一个很阴森巷子里面的另一块店面，在等了一会儿之后，我们终于盼来了一张桌子，这里的菜单叫烤卷，点菜叫开始高考。这里的菜也很是别致，他们没有酱，所有的食材都是预先经过腌制，放在纸盘子里面，老板说烤熟了就能直接吃了。我们尝了尝确实非常好吃，可惜量太少了，价格比较贵，人均要47块。吃完高烤，继续逛曾厝垵的夜市，大家突发奇想，进了一家酒吧。一进去妈的这酒吧真特么吵啊，里面的驻唱歌手和伴奏和声一个比一个响！坐在吧台的凳子上点了一些闹着玩的酒，菡姐点了一杯星空，感觉名字特别美，可是喝起来感觉一口一个小珍珠，非常难喝。接着大家开始玩真心话大冒险，问了菡姐一些感情方面的事情。吃完饭喝完酒后回到旅馆仍然不过瘾，商量着去演武大桥骑行。由于曹经文躲在旅馆不愿意去，所以只能我们三人出发，我们顺着环岛路往厦门大学方向走，这时候白天拥堵的人群少了很多，很快我们便到达了厦门大学。演武大桥是一座建在海面上的大桥，位于厦门大学的外侧。我们顺着大学路走顺着匝道上了演武大桥，不去不知道一去吓一跳，妈的演武大桥是个双向四车道的快速路，旁边没有自行车道的！我们只能沿着白实线外慢慢蹭，排队型拍照时，我们看着旁边车嗖嗖地飞驰而过不禁瑟瑟发抖，最难的是穿过有匝道的路口时，我们得不停给身后的车辆让路。在演武大桥上往右看就是厦门大学的白城海滩，虽然已经是晚上十一点了但沙滩上还三三两两地坐着情侣。查了查地图，眼看前面是和成功大道的一个立交，赶快从最近的匝道下来到演武路上。下了演武大桥，我们接着骑往明天要去的中山路。晚上的厦门还是比较安静的，我们从演武路顺着导航走，经过民族路到鹭江道上沿着海边骑往中山路。半路上在民族路附近，一条铁轨横穿马路，这是一个叫铁路文化公园的地方，感觉挺有意思的。后来知道这也是一个比较著名的景点，是用一条废弃的老铁路改造而成的。其实厦门岛上的主要景区（厦大、曾厝垵、中山路）等都离得非常近，很适合骑行。我们不一会儿就到了中山路。晚上的中山路显得特别安静，没啥好逛的。加上时间已是凌晨十二点，加上我们来时的的路比较寂静，有的小巷虽然有灯，但一个人都没有，让人感到挺害怕的，于是我们从中山路的东面走思明南路回宾馆。在思明南路我们又发现了铁路文化公园，原来这个公园是沿着老铁路的一条长4.5千米，宽十数米的公园，保存了厦门悠久浓厚的历史文化气息。回程又路过厦大西门，惊讶地发现厦门路边有像公交站台一样的24自动借书柜台，民众可以从任意借书点借书，并在其他的借书点归还，同时借书点还提供了预约功能。 Oct.3 中山路折腾了一个晚上，今天醒的有点迟。今天的行程是去中山路。厦门的建筑比较有特色，会在人行道上盖骑楼。中午我们在中山路吃了美团上有名的一家大块排骨锅。这个排骨锅很有意思，首先上来一个焖锅，里面是熬好的排骨，啃完排骨（大家都饱了）还可以往汤底里面当火锅加上不同的东西。中山路离第一码头不远，我们去第一码头查看了一下明天的船票，结果似乎第一码头只有厦门本市居民才能从那里乘船，我们还是得走我们套票上的东渡出发去鼓浪屿。来了厦门对一些店名会非常的有印象，例如张三疯奶茶店和赵小姐的店。我们下午对这些店进行了具体的考察。张三疯奶茶只有两种口味卖20块，其实相比它网红奶茶的身份，这价格并不贵，口感其实不错，不是特别甜腻，但也不是很突出。倒是里面的料大大的良心。我记得我的一杯奶茶至少三分之一的都是固体物质，特别是葡萄干，真的炒鸡炒鸡多！赵小姐的店主要是卖茶。还有一家叫黄远堂的凤梨酥，其招牌是祖传的手艺，绝对不加冬瓜。我之前从来没吃过凤梨酥，尝了尝感觉打开了新世界的大门，看一看价格，好贵好贵，一盒五枚要三十块，想想这家一直说不加冬瓜好像很不容易的样子，于是买了一盒。在中山路附近有一家大清一等邮局，它是一座类似外滩上的洋楼的建筑。邮局里面像个小商店，会卖各种小纪念品。既然来了邮局必须得盖一张邮戳，我们买了一张邮票，就可以贴在自己的小本本上盖邮戳了。我们在中山路一家阁楼店里面逛时，曹经文说有同学找他玩，于是他先走了，我们乘了一辆假的士回宾馆，路上又经过演武大桥。下午的演武大桥就没晚上那么恐怖了，实际上是堵得一塌糊涂，我们可以在桥上欣赏大海风光。晚上得知数学建模的成绩出来了，只拿了省二，很是伤心。我们在夜幕笼罩的海滩上开始准备觅食。晚上深入地逛了曾厝垵夜市，厦门的吃食是非常有特色的，除了之前吃的沙茶面，我们看到一种特别大的叫青芒的芒果，我之前都没有见过，于是我们买了好几个打算寄回去，老板说最少买六个才能寄，于是我合计了一下我打算买六个寄回家，后来回家称了称，妈的给我缺斤短两，折算下来只相当于淘宝上最贵的那种。海蛎煎给我的印象也特别深刻，它实际上就是将海蛎混入蛋饼中，再淋上特制的酱料制作而成的，吃起来非常地鲜美。还有一种非常常见的食物叫土笋冻，不过吃之前一定要做好心理准备，因为它并不是竹笋之类的东西，而是用一种叫沙虫（回来之后查了查应该是星虫，沙虫是以讹传讹）的虫子做成的。除了拼命逛街当然还要拼命盖章啦，鼓浪屿有些章也特别有意思，相同名字的连锁店，不同的店面的章也是不尽相同的，有一家叫一杯茶堂的店，它的章是一个狗头的雕塑，还有一家店它的章是用石头做的，像一座宝塔一样，特别特别沉。我们一直盖到十一点半，最后还剩一个叫芒果西番莲的店面，我们到达时那边已经关门了，于是非常遗憾地只能拍照留念。 Oct.4 鼓浪屿厦门岛上有个叫第一码头的地方，但是我们在美团上买的套票（175元包含往返船票、鼓浪屿景点联票以及两个额外景点选一）是要从海沧区的一个地方乘船去鼓浪屿。我们乘着公交车一路坐（堵）到海沧换成公交到达嵩屿码头，到了码头取票时发现鼓浪屿的门票得在厦门岛上取！大家当时都绝望了，打电话给美团那边的人，说到那边人安慰我们说到了鼓浪屿也是可以用自助取票机取的。乘坐轮渡真是痛苦的经历，我们背着全部家当和茫茫多的人挤在凉棚下苦等，站也站不得，坐也坐不了，非常蛋疼。等船靠了岸时间已经将近十一点了。因为鼓浪屿上住宿实在是太贵了，所以我们在鼓浪屿定了帐篷（这样还一个人50），到了内厝澳码头，我们直接奔赴租帐篷的人家寄存行李，房主是个女的，相当于是将自己家里拿出来做宾馆，但床位是一张一张的卖，而且特别贵，我们来的时候客厅里面已经挤满了人和行李。出了寄存行李的地方，这时候肚子里已经是饿得要死，我们决定先吃点东西再说，就在路边，山路旁边的一个小平台上，摆放了几副石桌石凳，于是我们就到哪里吃了个中饭。虽然环境简陋，可是那里的饭菜可是贵的一批啊。吃完饭就开始全岛晃荡着找取票的地方，我们一边找，曹经文一边逛沿途的各种店铺，最后终于找到了取票机。路上还经过菽庄花园，发现我们买的联票还不如直接用学生证单买。在鼓浪屿上我们吸食了一个叫百香果的水果，说是吸食一点不假，拿到手是一个石榴大小的果子，里面插着一根吸管，老板教我们来回搅动，然后用吸管吸出来的汁液，据说十分酸甜解渴，不过实际体验下来还是算了，水分真的很少……在琴园的时候我还15块买了个椰子吃了吃，感觉和家里面的也差不多，可惜不能砸开来吃椰肉。我和田韵决定先去玩近一点的日光岩。日光岩在晃岩路（路名感觉很巧妙啊）上，晃岩路非常好找，它旁边就是马约翰体育场的。如果你从那里出发一定不要错过派出所，是可以敲章的哦。日光岩又称晃岩、龙头山，是鼓浪屿的制高点，有着“不到日光岩就不算来过厦门”的俗称。日光岩的得名源自其顶部的一块巨石，据说这块巨石直径达到40米。我们从山脚下往上爬，经过日光岩寺、古避暑洞等景点。日光岩寺就是个山脚下的寺庙，我们都没怎么高兴去看。古避暑洞其实并不是一个山洞，而是两块岩石和地面相抵，形成的一个尚可通人的洞。过了避暑洞，继续往上走，到达一块岩石形成的较大平台，也就是日光岩的顶部。在日光岩的顶部建造有一个仅能容纳数人的观景台，称为“光复台”，通往观景平台的石阶又高又陡，只能容纳一人通过，但是我们还是勉强挤上了平台。从日光岩上往下看，鼓浪屿尽收眼底，对面的厦门岛也一览无余，鼓浪屿全岛的建筑风格和厦门大学有点类似，都是橙色的屋顶。据说在天气好的时候登上日光岩能够见到对岸的台湾岛。参观完了日光岩，从出口出来对面便是琴园的入口，进去之后有个百鸟园，我们正好碰上三点场的驯鸟表演。两只鹦鹉为我们带来了独轮走钢丝、跳舞、滚筒、套圈等演出。比较有意思的是最后演出人员会让我们拿出人民币，鹦鹉会飞到你拿里把钱叼走。有意思的是有人拿了一个皱巴巴的一元纸币，那鹦鹉飞了几次就是不飞过去，原来这鸟也是嫌贫爱富的呀！从百鸟园出来还可以往上走，当时只有我能爬的动，我便一个人爬了上去，上面英雄岩和听涛崖，还有一个关于殷承宗的博物馆，里面很少人。其中听涛崖是在海边的一块悬崖，据说是观看落日最佳的地方，不过我去的时候还是四点，太阳照的我眼睛有点睁不开，没看到晚霞。此外这里位于鼓浪屿最西南，也是登高望远的好地方，据说这里天气比较好的时候甚至可以看到对岸的漳州。地图上这里还有个景点叫鼓声洞，开始以为是一个和听涛崖一起的山洞，但事实上这是一个穿山的隧道！我们今天早些时候就是从这里来到了靠南的海滩上。菡姐下午因为一些原因身体不舒服，所以就先回旅馆了，没有和我们一起去日光岩玩。她和曹经文从菽庄花园出来，说里面有个关于十二生肖的景点可以捉迷藏，非常有意思。四点多的时候我们逛完琴园便去了菽庄花园。菽庄花园和日光岩比较相似，里面包含了钢琴博物馆、听涛亭、补山园、四十四桥等多个不同风格景点。从大门进去，绕过一道高墙，便是一个观海平台，一道石围栏将地势较高的菽庄花园观海平台和外面的地势较低海滨浴场隔开，既起到了分割作用，又不至于阻碍观赏美景，这是古代园林常有的开门见山的效果。再往南走不远就是四十四桥景点，四十四桥和二十四桥有点像，不过是环抱海边的一道桥或者栈道。走在桥上，蜿蜒曲折更有多个亭台点缀。朝西远望，落日下的日光岩尽收眼底，上面蚂蚁一样的人群还在往观景平台上奋力攀登，近看是一块巨大礁石上刻有“海阔天空”的书法，据说是明代大书法家所作，脚下海浪拍打着海岸，宛若在低语欢笑。在四十四桥上就看到了在山上的鼓浪屿钢琴博物馆，于是我们飞奔上去。钢琴博物馆分为两层，陈列有各式各样不同造型和年代的钢琴。鼓浪屿上的钢琴文化非常浓郁，据说每家每户都有一架钢琴。在钢琴博物馆我们看到了新老不一的钢琴，有的钢琴非常有意思，是成一个直角弯折过来的。还有很多自动演奏的钢琴，据说是先前贵族人家的主人如果热爱音乐又不会演奏钢琴，就可以在钢琴上装上打孔的纸带，用脚踩动，钢琴就能够自动地演奏出音乐。著名的音乐家殷承宗也是出生在鼓浪屿。在最后，讲解员为我们演奏了一曲《鼓浪屿之波》：“鼓浪屿对这台湾岛，台湾是我家乡。登上日光岩眺望，只见云海苍茫。我渴望，我渴望，快快见到你，美丽的基隆港”，这首歌表达了台湾人民对海峡两岸统一的愿望。菡姐提到的十二洞天的景点其实在补山园里面，它是一个非常大的假山，假山上有十二个山洞，错综复杂的明道与暗洞将上下左右的这些洞口相连，形成一道巨大的迷魂阵。十二生肖代表的动物雕塑就潜伏在洞口附近的石头中，需要耐心仔细地寻找才行。十二洞天是我见到过的规模最大的假山了，非常有意思。晚上住帐篷，洗澡变成了一件麻烦事，租帐篷的人很多，但是她家只有一个浴室，澡得排队洗。幸亏菡姐帮我们排了个队，我们只等了大概一小时左右吧。我排在四个人中的最后一个，其实我洗澡很快的，但是前面曹经文洗的比较慢，我才洗了三分钟，外面一个女声就开始碎碎念了，心里窝火，看把你猴急的样子，我说你要是急得话进来和我一起洗吧，于是她闭嘴了。经历了这次事件我们决定明天选择在中午或者下午洗澡，避开晚上的高峰时段。当然这里还是建议如果能够避免重大节假日还是尽量避免，这样能够获得更舒适的体验，否则你真的能够体会到什么叫人声鼎沸，水泄不通的！晚上曹经文和菡姐都很虚脱了，但是我和田韵还是很吊。于是继续在鼓浪屿上开始了漫漫的敲章（和帮菡姐曹经文敲章）之路。鼓浪屿的路非常有意思，有一些路走着走着就变成了一条巷子，有些路走着走着就进了一条隧道，有的路上静的怕人，但是侧面开了个两人宽的小道，从小道穿过霎时到了人声鼎沸的龙头路，更有走一段变个路名，原路要拐个弯才能到的情况。除了之前看到的晃岩路，还有一条龙头路，龙头路应该是鼓浪屿上最长的一条路了，一直通到海边的钢琴码头，在地图上看这条路并不是一条笔直的路，而像一棵树一样，这一片区域的所有路或者巷子都叫龙头路。值得庆幸的是，因为这里靠近海边，有KFC和一个蜡像馆，所以沿着主干道走倒也好找，并且这里也是鼓浪屿商铺（和美食）最为集中的地方，即使迷路了，随便逛逛也是挺有意思的。路上我们还看到一家店叫“联邦调查局”，进去一看原来是卖茶叶的。我们第一天在鼓浪屿从日光岩开始基本就是分头行动的！鼓浪屿偏西偏北的地势起伏比较大，有的时候也不能光看导航走，路线选不对就容易走山路，爬上爬下特别麻烦。这里推荐几个比较好的地标，第一个是马约翰体育场，因为它就挨着中华路边上，并且离菽庄花园也不远；第二个就是钢琴码头了，它靠着海边和龙头路，可以顺着导航从龙头路逛回来到这里集合。我们的帐篷在鼓浪屿的最北面海边的草地上，这里地势起伏比较大，景点相对来说也比较少，比较惨的是上厕所，这里离最近的厕所要走十分钟，关键是去了那儿那里居然不开放，我又得额外绕个几分钟，到了曾厝垵一个阴森的小巷里面上的厕所！我们在过去的路上意外看到有条路叫兴化路，这里的兴化不是我家，而是莆田的旧称啦。 Oct.5 鼓浪屿为了看日出，今天早上五点半就从帐篷里面爬出来了，顺着走到海边想看日出，谁知天公不作美，天上一朵接着一朵的云。今天早上的计划是去一个叫4D魔觉馆的地方，这是在美团上买门票送的一个景点。由于起的特别早，我们也无处可等。中途我们看到一家教堂三一堂。三一堂也是厦门最富名气的教堂，是情侣们在厦门举办婚礼的首选地点。走到这里时我们实在太困，就靠着旁边的一家锻炼器材的地方睡着了。去魔觉馆的路上我们经过了一些非常漂亮的小巷子，有些巷子后来从照片上看到才发现它的美。魔觉馆是由一对夫妇开的，老板人特别和善，我们去的时候还没开门，他们亲切地招呼我们坐下，当知道我们从南京过来时，他们说年轻的时候去过南京，那里是个好地方，特别热闹，不过路程太远了。魔觉馆类似于蜡像馆，也是一个拍照片的地方。逛完魔觉馆，我们在一家叫做闽南疯古早小吃的地方吃了午饭，古早是闽南语，意思就是怀旧。这家店很有特色，不仅是贵，而且是先用人民币充值，换取刀币，然后在一楼的自助平台用刀币兑换食物。临走时我们又领了一份免费的海蛎煎。吃完便沿着龙头路瞎逛。一直逛到了海边，我们拍了些合照，快三点多跟了一个导游逛了逛毓园。从台阶上下到皓月后的一片海滨浴场和大海来了次亲密的接触。这里的风景和菽庄花园旁边的浴场应该是最好的了。从这里能够看到对岸厦门岛的世茂海峡大厦和演武大桥的地标。世茂海峡大厦是一座双子塔，其形状像两柄刀，也像两片竹叶，无论是在厦大还是环岛路，亦或是在鼓浪屿，它的出镜率总是特别高。最刺激的是乘着快艇冲浪了，快艇在琴园附近的海滩上乘坐，我们大概五点多到那儿，可是一艘要满六个人才能坐，我们真担心要四cover六时，正巧来了一对情侣凑成一艘。快艇要开了，司机师傅嘱咐我们把手机啥的收好，弄丢不负责，后来发现真是明智。快艇加速时感觉我们要从船尾滑出，转弯时船舷靠着水面，我感觉感觉船要翻掉一样，遇到波浪时快艇会陡然的一阵顿挫，特别爽。开到一半师傅说加点钱就带我们环岛一圈，果断答应（后来有点后悔后悔当时应该假装不答应，叫那个男朋友出钱，不过实在是太爽了）。冲完浪大家就准备回宾馆了，路上大家算了算开销，大概三千多，其实并不高。我们在一个类似于露天的花园式咖啡厅的地方，点了一些晚餐。九点多的时候由出来沿着海边晃悠了一圈 Oct.6 回程回厦门岛是从三丘田码头出发到东渡。到了岛上，我们乘坐火车站快线到达火车站，一下火车站司机便堵住我们问我们要去哪里，我没好气地说去南京你带不带。大家肚子都饿得咕咕直叫，大家都盘算着还来得及来不及吃还没吃过的海鲜了。最后大家还是跑很远的地方买了KFC。开始一天的长途高铁之旅。]]></content>
      <tags>
        <tag>游记</tag>
        <tag>厦门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arthurluk攻略]]></title>
    <url>%2F2011%2F05%2F22%2Farthurluk%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[arthurluk是高中（大概2010年暑假）matrix67介绍的一个智力游戏，当时是大神arrowrowe引进的，我们做到46关。后面是收集的一些攻略。新版html -&gt; php 1http://riddle.arthurluk.net/stageone.htmldon’t install 2http://riddle.arthurluk.net/snowflakes.htmlCtrl+A点右下角链接 3http://riddle.arthurluk.net/fruit.html观察图片中水果种类strawberry 4http://riddle.arthurluk.net/strawberry.html查看源代码, 最后一行cleverest 5http://riddle.arthurluk.net/cleverest.html查看源代码，发现16是p，于是明白数字n代表第n个英文字母。（这技巧以后会经常用）{16, 15, 3, 11, 5, 20}→pocketpocket 6http://riddle.arthurluk.net/pocket.html谷歌搜索”弹珠台秘技 无限弹珠”bmax 7http://riddle.arthurluk.net/snowman/windows.html那是哪个操作系统的标志？linux 8http://riddle.arthurluk.net/snowman/linux.htmlCtrl+A看到”有聽過甚麼是元素週期表嗎？”于是查询：Phosphorus是第15号磷，Lithium是第3号锂，Boron是第5号硼，Hydrogen是第1号氢，Silicon是第14号硅。得到{15, 3, 5, 1, 14}。查看源代码，发现提示用第五关方法。{15, 3, 5, 1, 14}→oceanocean 9http://riddle.arthurluk.net/snowman/ocean.html在图中发现五个字母：左上角s，中下方阴影里o，右下角礼盒上l，圣诞树中上方偏右的外部v，左下角esolve 10http://riddle.arthurluk.net/snowman/eraser.html标题栏”diagonal”，于是连对角线发现”continue”continue 11http://riddle.arthurluk.net/search/unsinkable.html宣称永不沉没之船沉没了——再看图片风格——立刻想到泰坦尼克。查询得知泰坦尼克沉没于1912年1912 12http://riddle.arthurluk.net/search/1912.html标题栏”What’s the song?”，于是查歌词，发现是陈奕迅的《1874》1874 13http://riddle.arthurluk.net/search/carol.html标题栏”I wish I can see Pets Not Giants”，发现首字母故意大写标出PNG图片网址”http://riddle.arthurluk.net/search/tiger.jpg&quot;，换jpg为png，打开&quot;http://riddle.arthurluk.net/search/tiger.png&quot;发现图片上的答案wingdingswingdings 14http://riddle.arthurluk.net/search/wingdings.html计算。3^12+659+8+2483=534202534202 15http://riddle.arthurluk.net/search/534202.html计算。4562*3+65536/256=1394213942 16http://riddle.arthurluk.net/search/13942.html查看源代码，发现提示”数字人生”（香港有个电台节目叫”数字人生”）查询”数字人生”（http://baike.baidu.com/view/1234166.htm）发现歌词中”534202 13942”测试下一行”13424”，错误然后发现下面还有一行”534202 13942”，测试它的下一行”43140624”43140624 17http://riddle.arthurluk.net/search/running.html熟悉网页应立即意识到”&nbsp;”是空格，空格的英文”space”恰为5个字母space 18http://riddle.arthurluk.net/search/excuse.html查询”71828, 18284, 59045, 23536, 02874”，发现它是自然对数的前5个5位截断（http://baike.baidu.com/view/11033.htm）于是用第6个5位截断71352 19http://riddle.arthurluk.net/number/morse.html地址中”morse”提示莫尔斯，查看源代码发现提示”if “”l”” represents “”-“””用”-“替换”l”得到”-i-i i-i i i- - i”据莫尔斯编码（http://baike.baidu.com/view/20024.htm）对照替换得到&quot;create&quot;create 20http://riddle.arthurluk.net/number/copycat.html地址”copycat”提示把图片另存为，用记事本打开后发现含明文字符串”The password is supply.”supply 21http://riddle.arthurluk.net/number/battery.html超链接（”Hyper Text Markup”意为”超链接”）中划去Lhttp://riddle.arthurluk.net/number/battery.htm 22http://riddle.arthurluk.net/number/battery.htm图片左下角发现”run! escape!”，去掉非英文runescape Oops!http://riddle.arthurluk.net/number/runescape.htm需要L回来http://riddle.arthurluk.net/number/runescape.html 23http://riddle.arthurluk.net/number/runescape.html“QWERTY”指键盘排序转字母序，例：O是第9个，对应第9个字母i{9, 19, 12, 1, 14, 4}→islandisland 24http://riddle.arthurluk.net/number/heartbreak.html查看源代码，发现提示”別說你沒有這個遊戲 :P”，联想地址”heartbreak”、说明”偷走你們的心”、图片纸牌，得到结论红心大战查询红心大战计分法（http://wenwen.soso.com/z/q89592561.htm）得到&quot;每张红桃1分，黑桃Q 13分”结合标题”addition”（加和），于是计算13+1*5=18，测试18，错误，测试eighteeneighteen 25http://riddle.arthurluk.net/number/pascal.html地址和标题都提示”pascal”，于是用pascal运行此代码得到44244424 26http://riddle.arthurluk.net/flash/tutorial.html查看源代码，发现”答案在下面”，到最下面一行发现”你好像誤解了我的意思”，领悟到指的是Flash的下面打开Flash（http://riddle.arthurluk.net/flash/flash.swf），调节比例（纵向拉长），发现&quot;The password is :champion”champion 27http://riddle.arthurluk.net/flash/stillflash.html要等3600s，足足1h，当然要跃过时间。发现无法跳帧，于是动用VB（因为VB最方便嘛 = =。）代码：（添加Flash播放器控件，命名S） S.Movie = “http://riddle.arthurluk.net/flash/wait.swf&quot; S.Play S.SetVariable “time”, 0发现”well… well…\nthe password is ATTIC”attic 28http://riddle.arthurluk.net/ballgames/snooker.html查看源代码，发现”Again, a=1”，于是寻找数字组地址和标题都提示”snooker”，于是查询斯诺克计分法（http://baike.baidu.com/view/5025.htm，相关术语&gt;&gt;彩色球）得到红1、白2、绿3、棕4、蓝5、粉6、黑7转换球得到{1, 3, 3, 5, 4, 5}→accedeaccede 29http://riddle.arthurluk.net/ballgames/accede.html查询”eagle par”（http://www.google.com.hk/search?hl=zh-CN&amp;source=hp&amp;q=eagle+par&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）立刻明白是birdiebirdie 30http://riddle.arthurluk.net/moon/essential.html第一个来月球的当然是阿姆斯特朗了armstrong 31http://riddle.arthurluk.net/moon/armstrong.html查看源代码，发现提示”Not mathematics but coordinates”（不是数学而是坐标）在图片中建立标准计算机坐标系（左上角原点，X正方向水平向右，Y正方向竖直向下）在底下那串数字里得到坐标（+为坐标间的分隔，-为X、Y间的分隔）检查每一组坐标对应的点所指向的字母，得到horoscopehoroscope 32http://riddle.arthurluk.net/moon/horoscope.html标题栏”A cartoon character”，查看源代码，图片对应”Who’s my owner?”联想到多来A梦的任意门doraemon 33http://riddle.arthurluk.net/checked/normal.html图片上一闪而过”REMEMBER THE PASSWORD: 69368549465021468008”（用截屏软件或者干脆(Alt+)PrintScreen再粘贴）69368549465021468008 34http://riddle.arthurluk.net/checked/advancedsearch.html标题提示”In Depth Battlepedia”、源码提示”NQII InSaNe Mode”、说明提示”no space, no capital”（无空格，无大写）搜索过程是枯燥的，就省略了。最终找到了此游戏的资源库（http://items.jellyneo.net/?go=show_items&amp;name=bow&amp;name_type=partial&amp;desc=&amp;cat=0&amp;specialcat=0&amp;status=0&amp;rarity=0&amp;sortby=name&amp;numitems=20）第二页的左下角就是这把弓，图片完全一致。名称是”Bow of Destiny”（去空格，去大写）bowofdestiny 35http://riddle.arthurluk.net/checked/bowofdestiny.html查看源代码，图片的Aim属性”Find the composer”（找到作曲者）查询”Sonata in E minor, Op.90”，发现作曲者是Beethovenbeethoven 36http://riddle.arthurluk.net/checked/hogwarts.html地址提示霍格沃茨，图片提示火车，源码提示”有 hogwartsone 即是有…”查询之（http://www.google.com.hk/search?hl=zh-CN&amp;safe=strict&amp;q=%E6%9C%89+hogwartsone+%E5%8D%B3%E6%98%AF%E6%9C%89...&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）找到（”http://zhidao.baidu.com/question/165484021.html&quot;）gillywater 37http://riddle.arthurluk.net/checked/gillywater.html标题”The soup of Sung”（宋家汤？）、输入框answerlength属性”6 or 7”、查看源码”Guess a food”查询”The soup of Sung”（http://www.google.com.hk/search?hl=zh-CN&amp;source=hp&amp;q=The+soup+of+Sung&amp;btnG=Google+%E6%90%9C%E7%B4%A2&amp;aq=f&amp;aqi=&amp;aql=&amp;oq=&amp;gs_rfai=）果然是罗宋汤。borsch 38http://riddle.arthurluk.net/express/love.html输入Romeo、Juliet不解释……计算得到24.5%24.5 39http://riddle.arthurluk.net/express/24.5.html谷歌地球发挥作用。查看25°2’1”N 121°33’52”E处，是台北taipei 40http://riddle.arthurluk.net/express/taipei.html标题”Vowel”，动用Notepad++复制文本进去，用正则”[AEIOU]”高亮全部结果，发现隐藏着的EXTRAextra 41http://riddle.arthurluk.net/express/extra.html标题”Keyboard caesar”，于是用CaesarCode加解密dyrq，均错误恺撒密码 后推三位联系Keyboard和第23关经验，于是用键盘顺序来作密表，加密dyrq得到hour 键盘后推三位hour 42http://riddle.arthurluk.net/express/hour.html标题意为帝国时代2，Ctrl+A看到”這建築物的英文名稱？”翻译铁匠铺得到BlackSmithblacksmith 43http://riddle.arthurluk.net/factory/mix.html地址提示”混合”，联想”巧克力、咖啡”得到摩卡咖啡（http://baike.baidu.com/view/8123.htm）mocha 44http://riddle.arthurluk.net/biologycity/entrance.html查看源代码，进入”http://riddle.arthurluk.net/biologycity/plant.html&quot;那个蘑菇（http://riddle.arthurluk.net/biologycity/mushroom.jpg）哪里错了呢？（它不是蘑菇，好像是树。。。）于是进入http://riddle.arthurluk.net/biologycity/tree.jpg，可是这里是草于是进入http://riddle.arthurluk.net/biologycity/grass.jpg，可是这里是蜗牛于是进入http://riddle.arthurluk.net/biologycity/snail.jpg，可是这里是鳄鱼于是进入http://riddle.arthurluk.net/biologycity/crocodile.jpg，可是这里是熊猫于是进入http://riddle.arthurluk.net/biologycity/panda.jpg大写字母要敏感的。。http://riddle.arthurluk.net/biologycity/troy.html 45http://riddle.arthurluk.net/biologycity/troy.html需要翻墙。。不解释。请跳到下一关 46http://riddle.arthurluk.net/highway/quest.html德沃夏克键盘… 47http://riddle.arthurluk.net/factory/fix.htmlorienteering43关是mix…不要说,查吧… 48http://riddle.arthurluk.net/factory/charlie/chocolate.html查理的巧克力工厂 49http://riddle.arthurluk.net/highway/calculator.html卡西欧 FX3650P 计算器 Mem clear : ? → A : ? → B : Lbl 1 :B ÷ A – .5 : Fix 0 : Rnd : Norm 1 : Ans → C :B – AC : Ans 10x D M+ : C → B :D + 1 → D : C =&gt; Goto 1 : M Find the output if A=5 and B=2007 也是很好算的 31012 50.1http://riddle.arthurluk.net/highway/fifty.html关键是“THIS TIME”直接在dvorak键盘上平移而不是转到普通键盘 发现和果然和上次41关一样，右移动3位，得到答案：truth 50.2http://riddle.arthurluk.net/highway/truth.htmlsilver.jpg 改为 gold.jpg 50.3http://riddle.arthurluk.net/highway/choice.html图的左上角 51http://riddle.arthurluk.net/highway/park.html数独，填出来是1942，中途岛海战,二战119 97 14 = war 52http://riddle.arthurluk.net/highway/secondworldwar.html保龄球 积分规则得到以下分数:7 9+10 10+10 10+8 8 10+10 10+10 10+10 10+10 10+8答案 187 53.1：http://riddle.arthurluk.net/samuelriddle/shadow.html看到那个括号了吗？仔细看，那个单词中有一个字母是错误的，改正它放入地址栏进入riddle 53.2：http://riddle.arthurluk.net/samuelriddle/riddle.htmlc c r a n e 能组成什么新单词呢？cancer(我弄了半小时!!!) 53.3：http://riddle.arthurluk.net/samuelriddle/cancer.htmlmspaint_a.png，把-a换成b.d.e.f.g…？一个一个的跳,直到h后把源码中所有mspaint_h.html全替换成空白 然后你看到一个网页，在右下角。。。mspeint_h.html 53.4：http://riddle.arthurluk.net/samuelriddle/mspeint_h.html这关就不为难你们了，需要专门的查看器，所以答案是muffin54关：http://riddle.arthurluk.net/samuelriddle/muffin.html察看图片吧 55关：http://riddle.arthurluk.net/chem_is_try/muffin.html原来这四个都是 欧盟的 危险品标识corrosive有害的harmful易爆的Explosive易燃的flammable首字母 55.2：http://riddle.arthurluk.net/chem_is_try/chef.html！！擦，同上一关类似~http://s2.hubimg.com/u/80145_f496.jpg 这是资料 55.3http://riddle.arthurluk.net/chem_is_try/beef.html希望你们还活着。。把XXXX改成txt，得到提示然后，1，听歌，2 谷歌它（元素周期表） 56关：http://riddle.arthurluk.net/chem_is_try/rubidium.html255汉诺塔。。。 57关： 微软雅黑所属的字体类型的名字Segoe Ui~~微软在Windows Vista和Office 12中放弃Windows XP中的Tahoma字体，转而启用新的Segoe UI字体，意在提高字体的可读性，使之更加人性化看图片名称，找出这个字体~是特有的哦~ 58关：http://riddle.arthurluk.net/escalator/segoeui.html1293，卡通人物 tiyilon=doraemon 59关：http://riddle.arthurluk.net/poker/chinese_horoscope.html罗马数字，生肖，首字母，我相信你知道的~ 60.http://riddle.arthurluk.net/poker/drop.html德国61.http://riddle.arthurluk.net/poker/germany.html一个日期(希特勒的生日)62.http://riddle.arthurluk.net/poker/hitler.htmlpiano(36个白,52个黑)63.http://riddle.arthurluk.net/goldengatebridge/obstacle.php看提示“此地不宜久留，請到圖所示的地方。”~~这是金门大桥呀~~再看网址http://riddle.arthurluk.net/goldengatebridge/obstacle.html ，其实的文件夹名就是金门大桥的意思，那剩下的obstacle是什么意思呢？百度之，原来是障碍~~那么，我们去掉障碍不就能到金门大桥了嘛~~于是输入http://riddle.arthurluk.net/goldengatebridge ，发现它跳了几次后跑到网站首页去了~~怎么回事？~~再看提示，“此地不宜久留”，哦，就是说要在它跳转的时候看代码~~于是多试几次呗，在跳转中不停地打开代码，直到你看到“你最後還是停了下來！”为止 64.http://riddle.arthurluk.net/goldengatebridge/flashgame.html这一关提示为“辛苦了這麼久，來玩個射擊遊戲吧！(Arthur：這關算是大放送XD)本關目標就是要找出 Final Boss 的名稱 (** Zombie)”，嗯，那就玩游戏吧~~只有几个要注意的，一是密码门那儿的密码就是门框上的不过要从右往左输；二是中毒后大左边的箱子，注意看会有个黑色的小东西出现，，打它得红卡，然后打右上按钮左边的黑线，即刷卡，然后依次打按钮即可~~最后要注意的是最终boss名字出现时间较短，要用心记~~嗯，最后出现的是“Limbless Zombie”意为无足的僵尸~~然后再注意一点，提示中已经给出Zombie了 65.http://riddle.arthurluk.net/goldengatebridge/limbless.html这一关咋一看我还以为是多少进制的呢，再一看代码，有个“ADFGVX cipher”，谷歌维基之，得ADFGVX密码~~是一战时候用的哦~~简单的说就是一个6*6的表格，行和列的表头都是ADFGVX，然后把26个字母和10个数字以一定顺序填入方框中，这样每个字母或数字都可以用如AD这样的坐标来代替(AD代表t)，读坐标时先读行再读列~~这样，题目“ADDDXF FXXFGXAD FGADAFGAXF AGFG GFAFAXADGGXDXF.DDADXAAG”就被翻译成了the next stage ls capture.html~~神奇吧~~不过里面有一处应该是is作者弄成了ls，应该是他错了~~ 66.http://riddle.arthurluk.net/goldengatebridge/capture.html 67.http://riddle.arthurluk.net/fortress/atmosphere.php看代码，里面有句“What is ISP in full name?”和一句“size=”20” maxlength=”20” answerlength=”23””~~意为答案是23为长度的ISP的全称~~百度，得Internet Service Provider~~输入internetserviceprovider，发现答案栏不够输，因为刚才代码中写了，最长范围为20答案有23~~于是输到网址中~~它说“答案就對了，不過你應把答案放到該放的位置。”~~看来还是要放到答案栏中~~怎么办呢？~~把源码保存下来，在本地自己用此源码新建个网页，改动action=”../check3.php”&gt;变为action=”http://riddle.arthurluk.net/check3.php&quot;&gt;，size=&quot;20&quot; maxlength=”20” 变为size=”23” maxlength=”23” ~~保存，打开，输入~~成功啦~~ 68.http://riddle.arthurluk.net/fortress/umbrella.html 69.http://riddle.arthurluk.net/fortress/vincentvangogh.html这一关其实就是个数学推理题，不过有点难度~~它问：ICQ+IQC+CIQ+CQI+QIC+QCI=WHAT，提示“WHAT is the answer”，于是计算呗~首先我们设2I+2C+2Q=XT，于是题目变成XT+10XT+100XT=WHAT~~我们用穷举法假设XT的所有可能，最后得出XTAHW=28013、83019、37014、73018、38124、83129、46015、64017、47125、74128、48235、84239、65127、57236、75238、58346、85349、76348、68457、86459、87569~~那么接下来就一个一个试呗~~我运气好，试第一个就对啦~~3108~~嗯，下一关 70. 72.http://riddle.arthurluk.net/fortress/bend.html盐…http://riddle.arthurluk.net/fortress/salt.html 73.http://riddle.arthurluk.net/fortress/sodiumchloride.phpNonogram游戏填充,是heart 74.http://riddle.arthurluk.net/marble/maze.phpbasketballhttp://riddle.arthurluk.net/marble/basketball.htmlJerry Alan Westhttp://riddle.arthurluk.net/marble/jerry.php这条是ascii和16进制解码 75.http://riddle.arthurluk.net/marble/chat.htm:題目為ひらえ うわ てを おそまけけふまそめ，由提示的伊呂波歌得下面歌詞：いろはにほへとちりぬるをわかよたれそつねならむういのおくやまけふこえてあさきゆめみしえひもせす並且由原始檔中寫的pic16.gif圖中看出A~Z&amp;a~z順序（Wedding字形），為縱行排序。將伊呂波歌依序填入1~47的空格，就可拼出”The pw is crossworD”（pw為password縮寫），故密碼為crossword 76.http://riddle.arthurluk.net/marble/exifforh人名 Aragorn Eowyn Gollum Théoden答案gate 77.http://riddle.arthurluk.net/sweater/english帝国时代答案 isolation 78.http://riddle.arthurluk.net/sweater/colour.php 79.http://riddle.arthurluk.net/sweater/royalblue.phpfind the director电影是mission impossible的海报导演brian de palma 80.http://riddle.arthurluk.net/sweater/briandepalma.php是纽约的夜景(联合国总部)答案 unitednations 81.http://riddle.arthurluk.net/sweater/unitednations.php香港童子军 答案 voyageraward 82.http://riddle.arthurluk.net/keroro/floppy.phpatbash密码 解码出来是notepad 记事本图片的名字为treasuremap.jpg,改成treasuremap.txt得到关于隐藏关卡的信息(aboutthehiddenstage.html),然后读到好几句话,每句话的字数:20,18,9,1,14,7,12,5;得到triangle 83.http://riddle.arthurluk.net/keroro/triangle.html图片名是tan.jpg,打开sin.jpg和cos.jpg得到fire love就是恋爱三要素和燃烧三要素 首字母来的答案honest 84. 一开始毫无头绪~~我查了标题triangle，是三角形的意思，还有一部电影也叫这个名字，恰巧我看过~于是输入导演名，不对~~然后看图片~我把图片后缀改成bmp、png、txt都不对~~又百度了图片中的Toblerone，是卡夫的三角形巧克力~~依然无头绪~~后来在卡了好久之后，我突然发现图片名tan不就是三角函数嘛~于是我试了sin和cos~出现心和火之类的~~我输入heart、fire这些都不对~~后来我突然想到会不会这回是要改前面的网址呢~于是我改成heart.php之类的，还是不对~~再后来我在打heart时突然想到会不会是heat温度呢？输入heat.php~显示“Partly correct.”部分正确~~然后我就无能为力了~~于是各种谷歌百度~网上有人提示“oxygen”氧气~~于是输入oxygen.php~~显示“Partly correct.”~~这时就有点眉目了~火燃烧的三个条件就是温度、氧气、可燃物~~于是看sin那张图~~试了好几次，最后发现是fuel~输入fuel.php~~显示“Partly correct.”~~对了，这时候注意到每个源文件中都有“That’s 1/6 of the answer”，也就是说我们还少三个单词~~好吧，继续百度，有大大说是passion激情~输入passion.php~~显示“Partly correct.”~~还有，这回出现的图片是船，前面分别是礼物盒子、急救车、问号~完全不知道是什么~~继续找大大~~有人说是“intimacy”亲密，出现一个圆~~又有人说是“commitment”委托，出现火车~~好啦现在6个全齐了~输入“heatoxygenfuelpassionintimacycommitment.php”~~竟然不对！~~我彻底疯了~~八成是要拆字~~好吧，我承认我拆不出来~~于是再去找大大~~得到提示“honest”~~输入，通过~~下一关http://riddle.arthurluk.net/keroro/honest.php ~~好吧，其实这一关我真的没干啥，全是在大大们的各种指引下才过的~真悲催~~唔！刚才洗澡的时候我突然地悟啦！~那个三角形中间套个火的图案其实在我们的化学书上见到过的，讲的就是火的三元素，所以才是温度heat、氧气oxygen、可燃物fuel~~那么那个三角形中间套个love的图案，讲的就是爱的三要素了~我百度“爱情三要素”，得到“爱情三角形理论”：美国心理学家斯腾伯格提出的爱情理论，认为爱情由三个基本成分组成：亲密（Intimacy）、激情（passion）、及承诺(commitment) ~~所以啦，那6个答案就都出来啦~~至于怎么把这6个答案合成honest~我现在还不知道~~http://riddle.arthurluk.net/keroro/honest.phphttp://riddle.arthurluk.net/keroro/angol.php 85.http://riddle.arthurluk.net/keroro/100000000000000.php在数字键盘上写字1478963456填上发现是A，9874123是C，852是I，74178621是D，9874123456是E，1475369是N，789852是T，合起来就是ACCIDENT哈~这一关一开始还真以为是什么找规律呢，结果看了好久也没看出个所以然来~~后来百度这些数字~~竟然被我找到了专门讲键盘加密方法的一个网页http://bbs.moyu8.com/home.php?mod=space&amp;uid=85626&amp;do=blog&amp;id=10751 ~~这个里面的数字键盘加密法，说白了就是在数字键盘上写字，怎么像怎么来~~于是我在数字键盘上把1478963456填上发现是A，9874123是C，852是I，74178621是D，9874123456是E，1475369是N，789852是T，合起来就是ACCIDENT意外事故~于是输入accident，通过~~下一关http://riddle.arthurluk.net/regular/recycle.php ~~86.http://riddle.arthurluk.net/regular/recycle.php这一关我的浏览器没发出声音，不知道你们的是不是~~不过我在源文件中发现了音乐的地址http://riddle.arthurluk.net/regular/stage86.mid ~~ 呃~但是我听不出来这是什么哎~~这就是从小没学音乐的后果~呜~~然后我用了一个在线录歌搜音乐的网站http://www.midomi.com/ ~~可惜还是没搜出来，这个网站主要是搜有人唱的歌的~~呃~于是我就只好在百度上搜“世界名曲钢琴曲”~然后一首一首的听~~终于被我听到啦~~是《土耳其进行曲》~~然后百度“土耳其进行曲”~得到是奥地利音乐家莫扎特Mozart于1781年至1783年间在慕尼黑或维也纳所作的~~于是输入mozart~~呃，竟然不对？幸亏我有没事就查看源文件的习惯~只见源文件中赫然写着“The next stage is in problem.php” 87.1http://riddle.arthurluk.net/regular/problem.php先看源代码，发现图片名为stage87pic1，于是好奇的输入stage87pic2，又出来一个图片~一共有5幅~~然后挨个儿看吧~~第一幅图片一开始我以为是什么游戏，后来猛然想到应该是元素，中间是质子，周围是一圈圈电子层~第二幅图片是一排数列？呃，这个彻底不知道，先放着~~第三幅图片是一个雪屋，大概是爱斯基摩人的吧~用百度翻译翻译雪屋，得igloo~这个有点小把握~~第四幅是一堆橘子，orange~~第五幅是扫雷游戏，可惜我家的这台电脑是中文版的，要是宿舍的那台英文版的就好了~所以只好百度，好像扫雷游戏的英文名是mine sweeping~~其实我一开始也愣了好久，后来才想到可能是用各个图片的首字母~~现在可能是是z?iom（？为一个任意字母，*为任意个任意字母）~~我用必应词典，输入z?iom~竟然没有！~~于是去掉最不肯定的z~~输入??iom~得axiom（公理）和idiom（习语）~~挨个试~~试到idiom时，终于对了，进入第二小关 87.2The grass is always greener on the other side，这山望着那山高http://riddle.arthurluk.net/regular/thegrassisalwaysgreener.php 88.http://riddle.arthurluk.net/regular/idiom.php点白色一团纸 89.http://riddle.arthurluk.net/eightynine.php 116.http://arthurluk.net/riddle/horror/quaver.php 117.http://riddle.arthurluk.net/revolution/mountain.php不要输密码框118.http://arthurluk.net/riddle/revolution/emptyfortstrategy.php 参考了以下的文章http://www.zhangshengdong.com/post/2012-03-17/15426274http://www.douban.com/group/topic/27282526/http://jilu.zhangshengdong.com/post/2012-05-30/40028636785http://www.sudokufans.org.cn/forums/topic/732/http://jilu.zhangshengdong.com/post/2012-05-30/40028636785和这个攻略 1:点击Don’t install. 2:Ctrl+A ，你看见了什么？ 3：查看图片的地址然后打开，知道是？ 4:打开源文件。 5:这个是字母表密码。 6:goole一下无限弹珠的游戏秘籍 7:与Windows齐名的另一款系统软件 企鹅系统？ 8:（元素周期表）先翻译成数字，再翻译成字母。 9:看见图上的字母了吗？我一直以为是loves 10:源文件老规矩看title “Diagonal” 11:泰坦尼克号：不沉的船还是沉了 12:百度一下你就知道（1874） 13:看见源文件中有一个Pets Not Giant.取首字母得PNG,拷贝老虎图片地址，将后缀名改成png便知秘密 14:直接算出来吧（534202） 15:直接算出来吧（13942） 16:数字人生（43140624） 17:空格？ 18:百度一下 自然对数？（71352） 19: 如果l是-那么i就是….【摩斯电码】 20:另存为——用记事本打开 或者查看图片注释。 21:去掉超文本标记html后边的l 22:仔细看图片？左下角？还有上一关？ 23:键盘移位密码： qwert键盘上对应的数字？ 24:红心大战记分规则？，答案用英文表示。 25:sqr()函数：平方 ; trunc()函数：去小数保整数。 26:打开FLASH源地址 冠军的身上- - (champion) 27:等吧。或者把FLASH下下来跳帧（好吧 不浪费大家时间了 答案是attic） 28:计分，并替换成英文字母。 29:Google之 30:…度娘一下吧 31:下载图片，进入画图，每个坐标对应一个字母。 32:这个门是叮当猫的。。。（很冷） 33:截屏。 34:在Jellyneo的Data base中搜索。 35:贝多芬的曲子。。 36:由hogwartsone推想hogwartszero然后google之 37:观察源文件得到提示，然后Google之 38:随便试试 39:Google Earth之 40:所有的元音调一下。 41:键盘凯撒。 42:帝国时代2建筑 43:Google之 44:不停地修改错误 45:其实就是作者的Xanga. 46:sign my questbook然后翻到最后一页，期间可以欣赏Simon大神的留言。。 47:Google之 48:观看标题，《查理的巧克力工厂》 49:老老实实算吧。 50:1)凯撒 2)观看源文件知道如何加密 3)看到silver想到gold 4)Jellyneo的Data base 5)看图的左上角 51:先解数独，然后猜事件 52:保龄球 187 53:1)改正riddle.. 2)cancer. 3)图片右下角，carrot. 4)破解QR码，muffin 54:修改中间,查看图片 55:1)首字母缩写 chef 2)同上 beef 3)观察标题。 56:汉诺伊塔 57:Segoe UI 58:1293..Google之 59:MCMLXXXVIII=1988=D MCMLXII=1963=R MCMLXII=1997=O MMVII=2007=P 60:帝国三主城 Germany的Berlin 61:加起来，然后看源文件，得到答案。 62:钢琴。 63:停止。先remove obstacle,然后停止 64:完成游戏。 65:查询得结果，棋盘密码。 66:语法 67:修改源文件 68:Google，然后多试几次 69:当成小学奥数题算，然后多试几次 70:这个。。看源文件。。观察日期的规律。 71:1)重复第21关 2)找出4种货币和他们对应的名称，连起来即可 72:考验你的时候到了。嘿嘿 73:填充，然后我发现这个简直是表白利器啊！！ 74:拼图，然后组词，这个词我想了很久。。 75:1)Google之 2)Hex+Ascll嘿嘿！别想太复杂 3)直接Google找答案！！ 76:看过《魔戒》没,认出你能认出的所有的，然后枚举吧！ 77:这个铁匠铺和外面的世界____？eyesolation是什么？ 78:http://ken.frwonline.com/color.htm自己研究吧 79:Wiki之 80:真的很简单 81:这个组织我好喜欢啊。为什么大陆没有呢？ 82:很烦人的一关，先观源文件，然后转换，然后翻译，然后再观汉字，然后再转字母 83:这个。。找吧。 84:1)太变态了！！Arthur 恶趣味！！！ 2)不断加0!!Arthur 恶趣味！！！ 85:感谢密码吧 86:看源文件就应该清楚它问的是什么。。然后相信自己。。 87:1)认出你会的所有的，然后枚举吧！ 2) 西方谚语 88:1)压力。。。 2)猜猜看呀。。。首页是？ 89:1)四边形推理 2)Do it! 看起来是什么幂诶。。。 90:1)单键吗？ 2)偶尔来一个水关反而会死很多人。。 3)What is missing? 4)呃。。 91:什么东西？一片空白？ 92:话说他少鸣谢了一个。。见66关 93:移去8个字母 94:去源文件看看吧。。嘿嘿。。相信你自己 95:找到赛道吧。 96:首页的图片 97:文字游戏 98:缩写 99:把图片绘出，然后识别一下 100:手机上写写，然后枚举！！ 101:排列组合 102:哇！这纸应该会很大！！ 103:100关后还有如此水关。。 104:搜索这个星舰 105:用圆周率来跳读，然后回答问题。 106:什么平均数来着？ 107:我。。。我以为是圣经。。原来是本儿童读物。 108:有一个原来的技巧在里面。 109:brick ignore the k 然后就行了 110:这个。。先变黑白，然后再flip然后就行了 111:保存下来，各种拉伸 112:这是某样东西的分布图 113:下载程序，然后找吧 114:旋转呀！ 115:哇哈哈，这些音符我太熟了 116:等效代换，有问题的可以问我。。 117:有密码框就一定要输吗？]]></content>
      <tags>
        <tag>arthurluk</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
</search>
