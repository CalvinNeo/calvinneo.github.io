<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,元编程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="最近使用C++实现了一些fortran的内部函数和STL，这里记录了遇到的有关C++模板的问题。另外对于fortran数组的实现放到了Fortran数组的C++实现中">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板编程">
<meta property="og:url" content="http://www.calvinneo.com/2016/12/22/C++模板编程/index.html">
<meta property="og:site_name" content="Calvin's Marbles">
<meta property="og:description" content="最近使用C++实现了一些fortran的内部函数和STL，这里记录了遇到的有关C++模板的问题。另外对于fortran数组的实现放到了Fortran数组的C++实现中">
<meta property="og:updated_time" content="2017-09-23T05:07:15.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++模板编程">
<meta name="twitter:description" content="最近使用C++实现了一些fortran的内部函数和STL，这里记录了遇到的有关C++模板的问题。另外对于fortran数组的实现放到了Fortran数组的C++实现中">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2016/12/22/C++模板编程/"/>





  <title>C++模板编程 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2016/12/22/C++模板编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++模板编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T00:29:16+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a class="cloud-tie-join-count" href="/2016/12/22/C++模板编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count join-count" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近使用C++实现了一些fortran的内部函数和STL，这里记录了遇到的有关C++模板的问题。另外对于fortran数组的实现放到了<a href="/2017/01/18/Fortran数组的C++实现/">Fortran数组的C++实现</a>中<br><a id="more"></a></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="引用列表"><a href="#引用列表" class="headerlink" title="引用列表"></a>引用列表</h2><p><code>vector</code>放引用应当使用<code>reference_wrapper</code>，不过挺恶心的，因为不能重载<code>operator.</code>的缘故，必须得<code>get()</code>一下</p>
<h2 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h2><p><code>operator=</code>、<code>operator()</code>、<code>operator[]</code>、<code>operator-&gt;</code>、<code>operator T</code>不能作为non-member function，这是因为担心与自动合成的<code>operator=</code>出现行为不一致的问题</p>
<h2 id="初始化类中的const成员"><a href="#初始化类中的const成员" class="headerlink" title="初始化类中的const成员"></a>初始化类中的const成员</h2><p>在构造函数的初始化列表中可以进行初始化，对于常量数组，可以使用<code>{}</code>进行初始化<br>在MSVC2015中，下面的代码是无法通过编译的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> C &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> x;</div><div class="line">	C(<span class="keyword">int</span> _x) :x(_x) &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">	<span class="keyword">int</span> a[c.x];</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因是在C.x虽然是常量，但是要到运行期才能知道，事实上只用const修饰的类成员仍然是占空间的，const节省空间的意义是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="external">const对象实际上并不发生复制</a></p>
<h2 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h2><h3 id="全特化函数模板和同签名的普通函数"><a href="#全特化函数模板和同签名的普通函数" class="headerlink" title="全特化函数模板和同签名的普通函数"></a>全特化函数模板和同签名的普通函数</h3><p>对于全特化的函数模板，它和不加<code>template&lt;&gt;</code>的普通函数有什么区别呢？根据C++ Premier中的说明</p>
<blockquote>
<p>当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的</p>
</blockquote>
<p><code>template&lt;&gt;</code>特化函数模板比普通函数匹配更为精确，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #1 </span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x, T y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #2 </span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">	promotion(<span class="number">1.0</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>main</code>中第1条语句输出<code>&quot;function&quot;</code>，因为<code>1</code>是int，不能精确匹配2号函数的两个<code>double</code>，所以只能匹配到3号函数<br><code>main</code>中第1条语句输出<code>&quot;template&lt;&gt;&quot;</code>，这时候两个参数都是<code>double</code>，于是2号函数更精确了。<br>又例如将3号和<code>main</code>改为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先根据上面的结论，1号模板函数肯定是匹配不了的，<br>注释掉2，得到输出是function，这是因为第一个参数1被隐式转换成1.0了<br>注释掉3，得到编译错误，因为特化模板要精确匹配</p>
<h3 id="“偏特化”函数"><a href="#“偏特化”函数" class="headerlink" title="“偏特化”函数"></a>“偏特化”函数</h3><p>需要注意的是，函数模板不能偏特化，如果需要使用“偏特化的函数模板”，考虑在一个偏特化类中实现static函数。<br>这又带来一个新的问题，考虑要偏特化一个类中<strong>成员函数</strong>，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="external">这里的说明</a>，这里另外给出对于非类型模板参数的写法<br>例如现在需要判断一个关于类型T的D维矩阵中维数<code>D</code>是否为1，可以这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::conditional&lt;D == <span class="number">1</span>, <span class="built_in">std</span>::true_type, <span class="built_in">std</span>::false_type&gt;::type is_vector;</div><div class="line">farray&lt;T, D&gt; &amp; _pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::true_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; _pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::false_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x) &#123;</div><div class="line">	<span class="keyword">return</span> _pluseq_impl(x, is_vector());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现实际上可以根据函数的重载而不是“偏特化”来实现上面的功能。<br> 此外，模板函数一旦全特化，就应当和对待普通函数一样，使用<code>inline</code>，<code>static</code>，<code>extern</code>关键字防止重复包含</p>
<h3 id="特化using"><a href="#特化using" class="headerlink" title="特化using"></a>特化using</h3><p>与函数相同，C++中的<code>using</code>也不能直接特化，如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> wrap&lt;T&gt; = T;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">using</span> wrap&lt;<span class="keyword">int</span>&gt; = <span class="keyword">int</span>;</div></pre></td></tr></table></figure></p>
<p>必须需要借助类来workaround<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> wrap&#123;</div><div class="line">	<span class="keyword">using</span> type = T;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用void-t实现Expression-SFINAE"><a href="#使用void-t实现Expression-SFINAE" class="headerlink" title="使用void_t实现Expression SFINAE"></a>使用void_t实现Expression SFINAE</h2><p>模板偏特化是相对原型（primary template）模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板<br>SFINAE(Substitution Failure Is Not An Error)是C++的模板编译规则，当推导<strong>模板参数</strong>（注意在函数内部使用ill-formed会导致hard error）失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。于是可以通过人为构造ill-formed的表达式或者类型来实现一些功能。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// https://www.zhihu.com/question/34264462</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont,</div><div class="line">	<span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line">	<span class="keyword">struct</span> has_push_back : <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line"><span class="keyword">struct</span> has_push_back&lt;Cont, <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;Cont::push_back)&gt;&gt; : <span class="built_in">std</span>::true_type &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>始终对<code>std::vector&lt;int&gt;</code>断言失败。后来查看<a href="http://stackoverflow.com/questions/31907885/void-t-fails-on-visual-studio-2015" target="_blank" rel="external">SoF</a>以为是MSVC2015对<code>std::void_t</code>的支持有问题。<br>后来在SoF的<a href="http://stackoverflow.com/questions/27687389/how-does-void-t-work" target="_blank" rel="external">另一篇博文上</a>发现如果不是选择成员函数，而是选择数据成员就可以通过<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> , <span class="keyword">class</span> = <span class="keyword">void</span> &gt;</div><div class="line"><span class="keyword">struct</span> has_member : <span class="built_in">std</span>::false_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// specialized as has_member&lt; T , void &gt; or discarded (sfinae)</span></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="keyword">struct</span> has_member&lt; T , <span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>( T::member ) &gt; &gt; : <span class="built_in">std</span>::true_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> member;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; A &gt;::value , <span class="string">"A"</span> );</div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; B &gt;::value , <span class="string">"B"</span> );</div></pre></td></tr></table></figure></p>
<p>后来去SoF上问了一波，这是因为<code>std::vector&lt;int&gt;::push_back</code>有多个重载版本，于是应该还要匹配函数签名。注意返回值不是函数签名的一部分（所以函数重载决议也是不包括返回值的），不被推导。<br>关于这种expression sfinae，可以参考<a href="http://stackoverflow.com/questions/12654067/what-is-expression-sfinae" target="_blank" rel="external">这个回答</a><br>但是这样还有个问题，例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;_Container_value_type&gt;().size()) &gt;&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type&gt;</div><div class="line"><span class="keyword">void</span> getsize(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line">	getsize_impl&lt;_Container_value_type&gt;(farr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样会出现函数模板已经定义的错误。在<a href="http://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="external">cppreference</a>中给出了说明</p>
<blockquote>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal.</p>
</blockquote>
<p>此外在<a href="http://stackoverflow.com/questions/30953248/why-doesnt-sfinae-enable-if-work-for-member-functions-of-a-class-template" target="_blank" rel="external">SoF</a> 上给出了如下说明</p>
<blockquote>
<p>SFINAE only works for deduced template arguments</p>
</blockquote>
<p>此外，实际上编译器不需要指定特化就可以区分匹配下面的两个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(Cont &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"not array"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(for1array&lt;Cont&gt; &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"array"</span>);</div><div class="line">		for1array_init&lt;<span class="keyword">typename</span> Cont::value_type&gt;(farr(<span class="number">1</span>)); <span class="comment">// 报错，因为typename Cont::value_type是ill-fromed</span></div><div class="line">		for1array_init(farr(<span class="number">1</span>)); <span class="comment">// 得到正确结果</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>编译错误是因为编译器会对<code>typename Cont::value_type</code>这个ill-formed求值报错，而不是重新使用上面的primary template推导，因此只可以在模板参数里写出要有<code>value_type</code>，这样的”concept”。例如下面的用法同样也是错的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> for1array_gettype2 &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;is_for1array::test&lt;T&gt;(<span class="literal">nullptr</span>), <span class="keyword">typename</span> for1array_gettype&lt;<span class="keyword">typename</span> T::value_type&gt;::type, T&gt; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="判断模板参数是否是广义函数"><a href="#判断模板参数是否是广义函数" class="headerlink" title="判断模板参数是否是广义函数"></a>判断模板参数是否是广义函数</h2><p>目前广义函数包括函数、<code>std::function</code>、lambda、仿函数，其中<code>std::is_function</code>只能识别函数。c++17标准添加了<code>std::is_callable</code>，现在考虑C++14标准。</p>
<h2 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h2><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="external">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>
<h2 id="将带类型推导的lambda传给std-function"><a href="#将带类型推导的lambda传给std-function" class="headerlink" title="将带类型推导的lambda传给std::function"></a>将带类型推导的lambda传给std::function</h2><p>根据<a href="http://stackoverflow.com/questions/9998402/c11-does-not-deduce-type-when-stdfunction-or-lambda-functions-are-involved" target="_blank" rel="external">StackOverflow上的这个答案</a>，lambda是函数对象而不是函数，但是可以被转换(convert to)成<code>std::function</code>，这是由<code>std::function</code>的可以有所有能被调用的类型构造，也就是说这可以这么写<code>std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };</code>。但是类型推导是另一回事，因为lambda并不是<code>std::function</code>，所以编译器不能通过一个lambda去推导<code>std::function</code>的参数<br>因此比较好的解决方式是直接使用<code>template&lt;typename F&gt;</code>，所以说现在的问题是如何得到F的返回值类型。从<a href="http://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda" target="_blank" rel="external">这个回答</a>可以看到，可以实现这样一个<code>function_matcher</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> function_traits</div><div class="line">	: <span class="keyword">public</span> function_traits&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt;</div><div class="line">&#123;&#125;;</div><div class="line"><span class="comment">// For generic types, directly use the result of the signature of its 'operator()'</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="keyword">struct</span> function_traits&lt;ReturnType(ClassType::*)(Args...) <span class="keyword">const</span>&gt;</div><div class="line">&#123;</div><div class="line">	<span class="comment">// we specialize for pointers to member function</span></div><div class="line">	<span class="keyword">enum</span> &#123; arity = <span class="keyword">sizeof</span>...(Args) &#125;;</div><div class="line">	<span class="comment">// arity is the number of arguments.</span></div><div class="line">	<span class="keyword">typedef</span> ReturnType result_type;</div><div class="line">	<span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</div><div class="line">	<span class="keyword">struct</span> arg</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type type;</div><div class="line">		<span class="comment">// the i-th argument is equivalent to the i-th tuple element of a tuple</span></div><div class="line">		<span class="comment">// composed of those arguments.</span></div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>此外注意到有个<code>std::result_of</code>的东西，能不能用它来推导<code>typename F</code>的返回类型呢？经测试可以推导函数对象的返回类型，不能推导原生函数的返回类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> native_func(<span class="keyword">int</span> a) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_func</span></span> &#123;</div><div class="line">	<span class="keyword">int</span> operator()(<span class="keyword">int</span> a) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">template&lt;typename F&gt;</div><div class="line">auto call_func(F f)-&gt; std::result_of_t&lt;F(<span class="keyword">int</span>)&gt; &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> main() &#123;</div><div class="line">	typename std::result_of&lt;object_func(<span class="keyword">int</span>)&gt;::<span class="class"><span class="keyword">type</span> <span class="title">x</span></span>; <span class="comment">// Yes</span></div><div class="line">	typename std::result_of&lt;native_func(<span class="keyword">int</span>)&gt;::<span class="class"><span class="keyword">type</span> <span class="title">y</span></span>; <span class="comment">// No</span></div><div class="line">	object_func of; </div><div class="line">	call_func(of); <span class="comment">// Yes</span></div><div class="line">	call_func(native_func); <span class="comment">// Yes</span></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考了<a href="http://stackoverflow.com/questions/11470802/stdresult-of-simple-function" target="_blank" rel="external">StackOverflow上的答案</a>，这是因为原生函数并不是一个type，但是<code>std::result_of&lt;F(Args...)&gt;</code>中的F必须要是一个类型，合适的解决方法是直接使用decltype+declval，<code>decltype(native_func(std::declval&lt;int&gt;()))</code>，而不是用<code>std::result_of</code></p>
<h2 id="在类模板中声明友元函数模板"><a href="#在类模板中声明友元函数模板" class="headerlink" title="在类模板中声明友元函数模板"></a>在类模板中声明友元函数模板</h2><p>在一个模板类<code>farray</code>中声明一个友元函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> farray&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y)&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能会报error LNK2019: 无法解析的外部符号 “struct for90std::farray<bool> __cdecl for90std::operator&lt;(struct for90std::farray<int> const &amp;,int const &amp;)” (??Mfor90std@@YA?AU?$farray@_N@0@AEBU?$farray@H@0@AEBH@Z)错误<br>原因是<code>T</code>是类模板<code>farray</code>的模板参数，随着类模板特化。所以应该给友元函数<code>operator&lt;</code>独立的模板参数，改成这样就好了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;U&gt; &amp; x, <span class="keyword">const</span> U &amp; y);</div></pre></td></tr></table></figure></int></bool></p>
<p>详细可以参考<a href="http://stackoverflow.com/questions/29055696/why-lnk1120-lnk2019-appears-in-case-of-template-and-friend-function" target="_blank" rel="external">这篇答案</a></p>
<h2 id="给参数包加上右值引用"><a href="#给参数包加上右值引用" class="headerlink" title="给参数包加上右值引用"></a>给参数包加上右值引用</h2><p>根据Effective Modern C++ Item 24的规定。函数签名中的<code>T&amp;&amp;</code>，如果<code>T</code>是需要推导得来的，这样的<code>T</code>表示通用引用(universal reference)<br>如果对于参数包不加上通用引用<code>Args&amp;&amp;</code>，那他就不能接受一个左值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x, Args ... args)</span> </span>&#123;</div><div class="line">	x = <span class="number">1</span>;</div><div class="line">	test_pack(forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x)</span> </span>&#123;</div><div class="line">	x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x, Args ... args)</span> </span>&#123;</div><div class="line"></div><div class="line">	test_pack_clvalue(forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</div><div class="line">	test_pack_clvalue(a, b, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>参数包：parameter pack<br>类型限定符（const, volatile）：qualification adjustment<br>返回类型后置：trailing return type<br>函数签名：signature<br>模板类型推导：template argument deduction<br>聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释<a href="http://blog.csdn.net/lanchunhui/article/details/50532790" target="_blank" rel="external"></a><br>非类型模板参数：non type template parameter<br>包扩展：pack expansion<br>brace-init-list<br>省略号(…)：ellipsis<br>符号扩展、零扩展<br>可变参数模板：Variadic Templates pack<br>展开模式：pattern<br>决议：resolution</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/元编程/" rel="tag"># 元编程</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/ICPC CHINA-FINAL小记/" rel="next" title="ICPC CHINA-FINAL小记">
                <i class="fa fa-chevron-left"></i> ICPC CHINA-FINAL小记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/30/C++初始化方式/" rel="prev" title="C++初始化方式(翻译)">
                C++初始化方式(翻译) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">79</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">102</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://wenwenla.github.io/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#注意事项"><span class="nav-number">1.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用列表"><span class="nav-number">1.1.</span> <span class="nav-text">引用列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator重载"><span class="nav-number">1.2.</span> <span class="nav-text">operator重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化类中的const成员"><span class="nav-number">1.3.</span> <span class="nav-text">初始化类中的const成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板特化"><span class="nav-number">1.4.</span> <span class="nav-text">函数模板特化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全特化函数模板和同签名的普通函数"><span class="nav-number">1.4.1.</span> <span class="nav-text">全特化函数模板和同签名的普通函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“偏特化”函数"><span class="nav-number">1.4.2.</span> <span class="nav-text">“偏特化”函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特化using"><span class="nav-number">1.4.3.</span> <span class="nav-text">特化using</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用void-t实现Expression-SFINAE"><span class="nav-number">1.5.</span> <span class="nav-text">使用void_t实现Expression SFINAE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断模板参数是否是广义函数"><span class="nav-number">1.6.</span> <span class="nav-text">判断模板参数是否是广义函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现member-function的const版本"><span class="nav-number">1.7.</span> <span class="nav-text">实现member function的const版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将带类型推导的lambda传给std-function"><span class="nav-number">1.8.</span> <span class="nav-text">将带类型推导的lambda传给std::function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在类模板中声明友元函数模板"><span class="nav-number">1.9.</span> <span class="nav-text">在类模板中声明友元函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#给参数包加上右值引用"><span class="nav-number">1.10.</span> <span class="nav-text">给参数包加上右值引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用术语"><span class="nav-number">2.</span> <span class="nav-text">常用术语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span>对本博客上的所有内容及其历史版本的任何引用必须征得作者书面同意并注明来源</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  
    
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "37598a3a99864bacb6bf78f7fbcbc3d6",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
  










  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
