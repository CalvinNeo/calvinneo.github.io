<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="模板编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的（STL）。C++11标准以来，C++在泛型编程方面引入了许多新的特性。本文讨论了围绕C++模板的诸多技术与编程方法。包括traits">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板编程">
<meta property="og:url" content="http://www.calvinneo.com/2016/12/22/C++模板编程/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="模板编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的（STL）。C++11标准以来，C++在泛型编程方面引入了许多新的特性。本文讨论了围绕C++模板的诸多技术与编程方法。包括traits">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-07-23T14:09:54.718Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++模板编程">
<meta name="twitter:description" content="模板编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的（STL）。C++11标准以来，C++在泛型编程方面引入了许多新的特性。本文讨论了围绕C++模板的诸多技术与编程方法。包括traits">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2016/12/22/C++模板编程/"/>





  <title>C++模板编程 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2016/12/22/C++模板编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++模板编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T00:29:16+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/22/C++模板编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/12/22/C++模板编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>模板编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的（STL）。C++11标准以来，C++在泛型编程方面引入了许多新的特性。本文讨论了围绕C++模板的诸多技术与编程方法。包括traits</p>
<a id="more"></a>
<h1 id="各种traits"><a href="#各种traits" class="headerlink" title="各种traits"></a>各种traits</h1><p>traits是C++ STL中的重要组成成分</p>
<h2 id="数值部分"><a href="#数值部分" class="headerlink" title="数值部分"></a>数值部分</h2><ol>
<li>判断是否是整数：<code>std::is_integral&lt;T&gt;::value</code></li>
<li>判断是否有符号：<code>std::numeric_limits&lt;T&gt;::is_signed</code></li>
</ol>
<h2 id="迭代器部分"><a href="#迭代器部分" class="headerlink" title="迭代器部分"></a>迭代器部分</h2><p>判断迭代器种类以及内容：<code>std::iterator_traits</code>。这个trait实现很有意思，为了兼容指针和常指针这两个最原始的“迭代器”，这里使用了SFINAE<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> _<span class="title">Iterator_traits_base</span>&lt;_Iter, void_t&lt; // 这里的void_t使得不具有下面五个成员的两种指针失配</span></span><br><span class="line"><span class="class">        typename _Iter::iterator_category,</span></span><br><span class="line"><span class="class">        typename _Iter::value_type,</span></span><br><span class="line"><span class="class">        typename _Iter::difference_type,</span></span><br><span class="line"><span class="class">        typename _Iter::pointer,</span></span><br><span class="line"><span class="class">        typename _Iter::reference</span></span><br><span class="line"><span class="class">        &gt; &gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// defined if _Iter::* types exist</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::reference reference;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">        :</span> _Iterator_traits_base&lt;_Iter&gt;</span><br><span class="line">    &#123;   <span class="comment">// get traits from iterator _Iter, if possible</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Ty *&gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// get traits from pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Ty *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty&amp; reference;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 const _Ty *要单独拿出来偏特化，如果用上面的偏特化的话，我们得到的是const _Ty而不是_Ty</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Ty *&gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// get traits from const pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Ty *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Ty&amp; reference;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="对象行为部分"><a href="#对象行为部分" class="headerlink" title="对象行为部分"></a>对象行为部分</h2><p>C++新标准中使用了<code>is_...able&lt;&gt;</code>函数代替了之前的<code>has_...</code>函数</p>
<h1 id="reference-wrapper"><a href="#reference-wrapper" class="headerlink" title="reference_wrapper"></a>reference_wrapper</h1><p>显然<code>std::vector</code>是不能存放<code>T &amp;</code>的，如果不希望放指针进去，可以使用<code>std::reference_wrapper</code>，不过这东西用起来也并不舒服，例如C++不能重载<code>operator.</code>，虽然最近有一些草案正在提到这一点，所以必须得<code>get()</code>一下。<br><code>std::reference_wrapper</code>常用于<code>std::bind</code>、<code>std::thread</code>等函数/类上。它们为了保证传入的参数在自己的生命周期中是持续存在的，决定始终通过传值的方式接受参数，即始终拷贝一份，因此此时如果要传递引用，就得使用<code>std::ref</code>包装一下了。</p>
<h1 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h1><p><code>operator=</code>、<code>operator()</code>、<code>operator[]</code>、<code>operator-&gt;</code>、<code>operator T</code>不能作为non-member function，这是因为担心与自动合成的<code>operator=</code>出现行为不一致的问题。其实还可以更深入地考虑这个问题，例如对于比较大小的运算符<code>operator&lt;</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> B &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这显然是不符合逻辑的</p>
<h1 id="const不是编译期常量"><a href="#const不是编译期常量" class="headerlink" title="const不是编译期常量"></a>const不是编译期常量</h1><p>在<a href="/2016/12/30/C++初始化方式/">C++初始化方式</a>中已经提到常量<code>const</code>是不能在构造函数体中初始化的，但可以在初始化列表中可以进行初始化，对于常量数组或者标准库的<code>std::vector</code>等容器，现在可以使用花括号<code>{}</code>进行初始化。<br>需要额外说明的是<code>const</code>甚至不能作为模板参数等编译期常量使用。例如在MSVC2015中，下面的代码是无法通过编译的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    C(<span class="keyword">int</span> _x) :x(_x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a[c.x];</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>原因是在<code>C.x</code>虽然是常量，但是要到运行期才能知道，这里应该使用的是<code>static const</code>或者<code>constexpr</code>，<code>const</code>修饰符实际上的意义更接近于<code>readonly</code>。如果说<code>const</code>能够“节省空间”，那是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="noopener">const对象实际上并不发生复制</a>，但只<code>const</code>修饰的类成员仍然是占空间的。</p>
<h1 id="特化using"><a href="#特化using" class="headerlink" title="特化using"></a>特化using</h1><p>与函数相同，C++中的<code>using</code>也不能直接特化，如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> wrap&lt;T&gt; = T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">using</span> wrap&lt;<span class="keyword">int</span>&gt; = <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure></p>
<p>必须需要借助类来workaround<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">struct wrap&#123;</span><br><span class="line">    using<span class="built_in"> type </span>= T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="函数模板的特化与函数的重载"><a href="#函数模板的特化与函数的重载" class="headerlink" title="函数模板的特化与函数的重载"></a>函数模板的特化与函数的重载</h1><p>为了实现函数的“多态”，常有借助模板类偏特化和重载两种方式。</p>
<h2 id="借助重载实现函数的“偏特化”"><a href="#借助重载实现函数的“偏特化”" class="headerlink" title="借助重载实现函数的“偏特化”"></a>借助重载实现函数的“偏特化”</h2><p>虽然函数模板不能偏特化，但函数本身就有重载，因此我们可以在每个不同的函数末尾加上一个tag来达到根据某些traits进行“分类讨论“的效果。例如最常用的<code>std::true_type</code>和<code>std::false_type</code>。在STL的实现中使用了很多这样的<code>_tag</code>来控制行为，例如控制<code>std::advance()</code>函数在接受五种不同迭代器时的更新行为，或者原子库中使用tag标记六种内存模型。即使当我们要“偏特化”的是非类型模板参数时，也可以直接利用重载而不是“偏特化”，这时候我们可以在类里面用<code>enum</code>或者<code>static constexpr int</code>将这个值封装起来，也可以直接借助于标准库的<code>std::condition</code>等函数。在下面的例子中，我们需求模板函数的行为根据<code>std::is_same&lt;T, C&gt;::value</code>进行分类讨论。<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T, typename U&gt; when_e<span class="string">q(T x, U y)</span>; <span class="regexp">//</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>在没有<code>constexpr if</code>的情况下，用函数重载来做是一种直截了当的方案。但是重载是对类型而言的，而<code>if</code>只能判断<code>true</code>/<code>false</code>值，非类型模板参数又不能使用整型以外的类型。所以必须要有个机制来将整型值包装成类型，这里可以借助标准库提供的<code>std::integral_constant&lt;typename T, T val&gt;</code>，或者也可以自己实现一个<code>Int2Type</code>或者<code>Int2Type2</code>。这个思路可以解决很多问题，例如<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="noopener">对成员函数的偏特化</a>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int2Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = I &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int2Type2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/* or constexpr */</span> <span class="keyword">int</span> value = I;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y, Int2Type&lt;<span class="number">1</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"eq"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y, Int2Type&lt;<span class="number">0</span>&gt;)</span></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"neq"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    when_eq(x, y, Int2Type&lt;is_same&lt;T, U&gt;::value&gt;()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    when_eq(X(), Y());</span><br><span class="line">    when_eq(X(), X());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里特别提一下<code>enum</code>的性质，根据标准在使用<code>enum E {V1, V2}</code>的值<code>V1</code>、<code>V2</code>时是不需要加上<code>E::</code>限定符的。此外其具体类型可以使用<code>std::underlying_type</code>获得。</p>
<h2 id="借助类模板实现偏特化"><a href="#借助类模板实现偏特化" class="headerlink" title="借助类模板实现偏特化"></a>借助类模板实现偏特化</h2><p>还可以使用类模板“偏特化”函数，如果需要上下文，那么可以重载<code>operator()</code>的方式实现一个仿函数，如果不需要上下文，可以在里面定义一个static函数。<br>如果一定需要偏特化，考虑在一个偏特化类中实现static函数。这又带来一个新的问题，考虑要偏特化一个类中<strong>成员函数</strong>，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="noopener">这里的说明</a></p>
<h1 id="普通函数、函数模板和全特化模板函数之间的决议"><a href="#普通函数、函数模板和全特化模板函数之间的决议" class="headerlink" title="普通函数、函数模板和全特化模板函数之间的决议"></a>普通函数、函数模板和全特化模板函数之间的决议</h1><p>在这一章节中，我们将讨论重载的普通函数、函数模板和其特化函数之间的决议顺序。<br>模板函数一旦全特化，它就和普通函数一样成为一个strong symbol，我们应当使用<code>inline</code>，<code>static</code>，<code>extern</code>关键字防止重复定义。<br>但是对于全特化的函数模板，它和不加<code>template&lt;&gt;</code>的普通函数还是有着很大区别的？根据C++ Premier中的说明</p>
<blockquote>
<p>当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的</p>
</blockquote>
<p>上面的话是说明<code>template&lt;&gt;</code>特化函数模板比普通函数的匹配要求更高，这是因为普通函数还能接受传入参数的隐式转换。我们在多个函数之间进行决议时总是选择最为精确的函数。</p>
<ol>
<li><p>在这个例子中，<code>a</code>是<code>int</code>，显然主模板0能够精确匹配，于是决议到0，输出<code>&quot;template&quot;</code>。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// template</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个例子就是一个经典的SFINAE用法了，我们知道一个数组的大小只能是整数而不能是浮点数，所以当<code>T</code>是<code>double</code>时，<code>char(*)[T()]</code>就是ill-formed。根据SFINAE，我们不把它作为错误，而是转而寻求次优解。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">char</span>(*)[T()]&gt;</span><br><span class="line"><span class="keyword">void</span> promotion(T x) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>但我们必须要考虑一个特例，也就是当有多于一个函数能精确匹配的情况，这时候优先级的顺序是普通函数、全特化、主模板</p>
<ol>
<li><p>普通函数先于全特化</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    promotion(<span class="number">1.0</span>); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全特化版本先于主模板</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    promotion(<span class="number">1.0</span>); <span class="comment">// template&lt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>decay</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T &amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="考虑可访问性"><a href="#考虑可访问性" class="headerlink" title="考虑可访问性"></a>考虑可访问性</h2><p>C++中的可访问性包括private、protected和public三类，可访问性是针对<strong>类</strong>而不是对象而言的。<br><a href="http://blog.csdn.net/starlee/article/details/1406781" target="_blank" rel="noopener">C++中重载决议是在可访问性检查之前进行的</a></p>
<h2 id="考虑隐式类型转换"><a href="#考虑隐式类型转换" class="headerlink" title="考虑隐式类型转换"></a>考虑隐式类型转换</h2><p>在日常编程中，我们我们常常把字符串直接量当做<code>std::string</code>使用，但其实字符串直接量的类型是<code>const char[]</code>，这其中涉及到隐式构造函数或者隐式类型转换。这导致在进行重载决议时出现“不合常理”的情况。</p>
<h3 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h3><p>在<a href="https://www.zhihu.com/question/27932618" target="_blank" rel="noopener">知乎的这篇问题</a>中，我们看到<code>Test</code>中定义了两个成员函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在考虑下面的调用，我们发现是调用的find 2版本的函数。这是由于<code>const char[]</code>被decay成了<code>const char *</code>，然后隐式转换成了<code>bool</code>。</p>
<pre><code>Test().find(&quot;a&quot;, &quot;b&quot;);
</code></pre><h3 id="隐式类型转换的顺序"><a href="#隐式类型转换的顺序" class="headerlink" title="隐式类型转换的顺序"></a>隐式类型转换的顺序</h3><p>类型隐式转换具有下面的顺序：</p>
<ol>
<li><p>精确匹配<br> 这里对应着四种的decay，即<code>T[] -&gt; T*</code>、<code>T&amp; -&gt; T</code>、<code>F(...) -&gt; F (*)(...)</code>、<code>T const -&gt; T</code></p>
<ol>
<li>无转换</li>
<li>lvalue到rvalue、数组到指针、函数到指针</li>
<li>限定符转换<br> 我们可以为任意类型加上CV限定符。对于多重指针来说，前面的重数的限制要高于后面重数的限制，如 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>** p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** p1 = p; <span class="comment">// error: level 2 more cv-qualified but level 1 is not const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> * p2 = p; <span class="comment">// OK: level 2 more cv-qualified and const added at level 1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>类型提升转换(promotion)<br> 即Numeric promotions，包含Integral promotion和Floating-point promotion<br> 这里注意，<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">非promotion的整数之间转换都作为conversion</a>，如<code>char -&gt; int</code></p>
</li>
<li>标准转换<br> 包含Numeric conversions，如Integral conversions、Floating-point conversions、Floating–integral conversions、Pointer conversions、Boolean conversions</li>
<li>用户自定义转换<br> 这就包括了<code>std::string</code>中定义的从<code>const char *</code>的转换了</li>
</ol>
<p>注意能进行隐式类型转换并不意味着类型相同，所以使用<code>std::is_same</code>进行的判断都是false，例如下面的代码输出都是false。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="考虑传参时decay的特殊情况"><a href="#考虑传参时decay的特殊情况" class="headerlink" title="考虑传参时decay的特殊情况"></a>考虑传参时decay的特殊情况</h3><p>紧接着上面的讨论，我们查看下面的一段代码，这时候输出就变成true了，究其原因是因为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::is_same&lt;T, U&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; b = a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; check(<span class="keyword">int</span>(), a) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样是类型转换问题，在<a href="http://www.cnblogs.com/liyuan989/p/4138378.html" target="_blank" rel="noopener">文章</a>中提到了一个特别的情况<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"template"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"normal"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在调用</p>
<pre><code>compare(&quot;123456&quot;, &quot;123456&quot;);
</code></pre><p>请问是调用了那个函数呢？有意思的是，对于不同编译器，结果还不一样。作者指出对G++/clang来说是调用了模板版本，而我使用VS2015发现调用的是普通版本。<br>调用模板版本的原因是<code>T = const char [6]</code>相比退化后的<code>const char *</code>更精确。但是调用普通版本的原因是数组传参时要decay成对应的指针。因此对于模板函数和普通函数实际上都不是精确匹配的（都要经过一次类型转换）。根据C++重载决议原则，如果调用具有二义性，则优先选择调用普通函数。<br>在本篇结尾，作者引用陈硕的观点，认为G++/clang的实现是符合标准的，但是这属于标准的bug。其原因是<strong>模板实参推断<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC" target="_blank" rel="noopener">(template argument deduction)</a></strong>时，除了产生新的实例化之外，编译器只会执行两种转换</p>
<ol>
<li>const转换：接受const引用或指针的函数可以分别用非const对象的引用或指针来调用，无须产生新的实例化。也就是可以传一个非const到需要const参数的函数。</li>
<li>数组或函数到指针的转换：<strong>如果模板形参不是引用类型</strong>，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针，函数实参当作指向函数类型的指针。</li>
</ol>
<p>由于模板参数使用了数组的const引用类型，所以按照标准应该不将数组向指针进行decay。</p>
<h2 id="考虑继承"><a href="#考虑继承" class="headerlink" title="考虑继承"></a>考虑继承</h2><h1 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h1><p>在C++中常常出现一些ill-formed的代码，这些代码在函数体或者其他地方出现编译器都是要报错的，SFINAE(Substitution Failure Is Not An Error)规定，当<strong>推导模板参数</strong>失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。我们需要注意，这样的替换发生在下面四种情况下：</p>
<ol>
<li>(Type SFINAE)所有用于函数的类型，包括函数的返回值与参数的类型</li>
<li>(Type SFINAE)所有用于模板参数的类型</li>
<li>(Expression SFINAE)所有用于函数类型中的表达式</li>
<li>(Expression SFINAE)所有用于模板形参声明中的表达式</li>
</ol>
<p>这些常被使用的ill-formed代码包括下面的形式：</p>
<ol>
<li>试图实例化含有多个不同长度包的包展开</li>
<li>试图创建void的数组、引用的数组、函数的数组、抽象类类型的数组、负大小的数组或零大小的数组<br> 例如之前提到过的<code>char(*)[0.5]</code>，还有<code>char [0]</code>、<code>void [3]</code>等</li>
<li>试图在<code>::</code>左侧使用非类或非枚举的类型<br> 比如<code>int::field</code>是错的</li>
<li>试图使用类型的不存在的成员<br> 比如<code>vector&lt;int&gt;::abcdefg</code>是错的，因为它肯定没有这个字段</li>
<li><p>试图在错误的地方是用类型的成员（类型、模板、非类型如literal等）</p>
</li>
<li><p>试图创建指向引用的指针</p>
</li>
<li>试图创建到 void 的引用</li>
<li><p>试图创建指向T成员的指针，其中T不是类类型<br> 这个常常可被用来判断<code>T</code>是否是类类型，代码如下所示。这里<code>C::*</code>表示一个指向类<code>C</code>中某<code>int</code>类型成员的指针，说明了这个指针带有<code>C</code>的上下文，而<code>...</code>相当于一个兜底的东西。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> C::*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// C是类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test&lt;X&gt;(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>试图将非法类型给予非类型模板参数<br> 这个SFINAE将在后面<code>std::void_t</code>中被广泛使用</p>
</li>
<li>试图进行非法转换</li>
<li>试图创建拥有形参类型<code>void</code>的函数<br>这个SFINAE对应于前面的“试图将非法类型给予非类型模板参数”</li>
<li>试图创建返回数组类型或函数类型的函数</li>
<li>试图创建参数类型或返回类型为抽象类的函数类型</li>
</ol>
<p>自然而然地想到如果我们需要判定某个实体是否具有某种性质，我们就可以构造一种没有这种特性就会造成ill-formed的<strong>表达式</strong>或者<strong>类型</strong>（分别对应Expression SFINAE和Type SFINAE），然后通过<strong>函数重载</strong>或者<strong>模板类的偏特化</strong>来进行分类讨论。在使用函数重载时，我们常常在函数最后放一个可能会ill-formed类型的指针。</p>
<h2 id="使用SFINAE判断是否存在成员"><a href="#使用SFINAE判断是否存在成员" class="headerlink" title="使用SFINAE判断是否存在成员"></a>使用SFINAE判断是否存在成员</h2><p>SFINAE分为两种，通常见到的是Type SFINAE。关于Expression SFINAE，可以参考<a href="http://stackoverflow.com/questions/12654067/what-is-expression-sfinae" target="_blank" rel="noopener">这个回答</a></p>
<p>模板偏特化是相对原型/初等/主(primary template)模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板。例如对模板类型参数<code>T</code>而言，<code>T*</code>、<code>T&amp;</code>、<code>const T &amp;</code>等是它的一个偏特化。通过偏特化我们可以进行分类讨论。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_container</span><span class="params">(Cont &amp; cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"not a container"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_container</span><span class="params">(Container&lt;Cont&gt; &amp; cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"container"</span>);</span><br><span class="line">    handle_container(cont[<span class="number">0</span>]); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>偏特化可以用来检查一个类中是否具有某个成员<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.zhihu.com/question/34264462</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line">struct has_push_back : <span class="built_in">std</span>::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_push_back</span>&lt;Cont, std::void_t&lt;decltype(&amp;Cont::push_back)&gt;&gt; :</span> <span class="built_in">std</span>::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>始终对<code>std::vector&lt;int&gt;</code>断言失败。后来查看<a href="http://stackoverflow.com/questions/31907885/void-t-fails-on-visual-studio-2015" target="_blank" rel="noopener">SoF</a>，当时以为是MSVC2015对<code>std::void_t</code>的支持有问题。后来在SoF的<a href="http://stackoverflow.com/questions/27687389/how-does-void-t-work" target="_blank" rel="noopener">另一篇博文上</a>发现如果我们的<code>push_back</code>不是成员函数而是数据成员就可以通过。去SoF上问了一波，这是因为<code>std::vector&lt;int&gt;::push_back</code>有多个重载版本，于是应该还要匹配函数签名，因此我们可以写成下面的形式，我们显式构造了<code>vector.push_back(vector::value_type())</code>这个表达式，看它是不是合法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.zhihu.com/question/34264462/answer/58260115</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_push_back : <span class="built_in">std</span>::false_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="keyword">using</span> ValueType = <span class="keyword">typename</span> Cont::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_push_back</span>&lt;Cont, std::void_t&lt;std::declval&lt;Cont&gt;().push_back(declval&lt;ValueType&lt;Cont&gt;&gt;())&gt;&gt; :</span> <span class="built_in">std</span>::true_type&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<p>注意到我们这里都是用类的偏特化来实现的，我也尝试了下使用函数搞一搞<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line"><span class="keyword">bool</span> has_push_back() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;Cont::push_back)&gt;&gt; </span><br><span class="line"><span class="keyword">bool</span> has_push_back() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会出现函数模板已经定义的错误。在<a href="http://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener">cppreference</a>中给出了说明</p>
<blockquote>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal.</p>
</blockquote>
<p>此外在<a href="http://stackoverflow.com/questions/30953248/why-doesnt-sfinae-enable-if-work-for-member-functions-of-a-class-template" target="_blank" rel="noopener">SoF</a> 上给出了如下说明</p>
<blockquote>
<p>SFINAE only works for deduced template arguments</p>
</blockquote>
<h1 id="判断模板参数是否是广义函数"><a href="#判断模板参数是否是广义函数" class="headerlink" title="判断模板参数是否是广义函数"></a>判断模板参数是否是广义函数</h1><p>目前广义函数包括函数、<code>std::function</code>、lambda、仿函数，其中<code>std::is_function</code>只能识别函数。C++17标准添加了<code>std::is_invokable</code>(即之前的<code>std::is_callable</code>)，用来表示可以INVOKE的类型。</p>
<h1 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h1><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="noopener">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>
<h1 id="推导lambda的类型"><a href="#推导lambda的类型" class="headerlink" title="推导lambda的类型"></a>推导lambda的类型</h1><p>根据<a href="http://stackoverflow.com/questions/9998402/c11-does-not-deduce-type-when-stdfunction-or-lambda-functions-are-involved" target="_blank" rel="noopener">StackOverflow上的这个答案</a>，lambda是函数对象而不是函数，但是可以被转换(convert to)成<code>std::function</code>，这是由<code>std::function</code>的可以有所有能被调用的类型构造，也就是说这可以这么写<code>std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };</code>。但是类型推导是另一回事，因为lambda并不是<code>std::function</code>，我们只能用<code>auto</code>来声明一个lambda表达式，所以编译器不能通过一个lambda去推导<code>std::function</code>的参数。BTW，Effective Modern C++指出使用<code>auto</code>关键字相对于使用显式声明是比较好的。具体得来说他可以避免default initialization的变量、难以表示的类型、避免可能造成的类型截断问题。<br>特别地，标准指出一个<strong>不捕获</strong>lambda表达式可以被转成一个函数指针，但是将这个lambda表达式转成函数指针需要一些技巧，如<a href="https://stackoverflow.com/questions/33024728/function-object-conversion-to-function-pointer" target="_blank" rel="noopener">借助lambda表达式</a>和<a href="http://www.cplusplus.com/forum/general/63552/" target="_blank" rel="noopener">不借助lambda表达式</a>。特别地，函数指针可以看做函数的入口点，它是全局的，而一个函数对象如<code>std::function</code>可以携带context，所以是不能转换为一个函数指针的。在这里还需要将函数签名与函数指针区分开来，一般在使用函数签名的场合常需要考虑C linkage。<br>因此比较好的解决方式是直接使用<code>template&lt;typename F&gt;</code>，所以说现在的问题是如何得到F的返回值类型。<br>这时候可以<a href="https://stackoverflow.com/questions/28618788/why-does-stdresult-of-not-work-with-lambdas" target="_blank" rel="noopener">借助<code>std::result_of</code>来推导<code>typename F</code>的返回类型</a>，注意这里要写成<code>decltype(lambda_func)()</code>，而不是<code>decltype(lambda_func)</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda_func = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">lambda_func_t</span> = <span class="built_in">std</span>::result_of&lt;<span class="keyword">decltype</span>(lambda_func)()&gt;::type;</span><br></pre></td></tr></table></figure></p>
<p>此外，经测试可以推导函数对象的返回类型，不能推导C原生函数的返回类型。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> native_func(<span class="keyword">int</span> a) &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">struct object_func &#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>()(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="keyword">auto</span> call_func(F f)-&gt; std::result_of_t&lt;F(<span class="keyword">int</span>)&gt; &#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    <span class="keyword">typename</span> std::result_of&lt;object_func(<span class="keyword">int</span>)&gt;::type x; <span class="comment">// Yes</span></span><br><span class="line">    <span class="keyword">typename</span> std::result_of&lt;native_func(<span class="keyword">int</span>)&gt;::type y; <span class="comment">// No</span></span><br><span class="line">    object_func of; </span><br><span class="line">    call_func(of); <span class="comment">// Yes</span></span><br><span class="line">    call_func(native_func); <span class="comment">// Yes</span></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考了<a href="http://stackoverflow.com/questions/11470802/stdresult-of-simple-function" target="_blank" rel="noopener">StackOverflow上的答案</a>，这是因为原生函数并不是一个type，但是<code>std::result_of&lt;F(Args...)&gt;</code>中的F必须要是一个类型，合适的解决方法是直接使用<code>decltype</code>+<code>declval</code>，<code>decltype(native_func(std::declval&lt;int&gt;()))</code>，而不是用<code>std::result_of</code>。此外，在C++17标准之后，可以使用<code>std::invoke_result</code>来替代<code>std::result_of</code>。<br>此外，从<a href="http://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda" target="_blank" rel="noopener">这个回答</a>可以看到，可以实现一个<code>function_traits</code>。这个类型类似pattern matching，能够同时处理函数对象和函数的指针的情况，并且能够推导出参数和返回值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span> :</span> <span class="keyword">public</span> function_traits&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; arity = <span class="keyword">sizeof</span>...(Args) &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> ReturnType result_type;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type type;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h1 id="在类模板中声明友元函数模板"><a href="#在类模板中声明友元函数模板" class="headerlink" title="在类模板中声明友元函数模板"></a>在类模板中声明友元函数模板</h1><p>在一个模板类<code>farray</code>中声明一个友元函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">farray</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可能会报error LNK2019: 无法解析的外部符号 “struct for90std::farray<bool> __cdecl for90std::operator&lt;(struct for90std::farray<int> const &amp;,int const &amp;)” (??Mfor90std@@YA?AU?$farray@_N@0@AEBU?$farray@H@0@AEBH@Z)错误<br>原因是<code>T</code>是类模板<code>farray</code>的模板参数，随着类模板特化。所以应该给友元函数<code>operator&lt;</code>独立的模板参数，改成这样就好了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;U&gt; &amp; x, <span class="keyword">const</span> U &amp; y);</span><br></pre></td></tr></table></figure></int></bool></p>
<p>详细可以参考<a href="http://stackoverflow.com/questions/29055696/why-lnk1120-lnk2019-appears-in-case-of-template-and-friend-function" target="_blank" rel="noopener">这篇答案</a></p>
<h1 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h1><p>根据Effective Modern C++ Item 24的规定。函数签名中的<code>T&amp;&amp;</code>，如果<code>T</code>是需要推导得来的，这样的<code>T</code>表示通用引用(universal/forward reference)。通用引用是C++通过引用折叠(reference collapsing)表现出的一个特性，一个通用引用可以绑定到任何由cv修饰的引用上。<br>容易混淆的通用/右值引用包括<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下属于rvalue reference</span></span><br><span class="line"><span class="keyword">void</span> f(Widget&amp;&amp; param);</span><br><span class="line"></span><br><span class="line">Widget&amp;&amp; var1 = Widget();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用引用定义必须是T&amp;&amp;或者auto&amp;&amp;的形式</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> f(std::vector&lt;T&gt;&amp;&amp; param)</span><br><span class="line"></span><br><span class="line">class vector&lt;T, allocator&lt;T&gt;&gt;&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 通用引用中必须发生类型推导</span></span><br><span class="line">    <span class="keyword">void</span> push_back(T&amp;&amp; x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下属于universal reference</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> f(T&amp;&amp; param);</span><br></pre></td></tr></table></figure></p>
<p>如果对于参数包不加上通用引用<code>Args&amp;&amp;</code>，那这个参数包就不能接受一个左值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x, Args ... args)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    test_pack(forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x, Args ... args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    test_pack_clvalue(forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    test_pack_clvalue(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>参数包：parameter pack<br>类型限定符（const, volatile）：qualification adjustment<br>返回类型后置：trailing return type<br>函数签名：signature<br>模板类型推导：template argument deduction<br>聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释<a href="http://blog.csdn.net/lanchunhui/article/details/50532790" target="_blank" rel="noopener"></a><br>非类型模板参数：non type template parameter<br>包扩展：pack expansion<br>花括号初始化器：brace-init-list<br>省略号(…)：ellipsis<br>符号扩展、零扩展：sign/zero extension<br>可变参数模板：Variadic Templates pack<br>展开模式：pattern<br>决议：resolution</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/ICPC CHINA-FINAL小记/" rel="next" title="ICPC CHINA-FINAL小记">
                <i class="fa fa-chevron-left"></i> ICPC CHINA-FINAL小记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/30/C++初始化方式/" rel="prev" title="C++初始化方式">
                C++初始化方式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">106</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">121</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#各种traits"><span class="nav-number">1.</span> <span class="nav-text">各种traits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数值部分"><span class="nav-number">1.1.</span> <span class="nav-text">数值部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器部分"><span class="nav-number">1.2.</span> <span class="nav-text">迭代器部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象行为部分"><span class="nav-number">1.3.</span> <span class="nav-text">对象行为部分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reference-wrapper"><span class="nav-number">2.</span> <span class="nav-text">reference_wrapper</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#operator重载"><span class="nav-number">3.</span> <span class="nav-text">operator重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#const不是编译期常量"><span class="nav-number">4.</span> <span class="nav-text">const不是编译期常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特化using"><span class="nav-number">5.</span> <span class="nav-text">特化using</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#函数模板的特化与函数的重载"><span class="nav-number">6.</span> <span class="nav-text">函数模板的特化与函数的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#借助重载实现函数的“偏特化”"><span class="nav-number">6.1.</span> <span class="nav-text">借助重载实现函数的“偏特化”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借助类模板实现偏特化"><span class="nav-number">6.2.</span> <span class="nav-text">借助类模板实现偏特化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#普通函数、函数模板和全特化模板函数之间的决议"><span class="nav-number">7.</span> <span class="nav-text">普通函数、函数模板和全特化模板函数之间的决议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑可访问性"><span class="nav-number">7.1.</span> <span class="nav-text">考虑可访问性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑隐式类型转换"><span class="nav-number">7.2.</span> <span class="nav-text">考虑隐式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通情况"><span class="nav-number">7.2.1.</span> <span class="nav-text">普通情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隐式类型转换的顺序"><span class="nav-number">7.2.2.</span> <span class="nav-text">隐式类型转换的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑传参时decay的特殊情况"><span class="nav-number">7.2.3.</span> <span class="nav-text">考虑传参时decay的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑继承"><span class="nav-number">7.3.</span> <span class="nav-text">考虑继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SFINAE"><span class="nav-number">8.</span> <span class="nav-text">SFINAE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用SFINAE判断是否存在成员"><span class="nav-number">8.1.</span> <span class="nav-text">使用SFINAE判断是否存在成员</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#判断模板参数是否是广义函数"><span class="nav-number">9.</span> <span class="nav-text">判断模板参数是否是广义函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现member-function的const版本"><span class="nav-number">10.</span> <span class="nav-text">实现member function的const版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#推导lambda的类型"><span class="nav-number">11.</span> <span class="nav-text">推导lambda的类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在类模板中声明友元函数模板"><span class="nav-number">12.</span> <span class="nav-text">在类模板中声明友元函数模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通用引用"><span class="nav-number">13.</span> <span class="nav-text">通用引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用术语"><span class="nav-number">14.</span> <span class="nav-text">常用术语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://calvinneo.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2016/12/22/C++模板编程/';
          this.page.identifier = '2016/12/22/C++模板编程/';
          this.page.title = 'C++模板编程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
