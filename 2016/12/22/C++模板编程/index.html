<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="最近使用C++实现了一些Fortran的数组相关的功能，这里记录了遇到的C++新标准相关的问题，其中大部分是遇到的和模板有关的坑。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板编程">
<meta property="og:url" content="http://www.calvinneo.com/2016/12/22/C++模板编程/index.html">
<meta property="og:site_name" content="Calvin's Marbles">
<meta property="og:description" content="最近使用C++实现了一些Fortran的数组相关的功能，这里记录了遇到的C++新标准相关的问题，其中大部分是遇到的和模板有关的坑。">
<meta property="og:updated_time" content="2018-01-04T05:53:26.579Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++模板编程">
<meta name="twitter:description" content="最近使用C++实现了一些Fortran的数组相关的功能，这里记录了遇到的C++新标准相关的问题，其中大部分是遇到的和模板有关的坑。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2016/12/22/C++模板编程/"/>





  <title>C++模板编程 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2016/12/22/C++模板编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++模板编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T00:29:16+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/12/22/C++模板编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2016/12/22/C++模板编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近使用C++实现了一些Fortran的数组相关的功能，这里记录了遇到的C++新标准相关的问题，其中大部分是遇到的和模板有关的坑。<br><a id="more"></a><br>另外对于Fortran数组的实现放到了<a href="/2017/01/18/Fortran数组的C++实现/">Fortran数组的C++实现</a>中。</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="引用列表"><a href="#引用列表" class="headerlink" title="引用列表"></a>引用列表</h2><p><code>vector</code>放引用应当使用<code>reference_wrapper</code>，不过挺恶心的，因为不能重载<code>operator.</code>的缘故，必须得<code>get()</code>一下</p>
<h2 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h2><p><code>operator=</code>、<code>operator()</code>、<code>operator[]</code>、<code>operator-&gt;</code>、<code>operator T</code>不能作为non-member function，这是因为担心与自动合成的<code>operator=</code>出现行为不一致的问题</p>
<h2 id="const不是编译期常量"><a href="#const不是编译期常量" class="headerlink" title="const不是编译期常量"></a>const不是编译期常量</h2><p>在构造函数的初始化列表中可以进行初始化，对于常量数组，可以使用<code>{}</code>进行初始化，这个在<a href="/2016/12/30/C++初始化方式/">C++初始化方式</a>中有说明<br>在MSVC2015中，下面的代码是无法通过编译的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> C &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> x;</div><div class="line">	C(<span class="keyword">int</span> _x) :x(_x) &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">	<span class="keyword">int</span> a[c.x];</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因是在<code>C.x</code>虽然是常量，但是要到运行期才能知道，这里应该使用的是<code>static const</code>或者<code>constexpr</code>，<code>const</code>修饰符实际上的意义更接近于<code>readonly</code>。如果说<code>const</code>能够“节省空间”，那是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="external">const对象实际上并不发生复制</a>，但只<code>const</code>修饰的类成员仍然是占空间的。</p>
<h2 id="“偏特化”函数"><a href="#“偏特化”函数" class="headerlink" title="“偏特化”函数"></a>“偏特化”函数</h2><p>需要注意的是，函数模板不能偏特化，因为函数本身就有重载。如果需要使用“偏特化的函数模板”，考虑在一个偏特化类中实现static函数。<br>这又带来一个新的问题，考虑要偏特化一个类中<strong>成员函数</strong>，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="external">这里的说明</a></p>
<p>还有一种情况，当我们要“偏特化”的是非类型模板参数，例如<code>int</code>时。例如现在需要判断一个关于类型<code>T</code>的<code>D</code>维数组<code>farray</code>中维数<code>D</code>是否为1，可以利用SFINAE<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::conditional&lt;D == <span class="number">1</span>, <span class="built_in">std</span>::true_type, <span class="built_in">std</span>::false_type&gt;::type is_vector;</div><div class="line">farray&lt;T, D&gt; &amp; _pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::true_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; _pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::false_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x) &#123;</div><div class="line">	<span class="keyword">return</span> _pluseq_impl(x, is_vector());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现实际上可以根据函数的重载而不是“偏特化”来实现上面的功能。<br>此外，模板函数一旦全特化，就应当和对待普通函数一样，使用<code>inline</code>，<code>static</code>，<code>extern</code>关键字防止重复包含。</p>
<h2 id="特化using"><a href="#特化using" class="headerlink" title="特化using"></a>特化using</h2><p>与函数相同，C++中的<code>using</code>也不能直接特化，如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">using</span> wrap&lt;T&gt; = T;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="keyword">using</span> wrap&lt;<span class="keyword">int</span>&gt; = <span class="keyword">int</span>;</div></pre></td></tr></table></figure></p>
<p>必须需要借助类来workaround<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> wrap&#123;</div><div class="line">	<span class="keyword">using</span> type = T;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数模板的特化与函数的重载"><a href="#函数模板的特化与函数的重载" class="headerlink" title="函数模板的特化与函数的重载"></a>函数模板的特化与函数的重载</h2><p>为了实现函数的“多态”，常有模板特化和重载两种方式。<br>根据上面的讨论，由于函数模板不能偏特化，因此常使用类模板重载<code>operator()</code>的方式实现一个仿函数。</p>
<h3 id="全特化函数模板和同签名的普通函数"><a href="#全特化函数模板和同签名的普通函数" class="headerlink" title="全特化函数模板和同签名的普通函数"></a>全特化函数模板和同签名的普通函数</h3><p>对于全特化的函数模板，它和不加<code>template&lt;&gt;</code>的普通函数有什么区别呢？根据C++ Premier中的说明</p>
<blockquote>
<p>当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的</p>
</blockquote>
<p><code>template&lt;&gt;</code>特化函数模板比普通函数匹配更为精确，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #1 </span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x, T y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #2 </span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">	promotion(<span class="number">1.0</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>main</code>中第1条语句输出<code>&quot;function&quot;</code>，因为<code>1</code>是int，不能精确匹配2号函数的两个<code>double</code>，所以只能匹配到3号函数<br><code>main</code>中第1条语句输出<code>&quot;template&lt;&gt;&quot;</code>，这时候两个参数都是<code>double</code>，于是2号函数更精确了。<br>又例如将3号和<code>main</code>改为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先根据上面的结论，1号模板函数肯定是匹配不了的，<br>注释掉2，得到输出是function，这是因为第一个参数1被隐式转换成1.0了<br>注释掉3，得到编译错误，因为特化模板要精确匹配</p>
<h3 id="考虑可访问性"><a href="#考虑可访问性" class="headerlink" title="考虑可访问性"></a>考虑可访问性</h3><p>C++中的可访问性包括private、protected和public三类，可访问性是针对类而不是对象而言的。<br><a href="http://blog.csdn.net/starlee/article/details/1406781" target="_blank" rel="external">C++中重载决议是在可访问性检查之前进行的</a></p>
<h3 id="考虑隐式类型转换"><a href="#考虑隐式类型转换" class="headerlink" title="考虑隐式类型转换"></a>考虑隐式类型转换</h3><p>在日常编程中，我们我们常常把字符串直接量当做<code>std::string</code>使用，但其实字符串直接量的类型是<code>const char[]</code>，这其中涉及到隐式构造函数或者隐式类型转换。这导致在进行重载决议时出现“不合常理”的情况。</p>
<h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><p>在<a href="https://www.zhihu.com/question/27932618" target="_blank" rel="external">知乎的这篇问题</a>中，我们看到<code>Test</code>中定义了两个成员函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Test &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</span></span>;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 1"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 2"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在考虑调用</p>
<pre><code>Test().find(&quot;a&quot;, &quot;b&quot;);
</code></pre><p>我们发现是调用的find 2版本的函数。这是由于<code>const char[]</code>被decay成了<code>const char *</code>，然后隐式转换成了<code>bool</code>。<br>类型隐式转换具有下面的顺序：</p>
<ol>
<li>精确匹配<br> 这里对应着四种的decay，即<code>T[] -&gt; T*</code>、<code>T&amp; -&gt; T</code>、<code>F(...) -&gt; F (*)(...)</code>、<code>T const -&gt; T</code><ol>
<li>无转换</li>
<li>lvalue到rvalue、数组到指针、函数到指针</li>
<li>限定符转换</li>
</ol>
</li>
<li>类型提升转换(promotion)<br> 即Numeric promotions，包含Integral promotion和Floating-point promotion<br> 这里注意，<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="external">非promotion的整数之间转换都作为conversion</a>，如<code>char -&gt; int</code></li>
<li>标准转换<br> 包含Numeric conversions，如Integral conversions、Floating-point conversions、Floating–integral conversions、Pointer conversions、Boolean conversions</li>
<li>用户自定义转换<br> 这就包括了<code>std::string</code>中定义的从<code>const char *</code>的转换了</li>
</ol>
<h3 id="考虑传参时decay的特殊情况"><a href="#考虑传参时decay的特殊情况" class="headerlink" title="考虑传参时decay的特殊情况"></a>考虑传参时decay的特殊情况</h3><p>同样是类型转换问题，在<a href="http://www.cnblogs.com/liyuan989/p/4138378.html" target="_blank" rel="external">文章</a>中提到了一个特别的情况<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"template"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"normal"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在调用</p>
<pre><code>compare(&quot;123456&quot;, &quot;123456&quot;);
</code></pre><p>请问是调用了那个函数呢？<br>有意思的是，对于不同编译器，结果还不一样。作者指出对G++/clang来说是调用了模板版本，而我使用VS2015发现调用的是普通版本。<br>调用模板版本的原因是<code>T = const char [6]</code>相比退化后的<code>const char *</code>更精确。<br>但是调用普通版本的原因是数组传参时要转换成对应的指针。因此对于模板函数和普通函数实际上都不是精确匹配的（都要经过一次类型转换）。根据C++重载决议原则，如果调用具有二义性，则优先选择调用普通函数。<br>在本篇结尾，作者引用陈硕的观点，认为G++/clang的实现是符合标准的，但是这属于标准的bug。其原因是<strong>模板实参推断<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC" target="_blank" rel="external">(template argument deduction)</a></strong>时，除了产生新的实例化之外，编译器只会执行两种转换</p>
<ol>
<li>const转换：接受const引用或指针的函数可以分别用非const对象的引用或指针来调用，无须产生新的实例化。也就是可以传一个非const到需要const参数的函数。</li>
<li>数组或函数到指针的转换：<strong>如果模板形参不是引用类型</strong>，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针，函数实参当作指向函数类型的指针。</li>
</ol>
<p>由于模板参数使用了数组的const引用类型，所以按照标准应该不将数组向指针进行decay。</p>
<h2 id="借助模板偏特化实现Expression-SFINAE"><a href="#借助模板偏特化实现Expression-SFINAE" class="headerlink" title="借助模板偏特化实现Expression SFINAE"></a>借助模板偏特化实现Expression SFINAE</h2><p>模板偏特化是相对原型/初等（primary template）模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板。<br>例如对模板类型参数<code>T</code>而言，<code>T*</code>、<code>T&amp;</code>等是它的一个偏特化。<br>SFINAE(Substitution Failure Is Not An Error)是C++的模板编译规则，当推导<strong>模板参数</strong>（注意在函数内部使用ill-formed会导致hard error）失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。于是可以通过人为构造ill-formed的表达式或者类型来实现一些功能。<br>比较通用的做法是使用函数重载来实现SFINAE，但也可以借助模板偏特化来实现SFINAE。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// https://www.zhihu.com/question/34264462</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont,</div><div class="line">	<span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line">	<span class="keyword">struct</span> has_push_back : <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line"><span class="keyword">struct</span> has_push_back&lt;Cont, <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;Cont::push_back)&gt;&gt; : <span class="built_in">std</span>::true_type &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>始终对<code>std::vector&lt;int&gt;</code>断言失败。后来查看<a href="http://stackoverflow.com/questions/31907885/void-t-fails-on-visual-studio-2015" target="_blank" rel="external">SoF</a>以为是MSVC2015对<code>std::void_t</code>的支持有问题。<br>后来在SoF的<a href="http://stackoverflow.com/questions/27687389/how-does-void-t-work" target="_blank" rel="external">另一篇博文上</a>发现如果不是选择成员函数，而是选择数据成员就可以通过<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> , <span class="keyword">class</span> = <span class="keyword">void</span> &gt;</div><div class="line"><span class="keyword">struct</span> has_member : <span class="built_in">std</span>::false_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// specialized as has_member&lt; T , void &gt; or discarded (sfinae)</span></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="keyword">struct</span> has_member&lt; T , <span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>( T::member ) &gt; &gt; : <span class="built_in">std</span>::true_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> member;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; A &gt;::value , <span class="string">"A"</span> );</div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; B &gt;::value , <span class="string">"B"</span> );</div></pre></td></tr></table></figure></p>
<p>后来去SoF上问了一波，这是因为<code>std::vector&lt;int&gt;::push_back</code>有多个重载版本，于是应该还要匹配函数签名。注意返回值不是函数签名的一部分（所以函数重载决议也是不包括返回值的），不被推导。<br>关于这种expression sfinae，可以参考<a href="http://stackoverflow.com/questions/12654067/what-is-expression-sfinae" target="_blank" rel="external">这个回答</a><br>但是这样还有个问题，例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;_Container_value_type&gt;().size()) &gt;&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Container_value_type&gt;</div><div class="line"><span class="keyword">void</span> getsize(<span class="keyword">const</span> for1array&lt;_Container_value_type&gt; &amp; farr) &#123;</div><div class="line">	getsize_impl&lt;_Container_value_type&gt;(farr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样会出现函数模板已经定义的错误。在<a href="http://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="external">cppreference</a>中给出了说明</p>
<blockquote>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal.</p>
</blockquote>
<p>此外在<a href="http://stackoverflow.com/questions/30953248/why-doesnt-sfinae-enable-if-work-for-member-functions-of-a-class-template" target="_blank" rel="external">SoF</a> 上给出了如下说明</p>
<blockquote>
<p>SFINAE only works for deduced template arguments</p>
</blockquote>
<p>此外，实际上编译器不需要指定特化就可以区分匹配下面的两个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(Cont &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"not array"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(for1array&lt;Cont&gt; &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"array"</span>);</div><div class="line">		for1array_init&lt;<span class="keyword">typename</span> Cont::value_type&gt;(farr(<span class="number">1</span>)); <span class="comment">// 报错，因为typename Cont::value_type是ill-fromed</span></div><div class="line">		for1array_init(farr(<span class="number">1</span>)); <span class="comment">// 得到正确结果</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>编译错误是因为编译器会对<code>typename Cont::value_type</code>这个ill-formed求值报错，而不是重新使用上面的primary template推导，因此只可以在模板参数里写出要有<code>value_type</code>，这样的”concept”。例如下面的用法同样也是错的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> for1array_gettype2 &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;is_for1array::test&lt;T&gt;(<span class="literal">nullptr</span>), <span class="keyword">typename</span> for1array_gettype&lt;<span class="keyword">typename</span> T::value_type&gt;::type, T&gt; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="判断模板参数是否是广义函数"><a href="#判断模板参数是否是广义函数" class="headerlink" title="判断模板参数是否是广义函数"></a>判断模板参数是否是广义函数</h2><p>目前广义函数包括函数、<code>std::function</code>、lambda、仿函数，其中<code>std::is_function</code>只能识别函数。C++17标准添加了<code>std::is_invocable</code>(<code>std::is_callable</code>)，用来表示可以INVOKE的类型。</p>
<h2 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h2><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="external">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>
<h2 id="推导lambda的类型"><a href="#推导lambda的类型" class="headerlink" title="推导lambda的类型"></a>推导lambda的类型</h2><p>根据<a href="http://stackoverflow.com/questions/9998402/c11-does-not-deduce-type-when-stdfunction-or-lambda-functions-are-involved" target="_blank" rel="external">StackOverflow上的这个答案</a>，lambda是函数对象而不是函数，但是可以被转换(convert to)成<code>std::function</code>，这是由<code>std::function</code>的可以有所有能被调用的类型构造，也就是说这可以这么写<code>std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };</code>。但是类型推导是另一回事，因为lambda并不是<code>std::function</code>，我们只能用<code>auto</code>来声明一个lambda表达式，所以编译器不能通过一个lambda去推导<code>std::function</code>的参数。BTW，Effective Modern C++指出使用<code>auto</code>关键字相对于使用显式声明是比较好的。具体得来说他可以避免default initialization的变量、难以表示的类型、避免可能造成的类型截断问题。<br>特别地，标准指出一个<strong>不捕获</strong>lambda表达式可以被转成一个函数指针，但是将函数对象转成函数指针需要一些技巧，如<a href="https://stackoverflow.com/questions/33024728/function-object-conversion-to-function-pointer" target="_blank" rel="external">借助lambda表达式</a>和<a href="http://www.cplusplus.com/forum/general/63552/" target="_blank" rel="external">不借助lambda表达式</a>。<br>因此比较好的解决方式是直接使用<code>template&lt;typename F&gt;</code>，所以说现在的问题是如何得到F的返回值类型。<br>这时候可以<a href="https://stackoverflow.com/questions/28618788/why-does-stdresult-of-not-work-with-lambdas" target="_blank" rel="external">借助<code>std::result_of</code>来推导<code>typename F</code>的返回类型</a>，注意这里要写成<code>decltype(lambda_func)()</code>，而不是<code>decltype(lambda_func)</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> lambda_func = []()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">using</span> <span class="keyword">lambda_func_t</span> = <span class="built_in">std</span>::result_of&lt;<span class="keyword">decltype</span>(lambda_func)()&gt;::type;</div></pre></td></tr></table></figure></p>
<p>此外，经测试可以推导函数对象的返回类型，不能推导C原生函数的返回类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> native_func(<span class="keyword">int</span> a) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_func</span></span> &#123;</div><div class="line">	<span class="keyword">int</span> operator()(<span class="keyword">int</span> a) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">template&lt;typename F&gt;</div><div class="line">auto call_func(F f)-&gt; std::result_of_t&lt;F(<span class="keyword">int</span>)&gt; &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> main() &#123;</div><div class="line">	typename std::result_of&lt;object_func(<span class="keyword">int</span>)&gt;::<span class="class"><span class="keyword">type</span> <span class="title">x</span></span>; <span class="comment">// Yes</span></div><div class="line">	typename std::result_of&lt;native_func(<span class="keyword">int</span>)&gt;::<span class="class"><span class="keyword">type</span> <span class="title">y</span></span>; <span class="comment">// No</span></div><div class="line">	object_func of; </div><div class="line">	call_func(of); <span class="comment">// Yes</span></div><div class="line">	call_func(native_func); <span class="comment">// Yes</span></div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>参考了<a href="http://stackoverflow.com/questions/11470802/stdresult-of-simple-function" target="_blank" rel="external">StackOverflow上的答案</a>，这是因为原生函数并不是一个type，但是<code>std::result_of&lt;F(Args...)&gt;</code>中的F必须要是一个类型，合适的解决方法是直接使用<code>decltype</code>+<code>declval</code>，<code>decltype(native_func(std::declval&lt;int&gt;()))</code>，而不是用<code>std::result_of</code>。此外，在C++17标准之后，可以使用<code>std::invoke_result</code>来替代<code>std::result_of</code>。<br>此外，从<a href="http://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda" target="_blank" rel="external">这个回答</a>可以看到，可以实现一个<code>function_traits</code>。这个类型类似pattern matching，能够同时处理函数对象和函数的指针的情况，并且能够推导出参数和返回值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> function_traits : <span class="keyword">public</span> function_traits&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="keyword">struct</span> function_traits&lt;ReturnType(ClassType::*)(Args...) <span class="keyword">const</span>&gt;</div><div class="line">&#123;</div><div class="line">	<span class="keyword">enum</span> &#123; arity = <span class="keyword">sizeof</span>...(Args) &#125;;</div><div class="line">	<span class="keyword">typedef</span> ReturnType result_type;</div><div class="line">	<span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</div><div class="line">	<span class="keyword">struct</span> arg</div><div class="line">	&#123;</div><div class="line">		<span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type type;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="在类模板中声明友元函数模板"><a href="#在类模板中声明友元函数模板" class="headerlink" title="在类模板中声明友元函数模板"></a>在类模板中声明友元函数模板</h2><p>在一个模板类<code>farray</code>中声明一个友元函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> farray&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">	<span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y)&#123;</div><div class="line">	<span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能会报error LNK2019: 无法解析的外部符号 “struct for90std::farray<bool> __cdecl for90std::operator&lt;(struct for90std::farray<int> const &amp;,int const &amp;)” (??Mfor90std@@YA?AU?$farray@_N@0@AEBU?$farray@H@0@AEBH@Z)错误<br>原因是<code>T</code>是类模板<code>farray</code>的模板参数，随着类模板特化。所以应该给友元函数<code>operator&lt;</code>独立的模板参数，改成这样就好了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;U&gt; &amp; x, <span class="keyword">const</span> U &amp; y);</div></pre></td></tr></table></figure></int></bool></p>
<p>详细可以参考<a href="http://stackoverflow.com/questions/29055696/why-lnk1120-lnk2019-appears-in-case-of-template-and-friend-function" target="_blank" rel="external">这篇答案</a></p>
<h2 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h2><p>根据Effective Modern C++ Item 24的规定。函数签名中的<code>T&amp;&amp;</code>，如果<code>T</code>是需要推导得来的，这样的<code>T</code>表示通用引用(universal/forward reference)。通用引用是C++通过引用折叠(reference collapsing)表现出的一个特性，一个通用引用可以绑定到任何由cv修饰的引用上。<br>容易混淆的通用/右值引用包括<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 以下属于rvalue reference</span></div><div class="line"><span class="keyword">void</span> f(Widget&amp;&amp; param);</div><div class="line"></div><div class="line">Widget&amp;&amp; var1 = Widget();</div><div class="line"></div><div class="line"><span class="comment">// 通用引用定义必须是T&amp;&amp;或者auto&amp;&amp;的形式</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> f(std::vector&lt;T&gt;&amp;&amp; param)</div><div class="line"></div><div class="line"><span class="keyword">class</span> vector&lt;T, allocator&lt;T&gt;&gt;&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	<span class="comment">// 通用引用中必须发生类型推导</span></div><div class="line">    <span class="keyword">void</span> push_back(T&amp;&amp; x);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 以下属于universal reference</span></div><div class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">void</span> f(T&amp;&amp; param);</div></pre></td></tr></table></figure></p>
<p>如果对于参数包不加上通用引用<code>Args&amp;&amp;</code>，那这个参数包就不能接受一个左值。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x, Args ... args)</span> </span>&#123;</div><div class="line">	x = <span class="number">1</span>;</div><div class="line">	test_pack(forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_lvalue</span><span class="params">(T &amp; x)</span> </span>&#123;</div><div class="line">	x = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x, Args ... args)</span> </span>&#123;</div><div class="line"></div><div class="line">	test_pack_clvalue(forward&lt;Args&gt;(args)...);</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_pack_clvalue</span><span class="params">(<span class="keyword">const</span> T &amp; x)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</div><div class="line">	test_pack_clvalue(a, b, c);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>参数包：parameter pack<br>类型限定符（const, volatile）：qualification adjustment<br>返回类型后置：trailing return type<br>函数签名：signature<br>模板类型推导：template argument deduction<br>聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释<a href="http://blog.csdn.net/lanchunhui/article/details/50532790" target="_blank" rel="external"></a><br>非类型模板参数：non type template parameter<br>包扩展：pack expansion<br>brace-init-list<br>省略号(…)：ellipsis<br>符号扩展、零扩展：sign/zero extension<br>可变参数模板：Variadic Templates pack<br>展开模式：pattern<br>决议：resolution</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/ICPC CHINA-FINAL小记/" rel="next" title="ICPC CHINA-FINAL小记">
                <i class="fa fa-chevron-left"></i> ICPC CHINA-FINAL小记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/30/C++初始化方式/" rel="prev" title="C++初始化方式">
                C++初始化方式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">96</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">110</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#注意事项"><span class="nav-number">1.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用列表"><span class="nav-number">1.1.</span> <span class="nav-text">引用列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator重载"><span class="nav-number">1.2.</span> <span class="nav-text">operator重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const不是编译期常量"><span class="nav-number">1.3.</span> <span class="nav-text">const不是编译期常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“偏特化”函数"><span class="nav-number">1.4.</span> <span class="nav-text">“偏特化”函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特化using"><span class="nav-number">1.5.</span> <span class="nav-text">特化using</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板的特化与函数的重载"><span class="nav-number">1.6.</span> <span class="nav-text">函数模板的特化与函数的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#全特化函数模板和同签名的普通函数"><span class="nav-number">1.6.1.</span> <span class="nav-text">全特化函数模板和同签名的普通函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑可访问性"><span class="nav-number">1.6.2.</span> <span class="nav-text">考虑可访问性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑隐式类型转换"><span class="nav-number">1.6.3.</span> <span class="nav-text">考虑隐式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#情况1"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">情况1</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑传参时decay的特殊情况"><span class="nav-number">1.6.4.</span> <span class="nav-text">考虑传参时decay的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#借助模板偏特化实现Expression-SFINAE"><span class="nav-number">1.7.</span> <span class="nav-text">借助模板偏特化实现Expression SFINAE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#判断模板参数是否是广义函数"><span class="nav-number">1.8.</span> <span class="nav-text">判断模板参数是否是广义函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现member-function的const版本"><span class="nav-number">1.9.</span> <span class="nav-text">实现member function的const版本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#推导lambda的类型"><span class="nav-number">1.10.</span> <span class="nav-text">推导lambda的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在类模板中声明友元函数模板"><span class="nav-number">1.11.</span> <span class="nav-text">在类模板中声明友元函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用引用"><span class="nav-number">1.12.</span> <span class="nav-text">通用引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用术语"><span class="nav-number">2.</span> <span class="nav-text">常用术语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://calvinneo.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2016/12/22/C++模板编程/';
          this.page.identifier = '2016/12/22/C++模板编程/';
          this.page.title = 'C++模板编程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
