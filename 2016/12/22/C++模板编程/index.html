<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,元编程," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="最近使用C++实现了一些fortran的内部函数和STL，其中遇到了一些问题">
<meta property="og:type" content="article">
<meta property="og:title" content="C++模板编程">
<meta property="og:url" content="http://www.calvinneo.com/2016/12/22/C++模板编程/index.html">
<meta property="og:site_name" content="Calvin's Marbles">
<meta property="og:description" content="最近使用C++实现了一些fortran的内部函数和STL，其中遇到了一些问题">
<meta property="og:updated_time" content="2017-01-20T14:17:19.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++模板编程">
<meta name="twitter:description" content="最近使用C++实现了一些fortran的内部函数和STL，其中遇到了一些问题">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://www.calvinneo.com/2016/12/22/C++模板编程/"/>


  <title> C++模板编程 | Calvin's Marbles </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Calvin's Marbles</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++模板编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-12-22T00:29:16+08:00" content="2016-12-22">
              2016-12-22
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/12/22/C++模板编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/22/C++模板编程/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
              &nbsp; | &nbsp;
              <span class="page-pv"><i class="fa fa-file-o"></i>
              <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
              </span>
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近使用C++实现了一些fortran的内部函数和STL，其中遇到了一些问题<br><a id="more"></a></p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="引用列表"><a href="#引用列表" class="headerlink" title="引用列表"></a>引用列表</h2><p><code>vector</code>放引用应当使用<code>reference_wrapper</code>，不过挺恶心的，因为不能重载<code>operator.</code>的缘故，必须得<code>get()</code>一下</p>
<h2 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h2><p><code>operator=</code>、<code>operator()</code>、<code>operator[]</code>、<code>operator-&gt;</code>、<code>operator T</code>不能作为non-member function，这是因为担心与自动合成的<code>operator=</code>出现行为不一致的问题</p>
<h2 id="初始化类中的const成员"><a href="#初始化类中的const成员" class="headerlink" title="初始化类中的const成员"></a>初始化类中的const成员</h2><p>在构造函数的初始化列表中可以进行初始化，对于常量数组，可以使用<code>{}</code>进行初始化<br>在MSVC2015中，下面的代码是无法通过编译的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> C &#123;</div><div class="line">	<span class="keyword">const</span> <span class="keyword">int</span> x;</div><div class="line">	C(<span class="keyword">int</span> <span class="number">_</span>x) :x(<span class="number">_</span>x) &#123;</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</div><div class="line">	<span class="keyword">int</span> a[c.x];</div><div class="line">	system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>原因是在C.x虽然是常量，但是要到运行期才能知道，事实上只用const修饰的类成员仍然是占空间的，const节省空间的意义是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="external">const对象实际上并不发生复制</a></p>
<h2 id="函数模板特化"><a href="#函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h2><h2 id="全特化函数模板和同签名的普通函数"><a href="#全特化函数模板和同签名的普通函数" class="headerlink" title="全特化函数模板和同签名的普通函数"></a>全特化函数模板和同签名的普通函数</h2><p>对于全特化的函数模板，它和不加<code>template&lt;&gt;</code>的普通函数有什么区别呢？根据C++ Premier中的说明</p>
<blockquote>
<p>当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的</p>
</blockquote>
<p><code>template&lt;&gt;</code>特化函数模板比普通函数匹配更为精确，比如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #1 </span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x, T y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #2 </span></div><div class="line"><span class="keyword">template</span>&lt;&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">	promotion(<span class="number">1.0</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>main</code>中第1条语句输出<code>&quot;function&quot;</code>，因为<code>1</code>是int，不能精确匹配2号函数的两个<code>double</code>，所以只能匹配到3号函数<br><code>main</code>中第1条语句输出<code>&quot;template&lt;&gt;&quot;</code>，这时候两个参数都是<code>double</code>，于是2号函数更精确了。<br>又例如将3号和<code>main</code>改为<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// #3</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</div><div class="line">	<span class="built_in">puts</span>(<span class="string">"function"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">	promotion(<span class="number">1</span>, <span class="number">1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先根据上面的结论，1号模板函数肯定是匹配不了的，<br>注释掉2，得到输出是function，这是因为第一个参数1被隐式转换成1.0了<br>注释掉3，得到编译错误，因为特化模板要精确匹配</p>
<h2 id="“偏特化”函数"><a href="#“偏特化”函数" class="headerlink" title="“偏特化”函数"></a>“偏特化”函数</h2><p>需要注意的是，函数模板不能偏特化，如果需要使用“偏特化的函数模板”，考虑在一个偏特化类中实现static函数。<br>这又带来一个新的问题，考虑要偏特化一个类中<strong>成员函数</strong>，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="external">这里的说明</a>，这里另外给出对于非类型模板参数的写法<br>例如现在需要判断一个关于类型T的D维矩阵中维数<code>D</code>是否为1，可以这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::conditional&lt;D == <span class="number">1</span>, <span class="built_in">std</span>::true_type, <span class="built_in">std</span>::false_type&gt;::type is_vector;</div><div class="line">farray&lt;T, D&gt; &amp; <span class="number">_</span>pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::true_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"true"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; <span class="number">_</span>pluseq_impl(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x, <span class="built_in">std</span>::false_type) &#123;</div><div class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"false"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line">farray&lt;T, D&gt; &amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> farray&lt;T, D&gt; &amp; x) &#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">_</span>pluseq_impl(x, is_vector());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现实际上可以根据函数的重载而不是“偏特化”来实现上面的功能。<br> 此外，模板函数一旦全特化，就应当和对待普通函数一样，使用<code>inline</code>，<code>static</code>，<code>extern</code>关键字防止重复包含</p>
<h2 id="使用void-t实现Expression-SFINAE"><a href="#使用void-t实现Expression-SFINAE" class="headerlink" title="使用void_t实现Expression SFINAE"></a>使用void_t实现Expression SFINAE</h2><p>模板偏特化是相对原型（primary template）模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板<br>SFINAE(Substitution Failure Is Not An Error)是C++的模板编译规则，当推导<strong>模板参数</strong>（注意在函数内部使用ill-formed会导致hard error）失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。于是可以通过人为构造ill-formed的表达式或者类型来实现一些功能。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// https://www.zhihu.com/question/34264462</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont,</div><div class="line">	<span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line">	<span class="keyword">struct</span> has_push_back : <span class="built_in">std</span>::false_type &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line"><span class="keyword">struct</span> has_push_back&lt;Cont, <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;Cont::push_back)&gt;&gt; : <span class="built_in">std</span>::true_type &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>始终对<code>std::vector&lt;int&gt;</code>断言失败。后来查看<a href="http://stackoverflow.com/questions/31907885/void-t-fails-on-visual-studio-2015" target="_blank" rel="external">SoF</a>以为是MSVC2015对<code>std::void_t</code>的支持有问题。<br>后来在SoF的<a href="http://stackoverflow.com/questions/27687389/how-does-void-t-work" target="_blank" rel="external">另一篇博文上</a>发现如果不是选择成员函数，而是选择数据成员就可以通过<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> , <span class="keyword">class</span> = <span class="keyword">void</span> &gt;</div><div class="line"><span class="keyword">struct</span> has_member : <span class="built_in">std</span>::false_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="comment">// specialized as has_member&lt; T , void &gt; or discarded (sfinae)</span></div><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T &gt;</div><div class="line"><span class="keyword">struct</span> has_member&lt; T , <span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>( T::member ) &gt; &gt; : <span class="built_in">std</span>::true_type</div><div class="line">&#123; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> member;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> B &#123;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; A &gt;::value , <span class="string">"A"</span> );</div><div class="line"><span class="keyword">static_assert</span>( has_member&lt; B &gt;::value , <span class="string">"B"</span> );</div></pre></td></tr></table></figure></p>
<p>后来去SoF上问了一波，这是因为<code>std::vector&lt;int&gt;::push_back</code>有多个重载版本，于是应该还要匹配函数签名。这样就可以了。<br>关于这种expression sfinae，可以参考<a href="http://stackoverflow.com/questions/12654067/what-is-expression-sfinae" target="_blank" rel="external">这个回答</a><br>但是这样还有个问题，例如<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Container_value_type, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;<span class="number">_</span>Container_value_type&gt; &amp; farr) &#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Container_value_type, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt; <span class="keyword">decltype</span>(<span class="built_in">std</span>::declval&lt;<span class="number">_</span>Container_value_type&gt;().size()) &gt;&gt;</div><div class="line"><span class="keyword">void</span> getsize_impl(<span class="keyword">const</span> for1array&lt;<span class="number">_</span>Container_value_type&gt; &amp; farr) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> <span class="number">_</span>Container_value_type&gt;</div><div class="line"><span class="keyword">void</span> getsize(<span class="keyword">const</span> for1array&lt;<span class="number">_</span>Container_value_type&gt; &amp; farr) &#123;</div><div class="line">	getsize_impl&lt;<span class="number">_</span>Container_value_type&gt;(farr);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样会出现函数模板已经定义的错误。在<a href="http://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="external">cppreference</a>中给出了说明</p>
<blockquote>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal.</p>
</blockquote>
<p>此外在<a href="http://stackoverflow.com/questions/30953248/why-doesnt-sfinae-enable-if-work-for-member-functions-of-a-class-template" target="_blank" rel="external">SoF</a> 上给出了如下说明</p>
<blockquote>
<p>SFINAE only works for deduced template arguments</p>
</blockquote>
<p>此外，实际上编译器不需要指定特化就可以区分匹配下面的两个函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(Cont &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"not array"</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">for1array_init</span><span class="params">(for1array&lt;Cont&gt; &amp; farr)</span> </span>&#123;</div><div class="line">		<span class="built_in">puts</span>(<span class="string">"array"</span>);</div><div class="line">		for1array_init&lt;<span class="keyword">typename</span> Cont::value_type&gt;(farr(<span class="number">1</span>)); <span class="comment">// 报错，因为typename Cont::value_type是ill-fromed</span></div><div class="line">		for1array_init(farr(<span class="number">1</span>)); <span class="comment">// 得到正确结果</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>编译错误是因为编译器会对<code>typename Cont::value_type</code>这个ill-formed求值报错，而不是重新使用上面的primary template推导，因此只可以在模板参数里写出要有<code>value_type</code>，这样的”concept”。例如下面的用法同样也是错的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct</span> for1array_gettype2 &#123;</div><div class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::conditional&lt;is_for1array::test&lt;T&gt;(<span class="literal">nullptr</span>), <span class="keyword">typename</span> for1array_gettype&lt;<span class="keyword">typename</span> T::value_type&gt;::type, T&gt; type;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="判断模板参数是否是广义函数"><a href="#判断模板参数是否是广义函数" class="headerlink" title="判断模板参数是否是广义函数"></a>判断模板参数是否是广义函数</h1><p>目前广义函数包括函数、<code>std::function</code>、lambda、仿函数，其中<code>std::is_function</code>只能识别函数。c++17标准添加了<code>std::is_callable</code>，现在考虑C++14标准。</p>
<h1 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h1><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="external">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改费mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>
<h1 id="将带类型推导的lambda传给std-function"><a href="#将带类型推导的lambda传给std-function" class="headerlink" title="将带类型推导的lambda传给std::function"></a>将带类型推导的lambda传给std::function</h1><p>返回值不是函数签名的一部分，不被推导<br>根据<a href="http://stackoverflow.com/questions/9998402/c11-does-not-deduce-type-when-stdfunction-or-lambda-functions-are-involved" target="_blank" rel="external">StackOverflow上的这个答案</a>，lambda是函数对象而不是函数，但是可以被转换(convert to)成<code>std::function</code>，这是由<code>std::function</code>的可以有所有能被调用的类型构造，也就是说这可以这么写<code>std::function&lt;int(int)&gt;lambda = [](int x) {return 0; };</code>。但是类型推导是另一回事，因为lambda并不是<code>std::function</code>，所以编译器不能通过一个lambda去推导<code>std::function</code>的参数<br>因此比较好的解决方式是直接使用<code>template&lt;typename F&gt;</code>，所以说现在的问题是如何得到F的返回值类型。从<a href="http://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda" target="_blank" rel="external">这个回答</a>可以看到<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>参数包：parameter pack<br>类型限定符（const, volatile）：qualification adjustment<br>返回类型后置：trailing return type<br>函数签名：signature<br>模板类型推导：template argument deduction<br>聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释<a href="http://blog.csdn.net/lanchunhui/article/details/50532790" target="_blank" rel="external"></a><br>非类型模板参数：non type template parameter<br>包扩展：pack expansion<br>brace-init-list<br>省略号(…)：ellipsis<br>符号扩展、零扩展<br>可变参数模板：Variadic Templates pack<br>展开模式：pattern<br>决议：resolution</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag">#C++</a>
          
            <a href="/tags/元编程/" rel="tag">#元编程</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/ICPC CHINA-FINAL小记/" rel="next" title="ICPC CHINA-FINAL小记">
                <i class="fa fa-chevron-left"></i> ICPC CHINA-FINAL小记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/30/C++初始化方式/" rel="prev" title="C++初始化方式(翻译)">
                C++初始化方式(翻译) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/12/22/C++模板编程/"
           data-title="C++模板编程" data-url="http://www.calvinneo.com/2016/12/22/C++模板编程/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">70</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#注意事项"><span class="nav-number">1.</span> <span class="nav-text">注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引用列表"><span class="nav-number">1.1.</span> <span class="nav-text">引用列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#operator重载"><span class="nav-number">1.2.</span> <span class="nav-text">operator重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#初始化类中的const成员"><span class="nav-number">1.3.</span> <span class="nav-text">初始化类中的const成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板特化"><span class="nav-number">1.4.</span> <span class="nav-text">函数模板特化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全特化函数模板和同签名的普通函数"><span class="nav-number">1.5.</span> <span class="nav-text">全特化函数模板和同签名的普通函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#“偏特化”函数"><span class="nav-number">1.6.</span> <span class="nav-text">“偏特化”函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用void-t实现Expression-SFINAE"><span class="nav-number">1.7.</span> <span class="nav-text">使用void_t实现Expression SFINAE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#判断模板参数是否是广义函数"><span class="nav-number">2.</span> <span class="nav-text">判断模板参数是否是广义函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实现member-function的const版本"><span class="nav-number">3.</span> <span class="nav-text">实现member function的const版本</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#将带类型推导的lambda传给std-function"><span class="nav-number">4.</span> <span class="nav-text">将带类型推导的lambda传给std::function</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用术语"><span class="nav-number">5.</span> <span class="nav-text">常用术语</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

<div class="busuanzi-count">

  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv"><i class="fa fa-user"></i><span class="busuanzi-value" id="busuanzi_value_site_uv"></span></span>
  

  
    <span class="site-pv"><i class="fa fa-eye"></i><span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span>
  
  
</div>



        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"calvinneoorg"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = false;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = decodeURIComponent(data.url);
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title >= 0 || index_content >= 0 ){
                                isMatch = true;
								if (i == 0) {
                                    first_occur = index_content;
                                }
                            } 
							
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

  


</body>
</html>
