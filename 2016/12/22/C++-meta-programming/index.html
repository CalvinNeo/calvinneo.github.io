<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="元编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的。 C++11标准以来，C++在泛型编程方面引入了许多新的特性。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++元编程">
<meta property="og:url" content="http://www.calvinneo.com/2016/12/22/C++-meta-programming/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="元编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的。 C++11标准以来，C++在泛型编程方面引入了许多新的特性。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2024-11-20T16:41:17.512Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++元编程">
<meta name="twitter:description" content="元编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的。 C++11标准以来，C++在泛型编程方面引入了许多新的特性。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2016/12/22/C++-meta-programming/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>C++元编程 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2016/12/22/C++-meta-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++元编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-22T00:29:16+08:00">
                2016-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>元编程是C++的一个重点和难点，标准库中有非常多的内容都是通过模板实现的。</p>
<p>C++11标准以来，C++在泛型编程方面引入了许多新的特性。</p>
<a id="more"></a>

<h1 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h1><p>traits 是C++ STL中的重要组成成分。type traits 的实现原理是 SFINAE，这里主要是介绍使用。</p>
<h2 id="数值部分"><a href="#数值部分" class="headerlink" title="数值部分"></a>数值部分</h2><ol>
<li>判断是否是整数：<code>std::is_integral&lt;T&gt;::value</code></li>
<li>判断是否有符号：<code>std::numeric_limits&lt;T&gt;::is_signed</code></li>
</ol>
<h2 id="迭代器部分"><a href="#迭代器部分" class="headerlink" title="迭代器部分"></a>迭代器部分</h2><p>判断迭代器种类以及内容：<code>std::iterator_traits</code>。这个trait实现很有意思，为了兼容指针和常指针这两个最原始的“迭代器”，这里使用了SFINAE</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> _<span class="title">Iterator_traits_base</span>&lt;_Iter, void_t&lt; // 这里的void_t使得不具有下面五个成员的两种指针失配</span></span><br><span class="line"><span class="class">        typename _Iter::iterator_category,</span></span><br><span class="line"><span class="class">        typename _Iter::value_type,</span></span><br><span class="line"><span class="class">        typename _Iter::difference_type,</span></span><br><span class="line"><span class="class">        typename _Iter::pointer,</span></span><br><span class="line"><span class="class">        typename _Iter::reference</span></span><br><span class="line"><span class="class">        &gt; &gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// defined if _Iter::* types exist</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::iterator_category iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::value_type value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Iter::reference reference;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span></span></span><br><span class="line"><span class="class">        :</span> _Iterator_traits_base&lt;_Iter&gt;</span><br><span class="line">    &#123;   <span class="comment">// get traits from iterator _Iter, if possible</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Ty *&gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// get traits from pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Ty *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty&amp; reference;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 const _Ty *要单独拿出来偏特化，如果用上面的偏特化的话，我们得到的是const _Ty而不是_Ty</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator_traits</span>&lt;const _Ty *&gt;</span></span><br><span class="line"><span class="class">    &#123;</span>   <span class="comment">// get traits from const pointer</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Ty *pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Ty&amp; reference;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="对象行为部分"><a href="#对象行为部分" class="headerlink" title="对象行为部分"></a>对象行为部分</h2><p>C++ 新标准中使用了 <code>is_...able&lt;&gt;</code> 函数代替了之前的 <code>has_... </code>函数</p>
<h1 id="reference-wrapper"><a href="#reference-wrapper" class="headerlink" title="reference_wrapper"></a>reference_wrapper</h1><p>显然 <code>std::vector</code> 是不能存放<code>T &amp;</code>的，如果不希望放指针进去，可以使用<code>std::reference_wrapper</code>，不过这东西用起来也并不舒服，例如C++不能重载<code>operator.</code>，虽然最近有一些草案正在提到这一点，所以必须得<code>get()</code>一下。<br><code>std::reference_wrapper</code>常用于<code>std::bind</code>、<code>std::thread</code>等函数/类上。它们为了保证传入的参数在自己的生命周期中是持续存在的，决定始终通过传值的方式接受参数，即始终拷贝一份，因此此时如果要传递引用，就得使用<code>std::ref</code>包装一下了。</p>
<h1 id="operator重载"><a href="#operator重载" class="headerlink" title="operator重载"></a>operator重载</h1><p><code>operator=</code>、<code>operator()</code>、<code>operator[]</code>、<code>operator-&gt;</code>、<code>operator T</code>不能作为non-member function，这是因为担心与自动合成的<code>operator=</code>出现行为不一致的问题。其实还可以更深入地考虑这个问题，例如对于比较大小的运算符<code>operator&lt;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> B &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> A &amp; b)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这显然是不符合逻辑的</p>
<h1 id="特化一些其他结构"><a href="#特化一些其他结构" class="headerlink" title="特化一些其他结构"></a>特化一些其他结构</h1><h2 id="特化using"><a href="#特化using" class="headerlink" title="特化using"></a>特化using</h2><p>与函数相同，C++中的<code>using</code>也不能直接特化，如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> wrap&lt;T&gt; = T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">using</span> wrap&lt;<span class="keyword">int</span>&gt; = <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>

<p>必须需要借助类来workaround</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">wrap</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> type = T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数模板的特化与函数的重载"><a href="#函数模板的特化与函数的重载" class="headerlink" title="函数模板的特化与函数的重载"></a>函数模板的特化与函数的重载</h2><p>为了实现函数的“多态”，常有借助模板类偏特化和重载两种方式。</p>
<h3 id="借助重载实现函数的“偏特化”"><a href="#借助重载实现函数的“偏特化”" class="headerlink" title="借助重载实现函数的“偏特化”"></a>借助重载实现函数的“偏特化”</h3><p>虽然函数模板不能偏特化，但函数本身就有重载，因此我们可以在每个不同的函数末尾加上一个tag来达到根据某些traits进行“分类讨论“的效果。例如最常用的<code>std::true_type</code>和<code>std::false_type</code>。在STL的实现中使用了很多这样的<code>_tag</code>来控制行为，例如控制<code>std::advance()</code>函数在接受五种不同迭代器时的更新行为，或者原子库中使用tag标记六种内存模型。即使当我们要“偏特化”的是非类型模板参数时，也可以直接利用重载而不是“偏特化”，这时候我们可以在类里面用<code>enum</code>或者<code>static constexpr int</code>将这个值封装起来，也可以直接借助于标准库的<code>std::condition</code>等函数。在下面的例子中，我们需求模板函数的行为根据<code>std::is_same&lt;T, C&gt;::value</code>进行分类讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; when_eq(T x, U y); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>在没有<code>constexpr if</code>的情况下，用函数重载来做是一种直截了当的方案。但是重载是对类型而言的，而<code>if</code>只能判断<code>true</code>/<code>false</code>值，非类型模板参数又不能使用整型以外的类型。所以必须要有个机制来将整型值包装成类型，这里可以借助标准库提供的<code>std::integral_constant&lt;typename T, T val&gt;</code>，或者也可以自己实现一个<code>Int2Type</code>或者<code>Int2Type2</code>。这个思路可以解决很多问题，例如<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="noopener">对成员函数的偏特化</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int2Type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; value = I &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> I&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Int2Type2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="comment">/* or constexpr */</span> <span class="keyword">int</span> value = I;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y, Int2Type&lt;<span class="number">1</span>&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"eq"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y, Int2Type&lt;<span class="number">0</span>&gt;)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"neq"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">when_eq</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    when_eq(x, y, Int2Type&lt;<span class="built_in">std</span>::is_same&lt;T, U&gt;::value&gt;()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    when_eq(X(), Y()); <span class="comment">// neq</span></span><br><span class="line">    when_eq(X(), X()); <span class="comment">// eq</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里特别提一下<code>enum</code>的性质，根据标准在使用<code>enum E {V1, V2}</code>的值<code>V1</code>、<code>V2</code>时是不需要加上<code>E::</code>限定符的。此外其具体类型可以使用<code>std::underlying_type</code>获得。</p>
<h3 id="借助类模板实现偏特化"><a href="#借助类模板实现偏特化" class="headerlink" title="借助类模板实现偏特化"></a>借助类模板实现偏特化</h3><p>还可以使用类模板“偏特化”函数，如果需要上下文，那么可以重载<code>operator()</code>的方式实现一个仿函数，如果不需要上下文，可以在里面定义一个static函数。<br>如果一定需要偏特化，考虑在一个偏特化类中实现static函数。这又带来一个新的问题，考虑要偏特化一个类中<strong>成员函数</strong>，如果偏特化类，那其他的成员函数也要重复实现一遍，显得很麻烦，对于这个问题，可以参考<a href="http://www.cnblogs.com/weiym/archive/2013/02/14/2912563.html" target="_blank" rel="noopener">这里的说明</a></p>
<h1 id="普通函数、函数模板和全特化模板函数之间的决议"><a href="#普通函数、函数模板和全特化模板函数之间的决议" class="headerlink" title="普通函数、函数模板和全特化模板函数之间的决议"></a>普通函数、函数模板和全特化模板函数之间的决议</h1><p>在这一章节中，我们将讨论重载的普通函数、函数模板和其特化函数之间的决议顺序。<br>模板函数一旦全特化，它就和普通函数一样成为一个strong symbol，我们应当使用<code>inline</code>，<code>static</code>，<code>extern</code>关键字防止重复定义。<br>但是对于全特化的函数模板，它和不加<code>template&lt;&gt;</code>的普通函数还是有着很大区别的？根据C++ Premier中的说明</p>
<blockquote>
<p>当调用从模板实例化的函数时，只有有限的类型转换可以被应用在模板实参推演过程使用的函数实参上；如果声明一个普通函数则可以考虑用所有的类型转换来转换实参，这是因为普通函数参数的类型是固定的</p>
</blockquote>
<p>上面的话是说明<code>template&lt;&gt;</code>特化函数模板比普通函数的匹配要求更高，这是因为普通函数还能接受传入参数的隐式转换。在C++ Primer的16.5节中指出，在多个函数之间进行决议时总是选择最为精确的函数，<strong>当普通函数和模板函数同样适配时，优先选择普通函数</strong>。</p>
<ol>
<li><p>在这个例子中，<code>a</code>是<code>int</code>，显然主模板0能够精确匹配，于是决议到0，输出<code>&quot;template&quot;</code>。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// template</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>这个例子就是一个经典的SFINAE用法了，我们知道一个数组的大小只能是整数而不能是浮点数，所以当<code>T</code>是<code>double</code>时，<code>char(*)[T()]</code>就是ill-formed。根据SFINAE，我们不把它作为错误，而是转而寻求次优解。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">char</span>(*)[T()]&gt;</span><br><span class="line"><span class="keyword">void</span> promotion(T x) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>但必须要考虑一个特例，也就是当有多于一个函数能精确匹配的情况，这时候优先级的顺序是普通函数、全特化、主模板。<a href="/asset/mbbc/a.cpp">首先给出一个综合的实例</a>，并讨论下面的几点比较简单的方面。</p>
<ol>
<li><p>普通函数先于全特化</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #2</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    promotion(<span class="number">1.0</span>); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>全特化版本先于主模板</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template&lt;&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    promotion(<span class="number">1.0</span>); <span class="comment">// template&lt;&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>decay<br> 想一想，如果主模板要发生 decay，更不可能会被选中。因为普通函数优先于全特化，进而优先于主模板。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #0</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"template"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// #1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">promotion</span><span class="params">(<span class="keyword">int</span> &amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"function"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    promotion(a); <span class="comment">// function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>一些类型转换的 case，可以参考<a href="/asset/mbbc/a.cpp">综合实例</a></p>
</li>
<li><p>一些和 SFINAE 相关的 case，同样可以参考<a href="/asset/mbbc/a.cpp">综合实例</a></p>
</li>
</ol>
<p>上述的重载决议，可以被用在<a href="https://b.atch.se/posts/constexpr-counter/" target="_blank" rel="noopener">stateful constexpr 实现 counter</a>上。</p>
<h2 id="考虑可访问性"><a href="#考虑可访问性" class="headerlink" title="考虑可访问性"></a>考虑可访问性</h2><p>C++中的可访问性包括private、protected和public三类，可访问性是针对<strong>类</strong>而不是对象而言的。<br><a href="http://blog.csdn.net/starlee/article/details/1406781" target="_blank" rel="noopener">C++中重载决议是在可访问性检查之前进行的</a></p>
<h2 id="考虑隐式类型转换"><a href="#考虑隐式类型转换" class="headerlink" title="考虑隐式类型转换"></a>考虑隐式类型转换</h2><p>在日常编程中，我们常常把字符串直接量当做<code>std::string</code>使用，但其实字符串直接量的类型是<code>const char[]</code>，这其中涉及到隐式构造函数或者隐式类型转换。这导致在进行重载决议时出现“不合常理”的情况。</p>
<p>有关更多隐式类型转换的内容，可以参考<a href="/2022/10/25/C++-type-cast/"></a>。</p>
<h3 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h3><p>在<a href="https://www.zhihu.com/question/27932618" target="_blank" rel="noopener">知乎的这篇问题</a>中，我们看到<code>Test</code>中定义了两个成员函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;first_name, <span class="keyword">const</span> <span class="built_in">string</span> &amp;last_name)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Test::find(<span class="keyword">const</span> <span class="built_in">string</span> &amp;name, <span class="keyword">bool</span> retied)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"find 2"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在考虑下面的调用，我们发现是调用的find 2版本的函数。这是由于<code>const char[]</code>被decay成了<code>const char *</code>，然后隐式转换成了<code>bool</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test().find(<span class="string">"a"</span>, <span class="string">"b"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="考虑传参时decay的特殊情况"><a href="#考虑传参时decay的特殊情况" class="headerlink" title="考虑传参时decay的特殊情况"></a>考虑传参时decay的特殊情况</h3><p>紧接着上面的讨论，我们查看下面的一段代码，这时候输出就变成true了，究其原因是因为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::is_same&lt;T, U&gt;::value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> &amp; b = a;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; check(<span class="keyword">int</span>(), a) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是类型转换问题，在<a href="http://www.cnblogs.com/liyuan989/p/4138378.html" target="_blank" rel="noopener">文章</a>中提到了一个特别的情况</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"template"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"normal"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在调用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(<span class="string">"123456"</span>, <span class="string">"123456"</span>);</span><br></pre></td></tr></table></figure>

<p>请问是调用了那个函数呢？有意思的是对于不同编译器结果还不一样。作者指出G++/clang调用了模板版本，而我使用VS2015发现调用的是普通版本。<br>调用模板版本的原因是<code>T = const char [6]</code>相比decay后的<code>const char *</code>更精确；但是调用普通版本的原因是数组传参时要 decay 成对应的指针。因此对于模板函数和普通函数实际上都不是精确匹配的，也就是都要经过一次类型转换。根据C++重载决议原则，如果调用具有二义性，则优先选择调用普通函数。<br>在本篇结尾，作者引用陈硕的观点，认为G++/clang的实现是符合标准的，但是这属于标准的bug。其原因是**模板实参推断<a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0%E6%8E%A8%E5%AF%BC" target="_blank" rel="noopener">(template argument deduction)</a>**时，除了产生新的实例化之外，编译器只会执行两种转换：</p>
<ol>
<li>const 转换：接受 const 引用或指针的函数可以分别用非 const 对象的引用或指针来调用，无须产生新的实例化。也就是可以传一个非 const 到需要 const 参数的函数。</li>
<li>数组或函数到指针的转换：<strong>如果模板形参不是引用类型</strong>，则对数组或函数类型的实参应用常规指针转换。数组实参将当作指向其第一个元素的指针(如前文所说)，函数实参当作指向函数类型的指针。</li>
</ol>
<p>由于模板参数使用了数组的 const 引用类型，所以按照标准应该不将数组向指针进行 decay。</p>
<h2 id="考虑继承"><a href="#考虑继承" class="headerlink" title="考虑继承"></a>考虑继承</h2><h1 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h1><p>在C++中常常出现一些ill-formed的代码，这些代码在函数体或者其他地方出现编译器都是要报错的，SFINAE(Substitution Failure Is Not An Error)规定，当<strong>推导模板参数</strong>失败(fail)时，编译器不产生错误，而是放弃使用这个重载集推导参数。需要注意这样的替换发生在下面四种情况下：</p>
<ol>
<li>(Type SFINAE)所有用于函数的类型，包括函数的返回值与参数的类型。</li>
<li>(Type SFINAE)所有用于模板参数的类型。</li>
<li>(Expression SFINAE)所有用于函数类型中的表达式。</li>
<li>(Expression SFINAE)所有用于模板形参声明中的表达式。</li>
</ol>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>函数模板参数会被替换两次：</p>
<ol>
<li>显式特化的模板参数在 template argument deduction 前被替换。</li>
<li>推导出的参数，和默认的参数在 template argument deduction 后被替换。</li>
</ol>
<p>替换发生在：</p>
<ol>
<li>在函数类型中使用的任意类型，包括返回类型和参数类型</li>
<li>在 template parameter declaration 中使用的所有类型</li>
<li>【C++11】在 function type 中用到的所有表达式</li>
<li>【C++11】在 template parameter declaration 中用到的所有表达式</li>
<li>【C++20】all expressions used in the explicit specifier</li>
</ol>
<p>A substitution failure is any situation when the type or expression above would be ill-formed (with a required diagnostic), if written using the substituted arguments.</p>
<p>只有在 function type 和它的 template parameter type 和 explicit specifier 的 immediate context 中的 type 和 expression 中的 failures 才被看做 SFINAE 错误。If the evaluation of a substituted type/expression causes a side-effect such as instantiation of some template specialization, generation of an implicitly-defined member function, etc, errors in those side-effects are treated as hard errors.</p>
<h2 id="Type-SFINAE"><a href="#Type-SFINAE" class="headerlink" title="Type SFINAE"></a>Type SFINAE</h2><p>这些常被使用的 ill-formed 代码包括下面的形式：</p>
<ol>
<li><p>试图实例化一个包展开，但这个包展开中含有多个不同长度的包</p>
</li>
<li><p>试图创建 void 的数组、引用的数组、函数的数组、抽象类类型的数组、负大小的数组或零大小的数组<br> 例如之前提到过的<code>char(*)[0.5]</code>，还有<code>char [0]</code>、<code>void [3]</code>这些都不是一个合法的。</p>
</li>
<li><p>试图在<code>::</code>左侧使用非类或非枚举的类型<br> 如下所示，0 这个 int 并不具有 B 这个字段，所以会匹配到第二个。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">f</span>(<span class="title">typename</span> <span class="title">T</span>:</span>:B*);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">f</span>(<span class="title">T</span>);</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> i = f&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>); <span class="comment">// uses second overload</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>试图使用类型的不存在的成员</strong><br> 比如<code>vector&lt;int&gt;::abcdefg</code>是错的，因为它肯定没有这个字段，但不止于此。主要分为下面几种类型：</p>
<ul>
<li>该类型中没有这样的成员。</li>
<li>该类型中有这样的成员，但是类型不匹配。</li>
<li>该类型中有这样的成员，但是它不是个模板，而我们要求它是个模板。</li>
<li>该类型中有这样的成员，但是它是个 non-type，而我们要求它是个 nin-type。</li>
</ul>
</li>
<li><p>试图在错误的地方是用类型的成员<br> 类型、模板、非类型如 literal 等。</p>
</li>
<li><p>试图创建指向引用的指针</p>
</li>
<li><p>试图创建到 void 的引用</p>
</li>
<li><p>试图创建指向 T 成员的指针，其中 T 不是类类型<br> 这个常常可被用来判断<code>T</code>是否是类类型，代码如下所示。<br> 这里<code>C::*</code>表示一个指向类<code>C</code>中某<code>int</code>类型成员的指针，说明了这个指针带有<code>C</code>的上下文，而<code>...</code>相当于一个兜底的东西。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> C::*)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// C是类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> x;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test&lt;X&gt;(<span class="number">0</span>)&lt;&lt; <span class="built_in">endl</span>; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>试图将非法类型给予非类型模板参数</strong></p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">S</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">f</span>(<span class="title">S</span>&lt;T, T()&gt;*);</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i0 = f&lt;X&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p> 这个SFINAE将在后面<code>std::void_t</code>中被使用。</p>
</li>
<li><p>试图进行非法转换</p>
</li>
<li><p>试图创建拥有类型<code>void</code>的形参的函数</p>
</li>
<li><p>试图创建返回数组类型或函数类型的函数</p>
</li>
<li><p>试图创建参数类型或返回类型为抽象类的函数类型</p>
</li>
</ol>
<p>自然而然地想到如果需要判定某个实体是否具有某种性质，我们就可以构造一种没有这种特性就会造成ill-formed的<strong>表达式</strong>或者<strong>类型</strong>，分别对应Expression SFINAE和Type SFINAE。这样我们就可以把traits的问题转化为<strong>函数重载</strong>或者<strong>模板类的偏特化</strong>的决议问题来讨论。</p>
<p>在函数重载使用SFINAE时，常常在定义函数时在函数最后放一个可能会ill-formed类型的指针，在调用时传一个nullptr过去。相对于遥不可及的concepts，SFINAE机制看起来更为神奇，它在不引入一个新的语法机制的情况下来实现了traits的功能，但伴随而来的是我们把Failure和Error都放在了模板实例化或者重载决议时处理，这样当Error发生时我们就不能得到清晰的错误报告。</p>
<h2 id="Expression-SFINAE"><a href="#Expression-SFINAE" class="headerlink" title="Expression SFINAE"></a>Expression SFINAE</h2><p>只介绍从 C++ 11 开始的内容。<br>下列的 Error 是 SFINAE error：</p>
<ol>
<li>Ill-formed expression used in a template parameter type</li>
<li>Ill-formed expression used in the function type</li>
</ol>
<p>如下所示，有两个 <code>f</code>，#1 要求返回类型是 <code>decltype(t1 + t2)</code>，#2 要求返回类型是 <code>X</code>。对于 X 类型的 x1 和 x2 而言，x1 + x2 是 ill-formed，所以 SFINAE 会选择到 #<br>2。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span> &#123;</span> Y(X)&#123;&#125; &#125;; <span class="comment">// X is convertible to Y</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">auto</span> <span class="title">f</span>(<span class="title">T</span> <span class="title">t1</span>, <span class="title">T</span> <span class="title">t2</span>) -&gt; <span class="title">decltype</span>(<span class="title">t1</span> + <span class="title">t2</span>);</span> <span class="comment">// overload #1</span></span><br><span class="line"> </span><br><span class="line"><span class="function">X <span class="title">f</span><span class="params">(Y, Y)</span></span>;                               <span class="comment">// overload #2</span></span><br><span class="line"> </span><br><span class="line">X x1, x2;</span><br><span class="line">X x3 = f(x1, x2); <span class="comment">// deduction fails on #1 (expression x1 + x2 is ill-formed)</span></span><br><span class="line">                  <span class="comment">// only #2 is in the overload set, and is called</span></span><br></pre></td></tr></table></figure>

<h2 id="偏特化中的-SFINAE"><a href="#偏特化中的-SFINAE" class="headerlink" title="偏特化中的 SFINAE"></a>偏特化中的 SFINAE</h2><p>Deduction and substitution also occur while determining whether a specialization of a class or variable【C++14】 template is generated by some partial specialization or the primary template.<br>编译器在做出决议时，不会将这个的替换失败看做是硬错误，而是只会忽略这个对应的偏特化错误，就好像在涉及函数模板的重载中一样。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primary template handles non-referenceable types:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">reference_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> add_lref = T;</span><br><span class="line">    <span class="keyword">using</span> add_rref = T;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// specialization recognizes referenceable types:</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">reference_traits</span>&lt;T, std::void_t&lt;T&amp;&gt;&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> add_lref = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> add_rref = T&amp;&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">add_lvalue_reference_t</span> = <span class="title">typename</span> <span class="title">reference_traits</span>&lt;T&gt;:</span>:add_lref;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">add_rvalue_reference_t</span> = <span class="title">typename</span> <span class="title">reference_traits</span>&lt;T&gt;:</span>:add_rref;</span><br></pre></td></tr></table></figure>

<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><h3 id="enable-if"><a href="#enable-if" class="headerlink" title="enable_if"></a>enable_if</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span>;</span></span><br></pre></td></tr></table></figure>

<p>如果 B 是 true，那么 enable_if 具有一个 T 类型的成员 type，否则没有任何类型。</p>
<p>这个函数可以在 concept 之前简化 SFINAE 的使用。特别是用来给定一定的条件，然后通过 type traits 将某些函数从 candidate set 中删除。allowing separate function overloads or specializations based on those different type traits。</p>
<p>std::enable_if can be used in many forms, including:</p>
<ol>
<li>as an additional function argument (not applicable to operator overloads)</li>
<li>as a return type (not applicable to constructors and destructors)</li>
<li>as a class template or function template parameter</li>
</ol>
<p>它的实现也很简单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> B, <span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">void</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span> &#123;</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">enable_if</span>&lt;true, T&gt; &#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="void-t"><a href="#void-t" class="headerlink" title="void_t"></a>void_t</h3><p>这个的作用是将一系列的类型都映射为 void</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... &gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">void_t</span> = <span class="title">void</span>;</span></span><br></pre></td></tr></table></figure>

<p>This metafunction is a convenient way to leverage SFINAE prior to C++20’s concepts, in particular for conditionally removing functions from the candidate set based on whether an expression is valid in the unevaluated context (such as operand to decltype expression), allowing to exist separate function overloads or specializations based on supported operations.</p>
<h3 id="使用SFINAE判断是否存在成员"><a href="#使用SFINAE判断是否存在成员" class="headerlink" title="使用SFINAE判断是否存在成员"></a>使用SFINAE判断是否存在成员</h3><p>利用SFINAE的方式分为两种，通常见到的是Type SFINAE。关于Expression SFINAE，可以参考<a href="http://stackoverflow.com/questions/12654067/what-is-expression-sfinae" target="_blank" rel="noopener">这个回答</a>。</p>
<p>模板偏特化是相对原型/初等/主(primary template)模板来说的，编译器首先匹配出原型，再根据原型找出合适的特化模板。例如对模板类型参数<code>T</code>而言，<code>T*</code>、<code>T&amp;</code>、<code>const T &amp;</code>等是它的一个偏特化。通过偏特化我们可以进行分类讨论。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_container</span><span class="params">(Cont &amp; cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"not a container"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_container</span><span class="params">(Container&lt;Cont&gt; &amp; cont)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"container"</span>);</span><br><span class="line">    handle_container(cont[<span class="number">0</span>]); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>偏特化可以用来检查一个类中是否具有某个成员，但当我们尝试匹配成员函数，写出如下代码时，则会发现匹配失败</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.zhihu.com/question/34264462</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line">struct has_push_back : <span class="built_in">std</span>::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_push_back</span>&lt;Cont, std::void_t&lt;decltype(&amp;Cont::push_back)&gt;&gt; :</span> <span class="built_in">std</span>::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>后来查看<a href="http://stackoverflow.com/questions/31907885/void-t-fails-on-visual-studio-2015" target="_blank" rel="noopener">SoF</a>，当时以为是MSVC2015对<code>std::void_t</code>的支持有问题。<br>后来在SoF的<a href="http://stackoverflow.com/questions/27687389/how-does-void-t-work" target="_blank" rel="noopener">另一篇博文上</a>发现如果我们的<code>push_back</code>不是成员函数而是数据成员就可以通过。去SoF上问了一波，这是因为<code>std::vector&lt;int&gt;::push_back</code>有多个重载版本，于是应该还要匹配函数签名。因此可以显式构造<code>vector.push_back(vector::value_type())</code>这个表达式，看它是不是合法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.zhihu.com/question/34264462/answer/58260115</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_push_back : <span class="built_in">std</span>::false_type&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="keyword">using</span> ValueType = <span class="keyword">typename</span> Cont::value_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_push_back</span>&lt;Cont, std::void_t&lt;std::declval&lt;Cont&gt;().push_back(declval&lt;ValueType&lt;Cont&gt;&gt;())&gt;&gt; :</span> <span class="built_in">std</span>::true_type&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>注意到这里都是用类的偏特化来实现的，我也尝试了下使用函数搞一搞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt; </span><br><span class="line"><span class="keyword">bool</span> has_push_back() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cont, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">void_t</span>&lt;<span class="keyword">decltype</span>(&amp;Cont::push_back)&gt;&gt; </span><br><span class="line"><span class="keyword">bool</span> has_push_back() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样会出现函数模板已经定义的错误。在<a href="http://en.cppreference.com/w/cpp/types/enable_if" target="_blank" rel="noopener">cppreference</a>中给出了说明</p>
<blockquote>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This is illegal because default template arguments are not part of function template’s signature, and declaring two different function templates with the same signature is illegal.</p>
</blockquote>
<p>此外在<a href="http://stackoverflow.com/questions/30953248/why-doesnt-sfinae-enable-if-work-for-member-functions-of-a-class-template" target="_blank" rel="noopener">SoF</a> 上给出了如下说明</p>
<blockquote>
<p>SFINAE only works for deduced template arguments</p>
</blockquote>
<h3 id="判断模板参数是否是广义函数"><a href="#判断模板参数是否是广义函数" class="headerlink" title="判断模板参数是否是广义函数"></a>判断模板参数是否是广义函数</h3><p>目前广义函数包括函数、<code>std::function</code>、lambda、仿函数，其中<code>std::is_function</code>只能识别函数。C++17标准添加了<code>std::is_invokable</code>(即之前的<code>std::is_callable</code>)，用来表示可以INVOKE的类型。关于这一部分，可以参考我的博文<a href="/2017/11/17/C++-functor/">C++仿函数的作用实现</a>。</p>
<h3 id="推导lambda的类型"><a href="#推导lambda的类型" class="headerlink" title="推导lambda的类型"></a>推导lambda的类型</h3><p>根据<a href="http://stackoverflow.com/questions/9998402/c11-does-not-deduce-type-when-stdfunction-or-lambda-functions-are-involved" target="_blank" rel="noopener">StackOverflow上的这个答案</a>，lambda是函数对象而不是函数，但是可以被转换(convert to)成<code>std::function</code>，这是因为<code>std::function</code>可以从所有能被调用的类型构造，也就是说这可以这么写</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; lambda = [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>但是类型推导是另一回事，因为lambda并不是<code>std::function</code>，我们只能用<code>auto</code>来声明一个lambda表达式，所以编译器不能通过一个lambda去推导<code>std::function</code>的参数。BTW，Effective Modern C++指出使用<code>auto</code>关键字相对于使用显式声明是比较好的。具体得来说他可以避免default initialization的变量、难以表示的类型、避免可能造成的类型截断问题。<br>但是，函数指针可以看做函数的入口点，它是全局的，而一个函数对象如<code>std::function</code>可以携带context，所以是不能转换为一个函数指针的。那我们有办法将<code>std::function</code>也“转换”为函数指针么？这需要一些技巧，如<a href="https://stackoverflow.com/questions/33024728/function-object-conversion-to-function-pointer" target="_blank" rel="noopener">这个方法</a>中定义了<code>to_function_pointer</code>，它会返回一个 lambda 表达式，在这个 lambda 表达式中，会调用 <code>std::function</code>。另一种方案是<a href="http://www.cplusplus.com/forum/general/63552/" target="_blank" rel="noopener">不借助lambda表达式</a>。<br>特别地，标准指出一个<strong>不捕获</strong>lambda表达式可以被转成一个函数指针。<br>在这里还需要将函数签名与函数指针区分开来，一般在使用函数签名的场合常需要考虑C linkage。</p>
<h3 id="推导-F-的返回值类型"><a href="#推导-F-的返回值类型" class="headerlink" title="推导 F 的返回值类型"></a>推导 F 的返回值类型</h3><p>比较省事的解决方式是直接使用<code>template&lt;typename F&gt;</code>，现在的问题是如何得到F的返回值类型。<br>这时候可以<a href="https://stackoverflow.com/questions/28618788/why-does-stdresult-of-not-work-with-lambdas" target="_blank" rel="noopener">借助<code>std::result_of</code>来推导<code>typename F</code>的返回类型</a>，注意这里要写成<code>decltype(lambda_func)()</code>，而不是<code>decltype(lambda_func)</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda_func = []()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">lambda_func_t</span> = <span class="built_in">std</span>::result_of&lt;<span class="keyword">decltype</span>(lambda_func)()&gt;::type;</span><br></pre></td></tr></table></figure>

<p>此外，经测试可以推导函数对象的返回类型，不能推导C原生函数的返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">native_func</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">object_func</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line">auto call_func(F f)-&gt; std::result_of_t&lt;F(int)&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;object_func(<span class="keyword">int</span>)&gt;::type x; <span class="comment">// Yes</span></span><br><span class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;native_func(<span class="keyword">int</span>)&gt;::type y; <span class="comment">// No</span></span><br><span class="line">    object_func of; </span><br><span class="line">    call_func(of); <span class="comment">// Yes</span></span><br><span class="line">    call_func(native_func); <span class="comment">// Yes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考了<a href="http://stackoverflow.com/questions/11470802/stdresult-of-simple-function" target="_blank" rel="noopener">StackOverflow上的答案</a>，<strong>这是因为原生函数并不是一个 type</strong>，但是<code>std::result_of&lt;F(Args...)&gt;</code>中的 F 必须要是一个类型，合适的方法是使用<code>decltype</code>+<code>declval</code>，比如如下所示，而不是用<code>std::result_of</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(native_func(<span class="built_in">std</span>::declval&lt;<span class="keyword">int</span>&gt;()))</span><br></pre></td></tr></table></figure>

<p>此外，在 C++17 标准之后，可以使用<code>std::invoke_result</code>来替代<code>std::result_of</code>。<br>此外，在<a href="http://stackoverflow.com/questions/7943525/is-it-possible-to-figure-out-the-parameter-type-and-return-type-of-a-lambda" target="_blank" rel="noopener">这个回答</a>中实现一个<code>function_traits</code>。这个类型类似 pattern matching，能够同时处理函数对象和函数指针的情况，并且能够推导出参数和返回值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span> :</span> <span class="keyword">public</span> function_traits&lt;<span class="keyword">decltype</span>(&amp;T::<span class="keyword">operator</span>())&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ClassType, <span class="keyword">typename</span> ReturnType, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">function_traits</span>&lt;ReturnType(ClassType::*)(Args...) const&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123; arity = <span class="keyword">sizeof</span>...(Args) &#125;;</span><br><span class="line">    <span class="keyword">typedef</span> ReturnType result_type;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">size_t</span> i&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">arg</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">std</span>::tuple_element&lt;i, <span class="built_in">std</span>::tuple&lt;Args...&gt;&gt;::type type;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="在类模板中声明友元函数模板"><a href="#在类模板中声明友元函数模板" class="headerlink" title="在类模板中声明友元函数模板"></a>在类模板中声明友元函数模板</h1><p>在一个模板类<code>farray</code>中声明一个友元函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">farray</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;T&gt; &amp; x, <span class="keyword">const</span> T &amp; y)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error LNK2019: 无法解析的外部符号 &quot;struct for90std::farray&lt;bool&gt; __cdecl for90std::operator&lt;(struct for90std::farray&lt;int&gt; const &amp;,int const &amp;)&quot; (??Mfor90std@@YA?AU?$farray@_N@0@AEBU?$farray@H@0@AEBH@Z)</span><br></pre></td></tr></table></figure>

<p>原因是<code>T</code>是类模板<code>farray</code>的模板参数，随着类模板特化。所以应该给友元函数<code>operator&lt;</code>独立的模板参数，改成这样就好了</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">friend</span> farray&lt;<span class="keyword">bool</span>&gt; <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> farray&lt;U&gt; &amp; x, <span class="keyword">const</span> U &amp; y);</span><br></pre></td></tr></table></figure>

<p>详细可以参考<a href="http://stackoverflow.com/questions/29055696/why-lnk1120-lnk2019-appears-in-case-of-template-and-friend-function" target="_blank" rel="noopener">这篇答案</a></p>
<h1 id="两阶段名字查找-Two-phase-name-look-up"><a href="#两阶段名字查找-Two-phase-name-look-up" class="headerlink" title="两阶段名字查找(Two-phase name look up)"></a>两阶段名字查找(Two-phase name look up)</h1><p><a href="http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html" target="_blank" rel="noopener">两阶段名字查找模型</a>是表示<a href="https://devblogs.microsoft.com/cppblog/two-phase-name-lookup-support-comes-to-msvc/" target="_blank" rel="noopener">一系列用来决议C++模板声明中使用到的名字的规则</a>，它最初的提出是用来在<a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/1992/N0209.pdf" target="_blank" rel="noopener">inclusion model（现在用的）和separation model</a>这两种模板实现方式之间进行妥协的。<br>两阶段名字查找模型规定了模板函数<strong>体</strong>中出现的所有名字的查找方式。我们首先定义non-dependent名字，一个non-dependent名字在查找时不依赖任何的模板参数，所以对于任意实例化后的模板它都是一样的。相反一个dependent名字依赖于模板参数，例如<code>A&lt;X&gt;::B b</code>中的<code>b</code>、<code>this</code>都是dependent的名字。此外对于像<code>A::B</code>这样的名字，编译器可能并不知道它是一个函数还是一个类型或者一个变量，所以当做类型使用时，我们需要显式指定一下<code>typename</code>来通告编译器。不过有的时候大家就滥用，有的没的都加上<code>typename</code>，会报错<code>expected a qualified name after &#39;typename&#39;</code>。这是因为只有在嵌套从属名称前面才要加上<code>typename</code>，其他的例如<code>typename C &amp; cont</code>的用法是错误的。</p>
<ol>
<li>对于non-dependent符号，该符号在模板定义阶段即被查找决议（all non-dependent names are resolved (looked up)），此外在第一阶段还会做一些语法检查。</li>
<li>对于dependent符号，查找被推迟到模板被实例化(point of instantiation, POI)时。</li>
</ol>
<p>在早期版本中，MSVC不支持two phase name lookup，由此带来的结果就是很多MSVC能编译的代码在GCC等编译器上并不能够编译。我们查看<a href="https://blogs.msdn.microsoft.com/c/2017/10/19/msvc%E5%B7%B2%E7%BB%8F%E6%94%AF%E6%8C%81two-phase-name-lookup/" target="_blank" rel="noopener">下面的代码</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">void</span>*)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"The call resolves to void*"</span>) ;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    func(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">puts</span>(<span class="string">"The call resolves to int"</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; g(<span class="number">3.14</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>根据两阶段查找，<code>func</code>是无依赖的，由此在模板定义时就会被决议。因此虽然<code>g</code>中调用的<code>func(0)</code>函数的最佳决议应该是<code>void func(int);</code>，但是由于此时<code>g</code>尚未看到<code>void func(int);</code>，所以只能决议到<code>void func(void *)</code>，这也就是gcc的标准实现。但MSVC的某些版本很懒，根本不在模板定义阶段做事，所以在模板实例化阶段我们已经能够看到最佳适配的<code>void func(int);</code>了。</p>
<h1 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h1><p>参数包：parameter pack<br>类型限定符（const, volatile）：qualification adjustment<br>返回类型后置：trailing return type<br>函数签名：signature<br>模板类型推导：template argument deduction<br>聚合体Aggregates和POD(Plain Old Data)=trival+standard layout：见此解释<a href="http://blog.csdn.net/lanchunhui/article/details/50532790" target="_blank" rel="noopener"></a><br>非类型模板参数：non type template parameter<br>包扩展：pack expansion<br>花括号初始化器：brace-init-list<br>省略号(…)：ellipsis<br>符号扩展、零扩展：sign/zero extension<br>可变参数模板：Variadic Templates pack<br>展开模式：pattern<br>决议：resolution</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/11/ICPC CHINA-FINAL小记/" rel="next" title="ICPC CHINA-FINAL小记">
                <i class="fa fa-chevron-left"></i> ICPC CHINA-FINAL小记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/30/C++初始化方式/" rel="prev" title="C++初始化方式">
                C++初始化方式 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">233</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">154</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#type-traits"><span class="nav-number">1.</span> <span class="nav-text">type traits</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数值部分"><span class="nav-number">1.1.</span> <span class="nav-text">数值部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器部分"><span class="nav-number">1.2.</span> <span class="nav-text">迭代器部分</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对象行为部分"><span class="nav-number">1.3.</span> <span class="nav-text">对象行为部分</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#reference-wrapper"><span class="nav-number">2.</span> <span class="nav-text">reference_wrapper</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#operator重载"><span class="nav-number">3.</span> <span class="nav-text">operator重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#特化一些其他结构"><span class="nav-number">4.</span> <span class="nav-text">特化一些其他结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#特化using"><span class="nav-number">4.1.</span> <span class="nav-text">特化using</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数模板的特化与函数的重载"><span class="nav-number">4.2.</span> <span class="nav-text">函数模板的特化与函数的重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#借助重载实现函数的“偏特化”"><span class="nav-number">4.2.1.</span> <span class="nav-text">借助重载实现函数的“偏特化”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#借助类模板实现偏特化"><span class="nav-number">4.2.2.</span> <span class="nav-text">借助类模板实现偏特化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#普通函数、函数模板和全特化模板函数之间的决议"><span class="nav-number">5.</span> <span class="nav-text">普通函数、函数模板和全特化模板函数之间的决议</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑可访问性"><span class="nav-number">5.1.</span> <span class="nav-text">考虑可访问性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑隐式类型转换"><span class="nav-number">5.2.</span> <span class="nav-text">考虑隐式类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通情况"><span class="nav-number">5.2.1.</span> <span class="nav-text">普通情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#考虑传参时decay的特殊情况"><span class="nav-number">5.2.2.</span> <span class="nav-text">考虑传参时decay的特殊情况</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#考虑继承"><span class="nav-number">5.3.</span> <span class="nav-text">考虑继承</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SFINAE"><span class="nav-number">6.</span> <span class="nav-text">SFINAE</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-number">6.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-SFINAE"><span class="nav-number">6.2.</span> <span class="nav-text">Type SFINAE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Expression-SFINAE"><span class="nav-number">6.3.</span> <span class="nav-text">Expression SFINAE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#偏特化中的-SFINAE"><span class="nav-number">6.4.</span> <span class="nav-text">偏特化中的 SFINAE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#样例"><span class="nav-number">6.5.</span> <span class="nav-text">样例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#enable-if"><span class="nav-number">6.5.1.</span> <span class="nav-text">enable_if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-t"><span class="nav-number">6.5.2.</span> <span class="nav-text">void_t</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用SFINAE判断是否存在成员"><span class="nav-number">6.5.3.</span> <span class="nav-text">使用SFINAE判断是否存在成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#判断模板参数是否是广义函数"><span class="nav-number">6.5.4.</span> <span class="nav-text">判断模板参数是否是广义函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推导lambda的类型"><span class="nav-number">6.5.5.</span> <span class="nav-text">推导lambda的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#推导-F-的返回值类型"><span class="nav-number">6.5.6.</span> <span class="nav-text">推导 F 的返回值类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在类模板中声明友元函数模板"><span class="nav-number">7.</span> <span class="nav-text">在类模板中声明友元函数模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#两阶段名字查找-Two-phase-name-look-up"><span class="nav-number">8.</span> <span class="nav-text">两阶段名字查找(Two-phase name look up)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#常用术语"><span class="nav-number">9.</span> <span class="nav-text">常用术语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2016/12/22/C++-meta-programming/';
          this.page.identifier = '2016/12/22/C++-meta-programming/';
          this.page.title = 'C++元编程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
