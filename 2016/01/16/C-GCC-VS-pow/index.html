<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,ACM,MSVC,GCC," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="ACM中常常遇到卡精度的问题，卡精度可能因为取整、比较相等、高精度等多种原因。这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。">
<meta name="keywords" content="C++,ACM,MSVC,GCC">
<meta property="og:type" content="article">
<meta property="og:title" content="GCC和MSVC在pow函数实现和类型转换比较">
<meta property="og:url" content="http://www.calvinneo.com/2016/01/16/C-GCC-VS-pow/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="ACM中常常遇到卡精度的问题，卡精度可能因为取整、比较相等、高精度等多种原因。这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_gcc1.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_vs1.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_gcc2.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_2gcc1.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_2vs1.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_main_enter.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_main.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_pow.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_pow_jumped.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_pow_jumped2.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_pow_jumped_getans.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_pow_jumped_getans_6ffae0.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_before_printf.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_cvttsd2si.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_after_cvttsd2si.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win10_vs_after_main_exit.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_pow.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_pow_jmp.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_pow_crt.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_pow_crt_return.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_2a3.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_after_pow.png">
<meta property="og:image" content="http://www.calvinneo.com/img/gccvspow/od_win7_main_ff1c.png">
<meta property="og:updated_time" content="2023-05-21T04:57:57.241Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCC和MSVC在pow函数实现和类型转换比较">
<meta name="twitter:description" content="ACM中常常遇到卡精度的问题，卡精度可能因为取整、比较相等、高精度等多种原因。这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。">
<meta name="twitter:image" content="http://www.calvinneo.com/img/gccvspow/gccvspow_gcc1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2016/01/16/C-GCC-VS-pow/"/>





  <title>GCC和MSVC在pow函数实现和类型转换比较 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2016/01/16/C-GCC-VS-pow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                GCC和MSVC在pow函数实现和类型转换比较
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-16T19:20:33+08:00">
                2016-01-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>ACM中常常遇到<strong>卡精度</strong>的问题，卡精度可能因为取整、比较相等、高精度等多种原因。<br>这里通过一个例子试图探讨两个编译器的浮点数运算实现机制以及类型转换的机制，以及使用不同编译器和使用不同指令集在取整上的卡精度的问题。</p>
<a id="more"></a>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>江科大的nomasp同学在刷Leetcode(171:Excel Colmun Number)的时候发现了一个问题。他的代码简化后如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, len = s.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = s[i] - <span class="string">'A'</span> + <span class="number">1</span>;</span><br><span class="line">        n += c * <span class="built_in">pow</span>(<span class="number">26</span>, len - <span class="number">1</span> - i);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"pow = "</span> &lt;&lt; <span class="built_in">pow</span>(<span class="number">26</span>, len - <span class="number">1</span> - i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"n = "</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;solve(<span class="string">"AAB"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Mingw32 GCC/G++(4.7.2)编译(g++.exe cpp_path -o exepath -std=c++11 -g3  -static-libstdc++ -static-libgcc -g3)后，输出如下：<br><img src="/img/gccvspow/gccvspow_gcc1.png"><br>使用MSVC140(VS2015)编译后，输出如下：<br><img src="/img/gccvspow/gccvspow_vs1.png"><br>稍有常识的人都会看出，GCC的结果是错误的。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><p>有同学认为pow函数是个浮点函数，因此应当转成int之后再相加减，但实际试验之后发现这个问题仍然存在，结果是：<br><img src="/img/gccvspow/gccvspow_gcc2.png"><br>经过分析，如果手动实现pow函数则GCC的结果是对的。因此定位到调用pow函数这边出了问题。因此取一下测试代码分析。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> f = <span class="built_in">pow</span>(<span class="number">26</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = f;</span><br><span class="line">	<span class="keyword">int</span> i2 = <span class="built_in">pow</span>(<span class="number">26</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f %d %d\n"</span>, f, i, i2); <span class="comment">//似乎这个版本的GCC不支持%lf</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GCC下编译运行得：<br><img src="/img/gccvspow/gccvspow_2gcc1.png"><br>在VS2015下编译运行得：<br><img src="/img/gccvspow/gccvspow_2vs1.png"><br>可以发现对GCC，当使用float变量直接初始化int时发生窄化，不过不影响结果。但是将这个float变量换成pow函数后就会影响结果。谦谦同学指出在GCC520版本下源代码也能正常运行。他进而提出pow函数返回的是double，在转成int的时候需要先转成float再转成int。根据这个意见，我测试了下面的代码，如果说会先转换成float，那么<code>yy</code>的值应当为55，因为从double到float的过程中精度丢失了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> x = <span class="number">54.999999999999993</span>;</span><br><span class="line">	<span class="keyword">int</span> y = (<span class="keyword">int</span>) x;</span><br><span class="line">	<span class="keyword">double</span> xx = <span class="number">54.999999999999993</span>;</span><br><span class="line">	<span class="keyword">int</span> yy = (<span class="keyword">int</span>) xx;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">double</span> xxx = <span class="number">54.999999999999993</span>;</span><br><span class="line">	<span class="keyword">int</span> yyy = (<span class="keyword">int</span>) xxx;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, y, yy, yyy); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过结果是<code>55 54 54</code>，看来从double到int并不会经过float。不过在他的提示下，我把pow函数改成powf函数，发现返回值正常了。既然如此，我又测试了下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> f = <span class="built_in">pow</span>(<span class="number">26</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = f;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f %d\n"</span>, f, i);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照上面的理论，这里应该输出675，但结果却是正确的676。因此现在的差别实际上就来自pow函数，我倾向于是一个RVO问题。<br>为了进一步研究原因，需要比较对pow函数的实现以及类型转换机制。</p>
<h2 id="MSVC对pow的实现"><a href="#MSVC对pow的实现" class="headerlink" title="MSVC对pow的实现"></a>MSVC对pow的实现</h2><p>MSVC中我们实际上使用的是<br><code>double pow&lt;int, int&gt;(int _Left, int _Right);</code> 这个重载版本。<br>首先定位到头文件<code>xtgmath.h</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xtgmath.h</span></span><br><span class="line">_C_STD_BEGIN</span><br><span class="line"><span class="comment">// #define _STD ::std::</span></span><br><span class="line"><span class="comment">// #define _CSTD ::</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>, <span class="title">class</span> _<span class="title">Ty2</span>&gt; <span class="title">inline</span></span></span><br><span class="line"><span class="class">	<span class="title">typename</span> _<span class="title">STD</span> <span class="title">enable_if</span>&lt; _STD is_arithmetic&lt;_Ty1&gt;::value &amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value		</span></span><br><span class="line"><span class="class">	,typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;:</span>:type</span><br><span class="line">	<span class="built_in">pow</span>(<span class="keyword">const</span> _Ty1 _Left, <span class="keyword">const</span> _Ty2 _Right)</span><br><span class="line">	&#123;	<span class="comment">// bring mixed types to a common type</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type;</span><br><span class="line">	<span class="keyword">return</span> (_CSTD <span class="built_in">pow</span>(type(_Left), type(_Right)));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到最后调用一个参数是<code>_Common_float_type</code>的pow函数，那这个函数在哪里呢，我们首先来看一下<code>_Common_float_type</code>这个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xtr1common.h	</span></span><br><span class="line"><span class="keyword">typedef</span> integral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt; false_type;</span><br><span class="line"><span class="comment">// integral_constant is convenient template for integral constant types</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//xtgmath.h	</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">struct</span> _<span class="title">Promote_to_float</span></span></span><br><span class="line"><span class="class">	&#123;</span>	<span class="comment">// promote integral to double</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> conditional&lt;is_integral&lt;_Ty&gt;::value,</span><br><span class="line">		<span class="keyword">double</span>, _Ty&gt;::type type;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty1</span>, <span class="title">class</span> _<span class="title">Ty2</span>&gt;</span></span><br><span class="line"><span class="class">	<span class="title">struct</span> _<span class="title">Common_float_type</span></span></span><br><span class="line"><span class="class">	&#123;</span>	<span class="comment">// find type for two-argument math function</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Promote_to_float&lt;_Ty1&gt;::type _Ty1f;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Promote_to_float&lt;_Ty2&gt;::type _Ty2f;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> conditional&lt;is_same&lt;_Ty1f, <span class="keyword">long</span> <span class="keyword">double</span>&gt;::value || is_same&lt;_Ty2f, <span class="keyword">long</span> <span class="keyword">double</span>&gt;::value, <span class="keyword">long</span> <span class="keyword">double</span>,</span><br><span class="line">		<span class="keyword">typename</span> conditional&lt;is_same&lt;_Ty1f, <span class="keyword">double</span>&gt;::value || is_same&lt;_Ty2f, <span class="keyword">double</span>&gt;::value, <span class="keyword">double</span>,</span><br><span class="line">			<span class="keyword">float</span>&gt;::type&gt;::type type;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>这边说明一下这段代码：<br><code>std::is_integral</code>用来判断一个类型是否是整数<br><code>std::conditional</code>有三个参数，其作用相当于<code>_Test? _Ty1: _Ty2</code>，其中<code>_Ty1</code>和<code>_Ty2</code>都是类型，而<code>std::enable_if</code>相对<code>std::conditional</code>省略了假的情况。<code>std::is_same</code>用来判断<code>_Ty1</code>和<code>_Ty2</code>是否相同类型。这个是模板编程里面常用到的元函数。<br><code>_Promote_to_float</code>用来将integral（整数）类型扩成double类型，如果是浮点数则不变。说到扩展，也挺有意思的，例如<code>char</code>在被爆之后是直接变成<code>int</code>，还有符号扩展和0扩展啥的，可以查看CSAPP P49页。<br><code>_Common_float_type</code>意思就是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_Ty1 is <span class="keyword">long</span> <span class="keyword">double</span> || _Ty2 is <span class="keyword">long</span> <span class="keyword">double</span>)</span><br><span class="line">	<span class="keyword">typedef</span> type <span class="keyword">long</span> <span class="keyword">double</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(_Ty1 is <span class="keyword">double</span> || _Ty2 is <span class="keyword">double</span>)</span><br><span class="line">	<span class="keyword">typedef</span> type <span class="keyword">double</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">typedef</span> type <span class="keyword">float</span></span><br></pre></td></tr></table></figure>

<p>用来给浮点数之间运算结果选择适合的精度</p>
<p>下面我们开启调试，跟踪pow函数执行。在调试中，在断点<code>_CSTD pow(type(_Left), type(_Right))</code>处发现<code>type(_Left)</code>和<code>type(_Right)</code>都已经通过<code>_Common_float_type</code>变成了<code>double</code>，继续跟踪发现直接调用了math.h中的pow。<br>特别地，对于c mode，<code>pow</code>实际直接调用了<code>pow(double, double)</code>。<br>此外还注意到<code>&lt;cmath&gt;</code>中有一个的<code>_Check_return_ inline double pow(_In_ double _Xx, _In_ int _Yx)</code>函数，而这个函数实际上调用了<code>&lt;cmath&gt;</code>中的<code>_Pow_int</code>函数，该函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">	_<span class="title">Check_return_</span> <span class="title">inline</span> _<span class="title">Ty</span> _<span class="title">Pow_int</span>(_<span class="title">Ty</span> _<span class="title">Xx</span>, <span class="title">int</span> _<span class="title">Yx</span>) _<span class="title">NOEXCEPT</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> _Nx;</span><br><span class="line">	<span class="keyword">if</span> (_Yx &gt;= <span class="number">0</span>)</span><br><span class="line">		_Nx = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(_Yx);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		_Nx = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(-_Yx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (_Ty _Zx = <span class="keyword">static_cast</span>&lt;_Ty&gt;(<span class="number">1</span>); ; _Xx *= _Xx)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">if</span> ((_Nx &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">			_Zx *= _Xx;</span><br><span class="line">		<span class="keyword">if</span> ((_Nx &gt;&gt;= <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> (_Yx &lt; <span class="number">0</span> ? <span class="keyword">static_cast</span>&lt;_Ty&gt;(<span class="number">1</span>) / _Zx : _Zx);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要就是处理指数为int的情况，其使用的是类似于快速幂的方法得到的结果。不过经过测试，这段代码始终没有被调用的情况，为什么标准库不使用这个重载版本，我想附录里面的一段答案应该能够给我们启发。<br>对于以上代码，我想最重要的就是<code>_Common_float_type</code>，<del>它避免了GCC472版本的类型二次转换的错误，</del>直接调用对应类型的重载版本。</p>
<h2 id="MSVC对类型转换的实现"><a href="#MSVC对类型转换的实现" class="headerlink" title="MSVC对类型转换的实现"></a>MSVC对类型转换的实现</h2><p>为了分析<code>_pow</code>函数，需要先了解一下MSVC对于类型转换的实现方案</p>
<h3 id="double-gt-int"><a href="#double-gt-int" class="headerlink" title="double -&gt; int"></a>double -&gt; int</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">;	int i = pow(26, 2);</span><br><span class="line">00E7277E  push        2  </span><br><span class="line">00E72780  push        1Ah  </span><br><span class="line">00E72782  call        pow&lt;int,int&gt; (0E71064h)  </span><br><span class="line">00E72787  add         esp,8  </span><br><span class="line">00E7278A  call        __ftol2_sse (0E71195h)  </span><br><span class="line">00E7278F  mov         dword ptr [i],eax  </span><br><span class="line">;	int i = pow(26.0, 2.0);</span><br><span class="line">00FE277E  sub         esp,8  </span><br><span class="line">00FE2781  movsd       xmm0,mmword ptr ds:[0FEAB98h]  </span><br><span class="line">00FE2789  movsd       mmword ptr [esp],xmm0  </span><br><span class="line">00FE278E  sub         esp,8  </span><br><span class="line">00FE2791  movsd       xmm0,mmword ptr ds:[0FEABD0h]  </span><br><span class="line">00FE2799  movsd       mmword ptr [esp],xmm0  </span><br><span class="line">00FE279E  call        _pow (0FE11FEh)  </span><br><span class="line">00FE27A3  add         esp,10h  </span><br><span class="line">00FE27A6  call        __ftol2_sse (0FE1195h)  </span><br><span class="line">00FE27AB  mov         dword ptr [i],eax  </span><br><span class="line">;	double s = 26.0;</span><br><span class="line">00D8277E  movsd       xmm0,mmword ptr ds:[0D8AB98h]  </span><br><span class="line">00D82786  movsd       mmword ptr [s],xmm0  </span><br><span class="line">;	int i = s;</span><br><span class="line">00D8278B  cvttsd2si   eax,mmword ptr [s]  </span><br><span class="line">00D82790  mov         dword ptr [i],eax</span><br></pre></td></tr></table></figure>

<p>这里我们发现如果pow参数都为int则是调用pow&lt;int, int&gt;，而这个pow&lt;int, int&gt;是通过xtgmath.h中的pow函数实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">_C_STD_BEGIN</span><br><span class="line">;template&lt;class _Ty1,</span><br><span class="line">;	class _Ty2&gt; inline</span><br><span class="line">;	typename _STD enable_if&lt; _STD is_arithmetic&lt;_Ty1&gt;::value</span><br><span class="line">;		&amp;&amp; _STD is_arithmetic&lt;_Ty2&gt;::value,</span><br><span class="line">;		typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type&gt;::type</span><br><span class="line">;	pow(const _Ty1 _Left, const _Ty2 _Right)</span><br><span class="line">;	&#123;	// bring mixed types to a common type</span><br><span class="line">00FE2B12  mov         ecx,30h  </span><br><span class="line">00FE2B17  mov         eax,0CCCCCCCCh  </span><br><span class="line">00FE2B1C  rep stos    dword ptr es:[edi]  </span><br><span class="line">;	typedef typename _STD _Common_float_type&lt;_Ty1, _Ty2&gt;::type type;</span><br><span class="line">;	return (_CSTD pow(type(_Left), type(_Right)));</span><br><span class="line">00FE2B1E  cvtsi2sd    xmm0,dword ptr [_Right]  </span><br><span class="line">00FE2B23  sub         esp,8  </span><br><span class="line">00FE2B26  movsd       mmword ptr [esp],xmm0  </span><br><span class="line">00FE2B2B  cvtsi2sd    xmm0,dword ptr [_Left]  </span><br><span class="line">00FE2B30  sub         esp,8  </span><br><span class="line">00FE2B33  movsd       mmword ptr [esp],xmm0  </span><br><span class="line">00FE2B38  call        _pow (0FE11FEh)  </span><br><span class="line">00FE2B3D  add         esp,10h  </span><br><span class="line">;	&#125;</span><br></pre></td></tr></table></figure>

<p><code>cvtsi2sd</code>来自SSE2，负责取出最低位的64位整型，并将其转换为一个浮点值，存放到<code>xmm0</code>浮点寄存器中。<br><code>mmword</code>负责将<code>xmm0</code>内的浮点移到<code>[esp]</code><br>所以<code>pow&lt;int, int&gt;</code>实现也是先转换成浮点再调用<code>_pow</code><br>对于<code>__ftol2_sse</code>函数底层是调用<code>cvtsi2sd</code>函数的，相比之下由于double是有符号而且表示范围要大于int，因此需要额外加一些处理。所以实际上通过调用<code>cvttsd2si</code>函数进行了类型转换。</p>
<h3 id="float-gt-int"><a href="#float-gt-int" class="headerlink" title="float -&gt; int"></a>float -&gt; int</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">;	int i = powf(26, 2);</span><br><span class="line">00C5277E  push        ecx  </span><br><span class="line">00C5277F  movss       xmm0,dword ptr ds:[0C5AB48h]  </span><br><span class="line">00C52787  movss       dword ptr [esp],xmm0  </span><br><span class="line">00C5278C  push        ecx  </span><br><span class="line">00C5278D  movss       xmm0,dword ptr ds:[0C5AB4Ch]  </span><br><span class="line">00C52795  movss       dword ptr [esp],xmm0  </span><br><span class="line">00C5279A  call        _powf (0C51523h)  </span><br><span class="line">00C5279F  add         esp,8  </span><br><span class="line">00C527A2  call        __ftol2_sse (0C51195h)  </span><br><span class="line">00C527A7  mov         dword ptr [i],eax  </span><br><span class="line">;	float s = 26.0;</span><br><span class="line">00D5277E  movss       xmm0,dword ptr ds:[0D5AB48h]  </span><br><span class="line">00D52786  movss       dword ptr [s],xmm0  </span><br><span class="line">;	int i = s;</span><br><span class="line">00D5278B  cvttss2si   eax,dword ptr [s]  </span><br><span class="line">00D52790  mov         dword ptr [i],eax</span><br></pre></td></tr></table></figure>

<h2 id="MSVC对-pow函数的实现"><a href="#MSVC对-pow函数的实现" class="headerlink" title="MSVC对_pow函数的实现"></a>MSVC对_pow函数的实现</h2><p>下面分析<code>_pow</code>函数<br>首先win7并没有装MSVC 140的库，编译成静态IDA导入不了PDB，都是天书。于是再在win10下面使用ollydbg来调试，然而并找不到<code>_main</code>，只看到<code>_cinit</code>函数包含的<code>_initterm</code>，只好靠调用关系和参数传递硬找。</p>
<table>
<thead>
<tr>
<th align="center">过程</th>
<th align="center">图片</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">进入main函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_main_enter.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">main函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_main.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pow函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_pow.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pow函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_pow_jumped.png"> <img src="/img/gccvspow/od_win10_vs_pow_jumped2.png"></td>
<td align="center">跳转使用SSE指令集计算pow</td>
</tr>
<tr>
<td align="center">pow函数返回</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_pow_jumped_getans.png"> <img src="/img/gccvspow/od_win10_vs_pow_jumped_getans_6ffae0.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">pow函数返回后准备调用类型转换函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_before_printf.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">使用cvttsd2si的类型转换函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_cvttsd2si.png"></td>
<td align="center">第一行的cmp指令由于不等于0，所以使用cvttsd2si而不是fistp，注意和后面gcc使用fistp进行比较</td>
</tr>
<tr>
<td align="center">类型转换的结果</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_after_cvttsd2si.png"></td>
<td align="center">od_win10_vs_after_main_exit</td>
</tr>
<tr>
<td align="center">退出main函数</td>
<td align="center"><img src="/img/gccvspow/od_win10_vs_after_main_exit.png"></td>
<td align="center">可以看到exit和_cexit函数</td>
</tr>
</tbody></table>
<h2 id="GCC对pow的实现"><a href="#GCC对pow的实现" class="headerlink" title="GCC对pow的实现"></a>GCC对pow的实现</h2><p>GCC版本之间差别比较大，我们这里还以GCC 472(Mingw32)分析。并简化了函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i2 = <span class="built_in">pow</span>(<span class="number">26</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>跟踪pow函数，发现实际调用了/MinGW32/lib/gcc/mingw32/5.7.2/include/c++/cmath中的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line">    <span class="keyword">inline</span> _GLIBCXX_CONSTEXPR</span><br><span class="line">    <span class="keyword">typename</span> __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type</span><br><span class="line">    <span class="built_in">pow</span>(_Tp __x, _Up __y)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__promote_2&lt;_Tp, _Up&gt;::__type __type;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">pow</span>(__type(__x), __type(__y));</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>的重载<code>std::pow&lt;int, int&gt;(__x = 26, __y = 2)</code><br>汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   0x00401d20 &lt;+0&gt;:	push   %ebp</span><br><span class="line">   0x00401d21 &lt;+1&gt;:	mov    %esp,%ebp</span><br><span class="line">   0x00401d23 &lt;+3&gt;:	sub    $0x18,%esp</span><br><span class="line">   0x00401d26 &lt;+6&gt;:	fildl  0xc(%ebp)</span><br><span class="line">   0x00401d29 &lt;+9&gt;:	fildl  0x8(%ebp)</span><br><span class="line">   0x00401d2c &lt;+12&gt;:	fxch   %st(1)</span><br><span class="line">   0x00401d2e &lt;+14&gt;:	fstpl  0x8(%esp)</span><br><span class="line">   0x00401d32 &lt;+18&gt;:	fstpl  (%esp)</span><br><span class="line">=&gt; 0x00401d35 &lt;+21&gt;:	call   0x401c88 &lt;pow&gt;</span><br><span class="line">   0x00401d3a &lt;+26&gt;:	leave  </span><br><span class="line">   0x00401d3b &lt;+27&gt;:	ret   </span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中<code>fildl</code>表示往st（浮点数操作堆栈）栈顶放入一个长整数，<code>fstpl</code>是取出一个长整型数<br>然后调用了crt中的<code>pow</code>函数的汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   0x74cd34b0 &lt;+0&gt;:	cmpl   $0x0,0x74cf6d84</span><br><span class="line">=&gt; 0x74cd34b7 &lt;+7&gt;:	je     0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt;</span><br><span class="line">   0x74cd34bd &lt;+13&gt;:	sub    $0x8,%esp</span><br><span class="line">   0x74cd34c0 &lt;+16&gt;:	stmxcsr 0x4(%esp)</span><br><span class="line">   0x74cd34c5 &lt;+21&gt;:	mov    0x4(%esp),%eax</span><br><span class="line">   0x74cd34c9 &lt;+25&gt;:	and    $0x1f80,%eax</span><br><span class="line">   0x74cd34ce &lt;+30&gt;:	cmp    $0x1f80,%eax</span><br><span class="line">   0x74cd34d3 &lt;+35&gt;:	jne    0x74cd34e4 &lt;pow+52&gt;</span><br><span class="line">   0x74cd34d5 &lt;+37&gt;:	fnstcw (%esp)</span><br><span class="line">   0x74cd34d8 &lt;+40&gt;:	mov    (%esp),%ax</span><br><span class="line">   0x74cd34dc &lt;+44&gt;:	and    $0x7f,%ax</span><br><span class="line">   0x74cd34e0 &lt;+48&gt;:	cmp    $0x7f,%ax</span><br><span class="line">   0x74cd34e4 &lt;+52&gt;:	lea    0x8(%esp),%esp</span><br><span class="line">   0x74cd34e8 &lt;+56&gt;:	jne    0x74cd3544 &lt;msvcrt!_CrtDbgReportWV+84&gt;</span><br><span class="line">   0x74cd34ea &lt;+58&gt;:	jmp    0x74ce0249 &lt;msvcrt!modf+9193&gt;</span><br><span class="line">   0x74cd34ef &lt;+63&gt;:	nop</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中<code>stmxcsr</code>将MXCSR存储到32位寄存器，<code>modf</code>将数分解为整数部分和小数部分。<br>在0x74cd34b7 &lt;+7&gt;处程序进入<code>msvcrt!_CrtDbgReportWV+84</code>。然后在其中某一个modf方法中卡死。于是很奇怪为什么要用到<code>msvcrt!_CrtDbgReportWV</code>这个函数<br>后来我试图用IDA来调试，不过win10 把我的安装程序杀掉了，所以我试图在win7里面用IDA调试，首先装完DevCPP之后进行调试，发现了不一样的光景。<br>crt中<code>pow</code>函数的代码变成了这样！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x7613608f &lt;+0&gt;:	cmpl   $0x0,0x761b50c0</span><br><span class="line">   0x76136096 &lt;+7&gt;:	je     0x7613609d &lt;pow+14&gt;</span><br><span class="line">   0x76136098 &lt;+9&gt;:	jmp    0x76140eb8 &lt;msvcrt!_CIpow+271&gt;</span><br><span class="line">   0x7613609d &lt;+14&gt;:	lea    0xc(%esp),%edx</span><br><span class="line">   0x761360a1 &lt;+18&gt;:	call   0x76120c6f &lt;msvcrt!_clearfp+230&gt;</span><br><span class="line">   0x761360a6 &lt;+23&gt;:	jmp    0x76120c85 &lt;msvcrt!_clearfp+252&gt;</span><br><span class="line">   0x761360ab &lt;+28&gt;:	movl   $0x8,-0x218(%ebp)</span><br><span class="line">   0x761360b5 &lt;+38&gt;:	jmp    0x7611cf67 &lt;wtoi+1860&gt;</span><br><span class="line">   0x761360ba &lt;+43&gt;:	cmp    %edi,%esi</span><br><span class="line">   0x761360bc &lt;+45&gt;:	jne    0x7611c269 &lt;wcsncpy_s+30&gt;</span><br><span class="line">   0x761360c2 &lt;+51&gt;:	jmp    0x7615dbb3 &lt;msvcrt!_ftol2_sse_excpt+114168&gt;</span><br><span class="line">   0x761360c7 &lt;+56&gt;:	xor    %eax,%eax</span><br><span class="line">   0x761360c9 &lt;+58&gt;:	mov    %ax,(%esi)</span><br><span class="line">   0x761360cc &lt;+61&gt;:	jmp    0x7611c2b8 &lt;wcsncpy_s+109&gt;</span><br></pre></td></tr></table></figure>

<p>反汇编居然不一样了！那到底哪个结果是对的呢？<br>用IDA调试发现GCC编译结果连main函数都不知道在哪里，到处都是sub_xxxx的无名函数，于是使用OD进行调试，至少能看清楚先后调用关系</p>
<p>下面是调试过程</p>
<table>
<thead>
<tr>
<th align="center">过程</th>
<th align="center">图片</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">进入main函数</td>
<td align="center"><img src="/img/gccvspow/od_win7_main.png"></td>
<td align="center">前面要先经过两个jmp</td>
</tr>
<tr>
<td align="center">进入pow&lt;int, int&gt;函数</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_pow.png"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">进入CRT中的pow函数的跳转</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_pow_jmp.png"></td>
<td align="center">这里是一个jmp跳转</td>
</tr>
<tr>
<td align="center">进入CRT中真正的pow函数</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_pow_crt.png"></td>
<td align="center">可以和WIN10和WIN7下的DEVCPP的反汇编进行对比</td>
</tr>
<tr>
<td align="center">CRT中pow函数返回</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_pow_crt_return.png"></td>
<td align="center">注意右边寄存器表中的ST0的值是正确的<code>26**2==676.00</code></td>
</tr>
<tr>
<td align="center"><code>printf</code>前的结果</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_2a3.png"></td>
<td align="center">注意到<strong>eax</strong>实际上存放着printf的参数<code>int i2</code>，但是变成了整数<code>0x02A3==675</code>而不是676</td>
</tr>
</tbody></table>
<p>所以应该是在浮点数变成整数这块出了问题<br>先解释几个汇编指令</p>
<table>
<thead>
<tr>
<th align="center">汇编</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fstcw</td>
<td align="center">存储FPU控制字到一个内存区域</td>
</tr>
<tr>
<td align="center">fldcw</td>
<td align="center">逆运算</td>
</tr>
<tr>
<td align="center">fistp</td>
<td align="center">存储ST(0)到整数并弹出寄存器堆栈</td>
</tr>
</tbody></table>
<p>下面来看main函数中是如何将FPU中的运算结果拿到eax中并提供给printf输出的</p>
<table>
<thead>
<tr>
<th align="center">过程</th>
<th align="center">图片</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center">从pow&lt;int, int&gt;函数跳出</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_after_pow.png"></td>
<td align="center">发现此时运算结果还在ST(0)中，并且fstcw指令从[esp+1e]处存取浮点控制字，fisttp指令将ST(0)存放到[esp+1c]==0x0028ff1c处</td>
</tr>
<tr>
<td align="center">运行完fistp检查内存块0x0028ff1c</td>
<td align="center"><img src="/img/gccvspow/od_win7_main_ff1c.png"></td>
<td align="center">发现此时结果变为2a3==675，于是应该是fistp指令出现了问题</td>
</tr>
</tbody></table>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>MSVC 140和GCC472(MinGW)使用了不同的汇编指令进行类型转换，导致出现问题。GCC使用了x87 FPU指令而MSVC 140使用了SSE指令集。<br>如果改成这样的方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i2 = <span class="built_in">pow</span>(<span class="number">26</span>, <span class="number">2</span>) + eps;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i2); <span class="comment">//似乎这个版本的GCC不支持%lf</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果在GCC472版本上也是正确的了</p>
<h1 id="Postscript"><a href="#Postscript" class="headerlink" title="Postscript"></a>Postscript</h1><p>本文参考了在 <a href="http://www.cplusplus.com/forum/general/5207/" target="_blank" rel="noopener">cplusplus.com</a> 上guestgulkan给出的这样的解答：</p>
<blockquote>
<p>This is actually quite interesting and works differently on Microsoft Visual Studio 2008 and Dev C++(using mingw);</p>
</blockquote>
<ol>
<li>Microsoft Visual Studio 2008 cmath is basically a wrapper that calls math.h.<br>In math.h if running in C mode you only get one power function pow(double, double).<br>In C++ mode (which we are using) you get the c++ overloaded functions:<br>long double pow(long double,int), float pow(float,int), double pow(double,int) and a few others.<br>So calling pow(int, int) for example pow(3,2) will always fail due to ambiguity whether you include cmath or math.h</li>
<li>DEV C++ with MINGW<br>With this set up, math.h just contains the the usual C function<br>pow(double, double) - so all the functions work because with pow(int, int) both ints get promoted to double by compiler and all is OK<br>cmath in more than a wrapper for math.h. First it includes math.h and then undefines a whole lot of stuff that math.h defined, and substitutes the c++ versions.<br>This includes the pow function declaration.<br>As the c++ overloaded functions (same as any other c++ compiler), you will get the ambiguity problem - when using pow(int, int).<br>P.S The ambiguity occurs with pow(int, int) because integers can be promoted to floats or doubles, which means that pow(int, int) can fit any of the 6 or so overloaded c++ pow function - so the compiler gets confused. </li>
</ol>
<p>对于标准库对pow函数的处理，<a href="http://stackoverflow.com/questions/2398442/why-isnt-int-powint-base-int-exponent-in-the-standard-c-libraries?answertab=active#tab-top" target="_blank" rel="noopener">stackoverflow</a>上的enigmaticPhysicist给出了这样的回答：</p>
<blockquote>
<p>A specialisation of pow(x, n) to where n is a natural number is often useful for time performance. But the standard library’s generic pow() still works pretty (surprisingly!) well for this purpose and it is absolutely critical to include as little as possible in the standard C library so it can be made as portable and as easy to implement as possible. On the other hand, that doesn’t stop it at all from being in the C++ standard library or the STL, which I’m pretty sure nobody is planning on using in some kind of embedded platform.</p>
</blockquote>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/ACM/" rel="tag"># ACM</a>
          
            <a href="/tags/MSVC/" rel="tag"># MSVC</a>
          
            <a href="/tags/GCC/" rel="tag"># GCC</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/12/26/brainfuck/" rel="next" title="brainfuck">
                <i class="fa fa-chevron-left"></i> brainfuck
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/06/numpy/" rel="prev" title="Python中的重要科学计算库numpy">
                Python中的重要科学计算库numpy <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">199</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">143</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#问题描述"><span class="nav-number">1.</span> <span class="nav-text">问题描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#问题分析"><span class="nav-number">2.</span> <span class="nav-text">问题分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MSVC对pow的实现"><span class="nav-number">2.1.</span> <span class="nav-text">MSVC对pow的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSVC对类型转换的实现"><span class="nav-number">2.2.</span> <span class="nav-text">MSVC对类型转换的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#double-gt-int"><span class="nav-number">2.2.1.</span> <span class="nav-text">double -&gt; int</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#float-gt-int"><span class="nav-number">2.2.2.</span> <span class="nav-text">float -&gt; int</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MSVC对-pow函数的实现"><span class="nav-number">2.3.</span> <span class="nav-text">MSVC对_pow函数的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GCC对pow的实现"><span class="nav-number">2.4.</span> <span class="nav-text">GCC对pow的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Postscript"><span class="nav-number">4.</span> <span class="nav-text">Postscript</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2016/01/16/C-GCC-VS-pow/';
          this.page.identifier = '2016/01/16/C-GCC-VS-pow/';
          this.page.title = 'GCC和MSVC在pow函数实现和类型转换比较';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
