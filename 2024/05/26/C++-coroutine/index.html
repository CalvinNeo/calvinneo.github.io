<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="翻译 lewissbaker 的三篇文章。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Coroutine 介绍的翻译">
<meta property="og:url" content="http://www.calvinneo.com/2024/05/26/C++-coroutine/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="翻译 lewissbaker 的三篇文章。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2025-10-17T14:42:27.957Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Coroutine 介绍的翻译">
<meta name="twitter:description" content="翻译 lewissbaker 的三篇文章。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2024/05/26/C++-coroutine/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>C++ Coroutine 介绍的翻译 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2024/05/26/C++-coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++ Coroutine 介绍的翻译
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-05-26T15:46:32+08:00">
                2024-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>翻译 <a href="https://lewissbaker.github.io/" target="_blank" rel="noopener">lewissbaker</a> 的三篇文章。</p>
<a id="more"></a>

<h1 id="Coroutine-Theory"><a href="#Coroutine-Theory" class="headerlink" title="Coroutine Theory"></a>Coroutine Theory</h1><p>暂略</p>
<h1 id="Understanding-operator-co-await"><a href="#Understanding-operator-co-await" class="headerlink" title="Understanding operator co_await"></a>Understanding operator co_await</h1><p><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await" target="_blank" rel="noopener">https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await</a></p>
<p>有两个接口需要定义，Promise 和 Awaiter。</p>
<p>Promise 接口定义了 coroutine 自己的行为，例如 coroutine 被调用的时候应该做什么，应该返回什么，并且定义 <code>co_await</code> 或者 <code>co_yield</code> 在 coroutine 中的行为。</p>
<p>Awaitable 接口定义了 co_await 的语义。<code>co_await</code> 一个对象时，这个 <code>co_await</code> 会被转化为一系列调用，负责挂起当前的 coroutine，执行一些帮助它后续被重新调度起来的命令，以及一些在 resume 之后生成 <code>co_await</code> 返回值的命令。</p>
<h2 id="Awaiters-and-Awaitables-Explaining-operator-co-await"><a href="#Awaiters-and-Awaitables-Explaining-operator-co-await" class="headerlink" title="Awaiters and Awaitables: Explaining operator co_await"></a>Awaiters and Awaitables: Explaining operator co_await</h2><h3 id="Awaitable"><a href="#Awaitable" class="headerlink" title="Awaitable"></a>Awaitable</h3><p>如果一个类型支持 <code>co_await &lt;expr&gt;</code>，它就是一个 Awaitable 类型。</p>
<p>Promise 类型可以通过 <code>await_transform</code> 方法去修改 <code>co_await</code> 的 expr：</p>
<ul>
<li>没有实现 <code>await_transform</code> 的 Promise 类型称为 Normally <code>Awaitable</code></li>
<li>实现了 <code>await_transform</code> 的 Promise 类型称为 Contextually <code>Awaitable</code><br>  此时这个类型只支持在一些特定类型的 coroutine 中被调用。</li>
</ul>
<h3 id="Awaiter"><a href="#Awaiter" class="headerlink" title="Awaiter"></a>Awaiter</h3><p>一个 Awaiter 类型需要实现三个方法：<code>await_ready</code>, <code>await_suspend</code> 和 <code>await_resume</code>，它们加在一起组成了 <code>co_await</code>。</p>
<p>目前来说，就是 Promise 类型通过 <code>await_transform</code> 得到 Awaitable，Awaitable 调用 <code>operator co_await()</code> 得到 Awaiter。特别地，一个类型可以既是 <code>Awaiter</code> 又是 <code>Awaitable</code>，这样就是少一次转换。</p>
<h2 id="获取-Awaiter"><a href="#获取-Awaiter" class="headerlink" title="获取 Awaiter"></a>获取 Awaiter</h2><p>假设这个 awaiting coroutine 的 <code>promise</code> 对象的类型是 P，并且这个 <code>promise</code> 是对当前 coroutine 中的 P 实例的左值引用。</p>
<ul>
<li>如果 P 有一个 <code>await_transform</code> 方法，那么 <code>expr</code> 就会被首先传给 <code>promise.await_transform(&lt;expr&gt;)</code>，以获得对应的 Awaitable 对象。否则，<code>expr</code> 的结果就会直接被作为 Awaitable 对象。不妨令为 <code>awaitable</code>。</li>
<li>然后，如果这个 <code>Awaitable</code> 对象 <code>awaitable</code> 有一个 <code>operator co_await()</code>，则会调用它得到 <code>Awaiter</code> 对象。否则就会直接使用 <code>awaitable</code> 作为 Awaiter 对象。</li>
</ul>
<p>如下代码所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaitable(P&amp; promise, T&amp;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_any_await_transform_member_v&lt;P&gt;)</span></span></span><br><span class="line">    return promise.await_transform(static_cast&lt;T&amp;&amp;&gt;(expr));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaiter(Awaitable&amp;&amp; awaitable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_member_operator_co_await_v&lt;Awaitable&gt;)</span></span></span><br><span class="line">    return static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable).operator co_await();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (has_non_member_operator_co_await_v&lt;Awaitable&amp;&amp;&gt;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> co_await(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】为什么要区分 Awaiter 和 Awaitable 呢？我觉得应该是便于解耦功能：</p>
<ul>
<li>Awaitable 只负责提供异步操作。</li>
<li>Awaiter 只负责处理如何挂起和恢复协程。</li>
</ul>
<p>进一步的，可以在一个 Awaitable 中实现多个不同的 Awaiter，根据不同的实现需求控制异步操作。</p>
<h2 id="Awaiting-the-Awaiter"><a href="#Awaiting-the-Awaiter" class="headerlink" title="Awaiting the Awaiter"></a>Awaiting the Awaiter</h2><h3 id="关于-await-suspend"><a href="#关于-await-suspend" class="headerlink" title="关于 await_suspend"></a>关于 await_suspend</h3><p><code>await_suspend</code> 有两个版本：</p>
<ol>
<li>返回 void 的版本<br> 在 <code>await_suspend</code> 调用返回后，会无条件将执行权转移给 caller 或者 resumer。<br> 我理解这对应了非对称协程，因为控制权会传递给外部的调度器。</li>
<li>返回 bool 的版本<br> 允许有条件地立即 resume 这个 coroutine，而不是将执行权转移给 caller 或者 resumer。<br> 一般来说，如果这个 awaiter 需要执行的异步操作在一些情况下可能同步地完成，那么就可以在 <code>await_suspend</code> 中返回 false，让 coroutine 立即 resume 从而执行后面的逻辑。<br> 我理解这对应了对称协程，因为返回 true 可以直接恢复协程运行，不需要通过外部的调度器。</li>
</ol>
<h3 id="关于整体流程"><a href="#关于整体流程" class="headerlink" title="关于整体流程"></a>关于整体流程</h3><p><code>co_await &lt;expr&gt;</code> 这个调用可以被转换成如下的形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">co_await (T expr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaitable = get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaiter = get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.await_ready())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)));</span><br><span class="line"></span><br><span class="line">    &lt;suspend-coroutine&gt;</span><br><span class="line">    <span class="comment">// 此后可以认为该 coroutine 已经被 suspend 了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// await_suspend 会处理诸如 rescheduling 的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_void_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      <span class="comment">// 此后，执行权交还给 caller 或者 resumer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">static_assert</span>(</span><br><span class="line">         <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;,</span><br><span class="line">         <span class="string">"await_suspend() must return 'void' or 'bool'."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;resume-point&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，下面说的 caller 我理解就是 coroutine 的 caller。而 resumer 指的是 coroutine 在被重新调度执行后的“caller”。</p>
</blockquote>
<p>在 <code>&lt;suspend-coroutine&gt;</code> 处，编译器会生成一些代码，保存当前 coroutine 的状态以便后续恢复。比如存储 <code>&lt;resume-point&gt;</code> 的位置，以及将当前寄存器的状态保存在内存中等。</p>
<p>在 <code>&lt;suspend-coroutine&gt;</code> 之后就可以认为这个 coroutine 已经被 suspend 了。所以可以在 <code>await_suspend</code> 调用中可以观察到被挂起的 coroutine。该 coroutine 随后可以被 resume 或者被 destroy。</p>
<p><code>await_suspend</code> 还需要负责在 coroutine 的异步操作被完成后重新 resume 或者 destroy 掉这个 coroutine。</p>
<p>如果这个 coroutine 的异步操作是被同步完成的，就可以通过 <code>await_ready</code> 调用避免掉 <code>&lt;suspend-coroutine&gt;</code> 挂起 coroutine 的开销。<br>【Q】那么它和返回 bool 的 <code>await_suspend</code> 的区别是啥呢？感觉 <code>await_ready</code> 是给你决定要不要，后者是真正处理挂起这个操作，虽然最终可能还是不挂起。。</p>
<p>在 <code>&lt;return-to-caller-or-resumer&gt;</code> 处，执行权会被重新转移给 caller 或者 resumer。此时会 popping the local stack frame but keeping the coroutine frame alive。</p>
<p>【Q】什么是 coroutine frame 呢？从下文可知，<code>coroutine_handle</code> 是一个 coroutine frame 的句柄，用来对它进行操作。可是它本体是啥呢？在<a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory" target="_blank" rel="noopener">前文</a>中有介绍：</p>
<blockquote>
<p>The ‘coroutine frame’ holds part of the coroutine’s activation frame that persists while the coroutine is suspended and the ‘stack frame’ part only exists while the coroutine is executing and is freed when the coroutine suspends and transfers execution back to the caller/resumer.</p>
</blockquote>
<p>如果被挂起的 coroutine 最终是被 resume 的话，会在 <code>&lt;resume-point&gt;</code> 点被继续执行。</p>
<p><code>await_resume</code> 调用的返回值会成为 <code>co_await</code> 的返回值。注意 <code>await_resume</code> 同样可能抛出异常，该异常会被传播到 <code>co_await</code> 之外。</p>
<p>Note that if an exception propagates out of the <code>await_suspend()</code> call then the coroutine is automatically resumed and the exception propagates out of the <code>co_await</code> expression without calling <code>await_resume()</code>.</p>
<h2 id="Coroutine-Handles"><a href="#Coroutine-Handles" class="headerlink" title="Coroutine Handles"></a>Coroutine Handles</h2><p>在上文中，一个 <code>coroutine_handle&lt;P&gt;</code> 类型的对象会被作为参数传给 <code>await_suspend</code>。这个类型是对 coroutine frame 的一个非 owning 的句柄。可以通过它：</p>
<ul>
<li>resume 或者 destroy 这个 coroutine</li>
<li>访问 coroutine 的 promise 对象</li>
</ul>
<p><code>coroutine_handle</code> 有类似下面的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>&lt;void&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span> :</span> coroutine_handle&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>resume<br> 当异步动作完成，需要 resume 这个 coroutine 的时候，应该调用 resume 方法。此时会在 <code>&lt;resume-point&gt;</code> 继续执行 coroutine。<br> 对 resume 本身的调用会在 coroutine 下一次碰到 <code>&lt;return-to-caller-or-resumer&gt;</code> 的时候返回。</li>
<li>destroy<br> 会销毁当前的 coroutine frame。<br> 这个方法一般是给是库作者实现 promise 类型的时候用的，一般开发者不需要使用。一般来说，coroutine frame 会被调用 coroutine 时返回的 RAII 类型所持有。所以使用的时候需要避免 double-destruction bug。</li>
<li>promise<br> 返回 coroutine 的 promise 对象的引用。<br> 对于大多数 Normally Awaitable 类型，应当使用 <code>coroutine_handle&lt;void&gt;</code> 作为 <code>await_suspend</code> 的参数，而不是 <code>coroutine_handle&lt;Promise&gt;</code>。如果在 <code>await_suspend</code> 中仅仅关心是否挂起，而不需要与 Promise 交互，那么 <code>coroutine_handle&lt;void&gt;</code> 是更合理的选择。<br> <code>coroutine_handle&lt;P&gt;::from_promise(P&amp; promise)</code> 这个函数可以由 coroutine promise 对象的引用来<strong>重新构造</strong> <code>coroutine_handle</code>。注意必须要保证 <code>P</code> 和 coroutine frame 使用的 concrete promise type 是一致的。也就是说如果创建 <code>coroutine_handle&lt;Base&gt;</code>，但是实际的 promise type 是 Derived 会导致 UB。</li>
<li>address/from_address<br> 将一个 coroutine handle 和 void* 指针进行互相转化。它的目的主要是和 C 语言的接口交互。<br> 但一般来说，在实现时经常发现还需要打包发送其他上下文，所以一般来说会将 <code>coroutine_handle</code> 放到一个结构中，并返回结构的指针。</li>
</ol>
<p>【Q】什么情况选需要使用 <code>coroutine_handle&lt;Promise&gt;</code> 呢？</p>
<ul>
<li>需要和 Promise 交互<br>  例如需要从 promise 对象获取某些异步的状态。</li>
</ul>
<h2 id="Synchronisation-free-async-code"><a href="#Synchronisation-free-async-code" class="headerlink" title="Synchronisation-free async code"></a>Synchronisation-free async code</h2><p><code>co_await</code> 的一个作用是可以在 coroutine 被 suspend 之后，和被 caller/resumer 重新获得执行权之前的这段时间中执行代码。</p>
<p>也就是说，Awaiter 对象会在 coroutine 被 suspend 之后启动一个 async 操作，将 <code>coroutine_handle</code> 传给这个 async 操作，让它能在完成后去 resume 之前的 coroutine。注意这个 coroutine 可能是在另一个线程中被 resume 了。整个过程中并不需要任何的线程间的同步开销。</p>
<p>举个例子，一段代码在线程 A 中执行，使用 coroutine 去做一个异步读，那么 Awaiter 可以在 <code>await_suspend</code> 中启动这个异步读，而这个异步读是在线程 B 中被实际处理的。但线程 A 和线程 B 之间是没有任何同步开销的。比如没有通过条件变量或者 channel 进行等待。如下面所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Time     Thread A                           Thread B</span><br><span class="line">  |      --------                           --------</span><br><span class="line">  |      ....                               Call OS - Wait for I/O event</span><br><span class="line">  |      Call await_ready()                    |</span><br><span class="line">  |      &lt;supend-point&gt;                        |</span><br><span class="line">  |      Call await_suspend(handle)            |</span><br><span class="line">  |        Store handle in operation           |</span><br><span class="line">  V        Start AsyncFileRead ---+            V</span><br><span class="line">                                  +-----&gt;   &lt;AsyncFileRead Completion Event&gt;</span><br><span class="line">                                            Load coroutine_handle from operation</span><br><span class="line">                                            Call handle.resume()</span><br><span class="line">                                              &lt;resume-point&gt;</span><br><span class="line">                                              Call to await_resume()</span><br><span class="line">                                              execution continues....</span><br><span class="line">           Call to AsyncFileRead returns</span><br><span class="line">         Call to await_suspend() returns</span><br><span class="line">         &lt;return-to-caller/resumer&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的伪代码中还需要注意：</p>
<ol>
<li>如果异步任务把 <code>coroutine_handle</code> 传给了另一个线程，那么这个线程就可能在 <code>await_suspend</code> 返回之前就 resume 这个 coroutine。这样，就会和 <code>await_suspend</code> 方法剩下来的部分竞争。</li>
<li>在 resume 一个 coroutine 的时候，首先需要调用 <code>await_resume</code> 去获得异步任务的结果。一般与此同时会立即析构掉 Awaiter 对象（可以看看上面的 demo）。因为 <code>await_suspend</code> 的 this 指针实际上指向 Awaiter 对象，所以 coroutine 可能会在 <code>await_suspend</code> 调用之前就 destruct 掉 coroutine 和 promise 对象。</li>
</ol>
<p>因此，一旦 coroutine 可以在另一个线程上 resume，就需要保证在 <code>await_suspend</code> 方法中不会再去访问 <code>this</code> 或者 coroutine 的 <code>promise()</code> 对象了，因为它们可能都被销毁了。实际上，当 coroutine 已经 scheduled for resumption 的时候，唯一能安全访问的只有 <code>await_suspend</code> 中的本地变量了。</p>
<h2 id="Comparison-to-Stackful-Coroutines"><a href="#Comparison-to-Stackful-Coroutines" class="headerlink" title="Comparison to Stackful Coroutines"></a>Comparison to Stackful Coroutines</h2><p>和诸如 win32 的 fiber 或者 <code>boost::context</code> 这样的有栈协程相比：</p>
<ul>
<li>在很多有栈协程中，suspend 操作通常会伴随着 resume 另一个 coroutine，从而组合成为一个 context-switch 操作。而这个操作会导致没有机会在 suspend 当前 coroutine 之后，且在将执行权转移到另一个 coroutine 之前执行一些逻辑。</li>
<li>这意味着如果需要实现一个 async-file-read 操作，就需要在 suspend 这个 coroutine <strong>之前</strong>就开启这个操作。因此这个操作可能就会在当前 coroutine 被 suspend 之前，就在另一个线程中被执行完了，而当前 coroutine 因此又要被 resume。这就在这两个线程之间引入了 race。而如上所述，C++ 的 coroutine 不需要在线程 A 和线程 B 之间引入同步机制。</li>
</ul>
<p>一个 workaround 手段是利用一个 trampoline context，它可以在 initiating context 被 suspend 之后代表它启动这个操作。但是，这个需要额外的技术设施，以及一个额外的 context-switch。因此，这个代价可能更大。</p>
<blockquote>
<p>这里的 trampoline 的本意是蹦床。技术上借指一种跳板机制：一小段由系统动态生成或预先安插的代码，它先获得 CPU 控制权，再“弹”到真正的目标地址去执行。常见的用这个机制的有 kretprobe、ftrace 的函数返回劫持，syscall，中断，长跳转补丁，PLT 机制等。</p>
</blockquote>
<h2 id="Avoiding-memory-allocations"><a href="#Avoiding-memory-allocations" class="headerlink" title="Avoiding memory allocations"></a>Avoiding memory allocations</h2><p>async 操作需要分配一些内存。比如在 win32 io 函数接口中，需要分配一个 OVERLAPPED 结构，这个结构在操作完成之后才会被释放。因此它必须要分配在堆上，并且每个 async 操作都需要 allocate 一次。在这里可以使用一个对象池来优化。</p>
<p>但是在 C++ 的 coroutine 中，可以避免堆内存分配，因为 local variable 在 coroutine 被 suspend 的时候会在 coroutine frame 里面，从而肯定是存活的。</p>
<p>将 per-operation state 存放在 Awaiter 对象中，可以白嫖 coroutine frame，从而延续到至少是 co_await expression 的 lifetime。一旦这个 operation 完成，coroutine 就会 resume，然后 Awaiter 对象就会被销毁。</p>
<p>当然，coroutine frame 本身还是会在堆上分配的，但是，一旦它被分配，是可以被用来执行很多个 async 操作的。这就好像是一个 arena memory allocator 一样，编译期可以在编译期计算出 local variable 的大小，然后就可以一次性分配出来了。</p>
<p>【Q】没太明白为啥 coroutine frame 是可以被复用的。我理解应该是指的可以 <code>co_await</code> 很多次。</p>
<h2 id="An-example-Implementing-a-simple-thread-synchronisation-primitive"><a href="#An-example-Implementing-a-simple-thread-synchronisation-primitive" class="headerlink" title="An example: Implementing a simple thread-synchronisation primitive"></a>An example: Implementing a simple thread-synchronisation primitive</h2><p>下面是一个简单的多生产者-多消费者模型。如果 set 已经被调用过了，那么后续的 consumer 就不会 suspend 了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">T value;</span><br><span class="line">async_manual_reset_event event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A single call to produce a value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  value = some_long_running_computation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish the value by setting the event.</span></span><br><span class="line">  event.<span class="built_in">set</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supports multiple concurrent consumers</span></span><br><span class="line">task&lt;&gt; consumer()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Wait until the event is signalled by call to event.set()</span></span><br><span class="line">  <span class="comment">// in the producer() function.</span></span><br><span class="line">  co_await event;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now it's safe to consume 'value'</span></span><br><span class="line">  <span class="comment">// This is guaranteed to 'happen after' assignment to 'value'</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的设计就是用一个 <code>std::atomic&lt;void*&gt;</code> 指针。它要么指向 this，说明已经 set 了；要么指向一个链表的表头，表示正在 suspend 的链表。</p>
<p>这里也实现了上面提到的节省内存分配的方案，将链表的 node 分配在 awaiter 对象里面，而 awaiter 对象在 coroutine frame 上面。</p>
<p>总而言之，代码如下所示。它支持 <code>co_await</code>，所以是个 Awaitable 类型。<code>co_await</code> 操作符返回一个 awaiter 也就是后面要实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">async_manual_reset_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  async_manual_reset_event(<span class="keyword">bool</span> initiallySet = <span class="literal">false</span>) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying/moving</span></span><br><span class="line">  async_manual_reset_event(<span class="keyword">const</span> async_manual_reset_event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event(async_manual_reset_event&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> async_manual_reset_event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event&amp; <span class="keyword">operator</span>=(async_manual_reset_event&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_set</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">awaiter</span>;</span></span><br><span class="line">  <span class="function">awaiter <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">awaiter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - 'this' =&gt; set state</span></span><br><span class="line">  <span class="comment">// - otherwise =&gt; not set, head of linked list of awaiter*.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span>*&gt; m_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 awaiter 如下所示:</p>
<ol>
<li>首先，它要持有一个 Awaitable 对象的指针，总得知道要 await 什么东西嘛。</li>
<li>然后，<code>async_manual_reset_event::awaiter</code> 形成了链表结构。每个 awaiter 要能访问自己后面的那个 awaiter。</li>
<li>然后，它要存储 coroutine_handle 对象，这样当 <code>await_suspend</code> 被调用后，它能知道如何去 resume coroutine<br> 我们没 <code>await_transform</code> 啥的，所以这里 <code>coroutine_handle</code> 对象就用的 <code>coroutine_handle&lt;void&gt;</code>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">async_manual_reset_event</span>:</span>:awaiter</span><br><span class="line">&#123;</span><br><span class="line">  awaiter(<span class="keyword">const</span> async_manual_reset_event&amp; event) <span class="keyword">noexcept</span></span><br><span class="line">  : m_event(event)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; awaitingCoroutine)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> async_manual_reset_event&amp; m_event;</span><br><span class="line">  <span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; m_awaitingCoroutine;</span><br><span class="line">  awaiter* m_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>await_ready</code> 要做的就是如果已经 set 了，就不再 suspend。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> async_manual_reset_event::awaiter::await_ready() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> m_event.is_set();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>await_suspend</code> 最为重要：</p>
<ol>
<li>首先，它要保存 <code>coroutine_handle</code>，从而后续可以调用 <code>coroutine_handle.resume()</code> 方法。</li>
<li>然后，就要将 awaiter 放到链表里面<br> 将链表头的指针 <code>m_state</code> 设置为 this。注意，这里的 this 是 awaiter 类型。<br> 如果添加成功，就返回 true，表示不会立即 resume 这个 coroutine。否则，就返回 false，表示可以立即 resume。这也回答了之前的一个【Q】，也就是 <code>await_suspend</code> 和 <code>await_ready</code> 的返回值到底作用有什么不同。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> async_manual_reset_event::awaiter::await_suspend(</span><br><span class="line">  <span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; awaitingCoroutine) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Special m_state value that indicates the event is in the 'set' state.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">const</span> setState = &amp;m_event;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the handle of the awaiting coroutine.</span></span><br><span class="line">  m_awaitingCoroutine = awaitingCoroutine;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to atomically push this awaiter onto the front of the list.</span></span><br><span class="line">  <span class="keyword">void</span>* oldValue = m_event.m_state.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Resume immediately if already in 'set' state.</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue == setState) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update linked list to point at current head.</span></span><br><span class="line">    m_next = <span class="keyword">static_cast</span>&lt;awaiter*&gt;(oldValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, try to swap the old list head, inserting this awaiter</span></span><br><span class="line">    <span class="comment">// as the new list head.</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!m_event.m_state.compare_exchange_weak(</span><br><span class="line">             oldValue,</span><br><span class="line">             <span class="keyword">this</span>,</span><br><span class="line">             <span class="built_in">std</span>::memory_order_release,</span><br><span class="line">             <span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Successfully enqueued. Remain suspended.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】这里 await_resume 起到了什么作用，为啥它是空的？</p>
<h2 id="Filling-out-the-rest-of-the-event-class"><a href="#Filling-out-the-rest-of-the-event-class" class="headerlink" title="Filling out the rest of the event class"></a>Filling out the rest of the event class</h2><p>下面是 <code>async_manual_reset_event::reset</code> 方法，它的实现很简单。如果是 set 状态，则改为 nullptr。</p>
<p>所以 <code>m_state</code> 有三种情况：</p>
<ol>
<li>nullptr<br> 没有 set，但是也没有 awaiter 在等</li>
<li>oldValue<br> set 了</li>
<li>其他<br> 有 awaiter 在等，并且指向了链表头</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> async_manual_reset_event::reset() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span>* oldValue = <span class="keyword">this</span>;</span><br><span class="line">  m_state.compare_exchange_strong(oldValue, <span class="literal">nullptr</span>, <span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 set 操作。其实有点类似于条件变量。实际行为是对链表中所有的 waiter 调用 <code>coroutine_handle.resume()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> async_manual_reset_event::<span class="built_in">set</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Needs to be 'release' so that subsequent 'co_await' has</span></span><br><span class="line">  <span class="comment">// visibility of our prior writes.</span></span><br><span class="line">  <span class="comment">// Needs to be 'acquire' so that we have visibility of prior</span></span><br><span class="line">  <span class="comment">// writes by awaiting coroutines.</span></span><br><span class="line">  <span class="keyword">void</span>* oldValue = m_state.exchange(<span class="keyword">this</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">  <span class="keyword">if</span> (oldValue != <span class="keyword">this</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Wasn't already in 'set' state.</span></span><br><span class="line">    <span class="comment">// Treat old value as head of a linked-list of waiters</span></span><br><span class="line">    <span class="comment">// which we have now acquired and need to resume.</span></span><br><span class="line">    <span class="keyword">auto</span>* waiters = <span class="keyword">static_cast</span>&lt;awaiter*&gt;(oldValue);</span><br><span class="line">    <span class="keyword">while</span> (waiters != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Read m_next before resuming the coroutine as resuming</span></span><br><span class="line">      <span class="comment">// the coroutine will likely destroy the awaiter object.</span></span><br><span class="line">      <span class="keyword">auto</span>* next = waiters-&gt;m_next;</span><br><span class="line">      waiters-&gt;m_awaitingCoroutine.resume();</span><br><span class="line">      waiters = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】这里的 awaiter 都是在什么地方被析构的呢？我理解这里的 awaiter 都是 local variable，生命周期等同于 <code>co_await</code> 的 <code>&lt;expr&gt;</code>。可以看到，<code>co_await</code> 返回的就是这个 awaiter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async_manual_reset_event::awaiter</span><br><span class="line">async_manual_reset_event::<span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> awaiter&#123; *<span class="keyword">this</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://godbolt.org/g/Ad47tH" target="_blank" rel="noopener">https://godbolt.org/g/Ad47tH</a> 是源码</p>
<h1 id="Understanding-the-promise-type"><a href="#Understanding-the-promise-type" class="headerlink" title="Understanding the promise type"></a>Understanding the promise type</h1><p><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type" target="_blank" rel="noopener">https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type</a></p>
<h2 id="Coroutine-Concepts"><a href="#Coroutine-Concepts" class="headerlink" title="Coroutine Concepts"></a>Coroutine Concepts</h2><p>Promise 接口用来自定义 coroutine 的行为，比如它被调用的时候，或者它返回（无论是正常值还是异常）的时候。</p>
<p>简单来说，之前的 Awaitable 和 Awaiter 花了很多精力处理 co_await，我们也看到如何通过 coroutine_handle 去 resume 或者 destroy。进而，我们会看到 Promise 是构建在 co_await 之上的。但 Promise 并不是一个语法糖，而是用来维护 coroutine 从被调用，到返回或者抛出异常，以及最后被销毁的整个生命周期的。换句话说，一个 coroutine 函数包含了多次 suspend 和 resume，而 co_await 只是处理其中的一次。Promise 则将整个过程串联起来，真正给我们展现了这个 coroutine。</p>
<h2 id="Promise-objects"><a href="#Promise-objects" class="headerlink" title="Promise objects"></a>Promise objects</h2><p>字如其名，Promise 确实有类似 <code>std::promise</code> 的作用，但功能更为衍生。应该将它理解为一个 coroutine state controller，而不应该看做 <code>std::promise</code>。</p>
<p>比如，写了一个 coroutine 函数，假设函数体是 <code>&lt;body-statements&gt;</code>，则编译器会转换成下面的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  co_await promise.initial_suspend();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    &lt;body-statements&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    promise.unhandled_exception();</span><br><span class="line">  &#125;</span><br><span class="line">FinalSuspend:</span><br><span class="line">  co_await promise.final_suspend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，promise 中还有一个 <code>get_return_object</code> 方法。调用 <code>promise.get_return_object()</code> 方法一个 <code>task</code> 对象。我理解这个 <code>task</code>，也就是 “Coroutine 本身”。关于这个类型，会在下一章讲解，但总的来说如下所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Task</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">promise_type</span> &#123;</span></span><br><span class="line">        <span class="function">Task <span class="title">get_return_object</span><span class="params">()</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> Task&#123;<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>)&#125;; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略其他成员</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; coro;  <span class="comment">// 协程句柄，用于管理协程的状态</span></span><br><span class="line"></span><br><span class="line">    Task(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) : coro(h) &#123;&#125;</span><br><span class="line">    ~Task() &#123; <span class="keyword">if</span> (coro) coro.destroy(); &#125;  <span class="comment">// 销毁协程句柄</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单概括：</p>
<ul>
<li><code>task</code> 里面会持有一个 <code>std::coroutine_handle</code> 对象。</li>
<li><code>task</code> 里面<strong>可以选择</strong>支持 <code>co_await</code> 操作符，也就是说它可以是一个 Awaitable 对象。</li>
<li>promise 对象的类型就是 <code>task::promise_type</code>。</li>
</ul>
<p>下面介绍一下整个生命流程，在后续的各个小节中，会逐个再次详细介绍。</p>
<p>当 coroutine 被调用的时候，会：</p>
<ol>
<li>【可选】用 operator new 分配一个 coroutine frame。<br> 【Q】为什么这里是可选的？见下文。</li>
<li>将 parameter 拷贝到 coroutine frame 里面。<br> 根据 cppreference，by value 的会被 copy 或者 move，by ref 的会被 ref。所以这里可能会有生命周期的问题。</li>
<li>调用 P 的构造函数创建 promise 对象。</li>
<li>调用 <code>promise.get_return_object()</code>，将返回值保存为 local variable。<code>promise.get_return_object()</code> 这个调用会在 coroutine 第一次 suspend 的时候返回。</li>
<li>调用 <code>promise.initial_suspend()</code>，并 <code>co_await</code> 结果。</li>
<li>当 <code>co_await promise.initial_suspend()</code> resume，coroutine 开始执行 <code>&lt;body-statements&gt;</code>。<br> 注意，根据上一章的介绍，initial_suspend 同样可能不挂起。</li>
</ol>
<p>在执行到 <code>co_return</code> 的时候，会：</p>
<ol>
<li>调用 <code>promise.return_void()</code> 或者 <code>promise.return_value(&lt;expr&gt;)</code>。</li>
<li>销毁所有的自动变量。</li>
<li>调用 <code>promise.final_suspend()</code>，并且 co_await 结果。</li>
</ol>
<p>和普通的 return 一样，falling off the end of the coroutine is equivalent to co_return。</p>
<p>特别地，如果 <code>&lt;body-statements&gt;</code> 抛出异常，则：</p>
<ol>
<li>捕获这个异常，并调用 <code>promise.unhandled_exception()</code>。</li>
<li>调用 <code>promise.final_suspend()</code>，并且 co_await 结果<br> It’s undefined behavior to resume a coroutine from this point.</li>
</ol>
<p>一旦 execution propagates outside of the coroutine body，那么 coroutine frame 就会被销毁。此时：</p>
<ol>
<li>调用 promise 对象的析构函数。</li>
<li>调用 parameter 的析构函数。</li>
<li>【可选】调用 operator delete 释放内存。</li>
<li>将执行权交还给 resumer 或者 caller。</li>
</ol>
<p>回顾下，在 <code>co_await</code> 中，执行完 <code>await_suspend</code> 之后，会有个叫 <code>&lt;return-to-caller-or-resumer&gt;</code> 的点。当第一次执行到 <code>&lt;return-to-caller-or-resumer&gt;</code> 的时候，或者 coroutine 没有执行到这个点就完成了，那么这个 coroutine 要么是 suspend 了，要么是 destroy 了。这之前通过调用 <code>promise.get_return_object()</code> 得到的 return-object 会被直接返回给 caller。</p>
<h2 id="Allocating-a-coroutine-frame"><a href="#Allocating-a-coroutine-frame" class="headerlink" title="Allocating a coroutine frame"></a>Allocating a coroutine frame</h2><p>First, the compiler generates a call to operator new to allocate memory for the coroutine frame.</p>
<p>If the promise type, P, defines a custom operator new method then that is called, otherwise the global operator new is called.</p>
<p>要点：</p>
<ol>
<li>operator new 分配的大小并不是 <code>sizeof(P)</code>，而是整个 coroutine frame 的大小，这个是由编译器计算的。包含了 parameter，promise 对象，local variables 以及其他的一些用来存储 coroutine state 的结构。我理解之前我们白嫖的也是这一段的空间。</li>
<li>编译期可以省略这个 operator new，而直接在 caller 的 stack-frame 或者 coroutine-frame 中分配，当：<ul>
<li>可以断定 coroutine frame 的生命周期是小于 caller 的。</li>
<li>并且编译期可以在调用的时候就能看到整个 coroutine frame 需要的大小。<br>目前 Coroutine TS 并没有 guarantee 任何的 elision 的情况，所以我们要处理分配 coroutine frame 的时候出现 std::bad_alloc 的情况。这里有一些异常处理相关的问题，一般我们就直接 terminate 掉了。但如果 promise 对象支持静态的 <code>P::get_return_object_on_allocation_failure()</code> 函数，则可以不抛出异常。</li>
</ul>
</li>
</ol>
<h3 id="Customising-coroutine-frame-memory-allocation"><a href="#Customising-coroutine-frame-memory-allocation" class="headerlink" title="Customising coroutine frame memory allocation"></a>Customising coroutine frame memory allocation</h3><p>Your promise type can define an overload of <code>operator new()</code> that will be called instead of global-scope <code>operator new</code> if the compiler needs to allocate memory for a coroutine frame that uses your promise type.</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_promise_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = my_custom_allocate(size);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    my_custom_free(ptr, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，也可以提供一个 custom allocator。如下所示，可以提供一个重载版本的 <code>P::operator new()</code>，它额外接受诸如 allocator 这样的参数，这样就可以在 new 的时候调用 <code>allocator.allocate()</code> 来分配内存了。</p>
<p>这里有个问题，coroutine frame 中存储的 parameter 在 <code>operator delete</code> 之前就已经被析构了，那如何获得 allocator 呢？所以，为了能在 <code>operator delete</code> 中调用 <code>allocator.deallocate()</code>，要将 allocator 存在 <code>allocatorOffset</code> 上面。</p>
<p>简而言之，就是在创建 my_promise_type 之前分配空间的时候，多分配一部分空间，用来存放对应的 allocator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ALLOCATOR&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_promise_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz, <span class="built_in">std</span>::<span class="keyword">allocator_arg_t</span>, ALLOCATOR&amp; allocator, ARGS&amp;... args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Round up sz to next multiple of ALLOCATOR alignment</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> allocatorOffset =</span><br><span class="line">      (sz + <span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>) &amp; ~(<span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call onto allocator to allocate space for coroutine frame.</span></span><br><span class="line">    <span class="keyword">void</span>* ptr = allocator.allocate(allocatorOffset + <span class="keyword">sizeof</span>(ALLOCATOR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take a copy of the allocator (assuming noexcept copy constructor here)</span></span><br><span class="line">    <span class="keyword">new</span> (((<span class="keyword">char</span>*)ptr) + allocatorOffset) ALLOCATOR(allocator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> allocatorOffset =</span><br><span class="line">      (sz + <span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>) &amp; ~(<span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>);</span><br><span class="line"></span><br><span class="line">    ALLOCATOR&amp; allocator = *<span class="keyword">reinterpret_cast</span>&lt;ALLOCATOR*&gt;(</span><br><span class="line">      ((<span class="keyword">char</span>*)ptr) + allocatorOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move allocator to local variable first so it isn't freeing its</span></span><br><span class="line">    <span class="comment">// own memory from underneath itself.</span></span><br><span class="line">    <span class="comment">// Assuming allocator move-constructor is noexcept here.</span></span><br><span class="line">    ALLOCATOR allocatorCopy = <span class="built_in">std</span>::move(allocator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// But don't forget to destruct allocator object in coroutine frame</span></span><br><span class="line">    allocator.~ALLOCATOR();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, free the memory using the allocator.</span></span><br><span class="line">    allocatorCopy.deallocate(ptr, allocatorOffset + <span class="keyword">sizeof</span>(ALLOCATOR));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To hook up the custom <code>my_promise_type</code> to be used for coroutines that pass <code>std::allocator_arg</code> as the first parameter, you need to specialise the <code>coroutine_traits</code> class (see section on <code>coroutine_traits</code> below for more details).</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ALLOCATOR, <span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_traits</span>&lt;my_return_type, std::allocator_arg_t, ALLOCATOR, ARGS...&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">using</span> promise_type = my_promise_type&lt;ALLOCATOR&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that even if you customise the memory allocation strategy for a coroutine, the compiler is still allowed to elide the call to your memory allocator.</p>
<h2 id="Copying-parameters-to-the-coroutine-frame"><a href="#Copying-parameters-to-the-coroutine-frame" class="headerlink" title="Copying parameters to the coroutine frame"></a>Copying parameters to the coroutine frame</h2><p>The coroutine needs to copy any parameters passed to the coroutine function by the original caller into the coroutine frame so that they remain valid after the coroutine is suspended.</p>
<p>复制 parameter 到 coroutine frame 的目的是保证了 coroutine 被 suspend 之后，这些东西都还在。</p>
<ol>
<li>如果是 by value 的复制，那么会调用 move-ctor。</li>
<li>如果是 by reference 的复制，无论是左值还是右值，那么只有引用本身会被复制，指向的对象是不会的。</li>
</ol>
<p>对于只有 trivial destructor 的 parameter，并且这个 parameter 在某个可达的 <code>&lt;return-to-caller-or-resumer&gt;</code> 之后就不再被访问了，则作为优化，编译器可以 elide 掉 copy。</p>
<p>C++ 中用完美转发会比较多，这在 coroutine 中经常会导致 UB。原因就是传入了 reference。</p>
<p>If any of the parameter copy/move constructors throws an exception then any parameters already constructed are destructed, the coroutine frame is freed and the exception propagates back out to the caller.</p>
<h2 id="Constructing-the-promise-object"><a href="#Constructing-the-promise-object" class="headerlink" title="Constructing the promise object"></a>Constructing the promise object</h2><p>先复制 parameter 再构造 promise 的原因是这样 promise 对象就可以基于复制后的 parameter 构建了。</p>
<p>First, the compiler checks to see if there is an overload of the promise constructor that can accept lvalue references to each of the copied parameters. If the compiler finds such an overload then the compiler generates a call to that constructor overload. If it does not find such an overload then the compiler falls back to generating a call to the promise type’s default constructor.</p>
<p>这个听起来挺神奇的，好像是既支持“默认”的 aggregate initialization，又支持 default initialization。</p>
<blockquote>
<p>Note that the ability for the promise constructor to “peek” at the parameters was a relatively recent change to the Coroutines TS, being adopted in N4723 at the Jacksonville 2018 meeting. See P0914R1 for the proposal. Thus it may not be supported by some older versions of Clang or MSVC.</p>
</blockquote>
<p>If the promise constructor throws an exception then the parameter copies are destructed and the coroutine frame freed during stack unwinding before the exception propagates out to the caller.</p>
<h2 id="Obtaining-the-return-object"><a href="#Obtaining-the-return-object" class="headerlink" title="Obtaining the return object"></a>Obtaining the return object</h2><p>The first thing a coroutine does with the promise object is obtain the <code>return-object</code> by calling <code>promise.get_return_object()</code>.</p>
<p>在 coroutine 被建立后，首先是调用 <code>promise.get_return_object()</code> 获取 return-object。return-object 后续会被返回给 coroutine 的 caller。如前文所说，返回的时间点是第一次 suspend，或者 coroutine 完成了。</p>
<p>执行大抵如下。注意，在 “Coroutine Handles” 这一节中介绍了，可以通过 <code>from_promise</code> 从 promise 重新构建出 <code>coroutine_handle</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pretend there's a compiler-generated structure called 'coroutine_frame'</span></span><br><span class="line"><span class="comment">// that holds all of the state needed for the coroutine. It's constructor</span></span><br><span class="line"><span class="comment">// takes a copy of parameters and default-constructs a promise object.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine_frame</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">some_coroutine</span><span class="params">(P param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* f = <span class="keyword">new</span> coroutine_frame(<span class="built_in">std</span>::forward&lt;P&gt;(param));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> returnObject = f-&gt;promise.get_return_object();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start execution of the coroutine body by resuming it.</span></span><br><span class="line">  <span class="comment">// This call will return when:</span></span><br><span class="line">  <span class="comment">// 1. the coroutine gets to the first suspend-point</span></span><br><span class="line">  <span class="comment">// 2. or when the coroutine runs to completion.</span></span><br><span class="line">  coroutine_handle&lt;<span class="keyword">decltype</span>(f-&gt;promise)&gt;::from_promise(f-&gt;promise).resume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then the return object is returned to the caller.</span></span><br><span class="line">  <span class="keyword">return</span> returnObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须要在执行 coroutine body 之前就获取 return-object</strong>。这因为：</p>
<ul>
<li>coroutine frame 以及它持有的 promise 对象可能在 <code>coroutine_handle::resume()</code> 返回前就被销毁掉。我理解也就是说，在 <code>resume()</code> 返回前，程序可能处于 suspend 状态的，后续这个 coroutine 就可能被直接销毁掉了。</li>
<li>此外，销毁未必发生在 caller 的线程上。所以，在开始执行 coroutine body 之后调用 <code>get_return_object()</code> 是不安全的。</li>
</ul>
<h2 id="The-initial-suspend-point"><a href="#The-initial-suspend-point" class="headerlink" title="The initial-suspend point"></a>The initial-suspend point</h2><p>The next thing the coroutine executes once the coroutine frame has been initialised and the return object has been obtained is execute the statement <code>co_await promise.initial_suspend()</code>;</p>
<p>执行 <code>co_await promise.initial_suspend()</code>，实际上允许 <code>promise_type</code> 也就是之前提到的 P 的作者，可以控制 coroutine 到底是立即执行，还是先 suspend 等调度。这有点类似于 <code>std::async</code> 里面相同参数的意思了。</p>
<p>如果在 initial suspend 点选择 suspend 的话，后续可以被 resume 或者被 destroy。</p>
<p>The result of the <code>co_await promise.initial_suspend()</code> expression is discarded so implementations should generally return void from the <code>await_resume()</code> method of the awaiter.</p>
<p>注意：</p>
<ol>
<li><code>initial_suspend()</code> 这个调用并没有被 try-catch 块环绕。则这里发生的异常，准确说是在 <code>&lt;return-to-caller-or-resumer&gt;</code> 之前的异常会在销毁 coroutine frame 和 <code>return-object</code> 之后被直接抛给 caller。</li>
<li>如果 <code>return-object</code> 中有某个 RAII 语义，能够在它被销毁的同时销毁 coroutine frame，那么就需要保证 <code>co_await promise.initial_suspend()</code> 不会抛出异常，否则会发生 double free 的问题。当然也有提案说要去修改这个行为。</li>
</ol>
<p>但实际上因为大部分 coroutine 的 <code>initial_suspend()</code> 只会返回都是 noexcept 的 <code>suspend_never</code> 或者 <code>suspend_always</code>，所以这不是个问题。</p>
<h2 id="Returning-to-the-caller"><a href="#Returning-to-the-caller" class="headerlink" title="Returning to the caller"></a>Returning to the caller</h2><p>当 coroutine 执行到第一个 <code>&lt;return-to-caller-or-resumer&gt;</code> 点（如果没有这个点就是执行完成）的时候，从 <code>get_return_object</code> 获取的 <code>return-object</code> 会被返回给 caller。</p>
<p>注意，<code>return-object</code> 的类型不一定是 coroutine function 的 return type。可以进行隐式转换。</p>
<h2 id="Returning-from-the-coroutine-using-co-return"><a href="#Returning-from-the-coroutine-using-co-return" class="headerlink" title="Returning from the coroutine using co_return"></a>Returning from the coroutine using co_return</h2><p>co_return 会被转化为:</p>
<ol>
<li><code>promise.return_void()</code><br><code>co_return &lt;expr&gt; </code></li>
<li><code>promise.return_value(&lt;expr&gt;)</code><br> 如果 expr 的类型是 void，则 <code>&lt;expr&gt;; promise.return_void();</code>。<br> 如果 expr 的类型不是 void，则 <code>promise.return_value(&lt;expr&gt;);</code></li>
</ol>
<p>Note that if execution runs off the end of a coroutine without a <code>co_return</code> statement then this is equivalent to having a <code>co_return</code>; at the end of the function body. In this case, if the <code>promise_type</code> does not have a <code>return_void()</code> method then the behaviour is undefined.</p>
<p>If either the evaluation of <code>&lt;expr&gt;</code> or the call to <code>promise.return_void()</code> or <code>promise.return_value()</code> throws an exception then the exception still propagates to <code>promise.unhandled_exception()</code>.</p>
<h2 id="Handling-exceptions-that-propagate-out-of-the-coroutine-body"><a href="#Handling-exceptions-that-propagate-out-of-the-coroutine-body" class="headerlink" title="Handling exceptions that propagate out of the coroutine body"></a>Handling exceptions that propagate out of the coroutine body</h2><p>TODO</p>
<h2 id="The-final-suspend-point"><a href="#The-final-suspend-point" class="headerlink" title="The final-suspend point"></a>The final-suspend point</h2><p><code>final_suspend</code> 的调用发生在 <code>return_void()</code>、<code>return_value()</code> 和 <code>unhandled_exception()</code> 之后。也发生在所有的 local variable 都被销毁之后。</p>
<p>这个调用允许 coroutine 去执行一些逻辑，例如 publishing a result，signalling completion，或者 resuming a continuation。<br>It also allows the coroutine to optionally suspend immediately before execution of the coroutine runs to completion and the coroutine frame is destroyed.</p>
<p>在 <code>final_suspend</code> 点 resume 一个 coroutine 是 UB 的，对于这个状态的 coroutine 只可以调用 destroy。</p>
<p>The rationale for this limitation, according to Gor Nishanov, is that this provides several optimisation opportunities for the compiler due to the reduction in the number of suspend states that need to be represented by the coroutine and a potential reduction in the number of branches required.</p>
<p>尽管可以在 <code>final_suspend</code> 处不 suspend，但建议是尽量 suspend。因为这可以强迫你在 coroutine 外面调用 destroy，当然，这里的调用一般是通过 RAII 实现的。这样，编译器才更容易确定 coroutine frame 的 lifetime 是被 caller 的 lifetime 覆盖了的，从而就可以执行之前说的 elide 掉 coroutine frame 内存分配的优化。</p>
<h2 id="How-the-compiler-chooses-the-promise-type"><a href="#How-the-compiler-chooses-the-promise-type" class="headerlink" title="How the compiler chooses the promise type"></a>How the compiler chooses the promise type</h2><p>编译期可以自动推导 <code>promise_type</code>。考虑下面 coroutine function 的签名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task&lt;<span class="keyword">float</span>&gt; foo(<span class="built_in">std</span>::<span class="built_in">string</span> x, <span class="keyword">bool</span> flag);</span><br></pre></td></tr></table></figure>

<p>Then the compiler will deduce the type of the coroutine’s promise by passing the return-type and parameter types as template arguments to coroutine_traits.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;<span class="keyword">float</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">bool</span>&gt;::promise_type;</span><br></pre></td></tr></table></figure>

<p>If the function is a non-static member function then the class type is passed as the second template parameter to <code>coroutine_traits</code>. Note that if your method is overloaded for rvalue-references then the second template parameter will be an rvalue reference.</p>
<p>For example, if you have the following methods:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task&lt;<span class="keyword">void</span>&gt; my_class::method1(<span class="keyword">int</span> x) <span class="keyword">const</span>;</span><br><span class="line">task&lt;foo&gt; my_class::method2() &amp;&amp;;</span><br></pre></td></tr></table></figure>

<p>Then the compiler will use the following promise types:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task&lt;<span class="keyword">void</span>&gt; my_class::method1(<span class="keyword">int</span> x) <span class="keyword">const</span>;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;<span class="keyword">void</span>&gt;, <span class="keyword">const</span> my_class&amp;, <span class="keyword">int</span>&gt;::promise_type;</span><br><span class="line"></span><br><span class="line">task&lt;foo&gt; my_class::method2() &amp;&amp;;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;foo&gt;, my_class&amp;&amp;&gt;::promise_type;</span><br></pre></td></tr></table></figure>

<p>可以自定义 <code>promise_type</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_traits</span>&lt;std::optional&lt;T&gt;, ARGS...&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">using</span> promise_type = optional_promise&lt;T&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Identifying-a-specific-coroutine-activation-frame"><a href="#Identifying-a-specific-coroutine-activation-frame" class="headerlink" title="Identifying a specific coroutine activation frame"></a>Identifying a specific coroutine activation frame</h2><p>介绍 <code>coroutine_handle</code> 这个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise = <span class="keyword">void</span>&gt;</span><br><span class="line">  struct coroutine_handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type-erased coroutine handle. Can refer to any kind of coroutine.</span></span><br><span class="line">  <span class="comment">// Doesn't allow access to the promise object.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>&lt;void&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// Constructs to the null handle.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">coroutine_handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to/from a void* for passing into C-style interop functions.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span>* <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query if the handle is non-null.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query if the coroutine is suspended at the final_suspend point.</span></span><br><span class="line">    <span class="comment">// Undefined behaviour if coroutine is not currently suspended.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resume/Destroy the suspended coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Coroutine handle for coroutines with a known promise type.</span></span><br><span class="line">  <span class="comment">// Template argument must exactly match coroutine's promise type.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span> :</span> coroutine_handle&lt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> coroutine_handle&lt;&gt;::coroutine_handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access to the coroutine's promise object.</span></span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can reconstruct the coroutine handle from the promise object.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以由两个方式获得：</p>
<ol>
<li><code>await_suspend</code> 的参数<br> 这类似于 CPS 的方式。</li>
<li>通过 <code>from_promise</code> 从 promise 构造</li>
</ol>
<p><code>coroutine_handle</code> 并不是 RAII 的，需要调用 destroy 去释放它。这样的设计是为了减少 overhead。</p>
<p>You should generally try to use higher-level types that provide the RAII semantics for coroutines, such as those provided by cppcoro (shameless plug), or write your own higher-level types that encapsulate the lifetime of the coroutine frame for your coroutine type.</p>
<h2 id="Customising-the-behaviour-of-co-await"><a href="#Customising-the-behaviour-of-co-await" class="headerlink" title="Customising the behaviour of co_await"></a>Customising the behaviour of co_await</h2><p>promise 类型可以可选地自定义 <code>co_await</code> 表达式的行为。<br>只需要定义这个类型的 <code>await_transform()</code> 方法，编译器就能够将所有的 <code>co_await &lt;expr&gt;</code> 转换为 <code>co_await promise.await_transform(&lt;expr&gt;)</code>。</p>
<p>为什么要提供这个功能呢？</p>
<h3 id="原因1"><a href="#原因1" class="headerlink" title="原因1"></a>原因1</h3><p>因为有些类型不是 awaitable 的，所以要提供这个转换。</p>
<p>For example, a promise type for coroutines with a <code>std::optional&lt;T&gt;</code> return-type might provide an <code>await_transform()</code> overload that takes a <code>std::optional&lt;U&gt;</code> and that returns an awaitable type that either returns a value of type U or suspends the coroutine if the awaited value contains <code>nullopt</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optional_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(<span class="built_in">std</span>::optional&lt;U&gt;&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">awaiter</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="built_in">std</span>::optional&lt;U&gt;&amp; value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      explicit awaiter(std::optional&lt;U&gt;&amp; x) noexcept : value(x) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value.has_value(); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt;)</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">      <span class="function">U&amp; <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *value; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> awaiter&#123; value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原因2"><a href="#原因2" class="headerlink" title="原因2"></a>原因2</h3><p>It lets you disallow awaiting on certain types by declaring <code>await_transform</code> overloads as deleted.</p>
<p>For example, a promise type for <code>std::generator&lt;T&gt;</code> return-type might declare a deleted <code>await_transform()</code> template member function that accepts any type. This basically disables use of co_await within the coroutine.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generator_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disable any use of co_await within this type of coroutine.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="built_in">std</span>::experimental::<span class="function">suspend_never <span class="title">await_transform</span><span class="params">(U&amp;&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原因3"><a href="#原因3" class="headerlink" title="原因3"></a>原因3</h3><p>It lets you adapt and change the behaviour of normally awaitable values.</p>
<p>For example, you could define a type of coroutine that ensured that the coroutine always resumed from every co_await expression on an associated executor by wrapping the awaitable in a resume_on() operator (see cppcoro::resume_on()).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">executor_task_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Executor executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> cppcoro::resume_on;</span><br><span class="line">    <span class="keyword">return</span> resume_on(<span class="keyword">this</span>-&gt;executor, <span class="built_in">std</span>::forward&lt;Awaitable&gt;(awaitable));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As a final word on <code>await_transform()</code>, it’s important to note that if the promise type defines any <code>await_transform()</code> members then this triggers the compiler to transform all <code>co_await</code> expressions to call promise.await_transform(). 所以，如果只是希望对某些类型定制 co_await 行为，最好为 <code>await_transform()</code> 提供一个只 forward argument 的重载。</p>
<h2 id="Customising-the-behaviour-of-co-yield"><a href="#Customising-the-behaviour-of-co-yield" class="headerlink" title="Customising the behaviour of co_yield"></a>Customising the behaviour of co_yield</h2><p>编译器会把 <code>co_yield &lt;expr&gt;</code> 转换为 <code>co_await promise.yield_value(&lt;expr&gt;)</code>。因此 promise 对象可以定制 <code>yield_value</code> 方法。</p>
<p>如果编译器没有定制这个方法，该方法不会有默认的行为。所以需要显式提供这样的方法，promise 类型才能支持 co_yield。</p>
<p>如下所示，对一个 generator 类型提供了 yield_value 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generator_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  T* valuePtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::experimental::<span class="function">suspend_always <span class="title">yield_value</span><span class="params">(T&amp; value)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Stash the address of the yielded value and then return an awaitable</span></span><br><span class="line">    <span class="comment">// that will cause the coroutine to suspend at the co_yield expression.</span></span><br><span class="line">    <span class="comment">// Execution will then return from the call to coroutine_handle&lt;&gt;::resume()</span></span><br><span class="line">    <span class="comment">// inside either generator&lt;T&gt;::begin() or generator&lt;T&gt;::iterator::operator++().</span></span><br><span class="line">    valuePtr = <span class="built_in">std</span>::addressof(value);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Understanding-Symmetric-Transfer"><a href="#Understanding-Symmetric-Transfer" class="headerlink" title="Understanding Symmetric Transfer"></a>Understanding Symmetric Transfer</h1><p><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer" target="_blank" rel="noopener">https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer</a></p>
<p>在 Coroutine TS 刚开始被提出的时候，有一个限制，会导致轻易的 stack-overflow。为了避免它，就需要在 <code>task&lt;T&gt;</code> 类型中引入额外的同步开销。</p>
<p>在 2018 年，引入了一个 symmetric transfer 的特性，使得我们可以挂起一个 Coroutine，并 Resume 另一个，但是不会消耗栈空间了。</p>
<h2 id="First-some-background-on-how-a-task-coroutine-works"><a href="#First-some-background-on-how-a-task-coroutine-works" class="headerlink" title="First some background on how a task coroutine works"></a>First some background on how a task coroutine works</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">co_await <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不放展开看看 <code>bar()</code> 在 <code>co_await foo()</code> 的时候都发生了什么：</p>
<ol>
<li>调用 foo 需要有下面几步<br> 为 coroutine frame 分配寻出空间。<br> 将参数复制到 coroutine frame 里面。在当前 case 里面没有参数，所以就是一个空操作。<br> 在 coroutine frame 里面构造 promise object。<br> 调用 <code>promise.get_return_object()</code> 获得 foo() 的返回值。这个过程中会产生被返回的 task 对象，并使用 std::coroutine_handle 创建它。如前所述，std::coroutine_handle 持有刚创建的 coroutine frame 的引用。<br> 在 initial-suspend point 挂起 coroutine 的执行。<br> 返回 task 对象给到 bar()。</li>
<li>后面，bar() 会执行 co_await<br> <code>bar()</code> 会被挂起，然后调用由 <code>foo()</code> 返回的 task 对象上的 <code>await_suspend()</code> 方法。会把指向 bar 的 coroutine frame 的 <code>std::coroutine_handle</code> 传给该方法。<br> 在 <code>await_suspend()</code> 中，会存储 bar() 的 <code>std::coroutine_handle</code> 到 foo 的 promise 对象中【A】，然后通过调用 <code>foo</code> 的 <code>std::coroutine_handle</code> 的 resume 方法去 resume foo() 的执行。</li>
<li>foo() 会同步地执行。</li>
<li>foo() 会在 final-suspend point 挂起，然后 resume bar。这是根据被存在 promise 对象中的 std::coroutine_handle 来找到的，见【A】步骤。</li>
<li>bar() 会 resume，继续执行，并最终到达 co_await 语句处，并调用临时 task 对象的析构函数。</li>
<li>task 对象执行析构。因为这个 task 对象是 foo() 返回的，所以它会调用 foo() 的 coroutine handle 上的 <code>.destroy()</code> 方法，这样就会销毁 coroutine frame，包括 promise 对象和之前复制了的参数之内。</li>
</ol>
<h2 id="Outline-of-a-task-implementation"><a href="#Outline-of-a-task-implementation" class="headerlink" title="Outline of a task implementation"></a>Outline of a task implementation</h2><p>下面可以看下如果不支持 symmetric transfer，task 类应该如何被实现。可以看出 task 是一个 Awaitable。</p>
<p>A task has exclusive ownership of the <code>std::coroutine_handle</code> that corresponds to the coroutine frame created during the invocation of the coroutine. The task object is an RAII object that ensures that <code>.destroy()</code> is called on the <code>std::coroutine_handle</code> when the task object goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span> <span class="comment">/* see below */</span> &#125;;</span><br><span class="line"></span><br><span class="line">  task(task&amp;&amp; t) <span class="keyword">noexcept</span></span><br><span class="line">  : coro_(<span class="built_in">std</span>::exchange(t.coro_, &#123;&#125;))</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~task() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_)</span><br><span class="line">      coro_.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">awaiter</span> &#123;</span> <span class="comment">/* see below */</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">awaiter <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">task</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  : coro_(h)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面会展开讲解 promise_type 和 awaiter 的实现。</p>
<h2 id="Implementing-task-promise-type"><a href="#Implementing-task-promise-type" class="headerlink" title="Implementing task::promise_type"></a>Implementing task::promise_type</h2><p>promise_type 会定义在 coroutine frame 中创建的 Promise 对象的类型。</p>
<p>首先，需要实现 <code>get_return_object()</code> 去构造将来要被返回的 task 对象。这个对象的初始化需要借助于 <code>std::coroutine_handle</code>。</p>
<p>这里是根据 <code>from_promise</code> 从 Promise 对象中重新构造出了 <code>std::coroutine_handle</code>。这是获得 <code>std::coroutine_handle</code> 的一种方法，另一种方法是 <code>await_suspend</code> 参数，前文中提到过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:promise_type &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">task <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task&#123;<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面，这个 coroutine 需要在 initial-suspend point 挂起，这样在 task 被 await 的时候，我们可以 resume 它。这样 lazy 的处理有下面几点好处：</p>
<ol>
<li>It means that we can attach the continuation’s <code>std::coroutine_handle</code> before starting execution of the coroutine. This means we don’t need to use thread-synchronisation to arbitrate the race between attaching the continuation later and the coroutine running to completion.<br> 我理解这里讲的是和“Comparison to Stackful Coroutines”这一章节中类似的问题。</li>
<li>It means that the task destructor can unconditionally destroy the coroutine frame - we don’t need to worry about whether the coroutine is potentially executing on another thread since the coroutine will not start executing until we await it, and while it is executing the calling coroutine is suspended and so won’t attempt to call the task destructor until the coroutine finishes executing.<br> 这里说的是 task 的析构函数可以不加判断地直接销毁掉 coroutine frame。也就是说，并不需要担心 coroutine 是否此时还在另一个线程上执行。实际上我们只有在 await 它的时候，coroutine 才会开始执行。而这个时候，调用方 coroutine 已经被挂起了，直到 coroutine 执行完成后，都不会再调用 task 的 destructor 了。<br> 所以这让编译器更容易把分配 coroutine frame 的操作 inline 到 caller 的 frame 里面。我理解就是“Allocating a coroutine frame”里面讲的东西。<br> See P0981R0 to read more about the Heap Allocation eLision Optimisation (HALO).</li>
<li>It also improves the exception-safety of your coroutine code. If you don’t immediately <code>co_await</code> the returned task and do something else that can throw an exception that causes the stack to unwind and the task destructor to run then we can safely destroy the coroutine since we know it hasn’t started yet. We aren’t left with the difficult choice between detaching, potentially leaving dangling references, blocking in the destructor, terminating or undefined-behaviour.<br> 这也能提高异常安全性。</li>
</ol>
<p>为了让 coroutine 能够 initially suspend，需要定义一个返回 <code>suspend_always</code> 的 <code>initial_suspend</code> 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后，定义 <code>return_void()</code> 方法。这是在执行 <code>co_return</code> 的时候，或者执行到 coroutine 末尾的时候被调用的。这个方法并不会做什么事情，只是让编译器知道 <code>co_return;</code> 对于当前的 coroutine 类型是合法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>We also need to add an <code>unhandled_exception()</code> method that is called if an exception escapes the body of the coroutine. For our purposes we can just treat the task coroutine bodies as noexcept and call <code>std::terminate()</code> if this happens.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::terminate();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，还需要 coroutine 能在 final-suspend point 被 suspend 住，然后 resume its Continuation。在当前的 case 中 continuation 就是在 awaiting 的 coroutine，在 <code>task::awaiter::await_suspend</code> 的时候被设置的。</p>
<p>【Q】“resume its Continuation” 中的 Continuation 指的是什么？这里我理解应该就是 loop_synchronously 里面循环的下一次迭代。可以在 Stack 图中看到 continuation 具体指向哪里的。</p>
<p>因此，需要在 promise 中引入一个成员，去持有 continuation 的 <code>std::coroutine_handle</code>，不然如何调用对应的 <code>.resume()</code> 方法呢？</p>
<p>还需要定义 <code>final_suspend()</code> 方法来返回一个 awaitable 对象也就是 final_awaiter，让它在当前 coroutine 被挂起后，去 resume 这个 continuation。</p>
<p>注意，需要再当前 coroutine 被 suspend 之后，才能 resume continuation。这是因为 continuation 可能立即就会调用 task 的析构函数，从而间接调用 coroutine frame 的 <code>.destroy()</code> 方法。<code>.destroy()</code> 方法只对 suspended 的 coroutine 生效。</p>
<p>The compiler inserts code to evaluate the statement <code>co_await promise.final_suspend();</code> at the closing curly brace.</p>
<p>需要注意，在调用 <code>final_suspend</code> 的时候，coroutine 还没有进入 suspend 状态。需要等到返回的 awaitable 对象上的 await_suspend() 方法被调用之后，coroutine 才被 suspend。关于这个我觉得可以参考之前讲的 <code>&lt;return-to-caller-or-resumer&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">final_awaiter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">      <span class="comment">// Lookup its continuation in the promise and resume it.</span></span><br><span class="line">      h.promise().continuation.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">final_awaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【Q】为啥这里定义一个 <code>final_awaiter</code>，而不是直接用 std::suspend_always。<br>首先，<code>suspend_always</code> 和 <code>suspend_never</code> 的实现上分别定义了 <code>await_ready()</code> 方法始终返回 false 或者 true。<code>await_suspend</code> 或者 <code>await_resume</code> 方法都是空实现。而这里是希望 <code>final_awaiter</code> 的 <code>await_suspend</code> 能去 resume continuation。</p>
<h2 id="Implementing-task-operator-co-await"><a href="#Implementing-task-operator-co-await" class="headerlink" title="Implementing task::operator co_await()"></a>Implementing task::operator co_await()</h2><p>co_await 会返回一个 awaiter 对象，这个对象需要支持 <code>await_ready()</code>、<code>await_suspend()</code> 和 <code>await_resume()</code>。</p>
<p>下面就是 awaiter 的简单实现。注意，一旦一个 coroutine 被 suspend 了，就需要保存 coroutine handle 到 promise 对象中。这样后续可以调用 std::coroutine_handle 中的 resume() 方法去执行这个 task。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:awaiter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">    <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">    coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then we resume the task's coroutine, which is currently suspended</span></span><br><span class="line">    <span class="comment">// at the initial-suspend-point (ie. at the open curly brace).</span></span><br><span class="line">    coro_.resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">awaiter</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;task::promise_type&gt; h)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  : coro_(h)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;task::promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">task::awaiter task::<span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> awaiter&#123;coro_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者给出了一个可编译的 demo 在 <a href="https://godbolt.org/z/-Kw6Nf%E3%80%82" target="_blank" rel="noopener">https://godbolt.org/z/-Kw6Nf。</a></p>
<h2 id="The-stack-overflow-problem"><a href="#The-stack-overflow-problem" class="headerlink" title="The stack-overflow problem"></a>The stack-overflow problem</h2><p>考虑下面的代码，如果 count 足够大，程序就会爆栈。例如 <a href="https://godbolt.org/z/gy5Q8q" target="_blank" rel="noopener">https://godbolt.org/z/gy5Q8q</a> 中展示了当 count 是 1000000 的时候，程序就爆栈了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">completes_synchronously</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">loop_synchronously</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="function">co_await <span class="title">completes_synchronously</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当 loop_synchronously() 开始执行时，有一个其他 coroutine 正在 <code>co_await</code> 的自己返回的 task，也就是在 <code>co_await loop_synchronously()</code>。因此，它会 suspend 正在 awating 的 coroutine，然后调用 <code>task::awaiter::await_suspend()</code>。如前文介绍，<code>await_suspend</code> 会负责调用对应 task 的<code> std::coroutine_handle</code> 的 <code>resume()</code> 方法。</p>
<p>Thus the stack will look something like this when loop_synchronously() starts.</p>
<p>我理解这里倒数第二底层的 task::awaiter::await_suspend 是由于这个其他 coroutine 在 await 从而产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+------------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume    | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+------------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume     |                     | | task::promise        | |</span><br><span class="line">+------------------------------+                     | | - continuation --.   | |</span><br><span class="line">| task::awaiter::await_suspend |                     | +------------------|---+ |</span><br><span class="line">+------------------------------+                     | ...                |     |</span><br><span class="line">| awaiting_coroutine$resume    |                     +--------------------|-----+</span><br><span class="line">+------------------------------+                                          V</span><br><span class="line">|  ....                        |                     +--------------------------+</span><br><span class="line">+------------------------------+                     | awaiting_coroutine frame |</span><br><span class="line">                                                     |                          |</span><br><span class="line">                                                     +--------------------------+</span><br></pre></td></tr></table></figure>

<p>这里的 <code>$resume</code> 后缀用来表示 coroutine 中的用户自定义逻辑。</p>
<p>然后，当 <code>loop_synchronously()</code> 去 <code>co_await</code> 从 <code>completes_synchronously()</code> 返回的 task 对象时，当前的 coroutine 会被 suspend，然后会调用 <code>task::awaiter::await_suspend()</code>。await_suspend() 方法会调用 <code>completes_synchronously()</code> 的 coroutine handle 上的 <code>.resume()</code> 方法。</p>
<p>这会 resume <code>completes_synchronously()</code> coroutine。这个 coroutine 会 synchronously 地运行结束，然后在 final-suspend point 被 suspend。然后它会调用 <code>task::promise::final_awaiter::await_suspend()</code>，然后最终调用 <code>loop_synchronously()</code> 这个 coroutine 的 coroutine handle 上的 <code>.resume()</code> 方法。</p>
<p>如果我们在 <code>loop_synchronously()</code> coroutine 被 resume 之后，它返回的临时的 task 被销毁之前，检查调用栈，就可以看到下面的情况。</p>
<p>这里的 final_awaiter 也就是 promise 对象的 final_suspend() 方法返回的内容。根据之前的说明，它是在 final-suspend point 之后 resume continuation 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+-------------------------------+ &lt;-- top of stack</span><br><span class="line">| loop_synchronously$resume     | active coroutine -.</span><br><span class="line">+-------------------------------+                   |</span><br><span class="line">| coroutine_handle::resume      |            .------&apos;</span><br><span class="line">+-------------------------------+            |</span><br><span class="line">| final_awaiter::await_suspend  |            |</span><br><span class="line">+-------------------------------+            |  +--------------------------+ &lt;-.</span><br><span class="line">| completes_synchronously$resume|            |  | completes_synchronously  |   |</span><br><span class="line">+-------------------------------+            |  | frame                    |   |</span><br><span class="line">| coroutine_handle::resume      |            |  +--------------------------+   |</span><br><span class="line">+-------------------------------+            &apos;---.                             |</span><br><span class="line">| task::awaiter::await_suspend  |                V                             |</span><br><span class="line">+-------------------------------+ &lt;-- prev top  +--------------------------+   |</span><br><span class="line">| loop_synchronously$resume     |     of stack  | loop_synchronously frame |   |</span><br><span class="line">+-------------------------------+               | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume      |               | | task::promise        | |   |</span><br><span class="line">+-------------------------------+               | | - continuation --.   | |   |</span><br><span class="line">| task::awaiter::await_suspend  |               | +------------------|---+ |   |</span><br><span class="line">+-------------------------------+               | - task temporary --|---------&apos;</span><br><span class="line">| awaiting_coroutine$resume     |               +--------------------|-----+</span><br><span class="line">+-------------------------------+                                    V</span><br><span class="line">|  ....                         |               +--------------------------+</span><br><span class="line">+-------------------------------+               | awaiting_coroutine frame |</span><br><span class="line">                                                |                          |</span><br><span class="line">                                                +--------------------------+</span><br></pre></td></tr></table></figure>

<p>然后，就会调用 task 的析构函数，摧毁 <code>completes_synchronously()</code> 的 coroutine frame。然后就会进行新一轮的循环，创建新的 completes_synchronously() 的 coroutine frame，然后 resume。</p>
<p>最终结果是，<code>loop_synchronously()</code> 和 <code>completes_synchronously()</code> 会递归地互相调用彼此。每次调用都会消耗一点栈空间，直到最后栈爆掉了。</p>
<p>Writing loops in coroutines built this way makes it very easy to write functions that perform unbounded recursion without looking like they are doing any recursion.</p>
<p>So, what would the solution look like under the original Coroutines TS design?</p>
<h2 id="The-Coroutines-TS-solution"><a href="#The-Coroutines-TS-solution" class="headerlink" title="The Coroutines TS solution"></a>The Coroutines TS solution</h2><p>TS 的解决方案是使用返回 bool 的版本的 await_suspend，根据的原理是<br>In the Coroutines TS there is also a version of await_suspend() that returns bool - if it returns true then the coroutine is suspended and execution returns to the caller of resume(), otherwise if it returns false then the coroutine is immediately resumed, but this time without consuming any additional stack-space.</p>
<p>具体来说，做出下面的修改：</p>
<ol>
<li>Inside the <code>task::awaiter::await_suspend()</code> method you can start executing the coroutine by calling <code>.resume()</code>. Then when the call to <code>.resume()</code> returns, check whether the coroutine has run to completion or not. If it has run to completion then we can return false, which indicates the awaiting coroutine should immediately resume, or we can return true, indicating that execution should return to the caller of <code>std::coroutine_handle::resume()</code>.</li>
<li>Inside <code>task::promise_type::final_awaiter::await_suspend()</code>, which is run when the coroutine runs to completion, we need to check whether the awaiting coroutine has (or will) return true from <code>task::awaiter::await_suspend()</code> and if so then resume it by calling .resume(). Otherwise, we need to avoid resuming the coroutine and notify task::awaiter::await_suspend() that it needs to return false.</li>
</ol>
<p>从下面的代码来看，<code>awaiter::await_suspend</code> 和 <code>final_awaiter::await_suspend</code> 中都会尝试设置 <code>promise.ready </code>为 true。但是：</p>
<ol>
<li>在 <code>awaiter::await_suspend</code> 中如果发现 promise.ready 原来是 false，说明还没结束，则要返回 true 去挂起，并且返回给 <code>std::coroutine_handle::resume()</code> 的调用方。如果原来是 true，说明执行完了，就返回 false，则可以立即 resume。</li>
<li>在 <code>final_awaiter::await_suspend</code> 中如果发现 promise.ready 原来是 true，说明【Q】</li>
</ol>
<blockquote>
<p>There is an added complication, however, in that it’s possible for a coroutine to start executing on the current thread then suspend and later resume and run to completion on a different thread before the call to .resume() returns. Thus, we need to be able to resolve the potential race between part 1 and part 2 above happening concurrently.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:promise_type &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  promise_type&amp; promise = coro_.promise();</span><br><span class="line">  promise.continuation = continuation;</span><br><span class="line">  coro_.resume();</span><br><span class="line">  <span class="keyword">return</span> !promise.ready.exchange(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  promise_type&amp; promise = h.promise();</span><br><span class="line">  <span class="keyword">if</span> (promise.ready.exchange(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel)) &#123;</span><br><span class="line">    <span class="comment">// The coroutine did not complete synchronously, resume it here.</span></span><br><span class="line">    promise.continuation.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的代码在 <a href="https://godbolt.org/z/7fm8Za%E3%80%82" target="_blank" rel="noopener">https://godbolt.org/z/7fm8Za。</a></p>
<h2 id="The-problems"><a href="#The-problems" class="headerlink" title="The problems"></a>The problems</h2><p>上面的方案依然存在问题：</p>
<ol>
<li>依赖原子操作<br> 第一次是在调用者在 suspend awaiting coroutine 的时候。<br> 第二次是在被调用者即将完成执行的时候。</li>
<li>引入额外的分支操作。</li>
</ol>
<p>最后一个最严重的问题是，被挂起的 coroutine 在被 resume 后，被哪个线程执行是不确定的。比如考虑下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cppcoro::static_thread_pool tp;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo1 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// Suspend coroutine and reschedule onto thread-pool thread.</span></span><br><span class="line">  co_await tp.schedule();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo2 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar1 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="function">co_await <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar2"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原始的实现中，可能的输出如下。这是因为我们保证在 the code that runs after <code>co_await foo()</code> would run inline on the same thread that foo() completed on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar1 1234</span><br><span class="line">foo1 1234</span><br><span class="line">foo2 3456</span><br><span class="line">bar2 3456</span><br></pre></td></tr></table></figure>

<p>但是因为使用了原子变量，就可能 foo 的 completion 和 bar 的 suspension 之间有 race（我理解就是上面的两个 await_suspend 会竞争地设置 promise.ready 吧）。那么在一些情况下，<code>co_await foo()</code> might run on the original thread that bar() started executing on. 如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar1 1234</span><br><span class="line">foo1 1234</span><br><span class="line">foo2 3456</span><br><span class="line">bar2 1234</span><br></pre></td></tr></table></figure>

<p>这对一些场景下是存在问题的。比如 <code>via</code> 这个函数可以指定一个 Scheduler 去运行某个 Awaitable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable, <span class="keyword">typename</span> Scheduler&gt;</span><br><span class="line">task&lt;<span class="keyword">await_result_t</span>&lt;Awaitable&gt;&gt; via(Awaitable a, Scheduler s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = co_await <span class="built_in">std</span>::move(a);</span><br><span class="line">  co_await s.schedule();</span><br><span class="line">  co_return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;T&gt; get_value();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">task&lt;<span class="keyword">void</span>&gt; consumer(static_thread_pool::scheduler s)</span><br><span class="line">&#123;</span><br><span class="line">  T result = co_await via(get_value(), s);</span><br><span class="line">  consume(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但像现在这样的话，<code>consume()</code> 可能在 s 上执行，但也有可能在 <code>consumer()</code> coroutine 开始时执行的线程上被执行，无论是它是什么。</p>
<h2 id="Enter-“symmetric-transfer”"><a href="#Enter-“symmetric-transfer”" class="headerlink" title="Enter “symmetric transfer”"></a>Enter “symmetric transfer”</h2><p>This paper proposed two key changes:</p>
<ol>
<li>Allow returning a <code>std::coroutine_handle&lt;T&gt;</code> from await_suspend() as a way of indicating that execution should be symmetrically transferred to the coroutine identified by the returned handle.</li>
<li>Add a std::experimental::noop_coroutine() function that returns a special std::coroutine_handle that can be returned from await_suspend() to suspend the current coroutine and return from the call to .resume() instead of transferring execution to another coroutine.</li>
</ol>
<p>首先，什么是 symmetric transfer？简单来说，像函数调用然后返回那样的就是 asymmetric transfer，因为有明确的调用者和被调用者。具体到 coroutine 场景中，当协程 A 中调用 <code>.resume()</code> 方法去 resume 一个 coroutine 的时候，尽管 resumed coroutine 正在被执行，但调用者 A 还在 stack 上。当这个 coroutine 后面挂起，并调用 <code>await_suspend</code> 返回 void（无条件 suspend）或者 true（条件 suspend），那么对 <code>.resume()</code> 的调用就返回了。</p>
<p>每次通过 <code>.resume()</code> 方法去 resume 一个 coroutine 的时候，都会创建一个新的 frame。可以看出，这类似于协程版本的尾递归。而当循环中出现 co_await 的时候，很容易造成栈溢出。</p>
<p>通过 symmetric transfer，就只是 suspend 某个 coroutine，resume 另一个 coroutine。这两个 coroutine 之间没有任何的调用者或者被调用者的关系。当一个 coroutine 被 suspend 后，它可以将 execution 给到任意的被 suspend 的coroutine，甚至包括自己。并且在自己被 suspend 之后，也不需要把 execution 还给之前的 coroutine。</p>
<p>简单来说，下面的代码无论循环多少次，都不会爆栈。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Task <span class="title">leaf</span><span class="params">()</span> </span>&#123; co_return; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Task <span class="title">outer</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="function">co_await <span class="title">leaf</span><span class="params">()</span></span>;   <span class="comment">// 每次都被优化成跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s look at what the compiler lowers a co_await expression to when the awaiter makes use of symmetric-transfer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) awaitable =</span><br><span class="line">      get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&amp;&amp;&gt;(value));</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) awaiter =</span><br><span class="line">      get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.await_ready())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;suspend-coroutine&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> h = awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">    h.resume();</span><br><span class="line">    <span class="comment">//&lt;return-to-caller-or-resumer&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//&lt;resume-point&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点关注下面的核心区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> h = awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">h.resume();</span><br><span class="line"><span class="comment">//&lt;return-to-caller-or-resumer&gt;</span></span><br></pre></td></tr></table></figure>

<p>Once the coroutine state-machine is lowered (a topic for another post), the <code>&lt;return-to-caller-or-resumer&gt;</code> part basically becomes a return; statement which causes the call to <code>.resume()</code> that last resumed the coroutine to return to its caller.</p>
<p>This means that we have the situation where we have a call to another function with the same signature, <code>std::coroutine_handle::resume()</code>, followed by a return; from the current function which is itself the body of a <code>std::coroutine_handle::resume()</code> call.</p>
<p>一些编译器在开启优化的情况下，可以将函数结尾对另一个函数的调用(calls to other functions the tail-position)，转换为 tail-calls。</p>
<p>It just so happens that this kind of tail-call optimisation is exactly the kind of thing we want to be able to do to avoid the stack-overflow problem we were encountering before. But instead of being at the mercy of the optimiser as to whether or not the tail-call transformation is perfromed, we want to be able to guarantee that the tail-call transformation occurs, even when optimisations are not enabled.</p>
<p>But first let’s dig into what we mean by tail-calls.</p>
<h2 id="Tail-calls"><a href="#Tail-calls" class="headerlink" title="Tail-calls"></a>Tail-calls</h2><p>Tail-call 指的是当前的 stack frame 被在调用前就被弹出了，然后当前函数的返回地址变为了被调用者的返回地址。比如，被调用者会直接返回给调用者的调用者。</p>
<p>在 X86 架构上，编译器会首先弹出当前的栈帧，然后用一个 jmp 指令去跳转到被调用的函数的 entry-point。而不是使用一个 call 指令，然后在返回后再弹出当前 stack-frame。</p>
<p>This optimisation is generally only possible to do in limited circumstances, however. In particular, it requires that:</p>
<ol>
<li>the calling convention supports tail-calls and is the same for the caller and callee;</li>
<li>the return-type is the same;</li>
<li>there are no non-trivial destructors that need to be run after the call before returning to the caller; and</li>
<li>the call is not inside a try/catch block.</li>
</ol>
<p>The shape of the symmetric-transfer form of co_await has actually been designed specifically to allow coroutines to satisfy all of these requirements. Let’s look at them individually.</p>
<ol>
<li><p>Calling convention<br> 当编译器 lowers 一个 coroutine 到机器码的时候，它实际上将 coroutine 分为了两部分。第一部分是 ramp，它会分配并初始化 coroutine 帧。第二部分是 body，它包含了从用户自定义的 coroutine body 生成的状态机。<br> The function signature of the coroutine (and thus any user-specified calling-convention) affects only the ramp part, 而 body 部分在编译器的控制之下，并且从来都不会被任何 user code 调用，它只会被 ramp function 和 by <code>std::coroutine_handle::resume()</code> 调用。<br> Body 部分的 calling-convention 并不对用户可见，并且是完全取决于编译器的，所以编译器可以选择一个恰当的 calling convention，and thus it can choose an appropriate calling convention that supports tail-calls and that is used by all coroutine bodies.</p>
</li>
<li><p>Return type is the same<br> “调用方” coroutine 和“被调用方” coroutine 的 <code>.resume()</code> 方法的返回值都是 void。</p>
</li>
<li><p>No non-trivial destructors<br> 在执行 tail-call 时，需要能够在调用目标函数之前就释放当前的 stack frame。而这需要所有在栈上分配的对象的生命周期都在调用前完成。<br> Normally, this would be problematic as soon as there are any objects with non-trivial destructors in-scope as the lifetime of those objects would not yet have ended and those objects would have been allocated on the stack.<br> 但是，当一个 coroutine 被 suspend 之后，它实际上会将需要续命的对象放到 coroutine frame 里面，而不是直接分配在 stack 上。<br> 对于真正的 local variable，也就是那些 lifetime 并不会跨越 suspend-point 的 variable，它们是会被分配在栈上的。但是它们的 lifetime 在 coroutine suspend 之前就已经结束了，并且对应的析构函数也已经被调用了。<br> 所以不会存在有 stack-allocated objects，它们的 non-trivial destructor 需要在 tail-call 返回之后被执行。</p>
</li>
<li><p>Call not inside a try/catch block<br> 这里比较 tricky 的一点是每个 coroutine 都会有一个隐式的 try/catch block，来包裹其中的用户自定义的部分。<br> 类似下面这，F 就是用户自定义的部分。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  promise_type promise;</span><br><span class="line">  co_await promise.initial_suspend();</span><br><span class="line">  <span class="keyword">try</span> &#123; F; &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123; promise.unhandled_exception(); &#125;</span><br><span class="line">final_suspend:</span><br><span class="line">  co_await promise.final_suspend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 所以，每个用户自定义的 co_await 表达式（除了 initial_suspend 和 final_suspend 的）会被 try catch 包裹。<br> However, implementations work around this by actually executing the call to .resume() outside of the context of the try-block.</p>
</li>
</ol>
<p>So we see that coroutines performing a symmetric-transfer generally satisfy all of the requirements for being able to perform a tail-call. The compiler guarantees that this will always be a tail-call, regardless of whether optimisations are enabled or not.</p>
<p>This means that by using the std::coroutine_handle-returning flavour of await_suspend() we can suspend the current coroutine and transfer execution to another coroutine without consuming extra stack-space.</p>
<p>This allows us to write coroutines that mutually and recursively resume each other to an arbitrary depth without fear of overflowing the stack.</p>
<p>This is exactly what we need to fix our task implementation.</p>
<h2 id="task-revisited"><a href="#task-revisited" class="headerlink" title="task revisited"></a>task revisited</h2><p>So with the new “symmetric transfer” capability under our belt let’s go back and fix our task type implementation.</p>
<p>To do this we need to make changes to the two await_suspend() methods in our implementation:</p>
<ol>
<li>First so that when we await the task that we perform a symmetric-transfer to resume the task’s coroutine.</li>
<li>Second so that when the task’s coroutine completes that it performs a symmetric transfer to resume the awaiting coroutine.</li>
</ol>
<p>To address the await direction we need to change the task::awaiter method from this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">  <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">  coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then we resume the task's coroutine, which is currently suspended</span></span><br><span class="line">  <span class="comment">// at the initial-suspend-point (ie. at the open curly brace).</span></span><br><span class="line">  coro_.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::coroutine_handle&lt;&gt; task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">  <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">  coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then we tail-resume the task's coroutine, which is currently suspended</span></span><br><span class="line">  <span class="comment">// at the initial-suspend-point (ie. at the open curly brace), by returning</span></span><br><span class="line">  <span class="comment">// its handle from await_suspend().</span></span><br><span class="line">  <span class="keyword">return</span> coro_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And to address the return-path we need to update the task::promise_type::final_awaiter method from this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">  <span class="comment">// Lookup its continuation in the promise and resume it.</span></span><br><span class="line">  h.promise().continuation.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::coroutine_handle&lt;&gt; task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">  <span class="comment">// Lookup its continuation in the promise and resume it symmetrically.</span></span><br><span class="line">  <span class="keyword">return</span> h.promise().continuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And now we have a task implementation that doesn’t suffer from the stack-overflow problem that the void-returning await_suspend flavour had and that doesn’t have the non-deterministic resumption context problem of the bool-returning await_suspend flavour had.</p>
<h2 id="Visualising-the-stack"><a href="#Visualising-the-stack" class="headerlink" title="Visualising the stack"></a>Visualising the stack</h2><p>这是之前的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">completes_synchronously</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">loop_synchronously</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="function">co_await <span class="title">completes_synchronously</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在 loop_synchronously() 第一次被执行的时候，可能是因为有些其他的 coroutine 去 co_await 了它。这是通过 symmetric transfer 来实现的，所以栈类似下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                Heap</span><br><span class="line">+---------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+---------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume  |                     | | task::promise        | |</span><br><span class="line">+---------------------------+                     | | - continuation --.   | |</span><br><span class="line">|     ...                   |                     | +------------------|---+ |</span><br><span class="line">+---------------------------+                     | ...                |     |</span><br><span class="line">                                                  +--------------------|-----+</span><br><span class="line">                                                                       V</span><br><span class="line">                                                  +--------------------------+</span><br><span class="line">                                                  | awaiting_coroutine frame |</span><br><span class="line">                                                  |                          |</span><br><span class="line">                                                  +--------------------------+</span><br></pre></td></tr></table></figure>

<p>然后，执行 <code>co_await completes_synchronously()</code> 的时候，又会触发一次 symmetric transfer 到 completes_synchronously。</p>
<p>It does this by:</p>
<ol>
<li>调用 <code>task::operator co_await()</code>，获得一个 task::awaiter 对象</li>
<li>suspend，然后调用 <code>task::awaiter::await_suspend()</code>。它的 symmetric transfer 的版本会返回 <code>coroutine_handle</code> of the <code>completes_synchronously</code> coroutine.</li>
<li>执行一次 tail-call 或者说 jump 去到 <code>completes_synchronously</code> coroutine。这会弹出 <code>loop_synchronously</code> 的 frame，然后再 activate <code>completes_synchronously</code> 的 frame.</li>
</ol>
<p>If we now look at the stack just after <code>completes_synchronously</code> is resumed it will now look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">              Stack                                          Heap</span><br><span class="line">                                            .-&gt; +--------------------------+ &lt;-.</span><br><span class="line">                                            |   | completes_synchronously  |   |</span><br><span class="line">                                            |   | frame                    |   |</span><br><span class="line">                                            |   | +----------------------+ |   |</span><br><span class="line">                                            |   | | task::promise        | |   |</span><br><span class="line">                                            |   | | - continuation --.   | |   |</span><br><span class="line">                                            |   | +------------------|---+ |   |</span><br><span class="line">                                            `-, +--------------------|-----+   |</span><br><span class="line">                                              |                      V         |</span><br><span class="line">+-------------------------------+ &lt;-- top of  | +--------------------------+   |</span><br><span class="line">| completes_synchronously$resume|     stack   | | loop_synchronously frame |   |</span><br><span class="line">+-------------------------------+ active -----&apos; | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume      | coroutine     | | task::promise        | |   |</span><br><span class="line">+-------------------------------+               | | - continuation --.   | |   |</span><br><span class="line">|     ...                       |               | +------------------|---+ |   |</span><br><span class="line">+-------------------------------+               | task temporary     |     |   |</span><br><span class="line">                                                | - coro_       -----|---------`</span><br><span class="line">                                                +--------------------|-----+</span><br><span class="line">                                                                     V</span><br><span class="line">                                                +--------------------------+</span><br><span class="line">                                                | awaiting_coroutine frame |</span><br><span class="line">                                                |                          |</span><br><span class="line">                                                +--------------------------+</span><br></pre></td></tr></table></figure>

<p>注意，stack-frame 的数量没有变多。</p>
<p>在 completes_synchronously 完成之后，当遇到右花括号的时候，会执行 <code>co_await promise.final_suspend()</code>。</p>
<p>这会导致 coroutine 被挂起，并且调用 <code>final_awaiter::await_suspend()</code>，从而返回 continuation 的 std::coroutine_handle，实际上就指向的 loop_synchronously。这之后会做一个 symmetric transfer/tail-call 去 resume loop_synchronously。</p>
<p>If we look at the stack just after loop_synchronously is resumed then it will look something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">                                                   +--------------------------+ &lt;-.</span><br><span class="line">                                                   | completes_synchronously  |   |</span><br><span class="line">                                                   | frame                    |   |</span><br><span class="line">                                                   | +----------------------+ |   |</span><br><span class="line">                                                   | | task::promise        | |   |</span><br><span class="line">                                                   | | - continuation --.   | |   |</span><br><span class="line">                                                   | +------------------|---+ |   |</span><br><span class="line">                                                   +--------------------|-----+   |</span><br><span class="line">                                                                        V         |</span><br><span class="line">+----------------------------+  &lt;-- top of stack   +--------------------------+   |</span><br><span class="line">| loop_synchronously$resume  | active coroutine -&gt; | loop_synchronously frame |   |</span><br><span class="line">+----------------------------+                     | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume() |                     | | task::promise        | |   |</span><br><span class="line">+----------------------------+                     | | - continuation --.   | |   |</span><br><span class="line">|     ...                    |                     | +------------------|---+ |   |</span><br><span class="line">+----------------------------+                     | task temporary     |     |   |</span><br><span class="line">                                                   | - coro_       -----|---------`</span><br><span class="line">                                                   +--------------------|-----+</span><br><span class="line">                                                                        V</span><br><span class="line">                                                   +--------------------------+</span><br><span class="line">                                                   | awaiting_coroutine frame |</span><br><span class="line">                                                   |                          |</span><br><span class="line">                                                   +--------------------------+</span><br></pre></td></tr></table></figure>

<p>loop_synchronously 在 resume 之后要做的第一件事，是调用临时的 task 对象的析构函数。这会销毁 coroutine-frame，释放它的内存，并产生下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+---------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+---------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume  |                     | | task::promise        | |</span><br><span class="line">+---------------------------+                     | | - continuation --.   | |</span><br><span class="line">|     ...                   |                     | +------------------|---+ |</span><br><span class="line">+---------------------------+                     | ...                |     |</span><br><span class="line">                                                  +--------------------|-----+</span><br><span class="line">                                                                       V</span><br><span class="line">                                                  +--------------------------+</span><br><span class="line">                                                  | awaiting_coroutine frame |</span><br><span class="line">                                                  |                          |</span><br><span class="line">                                                  +--------------------------+</span><br></pre></td></tr></table></figure>

<p>We are now back to executing the <code>loop_synchronously</code> coroutine and we now have the same number of stack-frames and coroutine-frames as we started, and will do so each time we go around the loop.</p>
<p>Thus we can perform as many iterations of the loop as we want and will only use a constant amount of storage space.</p>
<p>For a full example of the symmetric-transfer version of the task type see the following Compiler Explorer link: <a href="https://godbolt.org/z/9baieF" target="_blank" rel="noopener">https://godbolt.org/z/9baieF</a>.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/04/07/rust-borrow-checker/" rel="next" title="Rust 的 Borrow Checker">
                <i class="fa fa-chevron-left"></i> Rust 的 Borrow Checker
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/05/30/C++-allocator/" rel="prev" title="C++ 的 allocator 机制">
                C++ 的 allocator 机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">258</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">153</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Coroutine-Theory"><span class="nav-number">1.</span> <span class="nav-text">Coroutine Theory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-operator-co-await"><span class="nav-number">2.</span> <span class="nav-text">Understanding operator co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Awaiters-and-Awaitables-Explaining-operator-co-await"><span class="nav-number">2.1.</span> <span class="nav-text">Awaiters and Awaitables: Explaining operator co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Awaitable"><span class="nav-number">2.1.1.</span> <span class="nav-text">Awaitable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Awaiter"><span class="nav-number">2.1.2.</span> <span class="nav-text">Awaiter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-Awaiter"><span class="nav-number">2.2.</span> <span class="nav-text">获取 Awaiter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Awaiting-the-Awaiter"><span class="nav-number">2.3.</span> <span class="nav-text">Awaiting the Awaiter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关于-await-suspend"><span class="nav-number">2.3.1.</span> <span class="nav-text">关于 await_suspend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于整体流程"><span class="nav-number">2.3.2.</span> <span class="nav-text">关于整体流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine-Handles"><span class="nav-number">2.4.</span> <span class="nav-text">Coroutine Handles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronisation-free-async-code"><span class="nav-number">2.5.</span> <span class="nav-text">Synchronisation-free async code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparison-to-Stackful-Coroutines"><span class="nav-number">2.6.</span> <span class="nav-text">Comparison to Stackful Coroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Avoiding-memory-allocations"><span class="nav-number">2.7.</span> <span class="nav-text">Avoiding memory allocations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#An-example-Implementing-a-simple-thread-synchronisation-primitive"><span class="nav-number">2.8.</span> <span class="nav-text">An example: Implementing a simple thread-synchronisation primitive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filling-out-the-rest-of-the-event-class"><span class="nav-number">2.9.</span> <span class="nav-text">Filling out the rest of the event class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-the-promise-type"><span class="nav-number">3.</span> <span class="nav-text">Understanding the promise type</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine-Concepts"><span class="nav-number">3.1.</span> <span class="nav-text">Coroutine Concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-objects"><span class="nav-number">3.2.</span> <span class="nav-text">Promise objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Allocating-a-coroutine-frame"><span class="nav-number">3.3.</span> <span class="nav-text">Allocating a coroutine frame</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Customising-coroutine-frame-memory-allocation"><span class="nav-number">3.3.1.</span> <span class="nav-text">Customising coroutine frame memory allocation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copying-parameters-to-the-coroutine-frame"><span class="nav-number">3.4.</span> <span class="nav-text">Copying parameters to the coroutine frame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructing-the-promise-object"><span class="nav-number">3.5.</span> <span class="nav-text">Constructing the promise object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Obtaining-the-return-object"><span class="nav-number">3.6.</span> <span class="nav-text">Obtaining the return object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-initial-suspend-point"><span class="nav-number">3.7.</span> <span class="nav-text">The initial-suspend point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Returning-to-the-caller"><span class="nav-number">3.8.</span> <span class="nav-text">Returning to the caller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Returning-from-the-coroutine-using-co-return"><span class="nav-number">3.9.</span> <span class="nav-text">Returning from the coroutine using co_return</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-exceptions-that-propagate-out-of-the-coroutine-body"><span class="nav-number">3.10.</span> <span class="nav-text">Handling exceptions that propagate out of the coroutine body</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-final-suspend-point"><span class="nav-number">3.11.</span> <span class="nav-text">The final-suspend point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-the-compiler-chooses-the-promise-type"><span class="nav-number">3.12.</span> <span class="nav-text">How the compiler chooses the promise type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Identifying-a-specific-coroutine-activation-frame"><span class="nav-number">3.13.</span> <span class="nav-text">Identifying a specific coroutine activation frame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Customising-the-behaviour-of-co-await"><span class="nav-number">3.14.</span> <span class="nav-text">Customising the behaviour of co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原因1"><span class="nav-number">3.14.1.</span> <span class="nav-text">原因1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原因2"><span class="nav-number">3.14.2.</span> <span class="nav-text">原因2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原因3"><span class="nav-number">3.14.3.</span> <span class="nav-text">原因3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Customising-the-behaviour-of-co-yield"><span class="nav-number">3.15.</span> <span class="nav-text">Customising the behaviour of co_yield</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-Symmetric-Transfer"><span class="nav-number">4.</span> <span class="nav-text">Understanding Symmetric Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#First-some-background-on-how-a-task-coroutine-works"><span class="nav-number">4.1.</span> <span class="nav-text">First some background on how a task coroutine works</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Outline-of-a-task-implementation"><span class="nav-number">4.2.</span> <span class="nav-text">Outline of a task implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-task-promise-type"><span class="nav-number">4.3.</span> <span class="nav-text">Implementing task::promise_type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-task-operator-co-await"><span class="nav-number">4.4.</span> <span class="nav-text">Implementing task::operator co_await()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-stack-overflow-problem"><span class="nav-number">4.5.</span> <span class="nav-text">The stack-overflow problem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Coroutines-TS-solution"><span class="nav-number">4.6.</span> <span class="nav-text">The Coroutines TS solution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-problems"><span class="nav-number">4.7.</span> <span class="nav-text">The problems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enter-“symmetric-transfer”"><span class="nav-number">4.8.</span> <span class="nav-text">Enter “symmetric transfer”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tail-calls"><span class="nav-number">4.9.</span> <span class="nav-text">Tail-calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-revisited"><span class="nav-number">4.10.</span> <span class="nav-text">task revisited</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Visualising-the-stack"><span class="nav-number">4.11.</span> <span class="nav-text">Visualising the stack</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2024/05/26/C++-coroutine/';
          this.page.identifier = '2024/05/26/C++-coroutine/';
          this.page.title = 'C++ Coroutine 介绍的翻译';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
