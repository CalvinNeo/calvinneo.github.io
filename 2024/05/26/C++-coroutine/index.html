<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="翻译 lewissbaker 的三篇文章。">
<meta name="keywords" content="C++">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Coroutine 介绍的翻译">
<meta property="og:url" content="http://www.calvinneo.com/2024/05/26/C++-coroutine/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="翻译 lewissbaker 的三篇文章。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2024-12-09T16:47:29.816Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ Coroutine 介绍的翻译">
<meta name="twitter:description" content="翻译 lewissbaker 的三篇文章。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2024/05/26/C++-coroutine/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>C++ Coroutine 介绍的翻译 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2024/05/26/C++-coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                C++ Coroutine 介绍的翻译
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-05-26T15:46:32+08:00">
                2024-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>翻译 <a href="https://lewissbaker.github.io/" target="_blank" rel="noopener">lewissbaker</a> 的三篇文章。</p>
<a id="more"></a>

<h1 id="Coroutine-Theory"><a href="#Coroutine-Theory" class="headerlink" title="Coroutine Theory"></a>Coroutine Theory</h1><p>暂略</p>
<h1 id="Understanding-operator-co-await"><a href="#Understanding-operator-co-await" class="headerlink" title="Understanding operator co_await"></a>Understanding operator co_await</h1><p><a href="https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await" target="_blank" rel="noopener">https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await</a></p>
<p>有两个接口需要定义，Promise 和 Awaiter。</p>
<p>Promist 接口定义了 coroutine 自己的行为，例如 coroutine 被调用的时候应该做什么，应该返回什么，并且定义 co_await 或者 co_yield 在 coroutine 中的行为。</p>
<p>Awaitable 接口定义了 co_await 的语义。当我们 co_await 一个对象时，这个 co_await 会被转化为一系列调用，负责挂起当前的 coroutine，执行一些帮助它后续被重新调度起来的命令，以及一些在 resume 之后生成 co_await 返回值的命令。</p>
<h2 id="Awaiters-and-Awaitables-Explaining-operator-co-await"><a href="#Awaiters-and-Awaitables-Explaining-operator-co-await" class="headerlink" title="Awaiters and Awaitables: Explaining operator co_await"></a>Awaiters and Awaitables: Explaining operator co_await</h2><h3 id="Awaitable"><a href="#Awaitable" class="headerlink" title="Awaitable"></a>Awaitable</h3><p>如果一个类型支持 <code>co_await &lt;expr&gt;</code>，它就是一个 Awaitable 类型。</p>
<p>Promise 类型可以通过 await_transform 方法去修改 co_await 的 expr。下面将没有实现 await_transform 的类型称为 Normally Awaitable。将实现了 await_transform 的称为 Contextually Awaitable，此时这个类型只支持在一些特定类型的 coroutine 中被调用。</p>
<h3 id="Awaiter"><a href="#Awaiter" class="headerlink" title="Awaiter"></a>Awaiter</h3><p>一个 Awaiter 类型需要实现三个方法：await_ready, await_suspend 和 await_resume，它们加在一起组成了 co_await。</p>
<p>一个类型可以既是 Awaiter 又是 Awaitable。</p>
<h2 id="获取-Awaiter"><a href="#获取-Awaiter" class="headerlink" title="获取 Awaiter"></a>获取 Awaiter</h2><p>假设这个 awaiting coroutine 的 promise 对象的类型是 P，并且这个 <code>promise</code> 是对当前 coroutine 中的 P 实例的左值引用。</p>
<p>如果 P 有一个 await_transform 方法，那么 <code>expr</code> 就会被首先传给 <code>promise.await_transform(&lt;expr&gt;)</code>，以获得对应的 Awaitable 对象。否则，<code>expr</code> 的结果就会直接被作为 Awaitable 对象。不妨令为 <code>awaitable</code>。</p>
<p>Then, if the Awaitable object, awaitable, has an applicable operator co_await() overload then this is called to obtain the Awaiter object. Otherwise the object, awaitable, is used as the awaiter object.<br>然后，如果这个 Awaitable 对象 <code>awaitable</code> 有一个 <code>operator co_await()</code>，那么就可以通过调用它来获得一个 Awaiter 对象。否则就会直接使用 awaitable 作为 Awaiter 对象。</p>
<p>上面说的内容可以通过下面的代码来理解。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> P, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaitable(P&amp; promise, T&amp;&amp; expr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_any_await_transform_member_v&lt;P&gt;)</span></span></span><br><span class="line">    return promise.await_transform(static_cast&lt;T&amp;&amp;&gt;(expr));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(expr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) get_awaiter(Awaitable&amp;&amp; awaitable)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(has_member_operator_co_await_v&lt;Awaitable&gt;)</span></span></span><br><span class="line">    return static_cast&lt;Awaitable&amp;&amp;&gt;(awaitable).operator co_await();</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (has_non_member_operator_co_await_v&lt;Awaitable&amp;&amp;&gt;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">operator</span> co_await(<span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;Awaitable&amp;&amp;&gt;(awaitable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】为什么要区分 Awaiter 和 Awaitable 呢？</p>
<h2 id="Awaiting-the-Awaiter"><a href="#Awaiting-the-Awaiter" class="headerlink" title="Awaiting the Awaiter"></a>Awaiting the Awaiter</h2><p><code>co_await &lt;expr&gt;</code> 这个调用可以被转换成如下的形式。</p>
<p>注意，下面说的 caller 我理解就是 coroutine 的 caller。而 resumer 指的是 coroutine 在被重新调度执行后的“caller”。</p>
<p>await_suspend 有两个版本：</p>
<ol>
<li>返回 void 的版本<br> 在 await_suspend 调用返回后，会无条件将执行权转移给 caller 或者 resumer。</li>
<li>返回 bool 的版本<br> 允许有条件地立即 resume 这个 coroutine，而不是将执行权转移给 caller 或者 resumer。<br> 一般来说，如果这个 awaiter 需要执行的异步操作在一些情况下可能同步地完成，那么就可以在 await_suspend 中返回 false，让 coroutine 立即 resume 从而执行后面的逻辑。</li>
</ol>
<p>在 <code>&lt;suspend-coroutine&gt;</code> 处，编译期会生成一些代码，保存当前 coroutine 的状态以便后续恢复。比如存储 <code>&lt;resume-point&gt;</code> 的位置，以及将当前寄存器的状态保存在内存中等。</p>
<p>那么在 <code>&lt;suspend-coroutine&gt;</code> 之后就可以认为这个 coroutine 已经被 suspend 了。所以可以在 await_suspend 调用中首先可以观察到被挂起的 coroutine。此后，它可以被 resume 或者被 destroy。</p>
<p>await_suspend 还需要负责在 coroutine 的异步操作被完成后重新 resume 或者 destroy 掉这个 coroutine。</p>
<p>如果这个 coroutine 的异步操作是被同步完成的，就可以通过 await_ready 调用避免掉 <code>&lt;suspend-coroutine&gt;</code> 挂起 coroutine 的开销。<br>【Q】那么它和返回 bool 的 await_suspend 的区别是啥呢？感觉前者是给你决定要不要，后者是告诉你实际发生了什么。</p>
<p>在 <code>&lt;return-to-caller-or-resumer&gt;</code> 处，执行权会被重新转移给 caller 或者 resumer。此时会 popping the local stack frame but keeping the coroutine frame alive。</p>
<p>【Q】什么是 coroutine frame 呢？从下文可知，coroutine_handle 是一个 coroutine frame 的句柄，用来对它进行操作。可是它本体是啥呢？在<a href="https://lewissbaker.github.io/2017/09/25/coroutine-theory" target="_blank" rel="noopener">前文</a>中有介绍：</p>
<blockquote>
<p>The ‘coroutine frame’ holds part of the coroutine’s activation frame that persists while the coroutine is suspended and the ‘stack frame’ part only exists while the coroutine is executing and is freed when the coroutine suspends and transfers execution back to the caller/resumer.</p>
</blockquote>
<p>如果被挂起的 coroutine 最终是被 resume 的话，会在 <code>&lt;resume-point&gt;</code> 点被继续执行。</p>
<p>await_resume 调用的返回值会成为 co_await 的返回值。注意 await_resume 同样可能抛出异常，此时这个异常会被传播到 co_await 之外。</p>
<p>Note that if an exception propagates out of the await_suspend() call then the coroutine is automatically resumed and the exception propagates out of the co_await expression without calling await_resume().</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">co_await (T expr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaitable = get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&gt;(value));</span><br><span class="line">  <span class="keyword">auto</span>&amp;&amp; awaiter = get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.await_ready())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::experimental::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">await_suspend_result_t</span> =</span><br><span class="line">      <span class="keyword">decltype</span>(awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)));</span><br><span class="line"></span><br><span class="line">    &lt;suspend-coroutine&gt;</span><br><span class="line">    <span class="comment">// 此后可以认为该 coroutine 已经被 suspend 了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// await_suspend 会处理诸如 rescheduling 的事情</span></span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_void_v&lt;<span class="keyword">await_suspend_result_t</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">      &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      <span class="comment">// 此后，执行权交还给 caller 或者 resumer</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">static_assert</span>(</span><br><span class="line">         <span class="built_in">std</span>::is_same_v&lt;<span class="keyword">await_suspend_result_t</span>, <span class="keyword">bool</span>&gt;,</span><br><span class="line">         <span class="string">"await_suspend() must return 'void' or 'bool'."</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p)))</span><br><span class="line">      &#123;</span><br><span class="line">        &lt;<span class="keyword">return</span>-to-caller-<span class="keyword">or</span>-resumer&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;resume-point&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Coroutine-Handles"><a href="#Coroutine-Handles" class="headerlink" title="Coroutine Handles"></a>Coroutine Handles</h2><p>在上文中，一个 <code>coroutine_handle&lt;P&gt;</code> 类型的对象会被传给 await_suspend，作为 await_suspend 的参数。这个类型是对 coroutine frame 的一个非 owning 的句柄。可以通过它来 resume 或者 destroy。同时，还可以用它来访问 coroutine 的 promise 对象。</p>
<p>coroutine_handle 有类似下面的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>&lt;void&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span> :</span> coroutine_handle&lt;<span class="keyword">void</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* address)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>resume<br> 当异步动作完成，需要 resume 这个 coroutine 的时候，应该调用 resume 方法。此时会在 <code>&lt;resume-point&gt;</code> 继续执行 coroutine。<br> 对 resume 本身的调用会在 coroutine 下一次碰到 <code>&lt;return-to-caller-or-resumer&gt;</code> 的时候返回。</li>
<li>destroy<br> 会销毁当前的 coroutine feame。<br> 一般来说不需要调用这个方法，除非是库的作者在实现 promise 类型的时候。<br> 一般来说，coroutine frame 会被调用 coroutine 时返回的 RAII 类型所持有。所以需要避免 double-destruction bug。</li>
<li>promise<br> 返回 coroutine 的 promise 对象的引用。<br> 对于大多数 Normally Awaitable 类型，应当使用 <code>coroutine_handle&lt;void&gt;</code> 作为 await_suspend 的参数，而不是 <code>coroutine_handle&lt;Promise&gt;</code>。<br> <code>coroutine_handle&lt;P&gt;::from_promise(P&amp; promise)</code> 这个函数可以由 coroutine promise 对象的引用来<strong>重新构造</strong> coroutine_handle。注意必须要保证 P 和 coroutine frame 使用的 concrete promise type 是一致的。也就是说如果创建 <code>coroutine_handle&lt;Base&gt;</code>，但是实际的 promise type 是 Derived 会导致 UB。</li>
<li>address/from_address<br> 将一个 coroutine handle 和 void* 指针进行互相转化。它的目的主要是和 C 语言的接口交互。<br> 但一般来说，在实现时经常发现还需要打包发送其他上下文，所以一般来说会将 <code>coroutine_handle</code> 放到一个结构中，并返回结构的指针。</li>
</ol>
<h2 id="Synchronisation-free-async-code"><a href="#Synchronisation-free-async-code" class="headerlink" title="Synchronisation-free async code"></a>Synchronisation-free async code</h2><p>co_await 的一个作用是可以在 coroutine 被 suspend 之后，和被 caller/resumer 重新获得执行权之前的这段时间中执行代码。</p>
<p>也就是说，Awaiter 对象会在 coroutine 被 suspend 之后启动一个 async 操作，将 <code>coroutine_handle</code> 传给这个 async 操作，让它能在完成后去 resume 之前的 coroutine。注意这个 coroutine 可能是在另一个线程中被 resume 了。整个过程中并不需要任何的同步开销。</p>
<p>举个例子，一段代码在线程 A 中执行，使用 coroutine 去做一个异步读，那么 Awaiter 可以在 await_suspend 中启动这个异步读，而这个异步读是在线程 B 中被实际处理的。但线程 A 和线程 B 之间是没有任何同步开销的。比如没有通过条件变量或者 channel 进行等待。如下面所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Time     Thread A                           Thread B</span><br><span class="line">  |      --------                           --------</span><br><span class="line">  |      ....                               Call OS - Wait for I/O event</span><br><span class="line">  |      Call await_ready()                    |</span><br><span class="line">  |      &lt;supend-point&gt;                        |</span><br><span class="line">  |      Call await_suspend(handle)            |</span><br><span class="line">  |        Store handle in operation           |</span><br><span class="line">  V        Start AsyncFileRead ---+            V</span><br><span class="line">                                  +-----&gt;   &lt;AsyncFileRead Completion Event&gt;</span><br><span class="line">                                            Load coroutine_handle from operation</span><br><span class="line">                                            Call handle.resume()</span><br><span class="line">                                              &lt;resume-point&gt;</span><br><span class="line">                                              Call to await_resume()</span><br><span class="line">                                              execution continues....</span><br><span class="line">           Call to AsyncFileRead returns</span><br><span class="line">         Call to await_suspend() returns</span><br><span class="line">         &lt;return-to-caller/resumer&gt;</span><br></pre></td></tr></table></figure>

<p>在上面的伪代码中还需要注意：</p>
<ol>
<li>如果异步任务把 <code>coroutine_handle</code> 传给了另一个线程，那么这个线程就可能在 await_suspend 返回之前就 resume 这个 coroutine。这样，就会和 await_suspend 方法剩下来的部分竞争。</li>
<li>当 resume 一个 coroutine 的时候，首先需要调用 await_resume 去获得异步任务的结果。一般与此同时会立即析构掉 Awaiter 对象（可以看看上面的 demo）。因为 Awaiter 对象实际上就是 await_suspend 的 this 指针，所以 coroutine 可能会在 await_suspend 调用之前就 destruct 掉 coroutine 和 promise 对象。</li>
</ol>
<p>因此，在 await_suspend 方法中，一旦 coroutine 可以在另一个线程上并发地 resume，就需要保证不会再去访问 this 或者 coroutine 的 promise() 对象了，因为它们可能都被销毁了。实际上，当 coroutine 已经 scheduled for resumption 的时候，唯一能安全访问的只有 await_suspend 中的本地变量了。</p>
<h2 id="Comparison-to-Stackful-Coroutines"><a href="#Comparison-to-Stackful-Coroutines" class="headerlink" title="Comparison to Stackful Coroutines"></a>Comparison to Stackful Coroutines</h2><p>和诸如 win32 的 fiber 或者 boost::context 这样的有栈协程相比：<br>在很多有栈协程中，suspend 操作通常会伴随着 resume 另一个 coroutine，从而组合成为一个 context-switch 操作。而这个操作会导致没有机会再 suspend 当前 coroutine 之后，以及将执行权转移到另一个 coroutine 之前执行一些逻辑。<br>而这就意味着如果需要实现一个类似的 async-file-read 操作，就需要在 suspend 这个 coroutine 之前就开启这个操作。因此这个操作可能就会在当前 coroutine 被 suspend 之前，就在另一个线程中被执行完了，而当前 coroutine 因此又要被 resume。这就在这两个线程之间引入了 race。而如上所述，C++ 的 coroutine 不需要在线程 A 和线程 B 之间引入同步机制。</p>
<p>There are probably ways around this by using a trampoline context that can start the operation on behalf of the initiating context after the initiating context has been suspended. However this would require extra infrastructure and an extra context-switch to make it work and it’s possible that the overhead this introduces would be greater than the cost of the synchronisation it’s trying to avoid.</p>
<h2 id="Avoiding-memory-allocations"><a href="#Avoiding-memory-allocations" class="headerlink" title="Avoiding memory allocations"></a>Avoiding memory allocations</h2><p>async 操作需要分配一些内存。比如在 win32 io 函数接口中，需要分配一个 OVERLAPPED 结构，这个结构需要在操作完成之后才会被释放。因此这样的结构必须要分配在堆上，并且每个 async 操作都需要 allocate 一次。因此在这里可以使用一个对象池来优化。</p>
<p>但是在 C++ 的 coroutine 中，可以避免堆内存分配，因为 local variable 在 coroutine 被 suspend 的时候会在 coroutine frame 里面，从而肯定是存活的。</p>
<p>将 per-operation state 存放在 Awaiter 对象中，可以白嫖 coroutine frame，从而延续到至少是 co_await expression 的 lifetime。一旦这个 operation 完成，coroutine 就会 resume，然后 Awaiter 对象就会被销毁。</p>
<p>当然，coroutine frame 本身还是会在堆上分配的，但是，一旦它被分配，是可以被用来执行很多个 async 操作的。这就好像是一个 arena memory allocator 一样，编译期可以在编译期计算出 local variable 的大小，然后就可以一次性分配出来了。</p>
<p>【Q】没太明白为啥 coroutine frame 是可以被复用的。我理解应该是指的可以 co_await 很多次。</p>
<h2 id="An-example-Implementing-a-simple-thread-synchronisation-primitive"><a href="#An-example-Implementing-a-simple-thread-synchronisation-primitive" class="headerlink" title="An example: Implementing a simple thread-synchronisation primitive"></a>An example: Implementing a simple thread-synchronisation primitive</h2><p>下面是一个简单的多生产者-多消费者模型。如果 set 已经被调用过了，那么后续的 consumer 就不会 suspend 了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">T value;</span><br><span class="line">async_manual_reset_event event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A single call to produce a value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  value = some_long_running_computation();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Publish the value by setting the event.</span></span><br><span class="line">  event.<span class="built_in">set</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Supports multiple concurrent consumers</span></span><br><span class="line">task&lt;&gt; consumer()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Wait until the event is signalled by call to event.set()</span></span><br><span class="line">  <span class="comment">// in the producer() function.</span></span><br><span class="line">  co_await event;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now it's safe to consume 'value'</span></span><br><span class="line">  <span class="comment">// This is guaranteed to 'happen after' assignment to 'value'</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的设计就是用一个 <code>std::atomic&lt;void*&gt;</code> 指针。它要么指向 this，说明已经 set 了；要么指向一个链表的表头，表示正在 suspend 的链表。</p>
<p>在这里，我们也实现了上面提到的节省内存分配的方案，将链表的 node 分配在 awaiter 对象里面，而 awaiter 对象在 coroutine frame 上面。</p>
<p>总而言之，代码如下所示。它支持 co_await，所以是个 Awaitable 类型。co_await 操作符返回一个 awaiter 也就是后面要实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">async_manual_reset_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  async_manual_reset_event(<span class="keyword">bool</span> initiallySet = <span class="literal">false</span>) <span class="keyword">noexcept</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No copying/moving</span></span><br><span class="line">  async_manual_reset_event(<span class="keyword">const</span> async_manual_reset_event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event(async_manual_reset_event&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> async_manual_reset_event&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  async_manual_reset_event&amp; <span class="keyword">operator</span>=(async_manual_reset_event&amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_set</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">awaiter</span>;</span></span><br><span class="line">  <span class="function">awaiter <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span> <span class="title">awaiter</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// - 'this' =&gt; set state</span></span><br><span class="line">  <span class="comment">// - otherwise =&gt; not set, head of linked list of awaiter*.</span></span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">void</span>*&gt; m_state;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 awaiter 如下所示:</p>
<ol>
<li>首先，它要持有一个 Awaitable 对象的指针，这是因为它要知道自己是要 await 什么东西。</li>
<li>然后，它还要扮演一个在 awaiter 链表里面的一个节点的角色，所以它应该能访问自己后面的那个 awaiter。</li>
<li>然后，它还要存储 coroutine_handle 对象，这样当 await_suspend 被调用后，它能知道如何去 resume coroutine。因为我们没 await_transform 啥的，所以这里 coroutine_handle 对象就是 <code>coroutine_handle&lt;void&gt;</code>。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">async_manual_reset_event</span>:</span>:awaiter</span><br><span class="line">&#123;</span><br><span class="line">  awaiter(<span class="keyword">const</span> async_manual_reset_event&amp; event) <span class="keyword">noexcept</span></span><br><span class="line">  : m_event(event)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; awaitingCoroutine)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> async_manual_reset_event&amp; m_event;</span><br><span class="line">  <span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; m_awaitingCoroutine;</span><br><span class="line">  awaiter* m_next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>await_ready 要做的就是如果已经 set 了，就不再 suspend。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> async_manual_reset_event::awaiter::await_ready() <span class="keyword">const</span> <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> m_event.is_set();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>await_suspend 最为重要：</p>
<ol>
<li>首先，它要保存 coroutine_handle，从而后续可以调用 <code>coroutine_handle.resume()</code> 方法。</li>
<li>然后，就要将 awaiter 放到链表里面<br> 将链表头的指针即 m_state 设置为 this。注意，这里的 this 是 awaiter；而 oldValue 是 async_manual_reset_event，即 Awaitable。<br> 如果添加成功，就返回 true，表示不会立即 resume 这个 coroutine。否则，就返回 false，表示可以立即 resume。这也回答了之前的一个【Q】，也就是 await_suspend 和 await_ready 的返回值到底作用有什么不同。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> async_manual_reset_event::awaiter::await_suspend(</span><br><span class="line">  <span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt; awaitingCoroutine) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Special m_state value that indicates the event is in the 'set' state.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">const</span> setState = &amp;m_event;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remember the handle of the awaiting coroutine.</span></span><br><span class="line">  m_awaitingCoroutine = awaitingCoroutine;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Try to atomically push this awaiter onto the front of the list.</span></span><br><span class="line">  <span class="keyword">void</span>* oldValue = m_event.m_state.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Resume immediately if already in 'set' state.</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue == setState) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update linked list to point at current head.</span></span><br><span class="line">    m_next = <span class="keyword">static_cast</span>&lt;awaiter*&gt;(oldValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, try to swap the old list head, inserting this awaiter</span></span><br><span class="line">    <span class="comment">// as the new list head.</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (!m_event.m_state.compare_exchange_weak(</span><br><span class="line">             oldValue,</span><br><span class="line">             <span class="keyword">this</span>,</span><br><span class="line">             <span class="built_in">std</span>::memory_order_release,</span><br><span class="line">             <span class="built_in">std</span>::memory_order_acquire));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Successfully enqueued. Remain suspended.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】这里 await_resume 起到了什么作用，为啥它是空的？</p>
<h2 id="Filling-out-the-rest-of-the-event-class"><a href="#Filling-out-the-rest-of-the-event-class" class="headerlink" title="Filling out the rest of the event class"></a>Filling out the rest of the event class</h2><p>如果是 set 状态，则改为 nullptr。所以 m_state 有三种情况：</p>
<ol>
<li>nullptr<br> 没有 set，但是也没有 awaiter 在等</li>
<li>oldValue<br> set 了</li>
<li>其他<br> 有 awaiter 在等，并且指向了链表头</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> async_manual_reset_event::reset() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">void</span>* oldValue = <span class="keyword">this</span>;</span><br><span class="line">  m_state.compare_exchange_strong(oldValue, <span class="literal">nullptr</span>, <span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 set 操作。其实有点类似于 CV。实际上的行为就是对所有的 waiter 调用 <code>coroutine_handle.resume()</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> async_manual_reset_event::<span class="built_in">set</span>() <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Needs to be 'release' so that subsequent 'co_await' has</span></span><br><span class="line">  <span class="comment">// visibility of our prior writes.</span></span><br><span class="line">  <span class="comment">// Needs to be 'acquire' so that we have visibility of prior</span></span><br><span class="line">  <span class="comment">// writes by awaiting coroutines.</span></span><br><span class="line">  <span class="keyword">void</span>* oldValue = m_state.exchange(<span class="keyword">this</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">  <span class="keyword">if</span> (oldValue != <span class="keyword">this</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Wasn't already in 'set' state.</span></span><br><span class="line">    <span class="comment">// Treat old value as head of a linked-list of waiters</span></span><br><span class="line">    <span class="comment">// which we have now acquired and need to resume.</span></span><br><span class="line">    <span class="keyword">auto</span>* waiters = <span class="keyword">static_cast</span>&lt;awaiter*&gt;(oldValue);</span><br><span class="line">    <span class="keyword">while</span> (waiters != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Read m_next before resuming the coroutine as resuming</span></span><br><span class="line">      <span class="comment">// the coroutine will likely destroy the awaiter object.</span></span><br><span class="line">      <span class="keyword">auto</span>* next = waiters-&gt;m_next;</span><br><span class="line">      waiters-&gt;m_awaitingCoroutine.resume();</span><br><span class="line">      waiters = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【Q】这里的 awaiter 都是在什么地方被析构的呢？我理解这里的 awaiter 都是 local variable，生命周期等同于 co_await 的 <code>&lt;expr&gt;</code>。可以看到，co_await 返回的就是这个 awaiter。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async_manual_reset_event::awaiter</span><br><span class="line">async_manual_reset_event::<span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> awaiter&#123; *<span class="keyword">this</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://godbolt.org/g/Ad47tH" target="_blank" rel="noopener">https://godbolt.org/g/Ad47tH</a> 是源码</p>
<h1 id="Understanding-the-promise-type"><a href="#Understanding-the-promise-type" class="headerlink" title="Understanding the promise type"></a>Understanding the promise type</h1><p><a href="https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type" target="_blank" rel="noopener">https://lewissbaker.github.io/2018/09/05/understanding-the-promise-type</a></p>
<h2 id="Coroutine-Concepts"><a href="#Coroutine-Concepts" class="headerlink" title="Coroutine Concepts"></a>Coroutine Concepts</h2><p>Promise 接口用来自定义 coroutine 自己的行为，比如它被调用的时候，或者它返回（无论是正常值还是异常）的时候。</p>
<h2 id="Promise-objects"><a href="#Promise-objects" class="headerlink" title="Promise objects"></a>Promise objects</h2><p>字如其名，Promise 确实有类似 <code>std::promise</code> 的作用，但是它的功能更为衍生，实际上应该将它理解为一个 coroutine state controller。</p>
<p>比如，写了一个 coroutine function，编译器会转换成下面的形式，其中 <code>&lt;body-statements&gt;</code> 是函数体。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  co_await promise.initial_suspend();</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    &lt;body-statements&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...)</span><br><span class="line">  &#123;</span><br><span class="line">    promise.unhandled_exception();</span><br><span class="line">  &#125;</span><br><span class="line">FinalSuspend:</span><br><span class="line">  co_await promise.final_suspend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 coroutine 被调用的时候，会：</p>
<ol>
<li>【可选】用 operator new 分配一个 coroutine frame。<br> 【Q】为什么这里是可选的？见下文。</li>
<li>将 parameter 拷贝到 coroutine frame 里面。</li>
<li>调用 P 的构造函数创建 promise 对象。</li>
<li>调用 <code>promise.get_return_object()</code> 方法会得到一个东西，可以在第一次 suspend 的时候返回给 caller。这个东西被保存为 local variable。<br> 我理解这个东西，也就是后面会看到的 <code>task</code> 就是 “Coroutine 本身”。特别地：<ul>
<li><code>task</code> 里面会持有一个 std::coroutine_handle 对象。</li>
<li><code>task</code> 里面会支持 co_await 操作符，也就是说它是一个 Awaitable 对象。</li>
<li>promise 对象的类型就是 <code>task::promise_type</code>。</li>
</ul>
</li>
<li>调用 <code>promise.initial_suspend()</code>，并 <code>co_await</code> 结果。</li>
<li>当 co_await <code>promise.initial_suspend()</code> resume（这里同样可能不挂起直接返回），coroutine 开始执行 <code>&lt;body-statements&gt;</code>。</li>
</ol>
<p>在 co_return 被执行的时候，会：</p>
<ol>
<li>调用 <code>promise.return_void()</code> 或者 <code>promise.return_value(&lt;expr&gt;)</code>。</li>
<li>销毁所有的自动变量。</li>
<li>调用 <code>promise.final_suspend()</code>，并且 co_await 结果。</li>
</ol>
<p>特别地，如果 <code>&lt;body-statements&gt;</code> 抛出异常，则：</p>
<ol>
<li>捕获这个异常，并调用 <code>promise.unhandled_exception()</code>。</li>
<li>调用 <code>promise.final_suspend()</code>，并且 co_await 结果。</li>
</ol>
<p>一旦 execution propagates outside of the coroutine body，那么 coroutine frame 就会被销毁。此时：</p>
<ol>
<li>调用 promise 对象的析构函数。</li>
<li>调用 parameter 的析构函数。</li>
<li>【可选】调用 operator delete 释放内存。</li>
<li>将执行权交还给 resumer 或者 caller。</li>
</ol>
<p>当第一次执行到 <code>&lt;return-to-caller-or-resumer&gt;</code> 的时候，或者 coroutine 没有执行到这个点就完成了，那么这个 coroutine 要么是 suspend 了，要么是 destroy 了。此时这之前通过调用 <code>promise.get_return_object()</code> 得到的 return-object 会被直接返回给 caller。回顾下，这里的 <code>&lt;return-to-caller-or-resumer&gt;</code> 是在 <code>co_await</code> 中，执行完 <code>await_suspend</code> 之后的点。</p>
<h2 id="Allocating-a-coroutine-frame"><a href="#Allocating-a-coroutine-frame" class="headerlink" title="Allocating a coroutine frame"></a>Allocating a coroutine frame</h2><p>First, the compiler generates a call to operator new to allocate memory for the coroutine frame.</p>
<p>If the promise type, P, defines a custom operator new method then that is called, otherwise the global operator new is called.</p>
<p>要点：</p>
<ol>
<li>operator new 分配的大小并不是 sizeof(P)，而是整个 coroutine frame 的大小，这个是由编译器计算的。包含了 parameter，promise 对象，local variables 以及其他的一些用来存储 coroutine state 的结构。我理解之前我们白嫖的也是这一段的空间。</li>
<li>编译期可以省略这个 operator new，而直接在 caller 的 stack-frame 或者 coroutine-frame 中分配，当：<ul>
<li>可以断定 coroutine frame 的生命周期是小于 caller 的。</li>
<li>并且编译期可以在调用的时候就能看到整个 coroutine frame 需要的大小。<br>目前 Coroutine TS 并没有 guarantee 任何的 elision 的情况，所以我们要处理分配 coroutine frame 的时候出现 std::bad_alloc 的情况。这里有一些异常处理相关的问题，一般我们就直接 terminate 掉了。但如果 promise 对象支持静态的 <code>P::get_return_object_on_allocation_failure()</code> 函数，则可以不抛出异常。</li>
</ul>
</li>
</ol>
<h3 id="Customising-coroutine-frame-memory-allocation"><a href="#Customising-coroutine-frame-memory-allocation" class="headerlink" title="Customising coroutine frame memory allocation"></a>Customising coroutine frame memory allocation</h3><p>Your promise type can define an overload of operator new() that will be called instead of global-scope operator new if the compiler needs to allocate memory for a coroutine frame that uses your promise type.</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_promise_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* ptr = my_custom_allocate(size);</span><br><span class="line">    <span class="keyword">if</span> (!ptr) <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    my_custom_free(ptr, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>同样，也可以提供一个 custom allocator。如下所示，可以提供一个重载版本的 <code>P::operator new()</code>，它额外接受诸如 allocator 这样的参数，这样就可以在 new 的时候调用 <code>allocator.allocate()</code> 来分配内存了。</p>
<p>这里有个问题，coroutine frame 中存储的 parameter 在 <code>operator delete</code> 之前就已经被析构了，那如何获得 allocator 呢？所以，为了能在 <code>operator delete</code> 中调用 <code>allocator.deallocate()</code>，我们要将 allocator 存在 <code>allocatorOffset</code> 上面。</p>
<p>简而言之，就是在创建 my_promise_type 之前分配空间的时候，多分配一部分空间，用来存放对应的 allocator。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ALLOCATOR&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_promise_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> sz, <span class="built_in">std</span>::<span class="keyword">allocator_arg_t</span>, ALLOCATOR&amp; allocator, ARGS&amp;... args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Round up sz to next multiple of ALLOCATOR alignment</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> allocatorOffset =</span><br><span class="line">      (sz + <span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>) &amp; ~(<span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call onto allocator to allocate space for coroutine frame.</span></span><br><span class="line">    <span class="keyword">void</span>* ptr = allocator.allocate(allocatorOffset + <span class="keyword">sizeof</span>(ALLOCATOR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Take a copy of the allocator (assuming noexcept copy constructor here)</span></span><br><span class="line">    <span class="keyword">new</span> (((<span class="keyword">char</span>*)ptr) + allocatorOffset) ALLOCATOR(allocator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="built_in">std</span>::<span class="keyword">size_t</span> sz)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> allocatorOffset =</span><br><span class="line">      (sz + <span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>) &amp; ~(<span class="keyword">alignof</span>(ALLOCATOR) - <span class="number">1u</span>);</span><br><span class="line"></span><br><span class="line">    ALLOCATOR&amp; allocator = *<span class="keyword">reinterpret_cast</span>&lt;ALLOCATOR*&gt;(</span><br><span class="line">      ((<span class="keyword">char</span>*)ptr) + allocatorOffset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move allocator to local variable first so it isn't freeing its</span></span><br><span class="line">    <span class="comment">// own memory from underneath itself.</span></span><br><span class="line">    <span class="comment">// Assuming allocator move-constructor is noexcept here.</span></span><br><span class="line">    ALLOCATOR allocatorCopy = <span class="built_in">std</span>::move(allocator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// But don't forget to destruct allocator object in coroutine frame</span></span><br><span class="line">    allocator.~ALLOCATOR();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, free the memory using the allocator.</span></span><br><span class="line">    allocatorCopy.deallocate(ptr, allocatorOffset + <span class="keyword">sizeof</span>(ALLOCATOR));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>To hook up the custom <code>my_promise_type</code> to be used for coroutines that pass <code>std::allocator_arg</code> as the first parameter, you need to specialise the <code>coroutine_traits</code> class (see section on coroutine_traits below for more details).</p>
<p>For example:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ALLOCATOR, <span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_traits</span>&lt;my_return_type, std::allocator_arg_t, ALLOCATOR, ARGS...&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">using</span> promise_type = my_promise_type&lt;ALLOCATOR&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Note that even if you customise the memory allocation strategy for a coroutine, the compiler is still allowed to elide the call to your memory allocator.</p>
<h2 id="Copying-parameters-to-the-coroutine-frame"><a href="#Copying-parameters-to-the-coroutine-frame" class="headerlink" title="Copying parameters to the coroutine frame"></a>Copying parameters to the coroutine frame</h2><p>The coroutine needs to copy any parameters passed to the coroutine function by the original caller into the coroutine frame so that they remain valid after the coroutine is suspended.</p>
<p>复制 parameter 到 coroutine frame 的目的是保证了 coroutine 被 suspend 之后，这些东西都还在。</p>
<ol>
<li>如果是 by value 的复制，那么会调用 move-ctor。</li>
<li>如果是 by reference 的复制，无论是左值还是右值，那么只有引用本身会被复制，指向的对象是不会的。</li>
</ol>
<p>对于只有 trivial destructor 的 parameter，编译器可以 elide 掉 copy，如果这个 parameter 在某个可达的 <code>&lt;return-to-caller-or-resumer&gt;</code> 之后就不再被访问了。</p>
<p>C++ 中用完美转发会比较多，这在 coroutine 中经常会导致 UB。原因就是传入了 reference。</p>
<p>If any of the parameter copy/move constructors throws an exception then any parameters already constructed are destructed, the coroutine frame is freed and the exception propagates back out to the caller.</p>
<h2 id="Constructing-the-promise-object"><a href="#Constructing-the-promise-object" class="headerlink" title="Constructing the promise object"></a>Constructing the promise object</h2><p>先复制 parameter 再构造 promise 的原因是允许 promise 对象可以基于复制后的 parameter 构建。</p>
<p>First, the compiler checks to see if there is an overload of the promise constructor that can accept lvalue references to each of the copied parameters. If the compiler finds such an overload then the compiler generates a call to that constructor overload. If it does not find such an overload then the compiler falls back to generating a call to the promise type’s default constructor.</p>
<p>这个听起来挺神奇的，好像是既支持“默认”的 aggregate initialization，又支持 default initialization。</p>
<blockquote>
<p>Note that the ability for the promise constructor to “peek” at the parameters was a relatively recent change to the Coroutines TS, being adopted in N4723 at the Jacksonville 2018 meeting. See P0914R1 for the proposal. Thus it may not be supported by some older versions of Clang or MSVC.</p>
</blockquote>
<p>If the promise constructor throws an exception then the parameter copies are destructed and the coroutine frame freed during stack unwinding before the exception propagates out to the caller.</p>
<h2 id="Obtaining-the-return-object"><a href="#Obtaining-the-return-object" class="headerlink" title="Obtaining the return object"></a>Obtaining the return object</h2><p>The first thing a coroutine does with the promise object is obtain the return-object by calling promise.get_return_object().</p>
<p>在 coroutine 被建立后，首先是调用 <code>promise.get_return_object()</code> 获取 return-object。return-object 后续会被返回给 coroutine 的 caller。如前文所说，返回的时间点是第一次 suspend，或者 coroutine 完成了。</p>
<p>执行大抵如下。注意，在 “Coroutine Handles” 这一节中介绍了，可以通过 from_promise 从 promise 重新构建出 coroutine_handle。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pretend there's a compiler-generated structure called 'coroutine_frame'</span></span><br><span class="line"><span class="comment">// that holds all of the state needed for the coroutine. It's constructor</span></span><br><span class="line"><span class="comment">// takes a copy of parameters and default-constructs a promise object.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coroutine_frame</span> &#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">some_coroutine</span><span class="params">(P param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* f = <span class="keyword">new</span> coroutine_frame(<span class="built_in">std</span>::forward&lt;P&gt;(param));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> returnObject = f-&gt;promise.get_return_object();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start execution of the coroutine body by resuming it.</span></span><br><span class="line">  <span class="comment">// This call will return when:</span></span><br><span class="line">  <span class="comment">// 1. the coroutine gets to the first suspend-point</span></span><br><span class="line">  <span class="comment">// 2. or when the coroutine runs to completion.</span></span><br><span class="line">  coroutine_handle&lt;<span class="keyword">decltype</span>(f-&gt;promise)&gt;::from_promise(f-&gt;promise).resume();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then the return object is returned to the caller.</span></span><br><span class="line">  <span class="keyword">return</span> returnObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，必须要在执行 coroutine body 之前就获取 return-object。这因为 coroutine frame 以及它持有的 promise 对象可能在 <code>coroutine_handle::resume()</code> 返回前就被销毁掉。也就是说，在 resume() 返回前，程序可能处于 suspend 状态的，我理解后续这个 coroutine 就可能被直接销毁掉了。</p>
<p>销毁未必发生在 caller 的线程上。因此，在开始执行 coroutine body 之后调用 <code>get_return_object()</code> 是不安全的。</p>
<h2 id="The-initial-suspend-point"><a href="#The-initial-suspend-point" class="headerlink" title="The initial-suspend point"></a>The initial-suspend point</h2><p>The next thing the coroutine executes once the coroutine frame has been initialised and the return object has been obtained is execute the statement <code>co_await promise.initial_suspend()</code>;</p>
<p>执行 <code>co_await promise.initial_suspend()</code>，实际上允许 <code>promise_type</code> 也就是之前提到的 P 的作者，可以控制 coroutine 到底是立即执行，还是先 suspend 等调度。这有点类似于 std::async 里面相同参数的意思了。</p>
<p>如果在 initial suspend 点选择 suspend 的话，后续可以被 resume 或者被 destroy。</p>
<p><code>co_await promise.initial_suspend()</code> 的结果被丢弃，所以实现上可以从 <code>await_resume</code> 返回 void。</p>
<p>注意1：<code>initial_suspend()</code> 这个调用并没有被 try-catch 块环绕，也就是说这里发生的异常，更准确说是在它的 <code>&lt;return-to-caller-or-resumer&gt;</code> 之前的异常会在销毁 coroutine frame 和 return-object 之后被直接抛给 caller。</p>
<p>注意2：如果 return-object 中有某个 RAII 语义，能够在它被销毁的时候销毁 coroutine frame，那么就需要保证 <code>co_await promise.initial_suspend()</code> 不会抛出异常，否则会发生 double free 的问题。当然也有提案说要去修改这个行为。</p>
<p>但实际上因为大部分 coroutine 的 <code>initial_suspend()</code> 只会返回都是 noexcept 的 suspend_never 或者 suspend_always，所以这不是个问题。</p>
<h2 id="Returning-to-the-caller"><a href="#Returning-to-the-caller" class="headerlink" title="Returning to the caller"></a>Returning to the caller</h2><p>当 coroutine 执行到第一个 <code>&lt;return-to-caller-or-resumer&gt;</code> 点（如果没有这个点就是执行完成）的时候，从 get_return_object 获取的 return-object 会被返回给 caller。</p>
<p>注意，return-object 的类型不一定是 coroutine function 的 return type。可以进行隐式转换。</p>
<h2 id="Returning-from-the-coroutine-using-co-return"><a href="#Returning-from-the-coroutine-using-co-return" class="headerlink" title="Returning from the coroutine using co_return"></a>Returning from the coroutine using co_return</h2><p>co_return 会被转化为:</p>
<ol>
<li><code>promise.return_void()</code><br><code>co_return &lt;expr&gt; </code></li>
<li><code>promise.return_value(&lt;expr&gt;)</code><br> 如果 expr 的类型是 void，则 <code>&lt;expr&gt;; promise.return_void();</code>。<br> 如果 expr 的类型不是 void，则 <code>promise.return_value(&lt;expr&gt;);</code></li>
</ol>
<p>Note that if execution runs off the end of a coroutine without a <code>co_return</code> statement then this is equivalent to having a <code>co_return</code>; at the end of the function body. In this case, if the <code>promise_type</code> does not have a <code>return_void()</code> method then the behaviour is undefined.</p>
<p>If either the evaluation of <expr> or the call to <code>promise.return_void()</code> or <code>promise.return_value()</code> throws an exception then the exception still propagates to <code>promise.unhandled_exception()</code>.</expr></p>
<h2 id="Handling-exceptions-that-propagate-out-of-the-coroutine-body"><a href="#Handling-exceptions-that-propagate-out-of-the-coroutine-body" class="headerlink" title="Handling exceptions that propagate out of the coroutine body"></a>Handling exceptions that propagate out of the coroutine body</h2><h2 id="The-final-suspend-point"><a href="#The-final-suspend-point" class="headerlink" title="The final-suspend point"></a>The final-suspend point</h2><p>final_suspend 的调用发生在 <code>return_void()</code>、<code>return_value()</code> 和 <code>unhandled_exception()</code> 之后。也发生在所有的 local variable 都被销毁之后。</p>
<p>This allows the coroutine to execute some logic, such as publishing a result, signalling completion or resuming a continuation. It also allows the coroutine to optionally suspend immediately before execution of the coroutine runs to completion and the coroutine frame is destroyed.</p>
<p>在 final_suspend 点 resume 一个 coroutine 是 UB 的，对于这个状态的 coroutine 只可以调用 destroy。</p>
<p>The rationale for this limitation, according to Gor Nishanov, is that this provides several optimisation opportunities for the compiler due to the reduction in the number of suspend states that need to be represented by the coroutine and a potential reduction in the number of branches required.</p>
<p>尽管可以在 final_suspend 处不 suspend，但建议是尽量 suspend。因为这可以强迫你在 coroutine 外面调用 destroy（一般是通过某种 RAII 机制）。这样编译器就能够更容易确定 coroutine frame 的 lifetime 是被 caller 的 lifetime 覆盖了的，从而就可以执行之前说的 elide 掉 coroutine frame 内存分配的优化。</p>
<h2 id="How-the-compiler-chooses-the-promise-type"><a href="#How-the-compiler-chooses-the-promise-type" class="headerlink" title="How the compiler chooses the promise type"></a>How the compiler chooses the promise type</h2><p>编译期可以自动推导 promise_type。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task&lt;<span class="keyword">float</span>&gt; foo(<span class="built_in">std</span>::<span class="built_in">string</span> x, <span class="keyword">bool</span> flag);</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;<span class="keyword">float</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">bool</span>&gt;::promise_type;</span><br><span class="line"></span><br><span class="line">task&lt;<span class="keyword">void</span>&gt; my_class::method1(<span class="keyword">int</span> x) <span class="keyword">const</span>;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;<span class="keyword">void</span>&gt;, <span class="keyword">const</span> my_class&amp;, <span class="keyword">int</span>&gt;::promise_type;</span><br><span class="line"></span><br><span class="line">task&lt;foo&gt; my_class::method2() &amp;&amp;;</span><br><span class="line">--&gt;</span><br><span class="line"><span class="keyword">typename</span> coroutine_traits&lt;task&lt;foo&gt;, my_class&amp;&amp;&gt;::promise_type;</span><br></pre></td></tr></table></figure>

<p>可以自定义 promise_type</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... ARGS&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_traits</span>&lt;std::optional&lt;T&gt;, ARGS...&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">using</span> promise_type = optional_promise&lt;T&gt;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Identifying-a-specific-coroutine-activation-frame"><a href="#Identifying-a-specific-coroutine-activation-frame" class="headerlink" title="Identifying a specific coroutine activation frame"></a>Identifying a specific coroutine activation frame</h2><p>介绍 coroutine_handle 这个类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::experimental</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise = <span class="keyword">void</span>&gt;</span><br><span class="line">  struct coroutine_handle;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Type-erased coroutine handle. Can refer to any kind of coroutine.</span></span><br><span class="line">  <span class="comment">// Doesn't allow access to the promise object.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span>&lt;void&gt;</span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">// Constructs to the null handle.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">coroutine_handle</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to/from a void* for passing into C-style interop functions.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span>* <span class="title">address</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query if the handle is non-null.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Query if the coroutine is suspended at the final_suspend point.</span></span><br><span class="line">    <span class="comment">// Undefined behaviour if coroutine is not currently suspended.</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">done</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Resume/Destroy the suspended coroutine</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Coroutine handle for coroutines with a known promise type.</span></span><br><span class="line">  <span class="comment">// Template argument must exactly match coroutine's promise type.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Promise&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">coroutine_handle</span> :</span> coroutine_handle&lt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> coroutine_handle&lt;&gt;::coroutine_handle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> coroutine_handle <span class="title">from_address</span><span class="params">(<span class="keyword">void</span>* addr)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access to the coroutine's promise object.</span></span><br><span class="line">    <span class="function">Promise&amp; <span class="title">promise</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// You can reconstruct the coroutine handle from the promise object.</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> coroutine_handle <span class="title">from_promise</span><span class="params">(Promise&amp; promise)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它可以由两个方式获得：</p>
<ol>
<li>await_suspend 的参数<br> 这类似于 CPS 的方式。</li>
<li>通过 promise 从 from_promise 构造</li>
</ol>
<p>coroutine_handle 并不是 RAII 的，需要调用 destroy 去释放它。这样设计是为了减少 overhead。</p>
<p>You should generally try to use higher-level types that provide the RAII semantics for coroutines, such as those provided by cppcoro (shameless plug), or write your own higher-level types that encapsulate the lifetime of the coroutine frame for your coroutine type.</p>
<h2 id="Customising-the-behaviour-of-co-await"><a href="#Customising-the-behaviour-of-co-await" class="headerlink" title="Customising the behaviour of co_await"></a>Customising the behaviour of co_await</h2><p>promise 类型可以可选地自定义 co_await 表达式的行为。<br>只需要定义这个类型的 <code>await_transform()</code> 方法，编译器就能够将所有的 <code>co_await &lt;expr&gt;</code> 转换为 <code>co_await promise.await_transform(&lt;expr&gt;)</code>。</p>
<p>为什么要提供这个功能呢？</p>
<h3 id="原因1"><a href="#原因1" class="headerlink" title="原因1"></a>原因1</h3><p>因为有些类型不是 awaitable 的，所以要提供这个转换。</p>
<p>For example, a promise type for coroutines with a <code>std::optional&lt;T&gt;</code> return-type might provide an <code>await_transform()</code> overload that takes a <code>std::optional&lt;U&gt;</code> and that returns an awaitable type that either returns a value of type U or suspends the coroutine if the awaited value contains <code>nullopt</code>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optional_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(<span class="built_in">std</span>::optional&lt;U&gt;&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">awaiter</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="built_in">std</span>::optional&lt;U&gt;&amp; value;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">      explicit awaiter(std::optional&lt;U&gt;&amp; x) noexcept : value(x) &#123;&#125;</span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> value.has_value(); &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::experimental::coroutine_handle&lt;&gt;)</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">      <span class="function">U&amp; <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> *value; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> awaiter&#123; value &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原因2"><a href="#原因2" class="headerlink" title="原因2"></a>原因2</h3><p>It lets you disallow awaiting on certain types by declaring <code>await_transform</code> overloads as deleted.</p>
<p>For example, a promise type for <code>std::generator&lt;T&gt;</code> return-type might declare a deleted <code>await_transform()</code> template member function that accepts any type. This basically disables use of co_await within the coroutine.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generator_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Disable any use of co_await within this type of coroutine.</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="built_in">std</span>::experimental::<span class="function">suspend_never <span class="title">await_transform</span><span class="params">(U&amp;&amp;)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="原因3"><a href="#原因3" class="headerlink" title="原因3"></a>原因3</h3><p>It lets you adapt and change the behaviour of normally awaitable values.</p>
<p>For example, you could define a type of coroutine that ensured that the coroutine always resumed from every co_await expression on an associated executor by wrapping the awaitable in a resume_on() operator (see cppcoro::resume_on()).</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Executor&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">executor_task_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Executor executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">await_transform</span><span class="params">(Awaitable&amp;&amp; awaitable)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> cppcoro::resume_on;</span><br><span class="line">    <span class="keyword">return</span> resume_on(<span class="keyword">this</span>-&gt;executor, <span class="built_in">std</span>::forward&lt;Awaitable&gt;(awaitable));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>As a final word on <code>await_transform()</code>, it’s important to note that if the promise type defines any <code>await_transform()</code> members then this triggers the compiler to transform all <code>co_await</code> expressions to call promise.await_transform(). 所以，如果只是希望对某些类型定制 co_await 行为，最好为 <code>await_transform()</code> 提供一个只 forward argument 的重载。</p>
<h2 id="Customising-the-behaviour-of-co-yield"><a href="#Customising-the-behaviour-of-co-yield" class="headerlink" title="Customising the behaviour of co_yield"></a>Customising the behaviour of co_yield</h2><p>编译器会把 <code>co_yield &lt;expr&gt;</code> 转换为 <code>co_await promise.yield_value(&lt;expr&gt;)</code>。因此 promise 对象可以定制 <code>yield_value</code> 方法。</p>
<p>如果编译器没有定制这个方法，该方法不会有默认的行为。所以需要显式提供这样的方法，promise 类型才能支持 co_yield。</p>
<p>如下所示，对一个 generator 类型提供了 yield_value 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">generator_promise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  T* valuePtr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::experimental::<span class="function">suspend_always <span class="title">yield_value</span><span class="params">(T&amp; value)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="comment">// Stash the address of the yielded value and then return an awaitable</span></span><br><span class="line">    <span class="comment">// that will cause the coroutine to suspend at the co_yield expression.</span></span><br><span class="line">    <span class="comment">// Execution will then return from the call to coroutine_handle&lt;&gt;::resume()</span></span><br><span class="line">    <span class="comment">// inside either generator&lt;T&gt;::begin() or generator&lt;T&gt;::iterator::operator++().</span></span><br><span class="line">    valuePtr = <span class="built_in">std</span>::addressof(value);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="Understanding-Symmetric-Transfer"><a href="#Understanding-Symmetric-Transfer" class="headerlink" title="Understanding Symmetric Transfer"></a>Understanding Symmetric Transfer</h1><p><a href="https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer" target="_blank" rel="noopener">https://lewissbaker.github.io/2020/05/11/understanding_symmetric_transfer</a></p>
<p>在 Coroutine TS 刚开始被提出的时候，有一个限制，会导致轻易的 stack-overflow。为了避免它，就需要在 <code>task&lt;T&gt;</code> 类型中引入额外的同步开销。</p>
<p>在 2018 年，引入了一个 symmetric transfer 的特性，使得我们可以挂起一个 Coroutine，并 Resume 另一个，但是不会消耗栈空间了。</p>
<h2 id="First-some-background-on-how-a-task-coroutine-works"><a href="#First-some-background-on-how-a-task-coroutine-works" class="headerlink" title="First some background on how a task coroutine works"></a>First some background on how a task coroutine works</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">co_await <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不放展开看看 <code>bar()</code> 在 <code>co_await foo()</code> 的时候都发生了什么：</p>
<ol>
<li>调用 foo 需要有下面几步<br> 为 coroutine frame 分配寻出空间。<br> 将参数复制到 coroutine frame 里面。在当前 case 里面没有参数，所以就是一个空操作。<br> 在 coroutine frame 里面构造 promise object。<br> 调用 <code>promise.get_return_object()</code> 获得 foo() 的返回值。这个过程中会产生被返回的 task 对象，并使用 std::coroutine_handle 创建它。如前所述，std::coroutine_handle 持有刚创建的 coroutine frame 的引用。<br> 在 initial-suspend point 挂起 coroutine 的执行。<br> 返回 task 对象给到 bar()。</li>
<li>后面，bar() 会执行 co_await<br> <code>bar()</code> 会被挂起，然后调用由 <code>foo()</code> 返回的 task 对象上的 <code>await_suspend()</code> 方法。会把指向 bar 的 coroutine frame 的 <code>std::coroutine_handle</code> 传给该方法。<br> 在 <code>await_suspend()</code> 中，会存储 bar() 的 <code>std::coroutine_handle</code> 到 foo 的 promise 对象中【A】，然后通过调用 <code>foo</code> 的 <code>std::coroutine_handle</code> 的 resume 方法去 resume foo() 的执行。</li>
<li>foo() 会同步地执行。</li>
<li>foo() 会在 final-suspend point 挂起，然后 resume bar。这是根据被存在 promise 对象中的 std::coroutine_handle 来找到的，见【A】步骤。</li>
<li>bar() 会 resume，继续执行，并最终到达 co_await 语句处，并调用临时 task 对象的析构函数。</li>
<li>task 对象执行析构。因为这个 task 对象是 foo() 返回的，所以它会调用 foo() 的 coroutine handle 上的 <code>.destroy()</code> 方法，这样就会销毁 coroutine frame，包括 promise 对象和之前复制了的参数之内。</li>
</ol>
<h2 id="Outline-of-a-task-implementation"><a href="#Outline-of-a-task-implementation" class="headerlink" title="Outline of a task implementation"></a>Outline of a task implementation</h2><p>下面可以看下如果不支持 symmetric transfer，task 类应该如何被实现。可以看出 task 是一个 Awaitable。</p>
<p>A task has exclusive ownership of the <code>std::coroutine_handle</code> that corresponds to the coroutine frame created during the invocation of the coroutine. The task object is an RAII object that ensures that <code>.destroy()</code> is called on the <code>std::coroutine_handle</code> when the task object goes out of scope.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">promise_type</span> &#123;</span> <span class="comment">/* see below */</span> &#125;;</span><br><span class="line"></span><br><span class="line">  task(task&amp;&amp; t) <span class="keyword">noexcept</span></span><br><span class="line">  : coro_(<span class="built_in">std</span>::exchange(t.coro_, &#123;&#125;))</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~task() &#123;</span><br><span class="line">    <span class="keyword">if</span> (coro_)</span><br><span class="line">      coro_.destroy();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">awaiter</span> &#123;</span> <span class="comment">/* see below */</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">awaiter <span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">task</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  : coro_(h)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面会展开讲解 promise_type 和 awaiter 的实现。</p>
<h2 id="Implementing-task-promise-type"><a href="#Implementing-task-promise-type" class="headerlink" title="Implementing task::promise_type"></a>Implementing task::promise_type</h2><p>promise_type 会定义在 coroutine frame 中创建的 Promise 对象的类型。</p>
<p>首先，需要实现 <code>get_return_object()</code> 去构造将来要被返回的 task 对象。这个对象的初始化需要借助于 <code>std::coroutine_handle</code>。</p>
<p>这里是根据 <code>from_promise</code> 从 Promise 对象中重新构造出了 <code>std::coroutine_handle</code>。这是获得 <code>std::coroutine_handle</code> 的一种方法，另一种方法是 <code>await_suspend</code> 参数，前文中提到过。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:promise_type &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">task <span class="title">get_return_object</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> task&#123;<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt;::from_promise(*<span class="keyword">this</span>)&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面，这个 coroutine 需要在 initial-suspend point 挂起，这样在 task 被 await 的时候，我们可以 resume 它。这样 lazy 的处理有下面几点好处：</p>
<ol>
<li>It means that we can attach the continuation’s <code>std::coroutine_handle</code> before starting execution of the coroutine. This means we don’t need to use thread-synchronisation to arbitrate the race between attaching the continuation later and the coroutine running to completion.<br> 我理解这里讲的是和“Comparison to Stackful Coroutines”这一章节中类似的问题。</li>
<li>It means that the task destructor can unconditionally destroy the coroutine frame - we don’t need to worry about whether the coroutine is potentially executing on another thread since the coroutine will not start executing until we await it, and while it is executing the calling coroutine is suspended and so won’t attempt to call the task destructor until the coroutine finishes executing.<br> 这里说的是 task 的析构函数可以不加判断地直接销毁掉 coroutine frame。也就是说，并不需要担心 coroutine 是否此时还在另一个线程上执行。实际上我们只有在 await 它的时候，coroutine 才会开始执行。而这个时候，调用方 coroutine 已经被挂起了，直到 coroutine 执行完成后，都不会再调用 task 的 destructor 了。<br> 所以这让编译器更容易把分配 coroutine frame 的操作 inline 到 caller 的 frame 里面。我理解就是“Allocating a coroutine frame”里面讲的东西。<br> See P0981R0 to read more about the Heap Allocation eLision Optimisation (HALO).</li>
<li>It also improves the exception-safety of your coroutine code. If you don’t immediately <code>co_await</code> the returned task and do something else that can throw an exception that causes the stack to unwind and the task destructor to run then we can safely destroy the coroutine since we know it hasn’t started yet. We aren’t left with the difficult choice between detaching, potentially leaving dangling references, blocking in the destructor, terminating or undefined-behaviour.<br> 这也能提高异常安全性。</li>
</ol>
<p>为了让 coroutine 能够 initially suspend，需要定义一个返回 <code>suspend_always</code> 的 <code>initial_suspend</code> 方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">suspend_always <span class="title">initial_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后，定义 <code>return_void()</code> 方法。这是在执行 <code>co_return</code> 的时候，或者执行到 coroutine 末尾的时候被调用的。这个方法并不会做什么事情，只是让编译器知道 <code>co_return;</code> 对于当前的 coroutine 类型是合法的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">return_void</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>We also need to add an <code>unhandled_exception()</code> method that is called if an exception escapes the body of the coroutine. For our purposes we can just treat the task coroutine bodies as noexcept and call <code>std::terminate()</code> if this happens.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unhandled_exception</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::terminate();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>最后，还需要 coroutine 能在 final-suspend point 被 suspend 住，然后 resume its Continuation。在当前的 case 中 continuation 就是在 awaiting 的 coroutine，在 <code>task::awaiter::await_suspend</code> 的时候被设置的。</p>
<p>【Q】“resume its Continuation” 中的 Continuation 指的是什么？这里我理解应该就是 loop_synchronously 里面循环的下一次迭代。可以在 Stack 图中看到 continuation 具体指向哪里的。</p>
<p>因此，需要在 promise 中引入一个成员，去持有 continuation 的 <code>std::coroutine_handle</code>，不然如何调用对应的 <code>.resume()</code> 方法呢？</p>
<p>还需要定义 <code>final_suspend()</code> 方法来返回一个 awaitable 对象也就是 final_awaiter，让它在当前 coroutine 被挂起后，去 resume 这个 continuation。</p>
<p>注意，需要再当前 coroutine 被 suspend 之后，才能 resume continuation。这是因为 continuation 可能立即就会调用 task 的析构函数，从而间接调用 coroutine frame 的 <code>.destroy()</code> 方法。<code>.destroy()</code> 方法只对 suspended 的 coroutine 生效。</p>
<p>The compiler inserts code to evaluate the statement <code>co_await promise.final_suspend();</code> at the closing curly brace.</p>
<p>需要注意，在调用 <code>final_suspend</code> 的时候，coroutine 还没有进入 suspend 状态。需要等到返回的 awaitable 对象上的 await_suspend() 方法被调用之后，coroutine 才被 suspend。关于这个我觉得可以参考之前讲的 <code>&lt;return-to-caller-or-resumer&gt;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">final_awaiter</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">      <span class="comment">// Lookup its continuation in the promise and resume it.</span></span><br><span class="line">      h.promise().continuation.resume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">final_awaiter <span class="title">final_suspend</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>【Q】为啥这里定义一个 <code>final_awaiter</code>，而不是直接用 std::suspend_always。<br>首先，<code>suspend_always</code> 和 <code>suspend_never</code> 的实现上分别定义了<code> await_ready()</code> 方法始终返回 false 或者 true。<code>await_suspend</code> 或者 <code>await_resume</code> 方法都是空实现。而这里是希望 <code>final_awaiter</code> 的 <code>await_suspend</code> 能去 resume continuation。</p>
<h2 id="Implementing-task-operator-co-await"><a href="#Implementing-task-operator-co-await" class="headerlink" title="Implementing task::operator co_await()"></a>Implementing task::operator co_await()</h2><p>co_await 会返回一个 awaiter 对象，这个对象需要支持 <code>await_ready()</code>、<code>await_suspend()</code> 和 <code>await_resume()</code>。</p>
<p>下面就是 awaiter 的简单实现。注意，一旦一个 coroutine 被 suspend 了，就需要保存 coroutine handle 到 promise 对象中。这样后续可以调用 std::coroutine_handle 中的 resume() 方法去执行这个 task。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:awaiter &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">await_ready</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_suspend</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">    <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">    coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then we resume the task's coroutine, which is currently suspended</span></span><br><span class="line">    <span class="comment">// at the initial-suspend-point (ie. at the open curly brace).</span></span><br><span class="line">    coro_.resume();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">await_resume</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">awaiter</span><span class="params">(<span class="built_in">std</span>::coroutine_handle&lt;task::promise_type&gt; h)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">  : coro_(h)</span><br><span class="line">  &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;task::promise_type&gt; coro_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">task::awaiter task::<span class="function"><span class="keyword">operator</span> <span class="title">co_await</span><span class="params">()</span> &amp;&amp; <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> awaiter&#123;coro_&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作者给出了一个可编译的 demo 在 <a href="https://godbolt.org/z/-Kw6Nf%E3%80%82" target="_blank" rel="noopener">https://godbolt.org/z/-Kw6Nf。</a></p>
<h2 id="The-stack-overflow-problem"><a href="#The-stack-overflow-problem" class="headerlink" title="The stack-overflow problem"></a>The stack-overflow problem</h2><p>考虑下面的代码，如果 count 足够大，程序就会爆栈。例如 <a href="https://godbolt.org/z/gy5Q8q" target="_blank" rel="noopener">https://godbolt.org/z/gy5Q8q</a> 中展示了当 count 是 1000000 的时候，程序就爆栈了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">completes_synchronously</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">loop_synchronously</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="function">co_await <span class="title">completes_synchronously</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为当 loop_synchronously() 开始执行时，有一个其他 coroutine 正在 <code>co_await</code> 的自己返回的 task，也就是在 <code>co_await loop_synchronously()</code>。因此，它会 suspend 正在 awating 的 coroutine，然后调用 <code>task::awaiter::await_suspend()</code>。如前文介绍，<code>await_suspend</code> 会负责调用对应 task 的<code> std::coroutine_handle</code> 的 <code>resume()</code> 方法。</p>
<p>Thus the stack will look something like this when loop_synchronously() starts.</p>
<p>我理解这里倒数第二底层的 task::awaiter::await_suspend 是由于这个其他 coroutine 在 await 从而产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+------------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume    | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+------------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume     |                     | | task::promise        | |</span><br><span class="line">+------------------------------+                     | | - continuation --.   | |</span><br><span class="line">| task::awaiter::await_suspend |                     | +------------------|---+ |</span><br><span class="line">+------------------------------+                     | ...                |     |</span><br><span class="line">| awaiting_coroutine$resume    |                     +--------------------|-----+</span><br><span class="line">+------------------------------+                                          V</span><br><span class="line">|  ....                        |                     +--------------------------+</span><br><span class="line">+------------------------------+                     | awaiting_coroutine frame |</span><br><span class="line">                                                     |                          |</span><br><span class="line">                                                     +--------------------------+</span><br></pre></td></tr></table></figure>

<p>这里的 <code>$resume</code> 后缀用来表示 coroutine 中的用户自定义逻辑。</p>
<p>然后，当 <code>loop_synchronously()</code> 去 <code>co_await</code> 从 <code>completes_synchronously()</code> 返回的 task 对象时，当前的 coroutine 会被 suspend，然后会调用 <code>task::awaiter::await_suspend()</code>。await_suspend() 方法会调用 <code>completes_synchronously()</code> 的 coroutine handle 上的 <code>.resume()</code> 方法。</p>
<p>这会 resume <code>completes_synchronously()</code> coroutine。这个 coroutine 会 synchronously 地运行结束，然后在 final-suspend point 被 suspend。然后它会调用 <code>task::promise::final_awaiter::await_suspend()</code>，然后最终调用 <code>loop_synchronously()</code> 这个 coroutine 的 coroutine handle 上的 <code>.resume()</code> 方法。</p>
<p>如果我们在 <code>loop_synchronously()</code> coroutine 被 resume 之后，它返回的临时的 task 被销毁之前，检查调用栈，就可以看到下面的情况。</p>
<p>这里的 final_awaiter 也就是 promise 对象的 final_suspend() 方法返回的内容。根据之前的说明，它是在 final-suspend point 之后 resume continuation 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+-------------------------------+ &lt;-- top of stack</span><br><span class="line">| loop_synchronously$resume     | active coroutine -.</span><br><span class="line">+-------------------------------+                   |</span><br><span class="line">| coroutine_handle::resume      |            .------&apos;</span><br><span class="line">+-------------------------------+            |</span><br><span class="line">| final_awaiter::await_suspend  |            |</span><br><span class="line">+-------------------------------+            |  +--------------------------+ &lt;-.</span><br><span class="line">| completes_synchronously$resume|            |  | completes_synchronously  |   |</span><br><span class="line">+-------------------------------+            |  | frame                    |   |</span><br><span class="line">| coroutine_handle::resume      |            |  +--------------------------+   |</span><br><span class="line">+-------------------------------+            &apos;---.                             |</span><br><span class="line">| task::awaiter::await_suspend  |                V                             |</span><br><span class="line">+-------------------------------+ &lt;-- prev top  +--------------------------+   |</span><br><span class="line">| loop_synchronously$resume     |     of stack  | loop_synchronously frame |   |</span><br><span class="line">+-------------------------------+               | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume      |               | | task::promise        | |   |</span><br><span class="line">+-------------------------------+               | | - continuation --.   | |   |</span><br><span class="line">| task::awaiter::await_suspend  |               | +------------------|---+ |   |</span><br><span class="line">+-------------------------------+               | - task temporary --|---------&apos;</span><br><span class="line">| awaiting_coroutine$resume     |               +--------------------|-----+</span><br><span class="line">+-------------------------------+                                    V</span><br><span class="line">|  ....                         |               +--------------------------+</span><br><span class="line">+-------------------------------+               | awaiting_coroutine frame |</span><br><span class="line">                                                |                          |</span><br><span class="line">                                                +--------------------------+</span><br></pre></td></tr></table></figure>

<p>然后，就会调用 task 的析构函数，摧毁 <code>completes_synchronously()</code> 的 coroutine frame。然后就会进行新一轮的循环，创建新的 completes_synchronously() 的 coroutine frame，然后 resume。</p>
<p>最终结果是，<code>loop_synchronously()</code> 和 <code>completes_synchronously()</code> 会递归地互相调用彼此。每次调用都会消耗一点栈空间，直到最后栈爆掉了。</p>
<p>Writing loops in coroutines built this way makes it very easy to write functions that perform unbounded recursion without looking like they are doing any recursion.</p>
<p>So, what would the solution look like under the original Coroutines TS design?</p>
<h2 id="The-Coroutines-TS-solution"><a href="#The-Coroutines-TS-solution" class="headerlink" title="The Coroutines TS solution"></a>The Coroutines TS solution</h2><p>TS 的解决方案是使用返回 bool 的版本的 await_suspend，根据的原理是<br>In the Coroutines TS there is also a version of await_suspend() that returns bool - if it returns true then the coroutine is suspended and execution returns to the caller of resume(), otherwise if it returns false then the coroutine is immediately resumed, but this time without consuming any additional stack-space.</p>
<p>具体来说，做出下面的修改：</p>
<ol>
<li>Inside the <code>task::awaiter::await_suspend()</code> method you can start executing the coroutine by calling <code>.resume()</code>. Then when the call to <code>.resume()</code> returns, check whether the coroutine has run to completion or not. If it has run to completion then we can return false, which indicates the awaiting coroutine should immediately resume, or we can return true, indicating that execution should return to the caller of <code>std::coroutine_handle::resume()</code>.</li>
<li>Inside <code>task::promise_type::final_awaiter::await_suspend()</code>, which is run when the coroutine runs to completion, we need to check whether the awaiting coroutine has (or will) return true from <code>task::awaiter::await_suspend()</code> and if so then resume it by calling .resume(). Otherwise, we need to avoid resuming the coroutine and notify task::awaiter::await_suspend() that it needs to return false.</li>
</ol>
<p>从下面的代码来看，awaiter::await_suspend 和 final_awaiter::await_suspend 中都会尝试设置 promise.ready 为 true。但是：</p>
<ol>
<li>在 awaiter::await_suspend 中如果发现 promise.ready 原来是 false，说明还没结束，则要返回 true 去挂起，并且返回给 <code>std::coroutine_handle::resume()</code> 的调用方。如果原来是 true，说明执行完了，就返回 false，则可以立即 resume。</li>
<li>在 final_awaiter::await_suspend 中如果发现 promise.ready 原来是 true，说明【Q】</li>
</ol>
<blockquote>
<p>There is an added complication, however, in that it’s possible for a coroutine to start executing on the current thread then suspend and later resume and run to completion on a different thread before the call to .resume() returns. Thus, we need to be able to resolve the potential race between part 1 and part 2 above happening concurrently.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">task</span>:</span>:promise_type &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; ready = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  promise_type&amp; promise = coro_.promise();</span><br><span class="line">  promise.continuation = continuation;</span><br><span class="line">  coro_.resume();</span><br><span class="line">  <span class="keyword">return</span> !promise.ready.exchange(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  promise_type&amp; promise = h.promise();</span><br><span class="line">  <span class="keyword">if</span> (promise.ready.exchange(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_acq_rel)) &#123;</span><br><span class="line">    <span class="comment">// The coroutine did not complete synchronously, resume it here.</span></span><br><span class="line">    promise.continuation.resume();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改后的代码在 <a href="https://godbolt.org/z/7fm8Za%E3%80%82" target="_blank" rel="noopener">https://godbolt.org/z/7fm8Za。</a></p>
<h2 id="The-problems"><a href="#The-problems" class="headerlink" title="The problems"></a>The problems</h2><p>上面的方案依然存在问题：</p>
<ol>
<li>依赖原子操作<br> 第一次是在调用者在 suspend awaiting coroutine 的时候。<br> 第二次是在被调用者即将完成执行的时候。</li>
<li>引入额外的分支操作。</li>
</ol>
<p>最后一个最严重的问题是，被挂起的 coroutine 在被 resume 后，被哪个线程执行是不确定的。比如考虑下面的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cppcoro::static_thread_pool tp;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo1 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="comment">// Suspend coroutine and reschedule onto thread-pool thread.</span></span><br><span class="line">  co_await tp.schedule();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo2 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar1 "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="function">co_await <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar2"</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原始的实现中，可能的输出如下。这是因为我们保证在 the code that runs after <code>co_await foo()</code> would run inline on the same thread that foo() completed on.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar1 1234</span><br><span class="line">foo1 1234</span><br><span class="line">foo2 3456</span><br><span class="line">bar2 3456</span><br></pre></td></tr></table></figure>

<p>但是因为使用了原子变量，就可能 foo 的 completion 和 bar 的 suspension 之间有 race（我理解就是上面的两个 await_suspend 会竞争地设置 promise.ready 吧）。那么在一些情况下，<code>co_await foo()</code> might run on the original thread that bar() started executing on. 如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bar1 1234</span><br><span class="line">foo1 1234</span><br><span class="line">foo2 3456</span><br><span class="line">bar2 1234</span><br></pre></td></tr></table></figure>

<p>这对一些场景下是存在问题的。比如 <code>via</code> 这个函数可以指定一个 Scheduler 去运行某个 Awaitable。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Awaitable, <span class="keyword">typename</span> Scheduler&gt;</span><br><span class="line">task&lt;<span class="keyword">await_result_t</span>&lt;Awaitable&gt;&gt; via(Awaitable a, Scheduler s)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">auto</span> result = co_await <span class="built_in">std</span>::move(a);</span><br><span class="line">  co_await s.schedule();</span><br><span class="line">  co_return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task&lt;T&gt; get_value();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">task&lt;<span class="keyword">void</span>&gt; consumer(static_thread_pool::scheduler s)</span><br><span class="line">&#123;</span><br><span class="line">  T result = co_await via(get_value(), s);</span><br><span class="line">  consume(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但像现在这样的话，<code>consume()</code> 可能在 s 上执行，但也有可能在 whatever thread the consumer() coroutine started execution on 上被执行。</p>
<h2 id="Enter-“symmetric-transfer”"><a href="#Enter-“symmetric-transfer”" class="headerlink" title="Enter “symmetric transfer”"></a>Enter “symmetric transfer”</h2><p>This paper proposed two key changes:</p>
<ol>
<li>Allow returning a <code>std::coroutine_handle&lt;T&gt;</code> from await_suspend() as a way of indicating that execution should be symmetrically transferred to the coroutine identified by the returned handle.</li>
<li>Add a std::experimental::noop_coroutine() function that returns a special std::coroutine_handle that can be returned from await_suspend() to suspend the current coroutine and return from the call to .resume() instead of transferring execution to another coroutine.</li>
</ol>
<p>首先，什么是 symmetric transfer？简单来说，像函数调用，返回那样的就是 asymmetric transfer，因为有明确的调用者和被调用者。具体到 coroutine 场景中，当 A 调用 <code>.resume()</code> 方法去 resume 一个 coroutine 的时候，这个 A 还在 stack 上，尽管 resumed coroutine 正在被执行。当这个 coroutine 后面挂起，并调用 <code>await_suspend</code> 返回 void（无条件 suspend）或者 true（条件 suspend），那么对 <code>.resume()</code> 的调用就返回了。</p>
<p>每次我们通过 .resume() 方法去 resume 一个 coroutine 的时候，都会创建一个新的 frame。<br>但如果通过 symmetric transfer，我们就只是 suspend 某个 coroutine，resume 另一个 coroutine。这两个 coroutine 之间没有任何的调用者或者被调用者的关系。当一个 coroutine 被 suspend 后，它可以将 execution 给到任意的被 suspend 的coroutine，甚至包括自己，并且在自己被 suspend 之后，也不需要把 execution 还给之前的 coroutine。</p>
<p>Let’s look at what the compiler lowers a co_await expression to when the awaiter makes use of symmetric-transfer:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) value = &lt;expr&gt;;</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) awaitable =</span><br><span class="line">      get_awaitable(promise, <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(value)&amp;&amp;&gt;(value));</span><br><span class="line">  <span class="keyword">decltype</span>(<span class="keyword">auto</span>) awaiter =</span><br><span class="line">      get_awaiter(<span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(awaitable)&amp;&amp;&gt;(awaitable));</span><br><span class="line">  <span class="keyword">if</span> (!awaiter.await_ready())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">handle_t</span> = <span class="built_in">std</span>::coroutine_handle&lt;P&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//&lt;suspend-coroutine&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> h = awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">    h.resume();</span><br><span class="line">    <span class="comment">//&lt;return-to-caller-or-resumer&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//&lt;resume-point&gt;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> awaiter.await_resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Let’s zoom in on the key part that differs from other co_await forms:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> h = awaiter.await_suspend(<span class="keyword">handle_t</span>::from_promise(p));</span><br><span class="line">h.resume();</span><br><span class="line"><span class="comment">//&lt;return-to-caller-or-resumer&gt;</span></span><br></pre></td></tr></table></figure>

<p>Once the coroutine state-machine is lowered (a topic for another post), the <code>&lt;return-to-caller-or-resumer&gt;</code> part basically becomes a return; statement which causes the call to .resume() that last resumed the coroutine to return to its caller.</p>
<p>This means that we have the situation where we have a call to another function with the same signature, <code>std::coroutine_handle::resume()</code>, followed by a return; from the current function which is itself the body of a <code>std::coroutine_handle::resume()</code> call.</p>
<p>Some compilers, when optimisations are enabled, are able to apply an optimisation that turns calls to other functions the tail-position (ie. just before returning) into tail-calls as long as some conditions are met.</p>
<p>It just so happens that this kind of tail-call optimisation is exactly the kind of thing we want to be able to do to avoid the stack-overflow problem we were encountering before. But instead of being at the mercy of the optimiser as to whether or not the tail-call transformation is perfromed, we want to be able to guarantee that the tail-call transformation occurs, even when optimisations are not enabled.</p>
<p>But first let’s dig into what we mean by tail-calls.</p>
<h2 id="Tail-calls"><a href="#Tail-calls" class="headerlink" title="Tail-calls"></a>Tail-calls</h2><p>Tail-call 指的是当前的 stack frame 被在调用前就被弹出了，然后当前函数的返回地址变为了被调用者的返回地址。比如，被调用者会直接返回给调用者的调用者。</p>
<p>在 X86 架构上，编译器会首先弹出当前的栈帧，然后用一个 jmp 指令去跳转到被调用的函数的 entry-point。而不是使用一个 call 指令，然后在返回后再弹出当前 stack-frame。</p>
<p>This optimisation is generally only possible to do in limited circumstances, however. In particular, it requires that:</p>
<ol>
<li>the calling convention supports tail-calls and is the same for the caller and callee;</li>
<li>the return-type is the same;</li>
<li>there are no non-trivial destructors that need to be run after the call before returning to the caller; and</li>
<li>the call is not inside a try/catch block.</li>
</ol>
<p>The shape of the symmetric-transfer form of co_await has actually been designed specifically to allow coroutines to satisfy all of these requirements. Let’s look at them individually.</p>
<ol>
<li><p>Calling convention<br> 当编译器 lowers 一个 coroutine 到机器码的时候，它实际上将 coroutine 分为了两部分。第一部分是 ramp，它会分配并初始化 coroutine 帧。第二部分是 body，它包含了从用户自定义的 coroutine body 生成的状态机。<br> The function signature of the coroutine (and thus any user-specified calling-convention) affects only the ramp part, whereas the body part is under the control of the compiler and is never directly called by any user-code - only by the ramp function and by <code>std::coroutine_handle::resume()</code>.<br> The calling-convention of the coroutine body part is not user-visible and is entirely up to the compiler and thus it can choose an appropriate calling convention that supports tail-calls and that is used by all coroutine bodies.</p>
</li>
<li><p>Return type is the same<br> “调用方” coroutine 和“被调用方” coroutine 的 .resume() 方法的返回值都是 void。</p>
</li>
<li><p>No non-trivial destructors<br> 在执行 tail-call 时，需要能够在调用目标函数之前就释放当前的 stack frame。而这需要所有在栈上分配的对象的生命周期都在调用前完成。<br> Normally, this would be problematic as soon as there are any objects with non-trivial destructors in-scope as the lifetime of those objects would not yet have ended and those objects would have been allocated on the stack.<br> 但是，当一个 coroutine 被 suspend 之后，它实际上会将需要续命的对象放到 coroutine frame 里面，而不是直接分配在 stack 上。<br> 对于真正的 local variable，也就是那些 lifetime 并不会跨越 suspend-point 的 variable，它们是会被分配在栈上的。但是它们的 lifetime 在 coroutine suspend 之前就已经结束了，并且对应的析构函数也已经被调用了。<br> 所以不会存在有 stack-allocated objects，它们的 non-trivial destructor 需要在 tail-call 返回之后被执行。</p>
</li>
<li><p>Call not inside a try/catch block<br> 这里比较 tricky 的一点是每个 coroutine 都会有一个隐式的 try/catch block，来包裹其中的用户自定义的部分。<br> 类似下面这，F 就是用户自定义的部分。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  promise_type promise;</span><br><span class="line">  co_await promise.initial_suspend();</span><br><span class="line">  <span class="keyword">try</span> &#123; F; &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123; promise.unhandled_exception(); &#125;</span><br><span class="line">final_suspend:</span><br><span class="line">  co_await promise.final_suspend();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 所以，每个用户自定义的 co_await 表达式（除了 initial_suspend 和 final_suspend 的）会被 try catch 包裹。<br> However, implementations work around this by actually executing the call to .resume() outside of the context of the try-block.</p>
</li>
</ol>
<p>So we see that coroutines performing a symmetric-transfer generally satisfy all of the requirements for being able to perform a tail-call. The compiler guarantees that this will always be a tail-call, regardless of whether optimisations are enabled or not.</p>
<p>This means that by using the std::coroutine_handle-returning flavour of await_suspend() we can suspend the current coroutine and transfer execution to another coroutine without consuming extra stack-space.</p>
<p>This allows us to write coroutines that mutually and recursively resume each other to an arbitrary depth without fear of overflowing the stack.</p>
<p>This is exactly what we need to fix our task implementation.</p>
<h2 id="task-revisited"><a href="#task-revisited" class="headerlink" title="task revisited"></a>task revisited</h2><p>So with the new “symmetric transfer” capability under our belt let’s go back and fix our task type implementation.</p>
<p>To do this we need to make changes to the two await_suspend() methods in our implementation:</p>
<ol>
<li>First so that when we await the task that we perform a symmetric-transfer to resume the task’s coroutine.</li>
<li>Second so that when the task’s coroutine completes that it performs a symmetric transfer to resume the awaiting coroutine.</li>
</ol>
<p>To address the await direction we need to change the task::awaiter method from this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">  <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">  coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then we resume the task's coroutine, which is currently suspended</span></span><br><span class="line">  <span class="comment">// at the initial-suspend-point (ie. at the open curly brace).</span></span><br><span class="line">  coro_.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::coroutine_handle&lt;&gt; task::awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;&gt; continuation) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// Store the continuation in the task's promise so that the final_suspend()</span></span><br><span class="line">  <span class="comment">// knows to resume this coroutine when the task completes.</span></span><br><span class="line">  coro_.promise().continuation = continuation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Then we tail-resume the task's coroutine, which is currently suspended</span></span><br><span class="line">  <span class="comment">// at the initial-suspend-point (ie. at the open curly brace), by returning</span></span><br><span class="line">  <span class="comment">// its handle from await_suspend().</span></span><br><span class="line">  <span class="keyword">return</span> coro_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And to address the return-path we need to update the task::promise_type::final_awaiter method from this:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">  <span class="comment">// Lookup its continuation in the promise and resume it.</span></span><br><span class="line">  h.promise().continuation.resume();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会变成</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::coroutine_handle&lt;&gt; task::promise_type::final_awaiter::await_suspend(</span><br><span class="line">    <span class="built_in">std</span>::coroutine_handle&lt;promise_type&gt; h) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// The coroutine is now suspended at the final-suspend point.</span></span><br><span class="line">  <span class="comment">// Lookup its continuation in the promise and resume it symmetrically.</span></span><br><span class="line">  <span class="keyword">return</span> h.promise().continuation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>And now we have a task implementation that doesn’t suffer from the stack-overflow problem that the void-returning await_suspend flavour had and that doesn’t have the non-deterministic resumption context problem of the bool-returning await_suspend flavour had.</p>
<h2 id="Visualising-the-stack"><a href="#Visualising-the-stack" class="headerlink" title="Visualising the stack"></a>Visualising the stack</h2><p>这是之前的例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">task <span class="title">completes_synchronously</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">task <span class="title">loop_synchronously</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">    <span class="function">co_await <span class="title">completes_synchronously</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在 loop_synchronously() 第一次被执行的时候，可能是因为有些其他的 coroutine 去 co_await 了它。这是通过 symmetric transfer 来实现的，所以栈类似下面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                Heap</span><br><span class="line">+---------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+---------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume  |                     | | task::promise        | |</span><br><span class="line">+---------------------------+                     | | - continuation --.   | |</span><br><span class="line">|     ...                   |                     | +------------------|---+ |</span><br><span class="line">+---------------------------+                     | ...                |     |</span><br><span class="line">                                                  +--------------------|-----+</span><br><span class="line">                                                                       V</span><br><span class="line">                                                  +--------------------------+</span><br><span class="line">                                                  | awaiting_coroutine frame |</span><br><span class="line">                                                  |                          |</span><br><span class="line">                                                  +--------------------------+</span><br></pre></td></tr></table></figure>

<p>然后，执行 <code>co_await completes_synchronously()</code> 的时候，又会触发一次 symmetric transfer 到 completes_synchronously。</p>
<p>It does this by:</p>
<ol>
<li>调用 <code>task::operator co_await()</code>，获得一个 task::awaiter 对象</li>
<li>suspend，然后调用 <code>task::awaiter::await_suspend()</code>。它的 symmetric transfer 的版本会返回 <code>coroutine_handle</code> of the <code>completes_synchronously</code> coroutine.</li>
<li>执行一次 tail-call 或者说 jump 去到 <code>completes_synchronously</code> coroutine。这会弹出 <code>loop_synchronously</code> 的 frame，然后再 activate <code>completes_synchronously</code> 的 frame.</li>
</ol>
<p>If we now look at the stack just after <code>completes_synchronously</code> is resumed it will now look like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">              Stack                                          Heap</span><br><span class="line">                                            .-&gt; +--------------------------+ &lt;-.</span><br><span class="line">                                            |   | completes_synchronously  |   |</span><br><span class="line">                                            |   | frame                    |   |</span><br><span class="line">                                            |   | +----------------------+ |   |</span><br><span class="line">                                            |   | | task::promise        | |   |</span><br><span class="line">                                            |   | | - continuation --.   | |   |</span><br><span class="line">                                            |   | +------------------|---+ |   |</span><br><span class="line">                                            `-, +--------------------|-----+   |</span><br><span class="line">                                              |                      V         |</span><br><span class="line">+-------------------------------+ &lt;-- top of  | +--------------------------+   |</span><br><span class="line">| completes_synchronously$resume|     stack   | | loop_synchronously frame |   |</span><br><span class="line">+-------------------------------+ active -----&apos; | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume      | coroutine     | | task::promise        | |   |</span><br><span class="line">+-------------------------------+               | | - continuation --.   | |   |</span><br><span class="line">|     ...                       |               | +------------------|---+ |   |</span><br><span class="line">+-------------------------------+               | task temporary     |     |   |</span><br><span class="line">                                                | - coro_       -----|---------`</span><br><span class="line">                                                +--------------------|-----+</span><br><span class="line">                                                                     V</span><br><span class="line">                                                +--------------------------+</span><br><span class="line">                                                | awaiting_coroutine frame |</span><br><span class="line">                                                |                          |</span><br><span class="line">                                                +--------------------------+</span><br></pre></td></tr></table></figure>

<p>注意，stack-frame 的数量没有变多。</p>
<p>在 completes_synchronously 完成之后，当遇到右花括号的时候，会执行 <code>co_await promise.final_suspend()</code>。</p>
<p>这会导致 coroutine 被挂起，并且调用 <code>final_awaiter::await_suspend()</code>，从而返回 continuation 的 std::coroutine_handle，实际上就指向的 loop_synchronously。这之后会做一个 symmetric transfer/tail-call 去 resume loop_synchronously。</p>
<p>If we look at the stack just after loop_synchronously is resumed then it will look something like this:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">                                                   +--------------------------+ &lt;-.</span><br><span class="line">                                                   | completes_synchronously  |   |</span><br><span class="line">                                                   | frame                    |   |</span><br><span class="line">                                                   | +----------------------+ |   |</span><br><span class="line">                                                   | | task::promise        | |   |</span><br><span class="line">                                                   | | - continuation --.   | |   |</span><br><span class="line">                                                   | +------------------|---+ |   |</span><br><span class="line">                                                   +--------------------|-----+   |</span><br><span class="line">                                                                        V         |</span><br><span class="line">+----------------------------+  &lt;-- top of stack   +--------------------------+   |</span><br><span class="line">| loop_synchronously$resume  | active coroutine -&gt; | loop_synchronously frame |   |</span><br><span class="line">+----------------------------+                     | +----------------------+ |   |</span><br><span class="line">| coroutine_handle::resume() |                     | | task::promise        | |   |</span><br><span class="line">+----------------------------+                     | | - continuation --.   | |   |</span><br><span class="line">|     ...                    |                     | +------------------|---+ |   |</span><br><span class="line">+----------------------------+                     | task temporary     |     |   |</span><br><span class="line">                                                   | - coro_       -----|---------`</span><br><span class="line">                                                   +--------------------|-----+</span><br><span class="line">                                                                        V</span><br><span class="line">                                                   +--------------------------+</span><br><span class="line">                                                   | awaiting_coroutine frame |</span><br><span class="line">                                                   |                          |</span><br><span class="line">                                                   +--------------------------+</span><br></pre></td></tr></table></figure>

<p>loop_synchronously 在 resume 之后要做的第一件事，是调用临时的 task 对象的析构函数。这会销毁 coroutine-frame，释放它的内存，并产生下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">           Stack                                                   Heap</span><br><span class="line">+---------------------------+  &lt;-- top of stack   +--------------------------+</span><br><span class="line">| loop_synchronously$resume | active coroutine -&gt; | loop_synchronously frame |</span><br><span class="line">+---------------------------+                     | +----------------------+ |</span><br><span class="line">| coroutine_handle::resume  |                     | | task::promise        | |</span><br><span class="line">+---------------------------+                     | | - continuation --.   | |</span><br><span class="line">|     ...                   |                     | +------------------|---+ |</span><br><span class="line">+---------------------------+                     | ...                |     |</span><br><span class="line">                                                  +--------------------|-----+</span><br><span class="line">                                                                       V</span><br><span class="line">                                                  +--------------------------+</span><br><span class="line">                                                  | awaiting_coroutine frame |</span><br><span class="line">                                                  |                          |</span><br><span class="line">                                                  +--------------------------+</span><br></pre></td></tr></table></figure>

<p>We are now back to executing the <code>loop_synchronously</code> coroutine and we now have the same number of stack-frames and coroutine-frames as we started, and will do so each time we go around the loop.</p>
<p>Thus we can perform as many iterations of the loop as we want and will only use a constant amount of storage space.</p>
<p>For a full example of the symmetric-transfer version of the task type see the following Compiler Explorer link: <a href="https://godbolt.org/z/9baieF" target="_blank" rel="noopener">https://godbolt.org/z/9baieF</a>.</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/04/07/rust-borrow-checker/" rel="next" title="Rust 的 Borrow Checker">
                <i class="fa fa-chevron-left"></i> Rust 的 Borrow Checker
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/05/30/C++-allocator/" rel="prev" title="C++ 的 allocator 机制">
                C++ 的 allocator 机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">242</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">152</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Coroutine-Theory"><span class="nav-number">1.</span> <span class="nav-text">Coroutine Theory</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-operator-co-await"><span class="nav-number">2.</span> <span class="nav-text">Understanding operator co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Awaiters-and-Awaitables-Explaining-operator-co-await"><span class="nav-number">2.1.</span> <span class="nav-text">Awaiters and Awaitables: Explaining operator co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Awaitable"><span class="nav-number">2.1.1.</span> <span class="nav-text">Awaitable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Awaiter"><span class="nav-number">2.1.2.</span> <span class="nav-text">Awaiter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-Awaiter"><span class="nav-number">2.2.</span> <span class="nav-text">获取 Awaiter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Awaiting-the-Awaiter"><span class="nav-number">2.3.</span> <span class="nav-text">Awaiting the Awaiter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine-Handles"><span class="nav-number">2.4.</span> <span class="nav-text">Coroutine Handles</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronisation-free-async-code"><span class="nav-number">2.5.</span> <span class="nav-text">Synchronisation-free async code</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Comparison-to-Stackful-Coroutines"><span class="nav-number">2.6.</span> <span class="nav-text">Comparison to Stackful Coroutines</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Avoiding-memory-allocations"><span class="nav-number">2.7.</span> <span class="nav-text">Avoiding memory allocations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#An-example-Implementing-a-simple-thread-synchronisation-primitive"><span class="nav-number">2.8.</span> <span class="nav-text">An example: Implementing a simple thread-synchronisation primitive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Filling-out-the-rest-of-the-event-class"><span class="nav-number">2.9.</span> <span class="nav-text">Filling out the rest of the event class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-the-promise-type"><span class="nav-number">3.</span> <span class="nav-text">Understanding the promise type</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Coroutine-Concepts"><span class="nav-number">3.1.</span> <span class="nav-text">Coroutine Concepts</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-objects"><span class="nav-number">3.2.</span> <span class="nav-text">Promise objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Allocating-a-coroutine-frame"><span class="nav-number">3.3.</span> <span class="nav-text">Allocating a coroutine frame</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Customising-coroutine-frame-memory-allocation"><span class="nav-number">3.3.1.</span> <span class="nav-text">Customising coroutine frame memory allocation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copying-parameters-to-the-coroutine-frame"><span class="nav-number">3.4.</span> <span class="nav-text">Copying parameters to the coroutine frame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constructing-the-promise-object"><span class="nav-number">3.5.</span> <span class="nav-text">Constructing the promise object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Obtaining-the-return-object"><span class="nav-number">3.6.</span> <span class="nav-text">Obtaining the return object</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-initial-suspend-point"><span class="nav-number">3.7.</span> <span class="nav-text">The initial-suspend point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Returning-to-the-caller"><span class="nav-number">3.8.</span> <span class="nav-text">Returning to the caller</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Returning-from-the-coroutine-using-co-return"><span class="nav-number">3.9.</span> <span class="nav-text">Returning from the coroutine using co_return</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Handling-exceptions-that-propagate-out-of-the-coroutine-body"><span class="nav-number">3.10.</span> <span class="nav-text">Handling exceptions that propagate out of the coroutine body</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-final-suspend-point"><span class="nav-number">3.11.</span> <span class="nav-text">The final-suspend point</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#How-the-compiler-chooses-the-promise-type"><span class="nav-number">3.12.</span> <span class="nav-text">How the compiler chooses the promise type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Identifying-a-specific-coroutine-activation-frame"><span class="nav-number">3.13.</span> <span class="nav-text">Identifying a specific coroutine activation frame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Customising-the-behaviour-of-co-await"><span class="nav-number">3.14.</span> <span class="nav-text">Customising the behaviour of co_await</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原因1"><span class="nav-number">3.14.1.</span> <span class="nav-text">原因1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原因2"><span class="nav-number">3.14.2.</span> <span class="nav-text">原因2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原因3"><span class="nav-number">3.14.3.</span> <span class="nav-text">原因3</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Customising-the-behaviour-of-co-yield"><span class="nav-number">3.15.</span> <span class="nav-text">Customising the behaviour of co_yield</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Understanding-Symmetric-Transfer"><span class="nav-number">4.</span> <span class="nav-text">Understanding Symmetric Transfer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#First-some-background-on-how-a-task-coroutine-works"><span class="nav-number">4.1.</span> <span class="nav-text">First some background on how a task coroutine works</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Outline-of-a-task-implementation"><span class="nav-number">4.2.</span> <span class="nav-text">Outline of a task implementation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-task-promise-type"><span class="nav-number">4.3.</span> <span class="nav-text">Implementing task::promise_type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Implementing-task-operator-co-await"><span class="nav-number">4.4.</span> <span class="nav-text">Implementing task::operator co_await()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-stack-overflow-problem"><span class="nav-number">4.5.</span> <span class="nav-text">The stack-overflow problem</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-Coroutines-TS-solution"><span class="nav-number">4.6.</span> <span class="nav-text">The Coroutines TS solution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#The-problems"><span class="nav-number">4.7.</span> <span class="nav-text">The problems</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Enter-“symmetric-transfer”"><span class="nav-number">4.8.</span> <span class="nav-text">Enter “symmetric transfer”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tail-calls"><span class="nav-number">4.9.</span> <span class="nav-text">Tail-calls</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#task-revisited"><span class="nav-number">4.10.</span> <span class="nav-text">task revisited</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Visualising-the-stack"><span class="nav-number">4.11.</span> <span class="nav-text">Visualising the stack</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2024/05/26/C++-coroutine/';
          this.page.identifier = '2024/05/26/C++-coroutine/';
          this.page.title = 'C++ Coroutine 介绍的翻译';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
