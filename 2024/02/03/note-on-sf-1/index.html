<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Coq," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="https://github.com/CalvinNeo/SF-zh 做题笔记。">
<meta name="keywords" content="Coq">
<meta property="og:type" content="article">
<meta property="og:title" content="Software Foundation 做题的 Notes">
<meta property="og:url" content="http://www.calvinneo.com/2024/02/03/note-on-sf-1/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="https://github.com/CalvinNeo/SF-zh 做题笔记。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2024-03-08T15:07:58.086Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Software Foundation 做题的 Notes">
<meta name="twitter:description" content="https://github.com/CalvinNeo/SF-zh 做题笔记。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2024/02/03/note-on-sf-1/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>Software Foundation 做题的 Notes | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2024/02/03/note-on-sf-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Software Foundation 做题的 Notes
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2024-02-03T19:46:32+08:00">
                2024-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://github.com/CalvinNeo/SF-zh" target="_blank" rel="noopener">https://github.com/CalvinNeo/SF-zh</a> 做题笔记。</p>
<a id="more"></a>

<h1 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h1><p>intro 和 intros 会按顺序将命题中的 forall 里面的，和 <code>-&gt;</code> 左边的按照顺序移动下来作为假设。</p>
<p>reflexivity 相当于是化简等号两边，看是否相等。</p>
<p><code>rewrite -&gt; H</code> 是用 H 改写 goal 右边的部分，可以被简写为 <code>rewrite H</code>。<code>rewrite &lt;- H</code> 则是从右到左改写。</p>
<p>有个证明 <code>andb b c = true -&gt; c = true</code> 的看起来挺奇怪的，但实际上后面可以用 discriminate 来证明。</p>
<h1 id="Induction"><a href="#Induction" class="headerlink" title="Induction"></a>Induction</h1><p>Coq 中 induction 的归纳，不是数学归纳，而是根据构造函数归纳。比如皮亚诺自然数就有两个构造函数 S 和 O。</p>
<h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><h1 id="Poly"><a href="#Poly" class="headerlink" title="Poly"></a>Poly</h1><p>一般证明一些结论，用到 induction 的时候，会用某个操作符对某个操作符的分配率。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plus_n_Sm: <span class="keyword">forall</span> n m : nat, S (n + m) = n + S m</span><br><span class="line">plus_Sn_m: <span class="keyword">forall</span> n m : nat, S n + m = S (n + m)</span><br></pre></td></tr></table></figure>

<p>其目的是用分配率，把“递推”条件里面的部分给拆掉，一部分用 <code>IHl&#39;</code> 直接 apply 过去，剩下来一部分是比较简单处理的。<br>对 list 而言，就是证明各种函数，如 length、rev 和 ++ 之间的关系。</p>
<h1 id="Tactic"><a href="#Tactic" class="headerlink" title="Tactic"></a>Tactic</h1><p>这里 <code>apply eq2. apply eq1</code> 好像三段论一样，eq2 是大前提，eq1 是小前提。 </p>
<p><code>apply</code> 类似于反过来推。<code>apply H</code>，如果 <code>H</code> 是 <code>x = y</code>，则可以进行代入的改写，这不是很直观。但如果 <code>H</code> 是 <code>x -&gt; y</code> 这样，就可以将 <code>y</code> 这样的 goal 改写成 <code>x</code>，这就类似于是倒推了。<br>要使用 apply 策略，被应用的事实（的结论）必须精确地匹配证明目标。甚至等号反一下都不行，需要 symmetry 倒过来。<br><code>apply x in H</code> 类似于正过来推。它是把 x 应用到假设 H 而不是 goal 上。具体来说，[apply L in H] 会针对上下文中的假设 [H] 匹配某些形如 [X -&gt; Y] 的条件语句 [L]。[apply L in H] 会针对 [X] 匹配 [H]，如果成功，就将其替换为 [Y]。简而言之，就还是用 L 改写，但是改写 H 了。</p>
<p>同理，<code>simpl in H</code> 也是简化假设 H 而不是 goal。同理，也有 <code>rewrite ... in H</code> 来改写前提。</p>
<p><code>apply x with (m:=xxx)</code>，也就是帮助 apply 选择把 <code>m</code> 代成是什么。这里我不太清楚如果有多个 forall 如何逐个指定。但另外有一种方式是 pose proof。</p>
<p><code>injection</code> 是利用单射的性质。能方便的证明 <code>S n = S m -&gt; n = m</code> 这样的命题。在 evSS_ev_remember 中也能看到有使用处理 <code>S (S n&#39;) = S (S n)</code>。主要目的还是用来去掉包在外面的上下文。<br>通过编写 <code>injection H as Hmn1 Hmn2</code> 这样，我们让 Coq 利用构造子的单射性来产生所有它能从 H 所推出的等式。 每一个这样的等式都作为假设被添加到上下文中。</p>
<p><code>discriminate</code> 用来处理 <code>False -&gt; P</code> 这样的问题。也就是后面提到的 ex_falso_quodlibet，爆炸原理。</p>
<p><code>plus_n_n_injective</code> 的证明很 tricky，我有几种方式都不太证得了，不知道为啥。</p>
<p><code>eqb_true</code> 里面 <code>intros [] eq</code> 和 <code>intros m eq</code> 是有区别的。</p>
<p><code>intros</code> 有个问题是，它始终是按照顺序引入的。如果我 <code>intros n m</code>，但我只想对 m 归纳，继续 forall n，那就需要 <code>generalize dependent n</code> 这样把 n 再还回去。<br><code>intros</code> 另一个问题是，如果多引入了假设，或者少引入了假设，会导致后面处理会比较奇怪。所以一般直接 <code>intros</code>，看自己要用哪些。</p>
<p>用 <code>unfold</code> 展开定义。同理也有 <code>unfold... in H</code>。类似的展开方法还有 destruct。如 <code>silly_fact_2</code> 中举的例子一样，可以用 destruct 把用 match 讨论的 bar 函数的各个构造函数 destruct 出来讨论。</p>
<p>可以使用 <code>destruct (n =? 3) eqn:E1</code> 这样对表达式的结果进行讨论。</p>
<p>本文中最后总结了已有的一些策略。</p>
<h2 id="一些-case"><a href="#一些-case" class="headerlink" title="一些 case"></a>一些 case</h2><p>split 可以使用 match 做一个单 arm 的 destruct。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> combine_split : <span class="keyword">forall</span> X Y (l : list (X * Y)) l1 l2,</span><br><span class="line">  <span class="built_in">split</span> l = (l1, l2) -&gt;</span><br><span class="line">  combine l1 l2 = l.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> tx ty l.</span><br><span class="line">  <span class="built_in">induction</span> l <span class="built_in">as</span> [| <span class="type">h</span> t IH].</span><br><span class="line">  - <span class="built_in">simpl</span>. <span class="built_in">intros</span> l1 l2 H. <span class="built_in">simpl</span> <span class="built_in">in</span> H. <span class="built_in">inversion</span> H. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="built_in">intros</span> r1 r2 H.</span><br><span class="line">    <span class="built_in">destruct</span> h.</span><br><span class="line">    <span class="built_in">destruct</span> (<span class="built_in">split</span> t) eqn: E.</span><br></pre></td></tr></table></figure>

<p>下面就引入了多余的 <code>n&#39;</code></p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> mult_assoc : <span class="keyword">forall</span> n m p : nat,</span><br><span class="line">  n * (m * p) = (n * m) * p.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n.</span><br><span class="line">  <span class="built_in">induction</span> n <span class="built_in">as</span> [| <span class="type">n</span>' IHn] eqn: eq1.</span><br><span class="line">  - <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="built_in">simpl</span>. <span class="built_in">intros</span> m p.</span><br><span class="line">    <span class="built_in">assert</span> (H3: (m + n' * m) * p = m * p + n' * m * p).</span><br><span class="line">    <span class="built_in">apply</span> mult_plus_distr_r.</span><br><span class="line">    <span class="built_in">rewrite</span> H3.</span><br></pre></td></tr></table></figure>

<h1 id="Logic"><a href="#Logic" class="headerlink" title="Logic"></a>Logic</h1><p>本章开始提到了之前证明了很多 <code>a = b</code>、<code>a -&gt; b</code> 和 <code>forall x, P x</code> 的命题。<br>表达式 n = m 只是 eq n m 的语法糖（它使用 Notation 机制定义在 Coq 标准库中）。由于 eq 可被用于任何类型的元素，因此它也是多态的。</p>
<p>遇到 <code>\/</code> 作为条件，可以 destruct H as [H1 | H2]，产生两个 subgoal。然后用 bullet 去讨论。也可以直接 intros [H1 | H2] 甚至 intros [H | H]。<br>遇到 <code>\/</code> 作为 goal，可以用 left 或者 right 选择要证明哪一边。<br>遇到 <code>/\</code> 作为条件，可以用 destruct 分离成两个条件。<br>遇到 <code>/\</code> 作为 goal，需要用 split 将它分开成两个 subgoal，用 bullet 组织。</p>
<p>在 ex_falso_quodlibet 的证明中，会发现有的时候 False 出现在条件中，这个时候只需要 destruct 这个条件就可以了。如 <code>destruct contra</code>。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">P : <span class="keyword">Prop</span></span><br><span class="line">contra : False</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">P</span><br></pre></td></tr></table></figure>

<p>如果在条件中出现 <code>P -&gt; False</code>，但 goal 是 <code>P</code>，则可以使用 exfalso。我感觉好像他的作用是把 goal 变成 False。</p>
<p>一个诸如 H : exists x : A, f x = y /\ In x t 这样的条件，可以被 destruct 为 [w [h1 h2]] 这样。此时 w 就是这个 x。可以直接假设 exists w。</p>
<p>对于后面的排中律系列，在 <code>(P \/ P -&gt; False)</code> 时，建议选择 right，因为 right 会得到一个 P 的假设。</p>
<p><a href="https://stackoverflow.com/questions/77949233/why-i-cant-use-exact-p-if-p-is-a-prop" target="_blank" rel="noopener">注意</a><br>1.P : Prop means “let P be an arbitrary proposition”. It could be true, it could be false.<br>2.p : P means “let p be a proof of P”. That’s what means that P is true.</p>
<h2 id="对映"><a href="#对映" class="headerlink" title="对映"></a>对映</h2><p>我们可以通过以下两种方式来断言 n 为偶数：<br>evenb n 求值为 true</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> even_42_bool : evenb <span class="number">42</span> = true.</span><br></pre></td></tr></table></figure>

<p>或者存在某个 k 使得 n = double k</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span> even_42_prop : even <span class="number">42.</span></span><br></pre></td></tr></table></figure>

<p>解释了之前为什么要证明一个很奇怪的什么 eqb_true 的东西。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> eqb_true : <span class="keyword">forall</span> n m,</span><br><span class="line">    n =? m = true -&gt; n = m.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line"><span class="built_in">intro</span> n. <span class="built_in">induction</span> n <span class="built_in">as</span> [| <span class="type">n</span>' IHn'].</span><br><span class="line">  - <span class="built_in">intro</span> m. <span class="built_in">induction</span> m <span class="built_in">as</span> [| <span class="type">m</span>' IHm'].</span><br><span class="line">    + <span class="built_in">reflexivity</span>.</span><br><span class="line">    + <span class="built_in">discriminate</span>.</span><br><span class="line">  - <span class="built_in">intros</span> m eq. <span class="built_in">induction</span> m <span class="built_in">as</span> [| <span class="type">m</span>' IHm'].</span><br><span class="line">    + <span class="built_in">simpl</span>. <span class="built_in">discriminate</span>.</span><br><span class="line">    + <span class="built_in">apply</span> <span class="built_in">f_equal</span>. <span class="built_in">apply</span> IHn'. <span class="built_in">apply</span> eq.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h2 id="一些-case-1"><a href="#一些-case-1" class="headerlink" title="一些 case"></a>一些 case</h2><p>In_map_iff 的思路是考虑 H 的话，如果 y = x 则是另外的情况，否则 y 在 l 里面。就可以 destruct 出来，一部分匹配 IHl。<br>另外，下面的 <code>intros [H | H]</code> 的意思是把 <code>f h = y \/ In y (map f t) -&gt;</code> 引入，但生成两个 subgoal。第一个 goal 是对 <code>f h = y</code> 证明成立，第二个是对 <code>In y (map f t)</code> 成立。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> In_map_iff :</span><br><span class="line">  <span class="keyword">forall</span> (A B : <span class="keyword">Type</span>) (f : A -&gt; B) (l : list A) (y : B),</span><br><span class="line">    In y (map f l) &lt;-&gt;</span><br><span class="line">    <span class="built_in">exists</span> x, f x = y /\ In x l.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B f l y. <span class="built_in">split</span>.</span><br><span class="line">  <span class="built_in">induction</span> l <span class="built_in">as</span> [| <span class="type">h</span> t IHl].</span><br><span class="line">  - <span class="built_in">simpl</span>. <span class="built_in">intros</span>. <span class="built_in">destruct</span> H.</span><br><span class="line">  <span class="comment">(* In y (map f (h :: t)) -&gt; exists x : A, f x = y /\ In x (h :: t) *)</span></span><br><span class="line">  - <span class="built_in">simpl</span>. <span class="built_in">intros</span> [H | <span class="type">H</span>].</span><br><span class="line">    + <span class="built_in">exists</span> h. <span class="built_in">simpl</span>. <span class="built_in">split</span>.</span><br><span class="line">      * <span class="built_in">apply</span> H.</span><br><span class="line">      * <span class="built_in">left</span>. <span class="built_in">reflexivity</span>.</span><br><span class="line">    <span class="comment">(* f x != y *)</span></span><br><span class="line">    + <span class="built_in">apply</span> IHl <span class="built_in">in</span> H. <span class="built_in">destruct</span> H <span class="built_in">as</span> [w [h1 h2]].</span><br><span class="line">      <span class="comment">(* now H is useable *)</span></span><br><span class="line">      <span class="built_in">exists</span> w. <span class="built_in">split</span>.</span><br><span class="line">      * <span class="built_in">apply</span> h1.</span><br><span class="line">      * <span class="built_in">right</span>. <span class="built_in">apply</span> h2.</span><br><span class="line">  <span class="comment">(* (exists x : A, f x = y /\ In x l) -&gt; In y (map f l) *)</span></span><br><span class="line">  - <span class="built_in">intros</span> [w [h1 h2]].</span><br><span class="line">    <span class="built_in">rewrite</span> &lt;- h1. <span class="built_in">apply</span> In_map. <span class="built_in">exact</span> h2.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>另外，下面这个目标中的 x = x 如何被 simpl 掉？似乎没办法执行。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Lemma</span> In_map_iff2 :</span><br><span class="line">  <span class="keyword">forall</span> (A B : <span class="keyword">Type</span>) (f : A -&gt; B) (l : list A) (y : B),</span><br><span class="line">    In y (map f l) &lt;-&gt;</span><br><span class="line">    <span class="built_in">exists</span> x, f x = y /\ In x l.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> A B f l y. <span class="built_in">split</span>.</span><br><span class="line">    <span class="built_in">induction</span> l.</span><br><span class="line">    - <span class="built_in">simpl</span>. <span class="built_in">intros</span>. <span class="built_in">destruct</span> H.</span><br><span class="line">    - <span class="built_in">intros</span>. <span class="built_in">simpl</span>. <span class="built_in">exists</span> x. <span class="built_in">split</span>.</span><br><span class="line">      <span class="built_in">destruct</span> H. <span class="built_in">apply</span> H. <span class="built_in">apply</span> IHl <span class="built_in">in</span> H.</span><br><span class="line">      + <span class="built_in">admit</span>.</span><br><span class="line">      + <span class="built_in">simpl</span>.</span><br></pre></td></tr></table></figure>

<p>对应的 goal 如下</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">A : <span class="keyword">Type</span></span><br><span class="line">B : <span class="keyword">Type</span></span><br><span class="line">f : A -&gt; B</span><br><span class="line">x : A</span><br><span class="line">l : list A</span><br><span class="line">y : B</span><br><span class="line">IHl : In y (map f l) -&gt; <span class="built_in">exists</span> x : A, f x = y /\ In x l</span><br><span class="line">H : In y (map f (x :: l))</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">f x = y /\ (x = x \/ In x l)</span><br></pre></td></tr></table></figure>

<p>下面这里的 apply H 我觉得比较有意思。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> excluded_middle_2_double_negation_elimination :</span><br><span class="line">  excluded_middle &lt;-&gt; double_negation_elimination.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">split</span>.</span><br><span class="line">  - <span class="built_in">unfold</span> excluded_middle.</span><br><span class="line">    <span class="built_in">unfold</span> double_negation_elimination.</span><br><span class="line">    <span class="built_in">unfold</span> not.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="built_in">destruct</span> (H P).</span><br><span class="line">    + <span class="built_in">apply</span> H1.</span><br><span class="line">    + <span class="built_in">exfalso</span>. <span class="built_in">apply</span> H1. <span class="built_in">apply</span> H0 <span class="built_in">in</span> H1. <span class="built_in">destruct</span> H1.</span><br><span class="line">  - <span class="built_in">unfold</span> excluded_middle.</span><br><span class="line">    <span class="built_in">unfold</span> double_negation_elimination.</span><br><span class="line">    <span class="built_in">unfold</span> not.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="comment">(* Get rid of forall *)</span></span><br><span class="line">    <span class="built_in">apply</span> H.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="built_in">apply</span> H0.</span><br><span class="line">    <span class="built_in">right</span>. <span class="built_in">intros</span>. <span class="built_in">apply</span> H0. <span class="built_in">left</span>. <span class="built_in">apply</span> H1.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p>当时的 goal 是</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">H : <span class="keyword">forall</span> P : <span class="keyword">Prop</span>, ((P -&gt; False) -&gt; False) -&gt; P</span><br><span class="line">P : <span class="keyword">Prop</span></span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">P \/ (P -&gt; False)</span><br></pre></td></tr></table></figure>

<p>容易想到的是 left 或者 right 这样。但会陷入循环。比如我 <code>left. apply H. apply H. apply H0. apply H.</code>，最终是回到了最初的起点了。但是 apply H 完了之后，就得到</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(P \/ (P -&gt; False) -&gt; False) -&gt; False</span><br></pre></td></tr></table></figure>

<p>如果我 right. apply H. intros. apply H0. intros. apply H in H1. 就会得到如下的形式。我们不能 apply H in H1，因为这会得到什么呢？注意，这里是前向 apply 了，我们用 P 代换得不到sm东西。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">H : <span class="keyword">forall</span> P : <span class="keyword">Prop</span>, ((P -&gt; False) -&gt; False) -&gt; P</span><br><span class="line">P : <span class="keyword">Prop</span></span><br><span class="line">H0 : (P -&gt; False) -&gt; False</span><br><span class="line">H1 : P</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>这个应该是用 <code>((P -&gt; False) -&gt; False)</code> 代换了原来 goal 中的两处 P，然后再利用各种结合率啥的重新组合得到的。所以我觉得如果有 forall P : Prop, … -&gt; P 这样的东西，右边很简单的，不如大胆做个代换。</p>
<p>我们会遇到如 andb_true_iff 或者 ev5_nonsense 这样的，给一堆条件，证明 <code>false = true</code> 或者 <code>ev 5 -&gt; 2 + 2 = 9</code> 这样奇怪的命题。我们要做的并不是去 discriminate 掉 goal，而是要在条件中构造出一个 False，然后通过爆炸原理来证明。这里我觉得主要是，如果假设中能退出 True，那实际上是要证明 True -&gt; False，这个命题实际上是错误的。</p>
<p>另外，在 andb_true_iff  中需要注意 False 和 false 的区别。False 的定义是</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> False : <span class="keyword">Prop</span> :=  .</span><br></pre></td></tr></table></figure>

<p>而 false 只是我们定义的 bool 类型的一个构造函数。而 False 是一个 type，或者一个 proposition。所以无法证明 (false = true) = false。相应的，我们应该证明 <code>false = true &lt;-&gt; False</code>。</p>
<p><a href="https://stackoverflow.com/questions/77957169/how-can-i-handle-this-false-true-case/77974227#77974227" target="_blank" rel="noopener">另一个回答说</a>，他说 falsehood 通常的构造办法：<br>1.假设从一个空集中去一个值，这个值就不能被创造出来<br>2.两个值从不同的构造函数中构造出来的值是相同的，而凑早函数被认为是 injective 的。<br>比如，如果假设中有 <code>H: False</code> 我们可以 destruct H。如果假设中有 <code>false = true</code>，那么就可以 inversion。</p>
<h2 id="承认排中律"><a href="#承认排中律" class="headerlink" title="承认排中律"></a>承认排中律</h2><p>不需要排中律即可证明 <code>double_neg</code> 即 <code>P -&gt; ~~P</code>。但是反过来的 <code>~~P -&gt; P</code> 则需要排中律来证明。其实 <code>~~P -&gt; P</code> 感觉就是反证法。</p>
<p><code>~~(P \/ ~P)</code> 可以被证明，但 <code>P \/ ~P</code> 排中律则依赖选择公理。为什么前者可以被证明呢？因为我们不能同时证明 <code>P \/ ~P</code> 和证伪 <code>P \/ ~P</code>。这样 <code>(P \/ ~P)</code> 和 <code>~(P \/ ~P)</code> 不能同时为真。因为 <code>forall P: Prop, P -&gt; ~~P</code>，所以 <code>~~(P \/ ~P)</code> 和 <code>~(P \/ ~P)</code> 不能同时为真。</p>
<p><code>~~(P \/ ~P)</code> 的证明流程。unfold 去掉 not，得到的 goal 是 <code>forall P : Prop, (P \/ (P -&gt; False) -&gt; False) -&gt; False</code>。好像是证明 “<code>P \/ (P -&gt; False)</code> 是不可能的”是不可能的。intros 把 <code>P \/ (P -&gt; False) -&gt; False</code> 作为假设，goal 变成 False。这里发现可以进一步 apply 这个假设，替换到如下的形式</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">P : <span class="keyword">Prop</span></span><br><span class="line">H : P \/ (P -&gt; False) -&gt; False</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">P \/ (P -&gt; False)</span><br></pre></td></tr></table></figure>

<p>看起来好像是承认 Q -&gt; False 的情况下，反过来证明 Q 成立？继续证明。现在是给定 <code>H : P \/ (P -&gt; False) -&gt; False</code> 要证明 <code>P \/ (P -&gt; False)</code>。假设 P -&gt; False 成立，用 intros，假设 P 成立，证明 False。而已知条件是 <code>P \/ (P -&gt; False) -&gt; False</code>，不如再假设 P 成立，然后证明 <code>P \/ (P -&gt; False)</code>。</p>
<p>排中律本身和其他一些定理可以串起来形成一个证明的圈。这个和实数那几个的定理一样。</p>
<h1 id="InductionProp"><a href="#InductionProp" class="headerlink" title="InductionProp"></a>InductionProp</h1><p>之前，我们定义偶数一般是使用 nat。但现在介绍用 nat -&gt; Prop 这样的形式来定义偶数 ev。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Inductive</span> ev : nat -&gt; <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">ev_0</span> : ev <span class="number">0</span></span><br><span class="line">| <span class="type">ev_SS</span> (n : nat) (H : ev n) : ev (S (S n)).</span><br></pre></td></tr></table></figure>

<p>注意，另一种方式会出错，也就是将 nat 放到 <code>:</code> 的左侧。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Fail <span class="keyword">Inductive</span> wrong_ev (n : nat) : <span class="keyword">Prop</span> :=</span><br><span class="line">| <span class="type">wrong_ev_0</span> : wrong_ev <span class="number">0</span></span><br><span class="line">| <span class="type">wrong_ev_SS</span> (H: wrong_ev n) : wrong_ev (S (S n)).</span><br></pre></td></tr></table></figure>

<ul>
<li>We already know how to perform case analysis on <code>n</code> using destruct or induction</li>
<li>But for some proofs we may instead want to analyze the evidence that <code>ev n</code> directly<br>这是因为如果某人展示了对于 [ev n] 的 evidence [E]，那么我们知道 [E] 要么从 ev_0 来的，要么从 ev_SS 来的。<br>一个反演命题。这个命题是对 ev 这个判断奇偶性的命题而言的。对这个命题直接使用 induction 是搞不定的，因为<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev_inversion :</span><br><span class="line">  <span class="keyword">forall</span> (n : nat), ev n -&gt;</span><br><span class="line">    (n = <span class="number">0</span>) \/ (<span class="built_in">exists</span> n', n = S (S n') /\ ev n').</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n E.</span><br><span class="line">  <span class="built_in">destruct</span> E <span class="built_in">as</span> [ | <span class="type">n</span>' E'].</span><br><span class="line">  - <span class="comment">(* E = ev_0 : ev 0 *)</span></span><br><span class="line">    <span class="built_in">left</span>. <span class="built_in">reflexivity</span>.</span><br><span class="line">  - <span class="comment">(* E = ev_SS n' E' : ev (S (S n')) *)</span></span><br><span class="line">    <span class="built_in">right</span>. <span class="built_in">exists</span> n'. <span class="built_in">split</span>. <span class="built_in">reflexivity</span>. <span class="built_in">apply</span> E'.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure></li>
</ul>
<p>The [inversion] tactic can detect that:<br>1.the first case ([n =0]) does not apply<br>2.the [n’] that appears in the [ev_SS] case must be the same as [n].  </p>
<p>It has an “[as]” variant similar to [destruct], allowing us to assign names rather than have Coq choose them.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> evSS_ev' : <span class="keyword">forall</span> n,</span><br><span class="line">  ev (S (S n)) -&gt; ev n.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> n E.</span><br><span class="line">  <span class="built_in">inversion</span> E <span class="built_in">as</span> [| <span class="type">n</span>' E' EQ].</span><br><span class="line">  <span class="comment">(* We are in the [E = ev_SS n' E'] case now. *)</span></span><br><span class="line">  <span class="built_in">apply</span> E'.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<p><code>inversion</code> 策略会做很多东西，比如如果对一个等式使用，就相当于 discriminate 加上 injection。另外，它还会带上使用 injection 可能必须的 intros 和 rewrite。它还可以被 apply，去 analyze evident for inductively defined 命题。下面会用 inversion 来尝试证明 Tactics 章节中涉及的一些定理。</p>
<p>[inversion] 的工作原理大致如下：假设 [H] 指代上下文中的假设 [P]，且 [P] 由 [Inductive] 归纳定义，则对于 [P] 每一种可能的构造，[inversion H] 各为其生成子目标。子目标中自相矛盾者被忽略，证明其余子命题即可得证原命题。<br>在证明子目标时，上下文中的 [H] 会替换为 [P] 的构造条件，即其构造子所需参数以及必要的等式关系。例如：倘若 [ev n] 由 [ev_SS] 构造，上下文中会引入参数 [n’]、[ev n’]，以及等式 [S (S n’) = n]。</p>
<p>下面，是另一个问题。为了证明 [n] 的性质对于 [ev n] 成立的所有数字都成立。我们需要在 [ev n] 上 induction。证明分为两块，和 [ev n] 的两个构造函数对应。如果他通过 [ev_0] 构造，则 n = 0，那么性质肯定对 [0] 成立。如果他通过 [ev_SS] 构造，那么 [ev n] 的证据就具有形式 [en_SS n’ E’]，其中 [n = S (S n’)] ，[E’] 是 [eb n’] 的证据。这样，the inductive hypothesis says that the property we are trying to prove holds for [n’]。</p>
<p>注意，这里的 <code>exists (S k&#39;).</code> 来自于 ev 的定义，我们这里没有展开 ev。</p>
<p>从 le 的定义来看，可以总结出 destruct、inversion 和 induction 三种策略在 H: le e1 e2 上的作用。destruct H 能够产生两个 case。第一个 case 中 destruct H 产生两个情况，第一个是 e1 = e2，此时 e2 被 e1 替换掉。在第二个 case 中，e2 = S n’，并且对于某个 n’ 有 le e1 n’ 成立，并且用 S n’ 替换 e2。inversion H 会移除不可能的 case，并且将生成的新的等式添加到上下文中。执行 induction H，在第二种情况下，会将 induction hypothesis 的 e2 用 n’ 替换。</p>
<h2 id="具体-case"><a href="#具体-case" class="headerlink" title="具体 case"></a>具体 case</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> ev'_ev_try1 : <span class="keyword">forall</span> n, ev' n &lt;-&gt; ev n.</span><br><span class="line"></span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span>.</span><br><span class="line">  <span class="built_in">split</span>.</span><br><span class="line">  - <span class="built_in">induction</span> n.</span><br><span class="line">    + <span class="built_in">intros</span>. <span class="built_in">apply</span> ev_0.</span><br><span class="line">    + <span class="built_in">simpl</span>. <span class="keyword">Abort</span>.</span><br></pre></td></tr></table></figure>

<p>对应的 goal 如下，S n 肯定对 ev’ 啥的不成立了啊。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> goal</span><br><span class="line">n : nat</span><br><span class="line">IHn : ev' n -&gt; ev n</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">ev' (S n) -&gt; ev (S n)</span><br></pre></td></tr></table></figure>

<p>这里和 le_trans 相关的命题都是放缩法。遇到 S n，就通过 le_S 去掉 S。但是放缩法要符合情理。比如 n_le_m__Sn_le_Sm 里面就不能从 S n &lt;= S m 放缩到 S n &lt;= m。<br>要从 H : S n &lt;= 1 推导 n &lt;= 0，可以 inversion H。从 H1 : S n &lt;= 0 推 n &lt;= 0，也可以 inversion。感觉总的来说，inversion 是将一个更强的条件去分解为多个较弱的条件。<br>这里一个问题是不能用 injection 解决S n &lt;= S (S m) 推导 n &lt;= S m。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> le_S_ab2_try : <span class="keyword">forall</span> a b,</span><br><span class="line">  S a &lt;= b -&gt; a &lt;= b.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a b. </span><br><span class="line">  <span class="built_in">induction</span> a.</span><br><span class="line">  - <span class="built_in">intros</span>. <span class="built_in">inversion</span> H.</span><br><span class="line">    <span class="built_in">apply</span> le_S. <span class="built_in">apply</span> le_n. <span class="built_in">apply</span> O_le_n.</span><br><span class="line">  - <span class="built_in">intros</span>. <span class="built_in">inversion</span> H.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> goals</span><br><span class="line">a, b : nat</span><br><span class="line">IHa : S a &lt;= b -&gt; a &lt;= b</span><br><span class="line">H : S (S a) &lt;= b</span><br><span class="line">H0 : S (S a) = b</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">2</span>)</span><br><span class="line">S a &lt;= S (S a)</span><br><span class="line">______________________________________(<span class="number">2</span>/<span class="number">2</span>)</span><br><span class="line">S a &lt;= S m</span><br></pre></td></tr></table></figure>

<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> le_S_ab2 : <span class="keyword">forall</span> a b,</span><br><span class="line">  S a &lt;= b -&gt; a &lt;= b.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">  <span class="built_in">intros</span> a b. </span><br><span class="line">  <span class="built_in">generalize</span> <span class="built_in">dependent</span> a.</span><br><span class="line">  <span class="built_in">induction</span> b.</span><br><span class="line">  - <span class="built_in">intros</span>. <span class="built_in">inversion</span> H.</span><br><span class="line">  - <span class="built_in">intros</span>. <span class="built_in">inversion</span> H. <span class="built_in">apply</span> le_S. <span class="built_in">apply</span> le_n.</span><br><span class="line">    <span class="built_in">apply</span> le_S. <span class="built_in">apply</span> IHb. <span class="built_in">apply</span> H1.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> goals</span><br><span class="line">b : nat</span><br><span class="line">IHb : <span class="keyword">forall</span> a : nat, S a &lt;= b -&gt; a &lt;= b</span><br><span class="line">a : nat</span><br><span class="line">H : S a &lt;= S b</span><br><span class="line">H1 : a = b</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">2</span>)</span><br><span class="line">b &lt;= S b</span><br><span class="line">______________________________________(<span class="number">2</span>/<span class="number">2</span>)</span><br><span class="line">a &lt;= S b</span><br></pre></td></tr></table></figure>

<p>比较有意思的是这里又找到一个必须要 apply with 的结构</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> add_le_cases : <span class="keyword">forall</span> n m p q,</span><br><span class="line">    n + m &lt;= p + q -&gt; n &lt;= p \/ m &lt;= q.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="built_in">generalize</span> <span class="built_in">dependent</span> p.</span><br><span class="line">    <span class="built_in">induction</span> n. <span class="built_in">left</span>. <span class="built_in">apply</span> O_le_n.</span><br><span class="line">    <span class="built_in">intros</span>. <span class="built_in">destruct</span> p.</span><br><span class="line">    * <span class="built_in">right</span>. <span class="built_in">rewrite</span> plus_O_n <span class="built_in">in</span> H. <span class="built_in">apply</span> le_S_ab2.</span><br><span class="line">      <span class="built_in">apply</span> add_le_cases_helper.</span><br><span class="line"></span><br><span class="line">Unable to find an instance <span class="keyword">for</span> the variable n.</span><br></pre></td></tr></table></figure>

<p>另一个启发是不要过早地使用 left 或者 right 策略。会出现如下所示的问题，我们的条件和 goal 是不相关的。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> add_le_cases : <span class="keyword">forall</span> n m p q,</span><br><span class="line">    n + m &lt;= p + q -&gt; n &lt;= p \/ m &lt;= q.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="built_in">generalize</span> <span class="built_in">dependent</span> p.</span><br><span class="line">    <span class="built_in">induction</span> n. <span class="built_in">left</span>. <span class="built_in">apply</span> O_le_n.</span><br><span class="line">    <span class="built_in">intros</span>. <span class="built_in">destruct</span> p.</span><br><span class="line">    * <span class="built_in">right</span>. <span class="built_in">rewrite</span> plus_O_n <span class="built_in">in</span> H. <span class="built_in">apply</span> le_S_ab2.</span><br><span class="line">      <span class="built_in">apply</span> add_le_cases_helper <span class="built_in">with</span> (n:=n). <span class="built_in">exact</span> H.</span><br><span class="line">    * <span class="built_in">left</span>. <span class="built_in">simpl</span> <span class="built_in">in</span> H. <span class="built_in">apply</span> add_le_helper2 <span class="built_in">in</span> H. <span class="built_in">apply</span> IHn <span class="built_in">in</span> H.</span><br><span class="line">      <span class="built_in">destruct</span> H.</span><br><span class="line">      - <span class="built_in">apply</span> n_le_m__Sn_le_Sm. <span class="built_in">exact</span> H.</span><br><span class="line">      - </span><br><span class="line"><span class="number">1</span> goal</span><br><span class="line">n, m, q : nat</span><br><span class="line">IHn : <span class="keyword">forall</span> p : nat, n + m &lt;= p + q -&gt; n &lt;= p \/ m &lt;= q</span><br><span class="line">p : nat</span><br><span class="line">H : m &lt;= q</span><br><span class="line">______________________________________(<span class="number">1</span>/<span class="number">1</span>)</span><br><span class="line">S n &lt;= S p</span><br></pre></td></tr></table></figure>

<p>其实在第二个目标中，不要那么早使用 left 策略，而是先想办法 destruct H，根据 destruct 得到的条件选择是 left 还是 right 就能解决问题了。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Theorem</span> add_le_cases : <span class="keyword">forall</span> n m p q,</span><br><span class="line">    n + m &lt;= p + q -&gt; n &lt;= p \/ m &lt;= q.</span><br><span class="line"><span class="keyword">Proof</span>.</span><br><span class="line">    <span class="built_in">intros</span>.</span><br><span class="line">    <span class="built_in">generalize</span> <span class="built_in">dependent</span> p.</span><br><span class="line">    <span class="built_in">induction</span> n. <span class="built_in">left</span>. <span class="built_in">apply</span> O_le_n.</span><br><span class="line">    <span class="built_in">intros</span>. <span class="built_in">destruct</span> p.</span><br><span class="line">    * <span class="built_in">right</span>. <span class="built_in">rewrite</span> plus_O_n <span class="built_in">in</span> H. <span class="built_in">apply</span> le_S_ab2.</span><br><span class="line">      <span class="built_in">apply</span> add_le_cases_helper <span class="built_in">with</span> (n:=n). <span class="built_in">exact</span> H.</span><br><span class="line">    * <span class="built_in">simpl</span> <span class="built_in">in</span> H. <span class="built_in">apply</span> add_le_helper2 <span class="built_in">in</span> H. <span class="built_in">apply</span> IHn <span class="built_in">in</span> H.</span><br><span class="line">      <span class="built_in">destruct</span> H.</span><br><span class="line">      - <span class="built_in">left</span>. <span class="built_in">apply</span> n_le_m__Sn_le_Sm. <span class="built_in">exact</span> H.</span><br><span class="line">      - <span class="built_in">right</span>. <span class="built_in">exact</span> H.</span><br><span class="line"><span class="keyword">Qed</span>.</span><br></pre></td></tr></table></figure>

<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://coq.inria.fr/doc/V8.13+beta1/refman/proofs/writing-proofs/rewriting.html" target="_blank" rel="noopener">https://coq.inria.fr/doc/V8.13+beta1/refman/proofs/writing-proofs/rewriting.html</a><br> 介绍 rewrite</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Coq/" rel="tag"># Coq</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2024/01/31/ghost_cell/" rel="next" title="GhostCell">
                <i class="fa fa-chevron-left"></i> GhostCell
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2024/02/10/on_zfc/" rel="prev" title="ZFC 公理系统">
                ZFC 公理系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">247</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">153</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Basic"><span class="nav-number">1.</span> <span class="nav-text">Basic</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Induction"><span class="nav-number">2.</span> <span class="nav-text">Induction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lists"><span class="nav-number">3.</span> <span class="nav-text">Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Poly"><span class="nav-number">4.</span> <span class="nav-text">Poly</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Tactic"><span class="nav-number">5.</span> <span class="nav-text">Tactic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#一些-case"><span class="nav-number">5.1.</span> <span class="nav-text">一些 case</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Logic"><span class="nav-number">6.</span> <span class="nav-text">Logic</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对映"><span class="nav-number">6.1.</span> <span class="nav-text">对映</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些-case-1"><span class="nav-number">6.2.</span> <span class="nav-text">一些 case</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#承认排中律"><span class="nav-number">6.3.</span> <span class="nav-text">承认排中律</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#InductionProp"><span class="nav-number">7.</span> <span class="nav-text">InductionProp</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#具体-case"><span class="nav-number">7.1.</span> <span class="nav-text">具体 case</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">8.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2024/02/03/note-on-sf-1/';
          this.page.identifier = '2024/02/03/note-on-sf-1/';
          this.page.title = 'Software Foundation 做题的 Notes';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
