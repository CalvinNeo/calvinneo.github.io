<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="并行计算,redis," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta name="keywords" content="并行计算,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis底层对象实现原理分析">
<meta property="og:url" content="http://www.calvinneo.com/2018/07/23/redis_learn_object/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/redis_object/dict.png">
<meta property="og:updated_time" content="2020-10-16T15:09:23.665Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis底层对象实现原理分析">
<meta name="twitter:description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta name="twitter:image" content="http://www.calvinneo.com/img/redis_object/dict.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2018/07/23/redis_learn_object/"/>





  <title>Redis底层对象实现原理分析 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2018/07/23/redis_learn_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis底层对象实现原理分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-23T23:52:20+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和<a href="https://github.com/redis/redis/commit/c01e94a4319c416c4c231ffbea9e778d52424e30" target="_blank" rel="noopener">2020年8月版本</a>（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。<br>Redis中主要包含了字符串STRING、列表LIST（双向链表）、集合SET、哈希表HASH、有序集合ZSET五种最常见的类型。在后续的版本中，还提供了bitmap、geohash、hyperloglog、stream这四种类型。<br>这些对象依赖于一些内部结构，包括字符串(SDS)、哈希表(dict)、链表(list)、跳表(zskiplist)、压缩双向表(ziplist)、快表等。注意出于性能原因，一个对象的实现往往根据具体的内容而选择不同的实现。列举如下：</p>
<ol>
<li>STRING<br> 使用int、sds(raw)或者embstr。</li>
<li>HASH<br> 使用dict或者ziplist方案。</li>
<li>LIST<br> 3.0是使用list或者ziplist的方案。<br> 目前使用快表。</li>
<li>SET<br> 使用dict或者intset的方案。</li>
<li>ZSET<br> 视数据规模选用ziplist和skiplist+dict的方案。</li>
</ol>
<p>【未完待续】</p>
<a id="more"></a>
<h1 id="Redis源码结构"><a href="#Redis源码结构" class="headerlink" title="Redis源码结构"></a>Redis源码结构</h1><p>在3.0版本中，redis的主要结构都定义在redis.h中，在新版本中，它们被放到了server.h中。</p>
<h1 id="Redis-Object"><a href="#Redis-Object" class="headerlink" title="Redis Object"></a>Redis Object</h1><p>诸如<code>dict</code>、<code>sds</code>之类的对象，在db层面实际上是用<code>redisObject</code>封装的，需要的时候通过<code>robj-&gt;ptr</code>获取实际需要的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 由OBJ_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 由OBJ_ENCODING_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure>
<p>Redis对象的类型是用<code>OBJ_</code>宏来列出的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The "module" object type is a special one that signals that the object</span></span><br><span class="line"><span class="comment"> * is one directly managed by a Redis module. In this case the value points</span></span><br><span class="line"><span class="comment"> * to a moduleValue struct, which contains the object value (which is only</span></span><br><span class="line"><span class="comment"> * handled by the module itself) and the RedisModuleType struct which lists</span></span><br><span class="line"><span class="comment"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span></span><br><span class="line"><span class="comment"> * free the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span></span><br><span class="line"><span class="comment"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span></span><br><span class="line"><span class="comment"> * in order to dispatch the loading to the right module, plus a 10 bits</span></span><br><span class="line"><span class="comment"> * encoding version. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br></pre></td></tr></table></figure></p>
<p>Redis对象所实际使用的内部结构是用<code>OBJ_ENCODING_</code>宏来表示的，如前文所列举的，同一个对象可能有不同的实现。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">// OBJ_ENCODING_RAW是普通的SDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="comment">// embstr是对短字符串的一种优化编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="createObject"><a href="#createObject" class="headerlink" title="createObject"></a>createObject</h2><p>创建对象，<code>refcount</code>设为1。<code>encoding</code>设为<code>OBJ_ENCODING_RAW</code>，也就是普通SDS字符串。传入的<code>type</code>是<code>OBJ_</code>宏的某个特定值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>有两种特殊的引用计数值：</p>
<ol>
<li><code>OBJ_SHARED_REFCOUNT</code><br> 由<code>makeObjectShared</code>函数生成，在这种情况下这个对象是immutable的，因此可以不加锁地进行访问。这种对象也不受<code>incrRefCount</code>/<code>decrRefCount</code>控制。<br> 注意，这种对象设为immutable是合理的，它的一个通常作用是共享小整数对象，例如Redis会共享0到9999。</li>
<li><code>OBJ_STATIC_REFCOUNT</code><br> 一般由<code>initStaticStringObject</code>宏生成。看上去这个一般用在在栈上面分配的临时对象的refcount，我对此也不是很确定。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX     <span class="comment">/* Global object never destroyed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STATIC_REFCOUNT (INT_MAX-1) <span class="comment">/* Object allocated in the stack. */</span></span></span><br><span class="line"><span class="comment">// 第一个有特殊含义的refcount值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一般来说，使用引用计数可能存在循环引用的问题。Redis巧妙地避免了这个问题，首先在Redis的所有<code>redisObject</code>里面，只有String会被嵌入到其他类型中，也就是说ZSET等其他的数据类型不会互相引用（在Geo等新数据结构里面也是这样的么？）。而Redis对String类型引入对象共享机制，保证了不会产生互相引用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt; OBJ_FIRST_SPECIAL_REFCOUNT) &#123;</span><br><span class="line">        o-&gt;refcount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount == OBJ_SHARED_REFCOUNT) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do: this refcount is immutable. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;refcount == OBJ_STATIC_REFCOUNT) &#123;</span><br><span class="line">            serverPanic(<span class="string">"You tried to retain an object allocated in the stack"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>decrRefCount</code>还负责销毁对象，步骤是<code>freeXXXObject</code>，然后在<code>zfree</code>。前者用来释放<code>o-&gt;ptr</code>指向的对象的内存，后者用来释放<code>o</code>的内存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h1><h2 id="redisCommand对象"><a href="#redisCommand对象" class="headerlink" title="redisCommand对象"></a>redisCommand对象</h2><p>redisCommand对象有新旧很多种版本，新旧版本中存在一些区别，例如<code>sflag</code>的内容，我们以新版本为主。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags; <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * 通常用在Redis Cluster转发过程中 */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br><span class="line">    <span class="keyword">int</span> id;     <span class="comment">/* Command ID. This is a progressive ID starting from 0 that</span></span><br><span class="line"><span class="comment">                   is assigned at runtime, and is used in order to check</span></span><br><span class="line"><span class="comment">                   ACLs. A connection is able to execute a given command if</span></span><br><span class="line"><span class="comment">                   the user associated to the connection has this command</span></span><br><span class="line"><span class="comment">                   bit set in the bitmap of allowed commands. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>解释如下：</p>
<ol>
<li><code>sflags</code>表示这个命令的一些特性<br> 详见<a href="https://segmentfault.com/a/1190000017104165" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017104165</a></li>
<li><code>flags</code>是通过<code>populateCommandTableParseFlags</code>从<code>sflags</code>生成的<code>sflags</code>的二进制表示。详见server.h中的<code>CMD_</code>定义</li>
<li>下面是key三元组：<code>firstkey</code>表示第一个key参数的位置，<code>lastkey</code>表示最后一个key参数的位置，<code>keystep</code>表示key参数步长。通过上面三个参数，可以拿到所有的key。通常发生在<code>getKeysFromCommand</code>到<code>getKeysUsingCommandTable</code>函数调用链中。引入这个三元组的目的是有一些指令（如<code>mset</code>和<code>msetnx</code>的<code>keystep</code>取2）是支持在一个命令中对多个key/value对进行赋值的。我们需要注意的是诸如<code>ZADD</code>的指令虽然可以同时添加很多个<code>(score, member)</code>对，但是实际上他们是对一个key添加的，所以它们的三元组都是1。</li>
<li><code>getkeys_proc</code>表示<a href="https://developer.aliyun.com/article/754089" target="_blank" rel="noopener">从命令中判断命令的key</a>，实际上就是当<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>不能描述的时候，就会用到这个，返回一个<code>int*</code>表示所有key。例如后面举的eval的例子。</li>
<li><code>microseconds</code>表示该命令的调用总时间</li>
<li><code>calls</code>表示该命令的调用总次数</li>
<li><code>id</code>是在运行时给每个指令分配的id</li>
</ol>
<p>我们结合一个具体的定义来了解这个结构：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"module"</span>,moduleCommand,<span class="number">-2</span>, <span class="comment">// -2表示大于等于2个参数</span></span><br><span class="line">     <span class="string">"admin no-script"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>, <span class="comment">// 这个叫get的指令对应到void getCommand(client *c)，有2个参数</span></span><br><span class="line">     <span class="string">"read-only fast @string"</span>, <span class="comment">// 是只读的，fast表示命令执行时间超过阈值时，会记录延迟事件。</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// flags</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">// getkeys_proc</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// firstkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// lastkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// keystep</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// microseconds</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// calls</span></span><br><span class="line">     <span class="number">0</span> <span class="comment">// id</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment">     * implicit DEL of a large key. */</span></span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"write use-memory @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"eval"</span>,evalCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"no-script @scripting"</span>,</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     evalGetKeys, <span class="comment">// eval无法通过key三元组描述，所以这里指定一个特殊的getkeys_proc</span></span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">"zadd"</span>,zaddCommand,<span class="number">-4</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @sortedset"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h1 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h1><h2 id="redisDb类"><a href="#redisDb类" class="headerlink" title="redisDb类"></a>redisDb类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间，字典的键为键，字典的值为过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 用来服务诸如BLPOP的命令，记录目前被阻塞的键 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均TTL，统计信息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<p>可以发现，<code>redisDb</code>本身就依赖<code>dict</code>和<code>list</code>等Redis底层结构的实现，说明Redis的复用性还是很好的。</p>
<h2 id="DEL相关实现"><a href="#DEL相关实现" class="headerlink" title="DEL相关实现"></a>DEL相关实现</h2><p>为了理解下面论述中涉及到的expire相关实现，我们需要先介绍一些<code>UNLINK</code>和<code>DEL</code>的实现。<br>这个Command的实现是比较Legacy的，从<code>c-&gt;argv</code>中读取所有需要被删除的key。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码会进行事件通知，我们将专门进行介绍<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlinkCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="同步实现"><a href="#同步实现" class="headerlink" title="同步实现"></a>同步实现</h3><p>我们首先来看简单的同步实现。<br>首先，如果<code>db-&gt;expires</code>非空，从<code>db-&gt;expires</code>里面删除<code>key</code>，实际上是删除的过期时间。这里需要注意的是在删除之后，<code>key-&gt;ptr</code>这个sds其实并没有被删除，因为它和<code>db-&gt;dict</code>是共享的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="comment">// dictDelete最终调用dictGenericDelete</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure></p>
<p>不过查看<code>dictDelete</code>里面，发现新版本肯定会调用<code>dictFreeEntryKey</code>。从下面的实现中可以看到，这个函数一定会导致对应sds的析构。所以我理解上面这个注释的意思是我们不会用<code>db-&gt;expires</code>里面的key去调用<code>dbSyncDelete</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeEntryKey(ht, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((ht)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (ht)-&gt;type-&gt;keyDestructor((ht)-&gt;privdata, (entry)-&gt;key)</span><br></pre></td></tr></table></figure></p>
<p>说一下<code>#define DICT_NOTUSED(V) ((void) V)</code>这个用法，实际上作用是为了保证编译器不会出现这个XXX没有被使用的warning。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSdsDestructor</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面接着看<code>dbSyncDelete</code>的逻辑，实际上就是在<code>dictDelete</code>之外，对<code>server.cluster_enabled</code>的情况进行了额外的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再从db-&gt;dict里面删除key</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// Redis Cluster相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="异步实现"><a href="#异步实现" class="headerlink" title="异步实现"></a>异步实现</h3><p>前面的是大差不差的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazyfree.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB.</span></span><br><span class="line"><span class="comment"> * If there are enough allocations to free the value object may be put into</span></span><br><span class="line"><span class="comment"> * a lazy free list instead of being freed synchronously. The lazy free list</span></span><br><span class="line"><span class="comment"> * will be reclaimed in a different bio.c thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure></p>
<p>下面调用<code>dictUnlink</code>而不是<code>dictDelete</code>了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment"> * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment"> * the object synchronously. */</span></span><br><span class="line">dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br></pre></td></tr></table></figure></p>
<p>查看<code>dictUnlink</code>的源码，发现是设置了<code>nofree=1</code>调用了<code>dictGenericDelete</code>。在这个参数的作用下，<strong>不会去析构<code>key</code>和<code>value</code></strong>。关于这个函数的具体实现，在dict相关章节进行介绍了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictUnlink</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们要手动来进行析构。会首先使用<code>lazyfreeGetFreeEffort</code>来计算析构的代价，如果代价过高，就将这个对象放到lazy free list里面让它后台去析构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (de) &#123;</span><br><span class="line">    robj *val = dictGetVal(de);</span><br><span class="line">    <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要注意的是，如果这个对象是被共享的，那么在这里重新获取它是不太现实的。</span></span><br><span class="line">    <span class="comment">// 这个倒不经常发生，但有些时候Redis的一些实现代码会调动`incrRefCount`来保护对象，然后调用`dbDelete`。</span></span><br><span class="line">    <span class="comment">// （我理解这种情况下val-&gt;refcount就是一个大于1的值）</span></span><br><span class="line">    <span class="comment">// 在这种情况下我们会直接到达`dictFreeUnlinkedEntry`的调用，它的作用相当于调用`decrRefCount`。</span></span><br><span class="line">    <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">        bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">        dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里面涉及的几个函数来讲解一下：</p>
<ol>
<li><code>lazyfreeGetFreeEffort</code></li>
<li><p><code>atomicIncr</code><br> 是一个原子操作，更新lazyfree里面的一个static变量<code>lazyfree_objects</code>。根据不同的操作系统的支持，有三种实现：<br> 如果支持atomic语义</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure>
<p> 如果有sync语义，一般是gcc的一个内置宏</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __sync_add_and_fetch(&amp;var,(count))</span></span><br></pre></td></tr></table></figure>
<p> 如果什么都没有，用mutex</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</span><br><span class="line">    var += (count); \</span><br><span class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>bioCreateBackgroundJob</code></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>dictSetVal</code><br> 下面就是给之前<code>nofree</code>没做的事情查一下屁股，包含调用<code>dictFreeKey</code>啥的来释放key和value所占用的内存。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    zfree(he);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="lookUpKey相关实现"><a href="#lookUpKey相关实现" class="headerlink" title="lookUpKey相关实现"></a>lookUpKey相关实现</h2><p>lookUpKey相关方法包括<code>lookupKeyRead</code>、<code>lookupKeyWrite</code>两个方向的函数，此外还根据是否<code>WithFlags</code>或者<code>OrReply</code>派生出其他几种函数。其中<code>WithFlags</code>目前只包含了<code>LOOKUP_NONE</code>和<code>LOOKUP_NOTOUCH</code>两个选项。<br>首先查看<code>lookupKeyWriteWithFlags</code>的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面查看<code>lookupKeyReadWithFlags</code>的实现，相比于写要复杂点，因为要处理键过期的时候读的问题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br></pre></td></tr></table></figure></p>
<p>首先，考虑Master的情况，如果key过期了，那么就直接返回NULL，并且触发一个keymiss事件。这里备注上说在Master情况下，<code>expireIfNeeded</code>返回0当且只当这个key不存在，这个我不是很理解。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Key expired. If we are in the context of a master, expireIfNeeded()</span></span><br><span class="line"><span class="comment"> * returns 0 only when the key does not exist at all, so it's safe</span></span><br><span class="line"><span class="comment"> * to return NULL ASAP. */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;</span><br></pre></td></tr></table></figure></p>
<p>更新统计信息，<code>server.stat_keyspace_misses</code>可以通过<code>INFO keyspace_misses</code>命令来查看。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    server.stat_keyspace_misses++;</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是对Slave情况来说的，这是因为在淘汰策略部分可以了解到，对Slave而言，<code>expireIfNeeded</code>并不会真的让key过期，而只是返回key的逻辑状态，而真正的过期是由Master来同步的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 如果指令的调用者不是master，作为一个额外的安全措施，</span></span><br><span class="line"><span class="comment">         * 这个指令是作为一个只读指令的，我们可以在这里安全地返回NULL。</span></span><br><span class="line"><span class="comment">         * 我们通过只读的方式，向client提供一个更加一致性的行为</span></span><br><span class="line"><span class="comment">         *（这里accessign还是个错别字），表达这个key不存在。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Notably this covers GETs when slaves are used to scale reads. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>lookUpKey</code>的主要内容包括从db里面找到对应的key，并且维护LRU或LFU。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Low level key lookup API, not actually called directly from commands</span></span><br><span class="line"><span class="comment"> * implementations that should instead rely on lookupKeyRead(),</span></span><br><span class="line"><span class="comment"> * lookupKeyWrite() and lookupKeyReadWithFlags(). */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从db中获得key对应的entry</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了，就取出val</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有子进程正在进行保存，就不进行LFU操作，以免破坏COW</span></span><br><span class="line">        <span class="comment">// 如果没有设置LOOKUP_NOTOUCH</span></span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="expire实现"><a href="#expire实现" class="headerlink" title="expire实现"></a>expire实现</h3><p><code>expireIfNeeded</code>用来删除过期的键。返回0表示键有效（键未过期，或永不过期），否则返回1表示已经过期并被删除。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In masters as a side effect of finding a key which is expired, such</span></span><br><span class="line"><span class="comment"> * key will be evicted from the database. Also this may trigger the</span></span><br><span class="line"><span class="comment"> * propagation of a DEL/UNLINK command in AOF / replication stream.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有过期，就返回0</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面这条语句和主从模式有关在主从模式下的Slave上运行的时候，直接返回，而不是继续删除键。这是因为Slave上的key过期是由Master控制的，Slave并不直接处理key的过期。Master会发送一个同步的<code>DEL</code>命令给Slave来删除某个键，Slave等到那时候再删除，<strong>这样做的目的是出于一致性的考量</strong>。但尽管如此，对Slave调用<code>expireIfNeeded</code>也应该返回一个正确的值，也就是实际上在这个时候键有没有过期。因此在Slave上可能存在键还在，但是却已经过期的窗口时间（因为还没有来得及收到并处理Master的<code>DEL</code>）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面肯定对应了已经过期的情况了。</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面负责通知删除事件，这里还出现了<code>propagateExpire</code>函数，我们也统一在后面讲解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.stat_expiredkeys++;</span><br><span class="line"><span class="comment">// 向AOF文件和Slave节点传播过期信息，实际会调用propagate函数</span></span><br><span class="line">propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line"><span class="comment">// 发送事件通知</span></span><br><span class="line">notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">"expired"</span>,key,db-&gt;id);</span><br></pre></td></tr></table></figure></p>
<p>下面是真正的过期删除的过程。这里根据<code>server.lazyfree_lazy_expire</code>的配置，可以选择异步删除或者同步删除，这类似于上面讨论过的<code>UNLINK</code>和<code>DEL</code>的实现。事实上在<code>expireGenericCommand</code>上就可以看到对应的映射关系。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);     </span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Redis的LRU和LFU实现"><a href="#Redis的LRU和LFU实现" class="headerlink" title="Redis的LRU和LFU实现"></a>Redis的LRU和LFU实现</h3><p>这里涉及到Redis中更新LRU的问题，Redis并没有采用hash+双向链表的办法来维护一个LRU，这是因为这种方式的内存开销很大。取而代之，Redis对每个<code>robj</code>对象去维护了一个<code>lru:LRU_BITS</code>字段。<br>在3.0版本，这个字段被用来存储当前秒级别的时间戳，在往后的版本中支持了LFU模式，在这种方式下会调用<code>updateLFU</code>进行处理，这个函数会在高16位存一个分钟级别的时间戳，在低8位存访问计数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        lruclock = server.lruclock;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Update LFU when an object is accessed.</span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 组装lru字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LFUDecrAndReturn</code>这个函数负责对<code>counter</code>减去<code>num_periods</code>。<code>num_periods</code>的值是由<code>server.lfu_decay_time</code>来定的，也就是计算一下现在过去了几个<code>lfu_decay_time</code>，那么就减少多少。默认情况下，<code>server.lfu_decay_time</code>是1分钟，这时候对<code>counter</code>的减少就是过去的分钟数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出老的分钟时间戳</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 取出老的计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? </span><br><span class="line">        LFUTimeElapsed(ldt) / server.lfu_decay_time : </span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得从ldt开始经过了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="comment">// 如果now小了，就当成已经wrap了刚好一次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-decay-time"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_decay_time, <span class="number">1</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<p>上面介绍了对<code>counter</code>随时间的衰减，下面介绍<code>counter</code>随访问次数的增长。<code>counter</code>的增长并不是访问一次就+1，而是用一个[0,1]之间的数<code>p</code>来描绘。<code>p</code>的值是<code>1.0/((counter-LFU_INIT_VAL)*server.lfu_log_factor+1)</code>，然后他还要和一个随机数<code>r</code>比较，大于<code>r</code>的话才能导致<code>counter</code>自增。可以看到当前的<code>counter</code>和<code>lfu_log_factor</code>越大，<code>counter</code>的自增概率就越小。事实上<code>counter</code>的增长和访问次数是成对数关系的。<br>另一个值得注意的是<code>LFU_INIT_VAL</code>的值，取5，这是为了防止新生对象的<code>counter</code>值为0，从而被快速淘汰掉。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-log-factor"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_log_factor, <span class="number">10</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="client类"><a href="#client类" class="headerlink" title="client类"></a>client类</h2><p>client类对应了3.0版本中的<code>redisClient</code>类。因为Redis对IO是多路复用的，所以需要为每个客户端连接维护一个状态，所以<code>client</code>实际上类似于session一样，是在服务器端维护的一个状态。而真正的Redis客户端定义在redis-cli.c这个文件里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="keyword">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="redisServer类"><a href="#redisServer类" class="headerlink" title="redisServer类"></a>redisServer类</h2><p><code>server</code>是一个全局对象，它的类型是<code>redisServer</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span> <span class="comment">/* Server global state */</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><p>在前面的代码中可以看到下面的语句，实际上是对主数据库<code>c-&gt;db</code>进行修改后，需要进行事件通知，我们将在下面介绍这几个语句的作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">    <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure></p>
<h3 id="signalModifiedKey"><a href="#signalModifiedKey" class="headerlink" title="signalModifiedKey"></a>signalModifiedKey</h3><p><code>signalModifiedKey</code>是key被修改的钩子函数，每当数据库<code>c-&gt;db</code>里面的key被改动时，会调用这个函数。这里的key发生改动也包括key对应的值发生改动，这是因为从<code>genericSetKey</code>的实现可以看到，SET指令也会导致<code>signalModifiedKey</code>被调用。<br>此外，根据注释，每一次DB被flush时，<code>signalFlushDb</code>会被调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(client *c, redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">    trackingInvalidateKey(c,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="touchWatchedKey"><a href="#touchWatchedKey" class="headerlink" title="touchWatchedKey"></a>touchWatchedKey</h4><p><code>touchWatchedKey</code>字如其名，它的作用是让WATCH这个键的事务失效。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br></pre></td></tr></table></figure></p>
<p>这里先特判一下，如果<code>db-&gt;watched_keys</code>为空就直接返回，这个用法在redis中非常常见，我猜想可能是<code>dictFind</code>的开销还是比较大的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面从<code>db-&gt;watched_keys</code>上拿到WATCH这个key的所有的client，并且对这个链表上的每一个client设置<code>CLIENT_DIRTY_CAS</code>这个flag。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 这个函数是dictFind(只能得到dictEntry)和dictGetVal的简单封装</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="trackingInvalidateKey"><a href="#trackingInvalidateKey" class="headerlink" title="trackingInvalidateKey"></a>trackingInvalidateKey</h4><p>下面看另一个函数<code>trackingInvalidateKey</code>。这个系列的函数是在Redis6.0左右被引入的，主要用途是维护客户端缓存。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper (the one actually called across the core) to pass the key</span></span><br><span class="line"><span class="comment"> * as object. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKey</span><span class="params">(client *c, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    trackingInvalidateKeyRaw(c,keyobj-&gt;ptr,sdslen(keyobj-&gt;ptr),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function is called from signalModifiedKey() or other places in Redis</span></span><br><span class="line"><span class="comment"> * when a key changes value. In the context of keys tracking, our task here is</span></span><br><span class="line"><span class="comment"> * to send a notification to every client that may have keys about such caching</span></span><br><span class="line"><span class="comment"> * slot.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that 'c' may be NULL in case the operation was performed outside the</span></span><br><span class="line"><span class="comment"> * context of a client modifying the database (for instance when we delete a</span></span><br><span class="line"><span class="comment"> * key because of expire).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * `bcast`参数的作用是是否要将这个key通过BCAST模式广播给client们。</span></span><br><span class="line"><span class="comment"> * This is the case when the function is called from the Redis core once a key is modified, however</span></span><br><span class="line"><span class="comment"> * we also call the function in order to evict keys in the key table in case</span></span><br><span class="line"><span class="comment"> * of memory pressure: in that case the key didn't really change, so we want</span></span><br><span class="line"><span class="comment"> * just to notify the clients that are in the table for this key, that would</span></span><br><span class="line"><span class="comment"> * otherwise miss the fact we are no longer tracking the key for them. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKeyRaw</span><span class="params">(client *c, <span class="keyword">char</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> bcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TrackingTable == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcast &amp;&amp; raxSize(PrefixTable) &gt; <span class="number">0</span>)</span><br><span class="line">        trackingRememberKeyToBroadcast(c,key,keylen);</span><br><span class="line"></span><br><span class="line">    rax *ids = raxFind(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen);</span><br><span class="line">    <span class="keyword">if</span> (ids == raxNotFound) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    raxIterator ri;</span><br><span class="line">    raxStart(&amp;ri,ids);</span><br><span class="line">    raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> id;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;id,ri.key,<span class="keyword">sizeof</span>(id));</span><br><span class="line">        client *target = lookupClientByID(id);</span><br><span class="line">        <span class="comment">/* Note that if the client is in BCAST mode, we don't want to</span></span><br><span class="line"><span class="comment">         * send invalidation messages that were pending in the case</span></span><br><span class="line"><span class="comment">         * previously the client was not in BCAST mode. This can happen if</span></span><br><span class="line"><span class="comment">         * TRACKING is enabled normally, and then the client switches to</span></span><br><span class="line"><span class="comment">         * BCAST mode. */</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span> ||</span><br><span class="line">            !(target-&gt;flags &amp; CLIENT_TRACKING)||</span><br><span class="line">            target-&gt;flags &amp; CLIENT_TRACKING_BCAST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client enabled the NOLOOP mode, don't send notifications</span></span><br><span class="line"><span class="comment">         * about keys changed by the client itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;flags &amp; CLIENT_TRACKING_NOLOOP &amp;&amp;</span><br><span class="line">            target == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendTrackingMessage(target,key,keylen,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    raxStop(&amp;ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the tracking table: we'll create the radix tree and populate it</span></span><br><span class="line"><span class="comment">     * again if more keys will be modified in this caching slot. */</span></span><br><span class="line">    TrackingTableTotalItems -= raxSize(ids);</span><br><span class="line">    raxFree(ids);</span><br><span class="line">    raxRemove(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="notifyKeyspaceEvent"><a href="#notifyKeyspaceEvent" class="headerlink" title="notifyKeyspaceEvent"></a>notifyKeyspaceEvent</h3><p>函数<code>notifyKeyspaceEvent</code>用来触发数据库事件，这个对应了Redis中的叫<a href="http://redisdoc.com/topic/notification.html" target="_blank" rel="noopener">“键空间通知”/“键事件通知”</a>的特性。<br>简单来说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL key [key ...]</code>命令时，系统将分发两条消息，相当于执行以下两个<a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a>命令。其中<code>__keyspace</code>系列命令称为键空间通知(key-space notification)，<code>__keyevent</code>系列命令称为键事件通知(key-event notification)。订阅第一个PUBLISH命令，可以接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件。订阅第二个可以接收<code>0</code>号数据库中所有执行<code>del</code>命令的键<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace<span class="variable">@0__</span><span class="symbol">:mykey</span> del</span><br><span class="line">PUBLISH __keyevent<span class="variable">@0__</span><span class="symbol">:del</span> mykey</span><br></pre></td></tr></table></figure></p>
<p>下面看看这个函数的具体实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If any modules are interested in events, notify the module system now.</span></span><br><span class="line"><span class="comment">     * This bypasses the notifications configuration, but the module engine</span></span><br><span class="line"><span class="comment">     * will only call event subscribers if the event type matches the types</span></span><br><span class="line"><span class="comment">     * they are interested in. */</span></span><br><span class="line">     moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If notifications for this class of events are off, return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyspace@"</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyevent@"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="propagateExpire"><a href="#propagateExpire" class="headerlink" title="propagateExpire"></a>propagateExpire</h2><p>在前面的代码中，还看到<code>propagateExpire</code>的使用，这里也解释下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p>
<h1 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h1><h2 id="Redis内存分配机制"><a href="#Redis内存分配机制" class="headerlink" title="Redis内存分配机制"></a>Redis内存分配机制</h2><p>Redis基于zmalloc系列函数进行内存分配。<br>zmalloc是为了解决什么问题呢？主要是为了做到异常处理和内存统计的功能。<br>下面首先来看<code>zmalloc</code>的实现。<br>可以看到，它会额外分配一个<code>PREFIX_SIZE</code>，用来存储额外信息。<code>zmalloc</code>最终返回的是<code>(char*)ptr+PREFIX_SIZE</code>，这个有点类似于SDS的骚操作。<code>PREFIX_SIZE</code>的大小是由宏来定义的，并且可以通过<code>HAVE_MALLOC_SIZE</code>禁用内存统计的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 如果不记录内存分配大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果记录内存分配大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们仔细查看一下<code>update_zmalloc_stat_alloc</code>函数的实现，不出所料的话，应该是通过一个原子操作来实现更新的。实际上也果不其然，<code>atomicIncr</code>的实现在后面会讲到。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) atomicIncr(used_memory,(__n))</span></span><br></pre></td></tr></table></figure></p>
<p>我们还可以看到的是一个用来处理oom的函数<code>zmalloc_oom_handler</code>。对于C语言来说，<code>malloc</code>在内存分配失败后会返回一个0指针，然后我们在进行后续操作的时候要自行判断。基本上对于oom的处理就是打印一条日志然后abort了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisOutOfMemoryHandler</span><span class="params">(<span class="keyword">size_t</span> allocation_size)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Out Of Memory allocating %zu bytes!"</span>,</span><br><span class="line">        allocation_size);</span><br><span class="line">    serverPanic(<span class="string">"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"</span>, </span><br><span class="line">        allocation_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)</span></span><br><span class="line"><span class="comment">// debug.c</span></span><br><span class="line"><span class="keyword">void</span> _serverPanic(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *msg, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,msg);</span><br><span class="line">    <span class="keyword">char</span> fmtmsg[<span class="number">256</span>];</span><br><span class="line">    vsnprintf(fmtmsg,<span class="keyword">sizeof</span>(fmtmsg),msg,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    bugReportStart();</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"!!! Software Failure. Press left mouse button to continue"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Guru Meditation: %s #%s:%d"</span>,fmtmsg,file,line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.crashlog_enabled) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">        logStackTrace(<span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        printCrashReport();</span><br><span class="line">    &#125;</span><br><span class="line">    bugReportEnd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bugReportStart</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bug_report_start_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bug_report_start == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLogRaw(LL_WARNING|LL_RAW,</span><br><span class="line">        <span class="string">"\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n"</span>);</span><br><span class="line">        bug_report_start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bug_report_start_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>SDS(simple dynamic string)是Redis中的动态字符串实现，没错，Redis又重复了C/C++的传统，自己造了套轮子。我们考虑一下设计一个字符串的几个方面，复制/移动效率、空间效率、编码问题。例如在<code>std::string</code>中就会进行一些短串优化(SSO)（对每个字符串对象内部维护一段较短的buffer，当buffer不够用时再向堆请求空间）、写时拷贝(COW)的方法来进行优化，这会导致不同STL下<code>c_str</code>的<a href="https://gaomf.cn/2017/07/26/Cpp_string_COW_SSO/" target="_blank" rel="noopener">不同行为</a>。但在字符串设计时，常将其实现成immutable的，以Java为例，这是为了防止在外部对容器（如Hashset）中对象的更改破坏容器的特性（Hashset的唯一性）、并发、便于进行常量池优化考虑。但是SDS却是可变的，并且被用在实现键和值中。例如<code>SET hello world</code>中，键<code>hello</code>和值<code>world</code>的底层都是SDS。此外，由于其可变性，SDS还被用作缓冲区。<br>查看<code>sds</code>的实现，发现是一个<code>char*</code>，难道直接就是一个<code>char*</code>的原生表示么？其实还真是这样，可以直接通过<code>printf(&quot;%s&quot;, s)</code>打印这个sds。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，Redis总不会用<code>O(n)</code>来算字符串长度吧，那么元信息报错在哪里呢？我们看到Redis提供了支持不同最大长度的<code>sdshdr</code>类型，和<code>sds</code>开头的C-style的字符串函数。所以说元信息是保存在<code>sdshdr</code>里面的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>简单解释一下这几个参数：</p>
<ol>
<li>len<br> <code>len</code>表示了字符串的长度，所以我们省去了<code>strlen</code>的开销，虽然我们还是可以直接对sds用。</li>
<li>buf<br> 特别地，<code>buf</code>实际上是一个二进制数组，<code>\0</code>可以出现在中间，Redis只保证<code>buf</code>最终以<code>\0</code>结尾。而这个buf实际上就是sds所指向的东西，我们将在稍后解释这一点。</li>
</ol>
<p>现在要讲解的重点是Redis是如何组织sdshdr和sds的，事实上它们的内存布局如图所示。容易看出，给定一个<code>sds</code>，可以直接当做<code>char*</code>来处理，但也可以往前推<code>sizeof(sdshdr)</code>大小，去获得sdshdr结构。而到底往前推多少字节，取决于<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      sds</span><br><span class="line">       <span class="string">|</span></span><br><span class="line">       v</span><br><span class="line">sdshdr <span class="string">| sdshdr.buf</span></span><br></pre></td></tr></table></figure></p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现，主要是会调用<code>sdsnewlen</code>这个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br></pre></td></tr></table></figure></p>
<p>首先，看一下这个<code>type</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，根据要分配的字符串的长度，会给到不同的<code>SDS_TYPE_</code>，实际上也就对应到不同长度的sdshdr对象，下面我们就要具体来分配一个sdshdr对象了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment"> * since type 5 is not good at this. */</span></span><br><span class="line"><span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line"><span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br></pre></td></tr></table></figure></p>
<p>看一下<code>sdsHdrSize</code>，不出所料，是根据<code>type</code>去<code>sizeof</code>算得需要使用的sdshdr对象的大小。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr5);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是分配了sdshdr对象和sds字符串的所有的内存，并加上一个结尾的<code>\0</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">    init = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">    <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面一个有趣的是<code>s</code>，它实际上就是最后返回的<code>sds</code>了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>在新版本下，Redis中的list(t_list)的实现借助于快表，但本章主要是讲解原始双向链表<code>list</code>的实现，它被定义在adlist文件中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 复制</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 对比</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，保存了head、tail和len的值，因此len操作是O(1)的。</p>
<h1 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h1><p>dict是Redis中非常重要的结构，它不仅被用来实现HASH等数据结构，而且还被广泛地使用到Redis数据库服务器等基础设施中。在本章中，将介绍dict的实现，并使用HASH数据结构跟踪到dict的上层调用。我们首先看一下<code>dict</code>类的包含关系。<br><img src="/img/redis_object/dict.png" alt=""><br>其中，<code>union v</code>包含下面的几个类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">    <span class="keyword">int64_t</span> s64;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125; v;</span><br></pre></td></tr></table></figure></p>
<h2 id="dict的基本实现与Rehash机制"><a href="#dict的基本实现与Rehash机制" class="headerlink" title="dict的基本实现与Rehash机制"></a>dict的基本实现与Rehash机制</h2><p>在这个章节中，我们主要介绍dict的主要实现和Hash以及Rehash机制。</p>
<h3 id="dictEntry、dictht"><a href="#dictEntry、dictht" class="headerlink" title="dictEntry、dictht"></a>dictEntry、dictht</h3><p><code>dict</code>的实现在<strong>dict.h</strong>中，注意在<strong>deps/hiredis</strong>中也有另一个实现，注意不要搞混。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// next指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure></p>
<p><code>dictEntry</code>是一个<strong>KV对</strong>，可以看到Redis以链表的形式存储KV，并且使用<code>union</code>来优化空间存储。我们不能从<code>dictEntry</code>获得任何的类型信息，实际上它是作为下面<code>dictht</code>对象的一个组件来使用的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure></p>
<p><code>dictht</code>描述了一个哈希表，它将<code>dictEntry</code>组织起来，它维护了长度和节点数等信息，但并没有描述这个哈希表的行为、类型等信息，它将被进一步封装。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    <span class="comment">// dictEntry本身是一个KV对，外面一维是哈希的**桶**，里面一维是开链表</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 表示桶的数量，注意`dictSize`函数表示`dict`中两个ht钟所有的元素数量而不是桶的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask; <span class="comment">// === size-1</span></span><br><span class="line">    <span class="comment">// 表示哈希表中装载的元素数量，也就是每个桶中所有链表的长度之和</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure></p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>看到这里有个疑问，似乎这里的<code>key</code>是一个指针，而不是我想象中的一个SDS或者<code>char*</code>值，难道我们仅仅是根据<code>key</code>的指针值来进行哈希么？事实上并非如此，根据不同的<code>dictType</code>，实际上会有不同的Hash函数。可以看到对于大多数key为SDS的情况，会落到<code>dictGenHashFunction</code>的调用上。在3.0时代，这个函数是一个对MurmurHash2函数的调用，在当前版本下，这是一个对<code>siphash</code>函数的调用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="comment">/* Set dictionary type. Keys are SDS strings, values are ot used. */</span></span><br><span class="line">dictType setDictType = &#123;</span><br><span class="line">    dictSdsHash,               <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,         <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> dictSdsHash(<span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, sdslen((<span class="keyword">char</span>*)key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> dictGenHashFunction(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash(key,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> siphash(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *in, <span class="keyword">const</span> <span class="keyword">size_t</span> inlen, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *k) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNALIGNED_LE_CPU</span></span><br><span class="line">    <span class="keyword">uint64_t</span> hash;</span><br><span class="line">    <span class="keyword">uint8_t</span> *out = (<span class="keyword">uint8_t</span>*) &amp;hash;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> v0 = <span class="number">0x736f6d6570736575</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v1 = <span class="number">0x646f72616e646f6d</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v2 = <span class="number">0x6c7967656e657261</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v3 = <span class="number">0x7465646279746573</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> k0 = U8TO64_LE(k);</span><br><span class="line">    <span class="keyword">uint64_t</span> k1 = U8TO64_LE(k + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> m;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *end = in + inlen - (inlen % <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> left = inlen &amp; <span class="number">7</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<h3 id="dict和dictAdd"><a href="#dict和dictAdd" class="headerlink" title="dict和dictAdd"></a>dict和dictAdd</h3><p>我们接着来看上面的<code>dictht</code>结构。就和我在libutp里面看到的环状缓冲区一样，这里<code>size</code>和<code>sizemask</code>已经是老套路了，我们已经可以想象<code>size</code>一定是按照2的级数增长的，然后<code>sizemask</code>一定全是1给哈希函数算出来的值<code>&amp;</code>一下。下面我们来看一个<code>dictAdd</code>的调用过程，以验证我们的思路。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这些宏用来封装调用`dictType`中定义的方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br><span class="line"></span><br><span class="line"><span class="comment">// dictAddRaw &lt;- dictAdd</span></span><br><span class="line"><span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，在这里会调用一个<code>_dictKeyIndex</code>，这个函数给定<code>key</code>，返回哈希表中可以插入到的slot的index。如果key已经在哈希表中存在，返回-1，并通过<code>existing</code>取回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _dictKeyIndex &lt;- dictAddRaw &lt;- dictAdd</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 这个for循环将在下文讲解</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        <span class="comment">// 对每个表都搜索，但如果在rehash过程中返回的一定是ht[1]对应的索引值。</span></span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 注意Redis使用开链法解决哈希冲突，所以要搜完`d-&gt;ht[table].table[idx]`这条链。</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">// 如果key和he-&gt;key相等（指针相等或者值相等）</span></span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不在Rehash过程中，我们不找ht[1]，这个机制在后面的`dictFind`等函数中也会出现</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们返回idx即可，在后面插入的时候我们从**链表头**插入，</span></span><br><span class="line">    <span class="comment">// 这样的好处是一方面我们只要记录一个链表头，</span></span><br><span class="line">    <span class="comment">// 另一方面是Redis假设最近被添加的字段会被频繁访问。</span></span><br><span class="line">    <span class="comment">// 特别地，一般需要保存链表尾的场景包含需要快速pop</span></span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在刚才的代码中出现了<code>dict</code>这个结构，它也就是我们真正提供的完备的哈希表。因此，到这里的“继承关系”是<code>dict &lt;- dictht &lt;- dictEntry</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// `type`和`privdata`被用来实现类似继承的机制，这样我们可以自定义`dict`的行为。</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 这里的`ht[1]`在rehash的时候用。</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 用来表示此时Rehash的过程（具体机制查看后文）：</span></span><br><span class="line">    <span class="comment">// -1表示未在Rehash；</span></span><br><span class="line">    <span class="comment">// &gt;=0表示Rehash开始，将要移动`ht[0].table[rehashidx]`这个桶。</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx; </span><br><span class="line">    <span class="comment">// 表示这个字典上的**安全**迭代器的个数。</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure></p>
<p>当哈希表容量不够时就需要进行扩容，同时需要进行Rehash。扩容需要满足几个条件：</p>
<ol>
<li><code>used &gt;= size</code><br> 回忆一下，<code>used</code>是会大于<code>size</code>的，因为开链表。</li>
<li><code>dict_can_resize</code><br> 根据<code>updateDictResizePolicy</code>函数，在一些情况下<code>dict_can_resize</code>是<code>false</code>，这时候不会扩张。根据《Redis设计与实现》，这种情况发生在BGSLAVE或者BGREWRITEAOF命令运行时针对COW机制的一个优化。</li>
<li>但是当used/size大于一个比例，默认是5，会强制扩张（注意扩张还是按照2倍）。</li>
</ol>
<h3 id="哈希表的扩容与Rehash"><a href="#哈希表的扩容与Rehash" class="headerlink" title="哈希表的扩容与Rehash"></a>哈希表的扩容与Rehash</h3><p>下面我们正式来研究哈希表的扩容与Rehash部分<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此时正在进行Rehash（有没有很奇怪为啥会有个正在进行中的状态？请看下文）</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash表扩张条件：</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// size是要扩张到的大小，在计算时是按照used成比例放大的，所以肯定比used要大。</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假如ht[0]是空的，那这是一次初始化，直接将ht[0]指向新的hash表`n`。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则将ht[1]指向新的哈希表`n`。</span></span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到扩容操作只是创建了一个空的哈希表，并没有真正移动<code>ht[0]</code>的元素到<code>ht[1]</code>对应的位置上（这个过程被称作桶转移），难道这里又是COW了？通过优秀的英文能力，我们猜到了真正做Rehash的函数<code>int dictRehash(dict *d, int n)</code>，这个函数在<code>dictRehashMilliseconds</code>和<code>_dictRehashStep</code>中被调用。这个函数表示对<code>d</code>做<code>n</code>步的Rehash，其中一步表示将<code>ht[0]</code>中的一个桶<code>d-&gt;ht[0].table[d-&gt;rehashidx]</code>移到<code>ht[1]</code>上。注意，这里的<code>d-&gt;ht[0].table[d-&gt;rehashidx]</code>是一个开链表。容易看出<code>ht[0].size &gt; rehashidx</code>是始终成立的，因为<code>ht[0].size</code>就是桶的最多数量。注意这个<code>n</code>不包括空桶，Redis每次哈希可以跳过<code>empty_visits</code>个空桶，这时候我们要做的仅仅是自增<code>d-&gt;rehashidx</code>。<br><code>dictRehashMilliseconds</code>是一个时间相关的函数，它在ms毫秒的时间里面rehash尽可能多的桶，也就是每rehash 100个桶之后检查一下有没有超时，没有就接着来。这个函数在后台被定时调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementallyRehash</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Keys dictionary */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].dict)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].dict,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Expires */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].expires)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].expires,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">databasesCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> work_done = incrementallyRehash(rehash_db);</span><br></pre></td></tr></table></figure></p>
<p><code>_dictRehashStep</code>在诸如<code>dictAddRaw</code>、<code>dictGenericDelete</code>、<code>dictFind</code>、<code>dictGetRandomKey</code>等函数中被调用，作为<code>dictRehashMilliseconds</code>的补充。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="comment">// 只有当</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看一下Rehash的过程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="comment">// 跳过空桶。</span></span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始移动非空桶。</span></span><br><span class="line">        <span class="comment">// 注意我们不能直接将这个非空桶整个移植过去，因为里面的key在Rehash之后可能会去到其他的桶里面，</span></span><br><span class="line">        <span class="comment">// 所以我们用de来遍历这个开链表。</span></span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当ht[0].used为0时过程终止，将d-&gt;rehashidx设为-1。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        <span class="comment">// 将ht[1]按指针赋值给ht[0]。</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则Rehash还没有结束。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现在Rehash的过程中，调用<code>dictRehash</code>都将<code>ht[0]</code>掏空一点给<code>ht[1]</code>，直到最后过程结束后将<code>ht[1]</code>指针赋值给<code>ht[0]</code>，因此在Rehash的过程中我们插入必须对<code>ht[1]</code>，而查找删除优先在<code>ht[0]</code>操作，然后再<code>ht[1]</code>。Rehash在对哈希表每一次的增删改查中渐进进行，我们查看相关代码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictAddRaw</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">...</span><br><span class="line">ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line"><span class="comment">// dictFind</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"><span class="comment">// 调用对应的hash function获得哈希值h</span></span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    <span class="comment">// 找到第table(0或者1)个ht的第idx的元素</span></span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">            <span class="keyword">return</span> he;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在Rehash过程中，我们找完ht[0]就不找了，因为只可能ht[0]有内容</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// dictGenericDelete</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">...</span><br><span class="line"><span class="comment">// _dictKeyIndex</span></span><br><span class="line">见前面</span><br></pre></td></tr></table></figure></p>
<h2 id="遍历机制"><a href="#遍历机制" class="headerlink" title="遍历机制"></a>遍历机制</h2><p>Redis中的遍历分为两块，第一个是<code>dictScan</code>函数，第二个是借助<code>dictIterator</code>这个迭代器。<br>由于Redis中哈希表的动态扩展和缩小中有<strong>渐进</strong>Rehash的<strong>过程</strong>，所以做到恰巧一遍的遍历是非常难的，函数<code>dictScan</code>的实现确保了每个元素都能遍历到，但可能存在元素被重复遍历。函数<code>dictScan</code>接受一个cursor即参数<code>v</code>，并移动这个cursor，返回其新值，初始情况下我们传入<code>v</code>为0。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="comment">// 进行位反转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> v, dictScanFunction *fn, dictScanBucketFunction* bucketfn, <span class="keyword">void</span> *privdata)</span></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有元素，直接返回0，表示遍历完毕</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="comment">// 假设不在Rehash过程中，此时只有ht[0]中有元素</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这一串表示对桶和桶中所有元素调用bucketfn和fn回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v |= ~m0;</span><br><span class="line">        v = rev(v);</span><br><span class="line">        v++;</span><br><span class="line">        v = rev(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里对<code>v</code>的更新十分奇妙，按照理想情况，我们完全可以去直接<code>v++</code>然后遍历完所有的桶，但是那四行代码的行为却很奇特，这种遍历方法被称为reverse binary iteration。首先第一行将<code>v</code>的高位0全部置为1，第二行将<code>v</code>按比特反转，这时候高位填充的1就到了最低位上。接着后面两行进行自增，再倒回去。以<code>mask = (uint8_t) 15</code>、<code>v = (uint8_t) 2</code>为例查看一下这个过程。</p>
<pre><code>00000010(2) -&gt; 11110010 -&gt; 01001111 -&gt; 01010000 -&gt; 00001010(10)
</code></pre><p>我们从<code>v=0</code>开始迭代，发现值依次是</p>
<pre><code>0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 0
0b0000 0b1000 0b0100 0b1100 0b0010 0b1010 0b0110 0b1110 0b0001 0b1001 0b0101 0b1101 0b0011 0b1011 0b0111 0b1111
</code></pre><p>为什么要做这样的设计呢？我们考虑将数字<code>[0,7]</code>哈希到2和4的不同情况，可以发现哈希到4时每个slot里数字的后<strong>2</strong>位都相同，而哈希到2时每个slot里数字的后<strong>1</strong>位相同。我们可以认为从$2^i$到$2^{i+1}$，我们将每个slot中的数按照第<code>i</code>位的值分成两个slot。</p>
<pre><code>0(00):0(000),4(100)
1(01):1(001),5(101)
2(10):2(010),6(110)
3(11):3(011),7(111)
===
0:0(000),2(010),4(100),6(110)
1:1(001),3(011),5(101),7(111)
</code></pre><p>在上面讨论了更通用的情形，特别用了slot而不是之前提到的桶的概念。在这篇文章中，一个桶指的是<code>ht</code>中哈希值相同的所有元素组成的链表，现在讨论的<code>dictScan</code>是针对桶的扫描而不是元素的扫描。特别地，我们将哈希表中的<code>N</code>个桶合并成<code>N/2</code>个桶时，相当于做一次针对桶的哈希。考虑一个8个桶的哈希表，其桶的遍历顺序是<code>0 4 2 6 1 5 3 7 0</code>。假设遍历<code>6(110)</code>前我们将8个桶缩小到4个桶，那么桶6中的元素应当被映射到新桶<code>2(10)</code>中了，因此我们应当遍历<code>2(10)</code>这个桶，此时我们<strong>已经遍历过</strong>的桶如下示意</p>
<pre><code>新桶      原桶
0(00):0(000),4(100)
1(01):
2(10):2(010)
3(11):
</code></pre><p>容易发现此时我们重复遍历了原来桶<code>2(010)</code>中的元素。这个过程结束时新的<code>mask</code>为3，<code>v</code>会更新到<code>1(01)</code>，我们发现下面要遍历的<code>1 5</code>两个就桶被合并到了<code>1(01)</code>这个新桶里面。如果考虑遍历<code>2(010)</code>前发生了缩小，那么我们就不要重复遍历元素。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器的声明如下，容易看出通过<code>d</code>、<code>index</code>和<code>table</code>我们可以确定一个桶。<code>safe</code>表示这个迭代器是否是一个安全的迭代器。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="comment">// 迭代器当前所指向的dictEntry位置</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="comment">// 正在被迭代的dictht号码，值可以是 0 或 1</span></span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">// 标识这个迭代器是否安全</span></span><br><span class="line">    <span class="keyword">int</span> safe;</span><br><span class="line">    <span class="comment">// 当前迭代到的节点的指针</span></span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    <span class="comment">// 见下文说明</span></span><br><span class="line">    dictEntry *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure></p>
<p>我们将在下面逐一介绍相关的字段用法</p>
<ol>
<li><p>安全迭代器<br> 安全的迭代器是什么意思呢？比如在Rehash机制中，存在safe迭代器的情况下是暂停Rehash的。只有当<code>iterators</code>数量为0时，才会进行Rehash。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 需要注意的是，在<a href="https://github.com/redis/redis/blob/6.0.0/src/dict.c" target="_blank" rel="noopener">Redis的6.0版本</a>上，dictScan也会增加iterators，从而导致rehash停止。而在<a href="https://github.com/redis/redis/blob/5.0.0/src/dict.c" target="_blank" rel="noopener">5.0版本</a>还没有这个限制。</p>
</li>
<li><p>fingerprint<br> 用来将两个<code>ht</code>的指针、<code>size</code>和<code>used</code>进行哈希，在<code>dictNext</code>开始和结束之后比较哈希值，如果不一样的话，就<code>assert</code>。这主要是用来保证，当不安全迭代器被使用时，该迭代器的使用者不能对这个哈希表做出不合法的操作。</p>
</li>
</ol>
<h3 id="dict迭代器相关方法"><a href="#dict迭代器相关方法" class="headerlink" title="dict迭代器相关方法"></a>dict迭代器相关方法</h3><p>搜索dict这个迭代器主要作用是在<strong>redis内部</strong>，例如持久化相关的工作。dict迭代器的相关方法主要包括<code>dictNext</code>、<code>dictGetIterator</code>、<code>dictGetSafeIterator</code>、<code>dictReleaseIterator</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有指定dictEntry</span></span><br><span class="line">            <span class="comment">// iter-&gt;table初始值是0</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这边是初始化</span></span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通常操作，找到下一个entry</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">// 但如果这个dictht遍历完了</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">// 如果同时有两个表(dictIsRehashing条件)，且表0遍历完了，就切换到表1</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再设置一下entry</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果指定了dictEntry，说明是之前有遍历到某个dictht的一半，这是大部分情况，所以就直接到nextEntry</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            <span class="comment">// 这里要记录nextEntry的原因是安全迭代器是能够对哈希表进行增删的，因此如果iter-&gt;entry在迭代时被删除了，那么就会导致iter-&gt;entry-&gt;next是无法访问的，因此这里要提前保存一下</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="dict的其他相关方法"><a href="#dict的其他相关方法" class="headerlink" title="dict的其他相关方法"></a>dict的其他相关方法</h2><h3 id="dict遍历抽象主干代码"><a href="#dict遍历抽象主干代码" class="headerlink" title="dict遍历抽象主干代码"></a>dict遍历抽象主干代码</h3><p>由于在dict中常出现遍历操作，为了方便阅读代码，我们将整个遍历操作先抽象出来，在下面相关代码的介绍中，只列出主干。关于这个循环的说明，可以参看<code>_dictKeyIndex</code>的讲解<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">    prevHe = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在Rehash过程中，就不需要查找table=1的表了</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h3><p>这个函数用来根据给定的key找到对应的<code>dictEntry</code>，如果找不到，就返回<code>NULL</code>。<br>其中涉及一些Rehash相关的机制，我们在先前已经讲过了，在这里就略过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="comment">// 参考“dict遍历抽象主干代码”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="dictGet系列函数"><a href="#dictGet系列函数" class="headerlink" title="dictGet系列函数"></a>dictGet系列函数</h3><p>这个系列的函数主要通过读取<code>union v</code>里面的不同类型的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="dictDelete"><a href="#dictDelete" class="headerlink" title="dictDelete"></a>dictDelete</h3><p>在前面已经看到，<code>dictDelete</code>系列函数相比其他操作会多一个场景，也就是是不是立即将key和value的对象free掉。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">    <span class="comment">// 参考“dict遍历抽象主干代码”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这里对dict遍历抽象主干代码的处理会有一些修改，首先用<code>prevHe</code>来记录待删除节点<code>he</code>的父节点，从而将链表接起来。然后是一个<code>nofree</code>选项，可以不去析构key和value。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">prevHe = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">while</span>(he) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">        <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">        <span class="keyword">if</span> (prevHe)</span><br><span class="line">            prevHe-&gt;next = he-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">            dictFreeKey(d, he);</span><br><span class="line">            dictFreeVal(d, he);</span><br><span class="line">            zfree(he);</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[table].used--;</span><br><span class="line">        <span class="keyword">return</span> he;</span><br><span class="line">    &#125;</span><br><span class="line">    prevHe = he;</span><br><span class="line">    he = he-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="HSET的相关数据结构"><a href="#HSET的相关数据结构" class="headerlink" title="HSET的相关数据结构"></a>HSET的相关数据结构</h2><h1 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h1><p>在本章中，我们将会从ZSET切入，了解它是如何包装ziplist和zskiplist的。<br>ZSET有两个实现，基于跳表的和基于ziplist的，具体来说：</p>
<ol>
<li>ziplist：是一个双向压缩链表的实现，这里的压缩链表指的是不会保存prev和next信息，而是采用类似线性表的方式将整个list存放在一整块内存中。对应于元素数量少于128，且每个元素的长度小于64字节</li>
<li>zskiplist：是个跳表的实现。对应于1之外的情况</li>
</ol>
<h2 id="ZSET和zadd"><a href="#ZSET和zadd" class="headerlink" title="ZSET和zadd"></a>ZSET和zadd</h2><p>从<code>redisCommandTable</code>找到绑定的函数<code>zaddCommand</code>，它会调用一个<code>zaddGenericCommand</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看<code>zaddGenericCommand</code>，它接受一个<code>flags</code>参数，我们稍后介绍。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">"resulting score is not a number (NaN)"</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* The following vars are used in order to track what the command actually</span></span><br><span class="line"><span class="comment">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class="line"><span class="comment">     * notification of keyspace change. */</span></span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br></pre></td></tr></table></figure></p>
<p>下面一部分代码是用来处理一些额外输入的flag参数，这里引入了<code>scoreidx</code>表示score/value对开始的位置，在3.0版本中写死了是2，但是由于后面版本允许了<code>nx</code>、<code>xx</code>等参数，所以这边改为动态计算的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scoreidx = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">    <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"nx"</span>)) flags |= ZADD_NX;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"xx"</span>)) flags |= ZADD_XX;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"ch"</span>)) flags |= ZADD_CH;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"incr"</span>)) flags |= ZADD_INCR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    scoreidx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line"><span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码主要是校验参数的合法性<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是一个通常的做法，类似于Spark里面的KV存储一样，把score和elements存得很整齐。</span></span><br><span class="line">elements = c-&gt;argc-scoreidx;</span><br><span class="line"><span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">    addReply(c,shared.syntaxerr);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">elements /= <span class="number">2</span>; <span class="comment">/* Now this holds the number of score-element pairs. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for incompatible options. */</span></span><br><span class="line"><span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">    addReplyError(c,</span><br><span class="line">        <span class="string">"XX and NX options at the same time are not compatible"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    addReplyError(c,</span><br><span class="line">        <span class="string">"INCR option supports a single increment-element pair"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们开始正式处理参数了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取回输入的score，或者报错，注意这里是从用户的输入取的</span></span><br><span class="line"><span class="comment">// 可以看出，偶数位是分数，奇数位是字段值</span></span><br><span class="line">scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">        != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数据库中找到这个ZSET对象</span></span><br><span class="line">zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line"><span class="comment">// 检查是否是OBJ_ZSET类型</span></span><br><span class="line"><span class="keyword">if</span> (checkType(c,zobj,OBJ_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line"><span class="comment">// 如果这个对象还没有被创建，就创建</span></span><br></pre></td></tr></table></figure></p>
<p>为了阅读接下来的代码，首先了解两个参数，可以看到，这两个参数就是规定了何时使用ziplist的阈值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createSizeTConfig(<span class="string">"zset-max-ziplist-value"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.zset_max_ziplist_value, <span class="number">64</span>, MEMORY_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>),</span><br><span class="line">createSizeTConfig(<span class="string">"zset-max-ziplist-entries"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.zset_max_ziplist_entries, <span class="number">128</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后我们来看一下两个对象的创建方法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_ZSET,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面来看一下创建的逻辑，可以发现，在创建时默认是创建一个ziplist的，其实在后面<code>zsetAdd</code>添加的时候，当超出了ziplist的阈值的时候会调用<code>zsetConvert</code>来转成skiplist。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">        server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果zset_max_ziplist_entries是0，也就是说不管怎么样都不会创建ziplist了，</span></span><br><span class="line">        <span class="comment">// 或者第一个要加入的元素就已经超长了</span></span><br><span class="line">        zobj = createZsetObject();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则还是先创建一个ziplist</span></span><br><span class="line">        zobj = createZsetZiplistObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向db注册这个zobj</span></span><br><span class="line">    dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，就是调用<code>zsetAdd</code>依次往ZSET里面添加元素了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个应该是用来支持CH参数的</span></span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        <span class="comment">// 如果指定了CH，就返回增加和修改的数量，否则只返回增加的数量</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">"zincr"</span> : <span class="string">"zadd"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="zsetAdd的实现"><a href="#zsetAdd的实现" class="headerlink" title="zsetAdd的实现"></a>zsetAdd的实现</h2><h3 id="zsetAdd"><a href="#zsetAdd" class="headerlink" title="zsetAdd"></a>zsetAdd</h3><p>在3.0版本里面，并没有这个函数，而是直接放到了<code>zaddGenericCommand</code>里面。但由于后续版本支持了各种flag（注意3.0是可以incr的），逻辑复杂了，所以单独做出了一个函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</span><br></pre></td></tr></table></figure></p>
<p>首先来讨论一下参数，<code>flags</code>按照指针传递，是因为它同时用来保存输入信息和输出信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Input flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_INCR (1&lt;&lt;0)    <span class="comment">/* Increment the score instead of setting it. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NX (1&lt;&lt;1)      <span class="comment">/* Don't touch elements not already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_XX (1&lt;&lt;2)      <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NOP (1&lt;&lt;3)     <span class="comment">/* Operation not performed because of conditionals.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NAN (1&lt;&lt;4)     <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_ADDED (1&lt;&lt;5)   <span class="comment">/* The element was new and was added. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_UPDATED (1&lt;&lt;6) <span class="comment">/* The element already existed, score updated. */</span></span></span><br></pre></td></tr></table></figure></p>
<p><code>newscore</code>被用来存储返回的incr后的分数。<br>下面我们来看函数的具体实现过程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line"><span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">*flags = <span class="number">0</span>; <span class="comment">/* We'll return our response flags. */</span></span><br><span class="line"><span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* NaN as input is an error regardless of all the other parameters. */</span></span><br><span class="line"><span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">    *flags = ZADD_NAN;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>ziplist存储的分支</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Update the sorted set according to its encoding. */</span></span><br><span class="line"><span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果已经找到了这个元素</span></span><br><span class="line">        <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">        <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">        <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">            score += curscore;</span><br><span class="line">            <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                *flags |= ZADD_NAN;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果需要取回score的值，则newscore不为NULL，那么就顺便返回</span></span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过先删除再添加的方法来实现修改score</span></span><br><span class="line">        <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">            zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">            *flags |= ZADD_UPDATED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到，并且没有xx选项（xx选项表示只更新不添加），那么就进行添加</span></span><br><span class="line">        <span class="comment">/* Optimize: check if the element is too large or the list</span></span><br><span class="line"><span class="comment">         * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">        zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">        <span class="comment">// 如果超过阈值，就要转换成跳表</span></span><br><span class="line">        <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||</span><br><span class="line">            sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">            zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">        <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">        *flags |= ZADD_ADDED;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *flags |= ZADD_NOP;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用跳表存储的分支</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 需要同时更新哈希表和跳表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看成员是否存在</span></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果成员存在</span></span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出成员的分值</span></span><br><span class="line">            <span class="comment">// 其中de是dictEntry</span></span><br><span class="line">            <span class="comment">// #define dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line">            <span class="comment">// #define dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                <span class="comment">// 对于跳表来讲，就有一个单独的函数了，对于某些情况，能够原地更新，但对于特殊情况会先删除再加上</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">/* Note that we did not removed the original element from</span></span><br><span class="line"><span class="comment">                 * the hash table representing the sorted set, so we just</span></span><br><span class="line"><span class="comment">                 * update the score. */</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="zsetConvert"><a href="#zsetConvert" class="headerlink" title="zsetConvert"></a>zsetConvert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zsetConvert</span><span class="params">(robj *zobj, <span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">    zset *zs;</span><br><span class="line">    zskiplistNode *node, *next;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == encoding) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_SKIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">        zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">        zs-&gt;zsl = zslCreate();</span><br><span class="line"></span><br><span class="line">        eptr = ziplistIndex(zl,<span class="number">0</span>);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,sptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (eptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            score = zzlGetScore(sptr);</span><br><span class="line">            serverAssertWithInfo(<span class="literal">NULL</span>,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>)</span><br><span class="line">                ele = sdsfromlonglong(vlong);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ele = sdsnewlen((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line"></span><br><span class="line">            node = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;node-&gt;score) == DICT_OK);</span><br><span class="line">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(zobj-&gt;ptr);</span><br><span class="line">        zobj-&gt;ptr = zs;</span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Approach similar to zslFree(), since we want to free the skiplist at</span></span><br><span class="line"><span class="comment">         * the same time as creating the ziplist. */</span></span><br><span class="line">        zs = zobj-&gt;ptr;</span><br><span class="line">        dictRelease(zs-&gt;dict);</span><br><span class="line">        node = zs-&gt;zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zfree(zs-&gt;zsl-&gt;header);</span><br><span class="line">        zfree(zs-&gt;zsl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            zl = zzlInsertAt(zl,<span class="literal">NULL</span>,node-&gt;ele,node-&gt;score);</span><br><span class="line">            next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            zslFreeNode(node);</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(zs);</span><br><span class="line">        zobj-&gt;ptr = zl;</span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h1><p><code>zskiplist</code>是跳表，Redis用它来作为有序集合ZSET的一个实现。<br>跳表的查找复杂度是平均$O(log n)$最坏$O(n)$，而插入/删除复杂度是$O(log n)$。</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>容易看到，这里的<code>level</code>是一个Flex Array，这是C99里面的特性，实际上是一个长度为0的数组。</p>
<h3 id="zslCreateNode"><a href="#zslCreateNode" class="headerlink" title="zslCreateNode"></a>zslCreateNode</h3><p>我们进一步查看<code>zslCreateNode</code>是如何被初始化的，容易看出，它的空间占用等于<code>zskiplistNode</code>的大小，加上<code>level</code>的长度乘以<code>zskiplistLevel</code>的大小。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="跳表数据结构的展现"><a href="#跳表数据结构的展现" class="headerlink" title="跳表数据结构的展现"></a>跳表数据结构的展现</h3><p>下面的代码可以轻松地打印出zskiplist的结构。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printZsl</span><span class="params">(zskiplist *zsl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot_level = zsl-&gt;level;</span><br><span class="line">    <span class="keyword">int</span> node_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> join_size = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SUMMARY: tot level %d\n"</span>, tot_level);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; tot_level; level++)&#123;</span><br><span class="line">        zskiplistNode * prev = <span class="number">0</span>;</span><br><span class="line">        zskiplistNode * x = zsl-&gt;header;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  &#123;</span><br><span class="line">            <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(level &amp;&amp; prev)&#123;</span><br><span class="line">                zskiplistNode * y = prev;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y-&gt;ele != x-&gt;ele) &#123;</span><br><span class="line">                        gap ++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(y-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">                        y = y-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> length = (gap - <span class="number">1</span>) * node_len;</span><br><span class="line">                <span class="keyword">int</span> modified_length = length &lt;= <span class="number">0</span> ? <span class="number">0</span> : length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; modified_length; kk++) <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf, <span class="string">"(%3.3s)[S:%2ld]%*s"</span>, x-&gt;ele, x-&gt;level[level].span, join_size, <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(node_len == <span class="number">0</span>) node_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            <span class="built_in">printf</span>(buf);</span><br><span class="line">            prev = x;</span><br><span class="line">            <span class="keyword">if</span>(x-&gt;level[level].forward)</span><br><span class="line">                x = x-&gt;level[level].forward;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"node_len %d\n"</span>, node_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们修改<code>zslInsert</code>代码，并输入下面的语句，为了便于得到更高的跳表，我们设置<code>ZSKIPLIST_P</code>到0.5（参考下文）。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd zs2 <span class="number">1</span> a <span class="number">2</span> b <span class="number">10</span> c <span class="number">5</span> d <span class="number">5</span> e <span class="number">6</span> f1 <span class="number">6</span> f2 <span class="number">6</span> f3 <span class="number">6</span> f4 <span class="number">6</span> f5 <span class="number">6</span> f6 <span class="number">6</span> f7 <span class="number">6</span> f8 <span class="number">6</span> f9 <span class="number">6</span> f10 <span class="number">6</span> f11</span><br></pre></td></tr></table></figure></p>
<p>得到打印的结果如下<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SUMMARY: tot level <span class="number">7</span></span><br><span class="line">(   )[S: <span class="number">1</span>]  (  a)[S: <span class="number">1</span>]  (  b)[S: <span class="number">1</span>]  (  d)[S: <span class="number">1</span>]  (  e)[S: <span class="number">1</span>]  ( f1)[S: <span class="number">1</span>]  (f10)[S: <span class="number">1</span>]  ( f2)[S: <span class="number">1</span>]  ( f3)[S: <span class="number">1</span>]  ( f4)[S: <span class="number">1</span>]  ( f5)[S: <span class="number">1</span>]  ( f6)[S: <span class="number">1</span>]  ( f7)[S: <span class="number">1</span>]  ( f8)[S: <span class="number">1</span>]  ( f9)[S: <span class="number">1</span>]  (  c)[S: <span class="number">0</span>]  </span><br><span class="line">(   )[S: <span class="number">1</span>]  (  a)[S: <span class="number">1</span>]  (  b)[S: <span class="number">1</span>]  (  d)[S: <span class="number">1</span>]  (  e)[S: <span class="number">2</span>]  .............(f10)[S: <span class="number">1</span>]  ( f2)[S: <span class="number">5</span>]  ....................................................( f7)[S: <span class="number">1</span>]  ( f8)[S: <span class="number">2</span>]  </span><br><span class="line">(   )[S: <span class="number">1</span>]  (  a)[S: <span class="number">1</span>]  (  b)[S: <span class="number">1</span>]  (  d)[S: <span class="number">4</span>]  .......................................( f2)[S: <span class="number">5</span>]  ....................................................( f7)[S: <span class="number">1</span>]  ( f8)[S: <span class="number">2</span>]  </span><br><span class="line">(   )[S: <span class="number">2</span>]  .............(  b)[S: <span class="number">1</span>]  (  d)[S: <span class="number">4</span>]  .......................................( f2)[S: <span class="number">6</span>]  .................................................................( f8)[S: <span class="number">2</span>]  </span><br><span class="line">(   )[S: <span class="number">2</span>]  .............(  b)[S: <span class="number">1</span>]  (  d)[S: <span class="number">4</span>]  .......................................( f2)[S: <span class="number">8</span>]  </span><br><span class="line">(   )[S: <span class="number">2</span>]  .............(  b)[S: <span class="number">1</span>]  (  d)[S:<span class="number">12</span>]  </span><br><span class="line">(   )[S: <span class="number">2</span>]  .............(  b)[S:<span class="number">13</span>]  </span><br><span class="line">node_len <span class="number">13</span></span><br></pre></td></tr></table></figure></p>
<p>可以比较容易得看出：</p>
<ol>
<li>header节点是空的</li>
<li>span表示当前层上相邻两个节点的实际距离。对于level 0来说，相邻两个节点的实际距离一定为1</li>
</ol>
<h2 id="zslInsert的实现"><a href="#zslInsert的实现" class="headerlink" title="zslInsert的实现"></a>zslInsert的实现</h2><h3 id="跳表遍历抽象主干代码"><a href="#跳表遍历抽象主干代码" class="headerlink" title="跳表遍历抽象主干代码"></a>跳表遍历抽象主干代码</h3><p>我们首先看到的是跳表遍历抽象的主干代码，它会在很多地方重复出现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示我们在第i层的第update[i]节点后面，插入新节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="comment">// 这是一个临时变量，前期做迭代用，后期表示新节点</span></span><br><span class="line">    zskiplistNode *x; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">// x是表头节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层节点（跨度最大）逐层向下遍历，这样方便复用，稍后将看到我们新增节点的时候是从下往上构建的</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">// 最终rank[0]的值加一就是新节点的前置节点(update)的排位</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果要插入的score，比前面节点的score还要大，就前进</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    <span class="comment">// 如果score相等，那么就比较ele</span></span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// x-&gt;level[i].span表示第i层上，当前节点到forward节点的中间有多少个节点，比如这是第t个节点，那么经过了a_&#123;t+1&#125; – a&#123;t&#125;个节点。</span></span><br><span class="line">            <span class="comment">// rank[i]表示这个节点排第几</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">// 前进节点</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于第i层，我们要修改这个节点，它是score最大的小于要插入的x的节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在以上的代码执行完之后，我们得到了计算好的<code>update</code>和<code>rank</code>数组。我们要在<code>update[i]</code>后面插入节点，并且用<code>rank[i]</code>来更新span。<br>在这里，我们假设元素没有在跳表中，这是因为：</p>
<ol>
<li>跳表是通过score排序的，而score是允许重复的，所以无法通过score来判断。</li>
<li>而在跳表中插入相同的元素是不可能的情况，因为zslInsert的调用者通过dict来维护是否有相同元素。</li>
</ol>
<p>在插入新节点前，首先需要为这个节点生成一个随机层高，同时处理这个随机层高大于现有层高的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续zslInsert</span></span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">// 如果新节点的level比这个跳表的最大层数zsl-&gt;level都大，即出现一个珠穆朗玛峰了，</span></span><br><span class="line">        <span class="comment">// 初始化一下zsl-&gt;level以上的所有的层</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新跳表的最大层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">// 函数待续</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面就是将新增的节点插入跳表中。新链表的前后顺序是<code>update -&gt; x -&gt; update.forward</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续zslInsert</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 主要就是分配一个zskiplistNode，并且设置score和ele。</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新x前向指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">// 更新update前向指针</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br></pre></td></tr></table></figure>
<p>这里面涉及一个span的概念。span表示当前节点当前层的后向指针跨越了多少节点。由于<code>x</code>被插到了中间，所以需要更新<code>x</code>和<code>update</code>的span。<br>对于<code>x</code>而言，它继承了<code>update</code>的span的后半部分，这个后半部分的长度等于总span的长度减去从<code>update</code>到<code>x</code>的span。<br>为了方便理解，不如先看<code>i=0</code>的情况。<br>计算<code>x</code>最下层的span，即<code>x-&gt;level[0].span</code>，结果是<code>update[i]-&gt;level[i].span</code>。这是因为<code>x</code>是紧插到<code>update</code>后面的，这样会导致<code>x</code>实际上继承了<code>update</code>的span。<br>计算<code>update</code>最下层的span，即<code>update[0]-&gt;level[0].span</code>，结果是<code>rank[0]-ran[0]+1=1</code>。这是因为<code>update</code>紧后面就是<code>x</code>了，所以这里的1就表示跨越到<code>x</code>节点的距离。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 计算对于新增节点而言，它第i层的span</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在level层及之上，新节点x是没有对应的节点的，所以span要自增。</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新节点的前向节点始终是update[0]，也就是最底层的前驱</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="zslUpdateScore的实现"><a href="#zslUpdateScore的实现" class="headerlink" title="zslUpdateScore的实现"></a>zslUpdateScore的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we'll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header; </span><br><span class="line">    <span class="comment">// 参考zslInsert，主要是为了取得update和x</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>在下面几种情况下，可以不进行先删除再添加的操作，而只是更新score：</p>
<ol>
<li>如果是第一个节点，或者前面的节点的分数比新分数要小。</li>
<li>或者是最后一个节点（必须最下层），或者后面的节点的分数比新分数要大。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">    (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore))</span><br><span class="line">&#123;</span><br><span class="line">    x-&gt;score = newscore;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>在更通用的情况下，我们只能删除原节点<code>x</code>，并且重新插入新节点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    <span class="comment">// 这里复用原节点的ele字段，所以置为NULL，防止被delete</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h1><p>ziplist是一个比较神奇的结构，通常被用在ZSET和HASH等结构上面。首先我们解释一下它的名字</p>
<ol>
<li>zip<br> 说明ziplist是压缩的，空间优化的。那么既然优化了空间，时间可能就会受损。  </li>
<li>list<br> 说明ziplist是一个双向链表，可以存储SDS和整数。</li>
</ol>
<h2 id="格式与创建"><a href="#格式与创建" class="headerlink" title="格式与创建"></a>格式与创建</h2><p>首先，分配了头部和尾部的空间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br></pre></td></tr></table></figure></p>
<p>那么头部和尾部究竟是什么呢？<br>头部包含了32位的int，表示总长度；32位的int表示最后一个元素的offset。16位表示item的数量。在头部保存尾部指针的实现逻辑在链表中是非常常见的，这使得查找尾部的操作是$O(1)$的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br></pre></td></tr></table></figure></p>
<p>尾部有一个”end of ziplist” entry，它是一个值为255的byte，表示结束。不过为什么需要这个<code>ZIP_END</code>来表示结束呢？也许是为了遍历的方便，那么在这里我们就能猜测到ziplist里面的元素肯定是<strong>经过特殊编码</strong>的，255这个编码表示结束，没有第二个编码长这样。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the "end of ziplist" entry. Just one byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br></pre></td></tr></table></figure></p>
<p>这两个宏可以取头和尾<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return total bytes a ziplist is composed of. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of the last item inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br></pre></td></tr></table></figure></p>
<p>下面继续看实现，我们可以看到，ziplist的大小是包括了头和尾的大小的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>下面我们来看看ziplist的编码格式<br>首先我们知道了<code>ZIP_END</code>是255表示结束。</p>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog算法主要用在基数统计中，也就是能用很小的内存占用统计出集合的大小。在Redis中，只需要大概12KB的内存就能够统计接近<code>2**64</code>个不同元素的基数。<br>HyperLogLog算法是对LogLog算法的改进。包括LogLog Counting采用的算数/几何平均数对离群值（比如0）更敏感，而HyperLogLog采用了调和平均。这里的LogLog指的是算法复杂度是$O(log(log(N_{max})))$</p>
<h2 id="HLL原理"><a href="#HLL原理" class="headerlink" title="HLL原理"></a>HLL原理</h2><p>HLL通过一个哈希函数把输入<code>x</code>映射到一个bitset上，然后对这个bitset进行考察。考虑bitset长度为4，那么出现<code>0001</code>这样的结果的概率是<code>1/16</code>，也就是说平均要抛16次才能得到。在对数字的二进制表示进行采样的过程中，我们认为有一半的数字是以<code>1</code>开头的，另一半是以<code>0</code>开头的。同理，有1/4的数字是以<code>01</code>开头的，1/8以<code>001</code>开头的。那么在一个随机流中，我们恰恰发现一个<code>001</code>开头的，那么至少这个集合有8个元素。<br>我们可以进行推广，考虑长度为<code>L</code>的bitset，那么前<code>k-1</code>项都为0，而第<code>k</code>项为1的概率，根据二项分布是$1/2^k$。因此我们就可以通过统计bitset中第一个1出现的位置来估算数量。具体来说，我们把一批元素通过哈希函数处理成一系列bitset并放入一个桶里面，然后我们统计这个桶里面1出现的位置的最大值。我们假设最左端是第<strong>1</strong>位，那么假如第一个1出现的位置的最大值是在第$m$位，那么集合中就有$2^m$个元素。<br>为了提高精度，实际上可以使用多个桶而不是一个桶来进行统计，但在Redis中使用了一个分桶的技巧，也就是说给定一个序号$b$，将bitset中小于$b$的所有位数<code>bitset[0..(b-1)]</code>决定桶的序号。那么最终就能够得到这$2^b$个桶中的预估元素个数$2^{m_i}$。<br>HLL使用<strong>调和平均数</strong>来计算每个桶元素的个数，令$B  = 2^b$，表示总的桶数。那么计算$A$就是平均每个桶里面的元素个数。</p>
<p>$$<br>A = \frac{B}{\sum_{i=1}^{B}{2^{-m_i}}} = \frac{B}{\sum_{i=1}^{B}{ \frac{1}{2^{m_i}}  }}<br>$$</p>
<p>那总元素的个数就是$AB$。</p>
<p>在实际操作的时候，发现有一个问题，例如有的桶直接就是0，也就是说没有出现一个1，对这种情况我们如何处理呢？或者说，我们认为这表示这个集合的值是比<code>001</code>这样的小还是大呢？我觉得，其实应该认为这个集合是远远大于<code>001</code>的，事实上集合的大小至少应该等于<code>10...0</code>（共有len(bitset)个0）。形象一点，这里都是0的原因是因为真正的1其实还在更前面！所以在计算的时候，<code>0...00</code>和<code>0...01</code>表示的值之间就会存在一个很大的落差，不知道我理解是否正确。</p>
<p>最后，我们得到的$AB$其实不准确，还需要进行修正。</p>
<h2 id="Redis的HLL的基本结构"><a href="#Redis的HLL的基本结构" class="headerlink" title="Redis的HLL的基本结构"></a>Redis的HLL的基本结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* "HYLL" */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE or HLL_SPARSE. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先是<code>encoding</code>，它的取值是<code>HLL_DENSE</code>和<code>HLL_SPARSE</code>，分别对应Dense存储模式和Sparse存储模式。此外，在内部还会有一个<code>HLL_RAW</code>的模式，这个只在pfcount上用到，并且不对外暴露。<br>Dense模式就是经典的HLL算法，其中<code>registers</code>大概占据了12KB的大小。<br>Sparse模式是创建时默认的，实际上不会占用12KB的大小，主要用来表达连续<strong>多个桶的值为0</strong>的情况，也就是用CPU换存储。它使用下面三种编码方式：</p>
<ol>
<li>ZERO：格式为<code>00xxxxxx</code><br> 表示<code>xxxxxx</code>+1个0，所以实际上能够表示最多64个0</li>
<li>XZERO：格式为<code>01xxxxxx yyyyyyyy</code><br> 前面的6个x叫Most Signigicent Bits(MSB)，后面8个y叫Least Significant Bits(LSB)。所以可以表示16384个0，这也对应了后面提到的<code>HLL_SPARSE_XZERO_MAX_LEN</code>这个宏的取值，刚好等于<code>HLL_REGISTERS</code>的值。</li>
<li>VAL：格式为<code>1vvvvvxx</code><br> 5个v表示重复的计数值，2个x表示重复的桶的数量，也就是说有连续<code>xx</code>+1(&lt;4)个桶的值都是<code>vvvvv</code>+1(&lt;32)</li>
</ol>
<p>容易发现，在一开始，因为一个数都没有加入HLL中，所以桶的结构。而到VAL之后，随着计数值的增长，当出现超过32的值之后，就会切换为Dense模式。</p>
<h2 id="createHLLObject实现"><a href="#createHLLObject实现" class="headerlink" title="createHLLObject实现"></a>createHLLObject实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hyperloglog.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_HDR_SIZE sizeof(struct hllhdr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P_MASK (HLL_REGISTERS-1) <span class="comment">/* Mask to index register. */</span></span></span><br></pre></td></tr></table></figure>
<p>先说一下这几个常数，<code>HLL_REGISTERS</code>表示有多少个桶，默认<code>HLL_P</code>取14，实际上就是有16384个桶（对应到<code>registers</code>）。<code>HLL_P_MASK</code>可以通过<code>&amp;</code>来取出实际桶的序号。由于创建的HLL结构中每个桶的值都是0，所以默认肯定是Sparse存储省空间。现在需要手动构造一下。首先分配<code>sparselen</code>的空间，包括：</p>
<ol>
<li><code>HLL_HDR_SIZE</code>也就是HLL头部的大小</li>
<li>register的空间<br>$$<br>\frac{(HLL\_REGISTERS+(HLL\_SPARSE\_XZERO\_MAX\_LEN-1))}{HLL\_SPARSE\_XZERO\_MAX\_LEN} * 2<br>$$<br>这个公式看起来很奇怪，但是$\frac{X + (Y-1)}{Y}$实际上是向上取整的常规操作，所以说实际上要做的就是算出<br>$$<br>\lceil \frac{HLL\_REGISTERS}{HLL\_SPARSE\_XZERO\_MAX\_LEN} \rceil * 2<br>$$<br>所以这就好理解了，总共有多少个桶，然后除以每个XZERO opcode能放存多少个桶，最后乘以2，因为每个XZERO占用两个bytes。而一个<code>HLL_SPARSE_XZERO_MAX_LEN</code>能表示16384个桶，这在上文已经讲解过了，刚好等于<code>HLL_REGISTERS</code>的值，因此实际上一开始所有register用两个bytes就完全可以cover了。<br>打印下来发现<code>sparselen</code>为18，<code>HLL_HDR_SIZE</code>是16，所以确实一开始register只用了两个字节。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createHLLObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p;</span><br><span class="line">    <span class="keyword">int</span> sparselen = HLL_HDR_SIZE +</span><br><span class="line">                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN<span class="number">-1</span>)) /</span><br><span class="line">                     HLL_SPARSE_XZERO_MAX_LEN)*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sparselen %d HLL_HDR_SIZE %d\n"</span>, sparselen, HLL_HDR_SIZE);</span><br><span class="line">    <span class="keyword">int</span> aux;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>分配完空间，下面就是要初始化，具体做法就是调用<code>HLL_SPARSE_XZERO_SET</code>每两个字节set一下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Populate the sparse representation with as many XZERO opcodes as</span></span><br><span class="line"><span class="comment"> * needed to represent all the registers. */</span></span><br><span class="line">aux = HLL_REGISTERS;</span><br><span class="line">s = sdsnewlen(<span class="literal">NULL</span>,sparselen);</span><br><span class="line">p = (<span class="keyword">uint8_t</span>*)s + HLL_HDR_SIZE;</span><br><span class="line"><span class="keyword">while</span>(aux) &#123;</span><br><span class="line">    <span class="keyword">int</span> xzero = HLL_SPARSE_XZERO_MAX_LEN;</span><br><span class="line">    <span class="keyword">if</span> (xzero &gt; aux) xzero = aux;</span><br><span class="line">    HLL_SPARSE_XZERO_SET(p,xzero);</span><br><span class="line">    p += <span class="number">2</span>;</span><br><span class="line">    aux -= xzero;</span><br><span class="line">&#125;</span><br><span class="line">serverAssert((p-(<span class="keyword">uint8_t</span>*)s) == sparselen);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，实际上HLL是一个String对象。Redis中的String是可以存储二进制序列的，而不局限于是字符串。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Create the actual object. */</span></span><br><span class="line">    o = createObject(OBJ_STRING,s);</span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;magic,<span class="string">"HYLL"</span>,<span class="number">4</span>);</span><br><span class="line">    hdr-&gt;encoding = HLL_SPARSE;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pfadd实现"><a href="#pfadd实现" class="headerlink" title="pfadd实现"></a>pfadd实现</h2><p>如果没有，就新创建一个HLL对象<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PFADD var ele ele ele ... ele =&gt; :0 or :1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Create the key with a string value of the exact length to</span></span><br><span class="line"><span class="comment">         * hold our HLL data structure. sdsnewlen() when NULL is passed</span></span><br><span class="line"><span class="comment">         * is guaranteed to return bytes initialized to zero. */</span></span><br><span class="line">        o = createHLLObject();</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        updated++;</span><br></pre></td></tr></table></figure></p>
<p>否则，调用<code>dbUnshareStringValue</code>确保对象<code>o</code>能够被原地进行修改。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据<code>dbUnshareStringValue</code>的注释，一个对象是可以被修改的，除非：</p>
<ol>
<li>它是被shared的，即refcount &gt; 1</li>
<li>它的encoding不是RAW</li>
</ol>
<p>如果有对象是满足上面两个条件的，那么会存入这个string对象的一个unshared/not-encoded的副本，否则直接返回这个对象<code>o</code>。我们可以查看下面的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        robj *decoded = getDecodedObject(o);</span><br><span class="line">        o = createRawStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">        decrRefCount(decoded);</span><br><span class="line">        dbOverwrite(db,key,o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就是对于所有要添加的项目调用<code>hllAdd</code>，这和前面的<code>zaddGenericCommand</code>等命令很相似。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Perform the low level ADD operation for every element. */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">    <span class="keyword">int</span> retval = hllAdd(o, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)c-&gt;argv[j]-&gt;ptr,</span><br><span class="line">                           sdslen(c-&gt;argv[j]-&gt;ptr));</span><br><span class="line">    <span class="keyword">switch</span>(retval) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        updated++;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hdr = o-&gt;ptr;</span><br></pre></td></tr></table></figure></p>
<p>下面的话同样会调用<code>signalModifiedKey</code>和<code>notifyKeyspaceEvent</code>进行通知，参考之前的讲解。有趣的是这个<code>HLL_INVALIDATE_CACHE</code>，它涉及了cache的机制，我们将在稍后讲解。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"pfadd"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    addReply(c, updated ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的是主要的<code>hddAdd</code>实现，主要分为Dense和Sparse两种<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span> = <span class="title">o</span>-&gt;<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">switch</span>(hdr-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> HLL_DENSE: <span class="keyword">return</span> hllDenseAdd(hdr-&gt;registers,ele,elesize);</span><br><span class="line">    <span class="keyword">case</span> HLL_SPARSE: <span class="keyword">return</span> hllSparseAdd(o,ele,elesize);</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid representation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pfadd的Dense实现"><a href="#pfadd的Dense实现" class="headerlink" title="pfadd的Dense实现"></a>pfadd的Dense实现</h2><p><code>hllDenseAdd</code>函数主要在HLL结构中“插入”一个元素，事实上并没有什么元素被加上，只是说在需要的时候自增一下这个哈希值所属的max 0 pattern counter。</p>
<h3 id="hllPatLen"><a href="#hllPatLen" class="headerlink" title="hllPatLen"></a>hllPatLen</h3><p>首先，通过<code>hllPatLen</code>计算<code>ele</code>的哈希，并从哈希值获得桶的序号<code>index</code>，并且把这个哈希值里面第一个1出现的位置<code>count</code>返回（具体含义见下面说明，这里难以理解的是到底从左边数还是从右边数。。。）。需要注意的是，我们并不需要实际的哈希值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseAdd</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllDenseSet(registers,index,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了更方便进行调试，我们将<code>createHLLObject</code>中新对象的创建默认改为<code>HLL_DENSE</code>，并加上一系列调试语句，来观察行为。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">format_binary</span><span class="params">(<span class="keyword">uint64_t</span> x, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">char</span> b = x % <span class="number">2</span>;</span><br><span class="line">        buf[i] = b + <span class="string">'0'</span>;</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = buf[j];</span><br><span class="line">        buf[j] = buf[i - <span class="number">1</span> - j];</span><br><span class="line">        buf[i - <span class="number">1</span> - j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是单纯这样改会有问题，当第二次调用<code>pfadd</code>时会报错<code>WRONGTYPE Key is not a valid HyperLogLog string value</code>，原因是下面的语句检查不通过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isHLLObjectOrReply</span><span class="params">(client *c, robj *o)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE &amp;&amp;</span><br><span class="line">        stringObjectLen(o) != HLL_DENSE_SIZE) <span class="keyword">goto</span> invalid;</span><br></pre></td></tr></table></figure></p>
<p>所以比较好的做法是在<code>createHLLObject</code>最后直接调用<code>hllSparseToDense(o);</code>。<br>下面，我们就来查看<code>hllPatLen</code>的实现。首先，它基于<code>MurmurHash64A</code>算得哈希值<code>hash</code>，并且得到所在的桶(register)的编号<code>index</code>。容易知道，这个<code>index</code>的取值是在<code>[0, 2**HLL_P=16384)</code>之间的，这也对应了桶的数量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given a string element to add to the HyperLogLog, returns the length</span></span><br><span class="line"><span class="comment"> * of the pattern 000..1 of the element hash. As a side effect 'regp' is</span></span><br><span class="line"><span class="comment"> * set to the register index this element hashes to. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllPatLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize, <span class="keyword">long</span> *regp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash, bit, index;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    hash = MurmurHash64A(ele,elesize,<span class="number">0xadc83b19</span>ULL);</span><br><span class="line">    index = hash &amp; HLL_P_MASK; <span class="comment">/* Register index. */</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    format_binary(hash, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Raw hash %s\n"</span>, s);</span><br></pre></td></tr></table></figure></p>
<p>接着，将表示桶的<code>P</code>位移出，开始对剩下的<code>64-HLL_P=50</code>位进行原始的HLL算法。这里有一个优化点，就是将最高位设为1，防止死循环，这样的话返回值<code>count</code>最大为<code>Q+1</code>，也就是51。这样做的目的也是顺应了前面提到的全是0的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hash &gt;&gt;= HLL_P; <span class="comment">/* Remove bits used to address the register. */</span></span><br><span class="line">format_binary(hash, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"P-shift hash %llx %s\n"</span>, hash, s);</span><br><span class="line">hash |= ((<span class="keyword">uint64_t</span>)<span class="number">1</span>&lt;&lt;HLL_Q); </span><br><span class="line">format_binary(hash, s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Q-set hash %llx %s\n"</span>, hash, s);</span><br></pre></td></tr></table></figure></p>
<p>从第<code>HLL_REGISTERS位</code>开始计算0的数量，也就是从低位往高位找，最多运行<code>64-P+1=Q+1</code>位。所以可以看出这里和HLL的原算法还是有点不同的，原算法是找leftmost 1，而现在的实现是找right most 1。<strong>TODO 这里需要进一步确认下</strong>。<br>根据注释，需要注意的是结尾的1也要被算在计数里面，例如”001”的count是3；count的最小值是1，此时没有前导0。这个循环看上去很没有效率，但在平均情况下在很少的迭代之后就能找到一个1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">/* Initialized to 1 since we count the "00000...1" pattern. */</span></span><br><span class="line">    <span class="keyword">while</span>((hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">        format_binary(bit, s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"while bit %s count %d\n"</span>, s, count);</span><br><span class="line">        count++;</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    format_binary(bit, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"while end bit %s count %d\n"</span>, s, count);</span><br><span class="line">    *regp = (<span class="keyword">int</span>) index;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面打印了<code>pfadd p1 a</code>的执行结果<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Raw hash                     <span class="number">101001111010010010001110000101010011011010000111011000110100111</span></span><br><span class="line">P-shift hash <span class="number">14</span>f491c2a6d0e   <span class="number">1010011110100100100011100001010100110110100001110</span></span><br><span class="line">Q-set hash <span class="number">54</span>f491c2a6d0e   <span class="number">101010011110100100100011100001010100110110100001110</span></span><br><span class="line">while bit <span class="number">1</span> count <span class="number">1</span></span><br><span class="line">while end bit <span class="number">10</span> count <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>我们接着运行<code>pfadd p1 b c d e f h i0 i1 i2</code>，会看到这样一条记录<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Raw hash 110100001100001000111001011000101111000000001000000001111010000</span><br><span class="line">P-shift hash 1a18472c5e010 1101000011000010001110010110001011110000000010000</span><br><span class="line">Q-<span class="keyword">set</span> <span class="keyword">hash</span> <span class="number">5</span>a18472c5e010 <span class="number">101101000011000010001110010110001011110000000010000</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bit</span> <span class="number">1</span> <span class="keyword">count</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bit</span> <span class="number">10</span> <span class="keyword">count</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bit</span> <span class="number">100</span> <span class="keyword">count</span> <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">bit</span> <span class="number">1000</span> <span class="keyword">count</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">end</span> <span class="built_in">bit</span> <span class="number">10000</span> <span class="keyword">count</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="hllDenseSet"><a href="#hllDenseSet" class="headerlink" title="hllDenseSet"></a>hllDenseSet</h3><p>下面，我们再来看<code>hllDenseSet</code>的实现，它应该就是根据<code>hllPatLen</code>计算的结果更新对应桶的值了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  一个底层的函数，用来设置Dense HLL register。</span></span><br><span class="line"><span class="comment"> * 将index处的值设为count，如果count比当前值大。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * registers应该能够容纳HLL_REGISTERS+1的长度，这个是由sds的实现来保证的，</span></span><br><span class="line"><span class="comment"> * 因为sds字符串始终会在最后自动加上一个'\0'</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数始终会成功，返回1表示发生了修改，否则返回0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseSet</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount;</span><br><span class="line"></span><br><span class="line">    HLL_DENSE_GET_REGISTER(oldcount,registers,index);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; oldcount) &#123;</span><br><span class="line">        HLL_DENSE_SET_REGISTER(registers,index,count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很简单，就是先把老的<code>oldcount</code>读出来，如果<code>count</code>比较大，那么就更新，比较麻烦的就是这两个宏。首先是<code>HLL_BITS</code>，它的取值是6，为什么这么奇怪呢？这是出于压缩空间的考虑。首先，我们知道每个桶里面存储的是这个桶最大的count，那么这个值最大是多少呢？首先，我们得到的是64位的哈希，然后其中有14位被用来分桶了，那剩下最多还能表示<code>64-P+1=51</code>位的count（参考上文实验），而这个是最少需要6个bit来表示的，所以这里用了6比特而不是8比特。不过这样会不会因为内存不对齐从而产生开销呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the value of the register at position 'regnum' into variable 'target'.</span></span><br><span class="line"><span class="comment"> * 'p' is an array of unsigned bytes. */</span></span><br><span class="line"><span class="comment">// do...while(0)是Linux中常见的保护宏的机制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="comment">// 获得当前桶所在的起始byte</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="comment">// 获得当前桶所在的起始byte的偏移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="comment">// 还有_fb8个bit在下一个byte上</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b0 = _p[_byte]; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b1 = _p[_byte+<span class="number">1</span>]; \</span><br><span class="line">    <span class="comment">// 拼起来</span></span><br><span class="line">    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h2 id="pfadd的Sparse实现"><a href="#pfadd的Sparse实现" class="headerlink" title="pfadd的Sparse实现"></a>pfadd的Sparse实现</h2><p>首先介绍一下几个宏<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xzero类型前缀 01xxxxxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_BIT 0x40</span></span><br><span class="line"><span class="comment">// val类型前缀 1vvvvvxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_BIT 0x80</span></span><br></pre></td></tr></table></figure></p>
<p>下面的三个宏用来判断类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xc0=0x11000000 判断是否是zero类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_ZERO(p) (((*(p)) &amp; 0xc0) == 0) </span></span><br><span class="line"><span class="comment">// 判断是否是xzero类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_XZERO(p) (((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)</span></span><br><span class="line"><span class="comment">// 判断是否是val类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_VAL(p) ((*(p)) &amp; HLL_SPARSE_VAL_BIT)</span></span><br></pre></td></tr></table></figure></p>
<p>下面的几个宏计算出是连续多少个数字，对于VAL，还需要获得VAL的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 00xxxxxx &amp; 0x00111111 获得后6位的值，即zero的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_LEN(p) (((*(p)) &amp; 0x3f)+1)</span></span><br><span class="line"><span class="comment">// 01xxxxxx yyyyyyy 计算xzero长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_LEN(p) (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span><br><span class="line"><span class="comment">// 001vvvvv &amp; 值0x00011111 获得中间5位的值，即val的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_VALUE(p) ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span><br><span class="line"><span class="comment">// 获得后两位的值, 即长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_LEN(p) (((*(p)) &amp; 0x3)+1)</span></span><br></pre></td></tr></table></figure></p>
<p>下面的几个宏给出数值范围<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spase值5bit最大32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_VALUE 32</span></span><br><span class="line"><span class="comment">// 长度2bit 最大4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_LEN 4</span></span><br><span class="line"><span class="comment">// zero类型6位表示长度, 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_MAX_LEN 64</span></span><br><span class="line"><span class="comment">// xzero类型14bit, 最大16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384</span></span><br></pre></td></tr></table></figure></p>
<p><code>hllSparseAdd</code>的实现还是需要先通过<code>hllPatLen</code>来获得<code>count</code>和<code>index</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllSparseSet(o,index,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面来看<code>hllSparseSet</code>，这是一个贼复杂的函数，先翻译一下头部的说明。该函数接受输入参数对象<code>o</code>是用来存储HLL的String对象，这个函数需要这个对象的一个引用（指针），从而在需要的时候扩容。当集合的cardinality发生变化后，函数返回1；否则返回0，表示没有实际更新。返回-1表示错误。另外一个副作用是使得HLL从Sparse表示变为Dense表示，这个通常发生在某个值不能通过Sparse格式表示了（参考之前对VAL表示方法的论述），或者结果集的大小超过了<code>server.hll_sparse_max_bytes</code>（<code>createHLLObject</code>似乎不会检查当<code>server.hll_sparse_max_bytes</code>为0的时候就直接Dense，此外，还有个<code>HLL_SPARSE_VAL_MAX_VALUE</code>阈值）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseSet</span><span class="params">(robj *o, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount, *sparse, *end, *p, *prev, *next;</span><br><span class="line">    <span class="keyword">long</span> first, span;</span><br><span class="line">    <span class="keyword">long</span> is_zero = <span class="number">0</span>, is_xzero = <span class="number">0</span>, is_val = <span class="number">0</span>, runlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果count大于32，直接走promote流程到Dense</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; HLL_SPARSE_VAL_MAX_VALUE) <span class="keyword">goto</span> promote;</span><br></pre></td></tr></table></figure></p>
<p>下面，我们需要为处理最差情况（XZERO变为XZERO-VAL-XZERO）额外分配三个字节（后面讲到）。这个必须要现在做，因为<code>sdsMakeRoomFor</code>可能<code>realloc</code>，也可能<code>malloc</code>，但这两种都不保证返回的ptr和原来是相同的。而我们希望以后的<code>o-&gt;ptr</code>能够是不变的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面是第一步，先定位到sparse的头<code>sparse</code>，也就是<code>registers</code>数组，和尾<code>end</code>。这么做的目的是定位到需要修改的<code>opcode</code>，从而检查是否真的要修改。<br>下面这个大循环，主要就是从头遍历，先通过<code>HLL_SPARSE_IS_</code>宏判断是具体哪种op类型，然后前进对应的<code>oplen</code>和<code>span</code>。其中<code>oplen</code>表示在物理表示上使用了多少字节，而<code>span</code>表示跨过了多少个（相同的）数字。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">sparse = p = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr) + HLL_HDR_SIZE;</span><br><span class="line">end = p + sdslen(o-&gt;ptr) - HLL_HDR_SIZE;</span><br><span class="line"></span><br><span class="line">first = <span class="number">0</span>;</span><br><span class="line">prev = <span class="literal">NULL</span>; <span class="comment">/* Points to previous opcode at the end of the loop. */</span></span><br><span class="line">next = <span class="literal">NULL</span>; <span class="comment">/* Points to the next opcode at the end of the loop. */</span></span><br><span class="line">span = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">    <span class="keyword">long</span> oplen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set span to the number of registers covered by this opcode. */</span></span><br><span class="line">    <span class="comment">// 这个循环是最performance critical的。所以需要从最可能被处理的情况开始(ZERO)处理。</span></span><br><span class="line">    <span class="comment">// 最少见的情况(XZERO)放到最后。</span></span><br><span class="line">    oplen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        span = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_VAL(p)) &#123;</span><br><span class="line">        span = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* XZERO. */</span></span><br><span class="line">        span = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">        oplen = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Break if this opcode covers the register as 'index'. */</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= first+span<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    prev = p;</span><br><span class="line">    p += oplen;</span><br><span class="line">    first += span;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (span == <span class="number">0</span> || p &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid format. */</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的while循环结束后，我们维护了下面几个性质：</p>
<ol>
<li><code>first</code>储存了当前的opcode所覆盖的第一个<code>register</code>，<strong>注意这里的<code>register</code>对应了Dense里面桶的概念，而不是表示一个<code>uint8_t</code></strong></li>
<li><code>next</code>和<code>prev</code>分别存储了后一个和前一个opcode，如果不存在前驱后继，对应值是NULL</li>
<li><code>span</code>表示当前opcode覆盖了多少个register</li>
<li><code>oplen</code>表示这个op实际长度是多少个byte，根据前面对ZERO、XZERO和VAL的定义，其实取值只会在1和2</li>
<li><code>p</code>指向了当前的opcode</li>
<li><code>index</code>表示要哈希到哪个桶里面</li>
</ol>
<p>现在，我们找到了包含<code>index</code>的那个op了，我们判断这个op的类型到，并且计算<code>runlen</code>。那么这个<code>runlen</code>和<code>span</code>有啥区别呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">next = HLL_SPARSE_IS_XZERO(p) ? p+<span class="number">2</span> : p+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (next &gt;= end) next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cache current opcode type to avoid using the macro again and</span></span><br><span class="line"><span class="comment"> * again for something that will not change.</span></span><br><span class="line"><span class="comment"> * Also cache the run-length of the opcode. */</span></span><br><span class="line"><span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">    is_zero = <span class="number">1</span>;</span><br><span class="line">    runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">    is_xzero = <span class="number">1</span>;</span><br><span class="line">    runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    is_val = <span class="number">1</span>;</span><br><span class="line">    runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在得到类型后，我们需要进行分类讨论。<br>首先是两种VAL的平凡情况，我们尝试进行原地修改。</p>
<ol>
<li>如果这个VAL opcode所表示的<code>count</code>大于现在这个哈希产生的<code>count</code>，那么实际上并不需要进行更新。在这种情况下PFADD会返回0，因为没有发生任何更新。</li>
<li>在要更新的情况中，还有个特例。如果这个VAL opcode仅仅就覆盖了一个register，那么就仅<strong>直接进行更新</strong>，因为这是一个平凡情况。我们稍后会去具体查看<code>updated</code>的具体实现。相对的不平凡的情况就是这个VAL opcode覆盖了多个register，也就是有相邻的多个桶都是这个<code>count</code>，可想而知，我们要把这个register分离出来单独做一个VAL opcode，我们将在稍后看分割VAL的实现。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_val) &#123;</span><br><span class="line">    oldcount = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">    <span class="comment">/* Case A. */</span></span><br><span class="line">    <span class="keyword">if</span> (oldcount &gt;= count) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Case B. */</span></span><br><span class="line">    <span class="keyword">if</span> (runlen == <span class="number">1</span>) &#123;</span><br><span class="line">        HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">goto</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>我们先来看看<code>HLL_SPARSE_VAL_SET</code>的实现，很简单，这是通过移位进行拼装。<code>len-1</code>的意味很明显，VAL的后两位为<code>00</code>的时候表示有1个<code>val</code>的值。那有0个是怎么表示的呢？很简单啊，用ZERO和XZERO啊。此外，可能还有一个抑或，就是为什么要<code>HLL_SPARSE_VAL_SET(p,count,1)</code>，因为从宏的定义上来看，<code>count</code>被传给了形参<code>val</code>，而不是语义上更接近的<code>len</code>。原因需要回顾VAL的定义，它表示在<code>p</code>处有连续<code>1</code>个桶，它的值为<code>count</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_SET(p,val,len) do &#123; \</span></span><br><span class="line">    *(p) = (((val)<span class="number">-1</span>)&lt;&lt;<span class="number">2</span>|((len)<span class="number">-1</span>))|HLL_SPARSE_VAL_BIT; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>然后是数量为1的ZERO平凡情况，同样，如果是0，并且只覆盖了一个register，我们同样<strong>直接进行更新</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.</span></span><br><span class="line"><span class="comment"> * We can just replace it with a VAL opcode with our value and len of 1. */</span></span><br><span class="line"><span class="keyword">if</span> (is_zero &amp;&amp; runlen == <span class="number">1</span>) &#123;</span><br><span class="line">    HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">goto</span> updated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是较为复杂的普通情况，在这种情况下，opcode要不是VAL或者ZERO（len大于1），要不就是XZERO。这些情况特殊在需要将原来的opcode拆分为多个opcode。其中最坏情况要把XZERO拆分成XZERO-VAL-XZERO的结构，也就是在原来的XZERO范围中有一个register被hit了。这样会占用5个字节，比原来多3个。<br>下面的代码主要就是先将新序列写到<code>n</code>里面，然后将<code>n</code>原地插入到就数组中。首先处理ZERO和XZERO这块，这个处理主要就是将它分为Z-VAL-Z的序列，其中Z可能是ZERO可能是XZERO。具体查看代码中的注释。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> seq[<span class="number">5</span>], *n = seq;</span><br><span class="line"><span class="keyword">int</span> last = first+span<span class="number">-1</span>; <span class="comment">/* Last register covered by the sequence. */</span></span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_zero || is_xzero) &#123;</span><br><span class="line">    <span class="comment">/* Handle splitting of ZERO / XZERO. */</span></span><br><span class="line">    <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">        <span class="comment">// 在index前面有len个桶</span></span><br><span class="line">        len = index-first;</span><br><span class="line">        <span class="comment">// 如果这么多个桶不能不用ZERO放下，</span></span><br><span class="line">        <span class="comment">// 就用XZERO放</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">            HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">            n += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置count</span></span><br><span class="line">    HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="comment">// 同样的办法处理尾部的count</span></span><br><span class="line">    <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">        len = last-index;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">            HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">            n += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>下面是分割VAL的情况。我们也是在<code>n</code>上面进行修改。把除自己之外的设为<code>curval</code>，自己设置为<code>count</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Handle splitting of VAL. */</span></span><br><span class="line">    <span class="keyword">int</span> curval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">        len = index-first;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">        len = last-index;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面将<code>n</code>插入到老序列里面，其实就是一个<code>memmove</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Step 3: substitute the new sequence with the old one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we already allocated space on the sds string</span></span><br><span class="line"><span class="comment"> * calling sdsMakeRoomFor(). */</span></span><br><span class="line"> <span class="keyword">int</span> seqlen = n-seq;</span><br><span class="line"> <span class="keyword">int</span> oldlen = is_xzero ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">int</span> deltalen = seqlen-oldlen;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (deltalen &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">     sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) <span class="keyword">goto</span> promote;</span><br><span class="line"> <span class="keyword">if</span> (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);</span><br><span class="line"> sdsIncrLen(o-&gt;ptr,deltalen);</span><br><span class="line"> <span class="built_in">memcpy</span>(p,seq,seqlen);</span><br><span class="line"> end += deltalen;</span><br></pre></td></tr></table></figure></p>
<p>下面，来看<code>updated</code>的实现，这一块代码，主要是从处理VAL和ZERO的两个goto过来，以及通常情况的顺序执行过来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">updated:</span><br><span class="line">    <span class="comment">/* Step 4: Merge adjacent values if possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The representation was updated, however the resulting representation</span></span><br><span class="line"><span class="comment">     * may not be optimal: adjacent VAL opcodes can sometimes be merged into</span></span><br><span class="line"><span class="comment">     * a single one. */</span></span><br><span class="line">    p = prev ? prev : sparse;</span><br><span class="line">    <span class="keyword">int</span> scanlen = <span class="number">5</span>; <span class="comment">/* Scan up to 5 upcodes starting from prev. */</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end &amp;&amp; scanlen--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We need two adjacent VAL opcodes to try a merge, having</span></span><br><span class="line"><span class="comment">         * the same value, and a len that fits the VAL opcode max len. */</span></span><br><span class="line">        <span class="keyword">if</span> (p+<span class="number">1</span> &lt; end &amp;&amp; HLL_SPARSE_IS_VAL(p+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">int</span> v2 = HLL_SPARSE_VAL_VALUE(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= HLL_SPARSE_VAL_MAX_LEN) &#123;</span><br><span class="line">                    HLL_SPARSE_VAL_SET(p+<span class="number">1</span>,v1,len);</span><br><span class="line">                    memmove(p,p+<span class="number">1</span>,end-p);</span><br><span class="line">                    sdsIncrLen(o-&gt;ptr,<span class="number">-1</span>);</span><br><span class="line">                    end--;</span><br><span class="line">                    <span class="comment">/* After a merge we reiterate without incrementing 'p'</span></span><br><span class="line"><span class="comment">                     * in order to try to merge the just merged value with</span></span><br><span class="line"><span class="comment">                     * a value on its right. */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invalidate the cached cardinality. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>下面是promote流程，是比较直截了当的，也就是先<code>hllSparseToDense</code>转换到Dense，然后调用<code>hllDenseSet</code>。注意这也反过来意味着<code>PFADD</code>命令需要保证被广播到slaves和AOF中，从而保证slaves中也进行这个转换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">promote: <span class="comment">/* Promote to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (hllSparseToDense(o) == C_ERR) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Corrupted HLL. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to call hllDenseAdd() to perform the operation after the</span></span><br><span class="line"><span class="comment">     * conversion. However the result must be 1, since if we need to</span></span><br><span class="line"><span class="comment">     * convert from sparse to dense a register requires to be updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> dense_retval = hllDenseSet(hdr-&gt;registers,index,count);</span><br><span class="line">    serverAssert(dense_retval == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dense_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="pfcount实现"><a href="#pfcount实现" class="headerlink" title="pfcount实现"></a>pfcount实现</h2><h3 id="pfcountCommand函数"><a href="#pfcountCommand函数" class="headerlink" title="pfcountCommand函数"></a>pfcountCommand函数</h3><p>首先照例是<code>pfcountCommand</code>作为入口。<br>首先是处理<code>PFCOUNT</code>给出多个key的情况，此时会返回将这些HLL做union之后的近似cardinality。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PFCOUNT var -&gt; approximated cardinality of set. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfcountCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Case 1: multi-key keys, cardinality of the union.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When multiple keys are specified, PFCOUNT actually computes</span></span><br><span class="line"><span class="comment">     * the cardinality of the merge of the N HLLs specified. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compute an HLL with M[i] = MAX(M[i]_j). */</span></span><br><span class="line">        <span class="built_in">memset</span>(max,<span class="number">0</span>,<span class="keyword">sizeof</span>(max));</span><br><span class="line">        hdr = (struct hllhdr*) max;</span><br><span class="line">        hdr-&gt;encoding = HLL_RAW; <span class="comment">/* Special internal-only encoding. */</span></span><br><span class="line">        registers = max + HLL_HDR_SIZE;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* Check type and size. */</span></span><br><span class="line">            robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">NULL</span>) <span class="keyword">continue</span>; <span class="comment">/* Assume empty HLL for non existing var.*/</span></span><br><span class="line">            <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Merge with this HLL with our 'max' HLL by setting max[i]</span></span><br><span class="line"><span class="comment">             * to MAX(max[i],hll[i]). */</span></span><br><span class="line">            <span class="keyword">if</span> (hllMerge(registers,o) == C_ERR) &#123;</span><br><span class="line">                addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compute cardinality of the resulting set. */</span></span><br><span class="line">        addReplyLongLong(c,hllCount(hdr,<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的情况是处理一个HLL的cardinality。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Case 2: cardinality of the single HLL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The user specified a single key. Either return the cached value</span></span><br><span class="line"><span class="comment"> * or compute one and update the cache. */</span></span><br><span class="line">o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* No key? Cardinality is zero since no element was added, otherwise</span></span><br><span class="line"><span class="comment">     * we would have a key as HLLADD creates it as a side effect. */</span></span><br><span class="line">    addReply(c,shared.czero);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the cached cardinality is valid. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br></pre></td></tr></table></figure></p>
<p>假如可以使用cache，那么就直接使用cache去组装<code>card</code>。可以看出低字节在数组的低index中，所以是按照小端存储的。不过我还是比较好奇为啥不直接放一个<code>uint64_t</code>，而是要自己用<code>uint8_t</code>去维护一下？难道仅仅是为了在高位留一个字节表示是否是valid的？那其实可以用位域来实现啊？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HLL_VALID_CACHE(hdr)) &#123;</span><br><span class="line">    <span class="comment">/* Just return the cached value. */</span></span><br><span class="line">    card = (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">0</span>];</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">4</span>] &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">5</span>] &lt;&lt; <span class="number">40</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">6</span>] &lt;&lt; <span class="number">48</span>;</span><br><span class="line">    card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">7</span>] &lt;&lt; <span class="number">56</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>假如cache是无效的，那么会实际调用<code>hllCount</code>。<code>hllCount</code>有个<code>invalid</code>参数，表示这个HLL的结构是有问题的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> invalid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* Recompute it and update the cached value. */</span></span><br><span class="line">card = hllCount(hdr,&amp;invalid);</span><br><span class="line"><span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">    addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">hdr-&gt;card[<span class="number">0</span>] = card &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">1</span>] = (card &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">2</span>] = (card &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">3</span>] = (card &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">4</span>] = (card &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">5</span>] = (card &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">6</span>] = (card &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">hdr-&gt;card[<span class="number">7</span>] = (card &gt;&gt; <span class="number">56</span>) &amp; <span class="number">0xff</span>;</span><br></pre></td></tr></table></figure></p>
<p>在下面，同样需要调用<code>signalModifiedKey</code>。这是因为虽然<code>PFCOUNT</code>不会修改实际的存储，但是它可能会修改cache值。考虑到HLL实际上是作为String来存储的，所以我们需要广播这个变化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">        addReplyLongLong(c,card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="cache实现"><a href="#cache实现" class="headerlink" title="cache实现"></a>cache实现</h3><p>在先前可以看到，HLL结构有个<code>card[8]</code>字段用来缓存cardinality。这个<code>card</code>会在<code>PFCOUNT</code>被访问到。此外，在<code>PFADD</code>和<code>PFMERGE</code>操作中，会调用<code>HLL_INVALIDATE_CACHE</code>使得缓存失效。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_INVALIDATE_CACHE(hdr) (hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_VALID_CACHE(hdr) (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="一个naive的count函数"><a href="#一个naive的count函数" class="headerlink" title="一个naive的count函数"></a>一个naive的count函数</h3><p>下面我们根据自己的理解实现一个count函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">naiveHllCount</span><span class="params">(<span class="keyword">int</span> * reghisto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> useHarm = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; <span class="number">64</span>; v++)&#123;</span><br><span class="line">        <span class="keyword">double</span> bucketCount = <span class="number">1.0</span> / <span class="built_in">pow</span>(<span class="number">2.0</span>, -(v<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">int</span> countOfV = reghisto[v];</span><br><span class="line">        <span class="keyword">if</span>(useHarm)&#123;</span><br><span class="line">            <span class="keyword">double</span> delta = countOfV * <span class="number">1.0</span> / bucketCount;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"v %d countofV %d bucketCount %f delta %f \n"</span>, v, countOfV, bucketCount, delta);</span><br><span class="line">            s += delta;</span><br><span class="line">            c += countOfV;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> delta = countOfV * bucketCount;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"v %d countofV %d bucketCount %f delta %f \n"</span>, v, countOfV, bucketCount, delta);</span><br><span class="line">            s += delta;</span><br><span class="line">            c += countOfV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个0.709的修正来自于<a href="https://zhuanlan.zhihu.com/p/58519480" target="_blank" rel="noopener">论文中，知乎给出了解释</a>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(useHarm)&#123;</span><br><span class="line">        res = c / s * c * <span class="number">0.709</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum %f, c %f, res %f\n"</span>, s, c, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参考<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (p) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       <span class="keyword">constant</span> = <span class="number">0.673</span> * m * m;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">       <span class="keyword">constant</span> = <span class="number">0.697</span> * m * m;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">       <span class="keyword">constant</span> = <span class="number">0.709</span> * m * m;</span><br><span class="line">   default:</span><br><span class="line">       <span class="keyword">constant</span> = (<span class="number">0.7213</span> / (<span class="number">1</span> + <span class="number">1.079</span> / m)) * m * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="hllCount函数"><a href="#hllCount函数" class="headerlink" title="hllCount函数"></a>hllCount函数</h3><p>返回估计的cardinality，基于register数组的调和平均数。<code>hdr</code>指向持有这个HLL的SDS的开始位置。如果HLL的稀疏表示形式是不合法的，则设置<code>invalid</code>为0，否则不设置这个值。<br><code>hllCount</code>支持一种特殊的内部编码<code>HLL_RAW</code>，也就是<code>hdr-&gt;registers</code>会指向一个长度<code>HLL_REGISTERS</code>的<code>uint8_t</code>数组。这个有助于加速对多个键调用<code>PFCOUNT</code>，因为我们不需要处理6-bit的整数了，所以实际上这是一个空间换时间的方案。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> hllCount(struct hllhdr *hdr, <span class="keyword">int</span> *invalid) &#123;</span><br><span class="line">    <span class="keyword">double</span> m = HLL_REGISTERS;</span><br><span class="line">    <span class="keyword">double</span> E;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br></pre></td></tr></table></figure></p>
<p>下面计算每个register的直方图。注意到直方图数组<code>reghisto</code>的长度最多是<code>HLL_Q+2</code>，因为<code>HLL_Q+1</code>是哈希函数对<code>&quot;000...1&quot;</code>这样序列所能返回的最大的frequency。当然，很难检查输入的sanity，相反地，我们。。。这后面一堆注释，我理解就是说我们分配<code>reghisto</code>大一点。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reghisto[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compute register histogram */</span></span><br><span class="line"><span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) &#123;</span><br><span class="line">    hllDenseRegHisto(hdr-&gt;registers,reghisto);</span><br></pre></td></tr></table></figure></p>
<p><code>hllDenseRegHisto</code>会根据<code>HLL_REGISTERS == 16384 &amp;&amp; HLL_BITS == 6</code>的通用情况进行优化，我们对这个优化暂时按下不表，只关注实际在做什么。可以看到，它实际上去遍历了所有的register，然后通过<code>HLL_DENSE_GET_REGISTER</code>把这个<code>HLL_BITS=6</code>位的register取出来，并增加这个register的数量。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hllDenseRegHisto</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">int</span>* reghisto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HLL_REGISTERS == <span class="number">16384</span> &amp;&amp; HLL_BITS == <span class="number">6</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; HLL_REGISTERS; j++) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> reg;</span><br><span class="line">            HLL_DENSE_GET_REGISTER(reg,registers,j);</span><br><span class="line">            reghisto[reg]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同理，<code>hllSparseRegHisto</code>对Sparse情况进行统计。这个实现其实也很简单，遍历每个opcode，对于ZERO和XZERO就增加<code>reghisto[0]</code>，对于VAL就增加<code>reghisto[val]</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;encoding == HLL_SPARSE) &#123;</span><br><span class="line">    hllSparseRegHisto(hdr-&gt;registers,</span><br><span class="line">                     sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);</span><br></pre></td></tr></table></figure></p>
<p>下面是<code>HLL_RAW</code>这个特殊的encoding。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;encoding == HLL_RAW) &#123;</span><br><span class="line">    hllRawRegHisto(hdr-&gt;registers,reghisto);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Unknown HyperLogLog encoding in hllCount()"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个操作之后，我们得到了直方图<code>reghisto[reg]</code>，表示在所有<code>HLL_REGISTERS</code>个桶中，count为reg的桶的数量，而这个count表示第一个1出现的位置。即之前的<code>while end bit 10000 count 5</code>这样的内容。<br>下面就是根据直方图来计算估计的数量。在先前的论述中，我们设计了一个很naive的<code>naiveHllCount</code>。我们提到一个基于调和平均数的多桶的实现方案，而这里用了一篇很屌的论文里面的一个很屌的做法。<br>下面来看看聪明做法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Estimate cardinality form register histogram. See:</span></span><br><span class="line"><span class="comment">     * "New cardinality estimation algorithms for HyperLogLog sketches"</span></span><br><span class="line"><span class="comment">     * Otmar Ertl, arXiv:1702.01284 */</span></span><br><span class="line">    <span class="keyword">double</span> z = m * hllTau((m-reghisto[HLL_Q+<span class="number">1</span>])/(<span class="keyword">double</span>)m);</span><br><span class="line">    <span class="keyword">for</span> (j = HLL_Q; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        z += reghisto[j];</span><br><span class="line">        z *= <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    z += m * hllSigma(reghisto[<span class="number">0</span>]/(<span class="keyword">double</span>)m);</span><br><span class="line">    <span class="comment">// #define HLL_ALPHA_INF 0.721347520444481703680 /* constant for 0.5/ln(2) */</span></span><br><span class="line">    E = llroundl(HLL_ALPHA_INF*m*m/z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint64_t</span>) E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New cardinality estimation algorithms for HyperLogLog sketches</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hllTau</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0.</span> || x == <span class="number">1.</span>) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> zPrime;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> z = <span class="number">1</span> - x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x = <span class="built_in">sqrt</span>(x);</span><br><span class="line">        zPrime = z;</span><br><span class="line">        y *= <span class="number">0.5</span>;</span><br><span class="line">        z -= <span class="built_in">pow</span>(<span class="number">1</span> - x, <span class="number">2</span>)*y;</span><br><span class="line">    &#125; <span class="keyword">while</span>(zPrime != z);</span><br><span class="line">    <span class="keyword">return</span> z / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hllSigma</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1.</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">    <span class="keyword">double</span> zPrime;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> z = x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x *= x;</span><br><span class="line">        zPrime = z;</span><br><span class="line">        z += x * y;</span><br><span class="line">        y += y;</span><br><span class="line">    &#125; <span class="keyword">while</span>(zPrime != z);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h1><p>intset是存储int的集合。在底层存储上体现为一个有序的数组，这是它和ziplist的一个不同点。intset数组中的每个元素具有相同的长度，这个长度由<code>encoding</code>指定。<code>length</code>表示Intset里面元素的个数，所以柔性数组(Flex Array)<code>contents</code>的长度实际上就是<code>encoding * length</code>的值。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure></p>
<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>出于节省空间考虑，支持三种encoding，当出现该encoding装不下的数时，会新创建一个更大的encoding，当然这样会伴随空间浪费。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure></p>
<p>给定<code>v</code>的值，得到能够承载它的最小encoding。需要注意的是，这里都是<strong>有符号</strong>整数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>因为支持不同的编码，所以intset索性用一个<code>int8_t contents[]</code>来存这些int。如果我们要把一个64位数字按照8位8位地存到<code>char</code>数组里面，那么就会涉及到选择大端或者小端两种存储方式。其实在Redis的很多数据结构的实现中，我们可以明显地看到Redis开发者，或者很多C开发者的一个特点，也就是喜欢把所有的数据结构都自己编码到<code>char*</code>上面。<code>intrev32ifbe</code>这个函数用来从小/大端序转为小端序。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#if (<span class="name">BYTE_ORDER</span> == LITTLE_ENDIAN)</span><br><span class="line">#define memrev16ifbe(<span class="name">p</span>) ((<span class="name">void</span>)(<span class="number">0</span>))</span><br><span class="line">#define memrev32ifbe(<span class="name">p</span>) ((<span class="name">void</span>)(<span class="number">0</span>))</span><br><span class="line">#define memrev64ifbe(<span class="name">p</span>) ((<span class="name">void</span>)(<span class="number">0</span>))</span><br><span class="line">#define intrev16ifbe(<span class="name">v</span>) (<span class="name">v</span>)</span><br><span class="line">#define intrev32ifbe(<span class="name">v</span>) (<span class="name">v</span>)</span><br><span class="line">#define intrev64ifbe(<span class="name">v</span>) (<span class="name">v</span>)</span><br><span class="line">#else</span><br><span class="line">#define memrev16ifbe(<span class="name">p</span>) memrev16(<span class="name">p</span>)</span><br><span class="line">#define memrev32ifbe(<span class="name">p</span>) memrev32(<span class="name">p</span>)</span><br><span class="line">#define memrev64ifbe(<span class="name">p</span>) memrev64(<span class="name">p</span>)</span><br><span class="line">#define intrev16ifbe(<span class="name">v</span>) intrev16(<span class="name">v</span>)</span><br><span class="line">#define intrev32ifbe(<span class="name">v</span>) intrev32(<span class="name">v</span>)</span><br><span class="line">#define intrev64ifbe(<span class="name">v</span>) intrev64(<span class="name">v</span>)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><code>intsetFind</code>语句首先排除掉encoding过大的，比如在一串最大32767的数组里面肯定找不到99999。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就是<code>intsetSearch</code>，因为intset是有序的嘛，所以我想这个肯定是个二分的实现吧，果不其然。这个函数返回1表示找到，并用<code>pos</code>标记找到的位置/插入位置；否则返回0<br>在二分前，需要先特判一下value过大或者过小的情况，从而能够快速失败，而不是进入下面的二分。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span>(<span class="params">intset *<span class="keyword">is</span>, int64_t <span class="keyword">value</span>, uint32_t *pos</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// min和max表示intset的最左和最右的index</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(<span class="keyword">is</span>-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    int64_t cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(<span class="keyword">is</span>-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span> &gt; _intsetGet(<span class="keyword">is</span>,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(<span class="keyword">is</span>-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span> &lt; _intsetGet(<span class="keyword">is</span>,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的二分每次都会对mid进行+1或者-1，和我们通常的二分还不太一样。通常的二分因为要在一个F/T…TTT或者TTT…F/T型的序列中找到边界的T，所以在移动mid时，如果我们发现当前的mid是T，并且我们想移动l/r的话，我们不能移动到mid-1/mid+1，这是因为mid可能就是我们要找的值。但这个二分我们要找的是exact value，所以我们可以激进一点。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">while</span>(<span class="built_in">max</span> &gt;= <span class="built_in">min</span>) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">min</span> + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)<span class="built_in">max</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="built_in">if</span> (value &gt; cur) &#123;</span><br><span class="line">            <span class="built_in">min</span> = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="built_in">else</span> <span class="built_in">if</span> (value &lt; cur) &#123;</span><br><span class="line">            <span class="built_in">max</span> = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="built_in">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="built_in">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">        <span class="built_in">if</span> (pos) *pos = <span class="built_in">min</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>对于<code>intsetAdd</code>的情况，想想肯定是有一个$O(logn)$的查找和一个$O(n)$的移动的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 如果encoding明显大了，那么需要直接升级intset</span></span><br><span class="line">        <span class="comment">/* This always succeeds, so we don't need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate "pos" with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="comment">// 如果已经存在，就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为新插入的value分配长度为1的空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把[pos, )移到[pos+1, )，即往后挪一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Resize走的<code>zrealloc</code>，这个函数之前讲到过，并不保证不会重新分配内存，这也是为什么<code>intsetResize</code>会重新返回<code>intset *</code>指针的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>intsetMoveTail</code>实际调用了<code>memmove</code>，直截了当的函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">// bytes表示移动多少字节，目前的赋值是多少元素，后面还要乘上元素的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是先把64位的value放上去，如果机器上是大端(be)存储，那么再调用下面的宏倒成小端。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 大端小端宏</span><br><span class="line"><span class="number">16</span>的简单，<span class="number">3</span>次交换</span><br><span class="line">```C</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>32位的，6次交换，实际上是轴对称交换<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>64位的，12次交换，同样也是轴对称交换，代码就不列了。</p>
<h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap底层是一个SDS</p>
<h2 id="count实现"><a href="#count实现" class="headerlink" title="count实现"></a>count实现</h2><p>这个命令可以统计得到从<code>[start, end]</code>区间内的1的数量，但是这个<code>start</code>和<code>end</code>是以byte为单位的，从0开始。我们可以参考下面的这个demo<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbit test1 <span class="number">10</span> <span class="number">1</span></span><br><span class="line">setbit test1 <span class="number">20</span> <span class="number">1</span></span><br><span class="line">setbit test1 <span class="number">30</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>下面两个命令返回值都是3<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bitcount </span>test1 </span><br><span class="line"><span class="keyword">bitcount </span>test1 <span class="number">1</span> <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>其实bitmap底层是从左到右开始编号的。乍一看有点本末倒置，为啥最高位是0，但仔细想想，这种方式方便扩展啊。<br><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte offset      :<span class="number"> 0 </span>      <span class="number"> 1 </span>      <span class="number"> 2 </span>       3</span><br><span class="line">setbit test1<span class="number"> 10 </span>1:<span class="number"> 00000000 </span>00100000</span><br><span class="line">setbit test1<span class="number"> 20 </span>1:<span class="number"> 00000000 </span>00000000 00001000</span><br><span class="line">setbit test1<span class="number"> 30 </span>1:<span class="number"> 00000000 </span>00000000<span class="number"> 00000000 </span>00000010</span><br></pre></td></tr></table></figure></p>
<p>再举一个例子<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit test2 <span class="number">15</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>计算15/8=1.875，所以是位于第1个byte的最后一位<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span><span class="number">00000001</span>(<span class="number">15</span>)</span><br></pre></td></tr></table></figure></p>
<p>因此<br><code>getbit test2 0 0</code> 返回0<br><code>getbit test2 0 1</code> 返回1，因为第一个byte被包含了<br><code>getbit test2 2 3</code> 返回0<br>‘<br>下面看<code>bitcountCommand</code><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// bitops.c</span><br><span class="line"><span class="built_in">void</span> bitcountCommand(client *c) &#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    long start, <span class="keyword">end</span>, strlen;</span><br><span class="line">    unsigned <span class="built_in">char</span> *p;</span><br><span class="line">    <span class="built_in">char</span> llbuf[<span class="type">LONG_STR_SIZE</span>];</span><br><span class="line"></span><br><span class="line">    /* <span class="type">Lookup</span>, check <span class="keyword">for</span> <span class="keyword">type</span>, <span class="keyword">and</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">for</span> non existing keys. */</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],<span class="literal">shared</span>.czero)) == <span class="type">NULL</span> ||</span><br><span class="line">        checkType(c,o,<span class="type">OBJ_STRING</span>)) <span class="keyword">return</span>;</span><br><span class="line">    p = getObjectReadOnlyString(o,&amp;strlen,llbuf);</span><br><span class="line"></span><br><span class="line">    /* <span class="type">Parse</span> start/<span class="keyword">end</span> <span class="built_in">range</span> <span class="keyword">if</span> <span class="built_in">any</span>. */</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        /* <span class="type">The</span> whole <span class="built_in">string</span>. */</span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span> = strlen-<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        /* <span class="type">Syntax</span> error. */</span><br><span class="line">        addReply(c,<span class="literal">shared</span>.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* <span class="type">Precondition</span>: <span class="keyword">end</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">end</span> &lt; strlen, so the only condition where</span><br><span class="line">     * zero can be returned <span class="keyword">is</span>: start &gt; <span class="keyword">end</span>. */</span><br><span class="line">    <span class="keyword">if</span> (start &gt; <span class="keyword">end</span>) &#123;</span><br><span class="line">        addReply(c,<span class="literal">shared</span>.czero);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        long bytes = <span class="keyword">end</span>-start+<span class="number">1</span>;</span><br><span class="line">        addReplyLongLong(c,redisPopcount(p+start,bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面一堆废话结束，最关键的是<code>redisPopcount</code>这个函数，统计从<code>s</code>开始的<code>bytes</code>长度的slice里面的1的个数。<br>一开始发现一个表<code>bitsinbyte</code>，这里面<code>bitsinbyte[i]</code>表示<code>i</code>这个数字的二进制表示里面有几个1。可以从中看出，bitcount统计bytes而不是统计bits的原因可能很大程度上就是对bytes可以查表处理，起到加速作用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count number of bits set in the binary array pointed by 's' and long</span></span><br><span class="line"><span class="comment"> * 'count' bytes. The implementation of this function is required to</span></span><br><span class="line"><span class="comment"> * work with a input string length up to 512 MB. */</span></span><br><span class="line"><span class="keyword">size_t</span> redisPopcount(<span class="keyword">void</span> *s, <span class="keyword">long</span> count) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p4;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> bitsinbyte[<span class="number">256</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面的代码中<code>(unsigned long)p &amp; 3</code>的目的是用一个while循环统计下前面没有对齐到32位的数量。其实如果我们愿意慢一点，直接这个while循环就能全部统计完了。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Count initial bytes <span class="keyword">not</span> aligned <span class="keyword">to</span> <span class="number">32</span> bit. */</span><br><span class="line"><span class="keyword">while</span>((unsigned long)p &amp; <span class="number">3</span> &amp;&amp; <span class="built_in">count</span>) &#123;</span><br><span class="line">    bits += bitsinbyte[*p++];</span><br><span class="line">    <span class="built_in">count</span><span class="comment">--;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一次性计算28个bytes，这个算法经历过疯狂的升级，3.0的时候是同时计算16个，但总体来说还是一个SWAR算法，为了便于理解，先看3.0版本的16 bytes的算法，它其实有点类似于我们在GeoHash中看到的<code>interleave64</code>的算法。快速计算64位和32位整数二进制表示中1数量的算法是种群算法，我在<a href="/2018/01/18/csapp-data-lab/">csapp data lab</a>这篇文章中有介绍。<a href="http://yesteapea.wordpress.com/2013/03/03/counting-the-number-of-set-bits-in-an-integer/" target="_blank" rel="noopener">这篇文章</a> 中的介绍也很详细。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for 64 bit numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfSetBits64</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x3333333333333333</span>) +</span><br><span class="line">        ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>);</span><br><span class="line">    i = ((i + (i &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F0F0F0F0F</span>);</span><br><span class="line">    <span class="keyword">return</span> (i*(<span class="number">0x0101010101010101</span>))&gt;&gt;<span class="number">56</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for 32 bit integers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfSetBits32</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A</span></span><br><span class="line">    i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    <span class="comment">// B</span></span><br><span class="line">    i = ((i + (i &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    <span class="keyword">return</span> (i*(<span class="number">0x01010101</span>))&gt;&gt;<span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们以32位为例，复习一下该算法的原理。首先，我们回顾一下这几个常量的表示，<code>F</code>实际上是<code>01</code>的重复，<code>T</code>是<code>0011</code>的重复，<code>O</code>是<code>00001111</code>的重复<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F = <span class="number">0x55555555</span> = <span class="number">01010101010101010101010101010101</span></span><br><span class="line">T = <span class="number">0x33333333</span> = <span class="number">00110011001100110011001100110011</span></span><br><span class="line">O = <span class="number">0x0f0f0f0f</span> = <span class="number">00001111000011110000111100001111</span></span><br></pre></td></tr></table></figure></p>
<p>这个算法的思路是首先把32位长度的数组按照奇偶组合成16组，然后在每组中统计1的个数，容易看到，这个结果只能是0b0/0b1/0b10，不会溢出。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">‭数字 <span class="number">01</span> <span class="number">11</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> <span class="number">11</span> <span class="number">11</span> <span class="number">00</span> <span class="number">11</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span>‬(<span class="number">123456789</span>)‬‬</span><br><span class="line">和   <span class="number">01</span> <span class="number">10</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span> <span class="number">10</span> <span class="number">10</span> <span class="number">00</span> <span class="number">10</span> <span class="number">01</span> <span class="number">00</span> <span class="number">01</span> <span class="number">01</span> <span class="number">01</span></span><br></pre></td></tr></table></figure></p>
<p>这个过程是可以用位运算解决的，即<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br></pre></td></tr></table></figure></p>
<p>然后我们发现，为啥函数里面不是这样写的？其实下面两种是等价算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br></pre></td></tr></table></figure></p>
<p>一般来说，<code>&amp;</code>对<code>+</code>是不满足分配率的，但在对按4移位的情况下是可以的，即不会产生溢出。所以后面我们还可以提出<code>0x0F0F0F0F</code>公因式。注意对2移位是不能提公因式的，考虑<code>1010b</code>这种情况，移位相加会出现<code>10b + 10b</code>从而导致溢出。</p>
<p>下面我们来对照看看3.0版本的16 bytes的实现，在前面执行<code>NumberOfSetBits32</code>的A步骤，依次计算4个byte的数量到aux1/2/3/4里面。在最后执行B步骤，将最后结果加到<code>bits</code>里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line"><span class="keyword">while</span>(count&gt;=<span class="number">16</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4;</span><br><span class="line"></span><br><span class="line">    aux1 = *p4++;</span><br><span class="line">    aux2 = *p4++;</span><br><span class="line">    aux3 = *p4++;</span><br><span class="line">    aux4 = *p4++;</span><br><span class="line">    count -= <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    aux2 = aux2 - ((aux2 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    aux2 = (aux2 &amp; <span class="number">0x33333333</span>) + ((aux2 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    aux3 = aux3 - ((aux3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    aux3 = (aux3 &amp; <span class="number">0x33333333</span>) + ((aux3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    aux4 = aux4 - ((aux4 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    aux4 = (aux4 &amp; <span class="number">0x33333333</span>) + ((aux4 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line"></span><br><span class="line">    bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">            ((((aux2 + (aux2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">            ((((aux3 + (aux3 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">            ((((aux4 + (aux4 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面看28 bytes算法也是类似，不过为啥要选择28这个数呢，我不是很明白<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">28</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4, aux5, aux6, aux7;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *p++等于*(p++)</span></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        ...</span><br><span class="line">        aux7 = *p4++;</span><br><span class="line">        count -= <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        ...</span><br><span class="line">        aux7 = aux7 - ((aux7 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux7 = (aux7 &amp; <span class="number">0x33333333</span>) + ((aux7 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        </span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ...</span><br><span class="line">                    ((aux7 + (aux7 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>))* <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个循环和之前的<code>(unsigned long)p &amp; 3</code>循环是对应的，用来处理余下来和28个bytes不对齐的。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Count the remaining bytes. */</span></span><br><span class="line">p = (unsigned char*)<span class="built_in">p4</span><span class="comment">;</span></span><br><span class="line">    <span class="meta">while</span>(count--) <span class="keyword">bits </span>+= <span class="keyword">bitsinbyte[*p++];</span></span><br><span class="line"><span class="keyword"> </span>   return <span class="keyword">bits;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="set-get实现"><a href="#set-get实现" class="headerlink" title="set/get实现"></a>set/get实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SETBIT key offset bitvalue */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit is not an integer or out of range"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">ssize_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">int</span> byteval, bitval;</span><br><span class="line">    <span class="keyword">long</span> on;</span><br><span class="line">	</span><br><span class="line"><span class="comment">// 把bitoffset位置设置为on</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset,<span class="number">0</span>,<span class="number">0</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;on,err) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits can only be set or cleared... */</span></span><br><span class="line"><span class="comment">// 如果on不是0或者1，那么就返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (on &amp; ~<span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupStringForBitCommand(c,bitoffset)) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get current values */</span></span><br><span class="line"><span class="comment">// bitoffset除以8，得到所在的byte</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">byteval = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte];</span><br><span class="line"><span class="comment">// 由于bitmap是从左往右数的，所以这边要用7减一下，得到这个byte中从右往左的偏移量</span></span><br><span class="line">bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line"><span class="comment">// 取出实际的bit值</span></span><br><span class="line">    bitval = byteval &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Update byte with new bit value and return original value */</span></span><br><span class="line"><span class="comment">// 更新并返回原先的值</span></span><br><span class="line">    byteval &amp;= ~(<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    byteval |= ((on &amp; <span class="number">0x1</span>) &lt;&lt; bit);</span><br><span class="line">    ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte] = byteval;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"setbit"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h2><p>bitop指令的格式如下面所示，结果存到dest里面。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bitop</span></span> opname dest src1 src2 ...</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *opname = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">    robj *o, *targetkey = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> op, j, numkeys;</span><br><span class="line">    robj **objects;      <span class="comment">/* Array of source objects. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> **src; <span class="comment">/* Array of source strings pointers. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *len, maxlen = <span class="number">0</span>; <span class="comment">/* Array of length of src strings,</span></span><br><span class="line"><span class="comment">                                       and max len. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> minlen = <span class="number">0</span>;    <span class="comment">/* Min len among the input keys. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res = <span class="literal">NULL</span>; <span class="comment">/* Resulting string. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse the operation name. */</span></span><br><span class="line">    <span class="keyword">if</span> ((opname[<span class="number">0</span>] == <span class="string">'a'</span> || opname[<span class="number">0</span>] == <span class="string">'A'</span>) &amp;&amp; !strcasecmp(opname,<span class="string">"and"</span>))</span><br><span class="line">        op = BITOP_AND;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((opname[<span class="number">0</span>] == <span class="string">'o'</span> || opname[<span class="number">0</span>] == <span class="string">'O'</span>) &amp;&amp; !strcasecmp(opname,<span class="string">"or"</span>))</span><br><span class="line">        op = BITOP_OR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((opname[<span class="number">0</span>] == <span class="string">'x'</span> || opname[<span class="number">0</span>] == <span class="string">'X'</span>) &amp;&amp; !strcasecmp(opname,<span class="string">"xor"</span>))</span><br><span class="line">        op = BITOP_XOR;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((opname[<span class="number">0</span>] == <span class="string">'n'</span> || opname[<span class="number">0</span>] == <span class="string">'N'</span>) &amp;&amp; !strcasecmp(opname,<span class="string">"not"</span>))</span><br><span class="line">        op = BITOP_NOT;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity check: NOT accepts only a single key argument. */</span></span><br><span class="line">    <span class="keyword">if</span> (op == BITOP_NOT &amp;&amp; c-&gt;argc != <span class="number">4</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"BITOP NOT must be called with a single source key."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lookup keys, and store pointers to the string objects into an array. */</span></span><br><span class="line">    numkeys = c-&gt;argc - <span class="number">3</span>;</span><br><span class="line">    src = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) * numkeys);</span><br><span class="line">    len = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">long</span>) * numkeys);</span><br><span class="line">    objects = zmalloc(<span class="keyword">sizeof</span>(robj*) * numkeys);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        o = lookupKeyRead(c-&gt;db,c-&gt;argv[j+<span class="number">3</span>]);</span><br><span class="line">        <span class="comment">/* Handle non-existing keys as empty strings. */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            objects[j] = <span class="literal">NULL</span>;</span><br><span class="line">            src[j] = <span class="literal">NULL</span>;</span><br><span class="line">            len[j] = <span class="number">0</span>;</span><br><span class="line">            minlen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Return an error if one of the keys is not a string. */</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,OBJ_STRING)) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (objects[i])</span><br><span class="line">                    decrRefCount(objects[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            zfree(src);</span><br><span class="line">            zfree(len);</span><br><span class="line">            zfree(objects);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j] = getDecodedObject(o);</span><br><span class="line">        src[j] = objects[j]-&gt;ptr;</span><br><span class="line">        len[j] = sdslen(objects[j]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (len[j] &gt; maxlen) maxlen = len[j];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || len[j] &lt; minlen) minlen = len[j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比较有趣的是这里同样针对对齐数据有个优化。我们需要在ARM架构上跳过这个优化点，这是因为ARM不支持multiple-words load/store，即使在V6架构下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Compute the bit operation, if at least one string is not empty. */</span></span><br><span class="line">    <span class="keyword">if</span> (maxlen) &#123;</span><br><span class="line">        res = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) sdsnewlen(<span class="literal">NULL</span>,maxlen);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> output, byte;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> USE_ALIGNED_ACCESS</span></span><br><span class="line">        <span class="keyword">if</span> (minlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span> &amp;&amp; numkeys &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *lp[<span class="number">16</span>];</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *lres = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*) res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note: sds pointer is always aligned to 8 byte boundary. */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(lp,src,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)*numkeys);</span><br><span class="line">            <span class="built_in">memcpy</span>(res,src[<span class="number">0</span>],minlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Different branches per different operations for speed (sorry). */</span></span><br><span class="line">            <span class="keyword">if</span> (op == BITOP_AND) &#123;</span><br><span class="line">                <span class="keyword">while</span>(minlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numkeys; i++) &#123;</span><br><span class="line">                        lres[<span class="number">0</span>] &amp;= lp[i][<span class="number">0</span>];</span><br><span class="line">                        lres[<span class="number">1</span>] &amp;= lp[i][<span class="number">1</span>];</span><br><span class="line">                        lres[<span class="number">2</span>] &amp;= lp[i][<span class="number">2</span>];</span><br><span class="line">                        lres[<span class="number">3</span>] &amp;= lp[i][<span class="number">3</span>];</span><br><span class="line">                        lp[i]+=<span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lres+=<span class="number">4</span>;</span><br><span class="line">                    j += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>;</span><br><span class="line">                    minlen -= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_OR) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_XOR) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_NOT) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* j is set to the next byte to process by the previous loop. */</span></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; maxlen; j++) &#123;</span><br><span class="line">            output = (len[<span class="number">0</span>] &lt;= j) ? <span class="number">0</span> : src[<span class="number">0</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (op == BITOP_NOT) output = ~output;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numkeys; i++) &#123;</span><br><span class="line">                byte = (len[i] &lt;= j) ? <span class="number">0</span> : src[i][j];</span><br><span class="line">                <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">                <span class="keyword">case</span> BITOP_AND: output &amp;= byte; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BITOP_OR:  output |= byte; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BITOP_XOR: output ^= byte; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[j])</span><br><span class="line">            decrRefCount(objects[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(src);</span><br><span class="line">    zfree(len);</span><br><span class="line">    zfree(objects);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the computed value into the target key */</span></span><br><span class="line">    <span class="keyword">if</span> (maxlen) &#123;</span><br><span class="line">        o = createObject(OBJ_STRING,res);</span><br><span class="line">        setKey(c,c-&gt;db,targetkey,o);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"set"</span>,targetkey,c-&gt;db-&gt;id);</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dbDelete(c-&gt;db,targetkey)) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,targetkey);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,targetkey,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,maxlen); <span class="comment">/* Return the output string length in bytes. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h1><h1 id="Geo和GeoHash"><a href="#Geo和GeoHash" class="headerlink" title="Geo和GeoHash"></a>Geo和GeoHash</h1><p>Redis在3.2版本之后提供GeoHash的实现，主要包含下面的命令：</p>
<ol>
<li><code>GEOADD key longitude latitude member [longitude latitude member ...]</code><br> 将某个经纬度以及对应的名字(member)加入到指定的key里面</li>
<li><code>GEOPOS key member [member ...]</code><br> 以member为输入，返回经纬度为输出</li>
<li><code>GEODIST key member1 member2 [unit]</code><br> 返回两个位置之间的间隔，以unit为单位，默认为米</li>
<li><code>GEORADIUS key longitude latitude radius unit</code><br> 返回给定经纬度为中心radius范围内的位置，默认返回未排序的元素</li>
<li><code>GEORADIUSBYMEMBER</code><br> 同上，但是不是给出经纬度，而是直接给一个member名字</li>
<li><code>GEOHASH ley member [member ...]</code><br> 返回member的GeoHash值</li>
</ol>
<h2 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h2><p>可以看到，Geo的底层存储是一个ZSET。这也是可以理解的，因为通过GeoHash确实可以实现有序的地理坐标。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geoaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Check arguments number for sanity. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc - <span class="number">2</span>) % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Need an odd number of arguments if we got this far... */</span></span><br><span class="line">        addReplyError(c, <span class="string">"syntax error. Try GEOADD key [x1] [y1] [name1] "</span></span><br><span class="line">                         <span class="string">"[x2] [y2] [name2] ... "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里构建将来提供给zadd命令的<code>argc</code>和<code>argv</code>。<code>elements</code>表示坐标的数量，一个坐标需要有<code>(long, lat, name)</code>三元组来表示，所以这里要除以3。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> elements = (c-&gt;argc - <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">2</span>+elements*<span class="number">2</span>; <span class="comment">/* ZADD key score ele ... */</span></span><br><span class="line">robj **argv = zcalloc(argc*<span class="keyword">sizeof</span>(robj*));</span><br><span class="line"><span class="comment">// 表示创建一个值是"zadd"的`OBJ_STRING`对象</span></span><br><span class="line">argv[<span class="number">0</span>] = createRawStringObject(<span class="string">"zadd"</span>,<span class="number">4</span>);</span><br><span class="line">argv[<span class="number">1</span>] = c-&gt;argv[<span class="number">1</span>]; <span class="comment">/* key */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Step 1: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br></pre></td></tr></table></figure></p>
<p>这里自增argv[1]的引用计数是因为直接把<code>argv[1]</code>指向<code>c-&gt;argv[1]</code>了，所以实际上也是自增<code>c-&gt;argv[1]</code>的引用计数。实际上这么做同时也保证了<code>replaceClientCommandVector</code>在释放掉<code>c-&gt;argv</code>后，<code>c-&gt;argv[1]</code>所指向的对象仍有一个引用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incrRefCount(argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></p>
<p>在这个语句之后，我们得到<code>Step 1: argv[1]-&gt;refcount 2, c-&gt;argv[1]-&gt;refcount 2</code>。<br>下面的循环依次解析每个坐标，并构建<code>score</code>和<code>member</code>字段。<br>首先通过<code>extractLongLatOrReply</code>把经纬度读到<code>xy</code>里面，如果出现经纬度超出范围的问题函数会返回<code>C_ERR</code>，从而导致直接return。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create the argument vector to call ZADD in order to add all</span></span><br><span class="line"><span class="comment"> * the score,value pairs to the requested zset, where score is actually</span></span><br><span class="line"><span class="comment"> * an encoded version of lat,long. */</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) &#123;</span><br><span class="line">    <span class="keyword">double</span> xy[<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (extractLongLatOrReply(c, (c-&gt;argv+<span class="number">2</span>)+(i*<span class="number">3</span>),xy) == C_ERR) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">            <span class="keyword">if</span> (argv[i]) decrRefCount(argv[i]);</span><br><span class="line">        zfree(argv);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面根据我们取出来的<code>xy</code>算GeoHash，关于GeoHash部分会在后面讨论。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Turn the coordinates into the score of the element. */</span></span><br><span class="line">GeoHashBits hash;</span><br><span class="line"><span class="comment">// geohashEncodeWGS84最终调用geohashEncode</span></span><br><span class="line">geohashEncodeWGS84(xy[<span class="number">0</span>], xy[<span class="number">1</span>], GEO_STEP_MAX, &amp;hash);</span><br><span class="line">GeoHashFix52Bits bits = geohashAlign52Bits(hash);</span><br></pre></td></tr></table></figure></p>
<p><code>geohashAlign52Bits</code>函数能够将得到的哈希值<code>GeoHashBits</code>，其中<code>hash.bits</code>是哈希值，<code>hash.step</code>是精度。我们需要将它做成一个52位的整数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash_helper.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> GeoHashFix52Bits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// geo.c</span></span><br><span class="line"><span class="function">GeoHashFix52Bits <span class="title">geohashAlign52Bits</span><span class="params">(<span class="keyword">const</span> GeoHashBits hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> bits = hash.bits;</span><br><span class="line">    bits &lt;&lt;= (<span class="number">52</span> - hash.step * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看函数<code>geoaddCommand</code>，我们将得到的<code>bits</code>组装成SDS，并且安装到<code>argv</code>里面，接着调用<code>replaceClientCommandVector</code>得到一个以<code>argc</code>和<code>argv</code>为参数的新的<code>redisCommand</code>，放到<code>c-&gt;cmd</code>里面。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        robj *score = createObject(OBJ_STRING, sdsfromlonglong(bits));</span><br><span class="line">        robj *val = c-&gt;argv[<span class="number">2</span> + i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        argv[<span class="number">2</span>+i*<span class="number">2</span>] = score;</span><br><span class="line">        argv[<span class="number">3</span>+i*<span class="number">2</span>] = val;</span><br><span class="line">        incrRefCount(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally call ZADD that will do the work for us. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Step 2: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br><span class="line">    replaceClientCommandVector(c,argc,argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Step 3: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br><span class="line">    zaddCommand(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这之后，输出是<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S<span class="function"><span class="title">tep</span> 2: argv[1]-&gt;</span><span class="function"><span class="title">refcount</span> 2, c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>refcount <span class="number">2</span></span><br><span class="line">S<span class="function"><span class="title">tep</span> 3: argv[1]-&gt;</span><span class="function"><span class="title">refcount</span> 1, c-&gt;</span><span class="function"><span class="title">argv</span>[1]-&gt;</span>refcount <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replaceClientCommandVector"><a href="#replaceClientCommandVector" class="headerlink" title="replaceClientCommandVector"></a>replaceClientCommandVector</h3><p><code>replaceClientCommandVector</code>函数会释放<code>c-&gt;argv</code>和<code>c-&gt;argc</code>，并且使用传入的<code>argc</code>和<code>argv</code>替换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// networking.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Completely replace the client command vector with the provided one. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceClientCommandVector</span><span class="params">(client *c, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</span><br><span class="line">    freeClientArgv(c);</span><br><span class="line">    zfree(c-&gt;argv);</span><br><span class="line">    c-&gt;argv = argv;</span><br><span class="line">    c-&gt;argc = argc;</span><br><span class="line">    c-&gt;cmd = lookupCommandOrOriginal(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;cmd != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="freeClientArgv"><a href="#freeClientArgv" class="headerlink" title="freeClientArgv"></a>freeClientArgv</h3><p>查看<code>freeClientArgv</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeClientArgv</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        decrRefCount(c-&gt;argv[j]);</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lookupCommandOrOriginal"><a href="#lookupCommandOrOriginal" class="headerlink" title="lookupCommandOrOriginal"></a>lookupCommandOrOriginal</h3><p><code>lookupCommandOrOriginal</code>用来根据指令名<code>name</code>找到对应的<code>redisCommand</code>项目。首先会在<code>server.commands</code>里面找，如果没找到会在<code>server.orig_commands</code>里面找。<code>orig_commands</code>表示没有被redis.conf里面的rename命令修改过的原始的命令名字。看起来很奇怪，不过人家注释也说了<code>lookupCommandOrOriginal</code>一般只和<code>lookupCommandOrOriginal</code>配合使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is used by functions rewriting the argument vector such as</span></span><br><span class="line"><span class="comment"> * rewriteClientCommandVector() in order to set client-&gt;cmd pointer</span></span><br><span class="line"><span class="comment"> * correctly even if the command was renamed. */</span></span><br><span class="line"><span class="function">struct redisCommand *<span class="title">lookupCommandOrOriginal</span><span class="params">(sds name)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span> = <span class="title">dictFetchValue</span>(<span class="title">server</span>.<span class="title">commands</span>, <span class="title">name</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cmd) cmd = dictFetchValue(server.orig_commands,name);</span><br><span class="line">    <span class="keyword">return</span> cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="GEOHASH"><a href="#GEOHASH" class="headerlink" title="GEOHASH"></a>GEOHASH</h2><h3 id="前置知识和geohashGetCoordRange"><a href="#前置知识和geohashGetCoordRange" class="headerlink" title="前置知识和geohashGetCoordRange"></a>前置知识和geohashGetCoordRange</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> bits; <span class="comment">// 表示哈希值</span></span><br><span class="line">    <span class="keyword">uint8_t</span> step; <span class="comment">// 表示精度</span></span><br><span class="line">&#125; GeoHashBits;</span><br></pre></td></tr></table></figure>
<p>下面四个宏规定了经纬度的取值范围。在这里需要说明的是Redis的GeoHash的内部存储和标准有差异。标准规定纬度的取值范围是[-90, 90]，而Redis的实现是[-85, 85]。因此Redis实际上是不能索引位于南北极的一小块范围的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Limits from EPSG:900913 / EPSG:3785 / OSGEO:41001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LAT_MIN -85.05112878</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LAT_MAX 85.05112878</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LONG_MIN -180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LONG_MAX 180</span></span><br></pre></td></tr></table></figure></p>
<p>我们回顾之前看到的<code>geohashEncodeWGS84</code>的函数的调用链，它会通过<code>geohashGetCoordRange</code>来获得这次经纬度的范围，并作为参数传给<code>geohashEncode</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncodeType</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step, GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    GeoHashRange r[<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    geohashGetCoordRange(&amp;r[<span class="number">0</span>], &amp;r[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> geohashEncode(&amp;r[<span class="number">0</span>], &amp;r[<span class="number">1</span>], longitude, latitude, step, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncodeWGS84</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step,</span></span></span><br><span class="line"><span class="function"><span class="params">                       GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> geohashEncodeType(longitude, latitude, step, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geohashGetCoordRange</span><span class="params">(GeoHashRange *long_range, GeoHashRange *lat_range)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */</span></span><br><span class="line">    <span class="comment">/* We can't geocode at the north/south pole. */</span></span><br><span class="line">    long_range-&gt;max = GEO_LONG_MAX;</span><br><span class="line">    long_range-&gt;min = GEO_LONG_MIN;</span><br><span class="line">    lat_range-&gt;max = GEO_LAT_MAX;</span><br><span class="line">    lat_range-&gt;min = GEO_LAT_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="geohashCommand"><a href="#geohashCommand" class="headerlink" title="geohashCommand"></a>geohashCommand</h3><p>查看<code>geohashCommand</code>的实现<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geohashCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *geoalphabet= <span class="string">"0123456789bcdefghjkmnpqrstuvwxyz"</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the requested zset */</span></span><br><span class="line">    robj *zobj = lookupKeyRead(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (checkType(c, zobj, OBJ_ZSET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Geohash elements one after the other, using a null bulk reply for</span></span><br><span class="line"><span class="comment">     * missing elements. */</span></span><br><span class="line">    addReplyArrayLen(c,c-&gt;argc<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br></pre></td></tr></table></figure></p>
<p>首先通过<code>zsetScore</code>获得指定<code>member</code>即<code>c-&gt;argv[j]-&gt;ptr</code>的<code>score</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zobj || zsetScore(zobj, c-&gt;argv[j]-&gt;ptr, &amp;score) == C_ERR) &#123;</span><br><span class="line">    addReplyNull(c);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p>
<p>在前面提到过，Redis的GeoHash的内部存储和标准有差异。因此需要用<code>decodeGeohash</code>将<code>score</code>解码到<code>xy</code>，并且再通过<code>GeoHashRange</code>编码，得到纬度取值范围为[-90, 90]的<code>hash</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The internal format we use for geocoding is a bit different</span></span><br><span class="line"><span class="comment"> * than the standard, since we use as initial latitude range</span></span><br><span class="line"><span class="comment"> * -85,85, while the normal geohashing algorithm uses -90,90.</span></span><br><span class="line"><span class="comment"> * So we have to decode our position and re-encode using the</span></span><br><span class="line"><span class="comment"> * standard ranges in order to output a valid geohash string. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Decode... */</span></span><br><span class="line"><span class="keyword">double</span> xy[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">if</span> (!decodeGeohash(score,xy)) &#123;</span><br><span class="line">    addReplyNull(c);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Re-encode */</span></span><br><span class="line">GeoHashRange r[<span class="number">2</span>];</span><br><span class="line">GeoHashBits hash;</span><br><span class="line">r[<span class="number">0</span>].min = <span class="number">-180</span>;</span><br><span class="line">r[<span class="number">0</span>].max = <span class="number">180</span>;</span><br><span class="line">r[<span class="number">1</span>].min = <span class="number">-90</span>;</span><br><span class="line">r[<span class="number">1</span>].max = <span class="number">90</span>;</span><br><span class="line">geohashEncode(&amp;r[<span class="number">0</span>],&amp;r[<span class="number">1</span>],xy[<span class="number">0</span>],xy[<span class="number">1</span>],<span class="number">26</span>,&amp;hash);</span><br></pre></td></tr></table></figure></p>
<p>下面我们得到了符合标准的<code>hash</code>，接下来我们将这个<code>hash</code>值根据<code>geoalphabet</code>编码到字符串<code>buf</code>上。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">char</span> buf[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="comment">/* We have just 52 bits, but the API used to output</span></span><br><span class="line"><span class="comment">                     * an 11 bytes geohash. For compatibility we assume</span></span><br><span class="line"><span class="comment">                     * zero. */</span></span><br><span class="line">                    idx = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    idx = (hash.bits &gt;&gt; (<span class="number">52</span>-((i+<span class="number">1</span>)*<span class="number">5</span>))) &amp; <span class="number">0x1f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf[i] = geoalphabet[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            buf[<span class="number">11</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            addReplyBulkCBuffer(c,buf,<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="geohashEncode"><a href="#geohashEncode" class="headerlink" title="geohashEncode"></a>geohashEncode</h3><p>下面我们来看最关键的<code>geohashEncode</code>的实现。<br>首先是进行校验，包含两部分。首先检验经纬度Range是否合法，然后校验经纬度是否在<code>GEO_</code>宏规定的区间内，然后校验经纬度是否在经纬度Range给出的区间内。在这里有一个问题，从上面的代码实现可以看到，其实<code>lat_range</code>是可能比<code>GEO_LAT_MAX</code>/<code>GEO_LAT_MIN</code>范围大的，那么这是否影响GeoHash的结果呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGEISZERO(r) (!(r).max &amp;&amp; !(r).min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGEPISZERO(r) (r == NULL || RANGEISZERO(*r))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncode</span><span class="params">(<span class="keyword">const</span> GeoHashRange *long_range, <span class="keyword">const</span> GeoHashRange *lat_range,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Check basic arguments sanity. */</span></span><br><span class="line">    <span class="keyword">if</span> (hash == <span class="literal">NULL</span> || step &gt; <span class="number">32</span> || step == <span class="number">0</span> ||</span><br><span class="line">        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return an error when trying to index outside the supported</span></span><br><span class="line"><span class="comment">     * constraints. */</span></span><br><span class="line">    <span class="keyword">if</span> (longitude &gt; GEO_LONG_MAX || longitude &lt; GEO_LONG_MIN ||</span><br><span class="line">        latitude &gt; GEO_LAT_MAX || latitude &lt; GEO_LAT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    hash-&gt;bits = <span class="number">0</span>;</span><br><span class="line">    hash-&gt;step = step;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (latitude &lt; lat_range-&gt;min || latitude &gt; lat_range-&gt;max ||</span><br><span class="line">        longitude &lt; long_range-&gt;min || longitude &gt; long_range-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面计算两个offset，实际上类似于做min-max归一化。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> lat_offset =</span><br><span class="line">    (latitude - lat_range-&gt;min) / (lat_range-&gt;max - lat_range-&gt;min);</span><br><span class="line"><span class="keyword">double</span> long_offset =</span><br><span class="line">    (longitude - long_range-&gt;min) / (long_range-&gt;max - long_range-&gt;min);</span><br></pre></td></tr></table></figure></p>
<p>接着对归一化的结果，乘以$2^{step}$<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* convert to fixed point based on the step size */</span></span><br><span class="line">lat_offset *= (<span class="number">1U</span>LL &lt;&lt; step);</span><br><span class="line">long_offset *= (<span class="number">1U</span>LL &lt;&lt; step);</span><br></pre></td></tr></table></figure></p>
<p>接下来就是GeoHash算法的一个核心，也就是将得到的两个offset，按照<strong>奇数为纬度，偶数为经度</strong>的方式组成一个二进制序列。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    hash-&gt;bits = interleave64(lat_offset, long_offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看这个<code>interleave64</code>的实现。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interleave lower bits of x and y, so the bits of x</span></span><br><span class="line"><span class="comment"> * are in the even positions and bits from y in the odd;</span></span><br><span class="line"><span class="comment"> * x and y must initially be less than 2**32 (65536).</span></span><br><span class="line"><span class="comment"> * From:  https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint64_t <span class="title">interleave64</span><span class="params">(<span class="keyword">uint32_t</span> xlo, <span class="keyword">uint32_t</span> ylo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> B[] = &#123;<span class="number">0x5555555555555555</span>ULL, <span class="number">0x3333333333333333</span>ULL,</span><br><span class="line">                                 <span class="number">0x0F0F0F0F0F0F0F0F</span>ULL, <span class="number">0x00FF00FF00FF00FF</span>ULL,</span><br><span class="line">                                 <span class="number">0x0000FFFF0000FFFF</span>ULL&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> S[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> x = xlo;</span><br><span class="line">    <span class="keyword">uint64_t</span> y = ylo;</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">4</span>])) &amp; B[<span class="number">4</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">4</span>])) &amp; B[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">3</span>])) &amp; B[<span class="number">3</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">3</span>])) &amp; B[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">2</span>])) &amp; B[<span class="number">2</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">2</span>])) &amp; B[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">1</span>])) &amp; B[<span class="number">1</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">1</span>])) &amp; B[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">0</span>])) &amp; B[<span class="number">0</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">0</span>])) &amp; B[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x | (y &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们不妨以一个<a href="https://ideone.com/tajz9a" target="_blank" rel="noopener">32位的<code>0xffff</code>进行调试</a>。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x <span class="comment">(ffffffff)</span><span class="number">11111111111111111111111111111111</span> </span><br><span class="line">y <span class="comment">(0)</span> </span><br><span class="line">S <span class="number">4</span>: x <span class="comment">(ffff0000ffff)</span>                   <span class="number">111111111111111100000000000000001111111111111111</span></span><br><span class="line">S <span class="number">4</span>: y <span class="comment">(0)</span> </span><br><span class="line">S <span class="number">3</span>: x <span class="comment">(ff00ff00ff00ff)</span>         <span class="number">11111111000000001111111100000000111111110000000011111111</span></span><br><span class="line">S <span class="number">3</span>: y <span class="comment">(0)</span> </span><br><span class="line">S <span class="number">2</span>: x <span class="comment">(f0f0f0f0f0f0f0f)</span>    <span class="number">111100001111000011110000111100001111000011110000111100001111</span></span><br><span class="line">S <span class="number">2</span>: y <span class="comment">(0)</span> </span><br><span class="line">S <span class="number">1</span>: x <span class="comment">(3333333333333333)</span> <span class="number">11001100110011001100110011001100110011001100110011001100110011</span></span><br><span class="line">S <span class="number">1</span>: y <span class="comment">(0)</span> </span><br><span class="line">S <span class="number">0</span>: x <span class="comment">(5555555555555555)</span><span class="number">101010101010101010101010101010101010101010101010101010101010101</span></span><br><span class="line">S <span class="number">0</span>: y <span class="comment">(0)</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h1><p>Redis还提供了一个基数树的实现。这个实现被用作Redis Cluster模式下面存储slot对应的所有key的信息。此外，在Stream、RDB、客户端缓存等模块中也用到了这个数据结构。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h1 id="Redis的应用"><a href="#Redis的应用" class="headerlink" title="Redis的应用"></a>Redis的应用</h1><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>在使用分布式锁前，可以先考虑是否能够通过一（原子）写多读来维护分布式状态。<br>基于Redis的分布式锁时通过<code>SETNX</code>命令来实现的，也就是说如果不存在就创建一个key（获得锁）。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/并行计算/" rel="tag"># 并行计算</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/17/subprocess_usage/" rel="next" title="subprocess模块用法">
                <i class="fa fa-chevron-left"></i> subprocess模块用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/01/python-join-no-signal/" rel="prev" title="Python中join不能响应信号的问题">
                Python中join不能响应信号的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">139</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">147</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis源码结构"><span class="nav-number">1.</span> <span class="nav-text">Redis源码结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-Object"><span class="nav-number">2.</span> <span class="nav-text">Redis Object</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#createObject"><span class="nav-number">2.1.</span> <span class="nav-text">createObject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用计数"><span class="nav-number">2.2.</span> <span class="nav-text">引用计数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-Command"><span class="nav-number">3.</span> <span class="nav-text">Redis Command</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redisCommand对象"><span class="nav-number">3.1.</span> <span class="nav-text">redisCommand对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-Server"><span class="nav-number">4.</span> <span class="nav-text">Redis Server</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#redisDb类"><span class="nav-number">4.1.</span> <span class="nav-text">redisDb类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DEL相关实现"><span class="nav-number">4.2.</span> <span class="nav-text">DEL相关实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步实现"><span class="nav-number">4.2.1.</span> <span class="nav-text">同步实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步实现"><span class="nav-number">4.2.2.</span> <span class="nav-text">异步实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lookUpKey相关实现"><span class="nav-number">4.3.</span> <span class="nav-text">lookUpKey相关实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#expire实现"><span class="nav-number">4.3.1.</span> <span class="nav-text">expire实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis的LRU和LFU实现"><span class="nav-number">4.3.2.</span> <span class="nav-text">Redis的LRU和LFU实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#client类"><span class="nav-number">4.4.</span> <span class="nav-text">client类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#redisServer类"><span class="nav-number">4.5.</span> <span class="nav-text">redisServer类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis事件"><span class="nav-number">4.6.</span> <span class="nav-text">Redis事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#signalModifiedKey"><span class="nav-number">4.6.1.</span> <span class="nav-text">signalModifiedKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#touchWatchedKey"><span class="nav-number">4.6.1.1.</span> <span class="nav-text">touchWatchedKey</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#trackingInvalidateKey"><span class="nav-number">4.6.1.2.</span> <span class="nav-text">trackingInvalidateKey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notifyKeyspaceEvent"><span class="nav-number">4.6.2.</span> <span class="nav-text">notifyKeyspaceEvent</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#propagateExpire"><span class="nav-number">4.7.</span> <span class="nav-text">propagateExpire</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis内存管理"><span class="nav-number">5.</span> <span class="nav-text">Redis内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis内存分配机制"><span class="nav-number">5.1.</span> <span class="nav-text">Redis内存分配机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SDS"><span class="nav-number">6.</span> <span class="nav-text">SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建"><span class="nav-number">6.1.</span> <span class="nav-text">创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list"><span class="nav-number">7.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dict"><span class="nav-number">8.</span> <span class="nav-text">dict</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dict的基本实现与Rehash机制"><span class="nav-number">8.1.</span> <span class="nav-text">dict的基本实现与Rehash机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dictEntry、dictht"><span class="nav-number">8.1.1.</span> <span class="nav-text">dictEntry、dictht</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">8.1.2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict和dictAdd"><span class="nav-number">8.1.3.</span> <span class="nav-text">dict和dictAdd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表的扩容与Rehash"><span class="nav-number">8.1.4.</span> <span class="nav-text">哈希表的扩容与Rehash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历机制"><span class="nav-number">8.2.</span> <span class="nav-text">遍历机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#迭代器"><span class="nav-number">8.3.</span> <span class="nav-text">迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dict迭代器相关方法"><span class="nav-number">8.3.1.</span> <span class="nav-text">dict迭代器相关方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dict的其他相关方法"><span class="nav-number">8.4.</span> <span class="nav-text">dict的其他相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dict遍历抽象主干代码"><span class="nav-number">8.4.1.</span> <span class="nav-text">dict遍历抽象主干代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictFind"><span class="nav-number">8.4.2.</span> <span class="nav-text">dictFind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictGet系列函数"><span class="nav-number">8.4.3.</span> <span class="nav-text">dictGet系列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictDelete"><span class="nav-number">8.4.4.</span> <span class="nav-text">dictDelete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HSET的相关数据结构"><span class="nav-number">8.5.</span> <span class="nav-text">HSET的相关数据结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZSET"><span class="nav-number">9.</span> <span class="nav-text">ZSET</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ZSET和zadd"><span class="nav-number">9.1.</span> <span class="nav-text">ZSET和zadd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zsetAdd的实现"><span class="nav-number">9.2.</span> <span class="nav-text">zsetAdd的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zsetAdd"><span class="nav-number">9.2.1.</span> <span class="nav-text">zsetAdd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zsetConvert"><span class="nav-number">9.2.2.</span> <span class="nav-text">zsetConvert</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zskiplist"><span class="nav-number">10.</span> <span class="nav-text">zskiplist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">10.1.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zslCreateNode"><span class="nav-number">10.1.1.</span> <span class="nav-text">zslCreateNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表数据结构的展现"><span class="nav-number">10.1.2.</span> <span class="nav-text">跳表数据结构的展现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslInsert的实现"><span class="nav-number">10.2.</span> <span class="nav-text">zslInsert的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表遍历抽象主干代码"><span class="nav-number">10.2.1.</span> <span class="nav-text">跳表遍历抽象主干代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslUpdateScore的实现"><span class="nav-number">10.3.</span> <span class="nav-text">zslUpdateScore的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ziplist"><span class="nav-number">11.</span> <span class="nav-text">ziplist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#格式与创建"><span class="nav-number">11.1.</span> <span class="nav-text">格式与创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">11.1.1.</span> <span class="nav-text">格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">12.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HLL原理"><span class="nav-number">12.1.</span> <span class="nav-text">HLL原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的HLL的基本结构"><span class="nav-number">12.2.</span> <span class="nav-text">Redis的HLL的基本结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createHLLObject实现"><span class="nav-number">12.3.</span> <span class="nav-text">createHLLObject实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd实现"><span class="nav-number">12.4.</span> <span class="nav-text">pfadd实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd的Dense实现"><span class="nav-number">12.5.</span> <span class="nav-text">pfadd的Dense实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hllPatLen"><span class="nav-number">12.5.1.</span> <span class="nav-text">hllPatLen</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllDenseSet"><span class="nav-number">12.5.2.</span> <span class="nav-text">hllDenseSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd的Sparse实现"><span class="nav-number">12.6.</span> <span class="nav-text">pfadd的Sparse实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfcount实现"><span class="nav-number">12.7.</span> <span class="nav-text">pfcount实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pfcountCommand函数"><span class="nav-number">12.7.1.</span> <span class="nav-text">pfcountCommand函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache实现"><span class="nav-number">12.7.2.</span> <span class="nav-text">cache实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一个naive的count函数"><span class="nav-number">12.7.3.</span> <span class="nav-text">一个naive的count函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllCount函数"><span class="nav-number">12.7.4.</span> <span class="nav-text">hllCount函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#intset"><span class="nav-number">13.</span> <span class="nav-text">intset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#encoding"><span class="nav-number">13.1.</span> <span class="nav-text">encoding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码"><span class="nav-number">13.2.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">13.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加"><span class="nav-number">13.4.</span> <span class="nav-text">添加</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bitmap"><span class="nav-number">14.</span> <span class="nav-text">bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#count实现"><span class="nav-number">14.1.</span> <span class="nav-text">count实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-get实现"><span class="nav-number">14.2.</span> <span class="nav-text">set/get实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bitop"><span class="nav-number">14.3.</span> <span class="nav-text">bitop</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#quicklist"><span class="nav-number">15.</span> <span class="nav-text">quicklist</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Geo和GeoHash"><span class="nav-number">16.</span> <span class="nav-text">Geo和GeoHash</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GEOADD"><span class="nav-number">16.1.</span> <span class="nav-text">GEOADD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replaceClientCommandVector"><span class="nav-number">16.1.1.</span> <span class="nav-text">replaceClientCommandVector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freeClientArgv"><span class="nav-number">16.1.2.</span> <span class="nav-text">freeClientArgv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lookupCommandOrOriginal"><span class="nav-number">16.1.3.</span> <span class="nav-text">lookupCommandOrOriginal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEOHASH"><span class="nav-number">16.2.</span> <span class="nav-text">GEOHASH</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前置知识和geohashGetCoordRange"><span class="nav-number">16.2.1.</span> <span class="nav-text">前置知识和geohashGetCoordRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geohashCommand"><span class="nav-number">16.2.2.</span> <span class="nav-text">geohashCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geohashEncode"><span class="nav-number">16.2.3.</span> <span class="nav-text">geohashEncode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rax"><span class="nav-number">17.</span> <span class="nav-text">Rax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">18.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis的应用"><span class="nav-number">19.</span> <span class="nav-text">Redis的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分布式锁"><span class="nav-number">19.1.</span> <span class="nav-text">分布式锁</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2018/07/23/redis_learn_object/';
          this.page.identifier = '2018/07/23/redis_learn_object/';
          this.page.title = 'Redis底层对象实现原理分析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
