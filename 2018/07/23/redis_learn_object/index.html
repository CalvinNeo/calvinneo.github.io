<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>





<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="数据库,redis," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta name="keywords" content="数据库,redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis底层对象实现原理分析">
<meta property="og:url" content="http://www.calvinneo.com/2018/07/23/redis_learn_object/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/redis_object/dict.png">
<meta property="og:image" content="http://www.calvinneo.com/img/redis_object/skiplist.png">
<meta property="og:image" content="http://www.calvinneo.com/img/redis_object/geohash_peano.png">
<meta property="og:image" content="http://www.calvinneo.com/img/redis_object/geohash_border.png">
<meta property="og:updated_time" content="2025-01-03T11:10:42.264Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis底层对象实现原理分析">
<meta name="twitter:description" content="我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和2020年8月版本（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。Redis中主要包含了字符串STRING、列表L">
<meta name="twitter:image" content="http://www.calvinneo.com/img/redis_object/dict.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2018/07/23/redis_learn_object/"/>





  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5487541356791902"
     crossorigin="anonymous"></script>
  <title>Redis底层对象实现原理分析 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2018/07/23/redis_learn_object/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Redis底层对象实现原理分析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-23T23:52:20+08:00">
                2018-07-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我将直接根据github上的unstable分支代码分析。主要是2018年7月版本（dict实现的大部分）的和<a href="https://github.com/redis/redis/commit/c01e94a4319c416c4c231ffbea9e778d52424e30" target="_blank" rel="noopener">2020年8月版本</a>（其他部分）的，所以可能会有细微差别。因为Redis的代码比较好读，并且质量很高。这里还推荐《Redis设计与实现》一书，它介绍了Redis中部分比较有趣的设计思路，可惜还有些没有覆盖到，本文中对这些有趣的设计也进行了论述。<br>Redis中主要包含了字符串STRING、列表LIST（双向链表）、集合SET、哈希表HASH、有序集合ZSET五种最常见的类型。在后续的版本中，还提供了bitmap、geohash、hyperloglog、stream这四种类型。<br>这些对象依赖于一些内部结构，包括字符串(SDS)、哈希表(dict)、链表(list)、跳表(zskiplist)、压缩双向表(ziplist)、快表等。注意出于性能原因，一个对象的实现往往根据具体的内容而选择不同的实现。列举如下：</p>
<ol>
<li>STRING<br> 使用int、sds(raw)或者embstr。<br> 下面的类型也是使用STRING的存储的：<ol>
<li>hyperloglog</li>
<li>bitmap</li>
</ol>
</li>
<li>HASH<br> 使用dict或者ziplist方案。</li>
<li>LIST<br> 3.0是使用list或者ziplist的方案。<br> 目前使用快表。</li>
<li>SET<br> 使用dict或者intset的方案。</li>
<li>ZSET<br> 视数据规模选用ziplist和skiplist+dict的方案。<br> 下面的类型也是使用ZSET的存储的：<ol>
<li>GEOHASH</li>
</ol>
</li>
</ol>
<p>本文中不介绍的是，它们在系列的其他文章中讲解：</p>
<ol>
<li>Redis基础设施</li>
<li>Redis Sentinel</li>
<li>Redis Cluster</li>
<li>Redis AOF/RDB</li>
</ol>
<p>最后，本文的主体部分已经完成，但后续仍然会进行修订，或者补充。</p>
<a id="more"></a>

<h1 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h1><p>SDS(simple dynamic string)是Redis中的动态字符串实现，没错，Redis又重复了C/C++的传统，自己造了套轮子。我们考虑一下设计一个字符串的几个方面，复制/移动效率、空间效率、编码问题。例如在<code>std::string</code>中就会进行一些短串优化(SSO)（对每个字符串对象内部维护一段较短的buffer，当buffer不够用时再向堆请求空间）、写时拷贝(COW)的方法来进行优化，这会导致不同STL下<code>c_str</code>的<a href="https://gaomf.cn/2017/07/26/Cpp_string_COW_SSO/" target="_blank" rel="noopener">不同行为</a>。但在字符串设计时，常将其实现成immutable的，以Java为例，这是为了防止在外部对容器（如Hashset）中对象的更改破坏容器的特性（Hashset的唯一性）、并发、便于进行常量池优化考虑。但是SDS却是可变的，并且被用在实现键和值中。例如<code>SET hello world</code>中，键<code>hello</code>和值<code>world</code>的底层都是SDS。此外，由于其可变性，SDS还被用作缓冲区。</p>
<p>查看<code>sds</code>的实现，发现是一个<code>char*</code>，难道直接就是一个<code>char*</code>的原生表示么？其实还真是这样，可以直接通过<code>printf(&quot;%s&quot;, s)</code>打印这个sds。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sds.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，sds的中间段可以有<code>\0</code>，Redis总不会用<code>O(n)</code>来算字符串长度吧，那么元信息报错在哪里呢？我们看到Redis提供了支持不同最大长度的<code>sdshdr</code>类型，和<code>sds</code>开头的C-style的字符串函数。所以说元信息是保存在<code>sdshdr</code>里面的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr5</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr64</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单解释一下这几个参数：</p>
<ol>
<li>len<br> <code>len</code>表示了字符串的长度，所以我们省去了<code>strlen</code>的开销，虽然我们还是可以直接对sds用。</li>
<li>buf<br> 特别地，<code>buf</code>实际上是一个二进制数组，<code>\0</code>可以出现在中间，Redis只保证<code>buf</code>最终以<code>\0</code>结尾。而这个buf实际上就是sds所指向的东西，我们将在稍后解释这一点。</li>
</ol>
<p>现在要讲解的重点是Redis是如何组织sdshdr和sds的，事实上它们的内存布局如图所示。容易看出，给定一个<code>sds</code>，可以直接当做<code>char*</code>来处理，但也可以往前推<code>sizeof(sdshdr)</code>大小，去获得sdshdr结构。而到底往前推多少字节，取决于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      sds</span><br><span class="line">       |</span><br><span class="line">       v</span><br><span class="line">sdshdr | sdshdr.buf</span><br></pre></td></tr></table></figure>

<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</span><br><span class="line">    <span class="keyword">return</span> sdsnewlen(init, initlen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，主要是会调用<code>sdsnewlen</code>这个函数。这个函数根据传入的init和initlen创建一个sds，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mystring = sdsnewlen(<span class="string">"abc"</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>如果init传入的是NULL，那么就用<code>\0</code>初始化。但不管怎么样，这个sds总是以<code>\0</code>结尾，所以可以用printf打印。但和<code>char*</code>不同的是，sds的中间段可以有<code>\0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>特别注意，这个函数会导致“复制”，而不仅仅是将指针指向init。<br>首先，看一下这个<code>type</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_5;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1</span>&lt;&lt;<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_16;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (LONG_MAX == LLONG_MAX)</span></span><br><span class="line">    <span class="keyword">if</span> (string_size &lt; <span class="number">1l</span>l&lt;&lt;<span class="number">32</span>)</span><br><span class="line">        <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> SDS_TYPE_32;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，根据要分配的字符串的长度，会给到不同的<code>SDS_TYPE_</code>，实际上也就对应到不同长度的sdshdr对象。比如对长度小于<code>1&lt;&lt;8</code>的字符串来说，我们只需要一个<code>sdshdr8</code>类型的头部去维护它的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面我们就要具体来分配一个sdshdr对象了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续sdsnewlen</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>看一下<code>sdsHdrSize</code>，不出所料，是根据<code>type</code>去<code>sizeof</code>算得需要使用的sdshdr对象的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr5);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">sizeof</span>(struct sdshdr64);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是分配了sdshdr对象和sds字符串的所有的内存。<code>sh</code>指向的是包含头部和实际数据以及结尾的<code>\0</code>的一块内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面一个有趣的是<code>s</code>，它实际上就是最后要返回的<code>sds</code>了。<br><code>SDS_HDR_VAR(T,s)</code>表示最大长度为T，指针为s(实际数据而不是header)的sds，生成其header的指针，命名为sh。<code>fp</code>指向header中的<code>flags</code>字段，直接从<code>s</code>计算了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">64</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>在新版本下，Redis中的list(t_list)的实现借助于快表，但本章主要是讲解原始双向链表<code>list</code>的实现，它被定义在adlist文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 复制</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 对比</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，保存了head、tail和len的值，因此len操作是O(1)的。</p>
<h1 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h1><p>dict是Redis中非常重要的结构，它不仅被用来实现HASH等数据结构，而且还被广泛地使用到Redis数据库服务器等基础设施中。在本章中，将介绍dict的实现，并使用HASH数据结构跟踪到dict的上层调用。我们首先看一下<code>dict</code>类的包含关系。<br><img src="/img/redis_object/dict.png"><br>其中，<code>union v</code>包含下面的几个类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> *val;</span><br><span class="line">    <span class="keyword">uint64_t</span> u64;</span><br><span class="line">    <span class="keyword">int64_t</span> s64;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">&#125; v;</span><br></pre></td></tr></table></figure>

<h2 id="dict的基本实现与Rehash机制"><a href="#dict的基本实现与Rehash机制" class="headerlink" title="dict的基本实现与Rehash机制"></a>dict的基本实现与Rehash机制</h2><p>在这个章节中，我们主要介绍dict的主要实现和Hash以及Rehash机制。</p>
<h3 id="dictEntry、dictType、dictht"><a href="#dictEntry、dictType、dictht" class="headerlink" title="dictEntry、dictType、dictht"></a>dictEntry、dictType、dictht</h3><p><code>dict</code>的实现在<strong>dict.h</strong>中，注意在<strong>deps/hiredis</strong>中也有另一个实现，注意不要搞混。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// next指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><code>dictEntry</code>是一个<strong>KV对</strong>，可以看到Redis以链表的形式存储KV，并且使用<code>union</code>来优化空间存储。我们不能从<code>dictEntry</code>获得任何的类型信息，实际上它是作为下面<code>dictht</code>对象的一个组件来使用的。<br>下面是<code>dictType</code>这个类，实际上决定了对应的行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure>

<p>在server.c中，分门别类定义了各种dictType。这些type都是在<code>dictCreate</code>作为参数传入的，会产生不同的复制、析构、hash、比较等特性。<br>我们在先前也介绍过了<code>db-&gt;expires</code>是一个keyptrDictType，他在析构的时候不会删除对应的key，但是<code>db-&gt;dict</code>是dbDictType，这就不一样了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generic hash table type where keys are Redis Objects, Values</span></span><br><span class="line"><span class="comment"> * dummy pointers. */</span></span><br><span class="line">dictType objectKeyPointerValueDictType = &#123;</span><br><span class="line">    dictEncObjHash,            <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">    dictEncObjKeyCompare,      <span class="comment">/* key compare */</span></span><br><span class="line">    dictObjectDestructor,      <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like objectKeyPointerValueDictType(), but values can be destroyed, if</span></span><br><span class="line"><span class="comment"> * not NULL, calling zfree(). */</span></span><br><span class="line">dictType objectKeyHeapPointerValueDictType = &#123;</span><br><span class="line">    dictEncObjHash,            <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">    dictEncObjKeyCompare,      <span class="comment">/* key compare */</span></span><br><span class="line">    dictObjectDestructor,      <span class="comment">/* key destructor */</span></span><br><span class="line">    dictVanillaFree            <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>dictht</code>描述了一个哈希表，它将<code>dictEntry</code>组织起来，它维护了长度和节点数等信息，但并没有描述这个哈希表的行为、类型等信息，它将被进一步封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>

<p>具体解释一下dictht的一些成员：</p>
<ol>
<li>table<br> 乍一看，就很奇怪，为啥是个二维数组呢？<br> 外面一维是哈希的<strong>桶</strong>，里面一维是开链表。<br> 这个在Rehash的时候有介绍，<strong>到时候要将这些桶拆开来，将每个dictEntry而不是每个桶进行Rehash</strong>。【Q】为什么要这样麻烦呢？这是因为到时候桶里面的元素不一定都属于新的桶里面了。</li>
<li>size<br> 这里的size表示<strong>桶的数量</strong>，是2的指数。因此size的扩张只会在<code>dictExpand</code>中发生。而真正添加元素只是加到对应桶的开链表里面。<br> 需要和<code>dictSize</code>函数区分一下，后者表示<code>dict</code>中两个ht中所有的<strong>元素</strong>数量而不是<strong>桶</strong>的数量。</li>
<li>sizemask<br> 始终是<code>size-1</code>，这个是2质数增长的一个很经典的一个实现了。</li>
<li>used<br> 表示哈希表中装载的元素数量，也就是每个桶中所有链表的长度之和。<br> 因为开链表的存在，used是可能大于size的</li>
</ol>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>看到这里有个疑问，似乎这里的<code>key</code>是一个指针，而不是我想象中的一个SDS或者<code>char*</code>值，难道我们仅仅是根据<code>key</code>的指针值来进行哈希么？事实上并非如此，根据不同的<code>dictType</code>，实际上会有不同的Hash函数。可以看到对于大多数key为SDS的情况，会落到<code>dictGenHashFunction</code>的调用上。在3.0时代，这个函数是一个对MurmurHash2函数的调用，在当前版本下，这是一个对<code>siphash</code>函数的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="comment">/* Set dictionary type. Keys are SDS strings, values are ot used. */</span></span><br><span class="line">dictType setDictType = &#123;</span><br><span class="line">    dictSdsHash,               <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                      <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,         <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,         <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                       <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> dictSdsHash(<span class="keyword">const</span> <span class="keyword">void</span> *key) &#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenHashFunction((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key, sdslen((<span class="keyword">char</span>*)key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> dictGenHashFunction(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> siphash(key,len,dict_hash_function_seed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uint64_t</span> siphash(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *in, <span class="keyword">const</span> <span class="keyword">size_t</span> inlen, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *k) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNALIGNED_LE_CPU</span></span><br><span class="line">    <span class="keyword">uint64_t</span> hash;</span><br><span class="line">    <span class="keyword">uint8_t</span> *out = (<span class="keyword">uint8_t</span>*) &amp;hash;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">uint64_t</span> v0 = <span class="number">0x736f6d6570736575</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v1 = <span class="number">0x646f72616e646f6d</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v2 = <span class="number">0x6c7967656e657261</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> v3 = <span class="number">0x7465646279746573</span>ULL;</span><br><span class="line">    <span class="keyword">uint64_t</span> k0 = U8TO64_LE(k);</span><br><span class="line">    <span class="keyword">uint64_t</span> k1 = U8TO64_LE(k + <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> m;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> *end = in + inlen - (inlen % <span class="keyword">sizeof</span>(<span class="keyword">uint64_t</span>));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> left = inlen &amp; <span class="number">7</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="dict和dictAdd"><a href="#dict和dictAdd" class="headerlink" title="dict和dictAdd"></a>dict和dictAdd</h3><p>我们接着来看上面的<code>dictht</code>结构。就和我在libutp里面看到的环状缓冲区一样，这里<code>size</code>和<code>sizemask</code>已经是老套路了，我们已经可以想象<code>size</code>一定是按照2的级数增长的，然后<code>sizemask</code>一定全是1给哈希函数算出来的值<code>&amp;</code>一下。下面我们来看一个<code>dictAdd</code>的调用过程，以验证我们的思路。<br>这些宏用来封装调用<code>dictType</code>中定义的方法，从而实现对不同类型的不同哈希。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictCompareKeys(d, key1, key2) \</span></span><br><span class="line">    (((d)-&gt;type-&gt;keyCompare) ? \</span><br><span class="line">        (d)-&gt;type-&gt;keyCompare((d)-&gt;privdata, key1, key2) : \</span><br><span class="line">        (key1) == (key2))</span><br></pre></td></tr></table></figure>

<h4 id="检查是否已经存在"><a href="#检查是否已经存在" class="headerlink" title="检查是否已经存在"></a>检查是否已经存在</h4><p><code>dictAdd</code>会最终调用<code>dictAddRaw</code>，然后会调用一个<code>_dictKeyIndex</code>，这个函数给定<code>key</code>，返回哈希表中可以插入到的slot的index。如果key已经在哈希表中存在，返回-1，并通过<code>existing</code>取回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictAddRaw &lt;- dictAdd</span></span><br><span class="line"><span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数主要就是一个for循环，这个循环在dict中是非常常见的对所有<code>dictEntry</code>遍历的循环，我们列在“dict遍历抽象主干代码”这个章节里面。循环关键如下：</p>
<ol>
<li><p>遍历所有的table，如果正在Rehash过程中，那么就会有两个table。<br> 【Q】根据源码中的注释，如果在Rehash过程中<code>_dictKeyIndex</code>返回那个idx，一定是<code>ht[1]</code>对应的索引值？<br> 这在说啥呢？参考“会不会有两个键出现在两个table里面？”这个讨论，如果在Rehash过程中，我们插入要插入到新的表<code>ht[1]</code>中，所以插入的位置idx，也应该是新的表中的位置idx。下面的for循环从0到1的顺序保证了这一点。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++)</span><br></pre></td></tr></table></figure></li>
<li><p>我们根据key的哈希值，找到对应的桶<code>d-&gt;ht[table].table[idx]</code>。</p>
</li>
<li><p>我们遍历这个桶的开链表。</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _dictKeyIndex &lt;- dictAddRaw &lt;- dictAdd</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dictKeyIndex(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">uint64_t</span> hash, dictEntry **existing)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx, table;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">if</span> (existing) *existing = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Expand the hash table if needed */</span></span><br><span class="line">    <span class="keyword">if</span> (_dictExpandIfNeeded(d) == DICT_ERR)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 这个for循环在“dict遍历抽象主干代码”也列举了出来。</span></span><br><span class="line">    <span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">        idx = hash &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">        <span class="comment">// 注意Redis使用开链法解决哈希冲突，所以要搜完`d-&gt;ht[table].table[idx]`这条链。</span></span><br><span class="line">        he = d-&gt;ht[table].table[idx];</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">// 如果key和he-&gt;key相等（指针相等或者值相等），我们尝试赋值给*existing</span></span><br><span class="line">                <span class="keyword">if</span> (existing) *existing = he;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不在Rehash过程中，我们不找ht[1]，这个机制在后面的`dictFind`等函数中也会出现</span></span><br><span class="line">        <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>函数的返回值选取idx即可，具体的<code>dictEntry *</code>，如果调用者有需要，我们才设置<code>*existing</code>用来返回。因为我们用这个函数不仅是看有没有，还要顺便获得在后面插入位置。返回并保存链表头，后面就可以直接从<strong>链表头</strong>插入，这样的好处是一方面我们只要记录一个链表头，另一方面是Redis假设最近被添加的字段会被频繁访问。<br><strong>这里可以总结出链表使用的经验，如果需要快速push，保存链表头。如果需要快速pop，保存链表尾。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在刚才的代码中出现了<code>dict</code>这个结构，它也就是我们真正提供的完备的哈希表。因此，到这里的“继承关系”是<code>dict &lt;- dictht &lt;- dictEntry</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators;</span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure>

<p>同样简单介绍一下成员：</p>
<ol>
<li>type/privdata<br> 用来实现类似继承的机制，这样我们可以自定义<code>dict</code>的行为。</li>
<li>ht<br> 是两个dictht结构，每一个dictht就是上面提到的一个哈希表。这个用来实际保存数据。<br> 可是为什么是长度为2的数组呢？这里的<code>ht[1]</code>在rehash的时候用，在rehash的时候会把<code>ht[0]</code>慢慢搬到<code>ht[1]</code>上。</li>
<li>rehashidx<br> 用来表示此时Rehash的过程（具体机制查看后文）。<br> <code>-1</code>表示未在Rehash。<br> <code>&gt;=0</code>表示Rehash开始，将要移动<code>ht[0].table[rehashidx]</code>这个桶。</li>
<li>iterators<br> 表示这个字典上的<strong>安全</strong>迭代器的个数。</li>
</ol>
<h3 id="哈希表的扩容"><a href="#哈希表的扩容" class="headerlink" title="哈希表的扩容"></a>哈希表的扩容</h3><p>当哈希表容量不够时就需要进行扩容，同时需要进行Rehash。下面我们正式来研究哈希表的扩容与Rehash部分<br>根据<code>_dictExpandIfNeeded</code>，扩容需要满足几个条件：</p>
<ol>
<li><code>used &gt;= size</code><br> 回忆一下，<code>size</code>是桶的数量，<code>used</code>是键的数量。<code>used</code>是会大于<code>size</code>的，因为开链表。</li>
<li><code>dict_can_resize</code><br> 根据<code>updateDictResizePolicy</code>函数，在一些情况下<code>dict_can_resize</code>是<code>false</code>，这时候不会扩张。<br> 根据《Redis设计与实现》，这种情况发生在BGSLAVE或者BGREWRITEAOF命令运行时针对COW机制的一个优化。这两个命令实际上是后台写RDB和AOF的实现。</li>
<li>但是当used/size大于一个比例，默认是5，会强制扩张（注意扩张还是按照2倍）。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictIsRehashing(d) ((d)-&gt;rehashidx != -1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _dictExpandIfNeeded(dict *d)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此时正在进行Rehash（有没有很奇怪为啥会有个正在进行中的状态？请看下文）</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) <span class="keyword">return</span> DICT_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表是空的</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].size == <span class="number">0</span>) <span class="keyword">return</span> dictExpand(d, DICT_HT_INITIAL_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hash表扩张条件：</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used &gt;= d-&gt;ht[<span class="number">0</span>].size &amp;&amp;</span><br><span class="line">        (dict_can_resize || d-&gt;ht[<span class="number">0</span>].used/d-&gt;ht[<span class="number">0</span>].size &gt; dict_force_resize_ratio))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> dictExpand(d, d-&gt;ht[<span class="number">0</span>].used*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的<code>dictExpand</code>就是扩容函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Expand or create the hash table */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictExpand</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// size是要扩张到的大小，在计算时是按照used成比例放大的，所以肯定比used要大。</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; size)</span><br><span class="line">        <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    dictht n; <span class="comment">/* the new hash table */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rehashing to the same table size is not useful. */</span></span><br><span class="line">    <span class="keyword">if</span> (realsize == d-&gt;ht[<span class="number">0</span>].size) <span class="keyword">return</span> DICT_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></span><br><span class="line">    n.size = realsize;</span><br><span class="line">    n.sizemask = realsize<span class="number">-1</span>;</span><br><span class="line">    n.table = zcalloc(realsize*<span class="keyword">sizeof</span>(dictEntry*));</span><br><span class="line">    n.used = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>假如<code>ht[0]</code>是空的，那这是一次初始化，直接将ht[0]指向新的hash表<code>n</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].table == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = n;</span><br><span class="line">        <span class="keyword">return</span> DICT_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>否则将<code>ht[1]</code>指向新的哈希表<code>n</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    d-&gt;ht[<span class="number">1</span>] = n;</span><br><span class="line">    d-&gt;rehashidx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> DICT_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h3><p>我们看到扩容操作只是创建了一个空的哈希表，并没有真正移动<code>ht[0]</code>的元素到<code>ht[1]</code>对应的位置上(这个过程被称作桶转移)，难道这里又是COW了？<br>答案是肯定的。通过优秀的英文能力，我们猜到了真正做Rehash的函数<code>int dictRehash(dict *d, int n)</code>，<code>dictRehash</code>在<code>dictRehashMilliseconds</code>和<code>_dictRehashStep</code>中被调用。</p>
<p><code>dictRehash</code>对<code>d</code>做**<code>n</code>**步的Rehash，其中一步表示将<code>ht[0]</code>中的一个桶<code>d-&gt;ht[0].table[d-&gt;rehashidx]</code>移到<code>ht[1]</code>上。注意下面几点：</p>
<ol>
<li><p>这里的<code>d-&gt;ht[0].table[d-&gt;rehashidx]</code>是一个开链表。</p>
</li>
<li><p>我们不能直接移动桶，因为到时候里面的元素可能Rehash到不同的桶里面。所以，我们只能遍历桶的开链表里面的所有key，然后逐个放到新的table里面。</p>
</li>
<li><p>容易看出<code>ht[0].size &gt; rehashidx</code>是始终成立的。<br> 因为<code>ht[0].size</code>就是桶的最多数量，<code>rehashidx</code>表示现在哈希到第几个桶了。</p>
</li>
<li><p>这个**<code>n</code>**的计算不包括空桶，Redis每次哈希可以跳过<code>empty_visits</code>个空桶，这时候我们要做的仅仅是自增<code>d-&gt;rehashidx</code>。</p>
</li>
<li><p><code>dictRehashMilliseconds</code><br> 定时Rehash函数<code>incrementallyRehash</code>在后台被<code>databasesCron</code>定时调用，起到定时Rehash每个db的dict和expire表的作用。<br> <code>dictRehashMilliseconds</code>是一个时间相关的函数，它会在在ms毫秒的时间里面rehash尽可能多的桶，也就是每rehash 100个桶之后检查一下有没有超时，没有就接着来。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">databasesCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (server.activerehashing) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> work_done = incrementallyRehash(rehash_db);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">incrementallyRehash</span><span class="params">(<span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Keys dictionary */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].dict)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].dict,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Expires */</span></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(server.db[dbid].expires)) &#123;</span><br><span class="line">        dictRehashMilliseconds(server.db[dbid].expires,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* already used our millisecond for this loop... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</span><br><span class="line">    <span class="keyword">int</span> rehashes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(dictRehash(d,<span class="number">100</span>)) &#123;</span><br><span class="line">        rehashes += <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span> (timeInMilliseconds()-start &gt; ms) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rehashes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>_dictRehashStep</code><br> <code>_dictRehashStep</code>在诸如<code>dictAddRaw</code>、<code>dictGenericDelete</code>、<code>dictFind</code>、<code>dictGetRandomKey</code>等函数中被调用，作为<code>dictRehashMilliseconds</code>的补充。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="comment">// 只有当</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>下面我们来看一下Rehash的过程。最外面是一个大循环，表示移动最多<code>n</code>个桶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; </span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们最多跳过<code>empty_visits == n*10</code>个空桶，此时只更新<code>rehashidx</code>，不计算<code>n</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面开始移动非空桶。注意我们不能直接将这个非空桶整个移植过去，因为里面的key在Rehash之后可能会去到其他的桶里面，所以我们用de来遍历这个开链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在大循环移动完<code>n</code>个桶，或者遇到太多的空桶退出之后，检查<code>ht[0]</code>是不是已经结束了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 当ht[0].used为0时过程终止，将d-&gt;rehashidx设为-1。</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        <span class="comment">// 将ht[1]按指针赋值给ht[0]。</span></span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则Rehash还没有结束。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现在Rehash的过程中，调用<code>dictRehash</code>都将<code>ht[0]</code>掏空一点给<code>ht[1]</code>，直到最后过程结束后将<code>ht[1]</code>指针赋值给<code>ht[0]</code>。</p>
<h4 id="ht-0-和ht-1-的顺序"><a href="#ht-0-和ht-1-的顺序" class="headerlink" title="ht[0]和ht[1]的顺序"></a>ht[0]和ht[1]的顺序</h4><p>【Q】如果在Rehash过程中，增删改查需要考虑下面几点（<strong>注意我们的语境是在Rehash下！！）</strong>：</p>
<ol>
<li>对于插入操作，会不会在<code>ht[0]</code>中已经有了，我们又新插入到<code>ht[1]</code>，导致一个值在两个地方，或者反过来？<br> 这个是不可能的。首先，我们要规定插入只能在<code>ht[1]</code>；然后在每次插入前，我们都要在<code>ht[0]</code>和<code>ht[1]</code>中都检查一遍。</li>
<li>对于删除操作，会不会只删除ht中的数据？</li>
</ol>
<p>总结一下，在Rehash的过程中我们插入必须对<code>ht[1]</code>，而查找删除优先在<code>ht[0]</code>操作，然后再<code>ht[1]</code>。Rehash在对哈希表每一次的增删改查中渐进进行，我们查看相关代码。</p>
<p>首先看插入，我们首先调用<code>_dictKeyIndex</code>，如果不存在，则：</p>
<ol>
<li>如果不在Rehash，那么返回<code>ht[0]</code>中待插入的idx</li>
<li>如果在Rehash，则返回<code>ht[1]</code>。关于这部分，在<code>_dictKeyIndex</code>讲过了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictAddRaw</span></span><br><span class="line"><span class="function">dictEntry *<span class="title">dictAddRaw</span><span class="params">(dict *d, <span class="keyword">void</span> *key, dictEntry **existing)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    dictht *ht;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the index of the new element, or -1 if</span></span><br><span class="line"><span class="comment">     * the element already exists. */</span></span><br><span class="line">    <span class="keyword">if</span> ((index = _dictKeyIndex(d, key, dictHashKey(d,key), existing)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对查找来说，也是从<code>ht[0]</code>查，再查<code>ht[1]</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictFind</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"><span class="comment">// 调用对应的hash function获得哈希值h</span></span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    <span class="comment">// 找到第table(0或者1)个ht的第idx的元素</span></span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key))</span><br><span class="line">            <span class="keyword">return</span> he;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在Rehash过程中，我们找完ht[0]就不找了，因为只可能ht[0]有内容</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除同理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictGenericDelete</span></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">...</span><br><span class="line"><span class="comment">// _dictKeyIndex</span></span><br><span class="line"><span class="comment">// 见前面</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历机制-dictScan"><a href="#遍历机制-dictScan" class="headerlink" title="遍历机制(dictScan)"></a>遍历机制(dictScan)</h2><p>Redis中的遍历分为两块，第一个是<code>dictScan</code>函数，第二个是借助<code>dictIterator</code>这个迭代器。其中，前者用来对外提供SCAN，后者主要用来服务其他数据结构。我们首先介绍dictScan。<br>由于Redis中哈希表的动态扩展和缩小中有<strong>渐进</strong>Rehash的<strong>过程</strong>，所以做到恰巧一遍的遍历是非常难的，函数<code>dictScan</code>的实现确保了每个元素都能遍历到，但可能存在元素被重复遍历。函数<code>dictScan</code>接受一个cursor即参数<code>v</code>，并移动这个cursor，返回其新值，初始情况下我们传入<code>v</code>为0。<br>dictScanFunction表示需要对每一个dictEntry设置的函数。<br>dictScanBucketFunction表示需要对每个桶设置的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictSize(d) ((d)-&gt;ht[0].used+(d)-&gt;ht[1].used)</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">dictScan</span><span class="params">(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> v, dictScanFunction *fn, dictScanBucketFunction* bucketfn, <span class="keyword">void</span> *privdata)</span></span>&#123;</span><br><span class="line">    dictht *t0, *t1;</span><br><span class="line">    <span class="keyword">const</span> dictEntry *de, *next;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> m0, m1;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有元素，直接返回0，表示遍历完毕</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) &#123;</span><br><span class="line">        <span class="comment">// 假设不在Rehash过程中，此时只有ht[0]中有元素</span></span><br><span class="line">        t0 = &amp;(d-&gt;ht[<span class="number">0</span>]);</span><br><span class="line">        m0 = t0-&gt;sizemask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这一串表示对桶和桶中所有元素调用bucketfn和fn回调函数</span></span><br><span class="line">        <span class="keyword">if</span> (bucketfn) bucketfn(privdata, &amp;t0-&gt;table[v &amp; m0]);</span><br><span class="line">        de = t0-&gt;table[v &amp; m0];</span><br><span class="line">        <span class="keyword">while</span> (de) &#123;</span><br><span class="line">            next = de-&gt;next;</span><br><span class="line">            fn(privdata, de);</span><br><span class="line">            de = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        v |= ~m0;</span><br><span class="line">        v = rev(v);</span><br><span class="line">        v++;</span><br><span class="line">        v = rev(v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里对<code>v</code>的更新十分奇妙，按照理想情况，我们完全可以去直接<code>v++</code>，然后遍历完所有的桶。但是那四行代码的行为却很奇特，这种遍历方法被称为reverse binary iteration：</p>
<ol>
<li>首先第一行将<code>v</code>的会和<code>~mask</code> or一下</li>
<li>第二行调用<code>rev</code>将<code>v</code>按比特反转，这时候高位填充的1就到了最低位上。</li>
<li>接着后面两行进行自增，再倒回去。</li>
</ol>
<p>这么做的结果是<a href="https://xiking.win/2018/11/07/reverse-binary-iteration/" target="_blank" rel="noopener">二进制的进位是反向的</a>，我们首先对最高位自增，如果高位溢出了，就对低位进位。</p>
<p>我们首先介绍一下rev这个函数，它的作用是将一个二进制串前后倒置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进行位反转</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">rev</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s = <span class="number">8</span> * <span class="keyword">sizeof</span>(v); <span class="comment">// bit size; must be power of 2</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask = ~<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((s &gt;&gt;= <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mask ^= (mask &lt;&lt; s);</span><br><span class="line">        v = ((v &gt;&gt; s) &amp; mask) | ((v &lt;&lt; s) &amp; ~mask);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x;</span><br><span class="line">    x = <span class="number">0b1011011101111</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;64&gt;(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">bitset</span>&lt;64&gt;(rev(x)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印下来是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000000000000000000000000000000000000001011011101111</span><br><span class="line">1111011101101000000000000000000000000000000000000000000000000000</span><br></pre></td></tr></table></figure>

<p>以<code>mask = (uint8_t) 15</code>(0x1111)、<code>v = (uint8_t) 2</code>为例查看一下这个过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">00000010(2)初始状态</span><br><span class="line">-&gt; 11110010 `15`是0x1111，`~15`是0x11110000。这么做的目的是将“没用到”的位全部置为1</span><br><span class="line">-&gt; 01001111 rev函数逆向原串 </span><br><span class="line">-&gt; 01010000 自增</span><br><span class="line">-&gt; 00001010(10) rev函数再逆向回来</span><br></pre></td></tr></table></figure>

<p>我们从<code>v=0</code>开始迭代，发现值依次是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 0</span><br><span class="line">0b0000 0b1000 0b0100 0b1100 0b0010 0b1010 0b0110 0b1110 0b0001 0b1001 0b0101 0b1101 0b0011 0b1011 0b0111 0b1111</span><br></pre></td></tr></table></figure>

<p>【Q】为什么要做这样的设计呢？因为Rehash是以2为倍数扩展或者收缩的，这样遍历之下，能够保证Rehash之后，既不会漏掉，也不会重复遍历。</p>
<p>我们考虑将数字<code>[0,7]</code>哈希到2和4的不同情况，可以发现哈希到4时每个slot里数字的后<strong>2</strong>位都相同，而哈希到2时每个slot里数字的后<strong>1</strong>位相同。我们可以认为从$2^i$到$2^{i+1}$，我们将每个slot中的数按照第<code>i</code>位的值分成两个slot。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0(00):0(000),4(100)</span><br><span class="line">1(01):1(001),5(101)</span><br><span class="line">2(10):2(010),6(110)</span><br><span class="line">3(11):3(011),7(111)</span><br><span class="line">===</span><br><span class="line">0:0(000),2(010),4(100),6(110)</span><br><span class="line">1:1(001),3(011),5(101),7(111)</span><br></pre></td></tr></table></figure>

<p>在上面讨论了更通用的情形，特别用了slot而不是之前提到的桶的概念。在这篇文章中，一个桶指的是<code>ht</code>中哈希值相同的所有元素组成的链表，也就是dictht的<code>dictEntry** table</code>的第一维。现在讨论的<code>dictScan</code>是<strong>针对桶的扫描而不是元素的扫描</strong>。特别地，我们将哈希表中的<code>N</code>个桶合并成<code>N/2</code>个桶时，相当于做一次针对桶的哈希。考虑一个8个桶的哈希表，其桶的遍历顺序是<code>0 4 2 6 1 5 3 7 0</code>。假设遍历<code>6(110)</code>前我们将8个桶缩小到4个桶，那么桶6中的元素应当被映射到新桶<code>2(10)</code>中了，因此我们应当遍历<code>2(10)</code>这个桶，此时我们<strong>已经遍历过</strong>的桶如下示意</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">新桶      原桶</span><br><span class="line">0(00):0(000),4(100)</span><br><span class="line">1(01):</span><br><span class="line">2(10):2(010)</span><br><span class="line">3(11):</span><br></pre></td></tr></table></figure>

<p>容易发现此时我们重复遍历了原来桶<code>2(010)</code>中的元素。这个过程结束时新的<code>mask</code>为3，<code>v</code>会更新到<code>1(01)</code>，我们发现下面要遍历的<code>1 5</code>两个就桶被合并到了<code>1(01)</code>这个新桶里面。如果考虑遍历<code>2(010)</code>前发生了缩小，那么我们就不要重复遍历元素。</p>
<h2 id="遍历机制-迭代器"><a href="#遍历机制-迭代器" class="headerlink" title="遍历机制(迭代器)"></a>遍历机制(迭代器)</h2><p>迭代器的声明如下，容易看出通过<code>d</code>、<code>index</code>和<code>table</code>我们可以确定一个桶。<code>safe</code>表示这个迭代器是否是一个安全的迭代器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></span><br><span class="line">    <span class="comment">// 被迭代的字典</span></span><br><span class="line">    dict *d;</span><br><span class="line">    <span class="comment">// 迭代器当前所指向的dictEntry位置</span></span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="comment">// 正在被迭代的dictht号码，值可以是 0 或 1</span></span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line">    <span class="comment">// 标识这个迭代器是否安全</span></span><br><span class="line">    <span class="keyword">int</span> safe;</span><br><span class="line">    <span class="comment">// 当前迭代到的节点的指针</span></span><br><span class="line">    dictEntry *entry;</span><br><span class="line">    <span class="comment">// 见下文说明</span></span><br><span class="line">    dictEntry *nextEntry;</span><br><span class="line">    <span class="comment">/* unsafe iterator fingerprint for misuse detection. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint;</span><br><span class="line">&#125; dictIterator;</span><br></pre></td></tr></table></figure>

<p>我们将在下面逐一介绍相关的字段用法</p>
<ol>
<li><p>安全迭代器<br> 安全的迭代器是什么意思呢？比如在Rehash机制中，存在safe迭代器的情况下是暂停Rehash的。只有当<code>iterators</code>数量为0时，才会进行Rehash。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dictRehashStep(dict *d) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d-&gt;iterators == <span class="number">0</span>) dictRehash(d,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 需要注意的是，在<a href="https://github.com/redis/redis/blob/6.0.0/src/dict.c" target="_blank" rel="noopener">Redis的6.0版本</a>上，dictScan也会增加iterators，从而导致rehash停止。而在<a href="https://github.com/redis/redis/blob/5.0.0/src/dict.c" target="_blank" rel="noopener">5.0版本</a>还没有这个限制。【Q】为什么会有这个限制呢？</p>
</li>
<li><p>fingerprint<br> 用来将两个<code>ht</code>的指针、<code>size</code>和<code>used</code>进行哈希，在<code>dictNext</code>开始和结束之后比较哈希值，如果不一样的话，就<code>assert</code>。这主要是用来保证，当不安全迭代器被使用时，该迭代器的使用者不能对这个哈希表做出不合法的操作。</p>
</li>
</ol>
<h3 id="dict迭代器相关方法"><a href="#dict迭代器相关方法" class="headerlink" title="dict迭代器相关方法"></a>dict迭代器相关方法</h3><p>搜索dict这个迭代器主要作用是在<strong>redis内部</strong>，例如持久化相关的工作。dict迭代器的相关方法主要包括<code>dictNext</code>、<code>dictGetIterator</code>、<code>dictGetSafeIterator</code>、<code>dictReleaseIterator</code>。</p>
<h4 id="dictNext"><a href="#dictNext" class="headerlink" title="dictNext"></a>dictNext</h4><p>dictNext的实现比较特别，它会缓存当前的<code>iter-&gt;entry</code>，以及下一个<code>iter-&gt;nextEntry</code>。主要流程如下：</p>
<ol>
<li>初始化<br> 指向0这个table。指向0这个dictEntry。<br> <code>iter-&gt;index</code>表示遍历的distEntry的位置，<code>iter-&gt;entry</code>表示被遍历的那个distEntry。</li>
<li>如果<code>iter-&gt;entry</code>是NULL<br> 通常是因为初始化，或者遍历完了一张表<br> 如果遍历完了所有的dictEntry，就换到table 1。当然没有Rehash的话就结束。</li>
<li>如果<code>iter-&gt;entry</code>不是NULL<br> 这是大部分情况。<br> 我们移动到<code>iter-&gt;nextEntry</code>，然后去更新<code>iter-&gt;nextEntry</code>。<br> <strong>这里要用nextEntry的原因是安全迭代器是能够对哈希表进行增删的，因此如果<code>iter-&gt;entry</code>在迭代时被删除了，那么就会导致<code>iter-&gt;entry-&gt;next</code>是无法访问的，因此这里要提前保存一下</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictNext</span><span class="params">(dictIterator *iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有指定dictEntry</span></span><br><span class="line">            <span class="comment">// iter-&gt;table初始值是0</span></span><br><span class="line">            dictht *ht = &amp;iter-&gt;d-&gt;ht[iter-&gt;table];</span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index == <span class="number">-1</span> &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这边是初始化</span></span><br><span class="line">                <span class="keyword">if</span> (iter-&gt;safe)</span><br><span class="line">                    iter-&gt;d-&gt;iterators++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    iter-&gt;fingerprint = dictFingerprint(iter-&gt;d);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通常操作，找到下一个entry</span></span><br><span class="line">            iter-&gt;index++;</span><br><span class="line">            <span class="comment">// 但如果这个dictht遍历完了</span></span><br><span class="line">            <span class="keyword">if</span> (iter-&gt;index &gt;= (<span class="keyword">long</span>) ht-&gt;size) &#123;</span><br><span class="line">                <span class="comment">// 如果同时有两个表(dictIsRehashing条件)，且表0遍历完了，就切换到表1</span></span><br><span class="line">                <span class="keyword">if</span> (dictIsRehashing(iter-&gt;d) &amp;&amp; iter-&gt;table == <span class="number">0</span>) &#123;</span><br><span class="line">                    iter-&gt;table++;</span><br><span class="line">                    iter-&gt;index = <span class="number">0</span>;</span><br><span class="line">                    ht = &amp;iter-&gt;d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 再设置一下entry</span></span><br><span class="line">            iter-&gt;entry = ht-&gt;table[iter-&gt;index];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果指定了dictEntry，说明是之前有遍历到某个dictht的一半，这是大部分情况，所以就直接到nextEntry</span></span><br><span class="line">            iter-&gt;entry = iter-&gt;nextEntry;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;entry) &#123;</span><br><span class="line">            <span class="comment">/* We need to save the 'next' here, the iterator user</span></span><br><span class="line"><span class="comment">             * may delete the entry we are returning. */</span></span><br><span class="line">            iter-&gt;nextEntry = iter-&gt;entry-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> iter-&gt;entry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="dict的其他相关方法"><a href="#dict的其他相关方法" class="headerlink" title="dict的其他相关方法"></a>dict的其他相关方法</h2><h3 id="dict遍历抽象主干代码"><a href="#dict遍历抽象主干代码" class="headerlink" title="dict遍历抽象主干代码"></a>dict遍历抽象主干代码</h3><p>由于在dict中常出现遍历操作，为了方便阅读代码，我们将整个遍历操作先抽象出来，在下面相关代码的介绍中，只列出主干。关于这个循环的说明，可以参看<code>_dictKeyIndex</code>的讲解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictHashKey(d, key) (d)-&gt;type-&gt;hashFunction(key)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line">h = dictHashKey(d, key);</span><br><span class="line"><span class="keyword">for</span> (table = <span class="number">0</span>; table &lt;= <span class="number">1</span>; table++) &#123;</span><br><span class="line">    idx = h &amp; d-&gt;ht[table].sizemask;</span><br><span class="line">    he = d-&gt;ht[table].table[idx];</span><br><span class="line">    prevHe = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(he) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">            <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        he = he-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不在Rehash过程中，就不需要查找table=1的表了</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* not found */</span></span><br></pre></td></tr></table></figure>

<h3 id="dictFind"><a href="#dictFind" class="headerlink" title="dictFind"></a>dictFind</h3><p>这个函数用来根据给定的key找到对应的<code>dictEntry</code>，如果找不到，就返回<code>NULL</code>。<br>其中涉及一些Rehash相关的机制，我们在先前已经讲过了，在这里就略过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictFind</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dictEntry *he;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx, table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* dict is empty */</span></span><br><span class="line">    <span class="comment">// 参考“dict遍历抽象主干代码”</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dictGet系列函数"><a href="#dictGet系列函数" class="headerlink" title="dictGet系列函数"></a>dictGet系列函数</h3><p>这个系列的函数主要通过读取<code>union v</code>里面的不同类型的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetSignedIntegerVal(he) ((he)-&gt;v.s64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetUnsignedIntegerVal(he) ((he)-&gt;v.u64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictGetDoubleVal(he) ((he)-&gt;v.d)</span></span><br></pre></td></tr></table></figure>

<h3 id="dictDelete和dictGenericDelete"><a href="#dictDelete和dictGenericDelete" class="headerlink" title="dictDelete和dictGenericDelete"></a>dictDelete和dictGenericDelete</h3><p><code>dictDelete</code>实现，就是调用<code>dictGenericDelete</code>，并且指定是要free的。<strong>注意，我们不要和hiredis里面的dictDelete实现搞混起来</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Remove an element, returning DICT_OK on success or DICT_ERR if the</span></span><br><span class="line"><span class="comment"> * element was not found. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictDelete</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">0</span>) ? DICT_OK : DICT_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们介绍其依赖函数<code>dictGenericDelete</code>。这函数表示要从<code>d</code>中删除一个<code>key</code>。<br>在前面已经看到，<code>dictDelete</code>系列函数相比其他操作会多一个场景，也就是会考虑是不是立即将key和value的对象free掉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> dictEntry *<span class="title">dictGenericDelete</span><span class="params">(dict *d, <span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> nofree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> h, idx;</span><br><span class="line">    dictEntry *he, *prevHe;</span><br><span class="line">    <span class="keyword">int</span> table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span> &amp;&amp; d-&gt;ht[<span class="number">1</span>].used == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictIsRehashing(d)) _dictRehashStep(d);</span><br><span class="line"><span class="comment">// 下面代码参考“dict遍历抽象主干代码”，省略其中大部分</span></span><br><span class="line">...</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这里对dict遍历抽象主干代码的处理会有一些修改，首先用<code>prevHe</code>来记录待删除节点<code>he</code>的父节点，从而将链表接起来。然后是一个<code>nofree</code>选项，可以不去析构key和value。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dictGenericDelete中不连续的部分代码</span></span><br><span class="line">...</span><br><span class="line">        prevHe = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">while</span>(he) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key==he-&gt;key || dictCompareKeys(d, key, he-&gt;key)) &#123;</span><br><span class="line">                <span class="comment">/* Unlink the element from the list */</span></span><br><span class="line">                <span class="keyword">if</span> (prevHe)</span><br><span class="line">                    prevHe-&gt;next = he-&gt;next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    d-&gt;ht[table].table[idx] = he-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (!nofree) &#123;</span><br><span class="line">                    dictFreeKey(d, he);</span><br><span class="line">                    dictFreeVal(d, he);</span><br><span class="line">                    zfree(he);</span><br><span class="line">                &#125;</span><br><span class="line">                d-&gt;ht[table].used--;</span><br><span class="line">                <span class="keyword">return</span> he;</span><br><span class="line">            &#125;</span><br><span class="line">            prevHe = he;</span><br><span class="line">            he = he-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>而<code>dictUnlink</code>就是设置了<code>nofree=1</code>调用了<code>dictGenericDelete</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dictEntry *<span class="title">dictUnlink</span><span class="params">(dict *ht, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dictGenericDelete(ht,key,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HSET的相关数据结构"><a href="#HSET的相关数据结构" class="headerlink" title="HSET的相关数据结构"></a>HSET的相关数据结构</h2><p>HSET是对dict的封装。</p>
<h3 id="hset实现"><a href="#hset实现" class="headerlink" title="hset实现"></a>hset实现</h3><p>我们还是从<code>redisCommandTable</code>里面查到hset的对应函数是<code>hsetCommand</code>。<br><code>hashTypeLookupWriteOrCreate</code>这个函数就是调用<code>lookupKeyWrite</code>，如果找不到，就通过<code>createHashObject</code>创建，这个函数是创建一个<code>OBJ_HASH</code>对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyErrorFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="keyword">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">'s'</span> || cmdname[<span class="number">1</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">"hset"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ZSET"><a href="#ZSET" class="headerlink" title="ZSET"></a>ZSET</h1><p>在本章中，我们将会从ZSET切入，了解它是如何<strong>包装</strong>ziplist和zskiplist的。但是具体到ziplist和zskiplist的实现，是在单独的章节里面讲的。<br>ZSET有两个实现，基于跳表的和基于ziplist的，具体来说：</p>
<ol>
<li>ziplist<br> 是一个双向压缩链表的实现，这里的压缩链表指的是不会保存prev和next信息，而是采用类似线性表的方式将整个list存放在一整块内存中。对应于元素数量少于128，且每个元素的长度小于64字节。</li>
<li>zskiplist<br> 是个跳表的实现。对应于1之外的情况。</li>
</ol>
<h2 id="ZSET和zadd"><a href="#ZSET和zadd" class="headerlink" title="ZSET和zadd"></a>ZSET和zadd</h2><p>从<code>redisCommandTable</code>找到绑定的函数<code>zaddCommand</code>，它会调用一个<code>zaddGenericCommand</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    zaddGenericCommand(c,ZADD_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>zaddGenericCommand</code>，它接受一个<code>flags</code>参数，我们稍后介绍。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">"resulting score is not a number (NaN)"</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* The following vars are used in order to track what the command actually</span></span><br><span class="line"><span class="comment">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class="line"><span class="comment">     * notification of keyspace change. */</span></span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br></pre></td></tr></table></figure>

<p>下面一部分代码是用来处理一些额外输入的flag参数，这里引入了<code>scoreidx</code>表示score/value对开始的位置，在3.0版本中写死了是2，但是由于后面版本允许了<code>nx</code>、<code>xx</code>等参数，所以这边改为动态计算的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"nx"</span>)) flags |= ZADD_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"xx"</span>)) flags |= ZADD_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"ch"</span>)) flags |= ZADD_CH;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"incr"</span>)) flags |= ZADD_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的代码主要是校验参数的合法性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 这里是一个通常的做法，类似于Spark里面的KV存储一样，把score和elements存得很整齐。</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>; <span class="comment">/* Now this holds the number of score-element pairs. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for incompatible options. */</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">"XX and NX options at the same time are not compatible"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">"INCR option supports a single increment-element pair"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，我们开始正式处理参数了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 取回输入的score，或者报错，注意这里是从用户的输入取的</span></span><br><span class="line">    <span class="comment">// 可以看出，偶数位是分数，奇数位是字段值</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从数据库中找到这个ZSET对象</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="comment">// 检查是否是OBJ_ZSET类型</span></span><br><span class="line">    <span class="keyword">if</span> (checkType(c,zobj,OBJ_ZSET)) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    <span class="comment">// 如果这个对象还没有被创建，就创建</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>为了阅读接下来的代码，首先了解两个参数，可以看到，这两个参数就是规定了何时使用ziplist的阈值。上面两个指示了对zset而言，ziplist能用到什么时候，后面就是skiplist。下面两个指示对hash而言，ziplist能用到什么时候，后面就用dict。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createSizeTConfig(<span class="string">"zset-max-ziplist-value"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.zset_max_ziplist_value, <span class="number">64</span>, MEMORY_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>),</span><br><span class="line">createSizeTConfig(<span class="string">"zset-max-ziplist-entries"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.zset_max_ziplist_entries, <span class="number">128</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">createSizeTConfig(<span class="string">"hash-max-ziplist-entries"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.hash_max_ziplist_entries, <span class="number">512</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br><span class="line">createSizeTConfig(<span class="string">"hash-max-ziplist-value"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, LONG_MAX, server.hash_max_ziplist_value, <span class="number">64</span>, MEMORY_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>然后我们来看一下两个对象的创建方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_ZSET,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来看一下创建的逻辑，可以发现，在创建时默认是创建一个ziplist的，其实在后面<code>zsetAdd</code>添加的时候，当超出了ziplist的阈值的时候会调用<code>zsetConvert</code>来转成skiplist。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果zset_max_ziplist_entries是0，也就是说不管怎么样都不会创建ziplist了，</span></span><br><span class="line">            <span class="comment">// 或者第一个要加入的元素就已经超长了</span></span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则还是先创建一个ziplist</span></span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向db注册这个zobj</span></span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，就是调用<code>zsetAdd</code>依次往ZSET里面添加元素了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这个应该是用来支持CH参数的</span></span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReplyNull(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        <span class="comment">// 如果指定了CH，就返回增加和修改的数量，否则只返回增加的数量</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">"zincr"</span> : <span class="string">"zadd"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zsetAdd的实现"><a href="#zsetAdd的实现" class="headerlink" title="zsetAdd的实现"></a>zsetAdd的实现</h2><h3 id="zsetAdd"><a href="#zsetAdd" class="headerlink" title="zsetAdd"></a>zsetAdd</h3><p>在3.0版本里面，并没有这个函数，而是直接放到了<code>zaddGenericCommand</code>里面。但由于后续版本支持了各种flag（注意3.0是可以incr的），逻辑复杂了，所以单独做出了一个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>首先来讨论一下参数，<code>flags</code>按照指针传递，是因为它同时用来保存输入信息和输出信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Input flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NONE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_INCR (1&lt;&lt;0)    <span class="comment">/* Increment the score instead of setting it. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NX (1&lt;&lt;1)      <span class="comment">/* Don't touch elements not already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_XX (1&lt;&lt;2)      <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NOP (1&lt;&lt;3)     <span class="comment">/* Operation not performed because of conditionals.*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_NAN (1&lt;&lt;4)     <span class="comment">/* Only touch elements already existing. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_ADDED (1&lt;&lt;5)   <span class="comment">/* The element was new and was added. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZADD_UPDATED (1&lt;&lt;6) <span class="comment">/* The element already existed, score updated. */</span></span></span><br></pre></td></tr></table></figure>

<p><code>newscore</code>被用来存储返回的incr后的分数。<br>下面我们来看函数的具体实现过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    *flags = <span class="number">0</span>; <span class="comment">/* We'll return our response flags. */</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NaN as input is an error regardless of all the other parameters. */</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="ziplist存储的分支"><a href="#ziplist存储的分支" class="headerlink" title="ziplist存储的分支"></a>ziplist存储的分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Update the sorted set according to its encoding. */</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果已经找到了这个元素</span></span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果需要取回score的值，则newscore不为NULL，那么就顺便返回</span></span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过先删除再添加的方法来实现修改score</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">// 如果没有找到，并且没有xx选项（xx选项表示只更新不添加），那么就进行添加</span></span><br><span class="line">            <span class="comment">/* Optimize: check if the element is too large or the list</span></span><br><span class="line"><span class="comment">             * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">            <span class="comment">// 如果超过阈值，就要转换成跳表</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries ||</span><br><span class="line">                sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="跳表存储的分支"><a href="#跳表存储的分支" class="headerlink" title="跳表存储的分支"></a>跳表存储的分支</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 需要同时更新哈希表和跳表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看成员是否存在</span></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果成员存在</span></span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 取出成员的分值</span></span><br><span class="line">            <span class="comment">// 其中de是dictEntry</span></span><br><span class="line">            <span class="comment">// #define dictGetKey(he) ((he)-&gt;key)</span></span><br><span class="line">            <span class="comment">// #define dictGetVal(he) ((he)-&gt;v.val)</span></span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                <span class="comment">// 对于跳表来讲，就有一个单独的函数了，对于某些情况，能够原地更新，但对于特殊情况会先删除再加上</span></span><br><span class="line">                znode = zslUpdateScore(zs-&gt;zsl,curscore,ele,score);</span><br><span class="line">                <span class="comment">/* Note that we did not removed the original element from</span></span><br><span class="line"><span class="comment">                 * the hash table representing the sorted set, so we just</span></span><br><span class="line"><span class="comment">                 * update the score. */</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">// 如果没有设置只更新不添加的机制</span></span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="zsetConvert"><a href="#zsetConvert" class="headerlink" title="zsetConvert"></a>zsetConvert</h3><p>参数<code>encoding</code>表示要转换成什么格式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zsetConvert</span><span class="params">(robj *zobj, <span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">    zset *zs;</span><br><span class="line">    zskiplistNode *node, *next;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == encoding) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_SKIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">        zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">        zs-&gt;zsl = zslCreate();</span><br><span class="line"></span><br><span class="line">        eptr = ziplistIndex(zl,<span class="number">0</span>);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,sptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (eptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            score = zzlGetScore(sptr);</span><br><span class="line">            serverAssertWithInfo(<span class="literal">NULL</span>,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>)</span><br><span class="line">                ele = sdsfromlonglong(vlong);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ele = sdsnewlen((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line"></span><br><span class="line">            node = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;node-&gt;score) == DICT_OK);</span><br><span class="line">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(zobj-&gt;ptr);</span><br><span class="line">        zobj-&gt;ptr = zs;</span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Approach similar to zslFree(), since we want to free the skiplist at</span></span><br><span class="line"><span class="comment">         * the same time as creating the ziplist. */</span></span><br><span class="line">        zs = zobj-&gt;ptr;</span><br><span class="line">        dictRelease(zs-&gt;dict);</span><br><span class="line">        node = zs-&gt;zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        zfree(zs-&gt;zsl-&gt;header);</span><br><span class="line">        zfree(zs-&gt;zsl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            zl = zzlInsertAt(zl,<span class="literal">NULL</span>,node-&gt;ele,node-&gt;score);</span><br><span class="line">            next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            zslFreeNode(node);</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(zs);</span><br><span class="line">        zobj-&gt;ptr = zl;</span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zrangeGenericCommand"><a href="#zrangeGenericCommand" class="headerlink" title="zrangeGenericCommand"></a>zrangeGenericCommand</h2><p>zrangeGenericCommand主要处理<code>ZRANGE</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zrangeGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> reverse)</span> </span>&#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    <span class="keyword">int</span> withscores = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">long</span> end;</span><br><span class="line">    <span class="keyword">long</span> llen;</span><br><span class="line">    <span class="keyword">long</span> rangelen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;start, <span class="literal">NULL</span>) != C_OK) ||</span><br><span class="line">        (getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">3</span>], &amp;end, <span class="literal">NULL</span>) != C_OK)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">5</span> &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">4</span>]-&gt;ptr,<span class="string">"withscores"</span>)) &#123;</span><br><span class="line">        withscores = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyReadOrReply(c,key,shared.emptyarray)) == <span class="literal">NULL</span></span><br><span class="line">         || checkType(c,zobj,OBJ_ZSET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanitize indexes. */</span></span><br><span class="line">    llen = zsetLength(zobj);</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = llen+start;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = llen+end;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span>) start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant: start &gt;= 0, so this test will be true when end &lt; 0.</span></span><br><span class="line"><span class="comment">     * The range is empty when start &gt; end or start &gt;= length. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end || start &gt;= llen) &#123;</span><br><span class="line">        addReply(c,shared.emptyarray);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (end &gt;= llen) end = llen<span class="number">-1</span>;</span><br><span class="line">    rangelen = (end-start)+<span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>通过start和end计算出需要取出的长度rangelen。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Return the result in form of a multi-bulk reply. RESP3 clients</span></span><br><span class="line"><span class="comment">     * will receive sub arrays with score-&gt;element, while RESP2 returned</span></span><br><span class="line"><span class="comment">     * a flat array. */</span></span><br><span class="line">    <span class="keyword">if</span> (withscores &amp;&amp; c-&gt;resp == <span class="number">2</span>)</span><br><span class="line">        addReplyArrayLen(c, rangelen*<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        addReplyArrayLen(c, rangelen);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于ziplist的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reverse)</span><br><span class="line">            eptr = ziplistIndex(zl,<span class="number">-2</span>-(<span class="number">2</span>*start));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            eptr = ziplistIndex(zl,<span class="number">2</span>*start);</span><br><span class="line"></span><br><span class="line">        serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (rangelen--) &#123;</span><br><span class="line">            serverAssertWithInfo(c,zobj,eptr != <span class="literal">NULL</span> &amp;&amp; sptr != <span class="literal">NULL</span>);</span><br><span class="line">            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withscores &amp;&amp; c-&gt;resp &gt; <span class="number">2</span>) addReplyArrayLen(c,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>)</span><br><span class="line">                addReplyBulkLongLong(c,vlong);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                addReplyBulkCBuffer(c,vstr,vlen);</span><br><span class="line">            <span class="keyword">if</span> (withscores) addReplyDouble(c,zzlGetScore(sptr));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (reverse)</span><br><span class="line">                zzlPrev(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对于跳表的实现，通过<code>zslGetElementByRank</code>获得我们要遍历的起点<code>ln</code>。在找到之后，直接移动backward指针，或者最底层的forward指针，取出rangelen的元素。<br>所以对于面试日经题目，跳表的zrange复杂度是多少？答案就是<code>O(log(n)+rangelen)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln;</span><br><span class="line">        sds ele;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if starting point is trivial, before doing log(N) lookup. */</span></span><br><span class="line">        <span class="keyword">if</span> (reverse) &#123;</span><br><span class="line">            ln = zsl-&gt;tail;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span>)</span><br><span class="line">                ln = zslGetElementByRank(zsl,llen-start);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ln = zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            <span class="keyword">if</span> (start &gt; <span class="number">0</span>)</span><br><span class="line">                ln = zslGetElementByRank(zsl,start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(rangelen--) &#123;</span><br><span class="line">            serverAssertWithInfo(c,zobj,ln != <span class="literal">NULL</span>);</span><br><span class="line">            ele = ln-&gt;ele;</span><br><span class="line">            <span class="keyword">if</span> (withscores &amp;&amp; c-&gt;resp &gt; <span class="number">2</span>) addReplyArrayLen(c,<span class="number">2</span>);</span><br><span class="line">            addReplyBulkCBuffer(c,ele,sdslen(ele));</span><br><span class="line">            <span class="keyword">if</span> (withscores) addReplyDouble(c,ln-&gt;score);</span><br><span class="line">            ln = reverse ? ln-&gt;backward : ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="zskiplist"><a href="#zskiplist" class="headerlink" title="zskiplist"></a>zskiplist</h1><p><code>zskiplist</code>是跳表，Redis用它来作为有序集合ZSET的一个实现。<br>跳表的查找复杂度是平均$O(log n)$最坏$O(n)$，而插入/删除复杂度是$O(log n)$。</p>
<h2 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h2><p>跳表的结构如下所示</p>
<p><img src="/img/redis_object/skiplist.png"></p>
<p>结构定义如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>容易看到，这里的<code>level</code>是一个Flex Array，这是C99里面的特性，实际上是一个长度为0的数组。</p>
<p>跳表里面的一个元素，对应一个<code>zskiplistNode</code>。每个<code>zskiplistNode</code>可能有若干个<code>zskiplistLevel</code>，从而组成跳表的层次结构。</p>
<ol>
<li><p>backward<br> 这个指针是一个<code>zskiplistNode</code>一个的，指向<strong>最下面一层</strong>的前一个节点。</p>
</li>
<li><p>zskiplistLevel::forward<br> 每一层都有一个，指向当前层的下一个节点。层数越往上，<code>zskiplistLevel::span</code>越大。</p>
</li>
<li><p>span<br> span表示<strong>当前节点当前层</strong>的后向(forward)指针跨越了多少节点。对于最下面一层，<strong>它的span就是1</strong>。如果在某一层上，forward相对对下面一层跳过了一个节点，那么span就是2。<br> 这个值对跳表实现不是必要的，增加它是为了方便计算<code>rank[i]</code>。<br> rank是为了实现<code>zsetRank</code>设置的。【Q】一个问题是为什么需要用<code>rank[i]</code>数组。这个我加日志打印了一下，发现这反映了插入新Node时，我们插入到的是<code>update[i]</code>的后面，而<code>rank[i]</code>就表示这个<code>update[i]</code>到链表头的距离。<br> 考虑<code>zslInsert</code>，我们要插入下面两行</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zadd y 1.0 a 2.0 b 3.0 c 4.0 d 5.0 e 6.0 f</span><br><span class="line">zadd y 4.5 de</span><br><span class="line">zadd y 3.5 cd</span><br></pre></td></tr></table></figure>

<p> 检查插入cd前的行为。对于4/5层来说，d前面都没有该层节点了，所以rank都是0。同时可以注意到，因为最底层(第0层)永远表示待插入的节点前面有多少个。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rank[<span class="number">0</span>]=<span class="number">3</span></span><br><span class="line">rank[<span class="number">1</span>]=<span class="number">3</span></span><br><span class="line">rank[<span class="number">2</span>]=<span class="number">3</span></span><br><span class="line">rank[<span class="number">3</span>]=<span class="number">3</span></span><br><span class="line">rank[<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line">rank[<span class="number">5</span>]=<span class="number">0</span></span><br><span class="line">SUMMARY: tot level <span class="number">6</span></span><br><span class="line">(   )[S: <span class="number">1</span>]  (  a)[S: <span class="number">1</span>]  (  b)[S: <span class="number">1</span>]  (  c)[S: <span class="number">1</span>]  (  d)[S: <span class="number">1</span>]  ( de)[S: <span class="number">1</span>]  (  e)[S: <span class="number">1</span>]  (  f)[S: <span class="number">0</span>]  </span><br><span class="line">(   )[S: <span class="number">2</span>]  .............(  b)[S: <span class="number">1</span>]  (  c)[S: <span class="number">1</span>]  (  d)[S: <span class="number">3</span>]  ..........................(  f)[S: <span class="number">0</span>]  </span><br><span class="line">(   )[S: <span class="number">3</span>]  ..........................(  c)[S: <span class="number">1</span>]  (  d)[S: <span class="number">3</span>]  </span><br><span class="line">(   )[S: <span class="number">3</span>]  ..........................(  c)[S: <span class="number">1</span>]  (  d)[S: <span class="number">3</span>]  </span><br><span class="line">(   )[S: <span class="number">4</span>]  .......................................(  d)[S: <span class="number">3</span>]  </span><br><span class="line">(   )[S: <span class="number">4</span>]  .......................................(  d)[S: <span class="number">3</span>]  </span><br><span class="line">node_len <span class="number">13</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="zslCreateNode"><a href="#zslCreateNode" class="headerlink" title="zslCreateNode"></a>zslCreateNode</h3><p>我们进一步查看<code>zslCreateNode</code>是如何被初始化的，容易看出，它的空间占用等于<code>zskiplistNode</code>的大小，加上<code>level</code>的长度乘以<code>zskiplistLevel</code>的大小。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function">zskiplistNode *<span class="title">zslCreateNode</span><span class="params">(<span class="keyword">int</span> level, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *zn =</span><br><span class="line">        zmalloc(<span class="keyword">sizeof</span>(*zn)+level*<span class="keyword">sizeof</span>(struct zskiplistLevel));</span><br><span class="line">    zn-&gt;score = score;</span><br><span class="line">    zn-&gt;ele = ele;</span><br><span class="line">    <span class="keyword">return</span> zn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳表数据结构的展现"><a href="#跳表数据结构的展现" class="headerlink" title="跳表数据结构的展现"></a>跳表数据结构的展现</h3><p>下面的代码可以轻松地打印出zskiplist的结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printZsl</span><span class="params">(zskiplist *zsl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tot_level = zsl-&gt;level;</span><br><span class="line">    <span class="keyword">int</span> node_len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> join_size = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"SUMMARY: tot level %d\n"</span>, tot_level);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; tot_level; level++)&#123;</span><br><span class="line">        zskiplistNode * prev = <span class="number">0</span>;</span><br><span class="line">        zskiplistNode * x = zsl-&gt;header;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)  &#123;</span><br><span class="line">            <span class="keyword">int</span> gap = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(level &amp;&amp; prev)&#123;</span><br><span class="line">                zskiplistNode * y = prev;</span><br><span class="line">                <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y-&gt;ele != x-&gt;ele) &#123;</span><br><span class="line">                        gap ++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(y-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">                        y = y-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> length = (gap - <span class="number">1</span>) * node_len;</span><br><span class="line">                <span class="keyword">int</span> modified_length = length &lt;= <span class="number">0</span> ? <span class="number">0</span> : length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> kk = <span class="number">0</span>; kk &lt; modified_length; kk++) <span class="built_in">printf</span>(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sprintf</span>(buf, <span class="string">"(%3.3s)[S:%2ld]%*s"</span>, x-&gt;ele, x-&gt;level[level].span, join_size, <span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">if</span>(node_len == <span class="number">0</span>) node_len = <span class="built_in">strlen</span>(buf);</span><br><span class="line">            <span class="built_in">printf</span>(buf);</span><br><span class="line">            prev = x;</span><br><span class="line">            <span class="keyword">if</span>(x-&gt;level[level].forward)</span><br><span class="line">                x = x-&gt;level[level].forward;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"node_len %d\n"</span>, node_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们修改<code>zslInsert</code>代码，并输入下面的语句，为了便于得到更高的跳表，我们设置<code>ZSKIPLIST_P</code>到0.5（参考下文）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd zs2 1 a 2 b 10 c 5 d 5 e 6 f1 6 f2 6 f3 6 f4 6 f5 6 f6 6 f7 6 f8 6 f9 6 f10 6 f11</span><br></pre></td></tr></table></figure>

<p>得到打印的结果如下（这里输出是反的，第0层实际上是“最下面一层”，也就是最密集的那一层）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SUMMARY: tot level 7</span><br><span class="line">(   )[S: 1]  (  a)[S: 1]  (  b)[S: 1]  (  d)[S: 1]  (  e)[S: 1]  ( f1)[S: 1]  (f10)[S: 1]  ( f2)[S: 1]  ( f3)[S: 1]  ( f4)[S: 1]  ( f5)[S: 1]  ( f6)[S: 1]  ( f7)[S: 1]  ( f8)[S: 1]  ( f9)[S: 1]  (  c)[S: 0]  </span><br><span class="line">(   )[S: 1]  (  a)[S: 1]  (  b)[S: 1]  (  d)[S: 1]  (  e)[S: 2]  .............(f10)[S: 1]  ( f2)[S: 5]  ....................................................( f7)[S: 1]  ( f8)[S: 2]  </span><br><span class="line">(   )[S: 1]  (  a)[S: 1]  (  b)[S: 1]  (  d)[S: 4]  .......................................( f2)[S: 5]  ....................................................( f7)[S: 1]  ( f8)[S: 2]  </span><br><span class="line">(   )[S: 2]  .............(  b)[S: 1]  (  d)[S: 4]  .......................................( f2)[S: 6]  .................................................................( f8)[S: 2]  </span><br><span class="line">(   )[S: 2]  .............(  b)[S: 1]  (  d)[S: 4]  .......................................( f2)[S: 8]  </span><br><span class="line">(   )[S: 2]  .............(  b)[S: 1]  (  d)[S:12]  </span><br><span class="line">(   )[S: 2]  .............(  b)[S:13]  </span><br><span class="line">node_len 13</span><br></pre></td></tr></table></figure>

<p>可以比较容易得看出：</p>
<ol>
<li>header节点是空的</li>
<li>span表示当前层上相邻两个节点的实际距离。对于level 0来说，相邻两个节点的实际距离一定为1</li>
</ol>
<h2 id="zslInsert的实现"><a href="#zslInsert的实现" class="headerlink" title="zslInsert的实现"></a>zslInsert的实现</h2><h3 id="跳表遍历抽象主干代码"><a href="#跳表遍历抽象主干代码" class="headerlink" title="跳表遍历抽象主干代码"></a>跳表遍历抽象主干代码</h3><p>我们首先看到的是跳表遍历抽象的主干代码，它会在很多地方重复出现。这段代码的含义是计算<code>update[i]</code>和<code>rank[i]</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslInsert</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示我们在第i层的第update[i]节点后面，插入新节点</span></span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="comment">// 这是一个临时变量，前期做迭代用，后期表示新节点</span></span><br><span class="line">    zskiplistNode *x; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> rank[ZSKIPLIST_MAXLEVEL];</span><br><span class="line">    <span class="keyword">int</span> i, level;</span><br><span class="line"></span><br><span class="line">    serverAssert(!isnan(score));</span><br><span class="line">    <span class="comment">// x是表头节点</span></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="comment">// 从最高层节点（跨度最大）逐层向下遍历，这样方便复用，稍后将看到我们新增节点的时候是从下往上构建的</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* store rank that is crossed to reach the insert position */</span></span><br><span class="line">        <span class="comment">// 最终rank[0]的值加一就是新节点的前置节点(update)的排位</span></span><br><span class="line">        rank[i] = i == (zsl-&gt;level<span class="number">-1</span>) ? <span class="number">0</span> : rank[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                <span class="comment">// 如果要插入的score，比前面节点的score还要大，就前进</span></span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                    <span class="comment">// 如果score相等，那么就比较ele</span></span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                    sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// x-&gt;level[i].span表示第i层上，当前节点到forward节点的中间有多少个节点，比如这是第t个节点，那么经过了a_&#123;t+1&#125; – a&#123;t&#125;个节点。</span></span><br><span class="line">            <span class="comment">// rank[i]表示这个节点排第几</span></span><br><span class="line">            rank[i] += x-&gt;level[i].span;</span><br><span class="line">            <span class="comment">// 前进节点</span></span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于第i层，我们要修改这个节点，它是score最大的小于要插入的x的节点</span></span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在以上的代码执行完之后，我们得到了计算好的<code>update</code>和<code>rank</code>数组。我们要在<code>update[i]</code>后面插入节点，并且用<code>rank[i]</code>来更新span。<br>在这里，我们假设元素没有在跳表中，这是因为：</p>
<ol>
<li>跳表是通过score排序的，而score是允许重复的，所以无法通过score来判断。</li>
<li>而在跳表中插入相同的元素是不可能的情况，因为zslInsert的调用者通过dict来维护是否有相同元素。</li>
</ol>
<p>在插入新节点前，首先需要为这个节点生成一个随机层高，同时处理这个随机层高大于现有层高的情况。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续zslInsert</span></span><br><span class="line">...</span><br><span class="line">    level = zslRandomLevel();</span><br><span class="line">    <span class="keyword">if</span> (level &gt; zsl-&gt;level) &#123;</span><br><span class="line">        <span class="comment">// 如果新节点的level比这个跳表的最大层数zsl-&gt;level都大，即出现一个珠穆朗玛峰了，</span></span><br><span class="line">        <span class="comment">// 初始化一下zsl-&gt;level以上的所有的层</span></span><br><span class="line">        <span class="keyword">for</span> (i = zsl-&gt;level; i &lt; level; i++) &#123;</span><br><span class="line">            <span class="comment">// 这里是初始化一下rank，方便后面往上加span</span></span><br><span class="line">            rank[i] = <span class="number">0</span>;</span><br><span class="line">            update[i] = zsl-&gt;header;</span><br><span class="line">            update[i]-&gt;level[i].span = zsl-&gt;length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新跳表的最大层数</span></span><br><span class="line">        zsl-&gt;level = level;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 函数待续</span></span><br></pre></td></tr></table></figure>

<p>zslRandomLevel生成待插入节点的随机高度。<br>注意，这里层数越往上的概率是越低的，最终能够形成一个powerlaw的分布。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// t_zset.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br></pre></td></tr></table></figure>

<p>下面就是将新增的节点插入跳表中。新链表的前后顺序是<code>update -&gt; x -&gt; update.forward</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续zslInsert</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 主要就是分配一个zskiplistNode，并且设置score和ele。</span></span><br><span class="line">    x = zslCreateNode(level,score,ele);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="comment">// 更新x前向指针</span></span><br><span class="line">        x-&gt;level[i].forward = update[i]-&gt;level[i].forward;</span><br><span class="line">        <span class="comment">// 更新update前向指针</span></span><br><span class="line">        update[i]-&gt;level[i].forward = x;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面我们的目标是计算<code>x-&gt;level[i].span</code>。从前面介绍过了，span表示当前节点当前层的后向指针跨越了多少节点。由于<code>x</code>被插到了中间，所以需要更新<code>x</code>和<code>update</code>的span。<br>对于<code>x</code>而言，它继承了<code>update</code>的span的后半部分，即<code>+</code>号覆盖的部分，这个后半部分的长度等于总span的长度减去从<code>update</code>到<code>x</code>的span。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">插入前  update-------------update.forward</span><br><span class="line">插入后  update      x++++++update.forward</span><br></pre></td></tr></table></figure>

<p>下面这个公式，有点愣神了。为了方便理解，不如先看<code>i=0</code>的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[0] - rank[i]);</span><br></pre></td></tr></table></figure>

<ol>
<li>计算<code>x</code>最下层的span，即<code>x-&gt;level[0].span</code><br> 结果是<code>update[i]-&gt;level[i].span</code>。这是因为<code>x</code>是紧插到<code>update</code>后面的，这样会导致<code>x</code>实际上继承了<code>update</code>的span。</li>
<li>计算<code>update</code>最下层的span，即<code>update[0]-&gt;level[0].span</code><br> 结果是<code>rank[0]-rank[0]+1=1</code>。这是因为<code>update</code>紧后面就是<code>x</code>了，所以这里的1就表示跨越到<code>x</code>节点的距离。</li>
</ol>
<p>那么，往回看到<code>i</code>取任意值的情况：</p>
<ol>
<li>计算<code>x-&gt;level[i].span</code></li>
<li>计算<code>update[i]-&gt;level[i].span</code><br> 从前面的讨论中，我们可以知道<code>rank[0]</code>表示第0层中，待插入节点<code>x</code>前面有多少个节点。<br> 同理<code>rank[i]</code>表示在第i层中，待插入节点<code>x</code>前面有多少个节点。<br> 那么<code>(rank[0] - rank[i]) + 1</code>就是第i层上，<code>update[i]</code>和<code>x</code>中间有多少个节点。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">// 计算对于新增节点而言，它第i层的span</span></span><br><span class="line">        x-&gt;level[i].span = update[i]-&gt;level[i].span - (rank[<span class="number">0</span>] - rank[i]);</span><br><span class="line">        update[i]-&gt;level[i].span = (rank[<span class="number">0</span>] - rank[i]) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在level层及之上，新节点x是没有对应的节点的，所以span要自增。</span></span><br><span class="line">    <span class="keyword">for</span> (i = level; i &lt; zsl-&gt;level; i++) &#123;</span><br><span class="line">        update[i]-&gt;level[i].span++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新节点的前向节点始终是update[0]，也就是最底层的前驱</span></span><br><span class="line">    x-&gt;backward = (update[<span class="number">0</span>] == zsl-&gt;header) ? <span class="literal">NULL</span> : update[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;level[<span class="number">0</span>].forward)</span><br><span class="line">        x-&gt;level[<span class="number">0</span>].forward-&gt;backward = x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        zsl-&gt;tail = x;</span><br><span class="line">    zsl-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zslGetRank实现"><a href="#zslGetRank实现" class="headerlink" title="zslGetRank实现"></a>zslGetRank实现</h2><p>注意Rank是从1开始算的。<br>这里实现还是一个经典的二层循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Find the rank for an element by both score and key.</span></span><br><span class="line"><span class="comment"> * Returns 0 when the element cannot be found, rank otherwise.</span></span><br><span class="line"><span class="comment"> * Note that the rank is 1-based due to the span of zsl-&gt;header to the</span></span><br><span class="line"><span class="comment"> * first element. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">zslGetRank</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> score, sds ele)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> rank = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">            (x-&gt;level[i].forward-&gt;score &lt; score ||</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score == score &amp;&amp;</span><br><span class="line">                sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt;= <span class="number">0</span>))) &#123;</span><br><span class="line">            rank += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* x might be equal to zsl-&gt;header, so test if obj is non-NULL */</span></span><br><span class="line">        <span class="keyword">if</span> (x-&gt;ele &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rank;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zslUpdateScore的实现"><a href="#zslUpdateScore的实现" class="headerlink" title="zslUpdateScore的实现"></a>zslUpdateScore的实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">zskiplistNode *<span class="title">zslUpdateScore</span><span class="params">(zskiplist *zsl, <span class="keyword">double</span> curscore, sds ele, <span class="keyword">double</span> newscore)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *x;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to seek to element to update to start: this is useful anyway,</span></span><br><span class="line"><span class="comment">     * we'll have to update or remove it. */</span></span><br><span class="line">    x = zsl-&gt;header; </span><br><span class="line">    <span class="comment">// 参考zslInsert，主要是为了取得update和x</span></span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp;</span><br><span class="line">                (x-&gt;level[i].forward-&gt;score &lt; curscore ||</span><br><span class="line">                    (x-&gt;level[i].forward-&gt;score == curscore &amp;&amp;</span><br><span class="line">                     sdscmp(x-&gt;level[i].forward-&gt;ele,ele) &lt; <span class="number">0</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        update[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Jump to our element: note that this function assumes that the</span></span><br><span class="line"><span class="comment">     * element with the matching score exists. */</span></span><br><span class="line">    x = x-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">    serverAssert(x &amp;&amp; curscore == x-&gt;score &amp;&amp; sdscmp(x-&gt;ele,ele) == <span class="number">0</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在下面几种情况下，可以不进行先删除再添加的操作，而只是更新score：</p>
<ol>
<li>如果是第一个节点，或者前面的节点的分数比新分数要小。</li>
<li>或者是最后一个节点（必须最下层），或者后面的节点的分数比新分数要大。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((x-&gt;backward == <span class="literal">NULL</span> || x-&gt;backward-&gt;score &lt; newscore) &amp;&amp;</span><br><span class="line">        (x-&gt;level[<span class="number">0</span>].forward == <span class="literal">NULL</span> || x-&gt;level[<span class="number">0</span>].forward-&gt;score &gt; newscore))</span><br><span class="line">    &#123;</span><br><span class="line">        x-&gt;score = newscore;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在更通用的情况下，我们只能删除原节点<code>x</code>，并且重新插入新节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* No way to reuse the old node: we need to remove and insert a new</span></span><br><span class="line"><span class="comment">     * one at a different place. */</span></span><br><span class="line">    zslDeleteNode(zsl, x, update);</span><br><span class="line">    zskiplistNode *newnode = zslInsert(zsl,newscore,x-&gt;ele);</span><br><span class="line">    <span class="comment">// 这里复用原节点的ele字段，所以置为NULL，防止被delete</span></span><br><span class="line">    x-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">    zslFreeNode(x);</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="zslGetElementByRank的实现"><a href="#zslGetElementByRank的实现" class="headerlink" title="zslGetElementByRank的实现"></a>zslGetElementByRank的实现</h2><p>这个函数作用是获得的元素，被用来处理跳表对zrange的实现。这里的rank是从1开始的。<br>此外还有个zsetRank，用来获得元素从0开始的RANK。</p>
<p>这里的遍历，其实和经典的遍历类似。我们从最高层尝试往右移动指针，一旦我们发现移动过头了，我们就转而下沉一层。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Finds an element by its rank. The rank argument needs to be 1-based. */</span></span><br><span class="line"><span class="function">zskiplistNode* <span class="title">zslGetElementByRank</span><span class="params">(zskiplist *zsl, <span class="keyword">unsigned</span> <span class="keyword">long</span> rank)</span> </span>&#123;</span><br><span class="line">    zskiplistNode *x;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> traversed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    x = zsl-&gt;header;</span><br><span class="line">    <span class="keyword">for</span> (i = zsl-&gt;level<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (x-&gt;level[i].forward &amp;&amp; (traversed + x-&gt;level[i].span) &lt;= rank)</span><br><span class="line">        &#123;</span><br><span class="line">            traversed += x-&gt;level[i].span;</span><br><span class="line">            x = x-&gt;level[i].forward;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (traversed == rank) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ziplist"><a href="#ziplist" class="headerlink" title="ziplist"></a>ziplist</h1><p>ziplist是一个比较神奇的结构，通常被用在ZSET和HASH等结构上面。首先我们解释一下它的名字</p>
<ol>
<li>zip<br> 说明ziplist是压缩的，空间优化的。那么既然优化了空间，时间可能就会受损。  </li>
<li>list<br> 说明ziplist是一个双向链表，可以存储SDS和整数。</li>
</ol>
<p>那么，ziplist优化在哪里呢？</p>
<ol>
<li>ziplist整体是连续分配的<br> 虽然作为一个链表存在，但它的内存是一次性连续分配的。</li>
<li>因为连续分配，所以ziplist省去了前向指针<br> 可以根据这个entry的encoding，直接算出来下一个元素的offset。</li>
<li>ziplist节约了后向指针的大小<br> 因为只是指定了后向指针的偏移。</li>
</ol>
<h2 id="格式与创建"><a href="#格式与创建" class="headerlink" title="格式与创建"></a>格式与创建</h2><p>首先，分配了头部和尾部的空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ziplist.c</span></span><br><span class="line"><span class="comment">/* Create a new empty ziplist. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE+ZIPLIST_END_SIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</span><br></pre></td></tr></table></figure>

<p>那么头部和尾部究竟是什么呢？<br>头部包含了32位的int，表示总长度；32位的int表示最后一个元素的offset。16位表示item的数量。在头部保存尾部指针的实现逻辑在链表中是非常常见的，这使得查找尾部的操作是$O(1)$的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_HEADER_SIZE     (sizeof(uint32_t)*2+sizeof(uint16_t))</span></span><br></pre></td></tr></table></figure>

<p>尾部有一个”end of ziplist” entry，它是一个值为255的byte，表示结束。不过为什么需要这个<code>ZIP_END</code>来表示结束呢？也许是为了遍历的方便，那么在这里我们就能猜测到ziplist里面的元素肯定是<strong>经过特殊编码</strong>的，255这个编码表示结束，没有第二个编码长这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Size of the "end of ziplist" entry. Just one byte. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_END_SIZE        (sizeof(uint8_t))</span></span><br></pre></td></tr></table></figure>

<p>这两个宏可以取头和尾</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return total bytes a ziplist is composed of. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_BYTES(zl)       (*((uint32_t*)(zl)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the offset of the last item inside the ziplist. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZIPLIST_TAIL_OFFSET(zl) (*((uint32_t*)((zl)+sizeof(uint32_t))))</span></span><br></pre></td></tr></table></figure>

<p>下面继续看实现，我们可以看到，ziplist的大小是包括了头和尾的大小的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</span><br><span class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</span><br><span class="line">    ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</span><br><span class="line">    zl[bytes<span class="number">-1</span>] = ZIP_END;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>下面我们来看看ziplist的编码格式</p>
<ol>
<li>00xxxxxx<br> xxxxxx表示字符串的位数，最大长度63。</li>
<li>01xxxxxx xxxxxxxx<br> xxxxxx xxxxxxxx(14个x)表示字符串的长度。</li>
<li>10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd<br> 从a到d表示字符串的长度。</li>
<li>11000000<br> int16</li>
<li>11010000<br> int32</li>
<li>11100000<br> int64</li>
<li>11110000<br> int24</li>
<li>11111110<br> int8</li>
<li>11111111<br> <code>ZIP_END</code>是255表示结束。</li>
<li>1111xxxx<br> xxxx的范围只能是(0001<del>1101), 也就是1</del>13。<br> 因为int8和EOF占了14和15的情况。</li>
</ol>
<h1 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h1><p>HyperLogLog算法主要用在基数统计中，也就是能用很小的内存占用统计出集合的大小。在Redis中，只需要大概12KB的内存就能够统计接近<code>2**64</code>个不同元素的基数。<br>HyperLogLog算法是对LogLog算法的改进。包括LogLog Counting采用的算数/几何平均数对离群值（比如0）更敏感，而HyperLogLog采用了调和平均。这里的LogLog指的是算法复杂度是$O(log(log(N_{max})))$</p>
<h2 id="HLL原理"><a href="#HLL原理" class="headerlink" title="HLL原理"></a>HLL原理</h2><p>HLL通过一个哈希函数把输入<code>x</code>映射到一个bitset上，然后对这个bitset进行考察。考虑bitset长度为4，那么出现<code>0001</code>这样的结果的概率是<code>1/16</code>，也就是说平均要抛16次才能得到。在对数字的二进制表示进行采样的过程中，我们认为有一半的数字是以<code>1</code>开头的，另一半是以<code>0</code>开头的。同理，有1/4的数字是以<code>01</code>开头的，1/8以<code>001</code>开头的。那么在一个随机流中，我们恰恰发现一个<code>001</code>开头的，那么至少这个集合有8个元素。</p>
<p>进行推广，如下所示。考虑长度为<code>L</code>的bitset，那么前<code>k-1</code>项都为0，而第<code>k</code>项为1的概率，根据二项分布是$1/2^k$。因此可以通过统计bitset中第一个1出现的位置来估算数量。具体来说，我们把一批元素通过哈希函数映射成一系列bitset并放入一个桶里面，然后统计整个过程中，每个哈希值中第一个1出现的最大值(越往左越大)。我们假设最左端是第<strong>1</strong>位，那么假如第一个1出现的位置的最大值是在第$m$位，那么集合中就有$2^m$个元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         m</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">v1  xxxxxxxxx10</span><br><span class="line">v2  xxxxx100000</span><br><span class="line">... </span><br><span class="line">vn  xxxxxxx1000</span><br><span class="line">   |---- L ----|</span><br></pre></td></tr></table></figure>

<p>为了提高精度，实际上可以使用多个桶而不是一个桶来进行统计。Redis使用了一个分桶的技巧，也就是说给定一个序号$b$，将bitset中小于$b$的所有位数<code>bitset[0..(b-1)]</code>决定桶的序号，剩下的部分用来就是做那个伯努利过程。那么最终就能够得到这$2^b$个桶中第$i$个桶的预估元素个数$2^{m_i}$。</p>
<p>如何从这多个桶的输出结果中总结到最终结果呢？HLL使用<strong>调和平均数</strong>来计算。令$B  = 2^b$，表示总的桶数。那么计算$A$就是平均每个桶里面的元素个数。</p>
<p>$$<br>A = \frac{B}{\sum_{i=1}^{B}{2^{-m_i}}} = \frac{B}{\sum_{i=1}^{B}{ \frac{1}{2^{m_i}}  }}<br>$$</p>
<p>那总元素的个数就是$AB$。</p>
<p>在实际操作的时候，发现有一个问题，例如有的桶直接就是0，也就是说<strong>没有出现一个1</strong>，对这种情况我们如何处理呢？或者说，我们认为这表示这个集合的值是比<code>001</code>这样的小还是大呢？我觉得，其实应该认为这个集合是**远远大于<code>001</code>**的，事实上集合的大小至少应该等于<code>10...0</code>(共有len(bitset)个0)。形象一点，这里都是0的原因是因为真正的1其实还在更前面！所以在计算的时候，<code>0...00</code>和<code>0...01</code>表示的值之间就会存在一个很大的落差，不知道我理解是否正确。</p>
<p>最后，我们得到的$AB$其实不准确，还需要进行修正。</p>
<h2 id="Redis的HLL的基本结构"><a href="#Redis的HLL的基本结构" class="headerlink" title="Redis的HLL的基本结构"></a>Redis的HLL的基本结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">4</span>];      <span class="comment">/* "HYLL" */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> encoding;   <span class="comment">/* HLL_DENSE or HLL_SPARSE. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> notused[<span class="number">3</span>]; <span class="comment">/* Reserved for future use, must be zero. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> card[<span class="number">8</span>];    <span class="comment">/* Cached cardinality, little endian. */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> registers[]; <span class="comment">/* Data bytes. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>encoding</code><br> 它的取值是<code>HLL_DENSE</code>和<code>HLL_SPARSE</code>，分别对应<strong>Dense存储模式和Sparse存储模式</strong>，这两个存储模式是Redis的HLL实现的一个精妙的部分，用来节省存储空间。此外，在内部还会有一个<code>HLL_RAW</code>的模式，这个只在pfcount上用到，并且不对外暴露。后面详细介绍这两个结构。</li>
<li><code>registers</code><br> 一个Flex数组，即上面提到的bitset。因为Sparse存储模式一开始用的空间很少，所以我们的数据也是弹性分配的。</li>
</ol>
<h3 id="Dense和Sparse结构"><a href="#Dense和Sparse结构" class="headerlink" title="Dense和Sparse结构"></a>Dense和Sparse结构</h3><p>Dense模式就是经典的HLL算法，其中<code>registers</code>大概占据了12KB的大小。容易看到，这个空间占用还是比较大的，考虑到这里面大多数都是0，所以Redis又使用了Sparse模式。<br>Sparse模式是创建时默认的，实际上不会占用12KB的大小，主要用来表达连续<strong>多个桶的值为0</strong>的情况，也就是用CPU换存储。它使用下面三种编码方式，<strong>称为opcode</strong>：</p>
<ol>
<li>XZERO：格式为<code>01xxxxxx yyyyyyyy</code><br> 这个能表示最多的0形态。初始化之后，因为一个数都没有加入HLL中，就使用XZERO，占用两个字节。<br> 前面的6个x叫Most Signigicent Bits(MSB)，后面8个y叫Least Significant Bits(LSB)。这14位组合起来可以表示16384个0，这也对应了后面提到的<code>HLL_SPARSE_XZERO_MAX_LEN</code>这个宏的取值，刚好等于<code>HLL_REGISTERS</code>的值。</li>
<li>ZERO：格式为<code>00xxxxxx</code><br> ZERO能表示的0比XZERO要少，但只占用一个字节，所以能表示较少的0。<br> 表示<code>xxxxxx</code>+1个0，所以实际上能够表示最多64个0。</li>
<li>VAL：格式为<code>1vvvvvxx</code><br> 当HLL开始进一步稠密时，就可能出现VAL这种情况。<br> 5个v表示重复的计数值。注意，如果vvvvv为0，说明计数值是1。如果我们需要表示0的情况，就直接用XZERO和ZERO了。<br> 2个x表示重复的桶的数量，也就是说有连续<code>xx+1</code>(&lt;4)个桶的值都是<code>vvvvv+1</code>(&lt;32)。</li>
<li>变换为Dense<br> 注意，当VAL也无法描述时，例如：<ul>
<li>某一段重复的桶的数量超过4了，那么就要变换为Dense。</li>
<li>出现超过32的值之后，就会切换为Dense模式。</li>
</ul>
</li>
</ol>
<h3 id="HLL的空间占用"><a href="#HLL的空间占用" class="headerlink" title="HLL的空间占用"></a>HLL的空间占用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hyperloglog.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P 14 <span class="comment">/* The greater is P, the smaller the error. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_Q (64-HLL_P)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_HDR_SIZE sizeof(struct hllhdr)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTERS (1&lt;&lt;HLL_P) <span class="comment">/* With P=14, 16384 registers. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_P_MASK (HLL_REGISTERS-1) <span class="comment">/* Mask to index register. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_BITS 6 <span class="comment">/* Enough to count up to 63 leading zeroes. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_REGISTER_MAX ((1&lt;&lt;HLL_BITS)-1)</span></span><br></pre></td></tr></table></figure>

<p>先说一下这几个常数：</p>
<ol>
<li><p><code>HLL_P</code><br> 桶的数量，默认值14。P越大，计算得越精确。</p>
</li>
<li><p><code>HLL_Q</code><br> 用来做伯努利过程的尾数。</p>
</li>
<li><p><code>HLL_REGISTERS</code>表示有多少个桶<br> 如果默认值14，则可以构成16384个桶(对应到hllhdr中的<code>registers</code>)。</p>
</li>
<li><p><code>HLL_P_MASK</code><br> 可以通过<code>&amp;</code>来取出实际桶的序号。<br> 所以Dense的实际排布是</p>
 <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| Q bits <span class="keyword">of</span> hash | P bits <span class="keyword">of</span> <span class="keyword">register</span> <span class="keyword">index</span> |</span><br></pre></td></tr></table></figure></li>
<li><p><code>HLL_BITS</code><br> 每个桶的大小，这里是6bit。为什么不是8bit，正好一个bytes呢？因为<code>2**6</code>是64，可以用来表示63个0了。<br> 不过我觉得最多只有50个0。首先，我们得到的是64位的哈希，然后其中有14位被用来分桶了，那剩下最多还能表示<code>64-P+1=51</code>位的count(参考“pfadd的Dense实现”的实验)，而这个是最少需要6个bit来表示的，所以这里用了6bit而不是8bit。不过这样会不会因为内存不对齐从而产生开销呢？<br> 当然，这里用6bit，实际上会给定位某个桶带来麻烦。可以查看<code>hllDenseGet</code>和<code>HLL_DENSE_GET_REGISTER</code>。<br> 另外，我们还可以计算得到，Dense情况下HLL的大小为<code>6bit*16384</code>=12KB。</p>
</li>
</ol>
<h2 id="createHLLObject实现"><a href="#createHLLObject实现" class="headerlink" title="createHLLObject实现"></a>createHLLObject实现</h2><p>由于创建的HLL结构中每个桶的值都是0，所以默认肯定是Sparse存储省空间。所以要手动构造一下Sparse结构。首先分配<code>sparselen</code>的空间，包括：</p>
<ol>
<li><code>HLL_HDR_SIZE</code>也就是HLL头部的大小</li>
<li>register的空间</li>
</ol>
<p>它的值是</p>
<p>$$<br>\frac{(HLL\_REGISTERS+(HLL\_SPARSE\_XZERO\_MAX\_LEN-1))}{HLL\_SPARSE\_XZERO\_MAX\_LEN} * 2<br>$$<br>这个公式看起来很奇怪，但是$\frac{X + (Y-1)}{Y}$实际上是向上取整的常规操作，所以说实际上要做的就是算出<br>$$<br>\lceil \frac{HLL\_REGISTERS}{HLL\_SPARSE\_XZERO\_MAX\_LEN} \rceil * 2<br>$$</p>
<p>所以这就好理解了，总共有多少个桶，然后除以每个XZERO opcode能放存多少个桶，最后乘以2，因为每个XZERO占用两个bytes，这就是要给这个Sparse结构分配多少内存。而一个<code>HLL_SPARSE_XZERO_MAX_LEN</code>能表示16384个桶，这在上文已经讲解过了，刚好等于<code>HLL_REGISTERS</code>的值，因此实际上一开始所有register用两个bytes就完全可以cover了。<br>做个实验，打印下来发现<code>sparselen</code>为18，<code>HLL_HDR_SIZE</code>是16，所以确实一开始register只用了两个字节。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createHLLObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">uint8_t</span> *p;</span><br><span class="line">    <span class="keyword">int</span> sparselen = HLL_HDR_SIZE +</span><br><span class="line">                    (((HLL_REGISTERS+(HLL_SPARSE_XZERO_MAX_LEN<span class="number">-1</span>)) /</span><br><span class="line">                     HLL_SPARSE_XZERO_MAX_LEN)*<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sparselen %d HLL_HDR_SIZE %d\n"</span>, sparselen, HLL_HDR_SIZE);</span><br><span class="line">    <span class="keyword">int</span> aux;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>分配完空间，下面就是要初始化，具体做法就是调用<code>HLL_SPARSE_XZERO_SET</code>每两个字节set一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Populate the sparse representation with as many XZERO opcodes as</span></span><br><span class="line"><span class="comment">     * needed to represent all the registers. */</span></span><br><span class="line">    aux = HLL_REGISTERS;</span><br><span class="line">    s = sdsnewlen(<span class="literal">NULL</span>,sparselen);</span><br><span class="line">    p = (<span class="keyword">uint8_t</span>*)s + HLL_HDR_SIZE;</span><br><span class="line">    <span class="keyword">while</span>(aux) &#123;</span><br><span class="line">        <span class="keyword">int</span> xzero = HLL_SPARSE_XZERO_MAX_LEN;</span><br><span class="line">        <span class="keyword">if</span> (xzero &gt; aux) xzero = aux;</span><br><span class="line">        HLL_SPARSE_XZERO_SET(p,xzero);</span><br><span class="line">        p += <span class="number">2</span>;</span><br><span class="line">        aux -= xzero;</span><br><span class="line">    &#125;</span><br><span class="line">    serverAssert((p-(<span class="keyword">uint8_t</span>*)s) == sparselen);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上HLL是一个String对象。Redis中的String是可以存储二进制序列的，而不局限于是字符串。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Create the actual object. */</span></span><br><span class="line">    o = createObject(OBJ_STRING,s);</span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    <span class="built_in">memcpy</span>(hdr-&gt;magic,<span class="string">"HYLL"</span>,<span class="number">4</span>);</span><br><span class="line">    hdr-&gt;encoding = HLL_SPARSE;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pfadd实现"><a href="#pfadd实现" class="headerlink" title="pfadd实现"></a>pfadd实现</h2><p>如果没有，就新创建一个HLL对象</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* PFADD var ele ele ele ... ele =&gt; :0 or :1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Create the key with a string value of the exact length to</span></span><br><span class="line"><span class="comment">         * hold our HLL data structure. sdsnewlen() when NULL is passed</span></span><br><span class="line"><span class="comment">         * is guaranteed to return bytes initialized to zero. */</span></span><br><span class="line">        o = createHLLObject();</span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">        updated++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>否则，调用<code>dbUnshareStringValue</code>确保对象<code>o</code>能够被原地进行修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>根据<code>dbUnshareStringValue</code>的注释，一个对象是可以被修改的，除非：</p>
<ol>
<li>它是被shared的，即refcount &gt; 1</li>
<li>它的encoding不是RAW</li>
</ol>
<p>如果有对象是满足上面两个条件的，那么会存入这个string对象的一个unshared/not-encoded的副本，否则直接返回这个对象<code>o</code>。我们可以查看下面的实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">dbUnshareStringValue</span><span class="params">(redisDb *db, robj *key, robj *o)</span> </span>&#123;</span><br><span class="line">    redisAssert(o-&gt;type == REDIS_STRING);</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount != <span class="number">1</span> || o-&gt;encoding != REDIS_ENCODING_RAW) &#123;</span><br><span class="line">        robj *decoded = getDecodedObject(o);</span><br><span class="line">        o = createRawStringObject(decoded-&gt;ptr, sdslen(decoded-&gt;ptr));</span><br><span class="line">        decrRefCount(decoded);</span><br><span class="line">        dbOverwrite(db,key,o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是对于所有要添加的项目调用<code>hllAdd</code>，这和前面的<code>zaddGenericCommand</code>等命令很相似。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Perform the low level ADD operation for every element. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> retval = hllAdd(o, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)c-&gt;argv[j]-&gt;ptr,</span><br><span class="line">                               sdslen(c-&gt;argv[j]-&gt;ptr));</span><br><span class="line">        <span class="keyword">switch</span>(retval) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            updated++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的话同样会调用<code>signalModifiedKey</code>和<code>notifyKeyspaceEvent</code>进行通知，参考之前的讲解。有趣的是这个<code>HLL_INVALIDATE_CACHE</code>，它涉及了cache的机制，我们将在稍后讲解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"pfadd"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">        HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    &#125;</span><br><span class="line">    addReply(c, updated ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的是主要的<code>hddAdd</code>实现，主要分为Dense和Sparse两种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span> = <span class="title">o</span>-&gt;<span class="title">ptr</span>;</span></span><br><span class="line">    <span class="keyword">switch</span>(hdr-&gt;encoding) &#123;</span><br><span class="line">    <span class="keyword">case</span> HLL_DENSE: <span class="keyword">return</span> hllDenseAdd(hdr-&gt;registers,ele,elesize);</span><br><span class="line">    <span class="keyword">case</span> HLL_SPARSE: <span class="keyword">return</span> hllSparseAdd(o,ele,elesize);</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid representation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pfadd的Dense实现"><a href="#pfadd的Dense实现" class="headerlink" title="pfadd的Dense实现"></a>pfadd的Dense实现</h2><h3 id="hllDenseAdd"><a href="#hllDenseAdd" class="headerlink" title="hllDenseAdd"></a>hllDenseAdd</h3><p><code>hllDenseAdd</code>函数主要在HLL结构中“插入”一个元素，事实上并没有什么元素被加上，只是说在需要的时候自增一下这个哈希值所属的max 0 pattern counter。<br>首先，通过<code>hllPatLen</code>计算<code>ele</code>的哈希，并从哈希值获得桶的序号<code>index</code>，并且把这个哈希值里面第一个1出现的位置<code>count</code>返回(具体含义见下面说明，这里难以理解的是到底从左边数还是从右边数。。。)。需要注意的是，我们并不需要实际的哈希值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseAdd</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllDenseSet(registers,index,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了更方便进行调试，我们将<code>createHLLObject</code>中新对象的创建默认改为<code>HLL_DENSE</code>，并加上一系列调试语句，来观察行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">format_binary</span><span class="params">(<span class="keyword">uint64_t</span> x, <span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x)&#123;</span><br><span class="line">        <span class="keyword">char</span> b = x % <span class="number">2</span>;</span><br><span class="line">        buf[i] = b + <span class="string">'0'</span>;</span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = i / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">        <span class="keyword">char</span> tmp = buf[j];</span><br><span class="line">        buf[j] = buf[i - <span class="number">1</span> - j];</span><br><span class="line">        buf[i - <span class="number">1</span> - j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    buf[i] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是单纯这样改会有问题，当第二次调用<code>pfadd</code>时会报错<code>WRONGTYPE Key is not a valid HyperLogLog string value</code>，原因是下面的语句检查不通过。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isHLLObjectOrReply</span><span class="params">(client *c, robj *o)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE &amp;&amp;</span><br><span class="line">        stringObjectLen(o) != HLL_DENSE_SIZE) <span class="keyword">goto</span> invalid;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>所以比较好的做法是在<code>createHLLObject</code>最后直接调用<code>hllSparseToDense(o)</code>，让它从Sparse转成Dense进行研究。</p>
<h3 id="hllPatLen"><a href="#hllPatLen" class="headerlink" title="hllPatLen"></a>hllPatLen</h3><p>查看<code>hllPatLen</code>的实现。首先，它基于<code>MurmurHash64A</code>算得哈希值<code>hash</code>，并且得到所在的桶(register)的编号<code>index</code>。容易知道，这个<code>index</code>的取值是在<code>[0, 2**HLL_P=16384)</code>之间的，这也对应了桶的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given a string element to add to the HyperLogLog, returns the length</span></span><br><span class="line"><span class="comment"> * of the pattern 000..1 of the element hash. As a side effect 'regp' is</span></span><br><span class="line"><span class="comment"> * set to the register index this element hashes to. */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllPatLen</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize, <span class="keyword">long</span> *regp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash, bit, index;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    hash = MurmurHash64A(ele,elesize,<span class="number">0xadc83b19</span>ULL);</span><br><span class="line">    index = hash &amp; HLL_P_MASK; <span class="comment">/* Register index. */</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line">    format_binary(hash, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Raw hash %s\n"</span>, s);</span><br></pre></td></tr></table></figure>

<p>接着，将表示桶的<code>P</code>位mask出为<code>index</code>，并开始对剩下的<code>64-HLL_P=50</code>位进行原始的HLL算法。<br>首先，将<code>hash</code>右移<code>HLL_P</code>位，去掉register index。然后将最高位设为1，这样的话返回值<code>count</code>最大为<code>Q+1</code>，也就是51。这样做的目的：</p>
<ol>
<li>顺应了前面提到的全是0的情况。</li>
<li>防止后面死循环。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    hash &gt;&gt;= HLL_P; <span class="comment">/* Remove bits used to address the register. */</span></span><br><span class="line">    format_binary(hash, s);</span><br><span class="line">    <span class="built_in">printf</span>( %llx %s\n<span class="string">", hash, s);</span></span><br><span class="line"><span class="string">    hash |= ((uint64_t)1&lt;&lt;HLL_Q); </span></span><br><span class="line"><span class="string">    format_binary(hash, s);</span></span><br><span class="line"><span class="string">    printf("</span>Q-<span class="built_in">set</span> hash %llx %s\n<span class="string">", hash, s);</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>从第<code>HLL_REGISTERS位</code>开始计算0的数量，也就是从低位往高位找，最多找到<code>64-P+1=Q+1</code>位。我们令bit为1，然后从右往左扫，直到看到第一个1为止。根据注释，是结尾的1也要被算在计数里面，例如”001”的count是3；count的最小值是1，此时没有前导0。<br>可以看出这里和HLL的原算法还是有点不同的，原算法是找leftmost 1，而现在的实现是找rightmost 1。这个循环看上去很没有效率，但在平均情况下在很少的迭代之后就能找到一个1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    bit = <span class="number">1</span>;</span><br><span class="line">    count = <span class="number">1</span>; <span class="comment">/* Initialized to 1 since we count the "00000...1" pattern. */</span></span><br><span class="line">    <span class="keyword">while</span>((hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">        format_binary(bit, s);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"while bit %s count %d\n"</span>, s, count);</span><br><span class="line">        count++;</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    format_binary(bit, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"while end bit %s count %d\n"</span>, s, count);</span><br><span class="line">    *regp = (<span class="keyword">int</span>) index;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p><code>pfadd p1 a</code>中添加了一个元素，返回count为2。实际输出1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Raw hash                     101001111010010010001110000101010011011010000111011000110100111</span><br><span class="line">P-shift hash 14f491c2a6d0e   1010011110100100100011100001010100110110100001110</span><br><span class="line">Q-set hash 54f491c2a6d0e   101010011110100100100011100001010100110110100001110</span><br><span class="line">while bit 1 count 1</span><br><span class="line">while end bit 10 count 2</span><br></pre></td></tr></table></figure>

<p>接着运行<code>pfadd p1 b c d e f h i0 i1 i2</code>，现在有10个元素，返回count为5。实际输出10。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Raw hash 110100001100001000111001011000101111000000001000000001111010000</span><br><span class="line">P-shift hash 1a18472c5e010 1101000011000010001110010110001011110000000010000</span><br><span class="line">Q-set hash 5a18472c5e010 101101000011000010001110010110001011110000000010000</span><br><span class="line">while bit 1 count 1</span><br><span class="line">while bit 10 count 2</span><br><span class="line">while bit 100 count 3</span><br><span class="line">while bit 1000 count 4</span><br><span class="line">while end bit 10000 count 5</span><br></pre></td></tr></table></figure>

<h3 id="hllDenseSet"><a href="#hllDenseSet" class="headerlink" title="hllDenseSet"></a>hllDenseSet</h3><p>下面再来看<code>hllDenseSet</code>的实现，它应该就是根据<code>hllPatLen</code>计算的结果更新对应桶的值了。<br><code>hllDenseSet</code>是一个一个底层的函数，用来设置Dense HLL register。将index处的值设为count，如果count比当前值大。<br>registers应该能够容纳HLL_REGISTERS+1的长度，这个是由sds的实现来保证的，因为sds字符串始终会在最后自动加上一个’\0’。<br>这个函数始终会成功，返回1表示发生了修改，否则返回0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllDenseSet</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount;</span><br><span class="line"></span><br><span class="line">    HLL_DENSE_GET_REGISTER(oldcount,registers,index);</span><br><span class="line">    <span class="keyword">if</span> (count &gt; oldcount) &#123;</span><br><span class="line">        HLL_DENSE_SET_REGISTER(registers,index,count);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>逻辑很简单，就是先把老的<code>oldcount</code>读出来，如果<code>count</code>比较大，那么就更新，比较麻烦的就是这两个宏。</p>
<p>首先是<code>HLL_BITS</code>，它的取值是6，为什么这么奇怪呢？先前说到这是出于压缩空间的考虑。所以<code>HLL_DENSE_GET_REGISTER</code>做的就是从数组<code>p</code>中找到第<code>regnum</code>个register(桶)。方案也很简单，可以算得这个桶在第几个byte。然后从这个byte开始读6个bit，其中可能还会读到后一个byte上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Store the value of the register at position 'regnum' into variable 'target'.</span></span><br><span class="line"><span class="comment"> * 'p' is an array of unsigned bytes. */</span></span><br><span class="line"><span class="comment">// do...while(0)是Linux中常见的保护宏的机制</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_DENSE_GET_REGISTER(target,p,regnum) do &#123; \</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *_p = (<span class="keyword">uint8_t</span>*) p; \</span><br><span class="line">    <span class="comment">// 获得当前桶所在的起始byte</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _byte = regnum*HLL_BITS/<span class="number">8</span>; \</span><br><span class="line">    <span class="comment">// 获得当前桶所在的起始byte的偏移</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb = regnum*HLL_BITS&amp;<span class="number">7</span>; \</span><br><span class="line">    <span class="comment">// 还有_fb8个bit在下一个byte上</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> _fb8 = <span class="number">8</span> - _fb; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b0 = _p[_byte]; \</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> b1 = _p[_byte+<span class="number">1</span>]; \</span><br><span class="line">    <span class="comment">// 拼起来</span></span><br><span class="line">    target = ((b0 &gt;&gt; _fb) | (b1 &lt;&lt; _fb8)) &amp; HLL_REGISTER_MAX; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="pfadd的Sparse实现"><a href="#pfadd的Sparse实现" class="headerlink" title="pfadd的Sparse实现"></a>pfadd的Sparse实现</h2><h3 id="几个宏"><a href="#几个宏" class="headerlink" title="几个宏"></a>几个宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xzero类型前缀 01xxxxxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_BIT 0x40</span></span><br><span class="line"><span class="comment">// val类型前缀 1vvvvvxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_BIT 0x80</span></span><br></pre></td></tr></table></figure>

<p>下面的三个宏用来判断类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0xc0=0x11000000 判断是否是zero类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_ZERO(p) (((*(p)) &amp; 0xc0) == 0) </span></span><br><span class="line"><span class="comment">// 判断是否是xzero类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_XZERO(p) (((*(p)) &amp; 0xc0) == HLL_SPARSE_XZERO_BIT)</span></span><br><span class="line"><span class="comment">// 判断是否是val类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_IS_VAL(p) ((*(p)) &amp; HLL_SPARSE_VAL_BIT)</span></span><br></pre></td></tr></table></figure>

<p>下面的几个宏，对于XZERO和ZERO，是取出它表示有多少个0；对于VAL，还需要获得VAL的值，以及对应VAL的个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 00xxxxxx &amp; 0x00111111 获得后6位的值，即zero的长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_LEN(p) (((*(p)) &amp; 0x3f)+1)</span></span><br><span class="line"><span class="comment">// 01xxxxxx yyyyyyy 计算xzero长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_LEN(p) (((((*(p)) &amp; 0x3f) &lt;&lt; 8) | (*((p)+1)))+1)</span></span><br><span class="line"><span class="comment">// 001vvvvv &amp; 值0x00011111 获得中间5位的值，即val的值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_VALUE(p) ((((*(p)) &gt;&gt; 2) &amp; 0x1f)+1)</span></span><br><span class="line"><span class="comment">// 获得后两位的值, 即长度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_LEN(p) (((*(p)) &amp; 0x3)+1)</span></span><br></pre></td></tr></table></figure>

<p>下面的几个宏给出每个op对应的数值范围，为什么取这些值之前已经介绍过了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spase值5bit最大32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_VALUE 32</span></span><br><span class="line"><span class="comment">// 长度2bit 最大4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_MAX_LEN 4</span></span><br><span class="line"><span class="comment">// zero类型6位表示长度, 64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_ZERO_MAX_LEN 64</span></span><br><span class="line"><span class="comment">// xzero类型14bit, 最大16384</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_XZERO_MAX_LEN 16384</span></span><br></pre></td></tr></table></figure>

<p>下面几个宏是用来写入VAL、ZERO和XZERO的</p>
<ol>
<li><code>HLL_SPARSE_VAL_SET</code><br> 这是通过移位进行拼装。<br> 为什么是<code>(val)-1</code>而不是<code>val</code>呢，回想之前说过VAL为0的时候表示VAL为1而不是0，有0个的情况直接用ZERO和XZERO表示。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_SPARSE_VAL_SET(p,val,len) do &#123; \</span></span><br><span class="line">    *(p) = (((val)<span class="number">-1</span>)&lt;&lt;<span class="number">2</span>|((len)<span class="number">-1</span>))|HLL_SPARSE_VAL_BIT; \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="hllSparseAdd"><a href="#hllSparseAdd" class="headerlink" title="hllSparseAdd"></a>hllSparseAdd</h3><p><code>hllSparseAdd</code>的实现还是需要先通过<code>hllPatLen</code>来获得<code>count</code>和<code>index</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseAdd</span><span class="params">(robj *o, <span class="keyword">unsigned</span> <span class="keyword">char</span> *ele, <span class="keyword">size_t</span> elesize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> index;</span><br><span class="line">    <span class="keyword">uint8_t</span> count = hllPatLen(ele,elesize,&amp;index);</span><br><span class="line">    <span class="comment">/* Update the register if this element produced a longer run of zeroes. */</span></span><br><span class="line">    <span class="keyword">return</span> hllSparseSet(o,index,count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hllSparseSet"><a href="#hllSparseSet" class="headerlink" title="hllSparseSet"></a>hllSparseSet</h3><p><code>hllSparseSet</code>是一个贼复杂的函数，作用是将第<code>index</code>个register的值设置为不小于<code>count</code>。参数<code>o</code>是用来存储HLL的String对象，这个函数需要一个可变引用(指针)，从而在需要的时候扩容。</p>
<p>返回值：</p>
<ol>
<li>当集合的cardinality发生变化后，函数返回1。</li>
<li>返回0，表示没有实际更新。</li>
<li>返回-1表示错误。</li>
</ol>
<p>另外一个副作用是使得HLL从Sparse表示变为Dense表示，这个通常发生在某个值不能通过Sparse格式表示了(参考之前对VAL表示方法的论述)，或者结果集的大小超过了<code>server.hll_sparse_max_bytes</code>。<br>不过，在<code>createHLLObject</code>创建HLL时，却不会判断<code>server.hll_sparse_max_bytes</code>为0的时候就直接Dense，此外，还有个<code>HLL_SPARSE_VAL_MAX_VALUE</code>阈值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hllSparseSet</span><span class="params">(robj *o, <span class="keyword">long</span> index, <span class="keyword">uint8_t</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> oldcount, *sparse, *end, *p, *prev, *next;</span><br><span class="line">    <span class="keyword">long</span> first, span;</span><br><span class="line">    <span class="keyword">long</span> is_zero = <span class="number">0</span>, is_xzero = <span class="number">0</span>, is_val = <span class="number">0</span>, runlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果count大于32，直接走promote流程到Dense</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; HLL_SPARSE_VAL_MAX_VALUE) <span class="keyword">goto</span> promote;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>后面讲到，我们先得在这里为最差情况(XZERO变为XZERO-VAL-XZERO)额外分配3个字节。这个必须要现在做，因为<code>sdsMakeRoomFor</code>可能<code>realloc</code>，也可能<code>malloc</code>，但这两种都不保证返回的ptr不会变化。而我们希望以后的<code>o-&gt;ptr</code>能够是不变的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    o-&gt;ptr = sdsMakeRoomFor(o-&gt;ptr,<span class="number">3</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是第一步，先定位到sparse的头<code>sparse</code>，也就是<code>registers</code>数组，和尾<code>end</code>。目的是定位到需要修改的<code>opcode</code>，从而检查是否真的要修改。<br>下面这个大循环，主要就是从头遍历，先通过<code>HLL_SPARSE_IS_</code>宏判断是具体哪种op类型，然后前进对应的<code>oplen</code>和<code>span</code>。<br>在上面的while循环结束后，我们维护了下面几个性质：</p>
<ol>
<li><code>first</code>储存了当前的opcode所覆盖的第一个<code>register</code>，<strong>注意这里的<code>register</code>对应了Dense里面桶的概念，而不是表示一个<code>uint8_t</code></strong></li>
<li><code>next</code>和<code>prev</code>分别存储了后一个和前一个opcode，如果不存在前驱后继，对应值是NULL</li>
<li><code>span</code>表示当前opcode覆盖了多少个register，也就是跨过了多少个相同的数字</li>
<li><code>oplen</code>表示这个op实际长度是多少个byte，根据前面对ZERO、XZERO和VAL的定义，其实取值只会在1和2</li>
<li><code>p</code>指向了当前的opcode</li>
<li><code>index</code>表示要哈希到哪个桶里面</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    sparse = p = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr) + HLL_HDR_SIZE;</span><br><span class="line">    end = p + sdslen(o-&gt;ptr) - HLL_HDR_SIZE;</span><br><span class="line"></span><br><span class="line">    first = <span class="number">0</span>;</span><br><span class="line">    prev = <span class="literal">NULL</span>; <span class="comment">/* Points to previous opcode at the end of the loop. */</span></span><br><span class="line">    next = <span class="literal">NULL</span>; <span class="comment">/* Points to the next opcode at the end of the loop. */</span></span><br><span class="line">    span = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &lt; end) &#123;</span><br><span class="line">        <span class="keyword">long</span> oplen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set span to the number of registers covered by this opcode. */</span></span><br><span class="line">        <span class="comment">// 这个循环是最performance critical的。所以需要从最可能被处理的情况开始(ZERO)处理。</span></span><br><span class="line">        <span class="comment">// 最少见的情况(XZERO)放到最后。</span></span><br><span class="line">        oplen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_VAL(p)) &#123;</span><br><span class="line">            span = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* XZERO. */</span></span><br><span class="line">            span = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">            oplen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果这个opcode覆盖了要访问的register，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= first+span<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        prev = p;</span><br><span class="line">        p += oplen;</span><br><span class="line">        first += span;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (span == <span class="number">0</span> || p &gt;= end) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Invalid format. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>现在，我们找到了包含<code>index</code>的那个op了，判断这个op的类型，并且计算<code>runlen</code>。也就是这个opcode表示有多少个0或者VAL，对应的诸如<code>HLL_SPARSE_ZERO_LEN</code>宏之前也讲过了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    next = HLL_SPARSE_IS_XZERO(p) ? p+<span class="number">2</span> : p+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (next &gt;= end) next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cache current opcode type to avoid using the macro again and</span></span><br><span class="line"><span class="comment">     * again for something that will not change.</span></span><br><span class="line"><span class="comment">     * Also cache the run-length of the opcode. */</span></span><br><span class="line">    <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">        is_zero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_ZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">        is_xzero = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_XZERO_LEN(p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        is_val = <span class="number">1</span>;</span><br><span class="line">        runlen = HLL_SPARSE_VAL_LEN(p);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在得到类型后，我们需要进行分类讨论。</p>
<p>首先是<strong>VAL</strong>的两种平凡情况，尝试进行原地修改。</p>
<ol>
<li>如果这个VAL opcode所表示的<code>count</code>大于现在这个哈希产生的<code>count</code>，那么实际上并不需要进行更新<br> 在这种情况下PFADD会返回0，因为没有发生任何更新。</li>
<li>特例。如果这个VAL opcode仅仅就覆盖了一个register，那么就仅<strong>直接进行更新</strong><br> 我们稍后会去具体查看<code>updated</code>的具体实现。<br> 相对的不平凡的情况就是这个VAL opcode覆盖了多个register，也就是有相邻的多个桶都是这个<code>count</code>，可想而知，需要把这个register切出来单独做一个VAL opcode，实现稍后分析。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (is_val) &#123;</span><br><span class="line">        oldcount = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">        <span class="comment">/* Case A. */</span></span><br><span class="line">        <span class="keyword">if</span> (oldcount &gt;= count) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Case B. */</span></span><br><span class="line">        <span class="keyword">if</span> (runlen == <span class="number">1</span>) &#123;</span><br><span class="line">            HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> updated;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>然后是<strong>数量为1的ZERO</strong>平凡情况。如果是0，并且只覆盖了一个register，同样<strong>直接进行更新</strong>。注意这里对这个函数的调用是<code>HLL_SPARSE_VAL_SET(p,count,1)</code>。<code>count</code>被传给了形参<code>val</code>，而不是语义上更接近的<code>len</code>。这表示在<code>p</code>处有连续<code>1</code>个桶，它的值为<code>count</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* C) Another trivial to handle case is a ZERO opcode with a len of 1.</span></span><br><span class="line"><span class="comment">     * We can just replace it with a VAL opcode with our value and len of 1. */</span></span><br><span class="line">    <span class="keyword">if</span> (is_zero &amp;&amp; runlen == <span class="number">1</span>) &#123;</span><br><span class="line">        HLL_SPARSE_VAL_SET(p,count,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">goto</span> updated;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是较为复杂的普通情况。opcode要不是VAL，要不是len大于1的ZERO，要不就是XZERO。<br>这些情况特殊在需要<strong>将原来的opcode拆分为多个opcode</strong>。其中最坏情况要把XZERO拆分成XZERO-VAL-XZERO的结构，也就是在原来的XZERO范围中有一个register被hit了。这个变化会占用5个字节，比原来多3个，也就是我们前面提前分配3个字节的原因。【Q】如果最后发现这3个字节不需要的话，会回收么？如果不会回收的话，每次访问这个opcode，会不会导致每次都会尝试多分配3个？其实<code>sdsMakeRoomFor</code>是对当前实际使用的长度<code>len</code>而言的，而不是每次都增加capacity。</p>
<p>下面就是先将新序列写到<code>n</code>里面，然后将<code>n</code>原地插入到旧数组中。创建一个长度为5的buf即<code>seq</code>，保证不会溢出。<br>首先处理ZERO和XZERO这块，这个处理主要就是将它分为Z-VAL-Z的序列，其中Z可能是ZERO可能是XZERO。具体查看代码中的注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">uint8_t</span> seq[<span class="number">5</span>], *n = seq;</span><br><span class="line">    <span class="keyword">int</span> last = first+span<span class="number">-1</span>; <span class="comment">/* Last register covered by the sequence. */</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_zero || is_xzero) &#123;</span><br><span class="line">        <span class="comment">/* Handle splitting of ZERO / XZERO. */</span></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            <span class="comment">// 在index前面有len个桶</span></span><br><span class="line">            len = index-first;</span><br><span class="line">            <span class="comment">// 如果这么多个桶不能用ZERO放下，</span></span><br><span class="line">            <span class="comment">// 就用XZERO放</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置count</span></span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="comment">// 同样的办法处理尾部</span></span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            <span class="keyword">if</span> (len &gt; HLL_SPARSE_ZERO_MAX_LEN) &#123;</span><br><span class="line">                HLL_SPARSE_XZERO_SET(n,len);</span><br><span class="line">                n += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HLL_SPARSE_ZERO_SET(n,len);</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是分割VAL的情况。我们也是在<code>n</code>上面进行修改。把除自己之外的设为<code>curval</code>，自己设置为<code>count</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Handle splitting of VAL. */</span></span><br><span class="line">        <span class="keyword">int</span> curval = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != first) &#123;</span><br><span class="line">            len = index-first;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">        HLL_SPARSE_VAL_SET(n,count,<span class="number">1</span>);</span><br><span class="line">        n++;</span><br><span class="line">        <span class="keyword">if</span> (index != last) &#123;</span><br><span class="line">            len = last-index;</span><br><span class="line">            HLL_SPARSE_VAL_SET(n,curval,len);</span><br><span class="line">            n++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面将<code>n</code>插入到老序列里面，其实就是一个<code>memmove</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Step 3: substitute the new sequence with the old one.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we already allocated space on the sds string</span></span><br><span class="line"><span class="comment">     * calling sdsMakeRoomFor(). */</span></span><br><span class="line">     <span class="keyword">int</span> seqlen = n-seq;</span><br><span class="line">     <span class="keyword">int</span> oldlen = is_xzero ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> deltalen = seqlen-oldlen;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (deltalen &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         sdslen(o-&gt;ptr)+deltalen &gt; server.hll_sparse_max_bytes) <span class="keyword">goto</span> promote;</span><br><span class="line">     <span class="keyword">if</span> (deltalen &amp;&amp; next) memmove(next+deltalen,next,end-next);</span><br><span class="line">     sdsIncrLen(o-&gt;ptr,deltalen);</span><br><span class="line">     <span class="built_in">memcpy</span>(p,seq,seqlen);</span><br><span class="line">     end += deltalen;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面，来看<code>updated</code>的实现，这一块代码，主要是从处理VAL和ZERO的两个goto过来，以及通常情况的顺序执行过来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">updated:</span><br><span class="line">    <span class="comment">/* Step 4: Merge adjacent values if possible.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The representation was updated, however the resulting representation</span></span><br><span class="line"><span class="comment">     * may not be optimal: adjacent VAL opcodes can sometimes be merged into</span></span><br><span class="line"><span class="comment">     * a single one. */</span></span><br><span class="line">    p = prev ? prev : sparse;</span><br><span class="line">    <span class="keyword">int</span> scanlen = <span class="number">5</span>; <span class="comment">/* Scan up to 5 upcodes starting from prev. */</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; end &amp;&amp; scanlen--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HLL_SPARSE_IS_XZERO(p)) &#123;</span><br><span class="line">            p += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (HLL_SPARSE_IS_ZERO(p)) &#123;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* We need two adjacent VAL opcodes to try a merge, having</span></span><br><span class="line"><span class="comment">         * the same value, and a len that fits the VAL opcode max len. */</span></span><br><span class="line">        <span class="keyword">if</span> (p+<span class="number">1</span> &lt; end &amp;&amp; HLL_SPARSE_IS_VAL(p+<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">int</span> v1 = HLL_SPARSE_VAL_VALUE(p);</span><br><span class="line">            <span class="keyword">int</span> v2 = HLL_SPARSE_VAL_VALUE(p+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2) &#123;</span><br><span class="line">                <span class="keyword">int</span> len = HLL_SPARSE_VAL_LEN(p)+HLL_SPARSE_VAL_LEN(p+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (len &lt;= HLL_SPARSE_VAL_MAX_LEN) &#123;</span><br><span class="line">                    HLL_SPARSE_VAL_SET(p+<span class="number">1</span>,v1,len);</span><br><span class="line">                    memmove(p,p+<span class="number">1</span>,end-p);</span><br><span class="line">                    sdsIncrLen(o-&gt;ptr,<span class="number">-1</span>);</span><br><span class="line">                    end--;</span><br><span class="line">                    <span class="comment">/* After a merge we reiterate without incrementing 'p'</span></span><br><span class="line"><span class="comment">                     * in order to try to merge the just merged value with</span></span><br><span class="line"><span class="comment">                     * a value on its right. */</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invalidate the cached cardinality. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line">    HLL_INVALIDATE_CACHE(hdr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是promote流程，是比较直截了当的，也就是先<code>hllSparseToDense</code>转换到Dense，然后调用<code>hllDenseSet</code>。注意这也反过来意味着<code>PFADD</code>命令需要保证被广播到slaves和AOF中，从而保证slaves中也进行这个转换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">promote: <span class="comment">/* Promote to dense representation. */</span></span><br><span class="line">    <span class="keyword">if</span> (hllSparseToDense(o) == C_ERR) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">/* Corrupted HLL. */</span></span><br><span class="line">    hdr = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to call hllDenseAdd() to perform the operation after the</span></span><br><span class="line"><span class="comment">     * conversion. However the result must be 1, since if we need to</span></span><br><span class="line"><span class="comment">     * convert from sparse to dense a register requires to be updated.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> dense_retval = hllDenseSet(hdr-&gt;registers,index,count);</span><br><span class="line">    serverAssert(dense_retval == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dense_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="pfcount实现"><a href="#pfcount实现" class="headerlink" title="pfcount实现"></a>pfcount实现</h2><h3 id="pfcountCommand函数"><a href="#pfcountCommand函数" class="headerlink" title="pfcountCommand函数"></a>pfcountCommand函数</h3><p>照例是<code>pfcountCommand</code>作为入口。<br>首先是处理<code>PFCOUNT</code>给出多个key的情况，此时会返回将这些HLL做union之后的近似cardinality。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PFCOUNT var -&gt; approximated cardinality of set. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pfcountCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hllhdr</span> *<span class="title">hdr</span>;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> card;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Case 1: multi-key keys, cardinality of the union.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When multiple keys are specified, PFCOUNT actually computes</span></span><br><span class="line"><span class="comment">     * the cardinality of the merge of the N HLLs specified. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">uint8_t</span> max[HLL_HDR_SIZE+HLL_REGISTERS], *registers;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compute an HLL with M[i] = MAX(M[i]_j). */</span></span><br><span class="line">        <span class="built_in">memset</span>(max,<span class="number">0</span>,<span class="keyword">sizeof</span>(max));</span><br><span class="line">        hdr = (struct hllhdr*) max;</span><br><span class="line">        hdr-&gt;encoding = HLL_RAW; <span class="comment">/* Special internal-only encoding. */</span></span><br><span class="line">        registers = max + HLL_HDR_SIZE;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">            <span class="comment">/* Check type and size. */</span></span><br><span class="line">            robj *o = lookupKeyRead(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="literal">NULL</span>) <span class="keyword">continue</span>; <span class="comment">/* Assume empty HLL for non existing var.*/</span></span><br><span class="line">            <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Merge with this HLL with our 'max' HLL by setting max[i]</span></span><br><span class="line"><span class="comment">             * to MAX(max[i],hll[i]). */</span></span><br><span class="line">            <span class="keyword">if</span> (hllMerge(registers,o) == C_ERR) &#123;</span><br><span class="line">                addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Compute cardinality of the resulting set. */</span></span><br><span class="line">        addReplyLongLong(c,hllCount(hdr,<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的情况是处理一个HLL的cardinality。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Case 2: cardinality of the single HLL.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The user specified a single key. Either return the cached value</span></span><br><span class="line"><span class="comment">     * or compute one and update the cache. */</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* No key? Cardinality is zero since no element was added, otherwise</span></span><br><span class="line"><span class="comment">         * we would have a key as HLLADD creates it as a side effect. */</span></span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isHLLObjectOrReply(c,o) != C_OK) <span class="keyword">return</span>;</span><br><span class="line">        o = dbUnshareStringValue(c-&gt;db,c-&gt;argv[<span class="number">1</span>],o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the cached cardinality is valid. */</span></span><br><span class="line">        hdr = o-&gt;ptr;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>假如可以使用cache，那么就直接使用cache去组装<code>card</code>。可以看出低字节在数组的低index中，所以是按照小端存储的。【Q】为啥不直接放一个<code>uint64_t</code>，而是要自己用<code>uint8_t</code>去维护一下？难道仅仅是为了在高位留一个字节表示是否是valid的？那其实可以用位域来实现啊？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (HLL_VALID_CACHE(hdr)) &#123;</span><br><span class="line">            <span class="comment">/* Just return the cached value. */</span></span><br><span class="line">            card = (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">0</span>];</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">4</span>] &lt;&lt; <span class="number">32</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">5</span>] &lt;&lt; <span class="number">40</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">6</span>] &lt;&lt; <span class="number">48</span>;</span><br><span class="line">            card |= (<span class="keyword">uint64_t</span>)hdr-&gt;card[<span class="number">7</span>] &lt;&lt; <span class="number">56</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>假如cache是无效的，那么会实际调用<code>hllCount</code>。<code>hllCount</code>有个<code>invalid</code>参数，表示这个HLL的结构是有问题的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">int</span> invalid = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* Recompute it and update the cached value. */</span></span><br><span class="line">            card = hllCount(hdr,&amp;invalid);</span><br><span class="line">            <span class="keyword">if</span> (invalid) &#123;</span><br><span class="line">                addReplySds(c,sdsnew(invalid_hll_err));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hdr-&gt;card[<span class="number">0</span>] = card &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">1</span>] = (card &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">2</span>] = (card &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">3</span>] = (card &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">4</span>] = (card &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">5</span>] = (card &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">6</span>] = (card &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            hdr-&gt;card[<span class="number">7</span>] = (card &gt;&gt; <span class="number">56</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在下面，同样需要调用<code>signalModifiedKey</code>。这是因为虽然<code>PFCOUNT</code>不会修改实际的存储，但是它可能会修改cache值。考虑到HLL实际上是作为String来存储的，所以我们需要广播这个变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">        addReplyLongLong(c,card);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="cache实现"><a href="#cache实现" class="headerlink" title="cache实现"></a>cache实现</h3><p>在先前可以看到，HLL结构有个<code>card[8]</code>字段用来缓存cardinality。这个<code>card</code>会在<code>PFCOUNT</code>被访问到。此外，在<code>PFADD</code>和<code>PFMERGE</code>操作中，会调用<code>HLL_INVALIDATE_CACHE</code>使得缓存失效。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_INVALIDATE_CACHE(hdr) (hdr)-&gt;card[7] |= (1&lt;&lt;7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HLL_VALID_CACHE(hdr) (((hdr)-&gt;card[7] &amp; (1&lt;&lt;7)) == 0)</span></span><br></pre></td></tr></table></figure>

<h3 id="hllCount函数"><a href="#hllCount函数" class="headerlink" title="hllCount函数"></a>hllCount函数</h3><p>返回估计的cardinality，基于register数组的调和平均数。<code>hdr</code>指向持有这个HLL的SDS的开始位置。如果HLL的Sparse疏表示形式是不合法的，则设置<code>invalid</code>为0，否则不设置这个值。<br><code>hllCount</code>支持一种特殊的内部编码<code>HLL_RAW</code>，也就是<code>hdr-&gt;registers</code>会指向一个长度<code>HLL_REGISTERS</code>的<code>uint8_t</code>数组。这个有助于加速对多个键调用<code>PFCOUNT</code>，因为我们不需要处理6bit的整数了，所以实际上这是一个空间换时间的方案。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> hllCount(struct hllhdr *hdr, <span class="keyword">int</span> *invalid) &#123;</span><br><span class="line">    <span class="keyword">double</span> m = HLL_REGISTERS;</span><br><span class="line">    <span class="keyword">double</span> E;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面计算每个register的直方图。注意到直方图数组<code>reghisto</code>的长度最多是<code>HLL_Q+2</code>，因为<code>HLL_Q+1</code>是哈希函数对<code>&quot;000...1&quot;</code>这样序列所能返回的最大的frequency。当然，很难检查输入的合法性，所以不如分配<code>reghisto</code>就直接大一点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> reghisto[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute register histogram */</span></span><br><span class="line">    <span class="keyword">if</span> (hdr-&gt;encoding == HLL_DENSE) &#123;</span><br><span class="line">        hllDenseRegHisto(hdr-&gt;registers,reghisto);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是<code>HLL_RAW</code>这个特殊的encoding。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;encoding == HLL_RAW) &#123;</span><br><span class="line">        hllRawRegHisto(hdr-&gt;registers,reghisto);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown HyperLogLog encoding in hllCount()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    naiveHllCount(reghisto);</span><br><span class="line"><span class="comment">// 后续是统计reghisto</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个操作之后，我们得到了直方图<code>reghisto[reg]</code>，表示在所有<code>HLL_REGISTERS</code>个桶中，count为reg的桶的数量，而这个count表示第一个1出现的位置。即之前的<code>while end bit 10000 count 5</code>这样的内容。<br>下面就是根据直方图来计算估计的数量。我们设计了一个很naive的<code>naiveHllCount</code>，即基于调和平均数的多桶的实现方案，而这里用了一篇很屌的论文里面的一个很屌的做法。</p>
<h4 id="一个naive的count函数"><a href="#一个naive的count函数" class="headerlink" title="一个naive的count函数"></a>一个naive的count函数</h4><p>下面我们根据自己的理解实现一个count函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">naiveHllCount</span><span class="params">(<span class="keyword">int</span> * reghisto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> s = <span class="number">0.0</span>; <span class="comment">// sum</span></span><br><span class="line">    <span class="keyword">double</span> c = <span class="number">0</span>; <span class="comment">// count</span></span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否用调和平均</span></span><br><span class="line">    <span class="keyword">bool</span> useHarm = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt; <span class="number">64</span>; v++)&#123;</span><br><span class="line">        <span class="keyword">double</span> bucketCount = <span class="number">1.0</span> / <span class="built_in">pow</span>(<span class="number">2.0</span>, -(v<span class="number">-1</span>));</span><br><span class="line">        <span class="comment">// How many buckets has count of v?</span></span><br><span class="line">        <span class="keyword">int</span> countOfV = reghisto[v];</span><br><span class="line">        <span class="keyword">if</span>(useHarm)&#123;</span><br><span class="line">            <span class="keyword">double</span> delta = countOfV * <span class="number">1.0</span> / bucketCount;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"v %d countofV %d bucketCount %f delta %f \n"</span>, v, countOfV, bucketCount, delta);</span><br><span class="line">            s += delta;</span><br><span class="line">            c += countOfV;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">double</span> delta = countOfV * bucketCount;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"v %d countofV %d bucketCount %f delta %f \n"</span>, v, countOfV, bucketCount, delta);</span><br><span class="line">            s += delta;</span><br><span class="line">            c += countOfV;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(useHarm)&#123;</span><br><span class="line">        res = c / s * c;</span><br><span class="line">        <span class="comment">// res = c / s * c * 0.709;</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum %f, c %f, res %f\n"</span>, s, c, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际运行下来，对于<code>pfadd p1 a</code>的结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">v 37 countofV 0 bucketCount 68719476736.000000 delta 0.000000</span><br><span class="line">v 38 countofV 0 bucketCount 137438953472.000000 delta 0.000000</span><br><span class="line">v 39 countofV 0 bucketCount 274877906944.000000 delta 0.000000</span><br><span class="line">v 40 countofV 0 bucketCount 549755813888.000000 delta 0.000000</span><br><span class="line">v 41 countofV 0 bucketCount 1099511627776.000000 delta 0.000000</span><br><span class="line">v 42 countofV 0 bucketCount 2199023255552.000000 delta 0.000000</span><br><span class="line">v 43 countofV 0 bucketCount 4398046511104.000000 delta 0.000000</span><br><span class="line">v 44 countofV 0 bucketCount 8796093022208.000000 delta 0.000000</span><br><span class="line">v 45 countofV 0 bucketCount 17592186044416.000000 delta 0.000000</span><br><span class="line">v 46 countofV 0 bucketCount 35184372088832.000000 delta 0.000000</span><br><span class="line">v 47 countofV 0 bucketCount 70368744177664.000000 delta 0.000000</span><br><span class="line">v 48 countofV 0 bucketCount 140737488355328.000000 delta 0.000000</span><br><span class="line">v 49 countofV 0 bucketCount 281474976710656.000000 delta 0.000000</span><br><span class="line">v 50 countofV 0 bucketCount 562949953421312.000000 delta 0.000000</span><br><span class="line">v 51 countofV 0 bucketCount 1125899906842624.000000 delta 0.000000</span><br><span class="line">v 52 countofV 0 bucketCount 2251799813685248.000000 delta 0.000000</span><br><span class="line">v 53 countofV 0 bucketCount 4503599627370496.000000 delta 0.000000</span><br><span class="line">v 54 countofV 0 bucketCount 9007199254740992.000000 delta 0.000000</span><br><span class="line">v 55 countofV 0 bucketCount 18014398509481984.000000 delta 0.000000</span><br><span class="line">v 56 countofV 0 bucketCount 36028797018963968.000000 delta 0.000000</span><br><span class="line">v 57 countofV 0 bucketCount 72057594037927936.000000 delta 0.000000</span><br><span class="line">v 58 countofV 0 bucketCount 144115188075855872.000000 delta 0.000000</span><br><span class="line">v 59 countofV 0 bucketCount 288230376151711744.000000 delta 0.000000</span><br><span class="line">v 60 countofV 0 bucketCount 576460752303423488.000000 delta 0.000000</span><br><span class="line">v 61 countofV 0 bucketCount 1152921504606846976.000000 delta 0.000000</span><br><span class="line">v 62 countofV 0 bucketCount 2305843009213693952.000000 delta 0.000000</span><br><span class="line">v 63 countofV 0 bucketCount 4611686018427387904.000000 delta 0.000000</span><br><span class="line">sum 0.500000, c 1.000000, res 2.000000</span><br><span class="line">Actual 1073741824</span><br></pre></td></tr></table></figure>

<h5 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h5><p>有个修正来自于<a href="https://zhuanlan.zhihu.com/p/58519480" target="_blank" rel="noopener">论文中，知乎给出了解释</a>。参考</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (p) &#123;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">       constant = <span class="number">0.673</span> * m * m;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">       constant = <span class="number">0.697</span> * m * m;</span><br><span class="line">   <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">       constant = <span class="number">0.709</span> * m * m;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">       constant = (<span class="number">0.7213</span> / (<span class="number">1</span> + <span class="number">1.079</span> / m)) * m * m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="牛逼做法"><a href="#牛逼做法" class="headerlink" title="牛逼做法"></a>牛逼做法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续hllCount</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Estimate cardinality form register histogram. See:</span></span><br><span class="line"><span class="comment">     * "New cardinality estimation algorithms for HyperLogLog sketches"</span></span><br><span class="line"><span class="comment">     * Otmar Ertl, arXiv:1702.01284 */</span></span><br><span class="line">    <span class="keyword">double</span> z = m * hllTau((m-reghisto[HLL_Q+<span class="number">1</span>])/(<span class="keyword">double</span>)m);</span><br><span class="line">    <span class="keyword">for</span> (j = HLL_Q; j &gt;= <span class="number">1</span>; --j) &#123;</span><br><span class="line">        z += reghisto[j];</span><br><span class="line">        z *= <span class="number">0.5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    z += m * hllSigma(reghisto[<span class="number">0</span>]/(<span class="keyword">double</span>)m);</span><br><span class="line">    <span class="comment">// #define HLL_ALPHA_INF 0.721347520444481703680 /* constant for 0.5/ln(2) */</span></span><br><span class="line">    E = llroundl(HLL_ALPHA_INF*m*m/z);</span><br><span class="line">    <span class="comment">// 注意这里要转换一下，不然结果不对</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Actual %llu\n"</span>, (<span class="keyword">uint64_t</span>) E);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">uint64_t</span>) E;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// New cardinality estimation algorithms for HyperLogLog sketches</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hllTau</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0.</span> || x == <span class="number">1.</span>) <span class="keyword">return</span> <span class="number">0.</span>;</span><br><span class="line">    <span class="keyword">double</span> zPrime;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> z = <span class="number">1</span> - x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x = <span class="built_in">sqrt</span>(x);</span><br><span class="line">        zPrime = z;</span><br><span class="line">        y *= <span class="number">0.5</span>;</span><br><span class="line">        z -= <span class="built_in">pow</span>(<span class="number">1</span> - x, <span class="number">2</span>)*y;</span><br><span class="line">    &#125; <span class="keyword">while</span>(zPrime != z);</span><br><span class="line">    <span class="keyword">return</span> z / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">hllSigma</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1.</span>) <span class="keyword">return</span> INFINITY;</span><br><span class="line">    <span class="keyword">double</span> zPrime;</span><br><span class="line">    <span class="keyword">double</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> z = x;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x *= x;</span><br><span class="line">        zPrime = z;</span><br><span class="line">        z += x * y;</span><br><span class="line">        y += y;</span><br><span class="line">    &#125; <span class="keyword">while</span>(zPrime != z);</span><br><span class="line">    <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hllDenseRegHisto"><a href="#hllDenseRegHisto" class="headerlink" title="hllDenseRegHisto"></a>hllDenseRegHisto</h3><p><code>hllDenseRegHisto</code>会根据<code>HLL_REGISTERS == 16384 &amp;&amp; HLL_BITS == 6</code>的通用情况进行优化，我们对这个优化暂时按下不表，只关注实际在做什么。可以看到，它实际上去遍历了所有的register，然后通过<code>HLL_DENSE_GET_REGISTER</code>把这个<code>HLL_BITS=6</code>位的register取出来，并增加这个register的数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hllDenseRegHisto</span><span class="params">(<span class="keyword">uint8_t</span> *registers, <span class="keyword">int</span>* reghisto)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HLL_REGISTERS == <span class="number">16384</span> &amp;&amp; HLL_BITS == <span class="number">6</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; HLL_REGISTERS; j++) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> reg;</span><br><span class="line">            HLL_DENSE_GET_REGISTER(reg,registers,j);</span><br><span class="line">            reghisto[reg]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="hllSparseRegHisto"><a href="#hllSparseRegHisto" class="headerlink" title="hllSparseRegHisto"></a>hllSparseRegHisto</h3><p><code>hllSparseRegHisto</code>对Sparse情况进行统计。这个实现其实也很简单，遍历每个opcode，对于ZERO和XZERO就增加<code>reghisto[0]</code>，对于VAL就增加<code>reghisto[val]</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hdr-&gt;encoding == HLL_SPARSE) &#123;</span><br><span class="line">        hllSparseRegHisto(hdr-&gt;registers,</span><br><span class="line">                         sdslen((sds)hdr)-HLL_HDR_SIZE,invalid,reghisto);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h1 id="intset"><a href="#intset" class="headerlink" title="intset"></a>intset</h1><p>intset是存储int的集合。在底层存储上体现为一个有序的数组，这是它和ziplist的一个不同点。intset数组中的每个元素具有相同的长度，这个长度由<code>encoding</code>指定。<code>length</code>表示Intset里面元素的个数，所以柔性数组(Flex Array)<code>contents</code>的长度实际上就是<code>encoding * length</code>的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// intset.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<h2 id="encoding"><a href="#encoding" class="headerlink" title="encoding"></a>encoding</h2><p>类似于HLL的实现，intset也要考虑节省空间。<br>出于节省空间考虑，支持三种encoding，当出现该encoding装不下的数时，会新创建一个更大的encoding，当然这样会伴随空间浪费。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>

<p>给定<code>v</code>的值，得到能够承载它的最小encoding。需要注意的是，这里都是<strong>有符号</strong>整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">uint8_t</span> _intsetValueEncoding(<span class="keyword">int64_t</span> v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; INT32_MIN || v &gt; INT32_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT64;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; INT16_MIN || v &gt; INT16_MAX)</span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT32;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> INTSET_ENC_INT16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>因为支持不同的编码，所以intset索性用一个<code>int8_t contents[]</code>来存这些int。如果我们要把一个64位数字按照8位8位地存到<code>char</code>数组里面，那么就会涉及到选择大端或者小端两种存储方式。其实在Redis的很多数据结构的实现中，我们可以明显地看到Redis开发者，或者很多C开发者的一个特点，也就是喜欢把所有的数据结构都自己编码到<code>char*</code>上面。<code>intrev32ifbe</code>这个函数用来从小/大端序转为小端序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == LITTLE_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) memrev16(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) memrev32(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) memrev64(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) intrev16(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) intrev32(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><code>intsetFind</code>语句首先排除掉encoding过大的，比如在一串最大32767的数组里面肯定找不到99999。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Determine whether a value belongs to this set */</span></span><br><span class="line"><span class="keyword">uint8_t</span> intsetFind(intset *is, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">return</span> valenc &lt;= intrev32ifbe(is-&gt;encoding) &amp;&amp; intsetSearch(is,value,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就是<code>intsetSearch</code>，因为intset是有序的嘛，所以我想这个肯定是个二分的实现吧，果不其然。这个函数返回1表示找到，并用<code>pos</code>标记找到的位置/插入位置；否则返回0<br>在二分前，需要先特判一下value过大或者过小的情况，从而能够快速失败，而不是进入下面的二分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// min和max表示intset的最左和最右的index</span></span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里的二分每次都会对mid进行+1或者-1，和我们通常的二分还不太一样。通常的二分因为要在一个F/T…TTT或者TTT…F/T型的序列中找到边界的T，所以在移动mid时，如果我们发现当前的mid是T，并且我们想移动l/r的话，我们<strong>不能移动到mid-1/mid+1</strong>，这是因为mid可能就是我们要找的值。但这个二分我们要找的是exact value，所以我们可以激进一点，<strong>直接-1或者+1</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><p>对于<code>intsetAdd</code>的情况，想想肯定是有一个$O(logn)$的查找和一个$O(n)$的移动的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">intset *<span class="title">intsetAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint8_t</span> *success)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> valenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">uint32_t</span> pos;</span><br><span class="line">    <span class="keyword">if</span> (success) *success = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade encoding if necessary. If we need to upgrade, we know that</span></span><br><span class="line"><span class="comment">     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),</span></span><br><span class="line"><span class="comment">     * because it lies outside the range of existing values. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (valenc &gt; intrev32ifbe(is-&gt;encoding)) &#123;</span><br><span class="line">        <span class="comment">// 如果encoding明显大了，那么需要直接升级intset</span></span><br><span class="line">        <span class="comment">/* This always succeeds, so we don't need to curry *success. */</span></span><br><span class="line">        <span class="keyword">return</span> intsetUpgradeAndAdd(is,value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Abort if the value is already present in the set.</span></span><br><span class="line"><span class="comment">         * This call will populate "pos" with the right position to insert</span></span><br><span class="line"><span class="comment">         * the value when it cannot be found. */</span></span><br><span class="line">        <span class="keyword">if</span> (intsetSearch(is,value,&amp;pos)) &#123;</span><br><span class="line">            <span class="comment">// 如果已经存在，就直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (success) *success = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> is;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为新插入的value分配长度为1的空间</span></span><br><span class="line">        is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 把[pos, )移到[pos+1, )，即往后挪一位</span></span><br><span class="line">        <span class="keyword">if</span> (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _intsetSet(is,pos,value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Resize走的<code>zrealloc</code>，这个函数之前讲到过，并不保证不会重新分配内存，这也是为什么<code>intsetResize</code>会重新返回<code>intset *</code>指针的原因。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetResize</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> size = len*intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    is = zrealloc(is,<span class="keyword">sizeof</span>(intset)+size);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>intsetMoveTail</code>实际调用了<code>memmove</code>，直截了当的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">intsetMoveTail</span><span class="params">(intset *is, <span class="keyword">uint32_t</span> from, <span class="keyword">uint32_t</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *src, *dst;</span><br><span class="line">    <span class="comment">// bytes表示移动多少字节，目前的赋值是多少元素，后面还要乘上元素的长度</span></span><br><span class="line">    <span class="keyword">uint32_t</span> bytes = intrev32ifbe(is-&gt;length)-from;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        src = (<span class="keyword">int64_t</span>*)is-&gt;contents+from;</span><br><span class="line">        dst = (<span class="keyword">int64_t</span>*)is-&gt;contents+to;</span><br><span class="line">        bytes *= <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    memmove(dst,src,bytes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是先把64位的value放上去，如果机器上是大端(be)存储，那么再调用下面的宏倒成小端。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _intsetSet(intset *is, <span class="keyword">int</span> pos, <span class="keyword">int64_t</span> value) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> encoding = intrev32ifbe(is-&gt;encoding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (encoding == INTSET_ENC_INT64) &#123;</span><br><span class="line">        ((<span class="keyword">int64_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev64ifbe(((<span class="keyword">int64_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (encoding == INTSET_ENC_INT32) &#123;</span><br><span class="line">        ((<span class="keyword">int32_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev32ifbe(((<span class="keyword">int32_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ((<span class="keyword">int16_t</span>*)is-&gt;contents)[pos] = value;</span><br><span class="line">        memrev16ifbe(((<span class="keyword">int16_t</span>*)is-&gt;contents)+pos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大端小端宏"><a href="#大端小端宏" class="headerlink" title="大端小端宏"></a>大端小端宏</h3><p><strong>简单介绍一下memrev系列大小端转换的代码</strong>。<br>16的简单，3次交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>32位的，6次交换，实际上是轴对称交换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3</span><br><span class="line">3 1 2 0</span><br><span class="line">3 2 1 0</span><br></pre></td></tr></table></figure>

<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>64位的，12次交换，同样也是轴对称交换，代码就不列了。</p>
<h1 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h1><p>bitmap底层是一个SDS</p>
<h2 id="count实现"><a href="#count实现" class="headerlink" title="count实现"></a>count实现</h2><p>这个命令可以统计得到从<code>[start, end]</code>区间内的1的数量，但是这个<code>start</code>和<code>end</code>是以byte为单位的，从0开始。我们可以参考下面的这个demo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setbit test1 10 1</span><br><span class="line">setbit test1 20 1</span><br><span class="line">setbit test1 30 1</span><br></pre></td></tr></table></figure>

<p>下面两个命令返回值都是3</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitcount test1 </span><br><span class="line">bitcount test1 1 9</span><br></pre></td></tr></table></figure>

<p>其实bitmap底层是从左到右开始编号的。乍一看有点本末倒置，为啥最高位是0，但仔细想想，这种方式方便扩展啊。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">byte offset      : 0        1        2        3</span><br><span class="line">setbit test1 10 1: 00000000 00100000</span><br><span class="line">setbit test1 20 1: 00000000 00000000 00001000</span><br><span class="line">setbit test1 30 1: 00000000 00000000 00000000 00000010</span><br></pre></td></tr></table></figure>

<p>再举一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit test2 15 1</span><br></pre></td></tr></table></figure>

<p>计算15/8=1.875，所以是位于第1个byte的最后一位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000 00000001(15)</span><br></pre></td></tr></table></figure>

<p>因此<br><code>getbit test2 0 0</code> 返回0<br><code>getbit test2 0 1</code> 返回1，因为第一个byte被包含了<br><code>getbit test2 2 3</code> 返回0<br>‘<br>下面看<code>bitcountCommand</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bitops.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitcountCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">long</span> start, end, <span class="built_in">strlen</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">char</span> llbuf[LONG_STR_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lookup, check for type, and return 0 for non existing keys. */</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line">    p = getObjectReadOnlyString(o,&amp;<span class="built_in">strlen</span>,llbuf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse start/end range if any. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc == <span class="number">4</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c-&gt;argc == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* The whole string. */</span></span><br><span class="line">        start = <span class="number">0</span>;</span><br><span class="line">        end = <span class="built_in">strlen</span><span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Syntax error. */</span></span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Precondition: end &gt;= 0 &amp;&amp; end &lt; strlen, so the only condition where</span></span><br><span class="line"><span class="comment">     * zero can be returned is: start &gt; end. */</span></span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) &#123;</span><br><span class="line">        addReply(c,shared.czero);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> bytes = end-start+<span class="number">1</span>;</span><br><span class="line">        addReplyLongLong(c,redisPopcount(p+start,bytes));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面一堆废话结束，最关键的是<code>redisPopcount</code>这个函数，统计从<code>s</code>开始的<code>bytes</code>长度的slice里面的1的个数。<br>一开始发现一个表<code>bitsinbyte</code>，这里面<code>bitsinbyte[i]</code>表示<code>i</code>这个数字的二进制表示里面有几个1。可以从中看出，bitcount统计bytes而不是统计bits的原因可能很大程度上就是对bytes可以查表处理，起到加速作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Count number of bits set in the binary array pointed by 's' and long</span></span><br><span class="line"><span class="comment"> * 'count' bytes. The implementation of this function is required to</span></span><br><span class="line"><span class="comment"> * work with a input string length up to 512 MB. */</span></span><br><span class="line"><span class="keyword">size_t</span> redisPopcount(<span class="keyword">void</span> *s, <span class="keyword">long</span> count) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = s;</span><br><span class="line">    <span class="keyword">uint32_t</span> *p4;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> bitsinbyte[<span class="number">256</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的代码中<code>(unsigned long)p &amp; 3</code>的目的是用一个while循环统计下前面没有对齐到32位的数量。其实如果我们愿意慢一点，直接这个while循环就能全部统计完了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Count initial bytes not aligned to 32 bit. */</span></span><br><span class="line">    <span class="keyword">while</span>((<span class="keyword">unsigned</span> <span class="keyword">long</span>)p &amp; <span class="number">3</span> &amp;&amp; count) &#123;</span><br><span class="line">        bits += bitsinbyte[*p++];</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>一次性计算 28 个 bytes，这个算法经历过疯狂的升级，3.0 的时候是同时计算 16 个，但总体来说还是一个 SWAR 算法。为了便于理解，先看 3.0 版本的 16 bytes 的算法，它其实有点类似于在 GeoHash 中看到的 <code>interleave64</code> 的算法。快速计算 64 位和 32 位整数二进制表示中 1 数量的算法是种群算法，我在<a href="/2018/01/18/csapp-data-lab/">csapp data lab</a>这篇文章中有介绍。<a href="http://yesteapea.wordpress.com/2013/03/03/counting-the-number-of-set-bits-in-an-integer/" target="_blank" rel="noopener">这篇文章</a> 中的介绍也很详细。此外，gcc 提供了对于不同长度类型计算 1 的数量的 <code>__builtin_popcount</code> 的系列内置函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for 64 bit numbers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfSetBits64</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x5555555555555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x3333333333333333</span>) +</span><br><span class="line">        ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x3333333333333333</span>);</span><br><span class="line">    i = ((i + (i &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F0F0F0F0F</span>);</span><br><span class="line">    <span class="keyword">return</span> (i*(<span class="number">0x0101010101010101</span>))&gt;&gt;<span class="number">56</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for 32 bit integers</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">NumberOfSetBits32</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A</span></span><br><span class="line">    i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">    i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">    <span class="comment">// B</span></span><br><span class="line">    i = ((i + (i &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>);</span><br><span class="line">    <span class="keyword">return</span> (i*(<span class="number">0x01010101</span>))&gt;&gt;<span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们以32位为例，复习一下该算法的原理。首先回顾一下这几个常量的表示，<code>F</code>实际上是<code>01</code>的重复，<code>T</code>是<code>0011</code>的重复，<code>O</code>是<code>00001111</code>的重复</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F = <span class="number">0x55555555</span> = <span class="number">01010101010101010101010101010101</span></span><br><span class="line">T = <span class="number">0x33333333</span> = <span class="number">00110011001100110011001100110011</span></span><br><span class="line">O = <span class="number">0x0f0f0f0f</span> = <span class="number">00001111000011110000111100001111</span></span><br></pre></td></tr></table></figure>

<p>这个算法的思路是首先把32位长度的数组按照奇偶组合成16组，然后在每组中统计1的个数，容易看到，这个结果只能是0b0/0b1/0b10，不会溢出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">‭数字 01 11 01 01 10 11 11 00 11 01 00 01 01 01‬(123456789)‬‬</span><br><span class="line">和   01 10 01 01 01 10 10 00 10 01 00 01 01 01</span><br></pre></td></tr></table></figure>

<p>这个过程是可以用位运算解决的，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们发现，为啥函数里面不是这样写的？其实下面两种是等价算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x55555555</span>) + ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">i = i - ((i &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br></pre></td></tr></table></figure>

<p>一般来说，<code>&amp;</code> 对 <code>+</code> 是不满足分配率的，但在对按4移位的情况下是可以的，即不会产生溢出。所以后面我们还可以提出 <code>0x0F0F0F0F</code>公因式。注意对 2 移位是不能提公因式的，考虑 <code>1010b</code> 这种情况，移位相加会出现 <code>10b + 10b</code> 从而导致溢出。</p>
<p>下面我们来对照看看3.0版本的16 bytes的实现，在前面执行<code>NumberOfSetBits32</code>的A步骤，依次计算4个byte的数量到aux1/2/3/4里面。在最后执行B步骤，将最后结果加到<code>bits</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4;</span><br><span class="line"></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        aux2 = *p4++;</span><br><span class="line">        aux3 = *p4++;</span><br><span class="line">        aux4 = *p4++;</span><br><span class="line">        count -= <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux2 = aux2 - ((aux2 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux2 = (aux2 &amp; <span class="number">0x33333333</span>) + ((aux2 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux3 = aux3 - ((aux3 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux3 = (aux3 &amp; <span class="number">0x33333333</span>) + ((aux3 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        aux4 = aux4 - ((aux4 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux4 = (aux4 &amp; <span class="number">0x33333333</span>) + ((aux4 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line"></span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">                ((((aux2 + (aux2 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">                ((((aux3 + (aux3 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>) +</span><br><span class="line">                ((((aux4 + (aux4 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) * <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面看28 bytes算法也是类似，不过为啥要选择28这个数呢，我不是很明白</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    p4 = (<span class="keyword">uint32_t</span>*)p;</span><br><span class="line">    <span class="keyword">while</span>(count&gt;=<span class="number">28</span>) &#123;</span><br><span class="line">        <span class="keyword">uint32_t</span> aux1, aux2, aux3, aux4, aux5, aux6, aux7;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *p++等于*(p++)</span></span><br><span class="line">        aux1 = *p4++;</span><br><span class="line">        ...</span><br><span class="line">        aux7 = *p4++;</span><br><span class="line">        count -= <span class="number">28</span>;</span><br><span class="line"></span><br><span class="line">        aux1 = aux1 - ((aux1 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux1 = (aux1 &amp; <span class="number">0x33333333</span>) + ((aux1 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        ...</span><br><span class="line">        aux7 = aux7 - ((aux7 &gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        aux7 = (aux7 &amp; <span class="number">0x33333333</span>) + ((aux7 &gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        </span><br><span class="line">        bits += ((((aux1 + (aux1 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>) +</span><br><span class="line">                    ...</span><br><span class="line">                    ((aux7 + (aux7 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0F0F0F0F</span>))* <span class="number">0x01010101</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环和之前的<code>(unsigned long)p &amp; 3</code>循环是对应的，用来处理余下来和28个bytes不对齐的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Count the remaining bytes. */</span></span><br><span class="line">p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)p4;</span><br><span class="line">    <span class="keyword">while</span>(count--) bits += bitsinbyte[*p++];</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="set-get实现"><a href="#set-get实现" class="headerlink" title="set/get实现"></a>set/get实现</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SETBIT key offset bitvalue */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbitCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    <span class="keyword">char</span> *err = <span class="string">"bit is not an integer or out of range"</span>;</span><br><span class="line">    <span class="keyword">size_t</span> bitoffset;</span><br><span class="line">    <span class="keyword">ssize_t</span> byte, bit;</span><br><span class="line">    <span class="keyword">int</span> byteval, bitval;</span><br><span class="line">    <span class="keyword">long</span> on;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 把bitoffset位置设置为on</span></span><br><span class="line">    <span class="keyword">if</span> (getBitOffsetFromArgument(c,c-&gt;argv[<span class="number">2</span>],&amp;bitoffset,<span class="number">0</span>,<span class="number">0</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;on,err) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bits can only be set or cleared... */</span></span><br><span class="line">    <span class="comment">// 如果on不是0或者1，那么就返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (on &amp; ~<span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面这个命令，进行检查，该创建的创建，该扩容的扩容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> ((o = lookupStringForBitCommand(c,bitoffset)) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get current values */</span></span><br><span class="line">    <span class="comment">// bitoffset除以8，得到所在的byte</span></span><br><span class="line">    byte = bitoffset &gt;&gt; <span class="number">3</span>;</span><br><span class="line">    byteval = ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte];</span><br><span class="line">    <span class="comment">// 由于bitmap是从左往右数的，所以这边要用7减一下，得到这个byte中从右往左的偏移量</span></span><br><span class="line">    bit = <span class="number">7</span> - (bitoffset &amp; <span class="number">0x7</span>);</span><br><span class="line">    <span class="comment">// 取出实际的bit值</span></span><br><span class="line">    bitval = byteval &amp; (<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update byte with new bit value and return original value */</span></span><br><span class="line">    <span class="comment">// 更新并返回原先的值</span></span><br><span class="line">    byteval &amp;= ~(<span class="number">1</span> &lt;&lt; bit);</span><br><span class="line">    byteval |= ((on &amp; <span class="number">0x1</span>) &lt;&lt; bit);</span><br><span class="line">    ((<span class="keyword">uint8_t</span>*)o-&gt;ptr)[byte] = byteval;</span><br><span class="line">    signalModifiedKey(c,c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"setbit"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">    addReply(c, bitval ? shared.cone : shared.czero);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a>bitop</h2><p>bitop指令的格式如下面所示，结果存到dest里面。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bitop</span></span> opname dest src1 src2 ...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* BITOP op_name target_key src_key1 src_key2 src_key3 ... src_keyN */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bitopCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *opname = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">    robj *o, *targetkey = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> op, j, numkeys;</span><br><span class="line">    robj **objects;      <span class="comment">/* Array of source objects. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> **src; <span class="comment">/* Array of source strings pointers. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *len, maxlen = <span class="number">0</span>; <span class="comment">/* Array of length of src strings,</span></span><br><span class="line"><span class="comment">                                       and max len. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> minlen = <span class="number">0</span>;    <span class="comment">/* Min len among the input keys. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *res = <span class="literal">NULL</span>; <span class="comment">/* Resulting string. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在字符串判定的时候有个优化，因为<code>strcasecmp</code>的开销比较大，所以会先判断第一个字母合不合法，合法再调用这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Parse the operation name. */</span></span><br><span class="line">    <span class="keyword">if</span> ((opname[<span class="number">0</span>] == <span class="string">'a'</span> || opname[<span class="number">0</span>] == <span class="string">'A'</span>) &amp;&amp; !strcasecmp(opname,<span class="string">"and"</span>))</span><br><span class="line">        op = BITOP_AND;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sanity check: NOT accepts only a single key argument. */</span></span><br><span class="line">    <span class="keyword">if</span> (op == BITOP_NOT &amp;&amp; c-&gt;argc != <span class="number">4</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"BITOP NOT must be called with a single source key."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>遍历所有要查找的key，统计一些信息：</p>
<ol>
<li>objects<br> 调用<code>getDecodedObject</code>。因为这个是raw encoding，所以相当于就是自增了一下引用。</li>
<li>src<br> 每一个src的指针</li>
<li>len<br> 每一个src的对应长度，这个长度是按照字节算的</li>
<li>maxlen/minlen<br> 所有src的最大长度和最小长度</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Lookup keys, and store pointers to the string objects into an array. */</span></span><br><span class="line">    numkeys = c-&gt;argc - <span class="number">3</span>;</span><br><span class="line">    src = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>*) * numkeys);</span><br><span class="line">    len = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">long</span>) * numkeys);</span><br><span class="line">    objects = zmalloc(<span class="keyword">sizeof</span>(robj*) * numkeys);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        o = lookupKeyRead(c-&gt;db,c-&gt;argv[j+<span class="number">3</span>]);</span><br><span class="line">        <span class="comment">/* Handle non-existing keys as empty strings. */</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            objects[j] = <span class="literal">NULL</span>;</span><br><span class="line">            src[j] = <span class="literal">NULL</span>;</span><br><span class="line">            len[j] = <span class="number">0</span>;</span><br><span class="line">            minlen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Return an error if one of the keys is not a string. */</span></span><br><span class="line">        <span class="comment">// 如果有不是OBJ_STRING对象，就返回错误，并且释放</span></span><br><span class="line">        <span class="keyword">if</span> (checkType(c,o,OBJ_STRING)) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (objects[i])</span><br><span class="line">                    decrRefCount(objects[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            zfree(src);</span><br><span class="line">            zfree(len);</span><br><span class="line">            zfree(objects);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        objects[j] = getDecodedObject(o);</span><br><span class="line">        src[j] = objects[j]-&gt;ptr;</span><br><span class="line">        len[j] = sdslen(objects[j]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (len[j] &gt; maxlen) maxlen = len[j];</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || len[j] &lt; minlen) minlen = len[j];</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>比较有趣的是这里同样针对对齐数据有个优化。我们需要在ARM架构上跳过这个优化点，这是因为ARM不支持multiple-words load/store，即使在V6架构下。<br>首先，解释一下几个临时变量：</p>
<ol>
<li>j<br> 表示SDS里面的每一个字节</li>
<li>i<br> 表示op作用的每一个key</li>
</ol>
<p>出于从普通到特殊，可以先阅读后面的普通实现，再看这个优化实现。<br>优化实现能够处理最短的bitmap至少有4个long（32位）的情况，但是要求key的总数小于等于16。也就是说我们能够一批4个地对所有的key做bitop。【Q】不过不需要什么特殊的指令，直接这样写CPU就可以优化了吗？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Compute the bit operation, if at least one string is not empty. */</span></span><br><span class="line">    <span class="keyword">if</span> (maxlen) &#123;</span><br><span class="line">        res = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) sdsnewlen(<span class="literal">NULL</span>,maxlen);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> output, byte;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> i;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifndef</span> USE_ALIGNED_ACCESS</span></span><br><span class="line">        <span class="keyword">if</span> (minlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span> &amp;&amp; numkeys &lt;= <span class="number">16</span>) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *lp[<span class="number">16</span>];</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> *lres = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*) res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note: sds pointer is always aligned to 8 byte boundary. */</span></span><br><span class="line">            <span class="built_in">memcpy</span>(lp,src,<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>*)*numkeys);</span><br><span class="line">            <span class="built_in">memcpy</span>(res,src[<span class="number">0</span>],minlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Different branches per different operations for speed (sorry). */</span></span><br><span class="line">            <span class="keyword">if</span> (op == BITOP_AND) &#123;</span><br><span class="line">                <span class="keyword">while</span>(minlen &gt;= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numkeys; i++) &#123;</span><br><span class="line">                        lres[<span class="number">0</span>] &amp;= lp[i][<span class="number">0</span>];</span><br><span class="line">                        lres[<span class="number">1</span>] &amp;= lp[i][<span class="number">1</span>];</span><br><span class="line">                        lres[<span class="number">2</span>] &amp;= lp[i][<span class="number">2</span>];</span><br><span class="line">                        lres[<span class="number">3</span>] &amp;= lp[i][<span class="number">3</span>];</span><br><span class="line">                        lp[i]+=<span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lres+=<span class="number">4</span>;</span><br><span class="line">                    j += <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>;</span><br><span class="line">                    minlen -= <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span>)*<span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_OR) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_XOR) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == BITOP_NOT) &#123;</span><br><span class="line">...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #endif</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>专门提取第一个出来作为左操作数，下面<code>i</code>从1开始循环</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* j is set to the next byte to process by the previous loop. */</span></span><br><span class="line">        <span class="keyword">for</span> (; j &lt; maxlen; j++) &#123;</span><br><span class="line">            output = (len[<span class="number">0</span>] &lt;= j) ? <span class="number">0</span> : src[<span class="number">0</span>][j];</span><br><span class="line">            <span class="keyword">if</span> (op == BITOP_NOT) output = ~output;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里我有个疑惑了，既然里面都不处理<code>BITOP_NOT</code>了，为啥不直接跳过这个for循环呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numkeys; i++) &#123;</span><br><span class="line">                byte = (len[i] &lt;= j) ? <span class="number">0</span> : src[i][j];</span><br><span class="line">                <span class="keyword">switch</span>(op) &#123;</span><br><span class="line">                <span class="keyword">case</span> BITOP_AND: output &amp;= byte; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BITOP_OR:  output |= byte; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> BITOP_XOR: output ^= byte; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[j] = output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面是清理工作了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects[j])</span><br><span class="line">            decrRefCount(objects[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    zfree(src);</span><br><span class="line">    zfree(len);</span><br><span class="line">    zfree(objects);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store the computed value into the target key */</span></span><br><span class="line">    <span class="keyword">if</span> (maxlen) &#123;</span><br><span class="line">        o = createObject(OBJ_STRING,res);</span><br><span class="line">        setKey(c,c-&gt;db,targetkey,o);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"set"</span>,targetkey,c-&gt;db-&gt;id);</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dbDelete(c-&gt;db,targetkey)) &#123;</span><br><span class="line">        signalModifiedKey(c,c-&gt;db,targetkey);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,targetkey,c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,maxlen); <span class="comment">/* Return the output string length in bytes. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="quicklist"><a href="#quicklist" class="headerlink" title="quicklist"></a>quicklist</h1><h1 id="Geo和GeoHash"><a href="#Geo和GeoHash" class="headerlink" title="Geo和GeoHash"></a>Geo和GeoHash</h1><p>Redis在3.2版本之后提供GeoHash的实现，主要包含下面的命令：</p>
<ol>
<li><code>GEOADD key longitude latitude member [longitude latitude member ...]</code><br> 将某个经纬度以及对应的名字(member)加入到指定的key里面</li>
<li><code>GEOPOS key member [member ...]</code><br> 以member为输入，返回经纬度为输出</li>
<li><code>GEODIST key member1 member2 [unit]</code><br> 返回两个位置之间的间隔，以unit为单位，默认为米</li>
<li><code>GEORADIUS key longitude latitude radius unit</code><br> 返回给定经纬度为中心radius范围内的位置，默认返回未排序的元素</li>
<li><code>GEORADIUSBYMEMBER</code><br> 同上，但是不是给出经纬度，而是直接给一个member名字</li>
<li><code>GEOHASH ley member [member ...]</code><br> 返回member的GeoHash值</li>
<li><code>ZREM</code><br> 用来删除一个GEOHASH对象</li>
</ol>
<h2 id="GEOADD"><a href="#GEOADD" class="headerlink" title="GEOADD"></a>GEOADD</h2><p>对应<code>GEOADD</code>指令。<br>可以看到，Geo的底层存储是一个ZSET。这也是可以理解的，因为通过GeoHash确实可以实现有序的地理坐标，所以我们是按照顺序存储的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geoaddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Check arguments number for sanity. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc - <span class="number">2</span>) % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Need an odd number of arguments if we got this far... */</span></span><br><span class="line">        addReplyError(c, <span class="string">"syntax error. Try GEOADD key [x1] [y1] [name1] "</span></span><br><span class="line">                         <span class="string">"[x2] [y2] [name2] ... "</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这里构建将来**提供给zadd命令的<code>argc</code>和<code>argv</code>**。<code>elements</code>表示坐标的数量，一个坐标需要有<code>(long, lat, name)</code>三元组来表示，所以这里要除以3。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> elements = (c-&gt;argc - <span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">2</span>+elements*<span class="number">2</span>; <span class="comment">/* ZADD key score ele ... */</span></span><br><span class="line">    robj **argv = zcalloc(argc*<span class="keyword">sizeof</span>(robj*));</span><br><span class="line">    <span class="comment">// 表示创建一个值是"zadd"的`OBJ_STRING`对象</span></span><br><span class="line">    argv[<span class="number">0</span>] = createRawStringObject(<span class="string">"zadd"</span>,<span class="number">4</span>);</span><br><span class="line">    argv[<span class="number">1</span>] = c-&gt;argv[<span class="number">1</span>]; <span class="comment">/* key */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Step 1: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里自增argv[1]的引用计数是因为直接把<code>argv[1]</code>指向<code>c-&gt;argv[1]</code>了，所以实际上也是自增<code>c-&gt;argv[1]</code>的引用计数。实际上这么做同时也保证了<code>replaceClientCommandVector</code>在释放掉<code>c-&gt;argv</code>后，<code>c-&gt;argv[1]</code>所指向的对象仍有一个引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个语句之后，我们得到<code>Step 1: argv[1]-&gt;refcount 2, c-&gt;argv[1]-&gt;refcount 2</code>。<br>下面的循环依次解析每个坐标，并构建<code>score</code>和<code>member</code>字段。<br>首先通过<code>extractLongLatOrReply</code>把经纬度读到<code>xy</code>里面，如果出现经纬度超出范围的问题函数会返回<code>C_ERR</code>，从而导致直接return。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Create the argument vector to call ZADD in order to add all</span></span><br><span class="line"><span class="comment">     * the score,value pairs to the requested zset, where score is actually</span></span><br><span class="line"><span class="comment">     * an encoded version of lat,long. */</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements; i++) &#123;</span><br><span class="line">        <span class="keyword">double</span> xy[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (extractLongLatOrReply(c, (c-&gt;argv+<span class="number">2</span>)+(i*<span class="number">3</span>),xy) == C_ERR) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">                <span class="keyword">if</span> (argv[i]) decrRefCount(argv[i]);</span><br><span class="line">            zfree(argv);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面的<code>geohashEncodeWGS84</code>函数根据我们取出来的<code>xy</code>算GeoHash，最后会调用到<code>geohashEncodeType -&gt; geohashEncode</code>，关于GeoHash部分会在后面讨论。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Turn the coordinates into the score of the element. */</span></span><br><span class="line">        GeoHashBits hash;</span><br><span class="line">        <span class="comment">// geohashEncodeWGS84最终调用geohashEncode</span></span><br><span class="line">        geohashEncodeWGS84(xy[<span class="number">0</span>], xy[<span class="number">1</span>], GEO_STEP_MAX, &amp;hash);</span><br><span class="line">        GeoHashFix52Bits bits = geohashAlign52Bits(hash);</span><br><span class="line"><span class="comment">// geoaddCommand未完结</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>geohashAlign52Bits</code>函数能够将得到的哈希值<code>GeoHashBits</code>，其中<code>hash.bits</code>是哈希值，<code>hash.step</code>是精度。我们需要将它做成一个52位的整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash_helper.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> GeoHashFix52Bits;</span><br><span class="line"></span><br><span class="line"><span class="comment">// geo.c</span></span><br><span class="line"><span class="function">GeoHashFix52Bits <span class="title">geohashAlign52Bits</span><span class="params">(<span class="keyword">const</span> GeoHashBits hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> bits = hash.bits;</span><br><span class="line">    bits &lt;&lt;= (<span class="number">52</span> - hash.step * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着来看函数<code>geoaddCommand</code>，我们将得到的<code>bits</code>组装成SDS，并且安装到<code>argv</code>里面，接着**调用<code>replaceClientCommandVector</code>得到一个以<code>argc</code>和<code>argv</code>为参数的新的<code>redisCommand</code>**，放到<code>c-&gt;cmd</code>里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续geoaddCommand</span></span><br><span class="line">...</span><br><span class="line">        robj *score = createObject(OBJ_STRING, sdsfromlonglong(bits));</span><br><span class="line">        robj *val = c-&gt;argv[<span class="number">2</span> + i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        argv[<span class="number">2</span>+i*<span class="number">2</span>] = score;</span><br><span class="line">        argv[<span class="number">3</span>+i*<span class="number">2</span>] = val;</span><br><span class="line">        incrRefCount(val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Finally call ZADD that will do the work for us. */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Step 2: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br><span class="line">    replaceClientCommandVector(c,argc,argv);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Step 3: argv[1]-&gt;refcount %d, c-&gt;argv[1]-&gt;refcount %d\n"</span>, argv[<span class="number">1</span>]-&gt;refcount, c-&gt;argv[<span class="number">1</span>]-&gt;refcount);</span><br><span class="line">    zaddCommand(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这之后，输出是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Step 2: argv[1]-&gt;refcount 2, c-&gt;argv[1]-&gt;refcount 2</span><br><span class="line">Step 3: argv[1]-&gt;refcount 1, c-&gt;argv[1]-&gt;refcount 1</span><br></pre></td></tr></table></figure>

<h3 id="replaceClientCommandVector"><a href="#replaceClientCommandVector" class="headerlink" title="replaceClientCommandVector"></a>replaceClientCommandVector</h3><p><code>replaceClientCommandVector</code>函数会释放<code>c-&gt;argv</code>和<code>c-&gt;argc</code>，并且使用传入的<code>argc</code>和<code>argv</code>替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// networking.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Completely replace the client command vector with the provided one. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceClientCommandVector</span><span class="params">(client *c, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</span><br><span class="line">    freeClientArgv(c);</span><br><span class="line">    zfree(c-&gt;argv);</span><br><span class="line">    c-&gt;argv = argv;</span><br><span class="line">    c-&gt;argc = argc;</span><br><span class="line">    c-&gt;cmd = lookupCommandOrOriginal(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,c-&gt;cmd != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freeClientArgv"><a href="#freeClientArgv" class="headerlink" title="freeClientArgv"></a>freeClientArgv</h3><p>查看<code>freeClientArgv</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">freeClientArgv</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;argc; j++)</span><br><span class="line">        decrRefCount(c-&gt;argv[j]);</span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    c-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="lookupCommandOrOriginal"><a href="#lookupCommandOrOriginal" class="headerlink" title="lookupCommandOrOriginal"></a>lookupCommandOrOriginal</h3><p><code>lookupCommandOrOriginal</code>用来根据指令名<code>name</code>找到对应的<code>redisCommand</code>项目。首先会在<code>server.commands</code>里面找，如果没找到会在<code>server.orig_commands</code>里面找。<code>orig_commands</code>表示没有被redis.conf里面的rename命令修改过的原始的命令名字。看起来很奇怪，不过人家注释也说了<code>lookupCommandOrOriginal</code>一般只和<code>lookupCommandOrOriginal</code>配合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is used by functions rewriting the argument vector such as</span></span><br><span class="line"><span class="comment"> * rewriteClientCommandVector() in order to set client-&gt;cmd pointer</span></span><br><span class="line"><span class="comment"> * correctly even if the command was renamed. */</span></span><br><span class="line"><span class="function">struct redisCommand *<span class="title">lookupCommandOrOriginal</span><span class="params">(sds name)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span> = <span class="title">dictFetchValue</span>(<span class="title">server</span>.<span class="title">commands</span>, <span class="title">name</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cmd) cmd = dictFetchValue(server.orig_commands,name);</span><br><span class="line">    <span class="keyword">return</span> cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="GEOHASH算法介绍"><a href="#GEOHASH算法介绍" class="headerlink" title="GEOHASH算法介绍"></a>GEOHASH算法介绍</h2><p>GEOHASH是将二进制的经纬度转换为字符串，每个字符串<strong>表示一块矩形的区域</strong>。这些字符串越长，那么表示的范围就越精确。</p>
<p>下面阐述如何计算GEOHASH：</p>
<ol>
<li>如何编码精度或者纬度<br> 例如纬度的范围是[-90,90]，那么我们不断二分就可以得到一个二进制的表示。例如<code>00</code>表示<code>[-90,-45)</code>，<code>11</code>表示<code>[45,90]</code>。</li>
<li>如何组合精度和纬度<br> 通过interleave来组合。也就是偶数位放经度，奇数位放纬度。</li>
<li>如何生成字符串<br> 我们组成的GeoHash有52位，通过Base32编码(一个char能表示5位)可以得到长度为11的字符串。</li>
</ol>
<p>这种interleave的组合方式成为<a href="https://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">Peano空间填充曲线</a>。如下所示，这个曲线可能存在<strong>编码相邻但是实际距离很远</strong>的情况，例如0111和1000。因此，在通过GEOHASH召回部分空间点后，还需要去判断一下实际距离。<br><img src="/img/redis_object/geohash_peano.png"></p>
<h2 id="GEOHASH实现"><a href="#GEOHASH实现" class="headerlink" title="GEOHASH实现"></a>GEOHASH实现</h2><h3 id="GeoHashBits-geohashGetCoordRange"><a href="#GeoHashBits-geohashGetCoordRange" class="headerlink" title="GeoHashBits/geohashGetCoordRange"></a>GeoHashBits/geohashGetCoordRange</h3><p><code>GeoHashBits</code>是GEOHASH结构。bits表示hash值，是interleave64之后的结果。step表示进行二分的次数，Redis中默认是26，所以最终得到的hash是52位的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> bits; <span class="comment">// 表示哈希值</span></span><br><span class="line">    <span class="keyword">uint8_t</span> step; <span class="comment">// 表示精度</span></span><br><span class="line">&#125; GeoHashBits;</span><br></pre></td></tr></table></figure>

<p>下面四个宏规定了经纬度的取值范围。在这里需要说明的是Redis的GeoHash的内部存储和标准有差异。标准规定纬度的取值范围是[-90, 90]，而Redis的实现是[-85, 85]。因此Redis实际上是不能索引位于南北极的一小块范围的。<br>【Q】为什么这么做呢？我觉得可能有两个原因：</p>
<ol>
<li>南北极的位置本来也不常用</li>
<li>南北极的经度变化比较敏感，所以其实有点浪费</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Limits from EPSG:900913 / EPSG:3785 / OSGEO:41001 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LAT_MIN -85.05112878</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LAT_MAX 85.05112878</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LONG_MIN -180</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GEO_LONG_MAX 180</span></span><br></pre></td></tr></table></figure>

<p>我们回顾之前看到的<code>geohashEncodeWGS84</code>的函数的调用链，它会通过<code>geohashGetCoordRange</code>来获得这次经纬度的范围，并作为参数传给<code>geohashEncode</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncodeType</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step, GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    GeoHashRange r[<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    geohashGetCoordRange(&amp;r[<span class="number">0</span>], &amp;r[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> geohashEncode(&amp;r[<span class="number">0</span>], &amp;r[<span class="number">1</span>], longitude, latitude, step, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncodeWGS84</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step,</span></span></span><br><span class="line"><span class="function"><span class="params">                       GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> geohashEncodeType(longitude, latitude, step, hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geohashGetCoordRange</span><span class="params">(GeoHashRange *long_range, GeoHashRange *lat_range)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* These are constraints from EPSG:900913 / EPSG:3785 / OSGEO:41001 */</span></span><br><span class="line">    <span class="comment">/* We can't geocode at the north/south pole. */</span></span><br><span class="line">    long_range-&gt;max = GEO_LONG_MAX;</span><br><span class="line">    long_range-&gt;min = GEO_LONG_MIN;</span><br><span class="line">    lat_range-&gt;max = GEO_LAT_MAX;</span><br><span class="line">    lat_range-&gt;min = GEO_LAT_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geohashCommand"><a href="#geohashCommand" class="headerlink" title="geohashCommand"></a>geohashCommand</h3><p>查看<code>geohashCommand</code>的实现，它主要是通过<code>geohashEncode</code>去得到一个<code>GeoHashBits</code>对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">geohashCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *geoalphabet= <span class="string">"0123456789bcdefghjkmnpqrstuvwxyz"</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the requested zset */</span></span><br><span class="line">    robj *zobj = lookupKeyRead(c-&gt;db, c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (checkType(c, zobj, OBJ_ZSET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Geohash elements one after the other, using a null bulk reply for</span></span><br><span class="line"><span class="comment">     * missing elements. */</span></span><br><span class="line">    addReplyArrayLen(c,c-&gt;argc<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>首先通过<code>zsetScore</code>获得指定<code>member</code>即<code>c-&gt;argv[j]-&gt;ptr</code>的<code>score</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!zobj || zsetScore(zobj, c-&gt;argv[j]-&gt;ptr, &amp;score) == C_ERR) &#123;</span><br><span class="line">            addReplyNull(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在前面提到过，Redis的GeoHash的内部<strong>存储</strong>和标准的GEOHASH坐标有差异。Redis的是[-85,85]这个区间，但是普通的GEOHASH是[-90,90]区间。因为这个命令会返回<strong>标准的GEOHASH值</strong>，所以我们需要将它转换到标准GeoHash。<br>因此需要用<code>decodeGeohash</code>将<code>score</code>解码到<code>xy</code>，并且再通过<code>GeoHashRange</code>编码，得到纬度取值范围为[-90, 90]的<code>hash</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="comment">/* The internal format we use for geocoding is a bit different</span></span><br><span class="line"><span class="comment">             * than the standard, since we use as initial latitude range</span></span><br><span class="line"><span class="comment">             * -85,85, while the normal geohashing algorithm uses -90,90.</span></span><br><span class="line"><span class="comment">             * So we have to decode our position and re-encode using the</span></span><br><span class="line"><span class="comment">             * standard ranges in order to output a valid geohash string. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Decode... */</span></span><br><span class="line">            <span class="keyword">double</span> xy[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (!decodeGeohash(score,xy)) &#123;</span><br><span class="line">                addReplyNull(c);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Re-encode */</span></span><br><span class="line">            GeoHashRange r[<span class="number">2</span>];</span><br><span class="line">            GeoHashBits hash;</span><br><span class="line">            r[<span class="number">0</span>].min = <span class="number">-180</span>;</span><br><span class="line">            r[<span class="number">0</span>].max = <span class="number">180</span>;</span><br><span class="line">            r[<span class="number">1</span>].min = <span class="number">-90</span>;</span><br><span class="line">            r[<span class="number">1</span>].max = <span class="number">90</span>;</span><br><span class="line">            geohashEncode(&amp;r[<span class="number">0</span>],&amp;r[<span class="number">1</span>],xy[<span class="number">0</span>],xy[<span class="number">1</span>],<span class="number">26</span>,&amp;hash);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面我们得到了符合标准的<code>hash</code>，接下来我们将这个<code>hash</code>值根据<code>geoalphabet</code>编码到字符串<code>buf</code>上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">12</span>];</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">11</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">10</span>) &#123;</span><br><span class="line">                    <span class="comment">/* We have just 52 bits, but the API used to output</span></span><br><span class="line"><span class="comment">                     * an 11 bytes geohash. For compatibility we assume</span></span><br><span class="line"><span class="comment">                     * zero. */</span></span><br><span class="line">                    idx = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    idx = (hash.bits &gt;&gt; (<span class="number">52</span>-((i+<span class="number">1</span>)*<span class="number">5</span>))) &amp; <span class="number">0x1f</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                buf[i] = geoalphabet[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            buf[<span class="number">11</span>] = <span class="string">'\0'</span>;</span><br><span class="line">            addReplyBulkCBuffer(c,buf,<span class="number">11</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geohashEncode"><a href="#geohashEncode" class="headerlink" title="geohashEncode"></a>geohashEncode</h3><p>下面我们来看最关键的<code>geohashEncode</code>的实现。<br>首先是进行校验，包含两部分。首先检验经纬度Range是否合法，然后校验经纬度是否在<code>GEO_</code>宏规定的区间内，然后校验经纬度是否在经纬度Range给出的区间内。<br>【Q】在这里有一个问题，从上面的代码实现可以看到，其实<code>lat_range</code>是可能比<code>GEO_LAT_MAX</code>/<code>GEO_LAT_MIN</code>范围大的，那么这是否影响GeoHash的结果呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// geohash.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGEISZERO(r) (!(r).max &amp;&amp; !(r).min)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RANGEPISZERO(r) (r == NULL || RANGEISZERO(*r))</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geohashEncode</span><span class="params">(<span class="keyword">const</span> GeoHashRange *long_range, <span class="keyword">const</span> GeoHashRange *lat_range,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">uint8_t</span> step,</span></span></span><br><span class="line"><span class="function"><span class="params">                  GeoHashBits *hash)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Check basic arguments sanity. */</span></span><br><span class="line">    <span class="keyword">if</span> (hash == <span class="literal">NULL</span> || step &gt; <span class="number">32</span> || step == <span class="number">0</span> ||</span><br><span class="line">        RANGEPISZERO(lat_range) || RANGEPISZERO(long_range)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>longitude和latitude既要满足<code>GEO_</code>宏定义的区间限制，也要满足传入的<code>long_range</code>和<code>lat_range</code>区间限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Return an error when trying to index outside the supported</span></span><br><span class="line"><span class="comment">     * constraints. */</span></span><br><span class="line">    <span class="keyword">if</span> (longitude &gt; GEO_LONG_MAX || longitude &lt; GEO_LONG_MIN ||</span><br><span class="line">        latitude &gt; GEO_LAT_MAX || latitude &lt; GEO_LAT_MIN) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    hash-&gt;bits = <span class="number">0</span>;</span><br><span class="line">    hash-&gt;step = step;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (latitude &lt; lat_range-&gt;min || latitude &gt; lat_range-&gt;max ||</span><br><span class="line">        longitude &lt; long_range-&gt;min || longitude &gt; long_range-&gt;max) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>下面计算的两个offset，实际上就是根据传入的<code>long_range</code>和<code>lat_range</code>做min-max归一化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">double</span> lat_offset =</span><br><span class="line">        (latitude - lat_range-&gt;min) / (lat_range-&gt;max - lat_range-&gt;min);</span><br><span class="line">    <span class="keyword">double</span> long_offset =</span><br><span class="line">        (longitude - long_range-&gt;min) / (long_range-&gt;max - long_range-&gt;min);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接着对归一化的结果，乘以$2^{step}$<br>【Q】这是为什么呢？这里的两个offset是无量纲的比例。我们乘以<code>(1ULL &lt;&lt; step)</code>相当于就是先把地图分step次，然后找到对应的offset在的位置。所以在读取GeoHash的时候，实际上是需要知道对应的step的。我们参考<code>geoaddCommand</code>里面的调用是<code>geohashEncodeWGS84(xy[0], xy[1], GEO_STEP_MAX, &amp;hash)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* convert to fixed point based on the step size */</span></span><br><span class="line">    lat_offset *= (<span class="number">1U</span>LL &lt;&lt; step);</span><br><span class="line">    long_offset *= (<span class="number">1U</span>LL &lt;&lt; step);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来就是GeoHash算法的一个核心，也就是将得到的两个offset，按照<strong>奇数为纬度，偶数为经度</strong>的方式组成一个二进制序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    hash-&gt;bits = interleave64(lat_offset, long_offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面我们来看这个<code>interleave64</code>的实现，他看起来就像一个拉链一样，交错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Interleave lower bits of x and y, so the bits of x</span></span><br><span class="line"><span class="comment"> * are in the even positions and bits from y in the odd;</span></span><br><span class="line"><span class="comment"> * x and y must initially be less than 2**32 (65536).</span></span><br><span class="line"><span class="comment"> * From:  https://graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint64_t <span class="title">interleave64</span><span class="params">(<span class="keyword">uint32_t</span> xlo, <span class="keyword">uint32_t</span> ylo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> B[] = &#123;<span class="number">0x5555555555555555</span>ULL, <span class="number">0x3333333333333333</span>ULL,</span><br><span class="line">                                 <span class="number">0x0F0F0F0F0F0F0F0F</span>ULL, <span class="number">0x00FF00FF00FF00FF</span>ULL,</span><br><span class="line">                                 <span class="number">0x0000FFFF0000FFFF</span>ULL&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> S[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> x = xlo;</span><br><span class="line">    <span class="keyword">uint64_t</span> y = ylo;</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">4</span>])) &amp; B[<span class="number">4</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">4</span>])) &amp; B[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">3</span>])) &amp; B[<span class="number">3</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">3</span>])) &amp; B[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">2</span>])) &amp; B[<span class="number">2</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">2</span>])) &amp; B[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">1</span>])) &amp; B[<span class="number">1</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">1</span>])) &amp; B[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    x = (x | (x &lt;&lt; S[<span class="number">0</span>])) &amp; B[<span class="number">0</span>];</span><br><span class="line">    y = (y | (y &lt;&lt; S[<span class="number">0</span>])) &amp; B[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x | (y &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们不妨以一个<a href="https://ideone.com/tajz9a" target="_blank" rel="noopener">32位的<code>0xffff</code>进行调试</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x (ffffffff)11111111111111111111111111111111 </span><br><span class="line">y (0) </span><br><span class="line">S 4: x (ffff0000ffff)                   111111111111111100000000000000001111111111111111</span><br><span class="line">S 4: y (0) </span><br><span class="line">S 3: x (ff00ff00ff00ff)         11111111000000001111111100000000111111110000000011111111</span><br><span class="line">S 3: y (0) </span><br><span class="line">S 2: x (f0f0f0f0f0f0f0f)    111100001111000011110000111100001111000011110000111100001111</span><br><span class="line">S 2: y (0) </span><br><span class="line">S 1: x (3333333333333333) 11001100110011001100110011001100110011001100110011001100110011</span><br><span class="line">S 1: y (0) </span><br><span class="line">S 0: x (5555555555555555)101010101010101010101010101010101010101010101010101010101010101</span><br><span class="line">S 0: y (0)</span><br></pre></td></tr></table></figure>

<h2 id="GEORADIUS-GEORADIUSBYMEMBER"><a href="#GEORADIUS-GEORADIUSBYMEMBER" class="headerlink" title="GEORADIUS/GEORADIUSBYMEMBER"></a>GEORADIUS/GEORADIUSBYMEMBER</h2><h3 id="GeoHashRadius类"><a href="#GeoHashRadius类" class="headerlink" title="GeoHashRadius类"></a>GeoHashRadius类</h3><p>这个类是一个非常大的上下文，包含了一个GEOHASH位置本身，以及他解码后实际的经纬度，以及它的八个邻居的GeoHashBits。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GeoHashBits hash;</span><br><span class="line">    GeoHashArea area;</span><br><span class="line">    GeoHashNeighbors neighbors;</span><br><span class="line">&#125; GeoHashRadius;</span><br></pre></td></tr></table></figure>

<p>GeoHashBits之前介绍过，包含哈希位bits和精度step，也就是一个GEOHASH地址，表示一块区域。<br>GeoHashArea的定义如下所示，它实际上就是对hash值的一个经纬度的表示，可以由<code>geohashDecode</code>算得。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GeoHashBits hash;</span><br><span class="line">    GeoHashRange longitude;</span><br><span class="line">    GeoHashRange latitude;</span><br><span class="line">&#125; GeoHashArea;</span><br></pre></td></tr></table></figure>

<p>GeoHashNeighbors表示周围八个区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    GeoHashBits north;</span><br><span class="line">    GeoHashBits east;</span><br><span class="line">    GeoHashBits west;</span><br><span class="line">    GeoHashBits south;</span><br><span class="line">    GeoHashBits north_east;</span><br><span class="line">    GeoHashBits south_east;</span><br><span class="line">    GeoHashBits north_west;</span><br><span class="line">    GeoHashBits south_west;</span><br><span class="line">&#125; GeoHashNeighbors;</span><br></pre></td></tr></table></figure>

<h3 id="georadiusGeneric函数"><a href="#georadiusGeneric函数" class="headerlink" title="georadiusGeneric函数"></a>georadiusGeneric函数</h3><p>在很多应用中有查找附近的人这样的功能，这就可以通过<code>GEORADIUSBYMEMBER</code>命令来实现。<br>【Q】在启用了GEOHASH之后，两个hash值越接近，说明两个点距离越近。所以说，这个函数是不是可以直接匹配前缀呢？答案是不行的，因为这样会漏掉跨边界的情况。如下图所示，如果我们采用前缀匹配的方式，则红点和蓝点的前缀更为接近，但实际上它和黄点的实际距离更近。所以在搜索时，我们要搜索周围的8个方块。</p>
<p><img src="/img/redis_object/geohash_border.png"></p>
<p>这个函数包含两部分：</p>
<ol>
<li>geohashGetAreasByRadius获得上下文GeoHashRadius</li>
<li>membersOfAllNeighbors得到所有满足条件的点</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]</span></span><br><span class="line"><span class="comment"> *                               [COUNT count] [STORE key] [STOREDIST key]</span></span><br><span class="line"><span class="comment"> * GEORADIUSBYMEMBER key member radius unit ... options ... */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">georadiusGeneric</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *storekey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> storedist = <span class="number">0</span>; <span class="comment">/* 0 for STORE, 1 for STOREDIST. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Look up the requested zset */</span></span><br><span class="line">    robj *zobj = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((zobj = lookupKeyReadOrReply(c, key, shared.emptyarray)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c, zobj, OBJ_ZSET)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find long/lat to use for radius search based on inquiry type */</span></span><br><span class="line">    <span class="keyword">int</span> base_args;</span><br><span class="line">    <span class="keyword">double</span> xy[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; RADIUS_COORDS) &#123;</span><br><span class="line">        base_args = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">if</span> (extractLongLatOrReply(c, c-&gt;argv + <span class="number">2</span>, xy) == C_ERR)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; RADIUS_MEMBER) &#123;</span><br><span class="line">        base_args = <span class="number">5</span>;</span><br><span class="line">        robj *member = c-&gt;argv[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (longLatFromMember(zobj, member, xy) == C_ERR) &#123;</span><br><span class="line">            addReplyError(c, <span class="string">"could not decode requested zset member"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addReplyError(c, <span class="string">"Unknown georadius search type"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Extract radius and units from arguments */</span></span><br><span class="line">    <span class="keyword">double</span> radius_meters = <span class="number">0</span>, conversion = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((radius_meters = extractDistanceOrReply(c, c-&gt;argv + base_args - <span class="number">2</span>,</span><br><span class="line">                                                &amp;conversion)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Discover and populate all optional parameters. */</span></span><br><span class="line">    <span class="keyword">int</span> withdist = <span class="number">0</span>, withhash = <span class="number">0</span>, withcoords = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sort = SORT_NONE;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc &gt; base_args) &#123;</span><br><span class="line">	    <span class="comment">// 这里面一堆对命令参数的判断，就省略了</span></span><br><span class="line">		...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Trap options not compatible with STORE and STOREDIST. */</span></span><br><span class="line">    <span class="keyword">if</span> (storekey &amp;&amp; (withdist || withhash || withcoords)) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">"STORE option in GEORADIUS is not compatible with "</span></span><br><span class="line">            <span class="string">"WITHDIST, WITHHASH and WITHCOORDS options"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* COUNT without ordering does not make much sense, force ASC</span></span><br><span class="line"><span class="comment">     * ordering if COUNT was specified but no sorting was requested. */</span></span><br><span class="line">    <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; sort == SORT_NONE) sort = SORT_ASC;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>函数<code>geohashGetAreasByRadiusWGS84</code>（实际上是<code>geohashGetAreasByRadius</code>）根据中心点位置<code>xy</code>和搜索范围距离<code>radius_meters</code>计算<code>georadius</code>，这个<code>GeoHashRadius georadius</code>可以理解为是一个上下文对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Get all neighbor geohash boxes for our radius search */</span></span><br><span class="line">    GeoHashRadius georadius =</span><br><span class="line">        geohashGetAreasByRadiusWGS84(xy[<span class="number">0</span>], xy[<span class="number">1</span>], radius_meters);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>函数<code>membersOfAllNeighbors</code>对中心点以及它周边八个方向进行查找，找出所有范围内的元素，返回满足搜索距离范围的点。该函数中依次对中心点及周边8个区块调用<code>membersOfGeoHashBox</code>函数。这个函数比较厉害，我们后面单独讲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Search the zset for all matching points */</span></span><br><span class="line">    geoArray *ga = geoArrayCreate();</span><br><span class="line">    membersOfAllNeighbors(zobj, georadius, xy[<span class="number">0</span>], xy[<span class="number">1</span>], radius_meters, ga);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果我们找不到对应的点，那么就返回一个空的Array。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* If no matching results, the user gets an empty reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (ga-&gt;used == <span class="number">0</span> &amp;&amp; storekey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        addReply(c,shared.emptyarray);</span><br><span class="line">        geoArrayFree(ga);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>否则我们就进行排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">long</span> result_length = ga-&gt;used;</span><br><span class="line">    <span class="keyword">long</span> returned_items = (count == <span class="number">0</span> || result_length &lt; count) ?</span><br><span class="line">                          result_length : count;</span><br><span class="line">    <span class="keyword">long</span> option_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process [optional] requested sorting */</span></span><br><span class="line">    <span class="keyword">if</span> (sort == SORT_ASC) &#123;</span><br><span class="line">        qsort(ga-&gt;<span class="built_in">array</span>, result_length, <span class="keyword">sizeof</span>(geoPoint), sort_gp_asc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sort == SORT_DESC) &#123;</span><br><span class="line">        qsort(ga-&gt;<span class="built_in">array</span>, result_length, <span class="keyword">sizeof</span>(geoPoint), sort_gp_desc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storekey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* No target key, return results to user. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Our options are self-contained nested multibulk replies, so we</span></span><br><span class="line"><span class="comment">         * only need to track how many of those nested replies we return. */</span></span><br><span class="line">        <span class="keyword">if</span> (withdist)</span><br><span class="line">            option_length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (withcoords)</span><br><span class="line">            option_length++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (withhash)</span><br><span class="line">            option_length++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The array len we send is exactly result_length. The result is</span></span><br><span class="line"><span class="comment">         * either all strings of just zset members  *or* a nested multi-bulk</span></span><br><span class="line"><span class="comment">         * reply containing the zset member string _and_ all the additional</span></span><br><span class="line"><span class="comment">         * options the user enabled for this request. */</span></span><br><span class="line">        addReplyArrayLen(c, returned_items);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Finally send results back to the caller */</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; returned_items; i++) &#123;</span><br><span class="line">            geoPoint *gp = ga-&gt;<span class="built_in">array</span>+i;</span><br><span class="line">            gp-&gt;dist /= conversion; <span class="comment">/* Fix according to unit. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have options in option_length, return each sub-result</span></span><br><span class="line"><span class="comment">             * as a nested multi-bulk.  Add 1 to account for result value</span></span><br><span class="line"><span class="comment">             * itself. */</span></span><br><span class="line">            <span class="keyword">if</span> (option_length)</span><br><span class="line">                addReplyArrayLen(c, option_length + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            addReplyBulkSds(c,gp-&gt;member);</span><br><span class="line">            gp-&gt;member = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withdist)</span><br><span class="line">                addReplyDoubleDistance(c, gp-&gt;dist);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withhash)</span><br><span class="line">                addReplyLongLong(c, gp-&gt;score);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (withcoords) &#123;</span><br><span class="line">                addReplyArrayLen(c, <span class="number">2</span>);</span><br><span class="line">                addReplyHumanLongDouble(c, gp-&gt;longitude);</span><br><span class="line">                addReplyHumanLongDouble(c, gp-&gt;latitude);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Target key, create a sorted set with the results. */</span></span><br><span class="line">        robj *zobj;</span><br><span class="line">        zset *zs;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">size_t</span> maxelelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (returned_items) &#123;</span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">            zs = zobj-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; returned_items; i++) &#123;</span><br><span class="line">            zskiplistNode *znode;</span><br><span class="line">            geoPoint *gp = ga-&gt;<span class="built_in">array</span>+i;</span><br><span class="line">            gp-&gt;dist /= conversion; <span class="comment">/* Fix according to unit. */</span></span><br><span class="line">            <span class="keyword">double</span> score = storedist ? gp-&gt;dist : gp-&gt;score;</span><br><span class="line">            <span class="keyword">size_t</span> elelen = sdslen(gp-&gt;member);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (maxelelen &lt; elelen) maxelelen = elelen;</span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,gp-&gt;member);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,gp-&gt;member,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            gp-&gt;member = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (returned_items) &#123;</span><br><span class="line">            zsetConvertToZiplistIfNeeded(zobj,maxelelen);</span><br><span class="line">            setKey(c,c-&gt;db,storekey,zobj);</span><br><span class="line">            decrRefCount(zobj);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_ZSET,<span class="string">"georadiusstore"</span>,storekey,</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty += returned_items;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dbDelete(c-&gt;db,storekey)) &#123;</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,storekey);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,storekey,c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">        &#125;</span><br><span class="line">        addReplyLongLong(c, returned_items);</span><br><span class="line">    &#125;</span><br><span class="line">    geoArrayFree(ga);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="geohashGetAreasByRadius"><a href="#geohashGetAreasByRadius" class="headerlink" title="geohashGetAreasByRadius"></a>geohashGetAreasByRadius</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">GeoHashRadius <span class="title">geohashGetAreasByRadius</span><span class="params">(<span class="keyword">double</span> longitude, <span class="keyword">double</span> latitude, <span class="keyword">double</span> radius_meters)</span> </span>&#123;</span><br><span class="line">    GeoHashRange long_range, lat_range;</span><br><span class="line">    GeoHashRadius radius;</span><br><span class="line">    GeoHashBits hash;</span><br><span class="line">    GeoHashNeighbors neighbors;</span><br><span class="line">    GeoHashArea area;</span><br><span class="line">    <span class="keyword">double</span> min_lon, max_lon, min_lat, max_lat;</span><br><span class="line">    <span class="keyword">double</span> bounds[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> steps;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们首先以<code>(longitude, latitude, radius_meters)</code>构造一个圆，我们通过<code>geohashBoundingBox</code>计算这个圆的外接矩形的经纬度范围。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    geohashBoundingBox(longitude, latitude, radius_meters, bounds);</span><br><span class="line">    min_lon = bounds[<span class="number">0</span>];</span><br><span class="line">    min_lat = bounds[<span class="number">1</span>];</span><br><span class="line">    max_lon = bounds[<span class="number">2</span>];</span><br><span class="line">    max_lat = bounds[<span class="number">3</span>];</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>接下来，我们要计算精度steps。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    steps = geohashEstimateStepsByRadius(radius_meters,latitude);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>geohashGetCoordRange</code>函数没鸟用，就是单纯用<code>GEO_LONG_MAX/GEO_LONG_MIN</code>设置一下range，得到的range被用来做Encode。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    geohashGetCoordRange(&amp;long_range,&amp;lat_range);</span><br><span class="line">    geohashEncode(&amp;long_range,&amp;lat_range,longitude,latitude,steps,&amp;hash);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>计算所有的邻居。这里的<code>neighbors</code>是<code>GeoHashNeighbors</code>结构的指针，这个结构里面保存了周围8个块的GeoHashBits。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    geohashNeighbors(&amp;hash,&amp;neighbors);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>把一个GEOHASH值，解码成经纬度的表示<code>area</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    geohashDecode(long_range,lat_range,hash,&amp;area);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们需要检查自己算出来的step是否足够。下面的注释说有的时候，search area太靠近area的边缘了，step就还不够小，因为东南西北侧的正方形太靠近search area，以至于无法覆盖所有的东西。<br>【Q】反正我是没懂search area和area的区别是啥？<br>反正对于这种情况，我们需要再减小一下step。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Check if the step is enough at the limits of the covered area.</span></span><br><span class="line"><span class="comment">     * Sometimes when the search area is near an edge of the</span></span><br><span class="line"><span class="comment">     * area, the estimated step is not small enough, since one of the</span></span><br><span class="line"><span class="comment">     * north / south / west / east square is too near to the search area</span></span><br><span class="line"><span class="comment">     * to cover everything. */</span></span><br><span class="line">    <span class="keyword">int</span> decrease_step = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        GeoHashArea north, south, east, west;</span><br><span class="line"></span><br><span class="line">        geohashDecode(long_range, lat_range, neighbors.north, &amp;north);</span><br><span class="line">        geohashDecode(long_range, lat_range, neighbors.south, &amp;south);</span><br><span class="line">        geohashDecode(long_range, lat_range, neighbors.east, &amp;east);</span><br><span class="line">        geohashDecode(long_range, lat_range, neighbors.west, &amp;west);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (geohashGetDistance(longitude,latitude,longitude,north.latitude.max)</span><br><span class="line">            &lt; radius_meters) decrease_step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (geohashGetDistance(longitude,latitude,longitude,south.latitude.min)</span><br><span class="line">            &lt; radius_meters) decrease_step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (geohashGetDistance(longitude,latitude,east.longitude.max,latitude)</span><br><span class="line">            &lt; radius_meters) decrease_step = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (geohashGetDistance(longitude,latitude,west.longitude.min,latitude)</span><br><span class="line">            &lt; radius_meters) decrease_step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (steps &gt; <span class="number">1</span> &amp;&amp; decrease_step) &#123;</span><br><span class="line">        steps--;</span><br><span class="line">        geohashEncode(&amp;long_range,&amp;lat_range,longitude,latitude,steps,&amp;hash);</span><br><span class="line">        geohashNeighbors(&amp;hash,&amp;neighbors);</span><br><span class="line">        geohashDecode(long_range,lat_range,hash,&amp;area);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Exclude the search areas that are useless. */</span></span><br><span class="line">    <span class="keyword">if</span> (steps &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (area.latitude.min &lt; min_lat) &#123;</span><br><span class="line">            GZERO(neighbors.south);</span><br><span class="line">            GZERO(neighbors.south_west);</span><br><span class="line">            GZERO(neighbors.south_east);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (area.latitude.max &gt; max_lat) &#123;</span><br><span class="line">            GZERO(neighbors.north);</span><br><span class="line">            GZERO(neighbors.north_east);</span><br><span class="line">            GZERO(neighbors.north_west);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (area.longitude.min &lt; min_lon) &#123;</span><br><span class="line">            GZERO(neighbors.west);</span><br><span class="line">            GZERO(neighbors.south_west);</span><br><span class="line">            GZERO(neighbors.north_west);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (area.longitude.max &gt; max_lon) &#123;</span><br><span class="line">            GZERO(neighbors.east);</span><br><span class="line">            GZERO(neighbors.south_east);</span><br><span class="line">            GZERO(neighbors.north_east);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    radius.hash = hash;</span><br><span class="line">    radius.neighbors = neighbors;</span><br><span class="line">    radius.area = area;</span><br><span class="line">    <span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="membersOfAllNeighbors"><a href="#membersOfAllNeighbors" class="headerlink" title="membersOfAllNeighbors"></a>membersOfAllNeighbors</h2><p>这里讲解一下返回值<code>geoArray</code>，这是一个简单的数组，<code>buckets</code>和<code>used</code>让我们联想到了之前的<code>dict</code>等结构。实际上，它也就是保存了一些列的点。buckets表示数组的容量，used表示实际数组用了多少。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">geoPoint</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> longitude;</span><br><span class="line">    <span class="keyword">double</span> latitude;</span><br><span class="line">    <span class="keyword">double</span> dist;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="keyword">char</span> *member;</span><br><span class="line">&#125; geoPoint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">geoArray</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">geoPoint</span> *<span class="title">array</span>;</span></span><br><span class="line">    <span class="keyword">size_t</span> buckets;</span><br><span class="line">    <span class="keyword">size_t</span> used;</span><br><span class="line">&#125; geoArray;</span><br></pre></td></tr></table></figure>

<p>下面看主体函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Search all eight neighbors + self geohash box */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">membersOfAllNeighbors</span><span class="params">(robj *zobj, GeoHashRadius n, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">double</span> radius, geoArray *ga)</span> </span>&#123;</span><br><span class="line">    GeoHashBits neighbors[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, count = <span class="number">0</span>, last_processed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> debugmsg = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    neighbors[<span class="number">0</span>] = n.hash;</span><br><span class="line">    neighbors[<span class="number">1</span>] = n.neighbors.north;</span><br><span class="line">    neighbors[<span class="number">2</span>] = n.neighbors.south;</span><br><span class="line">    neighbors[<span class="number">3</span>] = n.neighbors.east;</span><br><span class="line">    neighbors[<span class="number">4</span>] = n.neighbors.west;</span><br><span class="line">    neighbors[<span class="number">5</span>] = n.neighbors.north_east;</span><br><span class="line">    neighbors[<span class="number">6</span>] = n.neighbors.north_west;</span><br><span class="line">    neighbors[<span class="number">7</span>] = n.neighbors.south_east;</span><br><span class="line">    neighbors[<span class="number">8</span>] = n.neighbors.south_west;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主要逻辑就是遍历所有的<code>neighbors</code>，并调用<code>membersOfGeoHashBox</code>。这里唯一值得一提的逻辑是，如果说我们的半径范围很大，例如超过5000km了，那么neighbour可能会重复，所以我们判断一下重复的neighbour。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* For each neighbor (*and* our own hashbox), get all the matching</span></span><br><span class="line"><span class="comment">     * members and add them to the potential result list. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(neighbors) / <span class="keyword">sizeof</span>(*neighbors); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HASHISZERO(neighbors[i])) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debugmsg) D(<span class="string">"neighbors[%d] is zero"</span>,i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Debugging info. */</span></span><br><span class="line">        <span class="keyword">if</span> (debugmsg) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When a huge Radius (in the 5000 km range or more) is used,</span></span><br><span class="line"><span class="comment">         * adjacent neighbors can be the same, leading to duplicated</span></span><br><span class="line"><span class="comment">         * elements. Skip every range which is the same as the one</span></span><br><span class="line"><span class="comment">         * processed previously. */</span></span><br><span class="line">        <span class="keyword">if</span> (last_processed &amp;&amp;</span><br><span class="line">            neighbors[i].bits == neighbors[last_processed].bits &amp;&amp;</span><br><span class="line">            neighbors[i].step == neighbors[last_processed].step)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (debugmsg)</span><br><span class="line">                D(<span class="string">"Skipping processing of %d, same as previous\n"</span>,i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += membersOfGeoHashBox(zobj, neighbors[i], ga, lon, lat, radius);</span><br><span class="line">        last_processed = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="membersOfGeoHashBox"><a href="#membersOfGeoHashBox" class="headerlink" title="membersOfGeoHashBox"></a>membersOfGeoHashBox</h3><p>首先，我们根据hash，通过<code>scoresOfGeoHashBox</code>算出这个里面的位置点对应在ZSET中的score的范围。这个函数的实现，我们稍后讲。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Obtain all members between the min/max of this geohash bounding box.</span></span><br><span class="line"><span class="comment"> * Populate a geoArray of GeoPoints by calling geoGetPointsInRange().</span></span><br><span class="line"><span class="comment"> * Return the number of points added to the array. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">membersOfGeoHashBox</span><span class="params">(robj *zobj, GeoHashBits hash, geoArray *ga, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">    GeoHashFix52Bits min, max;</span><br><span class="line"></span><br><span class="line">    scoresOfGeoHashBox(hash,&amp;min,&amp;max);</span><br><span class="line">    <span class="keyword">return</span> geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scoresOfGeoHashBox"><a href="#scoresOfGeoHashBox" class="headerlink" title="scoresOfGeoHashBox"></a>scoresOfGeoHashBox</h3><p>如果step是3，那么我们的hash就有<code>step * 2 = 6</code>个有效位。例如，二进制的hash值，即bits是101010。<br>但是因为我们的分数是52位的，我们需要获取<code>101010?????????????????????????????????????????????</code>的范围，所以我们要在101010后面填充，让它对齐成52bit。<br>因为我们补齐部分的<code>?</code>可以取0，也可以取1，所以我们可以直接自增二进制的hash值即bits。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compute the sorted set scores min (inclusive), max (exclusive) we should</span></span><br><span class="line"><span class="comment"> * query in order to retrieve all the elements inside the specified area</span></span><br><span class="line"><span class="comment"> * 'hash'. The two scores are returned by reference in *min and *max. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scoresOfGeoHashBox</span><span class="params">(GeoHashBits hash, GeoHashFix52Bits *min, GeoHashFix52Bits *max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* We want to compute the sorted set scores that will include all the</span></span><br><span class="line"><span class="comment">     * elements inside the specified Geohash 'hash', which has as many</span></span><br><span class="line"><span class="comment">     * bits as specified by hash.step * 2.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * To get the min score we just use the initial hash value left</span></span><br><span class="line"><span class="comment">     * shifted enough to get the 52 bit value. Later we increment the</span></span><br><span class="line"><span class="comment">     * 6 bit prefis (see the hash.bits++ statement), and get the new</span></span><br><span class="line"><span class="comment">     * prefix: 101011, which we align again to 52 bits to get the maximum</span></span><br><span class="line"><span class="comment">     * value (which is excluded from the search). So we get everything</span></span><br><span class="line"><span class="comment">     * between the two following scores (represented in binary):</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1010100000000000000000000000000000000000000000000000 (included)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     * 1010110000000000000000000000000000000000000000000000 (excluded).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *min = geohashAlign52Bits(hash);</span><br><span class="line">    hash.bits++;</span><br><span class="line">    *max = geohashAlign52Bits(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geoGetPointsInRange"><a href="#geoGetPointsInRange" class="headerlink" title="geoGetPointsInRange"></a>geoGetPointsInRange</h3><p>在<code>membersOfAllNeighbors</code>中，ga最后是通过<code>geoGetPointsInRange</code>设置的。<br><code>geoGetPointsInRange</code>在ZSET中查找score位于min和max之间的所有元素，然后再通过<code>geoAppendIfWithinRadius</code>用<code>(log,lat,radius)</code>条件过滤一遍，将符合要求的点通过<code>geoArrayAppend</code>加入到ga中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * The ability of this function to append to an existing set of points is</span></span><br><span class="line"><span class="comment"> * important for good performances because querying by radius is performed</span></span><br><span class="line"><span class="comment"> * using multiple queries to the sorted set, that we later need to sort</span></span><br><span class="line"><span class="comment"> * via qsort. Similarly we need to be able to reject points outside the search</span></span><br><span class="line"><span class="comment"> * radius area ASAP in order to allocate and process more points than needed. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geoGetPointsInRange</span><span class="params">(robj *zobj, <span class="keyword">double</span> min, <span class="keyword">double</span> max, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">double</span> radius, geoArray *ga)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* minex 0 = include min in range; maxex 1 = exclude max in range */</span></span><br><span class="line">    <span class="comment">/* That's: min &lt;= val &lt; max */</span></span><br><span class="line">    zrangespec range = &#123; .min = min, .max = max, .minex = <span class="number">0</span>, .maxex = <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">size_t</span> origincount = ga-&gt;used;</span><br><span class="line">    sds member;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFirstInRange(zl, &amp;range)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing exists starting at our min.  No results. */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sptr = ziplistNext(zl, eptr);</span><br><span class="line">        <span class="keyword">while</span> (eptr) &#123;</span><br><span class="line">            score = zzlGetScore(sptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we fell out of range, break. */</span></span><br><span class="line">            <span class="keyword">if</span> (!zslValueLteMax(score, &amp;range))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We know the element exists. ziplistGet should always succeed */</span></span><br><span class="line">            ziplistGet(eptr, &amp;vstr, &amp;vlen, &amp;vlong);</span><br><span class="line">            member = (vstr == <span class="literal">NULL</span>) ? sdsfromlonglong(vlong) :</span><br><span class="line">                                      sdsnewlen(vstr,vlen);</span><br><span class="line">            <span class="keyword">if</span> (geoAppendIfWithinRadius(ga,lon,lat,radius,score,member)</span><br><span class="line">                == C_ERR) sdsfree(member);</span><br><span class="line">            zzlNext(zl, &amp;eptr, &amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line">        zskiplistNode *ln;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((ln = zslFirstInRange(zsl, &amp;range)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing exists starting at our min.  No results. */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ln) &#123;</span><br><span class="line">            sds ele = ln-&gt;ele;</span><br><span class="line">            <span class="comment">/* Abort when the node is no longer in range. */</span></span><br><span class="line">            <span class="keyword">if</span> (!zslValueLteMax(ln-&gt;score, &amp;range))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            <span class="keyword">if</span> (geoAppendIfWithinRadius(ga,lon,lat,radius,ln-&gt;score,ele)</span><br><span class="line">                == C_ERR) sdsfree(ele);</span><br><span class="line">            ln = ln-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ga-&gt;used - origincount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="geoAppendIfWithinRadius"><a href="#geoAppendIfWithinRadius" class="headerlink" title="geoAppendIfWithinRadius"></a>geoAppendIfWithinRadius</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Helper function for geoGetPointsInRange(): given a sorted set score</span></span><br><span class="line"><span class="comment"> * representing a point, and another point (the center of our search) and</span></span><br><span class="line"><span class="comment"> * a radius, appends this entry as a geoPoint into the specified geoArray</span></span><br><span class="line"><span class="comment"> * only if the point is within the search area.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * returns C_OK if the point is included, or REIDS_ERR if it is outside. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">geoAppendIfWithinRadius</span><span class="params">(geoArray *ga, <span class="keyword">double</span> lon, <span class="keyword">double</span> lat, <span class="keyword">double</span> radius, <span class="keyword">double</span> score, sds member)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> distance, xy[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!decodeGeohash(score,xy)) <span class="keyword">return</span> C_ERR; <span class="comment">/* Can't decode. */</span></span><br><span class="line">    <span class="comment">/* Note that geohashGetDistanceIfInRadiusWGS84() takes arguments in</span></span><br><span class="line"><span class="comment">     * reverse order: longitude first, latitude later. */</span></span><br><span class="line">    <span class="keyword">if</span> (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[<span class="number">0</span>], xy[<span class="number">1</span>],</span><br><span class="line">                                           radius, &amp;distance))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append the new element. */</span></span><br><span class="line">    geoPoint *gp = geoArrayAppend(ga);</span><br><span class="line">    gp-&gt;longitude = xy[<span class="number">0</span>];</span><br><span class="line">    gp-&gt;latitude = xy[<span class="number">1</span>];</span><br><span class="line">    gp-&gt;dist = distance;</span><br><span class="line">    gp-&gt;member = member;</span><br><span class="line">    gp-&gt;score = score;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Rax"><a href="#Rax" class="headerlink" title="Rax"></a>Rax</h1><p>Redis还提供了一个基数树的实现。这个实现被用作Redis Cluster模式下面存储slot对应的所有key的信息。此外，在Stream、RDB、客户端缓存等模块中也用到了这个数据结构。</p>
<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h1 id="zipmap"><a href="#zipmap" class="headerlink" title="zipmap"></a>zipmap</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下本章节中比较有意思的实现：</p>
<ol>
<li>sds可以通过一个指针同时访问header和data。</li>
<li>sds的多种大小的header以节省空间。</li>
<li>hash表的reverse binary iteration。</li>
<li>跳表实现中的span，用来方便计算rank。</li>
<li>hyperloglog算法。</li>
<li>redis实现hyperloglog算法中技巧：<ol>
<li>分桶。</li>
<li>使用Sparse模式解决连续桶为0的情况，从而大大节省空间。这个方案可以被用来参考实现压缩稀疏的一维线性数据。</li>
<li>在8bit数组中维护6bit元素。</li>
</ol>
</li>
<li>geohash中interleave组合经度和纬度。</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://xiking.win/2018/11/07/reverse-binary-iteration/" target="_blank" rel="noopener">https://xiking.win/2018/11/07/reverse-binary-iteration/</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/90125709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/90125709</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/数据库/" rel="tag"># 数据库</a>
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/17/subprocess_usage/" rel="next" title="subprocess模块用法">
                <i class="fa fa-chevron-left"></i> subprocess模块用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/01/python-join-no-signal/" rel="prev" title="Python中join不能响应信号的问题">
                Python中join不能响应信号的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">240</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">151</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#SDS"><span class="nav-number">1.</span> <span class="nav-text">SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建"><span class="nav-number">1.1.</span> <span class="nav-text">创建</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#list"><span class="nav-number">2.</span> <span class="nav-text">list</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#dict"><span class="nav-number">3.</span> <span class="nav-text">dict</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#dict的基本实现与Rehash机制"><span class="nav-number">3.1.</span> <span class="nav-text">dict的基本实现与Rehash机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dictEntry、dictType、dictht"><span class="nav-number">3.1.1.</span> <span class="nav-text">dictEntry、dictType、dictht</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">3.1.2.</span> <span class="nav-text">Hash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dict和dictAdd"><span class="nav-number">3.1.3.</span> <span class="nav-text">dict和dictAdd</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查是否已经存在"><span class="nav-number">3.1.3.1.</span> <span class="nav-text">检查是否已经存在</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表的扩容"><span class="nav-number">3.1.4.</span> <span class="nav-text">哈希表的扩容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rehash"><span class="nav-number">3.1.5.</span> <span class="nav-text">Rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ht-0-和ht-1-的顺序"><span class="nav-number">3.1.5.1.</span> <span class="nav-text">ht[0]和ht[1]的顺序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历机制-dictScan"><span class="nav-number">3.2.</span> <span class="nav-text">遍历机制(dictScan)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#遍历机制-迭代器"><span class="nav-number">3.3.</span> <span class="nav-text">遍历机制(迭代器)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dict迭代器相关方法"><span class="nav-number">3.3.1.</span> <span class="nav-text">dict迭代器相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dictNext"><span class="nav-number">3.3.1.1.</span> <span class="nav-text">dictNext</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dict的其他相关方法"><span class="nav-number">3.4.</span> <span class="nav-text">dict的其他相关方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#dict遍历抽象主干代码"><span class="nav-number">3.4.1.</span> <span class="nav-text">dict遍历抽象主干代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictFind"><span class="nav-number">3.4.2.</span> <span class="nav-text">dictFind</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictGet系列函数"><span class="nav-number">3.4.3.</span> <span class="nav-text">dictGet系列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dictDelete和dictGenericDelete"><span class="nav-number">3.4.4.</span> <span class="nav-text">dictDelete和dictGenericDelete</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HSET的相关数据结构"><span class="nav-number">3.5.</span> <span class="nav-text">HSET的相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hset实现"><span class="nav-number">3.5.1.</span> <span class="nav-text">hset实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ZSET"><span class="nav-number">4.</span> <span class="nav-text">ZSET</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ZSET和zadd"><span class="nav-number">4.1.</span> <span class="nav-text">ZSET和zadd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zsetAdd的实现"><span class="nav-number">4.2.</span> <span class="nav-text">zsetAdd的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zsetAdd"><span class="nav-number">4.2.1.</span> <span class="nav-text">zsetAdd</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ziplist存储的分支"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">ziplist存储的分支</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳表存储的分支"><span class="nav-number">4.2.1.2.</span> <span class="nav-text">跳表存储的分支</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#zsetConvert"><span class="nav-number">4.2.2.</span> <span class="nav-text">zsetConvert</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zrangeGenericCommand"><span class="nav-number">4.3.</span> <span class="nav-text">zrangeGenericCommand</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zskiplist"><span class="nav-number">5.</span> <span class="nav-text">zskiplist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本数据结构"><span class="nav-number">5.1.</span> <span class="nav-text">基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#zslCreateNode"><span class="nav-number">5.1.1.</span> <span class="nav-text">zslCreateNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表数据结构的展现"><span class="nav-number">5.1.2.</span> <span class="nav-text">跳表数据结构的展现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslInsert的实现"><span class="nav-number">5.2.</span> <span class="nav-text">zslInsert的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#跳表遍历抽象主干代码"><span class="nav-number">5.2.1.</span> <span class="nav-text">跳表遍历抽象主干代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslGetRank实现"><span class="nav-number">5.3.</span> <span class="nav-text">zslGetRank实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslUpdateScore的实现"><span class="nav-number">5.4.</span> <span class="nav-text">zslUpdateScore的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zslGetElementByRank的实现"><span class="nav-number">5.5.</span> <span class="nav-text">zslGetElementByRank的实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ziplist"><span class="nav-number">6.</span> <span class="nav-text">ziplist</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#格式与创建"><span class="nav-number">6.1.</span> <span class="nav-text">格式与创建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">6.1.1.</span> <span class="nav-text">格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HyperLogLog"><span class="nav-number">7.</span> <span class="nav-text">HyperLogLog</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HLL原理"><span class="nav-number">7.1.</span> <span class="nav-text">HLL原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis的HLL的基本结构"><span class="nav-number">7.2.</span> <span class="nav-text">Redis的HLL的基本结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dense和Sparse结构"><span class="nav-number">7.2.1.</span> <span class="nav-text">Dense和Sparse结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HLL的空间占用"><span class="nav-number">7.2.2.</span> <span class="nav-text">HLL的空间占用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#createHLLObject实现"><span class="nav-number">7.3.</span> <span class="nav-text">createHLLObject实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd实现"><span class="nav-number">7.4.</span> <span class="nav-text">pfadd实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd的Dense实现"><span class="nav-number">7.5.</span> <span class="nav-text">pfadd的Dense实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#hllDenseAdd"><span class="nav-number">7.5.1.</span> <span class="nav-text">hllDenseAdd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllPatLen"><span class="nav-number">7.5.2.</span> <span class="nav-text">hllPatLen</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Demo"><span class="nav-number">7.5.2.1.</span> <span class="nav-text">Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllDenseSet"><span class="nav-number">7.5.3.</span> <span class="nav-text">hllDenseSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfadd的Sparse实现"><span class="nav-number">7.6.</span> <span class="nav-text">pfadd的Sparse实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#几个宏"><span class="nav-number">7.6.1.</span> <span class="nav-text">几个宏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllSparseAdd"><span class="nav-number">7.6.2.</span> <span class="nav-text">hllSparseAdd</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllSparseSet"><span class="nav-number">7.6.3.</span> <span class="nav-text">hllSparseSet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pfcount实现"><span class="nav-number">7.7.</span> <span class="nav-text">pfcount实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pfcountCommand函数"><span class="nav-number">7.7.1.</span> <span class="nav-text">pfcountCommand函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cache实现"><span class="nav-number">7.7.2.</span> <span class="nav-text">cache实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllCount函数"><span class="nav-number">7.7.3.</span> <span class="nav-text">hllCount函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一个naive的count函数"><span class="nav-number">7.7.3.1.</span> <span class="nav-text">一个naive的count函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修正"><span class="nav-number">7.7.3.1.1.</span> <span class="nav-text">修正</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#牛逼做法"><span class="nav-number">7.7.3.2.</span> <span class="nav-text">牛逼做法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllDenseRegHisto"><span class="nav-number">7.7.4.</span> <span class="nav-text">hllDenseRegHisto</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hllSparseRegHisto"><span class="nav-number">7.7.5.</span> <span class="nav-text">hllSparseRegHisto</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#intset"><span class="nav-number">8.</span> <span class="nav-text">intset</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#encoding"><span class="nav-number">8.1.</span> <span class="nav-text">encoding</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码"><span class="nav-number">8.2.</span> <span class="nav-text">编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">8.3.</span> <span class="nav-text">查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加"><span class="nav-number">8.4.</span> <span class="nav-text">添加</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大端小端宏"><span class="nav-number">8.4.1.</span> <span class="nav-text">大端小端宏</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#bitmap"><span class="nav-number">9.</span> <span class="nav-text">bitmap</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#count实现"><span class="nav-number">9.1.</span> <span class="nav-text">count实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-get实现"><span class="nav-number">9.2.</span> <span class="nav-text">set/get实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bitop"><span class="nav-number">9.3.</span> <span class="nav-text">bitop</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#quicklist"><span class="nav-number">10.</span> <span class="nav-text">quicklist</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Geo和GeoHash"><span class="nav-number">11.</span> <span class="nav-text">Geo和GeoHash</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#GEOADD"><span class="nav-number">11.1.</span> <span class="nav-text">GEOADD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#replaceClientCommandVector"><span class="nav-number">11.1.1.</span> <span class="nav-text">replaceClientCommandVector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freeClientArgv"><span class="nav-number">11.1.2.</span> <span class="nav-text">freeClientArgv</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lookupCommandOrOriginal"><span class="nav-number">11.1.3.</span> <span class="nav-text">lookupCommandOrOriginal</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEOHASH算法介绍"><span class="nav-number">11.2.</span> <span class="nav-text">GEOHASH算法介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEOHASH实现"><span class="nav-number">11.3.</span> <span class="nav-text">GEOHASH实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GeoHashBits-geohashGetCoordRange"><span class="nav-number">11.3.1.</span> <span class="nav-text">GeoHashBits/geohashGetCoordRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geohashCommand"><span class="nav-number">11.3.2.</span> <span class="nav-text">geohashCommand</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geohashEncode"><span class="nav-number">11.3.3.</span> <span class="nav-text">geohashEncode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEORADIUS-GEORADIUSBYMEMBER"><span class="nav-number">11.4.</span> <span class="nav-text">GEORADIUS/GEORADIUSBYMEMBER</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GeoHashRadius类"><span class="nav-number">11.4.1.</span> <span class="nav-text">GeoHashRadius类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#georadiusGeneric函数"><span class="nav-number">11.4.2.</span> <span class="nav-text">georadiusGeneric函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#geohashGetAreasByRadius"><span class="nav-number">11.5.</span> <span class="nav-text">geohashGetAreasByRadius</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#membersOfAllNeighbors"><span class="nav-number">11.6.</span> <span class="nav-text">membersOfAllNeighbors</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#membersOfGeoHashBox"><span class="nav-number">11.6.1.</span> <span class="nav-text">membersOfGeoHashBox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#scoresOfGeoHashBox"><span class="nav-number">11.6.2.</span> <span class="nav-text">scoresOfGeoHashBox</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geoGetPointsInRange"><span class="nav-number">11.6.3.</span> <span class="nav-text">geoGetPointsInRange</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#geoAppendIfWithinRadius"><span class="nav-number">11.6.4.</span> <span class="nav-text">geoAppendIfWithinRadius</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Rax"><span class="nav-number">12.</span> <span class="nav-text">Rax</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">13.</span> <span class="nav-text">Stream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#zipmap"><span class="nav-number">14.</span> <span class="nav-text">zipmap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">15.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">16.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2018/07/23/redis_learn_object/';
          this.page.identifier = '2018/07/23/redis_learn_object/';
          this.page.title = 'Redis底层对象实现原理分析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
