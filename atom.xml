<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2022-10-15T15:06:00.166Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis基础机制分析</title>
    <link href="http://www.calvinneo.com/2022/10/15/redis-common/"/>
    <id>http://www.calvinneo.com/2022/10/15/redis-common/</id>
    <published>2022-10-15T15:52:20.000Z</published>
    <updated>2022-10-15T15:06:00.166Z</updated>
    
    <content type="html"><![CDATA[<p>因为原<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：</p><ol><li>redisDb，以及在这上面的增删改查</li><li>Redis的expire和evict机制</li><li>Redis的事件机制</li><li>Redis的主从复制(一部分)<br> 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。<br> 本文介绍的部分比如propagate机制。</li></ol><p>本文中不介绍的是，它们在系列的其他文章中讲解：</p><ol><li>Redis的对象实现</li><li>Redis Sentinel</li><li>Redis Cluster</li><li>Redis AOF/RDB</li></ol><a id="more"></a><h1 id="Redis源码结构"><a href="#Redis源码结构" class="headerlink" title="Redis源码结构"></a>Redis源码结构</h1><p>在3.0版本中，redis的主要结构都定义在redis.h中，在新版本中，它们被放到了server.h中。</p><p>我们主要介绍</p><ol><li>一些常用的类<ol><li>redisServer</li><li>redisDb</li><li>redisObject<br> 包含添加对象的逻辑</li></ol></li><li>删除逻辑<br> 包含对同步删除和异步删除的讨论。</li><li>查找逻辑</li><li>expire</li><li>evict</li><li>propagate</li><li>事件机制</li><li>内存管理</li></ol><h1 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h1><p>这个章节中介绍Redis数据库顶层键的架构和增删改查的实现，主要包括：</p><h2 id="redisDb类"><a href="#redisDb类" class="headerlink" title="redisDb类"></a>redisDb类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间，字典的键为键，字典的值为过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 用来服务诸如BLPOP的命令，记录目前被阻塞的键 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均TTL，统计信息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>可以发现，<code>redisDb</code>本身就依赖<code>dict</code>和<code>list</code>等Redis底层结构的实现，说明Redis的复用性还是很好的。</p><h2 id="client类"><a href="#client类" class="headerlink" title="client类"></a>client类</h2><p>client类对应了3.0版本中的<code>redisClient</code>类。因为Redis对IO是多路复用的，所以需要为每个客户端连接维护一个状态，所以<code>client</code>实际上类似于session一样，是在服务器端维护的一个状态。而真正的Redis客户端定义在redis-cli.c这个文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="keyword">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br></pre></td></tr></table></figure><h2 id="redisServer类"><a href="#redisServer类" class="headerlink" title="redisServer类"></a>redisServer类</h2><p><code>server</code>是一个全局对象，它的类型是<code>redisServer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span> <span class="comment">/* Server global state */</span></span><br></pre></td></tr></table></figure><h1 id="Redis基础类"><a href="#Redis基础类" class="headerlink" title="Redis基础类"></a>Redis基础类</h1><h2 id="增删改查涉及的系统梳理"><a href="#增删改查涉及的系统梳理" class="headerlink" title="增删改查涉及的系统梳理"></a>增删改查涉及的系统梳理</h2><ol><li>DB部分<br> 更新dirty</li><li>Cluster部分</li><li>事件部分<br> signalModifiedKey：包含通知WATCH列表、通知客户端更新缓存<br> notifyKeyspaceEvent：通过PUBLUSH发送消息</li><li>主从复制/持久化部分<br> propagate对应命令（在call中处理）</li><li>Module部分</li></ol><h2 id="Redis-Object"><a href="#Redis-Object" class="headerlink" title="Redis Object"></a>Redis Object</h2><p>诸如<code>dict</code>、<code>sds</code>之类的对象，在db层面实际上是用<code>redisObject</code>封装的，需要的时候通过<code>robj-&gt;ptr</code>获取实际需要的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 由OBJ_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 由OBJ_ENCODING_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure><p>Redis对象的类型是用<code>OBJ_</code>宏来列出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The "module" object type is a special one that signals that the object</span></span><br><span class="line"><span class="comment"> * is one directly managed by a Redis module. In this case the value points</span></span><br><span class="line"><span class="comment"> * to a moduleValue struct, which contains the object value (which is only</span></span><br><span class="line"><span class="comment"> * handled by the module itself) and the RedisModuleType struct which lists</span></span><br><span class="line"><span class="comment"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span></span><br><span class="line"><span class="comment"> * free the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span></span><br><span class="line"><span class="comment"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span></span><br><span class="line"><span class="comment"> * in order to dispatch the loading to the right module, plus a 10 bits</span></span><br><span class="line"><span class="comment"> * encoding version. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br></pre></td></tr></table></figure><p>Redis对象实际使用的内部结构是用<code>OBJ_ENCODING_</code>宏来表示的，如前文所列举的，同一个对象可能有不同的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">// OBJ_ENCODING_RAW是普通的SDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="comment">// embstr是对短字符串的一种优化编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>有两种特殊的引用计数值：</p><ol><li><code>OBJ_SHARED_REFCOUNT</code><br> 由<code>makeObjectShared</code>函数生成，在这种情况下这个对象是immutable的，因此可以不加锁地进行访问。这种对象也不受<code>incrRefCount</code>/<code>decrRefCount</code>控制。<br> 注意，这种对象设为immutable是合理的，它的一个通常作用是共享小整数对象，例如Redis会共享0到9999。</li><li><code>OBJ_STATIC_REFCOUNT</code><br> 一般由<code>initStaticStringObject</code>宏生成。看上去这个一般用在在栈上面分配的临时对象的refcount，我对此也不是很确定。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX     <span class="comment">/* Global object never destroyed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STATIC_REFCOUNT (INT_MAX-1) <span class="comment">/* Object allocated in the stack. */</span></span></span><br><span class="line"><span class="comment">// 第一个有特殊含义的refcount值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT</span></span><br></pre></td></tr></table></figure></li></ol><p>一般来说，使用引用计数可能存在循环引用的问题。Redis巧妙地避免了这个问题，首先在Redis的所有<code>redisObject</code>里面，只有String会被嵌入到其他类型中，也就是说ZSET等其他的数据类型不会互相引用（在Geo等新数据结构里面也是这样的么？）。而Redis对String类型引入对象共享机制，保证了不会产生互相引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt; OBJ_FIRST_SPECIAL_REFCOUNT) &#123;</span><br><span class="line">        o-&gt;refcount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount == OBJ_SHARED_REFCOUNT) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do: this refcount is immutable. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;refcount == OBJ_STATIC_REFCOUNT) &#123;</span><br><span class="line">            serverPanic(<span class="string">"You tried to retain an object allocated in the stack"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decrRefCount</code>还负责销毁对象，步骤是<code>freeXXXObject</code>，然后在<code>zfree</code>。前者用来释放<code>o-&gt;ptr</code>指向的对象的内存，后者用来释放<code>o</code>的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解<code>incr/decrRefCount</code>，如果我们创建或者复制一个对象，就要incr，如果我们要删除一个对象就要decr。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过<code>createObject</code>创建对象，<code>refcount</code>设为1。<code>encoding</code>设为<code>OBJ_ENCODING_RAW</code>，也就是普通SDS字符串。传入的<code>type</code>是<code>OBJ_</code>宏的某个特定值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在创建完对象后，还需要通过<code>dbAdd</code>将它插入到数据库里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the key to the DB. It's up to the caller to increment the reference</span></span><br><span class="line"><span class="comment"> * counter of the value if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The program is aborted if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,retval == DICT_OK);</span><br><span class="line">    signalKeyAsReady(db, key, val-&gt;type);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key-&gt;ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象装箱拆箱"><a href="#对象装箱拆箱" class="headerlink" title="对象装箱拆箱"></a>对象装箱拆箱</h3><p>这个都是返回一个“新”对象，这里“新”的意思是在使用完这个对象都应该<code>decrRefCount</code>。<br>如果是原生encoding储存的，就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果使用SDS保存的整数，实际上里面是个long long，那么就需要先<code>ll2string</code>把这个转换成字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h2><h3 id="redisCommand对象"><a href="#redisCommand对象" class="headerlink" title="redisCommand对象"></a>redisCommand对象</h3><p>redisCommand对象有新旧很多种版本，新旧版本中存在一些区别，例如<code>sflag</code>的内容，我们以新版本为主。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags; <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * 通常用在Redis Cluster转发过程中 */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br></pre></td></tr></table></figure><p>command id，是从0开始递增的，作用是检查ACL。一个connection在执行命令前，服务器先要检查第<code>id</code>位有没有设置，如果设置了，说明这个connection有对应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释如下：</p><ol><li><code>sflags</code>是字符串格式的，表示这个命令的一些特性<br> <a href="https://segmentfault.com/a/1190000017104165" target="_blank" rel="noopener">例如</a>：<br> write对应CMD_WRITE<br> read-only对应CMD_READONLY</li><li><code>flags</code>是通过<code>populateCommandTableParseFlags</code><strong>从<code>sflags</code>生成的二进制表示</strong>。详见server.h中的<code>CMD_</code>定义，我们在下面会讲解。</li><li>下面是key三元组：<code>firstkey</code>表示第一个key参数的位置，<code>lastkey</code>表示最后一个key参数的位置，<code>keystep</code>表示key参数步长。通过上面三个参数，可以拿到所有的key。通常发生在<code>getKeysFromCommand</code>到<code>getKeysUsingCommandTable</code>函数调用链中。引入这个三元组的目的是有一些指令（如<code>mset</code>和<code>msetnx</code>的<code>keystep</code>取2）是支持在一个命令中对多个key/value对进行赋值的。我们需要注意的是诸如<code>ZADD</code>的指令虽然可以同时添加很多个<code>(score, member)</code>对，但是实际上他们是对一个key添加的，所以它们的三元组都是1。</li><li><code>getkeys_proc</code>表示<a href="https://developer.aliyun.com/article/754089" target="_blank" rel="noopener">从命令中判断命令的key</a>，实际上就是当<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>不能描述的时候，就会用到这个，返回一个<code>int*</code>表示所有key。例如后面举的eval的例子。</li><li><code>microseconds</code>表示该命令的调用总时间</li><li><code>calls</code>表示该命令的调用总次数</li><li><code>id</code>是在运行时给每个指令分配的id</li></ol><h4 id="flags枚举"><a href="#flags枚举" class="headerlink" title="flags枚举"></a>flags枚举</h4><p>从sflags可以解析得到flags，枚举如下：</p><ol><li><code>CMD_WRITE (1ULL&lt;&lt;0)</code></li><li><code>CMD_READONLY (1ULL&lt;&lt;1)</code><br> 对应read-only，一般包括所有的非特殊的命令，例如返回keys的值，或者返回一些其他信息，例如TIME等。诸如admin、transaction相关的信息，也不会被标记为readonly，因为他们会影响服务器状态。<br> 只读命令和非只读命令在主从复制时，<a href="https://luoming1224.github.io/2019/04/08/[redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0]redis%E4%B8%ADGeo%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">是不一样的</a>。</li><li><code>CMD_DENYOOM (1ULL&lt;&lt;2)</code><br> 对应use-memory，表示这个命令可能导致内存增加。需要在发生OOM的时候拒绝掉。</li><li><code>CMD_MODULE (1ULL&lt;&lt;3)</code></li><li><code>CMD_ADMIN (1ULL&lt;&lt;4)</code><br> 对应admin，诸如SAVE或者SHUTDOWN的命令。</li><li><code>CMD_PUBSUB (1ULL&lt;&lt;5)</code><br> SUBSCRIBE、UNSUBSCRIBE</li><li><code>CMD_NOSCRIPT (1ULL&lt;&lt;6)</code><br> 这样的命令不能在lua脚本中使用，例如AUTH、SAVE等。</li><li><code>CMD_RANDOM (1ULL&lt;&lt;7)</code><br> 对应random，有的命令即使在相同的情况下的运行结果也是不确定的，诸如SPOP、RANDOMKEY。</li><li><code>CMD_SORT_FOR_SCRIPT (1ULL&lt;&lt;8)</code><br> 对应to-sort，需要对输出序列进行排序。</li><li><code>CMD_LOADING (1ULL&lt;&lt;9)</code><br> 在服务器启动载入过程中可以执行的命令。如果没标记该项目的命令，启动过程中不能执行。</li><li><code>CMD_STALE (1ULL&lt;&lt;10)</code></li><li><code>CMD_SKIP_MONITOR (1ULL&lt;&lt;11)</code><br> no-monitor，不自动将这个命令propagate到MONITOR。</li><li><code>CMD_SKIP_SLOWLOG (1ULL&lt;&lt;12)</code><br> no-slowlog，不自动将这个命令propagate到slowlog。比如EXEC、AUTH之类的命。</li><li><code>CMD_ASKING (1ULL&lt;&lt;13)</code></li><li><code>CMD_FAST (1ULL&lt;&lt;14)</code><br> 这个命令是O(1)或者O(log(N))复杂度的，他们不会延误执行。注意所有可能导致DEL操作的并不是FAST命令，例如SET。</li><li><code>CMD_NO_AUTH (1ULL&lt;&lt;15)</code></li></ol><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>我们结合一个具体的定义来了解这个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"module"</span>,moduleCommand,<span class="number">-2</span>, <span class="comment">// -2表示大于等于2个参数</span></span><br><span class="line">     <span class="string">"admin no-script"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>, <span class="comment">// 这个叫get的指令对应到void getCommand(client *c)，有2个参数</span></span><br><span class="line">     <span class="string">"read-only fast @string"</span>, <span class="comment">// sflags 中是只读的，fast表示命令执行时间超过阈值时，会记录延迟事件。</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// flags</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">// getkeys_proc</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// firstkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// lastkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// keystep</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// microseconds</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// calls</span></span><br><span class="line">     <span class="number">0</span> <span class="comment">// id</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment">     * implicit DEL of a large key. */</span></span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"write use-memory @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"eval"</span>,evalCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"no-script @scripting"</span>,</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     evalGetKeys, <span class="comment">// eval无法通过key三元组描述，所以这里指定一个特殊的getkeys_proc</span></span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">"zadd"</span>,zaddCommand,<span class="number">-4</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @sortedset"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="命令的处理顺序"><a href="#命令的处理顺序" class="headerlink" title="命令的处理顺序"></a>命令的处理顺序</h3><ol><li>call<ol><li>processCommand<ol><li>processCommandAndResetClient<ol><li>processInputBuffer<ol><li>readQueryFromClient</li><li>handleClientsWithPendingReadsUsingThreads</li></ol></li><li>handleClientsWithPendingReadsUsingThreads<ol><li>stopThreadedIO</li><li>beforeSleep</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="processCommand"><a href="#processCommand" class="headerlink" title="processCommand"></a>processCommand</h3><p>这个函数很复杂：</p><ol><li>通过call执行命令</li><li>准备从客户端进行一次读取</li></ol><p>返回<code>C_OK</code>表示这个客户端还存在，否则表示这个客户端没了。</p><p>首先需要特别处理quit命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The QUIT command is handled separately. Normal command procs will</span></span><br><span class="line"><span class="comment">     * go through checking for replication and QUIT will cause trouble</span></span><br><span class="line"><span class="comment">     * when FORCE_REPLICATION is enabled and would be implemented in</span></span><br><span class="line"><span class="comment">     * a regular command proc. */</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面通过<code>lookupCommand</code>查找对应的命令结构，并处理找不到或者命令格式错误的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment"> * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line">c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">    sds args = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; <span class="number">128</span>; i++)</span><br><span class="line">        args = sdscatprintf(args, <span class="string">"`%.*s`, "</span>, <span class="number">128</span>-(<span class="keyword">int</span>)sdslen(args), (<span class="keyword">char</span>*)c-&gt;argv[i]-&gt;ptr);</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"unknown command `%s`, with args beginning with: %s"</span>,</span><br><span class="line">        (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr, args);</span><br><span class="line">    sdsfree(args);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">           (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">        c-&gt;cmd-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断命令的性质，是只读的，还是可写的等性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_write_command = (c-&gt;cmd-&gt;flags &amp; CMD_WRITE) ||</span><br><span class="line">                       (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_WRITE));</span><br><span class="line"><span class="keyword">int</span> is_denyoom_command = (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) ||</span><br><span class="line">                         (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_DENYOOM));</span><br><span class="line"><span class="keyword">int</span> is_denystale_command = !(c-&gt;cmd-&gt;flags &amp; CMD_STALE) ||</span><br><span class="line">                           (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_STALE));</span><br><span class="line"><span class="keyword">int</span> is_denyloading_command = !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING) ||</span><br><span class="line">                             (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_LOADING));</span><br></pre></td></tr></table></figure><p>进行auth和ACL检查。<br>auth也就是登录状态检查。<br>ACL，即Access Control List，有一系列条件规则组成，用来具体控制某些用户是否可以运行某些命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Check if the user is authenticated. This check is skipped in case</span></span><br><span class="line"><span class="comment">     * the default user is flagged as "nopass" and is active. */</span></span><br><span class="line">    <span class="keyword">int</span> auth_required = (!(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) ||</span><br><span class="line">                          (DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED)) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    <span class="keyword">if</span> (auth_required) &#123;</span><br><span class="line">        <span class="comment">/* AUTH and HELLO and no auth modules are valid even in</span></span><br><span class="line"><span class="comment">         * non-authenticated state. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;cmd-&gt;flags &amp; CMD_NO_AUTH)) &#123;</span><br><span class="line">            rejectCommand(c,shared.noautherr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the user can run this command according to the current</span></span><br><span class="line"><span class="comment">     * ACLs. */</span></span><br><span class="line">    <span class="keyword">int</span> acl_keypos;</span><br><span class="line">    <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">    <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">        addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval == ACL_DENIED_CMD)</span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to run "</span></span><br><span class="line">                <span class="string">"the '%s' command or its subcommand"</span>, c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to access "</span></span><br><span class="line">                <span class="string">"one of the keys used as arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果启用了Redis Cluster，就要进行转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* If cluster is enabled perform the cluster redirection here.</span></span><br><span class="line"><span class="comment">     * However we don't perform the redirection if:</span></span><br><span class="line"><span class="comment">     * 1) The sender of this command is our master.</span></span><br><span class="line"><span class="comment">     * 2) The command has no key arguments. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hashslot;</span><br><span class="line">        <span class="keyword">int</span> error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>处理oom相关行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Handle the maxmemory directive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we do not want to reclaim memory if we are here re-entering</span></span><br><span class="line"><span class="comment">     * the event loop since there is a busy Lua script running in timeout</span></span><br><span class="line"><span class="comment">     * condition, to avoid mixing the propagation of scripts with the</span></span><br><span class="line"><span class="comment">     * propagation of DELs due to eviction. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="keyword">int</span> out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;</span><br><span class="line">        <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span></span><br><span class="line"><span class="comment">         * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> reject_cmd_on_oom = is_denyoom_command;</span><br><span class="line">        <span class="comment">/* If client is in MULTI/EXEC context, queuing may consume an unlimited</span></span><br><span class="line"><span class="comment">         * amount of memory, so we want to stop that.</span></span><br><span class="line"><span class="comment">         * However, we never want to reject DISCARD, or even EXEC (unless it</span></span><br><span class="line"><span class="comment">         * contains denied commands, in which case is_denyoom_command is already</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != execCommand &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != discardCommand) &#123;</span><br><span class="line">            reject_cmd_on_oom = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save out_of_memory result at script start, otherwise if we check OOM</span></span><br><span class="line"><span class="comment">         * untill first write within script, memory used by lua stack and</span></span><br><span class="line"><span class="comment">         * arguments might interfere. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == evalCommand || c-&gt;cmd-&gt;proc == evalShaCommand) &#123;</span><br><span class="line">            server.lua_oom = out_of_memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use a reasonable amount of memory for client side</span></span><br><span class="line"><span class="comment">     * caching metadata. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.tracking_clients) trackingLimitUsedSlots();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are problems persisting on disk</span></span><br><span class="line"><span class="comment">     * and if this is a master instance. */</span></span><br><span class="line">    <span class="keyword">int</span> deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">    <span class="keyword">if</span> (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span><br><span class="line">        server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (is_write_command ||c-&gt;cmd-&gt;proc == pingCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deny_write_type == DISK_ERROR_TYPE_RDB)</span><br><span class="line">            rejectCommand(c, shared.bgsaveerr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-MISCONF Errors writing to the AOF file: %s"</span>,</span><br><span class="line">                strerror(server.aof_last_write_errno));</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are not enough good slaves and</span></span><br><span class="line"><span class="comment">     * user configured the min-slaves-to-write option. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_to_write &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_max_lag &amp;&amp;</span><br><span class="line">        is_write_command &amp;&amp;</span><br><span class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.noreplicaserr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if this is a read only slave. But</span></span><br><span class="line"><span class="comment">     * accept write commands if this is our master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        is_write_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.roslaveerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow a subset of commands in the context of Pub/Sub if the</span></span><br><span class="line"><span class="comment">     * connection is in RESP2 mode. With RESP3 there are no limits. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp; c-&gt;resp == <span class="number">2</span>) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</span><br><span class="line">        rejectCommandFormat(c,</span><br><span class="line">            <span class="string">"Can't execute '%s': only (P)SUBSCRIBE / "</span></span><br><span class="line">            <span class="string">"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow commands with flag "t", such as INFO, SLAVEOF and so on,</span></span><br><span class="line"><span class="comment">     * when slave-serve-stale-data is no and we are a slave with a broken</span></span><br><span class="line"><span class="comment">     * link with master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        server.repl_serve_stale_data == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_denystale_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.masterdownerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loading DB? Return an error if the command has not the</span></span><br><span class="line"><span class="comment">     * CMD_LOADING flag. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; is_denyloading_command) &#123;</span><br><span class="line">        rejectCommand(c, shared.loadingerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lua script too slow? Only allow a limited number of commands.</span></span><br><span class="line"><span class="comment">     * Note that we need to allow the transactions commands, otherwise clients</span></span><br><span class="line"><span class="comment">     * sending a transaction with pipelining without error checking, may have</span></span><br><span class="line"><span class="comment">     * the MULTI plus a few initial commands refused, then the timeout</span></span><br><span class="line"><span class="comment">     * condition resolves, and the bottom-half of the transaction gets</span></span><br><span class="line"><span class="comment">     * executed, see Github PR #7022. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != multiCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != unwatchCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'n'</span>) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'k'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.slowscripterr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面才是真正的执行，对于非multi，会调用call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code>就是调用指令的函数，有一系列的flag：</p><ol><li><code>CMD_CALL_NONE</code></li><li><code>CMD_CALL_SLOWLOG</code><br> 检查指令执行的速度，是否记录到slow log中呢？</li><li><code>CMD_CALL_STATS</code><br> Populate command stats.</li><li><code>CMD_CALL_PROPAGATE_AOF</code><br> 如果对数据有改动（可以通过<code>server.dirty</code>字段看出），或者client有一个强迫propagate的<code>CLIENT_FORCE_AOF</code>，就加到AOF上。<br> 相应的，如果client设置了<code>CLIENT_PREVENT_AOF_PROP</code>，那么即使数据集变动了，也不会写AOF。<br> 注意，无论client设置了什么，如果没有<code>CMD_CALL_PROPAGATE_AOF</code>，那么永远不会写AOF。</li><li><code>CMD_CALL_PROPAGATE_REPL</code><br> 同理，但是对Slave。同样有<code>CLIENT_FORCE_REPL</code>/<code>CLIENT_PREVENT_REPL_PROP</code>。</li><li><code>CMD_CALL_PROPAGATE</code><br> 相当于<code>PROPAGATE_AOF|PROPAGATE_REPL</code></li><li><code>CMD_CALL_FULL</code><br> 相当于<code>SLOWLOG|STATS|PROPAGATE</code></li></ol><p><code>call</code>主要就是用<code>c-&gt;cmd-&gt;proc(c)</code>执行命令，后者实际上就是<code>xxxCommand()</code>这样的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="keyword">ustime_t</span> start, duration;</span><br><span class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">real_cmd</span> = <span class="title">c</span>-&gt;<span class="title">cmd</span>;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>fixed_time_expire</code>在expire机制中见到过的，如果有命令在执行过程中，这个值就不是0。<br>还会把除了ADMIN之外的命令发送给MONITOR，ADMIN命令展示出来太危险了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.fixed_time_expire++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the command to clients in MONITOR mode if applicable.</span></span><br><span class="line"><span class="comment">     * Administrative commands are considered too dangerous to be shown. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些初始化和执行工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Initialization: clear the flags that must be set by the command on</span></span><br><span class="line"><span class="comment">     * demand, and initialize the array for additional commands propagation. */</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    redisOpArray prev_also_propagate = server.also_propagate;</span><br><span class="line">    redisOpArrayInit(&amp;server.also_propagate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the command. */</span></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    updateCachedTime(<span class="number">0</span>);</span><br><span class="line">    start = server.ustime;</span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在执行后，统计数据库被修改的次数<code>dirty</code>。在<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>中看到，比如我新加一个元素，或者修改一个元素，都会导致<code>dirty</code>增加。也就对应了数据的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    duration = ustime()-start;</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When EVAL is called loading the AOF we don't want commands called</span></span><br><span class="line"><span class="comment">     * from Lua to go into the slowlog or to populate statistics. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span><br><span class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the caller is Lua, we want to force the EVAL caller to propagate</span></span><br><span class="line"><span class="comment">     * the script if the command flag or client flag are forcing the</span></span><br><span class="line"><span class="comment">     * propagation. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>记录延迟信息，并记录slowlog。其中<code>latencyAddSampleIfNeeded</code>在适当的时候调用<code>latencyAddSample</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Log the command into the Slow log if needed, and populate the</span></span><br><span class="line"><span class="comment">     * per-command statistics that we show in INFO commandstats. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_SKIP_SLOWLOG)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_STATS) &#123;</span><br><span class="line">        <span class="comment">/* use the real command that was executed (cmd and lastamc) may be</span></span><br><span class="line"><span class="comment">         * different, in case of MULTI-EXEC or re-written commands such as</span></span><br><span class="line"><span class="comment">         * EXPIRE, GEOADD, etc. */</span></span><br><span class="line">        real_cmd-&gt;microseconds += duration;</span><br><span class="line">        real_cmd-&gt;calls++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理propagate的情况，这个对应了<code>CALL_</code>开头的一些规则，就不详解了。最终会计算得到一个<code>propagate_flags</code>传给<code>propagate</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">         * set for replication / AOF propagation. */</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">         * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* However prevent AOF / replication propagation if the command</span></span><br><span class="line"><span class="comment">         * implementations called preventCommandPropagation() or similar,</span></span><br><span class="line"><span class="comment">         * or if we don't have the call() flags to do so. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">         * propagation is needed. Note that modules commands handle replication</span></span><br><span class="line"><span class="comment">         * in an explicit way, so we never replicate them automatically. */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在结束之后，我们需要还原一下有关propagate的相关flag，因为<code>call</code>可能被递归调用。<br>【Q】我觉得这里一个典型的例子就是这里的multi、exec。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Restore the old replication flags, since call() can be executed</span></span><br><span class="line"><span class="comment"> * recursively. */</span></span><br><span class="line">c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">    (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br></pre></td></tr></table></figure><p><code>alsoPropagate</code>函数可以往<code>server.also_propagate</code>里面加一些其他的op。下面就处理<code>alsoPropagate</code>的逻辑，也就是当propagate完当前的命令之后，还可以再去propagate一些命令。并且这些命令不被<code>CLIENT_PREVENT_PROP</code>影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.also_propagate.numops) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    redisOp *rop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">        <span class="keyword">int</span> multi_emitted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果说已经被包在了MULTI里面，就不在继续包在<code>also_propagate</code>里面propagate了。<br><code>execCommandPropagateMulti</code>实际上就是下面的propagate调用。这里的<code>shared.multi</code>或者<code>shared.exec</code>实际上是缓存的字符串对象<code>EXEC</code>和<code>MULTI</code>，减少频繁的内存分配的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateMulti</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.multiCommand,c-&gt;db-&gt;id,&amp;shared.multi,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateExec</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.execCommand,c-&gt;db-&gt;id,&amp;shared.exec,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是做propagate。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="comment">/* Wrap the commands in server.also_propagate array,</span></span><br><span class="line"><span class="comment">             * but don't wrap it if we are already in MULTI context,</span></span><br><span class="line"><span class="comment">             * in case the nested MULTI/EXEC.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * And if the array contains only one command, no need to</span></span><br><span class="line"><span class="comment">             * wrap it, since the single command is atomic. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.also_propagate.numops &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE) &amp;&amp;</span><br><span class="line">                !(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span><br><span class="line">                !(flags &amp; CMD_CALL_NOWRAP))</span><br><span class="line">            &#123;</span><br><span class="line">                execCommandPropagateMulti(c);</span><br><span class="line">                multi_emitted = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">                rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">                <span class="keyword">int</span> target = rop-&gt;target;</span><br><span class="line">                <span class="comment">/* Whatever the command wish is, we honor the call() flags. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">                <span class="keyword">if</span> (target)</span><br><span class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (multi_emitted) &#123;</span><br><span class="line">                execCommandPropagateExec(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line">    &#125;</span><br><span class="line">    server.also_propagate = prev_also_propagate;</span><br></pre></td></tr></table></figure><p>这个应该是和客户端缓存有关的，如果client提供了keys tracking功能，要通知。这个函数里面维护了一个tracking invalidation表，这样客户端会收到一个invalidation信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* If the client has keys tracking enabled for client side caching,</span></span><br><span class="line"><span class="comment">     * make sure to remember the keys it fetched via this command. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">        client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                            server.lua_caller : c;</span><br><span class="line">        <span class="keyword">if</span> (caller-&gt;flags &amp; CLIENT_TRACKING &amp;&amp;</span><br><span class="line">            !(caller-&gt;flags &amp; CLIENT_TRACKING_BCAST))</span><br><span class="line">        &#123;</span><br><span class="line">            trackingRememberKeys(caller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.fixed_time_expire--;</span><br><span class="line">    server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除逻辑实现"><a href="#删除逻辑实现" class="headerlink" title="删除逻辑实现"></a>删除逻辑实现</h1><p>为了理解下面论述中涉及到的expire相关实现，我们需要先介绍一些<code>UNLINK</code>和<code>DEL</code>的实现。<br>delGenericCommand的实现是比较Legacy的，从<code>c-&gt;argv</code>中读取所有需要被删除的key，然后调用dbAsyncDelete或者dbSyncDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>容易发现，删除有两种模式：异步(lazy)删除和同步删除。异步删除的情况包括：</p><ol><li>delete逻辑<ol><li><code>delGenericCommand</code>中传入lazy<br> 如果是unlink命令，那么一定是异步删除。<br> 如果是del命令，则取决于<code>server.lazyfree_lazy_user_del</code>。</li><li><code>dbDelete</code>中设置了<code>server.lazyfree_lazy_server_del</code></li></ol></li><li>expire逻辑<ol><li><code>expireIfNeeded</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应了Redis的lazy过期策略。</li><li><code>activeExpireCycleTryExpire</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应着Redis的定期循环，主动过期策略。</li><li><code>expireGenericCommand</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 直接运行expire命令，主动检查一下有没有过期。</li></ol></li><li>evict逻辑<ol><li><code>freeMemoryIfNeeded</code>中如果设置<code>server.lazyfree_lazy_eviction</code>，则使用异步删除</li></ol></li><li>其他<ol><li><code>RM_UnlinkKey</code></li></ol></li></ol><p>这些<code>lazyfree_lazy_</code>开头的配置，默认都是0。也就是说这些情况下默认都是同步删除。</p><p>同步删除的情况类似，除了“其他”中发生了变化：</p><ol><li>其他<ol><li><code>rdbLoadRio</code></li></ol></li></ol><p>下面的代码会进行事件通知，我们将专门进行介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【续】delGenericCommand函数</span></span><br><span class="line">...</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>del和unlink的唯一区别是，unlink一定是lazy删除的，但是del取决于配置<code>lazyfree_lazy_user_del</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlinkCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步删除"><a href="#同步删除" class="headerlink" title="同步删除"></a>同步删除</h2><p>看简单的同步实现。<br>首先，如果<code>db-&gt;expires</code>非空，从<code>db-&gt;expires</code>里面删除<code>key</code>，实际上是删除的过期时间。<br>这里有个注释，说从<code>db-&gt;expires</code>中删除一个entry不会释放<code>key-&gt;ptr</code>这个sds，因为它和<code>db-&gt;dict</code>是共享的。这里应该说的是在<code>setExpire</code>里面往<code>db-&gt;expires</code>添加key的时候，加的实际上是指向<code>db-&gt;dict</code>中的指针。<br>但果真是这样的么？继续看<code>dictDelete</code>最终调用<code>dictGenericDelete</code>。查看<code>dictDelete</code>实际上是<code>dictGenericDelete</code>的实现(在“dict的其他相关方法”这个章节中介绍)，发现新版本的代码肯定会调用<code>dictFreeKey</code>(Redis3.0里面有个<code>dictFreeEntryKey</code>，不要混淆了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>检查dictFreeKey的实现发现，这个函数调用<code>keyDestructor</code>，它似乎一定会导致对应sds的析构。看上去和上面的注释是矛盾的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br></pre></td></tr></table></figure><p>究竟是怎么回事呢？我们看下keyptrDictType和dbDictType这两个dict类型就有了答案。原来对于<code>db-&gt;expires</code>，它实际的类型就没有设置keyDestructor，所以不会析构key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line">server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;expires */</span></span><br><span class="line">dictType keyptrDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></span><br><span class="line">dictType dbDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></span><br><span class="line">    dictObjectDestructor   <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以说一下<code>#define DICT_NOTUSED(V) ((void) V)</code>是经典的关闭编译器unused variable warning的办法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSdsDestructor</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接着看<code>dbSyncDelete</code>的逻辑，刚才是删除的<code>db-&gt;expires</code>，还需要删除<code>db-&gt;dict</code>。<br>此外<code>server.cluster_enabled</code>的情况进行了额外的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再从db-&gt;dict里面删除key</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// Redis Cluster相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h2><p>异步删除的核心是调用<code>dictUnlink</code>而不是<code>dictDelete</code>。<br>前面的是大差不差的，删除<code>db-&gt;expires</code>里面的字段，因为他们的dictType不一样，他们的析构行为(<code>keyDestructor</code>)也不一样。这就导致expire可以直接dictDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazyfree.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB.</span></span><br><span class="line"><span class="comment"> * If there are enough allocations to free the value object may be put into</span></span><br><span class="line"><span class="comment"> * a lazy free list instead of being freed synchronously. The lazy free list</span></span><br><span class="line"><span class="comment"> * will be reclaimed in a different bio.c thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面调用<code>dictUnlink</code>而不是<code>dictDelete</code>了。这里注意区别一下<code>dictUnlink</code>和前面提到的UNLINK命令。<code>dictUnlink</code>的作用是将对应的key从dict中删除，但不会释放对应的结构，而是直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>拿到这个<code>de</code>，我们手动来析构。会首先使用<code>lazyfreeGetFreeEffort</code>来计算析构的代价，如果代价过高，就将这个对象放到lazy free list里面让它后台去析构。不然的话就在后面的代码中同步析构，这是因为如果对象很小，那么再搞这一套异步反而更耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先来看lazy的实现，如果算出来值得，那么就lazy。但这里还有个特殊情况我们不能异步删除，根据注释，如果这个对象是被共享的(<code>val-&gt;refcount</code>就是一个大于1的值)，我们不能就直接把它现在就回收掉。这个倒不经常发生，但确实Redis的一些实现代码会用<code>incrRefCount</code>来保护对象，然后调用<code>dbDelete</code>。在这种情况下我们会fall through到下面<code>dictFreeUnlinkedEntry</code>的调用，它的最终效果相当于直接调用<code>decrRefCount</code>。<br>经过了上述的判断，我们就可以使用bioCreateBackgroundJob来异步删除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就是同步删除的实现。<code>dictFreeUnlinkedEntry</code>这一块就是给之前<code>nofree</code>没做的事情擦一下屁股，包含调用<code>dictFreeKey</code>啥的来释放key和value所占用的内存。<br><code>slotToKeyDel</code>这个是Redis Cluster的实现逻辑，用来算出来这个key在哪个slot上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    zfree(he);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及的几个函数来讲解一下</p><h3 id="lazyfreeGetFreeEffort"><a href="#lazyfreeGetFreeEffort" class="headerlink" title="lazyfreeGetFreeEffort"></a>lazyfreeGetFreeEffort</h3><p>这个函数计算并返回释放一个对象的代价。返回值不一定是这个对象对应的内存分配次数，但是和这个量成比例的。具体来说：</p><ol><li>对于字符串，函数永远返回1。</li><li>对于用诸如哈希表等数据结构表示的聚合对象，返回组成该对象元素的数量。</li><li>对于只需要一次内存分配就产生的对象，认为是独立的一个对象，即使实际上是由多个造成的。</li><li>对于列表对象，返回quicklist里面的元素数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> lazyfreeGetFreeEffort(robj *obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">        quicklist *ql = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> ql-&gt;len;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_SET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br></pre></td></tr></table></figure><p>对于ZSET，如果是跳表实现，就返回跳表的长度。如果是ziplist实现就返回1？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_ZSET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_SKIPLIST)&#123;</span><br><span class="line">        zset *zs = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> zs-&gt;zsl-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_HASH &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_STREAM) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> effort = <span class="number">0</span>;</span><br><span class="line">        stream *s = obj-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make a best effort estimate to maintain constant runtime. Every macro</span></span><br><span class="line"><span class="comment">         * node in the Stream is one allocation. */</span></span><br><span class="line">        effort += s-&gt;rax-&gt;numnodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Every consumer group is an allocation and so are the entries in its</span></span><br><span class="line"><span class="comment">         * PEL. We use size of the first group's PEL as an estimate for all</span></span><br><span class="line"><span class="comment">         * others. */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;cgroups) &#123;</span><br><span class="line">            raxIterator ri;</span><br><span class="line">            streamCG *cg;</span><br><span class="line">            raxStart(&amp;ri,s-&gt;cgroups);</span><br><span class="line">            raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* There must be at least one group so the following should always</span></span><br><span class="line"><span class="comment">             * work. */</span></span><br><span class="line">            serverAssert(raxNext(&amp;ri));</span><br><span class="line">            cg = ri.data;</span><br><span class="line">            effort += raxSize(s-&gt;cgroups)*(<span class="number">1</span>+raxSize(cg-&gt;pel));</span><br><span class="line">            raxStop(&amp;ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> effort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Everything else is a single allocation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="atomicIncr"><a href="#atomicIncr" class="headerlink" title="atomicIncr"></a>atomicIncr</h3><p>是一个原子操作，更新lazyfree里面的一个static变量<code>lazyfree_objects</code>。根据不同的操作系统的支持，有三种实现：<br>如果支持atomic语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><p>如果有sync语义，一般是gcc的一个内置宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __sync_add_and_fetch(&amp;var,(count))</span></span><br></pre></td></tr></table></figure><p>如果什么都没有，用mutex，mutex的名字是变量名加上<code>_mutex</code>，这些mutex随着变量名一起被定义，只是可能不会被用到，如lazyfree_objects_mutex。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</span><br><span class="line">    var += (count); \</span><br><span class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="bioCreateBackgroundJob"><a href="#bioCreateBackgroundJob" class="headerlink" title="bioCreateBackgroundJob"></a>bioCreateBackgroundJob</h3><p>所有的bio开头的函数表示Redis的Background IO服务。根据注释，将来也许会迁移到libeio。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictSetVal"><a href="#dictSetVal" class="headerlink" title="dictSetVal"></a>dictSetVal</h3><p>见dict相关</p><h3 id="slotToKeyDel"><a href="#slotToKeyDel" class="headerlink" title="slotToKeyDel"></a>slotToKeyDel</h3><p>见 Redis Cluster 相关</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>lookUpKey相关方法根据查找目的是读或者写区分了<code>lookupKeyRead</code>、<code>lookupKeyWrite</code>两个方向的函数，此外还根据是否<code>WithFlags</code>或者<code>OrReply</code>派生出其他几种函数。</p><p>对于<code>lookupKeyWrite</code>来讲，有一个副作用，就是会先检查一下要不要expire，如果需要就直接expire掉。<br>对于<code>lookupKeyRead</code>来讲，也要处理expire的问题，但是因为涉及到主从复制的问题，所以要进行额外处理。【Q】为什么不需要对写处理呢？我想应该是因为只有Master处理写，处理完再发指令给Slave。</p><p>直接介绍带Flags的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WithFlags</code>目前只包含了<code>LOOKUP_NONE</code>和<code>LOOKUP_NOTOUCH</code>两个选项。：</p><ol><li><code>LOOKUP_NONE</code></li><li><code>LOOKUP_NOTOUCH</code><br> 表示这次访问不要更新LRU啥的，例如type这样的命令就带上这个参数。</li></ol><h2 id="lookupKeyReadWithFlags"><a href="#lookupKeyReadWithFlags" class="headerlink" title="lookupKeyReadWithFlags"></a>lookupKeyReadWithFlags</h2><p>下面查看<code>lookupKeyReadWithFlags</code>的实现，相比于写要复杂点，因为要处理键过期的时候读的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Master的<code>masterhost</code>肯定是NULL，这是一个经典判定。首先考虑Master的情况，如果key过期了，那么就直接安全地返回NULL，并且触发一个keymiss事件。这里注释上说在Master情况下，<code>expireIfNeeded</code>返回0当且只当这个key不存在。<br>为什么强调Master呢，实际上可以结合<code>expireIfNeeded</code>的实现来看。提前说一下，<strong>对Slave而言</strong>，<code>expireIfNeeded</code>并<strong>不会真的让key过期并删除</strong>，而只是返回key在逻辑上是过期的，而真正的过期是由Master来同步的，其目的是保持Slave和Master的一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Key expired. If we are in the context of a master, expireIfNeeded()</span></span><br><span class="line"><span class="comment">         * returns 0 only when the key does not exist at all, so it's safe</span></span><br><span class="line"><span class="comment">         * to return NULL ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更新统计信息，<code>server.stat_keyspace_misses</code>可以通过<code>INFO keyspace_misses</code>命令来查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是对Master情况的处理，下面是对Slave的情况。我们已经知道，Slave并不会真的删除过期key，而是等待Master的Del指令。所以即使<code>expireIfNeeded</code>返回1表示过期，<br>但根据注释，对Slave而言，作为一个额外的安全措施，如果相关指令是只读的，还是可以在这里安全地返回NULL。Redis的说法是：对于只读命令，这样可以向client提供一个更加一致性的行为。这个会包含GETS，当使用Slave来扩容读的时候。我的理解就是尽管slave上还没有删除，但是过期就是过期，我们要和Master一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookupKeyWriteWithFlags"><a href="#lookupKeyWriteWithFlags" class="headerlink" title="lookupKeyWriteWithFlags"></a>lookupKeyWriteWithFlags</h2><p>首先查看<code>lookupKeyWriteWithFlags</code>的实现，直接先检查下expire，然后调用<code>lookupKey</code>。这里的<code>expireIfNeeded</code>也是Redis的lazy过期策略的实现，在每次查找的时候都会调用，检查这个键是不是已经过期了。<br>不同于<code>lookupKeyReadWithFlags</code>，这里就不会统计keymiss啥的了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookUpKey"><a href="#lookUpKey" class="headerlink" title="lookUpKey"></a>lookUpKey</h2><p><code>lookUpKey</code>的主要内容包括从db里面找到对应的key，并且维护LRU或LFU。它是一个较为底层的 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从db中获得key对应的entry</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了，就取出val</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有设置</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是LRU和LFU的实现，更新每个key的访问情况，从而方便后续evict。详细见有关updateLFU的实现见”Redis的LRU和LFU实现”这一章节。<br>但先要做一些判断：</p><ol><li>如果设置了<code>LOOKUP_NOTOUCH</code>。</li><li>如果有子进程正在进行保存，就不进行LFU操作，以免破坏COW。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h1><h2 id="如何判断键已过期？"><a href="#如何判断键已过期？" class="headerlink" title="如何判断键已过期？"></a>如何判断键已过期？</h2><p>诸如<code>EXPIRE</code>/<code>RENAME</code>等的实现中会调用<code>setExpire</code>函数设置过期时间。<code>setExpire</code>会把每个键的过期时间都被存在<code>db-&gt;expires</code>这个字典里面。<br>通过<code>getExpire</code>可以从字典中读取到过期时间。</p><h3 id="getExpire"><a href="#getExpire" class="headerlink" title="getExpire"></a>getExpire</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the expire time of the specified key, or -1 if no expire</span></span><br><span class="line"><span class="comment"> * is associated with this key (i.e. the key is non volatile) */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keyIsExpired"><a href="#keyIsExpired" class="headerlink" title="keyIsExpired"></a>keyIsExpired</h3><p>keyIsExpired作用是判断某个键有没有过期。主要功能就是比较现在的时间，和获得的key的过期时间。被expireIfNeeded调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面一段代码的目的是：如果在执行lua脚本，将时间设置成脚本执行开始的时间，这样在脚本执行过程中就不会expire。这么做的原因是源自Github上面的<a href="https://github.com/redis/redis/issues/1525" target="_blank" rel="noopener">Issue1525</a>。作者发现这个脚本在Master和Slave上的执行是不一样的。原因是在Master上第一次执行可能key存在，第二次就不存在了。这导致<code>incr</code>实际只被执行了一次。但是因为此时Master会合成一个DEL指令，让Slave也删除并过期这个Key。此时，如果相同的脚本运行在Slave上面，那么<code>incr</code>一次也不会被执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保障向Slave和AOF的propagate是一致的，首先在执行lua脚本的时候，要禁止expire(就是这里的行为)；但是在执行脚本之前，先要对涉及的key做下<code>expireIfNeeded</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are in the middle of a command execution, we still want to use</span></span><br><span class="line"><span class="comment">     * a reference time that does not change: in that case we just use the</span></span><br><span class="line"><span class="comment">     * cached time, that we update before each call in the call() function.</span></span><br><span class="line"><span class="comment">     * This way we avoid that commands such as RPOPLPUSH or similar, that</span></span><br><span class="line"><span class="comment">     * may re-open the same key multiple times, can invalidate an already</span></span><br><span class="line"><span class="comment">     * open object in a next call, if the next call will see the key expired,</span></span><br><span class="line"><span class="comment">     * while the first did not. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For the other cases, we want to use the most fresh time we have. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key expired if the current (virtual or real) time is greater</span></span><br><span class="line"><span class="comment">     * than the expire time of the key. */</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="expireIfNeeded"><a href="#expireIfNeeded" class="headerlink" title="expireIfNeeded"></a>expireIfNeeded</h2><p><code>expireIfNeeded</code>用来删除过期的键，它是<strong>被动expire</strong>的关键步骤。返回0表示键有效(键未过期，或永不过期)，否则返回1表示已经过期并被删除。<br>对于Master，如果找到的键是expire的，会被从数据库中evict掉。并且会导致想AOF和Slave流propagate一条DEL或者UNLINK指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>如果没有过期，就返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先，通过<code>keyIsExpired</code>检测是不是已经过期了，如果还没有过期，上面就直接返回0了，再往下就是处理过期的情况。<br>根据注释，如果Redis运行在主从模式下，并且是在Slave上，<code>expireIfNeeded</code>直接返回，而不是继续删除键。这是因为Slave上的key过期是由Master控制的，Slave并不直接处理key的过期。Master会发送一个同步的<code>DEL</code>命令给Slave来删除某个键，Slave等到那时候再删除，<strong>这样做的目的是出于一致性的考量</strong>。<br>但尽管如此，对Slave调用<code>expireIfNeeded</code>也应该返回一个正确的值，也就是这个时候键应不应该过期。因此，Slave上是先过期，然后再删除键的，这其中存在一个窗口时间，因为Slave还没有来得及收到并处理Master的<code>DEL</code>。<br>下面肯定对应了已经过期的情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面负责通知删除事件，这里还出现了<code>propagateExpire</code>函数，我们也统一在后面讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 向AOF文件和Slave节点传播过期信息，实际会调用propagate函数</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是真正的过期删除的过程。这里根据<code>server.lazyfree_lazy_expire</code>的配置，可以选择异步删除或者同步删除，这类似于上面讨论过的<code>UNLINK</code>和<code>DEL</code>的实现。事实上在<code>expireGenericCommand</code>上就可以看到对应的映射关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);     </span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主动expire实现"><a href="#主动expire实现" class="headerlink" title="主动expire实现"></a>主动expire实现</h2><p>在<code>databasesCron</code>可以看到，如果开启了主动expire，并且自己是master，则会定时运行activeExpireCycle。<br>介绍<a href="https://stackoverflow.com/questions/33370047/configuring-redis-expire-algorithm" target="_blank" rel="noopener">参数</a>：<br><code>active_expire_effort</code>默认值为1，表示<a href="https://docs.aws.amazon.com/memorydb/latest/devguide/parametergroups.redis.html" target="_blank" rel="noopener">避免有超过<code>10%</code>的过期key，同时CPU占用不超过25%</a>。<br><code>config_keys_per_loop</code>表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    effort = server.active_expire_effort<span class="number">-1</span>, <span class="comment">/* Rescale from 0 to 9. */</span></span><br><span class="line">    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +</span><br><span class="line">                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +</span><br><span class="line">                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +</span><br><span class="line">                                  <span class="number">2</span>*effort,</span><br><span class="line">    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-</span><br><span class="line">                                    effort;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是几个全局变量：</p><ol><li>timelimit_exit表示是否已经超时了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></span><br><span class="line"><span class="comment">     * incrementally across calls. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>如果所有的clients停止了，那么我们的主动expire循环也要停止，从而保持数据库是静态的。没搞懂为啥这么设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里，Redis的主动过期策略分为了fast和slow两个模式。第一种在key比较少的情况下尝试是用较少的cpu，一旦这些过期的键的数量小于某个给定值，就退出。第二种更激进一点，以减少内存占用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exit</span></span><br><span class="line"><span class="comment">         * for time limit, unless the percentage of estimated stale keys is</span></span><br><span class="line"><span class="comment">         * too high. Also never repeat a fast cycle for the same period</span></span><br><span class="line"><span class="comment">         * as the fast cycle total duration itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit &amp;&amp;</span><br><span class="line">            server.stat_expired_stale_perc &lt; config_cycle_acceptable_stale)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + (<span class="keyword">long</span> <span class="keyword">long</span>)config_cycle_fast_duration*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每次扫多少db呢？默认<code>dbs_per_call</code>为CRON_DBS_PER_CALL，即16：</p><ol><li><code>dbs_per_call</code>不能超过总的db数。</li><li>如果<code>timelimit_exit</code>，需要扫描全部db<br> 我的理解是如果上次active expire都超时了，说明肯定有很多expire key等待清理，我们全部做一遍，以免占用太多内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We usually should test CRON_DBS_PER_CALL per iteration, with</span></span><br><span class="line"><span class="comment">     * two exceptions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Don't test more DBs than we have.</span></span><br><span class="line"><span class="comment">     * 2) If last time we hit the time limit, we want to scan all DBs</span></span><br><span class="line"><span class="comment">     * in this iteration, as there is work to do in some DB and we don't want</span></span><br><span class="line"><span class="comment">     * expired keys to use memory for too much time. */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里通过计算耗时，来限制active expire循环对CPU的占用。默认CPU限制是ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC。我们最多在这个函数中只能用timelimit这么多<strong>微秒</strong>。<code>server.hz</code>指的是表示一秒钟被触发多少次，<code>config_cycle_slow_time_perc</code>是个CPU的百分比，也就是每次迭代中只能用<code>config_cycle_slow_time_perc/100</code>这么久。因为每次迭代的耗时是<code>1/server.hz</code>秒，即<code>1000000/server.hz</code>微秒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We can use at max 'config_cycle_slow_time_perc' percentage of CPU</span></span><br><span class="line"><span class="comment">     * time per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span></span><br><span class="line">    timelimit = config_cycle_slow_time_perc*<span class="number">1000000</span>/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = config_cycle_fast_duration; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accumulate some global stats as we expire keys, to have some idea</span></span><br><span class="line"><span class="comment">     * about the number of keys that are already logically expired, but still</span></span><br><span class="line"><span class="comment">     * existing inside the database. */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>外层的循环，遍历所有的数据库。如果<code>timelimit_exit</code>为1，说明内层循环中已经发现执行超时了，外层循坏也退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="comment">/* Expired and checked in a single loop. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> expired, sampled;</span><br><span class="line"></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></span><br><span class="line"><span class="comment">         * in the current DB we'll restart from the next. This allows to</span></span><br><span class="line"><span class="comment">         * distribute the time evenly across DBs. */</span></span><br><span class="line">        current_db++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内层的循环，如果每次循环结束，还是有很高的没有处理的过期的key，就需要继续做。但我们也不能一直这么做下去，所以每过16次，就会检查是否超过timelimit。如果是的话，就设置timelimit_exit为1，然后退出当前循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">            <span class="keyword">int</span> ttl_samples;</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When there are less than 1% filled slots, sampling the key</span></span><br><span class="line"><span class="comment">             * space is expensive, so stop here waiting for better times...</span></span><br><span class="line"><span class="comment">             * The dictionary will be resized asap. */</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. */</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            sampled = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个db最多抽样这么多个</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; config_keys_per_loop)</span><br><span class="line">                num = config_keys_per_loop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Here we access the low level representation of the hash table</span></span><br><span class="line"><span class="comment">             * for speed concerns: this makes this code coupled with dict.c,</span></span><br><span class="line"><span class="comment">             * but it hardly changed in ten years.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Note that certain places of the hash table may be empty,</span></span><br><span class="line"><span class="comment">             * so we want also a stop condition about the number of</span></span><br><span class="line"><span class="comment">             * buckets that we scanned. However scanning for free buckets</span></span><br><span class="line"><span class="comment">             * is very fast: we are in the cache line scanning a sequential</span></span><br><span class="line"><span class="comment">             * array of NULL pointers, so we can scan a lot more buckets</span></span><br><span class="line"><span class="comment">             * than keys in the same time. */</span></span><br><span class="line">            <span class="keyword">long</span> max_buckets = num*<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">long</span> checked_buckets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> table = <span class="number">0</span>; table &lt; <span class="number">2</span>; table++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == <span class="number">1</span> &amp;&amp; !dictIsRehashing(db-&gt;expires)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx = db-&gt;expires_cursor;</span><br><span class="line">                    idx &amp;= db-&gt;expires-&gt;ht[table].sizemask;</span><br><span class="line">                    dictEntry *de = db-&gt;expires-&gt;ht[table].table[idx];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Scan the current bucket of the current table. */</span></span><br><span class="line">                    checked_buckets++;</span><br><span class="line">                    <span class="keyword">while</span>(de) &#123;</span><br><span class="line">                        <span class="comment">/* Get the next entry now since this entry may get</span></span><br><span class="line"><span class="comment">                         * deleted. */</span></span><br><span class="line">                        dictEntry *e = de;</span><br><span class="line">                        de = de-&gt;next;</span><br><span class="line"></span><br><span class="line">                        ttl = dictGetSignedIntegerVal(e)-now;</span><br><span class="line">                        <span class="keyword">if</span> (activeExpireCycleTryExpire(db,e,now)) expired++;</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">/* We want the average TTL of keys yet</span></span><br><span class="line"><span class="comment">                             * not expired. */</span></span><br><span class="line">                            ttl_sum += ttl;</span><br><span class="line">                            ttl_samples++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sampled++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                db-&gt;expires_cursor++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            total_sampled += sampled;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Do a simple running average with a few samples.</span></span><br><span class="line"><span class="comment">                 * We just use the current estimate with a weight of 2%</span></span><br><span class="line"><span class="comment">                 * and the previous estimate with a weight of 98%. */</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就是检查并设置timelimit_exit</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (sampled == <span class="number">0</span> ||</span><br><span class="line">                 (expired*<span class="number">100</span>/sampled) &gt; config_cycle_acceptable_stale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed = ustime()-start;</span><br><span class="line">    server.stat_expire_cycle_time_used += elapsed;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update our estimate of keys existing but yet to be expired.</span></span><br><span class="line"><span class="comment">     * Running average with this sample accounting for 5%. */</span></span><br><span class="line">    <span class="keyword">double</span> current_perc;</span><br><span class="line">    <span class="keyword">if</span> (total_sampled) &#123;</span><br><span class="line">        current_perc = (<span class="keyword">double</span>)total_expired/total_sampled;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        current_perc = <span class="number">0</span>;</span><br><span class="line">    server.stat_expired_stale_perc = (current_perc*<span class="number">0.05</span>)+</span><br><span class="line">                                     (server.stat_expired_stale_perc*<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="propagateExpire"><a href="#propagateExpire" class="headerlink" title="propagateExpire"></a>propagateExpire</h2><p>在前面的代码中，还看到<code>propagateExpire</code>的使用。我们知道，在主从结构下，键实际的expire操作是在Master完成的。在expire之后，Master会发送DEL指令给Slave和AOF，也就是这个函数。<br>在注释中还指出，因为AOF，以及Master到Slave的连接都是保证有序的，所以即使有操作去写已经失效的key，都能保证结果是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    robj *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    argv[<span class="number">0</span>] = lazy ? shared.unlink : shared.del;</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    incrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    propagate(server.delCommand,db-&gt;id,argv,<span class="number">2</span>,PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="propagate机制"><a href="#propagate机制" class="headerlink" title="propagate机制"></a>propagate机制</h1><p>在expire中，提到了<code>propagate</code>函数，因此这里也顺便介绍一些propagate机制。<br>propagate机制是Redis主从复制逻辑的一部分，通常来说，Redis主从复制<a href="http://redisbook.com/preview/replication/replicate-before-2-8.html" target="_blank" rel="noopener">包含两个机制</a>：</p><ol><li>sync/psync机制<br> 用来处理sync和psync指令，也就是刚开始同步的情况，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>propagate机制<br> 将指令从Master同步到Slave或者AOF文件。</li></ol><p>propagate机制将特定的指令传播给AOF或者Slave，这些指令有下面几种：</p><ol><li><code>PROPAGATE_NONE</code><br> 压根就不传播。</li><li><code>PROPAGATE_AOF</code><br> 如果开启了AOF，就传播给AOF。此时就会调用AOF的主入口函数<code>feedAppendOnlyFile</code>。关于RDB和AOF机制，我们在专门的文章介绍。</li><li><code>PROPAGATE_REPL</code><br> 传播给Slave。同样调用<code>replicationFeedSlaves</code>函数。</li></ol><p>根据注释，不能够在各个command的实现代码中使用这个函数，因为它不会wrap the resulting commands in MULTI/EXEC，如果需要，应该用<code>alsoPropagate</code>、<code>preventCommandPropagation</code>、<code>forceCommandPropagation</code>等。<br>However for functions that need to (also) propagate out of the context of a command execution, for example when serving a blocked client, you want to use propagate().</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="evict实现"><a href="#evict实现" class="headerlink" title="evict实现"></a>evict实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis对当前执行环节的判断</p><ol><li><code>server.masterhost == NULL</code><br> 常常被用来判断是不是Master服务器</li><li><code>server.current_client != server.master</code><br> 根据注释，这是指的服务器的当前客户端，仅用于崩溃报告。</li><li><code>sentinelRedisInstance-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)</code></li><li><code>sentinelRedisInstance-&gt;slave_master_host</code></li></ol><p>大家都知道，Redis里面有下面<a href="https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/" target="_blank" rel="noopener">几种evict policy</a>：</p><ol><li>noeviction<br> 这是默认情况。<br> 内存爆了，就直接报错。</li><li>allkeys-lru<br> 对所有的键做LRU。</li><li>allkeys-lfu<br> 对所有的键做LFU。</li><li>allkeys-random<br> 对所有的key做随机删除。</li><li>volatile-lru/volatile-lfu/volatile-random<br> 这是对有expire的键做对应的操作。</li><li>volatile-ttl<br> 删除剩余生命最短的键。</li></ol><p>而对应的实现，就在<code>freeMemoryIfNeeded</code>中。根据注释，这个函数被定时调用，当发现超出最大使用内存后，就会释放相关内存。如果释放内存成功，或者我们不需要释放内存，那么返回<code>C_OK</code>；如果我们没有能够释放足够的内存，那么返回<code>C_ERR</code>。总之一堆废话。。。其实我们想了解的是这几个问题：</p><ol><li>如何计算现在已经使用了多少内存？</li><li>如何实现LFU和LRU？</li><li>释放内存会对其他模块产生什么影响？</li></ol><h2 id="LRU和LFU的一般实现及优缺点讨论"><a href="#LRU和LFU的一般实现及优缺点讨论" class="headerlink" title="LRU和LFU的一般实现及优缺点讨论"></a>LRU和LFU的一般实现及优缺点讨论</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>对于LRU，一个队列就行了，我们把最近用到的元素放到队列尾部，需要evict的时候就弹出头部，一般用双向队列就行。但这样查找一个Key就变成<code>O(n)</code>的了，但这也不难，我们只需要用一个map记录一下对应元素在队列中的位置就行。也就是说，用hash+双向链表来维护。hash用来实现O(1)查询，双向链表用来维护顺序。</p><p>Redis并没有采用这个办法来维护一个LRU，显然内存开销很大，这是值得的么？<a href="https://juejin.cn/post/6844903454654087182" target="_blank" rel="noopener">文章</a>中提到，当<code>maxmemory-samples</code>数为<a href="https://segmentfault.com/a/1190000017555834" target="_blank" rel="noopener">10</a>的时候，近似LRU算法的性能已经很好了。此外，Redis实际上是记录了最后一次访问某个key的时间戳的(倒不是因为复用LFU的空间了，毕竟LRU是先有的)。到了我们这个版本的代码，近似LRU又被优化了，出现了一个<code>evictionPoolEntry</code>。这个pool的容量是16，里面的key是按照lru有序排列的。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>对于LFU，我们需要记录对应的访问次数，在淘汰时，选择最少访问次数的键值对。此时，队列的性质就不够用了，但可以考虑下面的方案</p><ol><li>用优先队列，把访问次数作为key，大不了手动实现一个二叉堆嘛。</li><li>用一个双层链表，第一层是从0开始的访问次数，第二层是具有这个访问次数的所有键值对的开链表。为了节约空间，第一层可以是哈希表的形式。</li></ol><h2 id="Redis的LRU和LFU实现"><a href="#Redis的LRU和LFU实现" class="headerlink" title="Redis的LRU和LFU实现"></a>Redis的LRU和LFU实现</h2><p>本章介绍了Redis对LRU和LFU数据结构的维护，这是必要的前置知识。<br>这一部分的实现是在先前介绍过的<code>lookupKey</code>函数中。根据<code>server.maxmemory_policy</code>分别用LRU和LFU进行维护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lookUpKey</span></span><br><span class="line"><span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        updateLFU(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的evict的时刻是<code>freeMemoryIfNeeded</code>函数。<br>Redis对每个<code>robj</code>对象去维护了一个<code>lru:LRU_BITS</code>字段。在3.0版本，这个字段被用来存储当前秒级别的时间戳。在往后的版本中还支持LFU模式，会复用这个字段。</p><p>维护了的LRU或者是LFU在<code>evictionPoolPopulate</code>中起作用，会分别根据<code>estimateObjectIdleTime</code>和<code>255-LFUDecrAndReturn(e)</code>进行排序</p><h3 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h3><p><code>LRU_CLOCK</code>这里会选择是直接用<code>server.lruclock</code>(也是在<code>serverCron</code>里面调用<code>getLRUClock</code>设置的)，或者直接自己调用一次<code>getLRUClock</code>。这个比较是怎么来的呢？有必要介绍一下，毕竟诸如<code>run_with_period</code>里面也有这样的比较。<br>首先，在<a href="/2020/10/18/redis-sentinel/">文章</a>中已经介绍过，<code>server.hz</code>指的是表示一秒钟被触发多少次。那么<code>1000/server.hz</code>就表示触发1次要多少毫秒。<code>LRU_CLOCK_RESOLUTION</code>的默认值是1000，表示时钟精度是1000毫秒调用一次。所以只要LRU的精度小于server调用的精度，就可以复用server.lruclock，从而少调用一次getLRUClock。<br>【Q】岂不是大多数情况下都可以复用server的时钟？毕竟hz不会为0.5啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        lruclock = server.lruclock;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-1"><a href="#LFU-1" class="headerlink" title="LFU"></a>LFU</h3><p>在访问一个对象的时候，用<code>updateLFU</code>更新<code>lru</code>字段。这个函数会在高16位存一个分钟级别的时间戳ldt，在低8位存访问计数counter。这两个值被存放在一个字段中完全是为了节省空间和复用字段，其组合后的值整体上没有实际意义。<br>更新<code>lru</code>需要注意两点，<strong>即要根据时间衰减，但也要根据访问次数增长</strong>。首先，通过<code>LFUDecrAndReturn</code>，计算通过当前时间和ldt的差值去减少<code>counter</code>。然后通过<code>LFULogIncr</code>以一定概率增加counter。最后，将最新的counter和ldt重新组装起来存入<code>-&gt;lru</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 组装lru字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加counter"><a href="#增加counter" class="headerlink" title="增加counter"></a>增加counter</h4><p>介绍<code>counter</code>随访问次数的增长。<br>每次访问，都需要增加访问计数，但<code>counter</code>的增长并不是访问一次就+1。而是每次访问以<code>[0,1]</code>之间的概率<code>p</code>来增长，当它大于随机<code>r</code>的阈值后才会自增<code>counter</code>。<br>其中<code>p</code>的值是<code>1.0/(baseval*lfu_log_factor+1)</code>，其中<code>baseval</code>为<code>max(0,counter-LFU_INIT_VAL)</code>。</p><p>不妨讨论下baseval：</p><ol><li>baseval=0，p=1</li><li>baseval=1，p=0.09</li><li>baseval=10，p=0.009</li></ol><p>可以看到：</p><ol><li><code>counter</code>越大，<code>counter</code>的自增概率就越小。</li><li><code>lfu_log_factor</code>越大，<code>counter</code>的自增概率就越小<br> 所以为了支持存储更高的访问频次，我们就需要设置更大的<code>lfu_log_factor</code>。</li></ol><p>事实上<code>counter</code>的增长和访问次数是<strong>成对数关系</strong>的。所以这8 bits足够存储很大的命中次数。<br>在更新版本的<a href="https://github.com/redis/redis/blob/9ab873d9d35e789a228c5281d57c9c4fdc1e4ce1/redis.conf#L2156" target="_blank" rel="noopener">redis.conf</a>中，列出了不同<code>lfu_log_factor</code>取值下，若干次hit之后，counter增加的数量。</p><p>因为r是随机取的，所以可能用数学计算挺困难的。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br><span class="line">| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |</span><br><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br><span class="line">| 0      | 104        | 255        | 255        | 255        | 255        |</span><br><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br><span class="line">| 1      | 18         | 49         | 255        | 255        | 255        |</span><br><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br><span class="line">| 10     | 10         | 18         | 142        | 255        | 255        |</span><br><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br><span class="line">| 100    | 8          | 11         | 49         | 143        | 255        |</span><br><span class="line"><span class="code">+--------+</span>------------<span class="code">+------------+</span>------------<span class="code">+------------+</span>------------+</span><br></pre></td></tr></table></figure><p>还需要特别介绍下<code>LFU_INIT_VAL</code>，每个对象在初始化时，对应的counter是<code>LFU_INIT_VAL</code>即5。没有这个，那么在<code>LFUDecrAndReturn</code>的时候，counter就会因为很小而被淘汰掉。但因为偏移了这个5，所以在<code>LFULogIncr</code>我们需要将它还原回实际的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="comment">// 确保不会回绕</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 随机数r</span></span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p小于该随机数r才增长</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-log-factor"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_log_factor, <span class="number">10</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h4 id="衰减counter"><a href="#衰减counter" class="headerlink" title="衰减counter"></a>衰减counter</h4><p><code>LFUDecrAndReturn</code>返回<code>counter</code>，表示当前对象的frequency。<br>此外，如果到了需要减少<code>counter</code>的时候，会尝试减少<code>num_periods</code>。它也不完全是两个时间相减，而是要除以<code>lfu_decay_time</code>。<br><code>server.lfu_decay_time</code>是个衰变因子，默认是1，也就是不衰减。这时候对<code>counter</code>的减少就是经过的分钟数。它还有个特殊值0，表示每次都不衰减(文档上可能错了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出老的分钟时间戳</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 取出老的计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? </span><br><span class="line">        LFUTimeElapsed(ldt) / server.lfu_decay_time : </span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-decay-time"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_decay_time, <span class="number">1</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>简单介绍<code>LFUTimeElapsed</code>，用来计算从<code>ldt</code>开始经过了多少分钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得从ldt开始经过了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="comment">// 如果now小了，就当成已经wrap了刚好一次，这个和estimateObjectIdleTime的实现是类似的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="evictionPoolEntry和evictionPoolPopulate"><a href="#evictionPoolEntry和evictionPoolPopulate" class="headerlink" title="evictionPoolEntry和evictionPoolPopulate"></a>evictionPoolEntry和evictionPoolPopulate</h2><p>来看<code>evictionPoolPopulate</code>这个函数，它作用是往<code>evictionPool</code>里面加一些<code>evictionPoolEntry</code>条目。<code>evictionPool</code>由一系列<code>evictionPoolEntry</code>组成，后者表示某个数据库中的某个键。在<code>evictionPool</code>中的entry都是按照<code>idle</code>排序的，左边的idle time最小，从小到大升序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><ol><li><code>idle</code><br> 表示每个对象的空闲时间。pool里面只能加入具有更大idle time的键。如果还有空余空间，就始终加入。</li><li><code>cached</code><br> <strong>这是一个有趣的优化</strong><br> 如果key的长度比较小，它就会被存在预分配好空间的cached结构中，从而避免在key中分配空间的开销。</li><li><code>dbid</code><br> 表示这个键所属的数据库。</li></ol><p>如何根据LRU或者LFU计算idle呢？</p><ol><li><p>如果采用LRU<br> 调用<code>estimateObjectIdleTime</code>函数计算，实际上就是乘以一个<code>LRU_CLOCK_RESOLUTION</code>。这里实现上还处理了一下回绕wrap的情况。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果采用LFU<br> 这里要反向一下，就是用255减一下<code>LFUDecrAndReturn(o)</code>。因为idle和访问频率是相反的。</p></li></ol><p>输入参数：</p><ol><li><code>sampledict</code>表示从哪个dict里面进行采样，根据策略不同，可能是dict(allkeys策略)或者expire(volatile策略)。</li><li><code>keydict</code>只能是对应的dict。因为expire里面只是存一个”引用”。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code>这个函数从dict里面任意取出若干个entry。<code>server.maxmemory_samples</code>默认被设置成5个。在取出这些entry到<code>samples</code>后，我们挨个尝试将它们插入pool中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的一段代码计算这个对象的<code>idle</code>时间。首先需要讨论是否需要回dict表再查一次，得到<code>keydict</code>中的entry <code>de</code>，以及key对应的val <code>o</code>：</p><ol><li>回表的情况<br> 显然，只要<code>sampledict</code>不等于<code>keydict</code>就需要回表。因为<code>sampledict</code>肯定是expire。</li><li>不回表的情况</li><li>特殊情况：volatile-ttl策略<br> 前面两种情况都是用的<code>keydict</code>中对应的entry、key和val，但这里我们直接用<code>sampledict</code>的。</li></ol><p>然后需要讨论具体的策略，这个在前面讲过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment">         * idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment">         * just a score where an higher score means better candidate. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码计算出了当前key对应的<code>idle</code>时间，接下来将元素插入到池中。这是一个类似<strong>插入排序</strong>的过程。<br>首先，找到第一个空bucket，或者找到第一个<code>idle &lt;= pool[k].idle</code>，可以插到它前面。下面的循环能够跳过所有不满足以上条件的情况。【Q】这里能直接二分么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理两种特殊情况，第一种是我们的<code>idle</code>比pool里面所有的idle都要小，并且也没有空余的格子给我们了。第二种是bucket完全空的情况，我们可以直接用最左边的格子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，因为<code>key</code>和<code>cache</code>有点类似于<strong>自引用结构</strong>的关系，但其实不是。因为key和cached实际上都是sds，也就是个<code>char*</code>。移动或者复制sds，并没有改变sds指向的内容。所以，我们只需要保证<strong>只要它不释放就行</strong>。<br>当然，发散一下，如果<code>key</code>是一个指向<code>cached</code>的<code>sds*</code>，那就真的是自引用结构了。但也并不需要绑定<code>key</code>和它可能指向的<code>cached</code>在一个结构中，因为这两个是一一对应的</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|<span class="string"> key 1 </span>|<span class="string"> key 2 </span>|<span class="string"> key 3 </span>|<span class="string"> nul k </span>|</span><br><span class="line">|<span class="string"> nul c </span>|<span class="string"> cac 3 </span>|<span class="string"> cac 2 </span>|<span class="string"> cac 1 </span>|</span><br></pre></td></tr></table></figure><p>此时<code>k</code>是第一个满足<code>idle &lt;= pool[k].idle</code>，我们的新entry应该插入在<code>k</code>之前。下面就插入排序，把待插入的<code>de</code>插入，然后把原来<code>k</code>以及之后的数字往右边移动。这里使用了memmove，它能自动检测src内存和dest内存重叠的情况并处理，所以是更安全的memcpy。<br>分为两种情况：</p><ol><li>最右边还有空位，将[k,)整体右移一格，新entry预计插入<code>k</code>处<br> 尽管这时候最右边的cached是空，但我们还是需要备份。否则就会泄露掉那一块内存。</li><li>最右边没有空位，将整个数组右移一格，新entry预计插入在<code>k-1</code>处<br> 此时最左边是idle最小的，将它从pool里面去掉，换成idle更大的。<br> 但同时，也要保证最左边的cached不被意外释放。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，将新entry插入pool中。这里说明下cached的使用：</p><ol><li>如果<code>key</code>的长度大于<code>EVPOOL_CACHED_SDS_SIZE</code><br> 则复制<code>key</code>到<code>pool[k].key</code></li><li>如果<code>key</code>的长度较小，就可以尝试做优化，将它放在<code>cached</code>中，然后让把<code>cache</code>赋值给<code>key</code>，从而避免复制底层的字符串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">// 尝试复用pool entry中的cached SDS。因为内存分配和回收还是开销比较大的。</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictGetSomeKeys"><a href="#dictGetSomeKeys" class="headerlink" title="dictGetSomeKeys"></a>dictGetSomeKeys</h3><p><code>dictGetSomeKeys</code>这个函数，是对一个dict来说的，而不是对db来说的。<br>它不保证一定返回正好count个，也不保证返回的元素都不重复。返回值被存到<code>des</code>里面，需要保证这个数组至少能容纳<code>count</code>个。<br>取出来的指针存在<code>des</code>中返回。<code>des</code>必须预分配至少<code>count</code>个空间，尽管函数可能未必能取到<code>count</code>个。其原因可能是本来就没那么多个，或者我们经过多轮迭代没添加完。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is not suitable when you need a good distribution</span></span><br><span class="line"><span class="comment"> * of the returned items, but only when you need to "sample" a given number</span></span><br><span class="line"><span class="comment"> * of continuous elements to run some kind of algorithm or to produce</span></span><br><span class="line"><span class="comment"> * statistics. However the function is much faster than dictGetRandomKey()</span></span><br><span class="line"><span class="comment"> * at producing N elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; <span class="comment">/* internal hash table id, 0 or 1. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; <span class="comment">/* 1 or 2 tables? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>首先，执行一点渐进式rehash。然后将<code>maxsizemask</code>设置为所有ht(没有rehash是1个，有是2个)的最大容量。<br>将<code>i</code>设置为随机一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Try to do a rehashing work proportional to 'count'. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">    <span class="comment">/* Pick a random point inside the larger table. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面进入主循环，循环条件有两个，一个是取满count个，一个是执行最多<code>maxsteps=count*10</code>次。<br>在每一次迭代中，对所有的ht（1或2个）进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">/* Continuous empty entries so far. */</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>涉及到rehashidx相关的逻辑，表示在每次进入<code>dictRehash</code>函数的时候，首先<code>ht[0].table[rehashidx]</code>这个桶。如果现在在rehash过程中，到<code>d-&gt;rehashidx</code>为止的所有index都已经被访问过了。实际上这些桶里面都空(not populated)了，因此我们可以跳过<code>ht[0]</code>里面$[0,idx-1]$这个区间的关卡，直接去看<code>ht[1]</code>里面的。这其实是一个优化，在<code>dictRehash</code>实现中，也有对空桶跳过的优化。<br>特别地，如果<code>i</code>在<code>ht[1]</code>里面也已经超了，这就表示截止到<code>rehashidx</code>两个表里面都没有了。【Q】为什么可以认为<code>ht[1]</code>中的<code>rehashidx</code>之前的也不需要判定了呢？或者说，为啥两个ht可以共享一个<code>i</code>呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">/* Out of range for this table. */</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们会统计遇到连续空桶的数量，如果超过了5个，就重新随机一个位置。</span></span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123;</span><br><span class="line">                    i = random() &amp; maxsizemask;</span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，我们使用桶里面所有的元素</span></span><br><span class="line">                emptylen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (he) &#123;</span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在主循环结束后，会自增<code>i</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主逻辑freeMemoryIfNeeded"><a href="#主逻辑freeMemoryIfNeeded" class="headerlink" title="主逻辑freeMemoryIfNeeded"></a>主逻辑freeMemoryIfNeeded</h2><p><code>freeMemoryIfNeeded</code>函数是evict的主要逻辑。<br>首先，如果是从服务器，并且配置了<code>server.repl_slave_ignore_maxmemory</code>就忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* By default replicas should ignore maxmemory</span></span><br><span class="line"><span class="comment">     * and just be masters exact copies. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就来计算占用了多少内存<code>mem_reported</code>，主要函数<code>getMaxmemoryState</code>我们放在后面单独讲解。<code>mem_reported</code>表示总共用了多少内存，<code>mem_tofree</code>表示应该释放多少内存(不算Slave和AOF的缓存)。<br><code>clientsArePaused</code>的检查，有点奇怪。根据注释，它的意思是，如果client都被pause了，那么数据就是静止的。不仅对于所有的client是这样，对于还没有做expire和evict的所有key也是这样。我觉得这应该是一个优化，防止在这种情况下再走下面的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency, lazyfree_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="keyword">int</span> result = C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>latencyStartMonitor</code>这个宏和stopwatch一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面开始根据淘汰政策<code>maxmemory_policy</code>进行讨论，如果是noeviction，那就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个内存释放过程是多次的，因此用一个循环来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理要排序的情况"><a href="#处理要排序的情况" class="headerlink" title="处理要排序的情况"></a>处理要排序的情况</h3><p>第一个if，用来处理所有需要排序的情况。查看代码，要用while循环去找<code>bestkey</code>，原因是可能从pool里面找到的key不存在了，【Q】可是究竟什么情况下会发生这个情况呢？<br>循环里面的过程就是我们去遍历整个数据库里面的所有db，如果它的<code>dict</code>或者<code>expires</code>不为空，则调用<code>evictionPoolPopulate</code>。这个函数会往pool里面加入一些key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，我们遍历整个pool，找到最合适的一个。解释几个问题：</p><ol><li>为什么要从尾往头遍历？<br> 在对evictionPool的介绍中提到，它是有序的，最左边的idle time最小，最右边的最大，因此优先淘汰右边的。</li><li>为什么要有bestdbid？将key之间的比较转化为数据库之间的比较么？</li><li><code>server.db[pool[k].dbid]</code>是什么鬼？<br> 实际上是要选择<code>pool[k].dbid</code>这个db。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                        <span class="comment">// 这个很奇怪，什么时候会出现这种情况呢？</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理随机情况"><a href="#处理随机情况" class="headerlink" title="处理随机情况"></a>处理随机情况</h3><p>第二个if，用来处理随机的情况。这个很简单，直接调用<code>dictGetRandomKey</code>就行，和eviction pool也没啥关系了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>如果我们找到了要删除的元素<code>bestkey</code>，就执行删除元素过程。<br>首先，调用老朋友<code>propagateExpire</code>，这个会发送一条删除指令给AOF/Slave。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，我们统计这次evict释放了多少内存，就是首尾两个<code>zmalloc_used_memory</code>相减。这个有点粗略了，就在刚才我们还将AOF/Slave缓存单独拿出来算的呢，现在直接总内存相减了。在注释中还提到，有可能用来<code>propagateExpire</code>的内存比我们释放的db内存还多呢，但我们是管不了的，否则<code>mem_freed &lt; mem_tofree</code>这个循环条件永远达不到了。并且，这些缓存终究会被释放的。<br>这里还统计了一下调用dictSyncDelete等的时间，并且通过<code>latencyAddSampleIfNeeded</code>放到统计里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            signalModifiedKey(<span class="literal">NULL</span>,db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些统计性的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在循环中就强制往Slave发送数据，确保即使在要传的数据都很大的情况下，我们仍然能够快速传递。<br>特别地，我们在<code>while (mem_freed &lt; mem_tofree)</code>这个循环的最后，还会有条件地检查一下内存是不是达标。这个主要是对异步删除来说的，在这种情况下，<code>dbAsyncDelete</code>流程中对内存的释放未必能和我们循环这边同步起来。所以我们每释放16个键，就检查一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                    <span class="comment">/* Let's satisfy our stop condition. */</span></span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (result != C_OK) &#123;</span><br><span class="line">        latencyStartMonitor(lazyfree_latency);</span><br><span class="line">        <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                result = C_OK;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(lazyfree_latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"eviction-lazyfree"</span>,lazyfree_latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMaxmemoryState"><a href="#getMaxmemoryState" class="headerlink" title="getMaxmemoryState"></a>getMaxmemoryState</h2><p>这个函数获得内存的使用情况，包括：</p><ol><li>total<br> 总共使用的内存。<br> 来自<code>zmalloc_used_memory</code>。</li><li>logical<br> 即<code>mem_used</code>，表示出了Slave/AOF buffer之外的内存。<br> 这个计算就是要减去<code>overhead</code>，也就是Slave/AOF buffer的内存，用<code>freeMemoryGetNotCountedMemory</code>计算得到的。</li><li>level<br> 表示内存使用率</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxmemoryState</span><span class="params">(<span class="keyword">size_t</span> *total, <span class="keyword">size_t</span> *logical, <span class="keyword">size_t</span> *tofree, <span class="keyword">float</span> *level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面获得了总内存量，如果没有设置最大内存，或者总内存量都没有操作，也不需要计算比例，那么就直接返回了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We may return ASAP if there is no need to compute the level. */</span></span><br><span class="line">    <span class="keyword">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>计算两个缓冲区占用的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the ratio of memory usage. */</span></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="keyword">float</span>)mem_used / (<span class="keyword">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><p>在前面的代码中可以看到下面的语句，实际上是对主数据库<code>c-&gt;db</code>进行修改后，需要进行事件通知，我们将在下面介绍这几个语句的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">    <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure><h3 id="signalModifiedKey"><a href="#signalModifiedKey" class="headerlink" title="signalModifiedKey"></a>signalModifiedKey</h3><p><code>signalModifiedKey</code>是key被修改的钩子函数，每当数据库<code>c-&gt;db</code>里面的key被改动时，会调用这个函数。这里的key发生改动也包括key对应的值发生改动，这是因为从<code>genericSetKey</code>的实现可以看到，SET指令也会导致<code>signalModifiedKey</code>被调用。<br>此外，根据注释，每一次DB被flush时，<code>signalFlushDb</code>会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(client *c, redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">    trackingInvalidateKey(c,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="touchWatchedKey"><a href="#touchWatchedKey" class="headerlink" title="touchWatchedKey"></a>touchWatchedKey</h4><p><code>touchWatchedKey</code>字如其名，它的作用是让WATCH这个键的事务失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里先特判一下，如果<code>db-&gt;watched_keys</code>为空就直接返回，这个用法在redis中非常常见，我猜想可能是<code>dictFind</code>的开销还是比较大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面从<code>db-&gt;watched_keys</code>上拿到WATCH这个key的所有的client，并且对这个链表上的每一个client设置<code>CLIENT_DIRTY_CAS</code>这个flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 这个函数是dictFind(只能得到dictEntry)和dictGetVal的简单封装</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trackingInvalidateKey"><a href="#trackingInvalidateKey" class="headerlink" title="trackingInvalidateKey"></a>trackingInvalidateKey</h4><p>下面看另一个函数<code>trackingInvalidateKey</code>。这个系列的函数是在Redis6.0左右被引入的，主要用途是维护客户端缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper (the one actually called across the core) to pass the key</span></span><br><span class="line"><span class="comment"> * as object. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKey</span><span class="params">(client *c, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    trackingInvalidateKeyRaw(c,keyobj-&gt;ptr,sdslen(keyobj-&gt;ptr),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key的值被改变后，在keys tracking的逻辑下，我们的任务是给每一个有可能缓存了当前keys的client发送通知。如果传入的<code>c</code>为空，表示这个不是一个client的场景，而是例如服务器内部做expire。<br><code>bcast</code>参数的作用是是否要将这个key通过BCAST模式广播给client们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * This is the case when the function is called from the Redis core once a key is modified, however</span></span><br><span class="line"><span class="comment"> * we also call the function in order to evict keys in the key table in case</span></span><br><span class="line"><span class="comment"> * of memory pressure: in that case the key didn't really change, so we want</span></span><br><span class="line"><span class="comment"> * just to notify the clients that are in the table for this key, that would</span></span><br><span class="line"><span class="comment"> * otherwise miss the fact we are no longer tracking the key for them. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKeyRaw</span><span class="params">(client *c, <span class="keyword">char</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> bcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TrackingTable == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcast &amp;&amp; raxSize(PrefixTable) &gt; <span class="number">0</span>)</span><br><span class="line">        trackingRememberKeyToBroadcast(c,key,keylen);</span><br><span class="line"></span><br><span class="line">    rax *ids = raxFind(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen);</span><br><span class="line">    <span class="keyword">if</span> (ids == raxNotFound) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    raxIterator ri;</span><br><span class="line">    raxStart(&amp;ri,ids);</span><br><span class="line">    raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> id;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;id,ri.key,<span class="keyword">sizeof</span>(id));</span><br><span class="line">        client *target = lookupClientByID(id);</span><br><span class="line">        <span class="comment">/* Note that if the client is in BCAST mode, we don't want to</span></span><br><span class="line"><span class="comment">         * send invalidation messages that were pending in the case</span></span><br><span class="line"><span class="comment">         * previously the client was not in BCAST mode. This can happen if</span></span><br><span class="line"><span class="comment">         * TRACKING is enabled normally, and then the client switches to</span></span><br><span class="line"><span class="comment">         * BCAST mode. */</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span> ||</span><br><span class="line">            !(target-&gt;flags &amp; CLIENT_TRACKING)||</span><br><span class="line">            target-&gt;flags &amp; CLIENT_TRACKING_BCAST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client enabled the NOLOOP mode, don't send notifications</span></span><br><span class="line"><span class="comment">         * about keys changed by the client itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;flags &amp; CLIENT_TRACKING_NOLOOP &amp;&amp;</span><br><span class="line">            target == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendTrackingMessage(target,key,keylen,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    raxStop(&amp;ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the tracking table: we'll create the radix tree and populate it</span></span><br><span class="line"><span class="comment">     * again if more keys will be modified in this caching slot. */</span></span><br><span class="line">    TrackingTableTotalItems -= raxSize(ids);</span><br><span class="line">    raxFree(ids);</span><br><span class="line">    raxRemove(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyKeyspaceEvent"><a href="#notifyKeyspaceEvent" class="headerlink" title="notifyKeyspaceEvent"></a>notifyKeyspaceEvent</h3><p>函数<code>notifyKeyspaceEvent</code>用来触发数据库事件，这个对应了Redis中的叫<a href="http://redisdoc.com/topic/notification.html" target="_blank" rel="noopener">“键空间通知”/“键事件通知”</a>的特性。这个特性是通过<strong>PUBLISH</strong>机制实现的。<br>简单来说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL key [key ...]</code>命令时，系统将分发两条消息，相当于执行以下两个<a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a>命令。其中<code>__keyspace</code>系列命令称为键空间通知(key-space notification)，<code>__keyevent</code>系列命令称为键事件通知(key-event notification)。订阅第一个PUBLISH命令，可以接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件。订阅第二个PUBLISH命令，可以接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>下面看看这个函数的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If any modules are interested in events, notify the module system now.</span></span><br><span class="line"><span class="comment">     * This bypasses the notifications configuration, but the module engine</span></span><br><span class="line"><span class="comment">     * will only call event subscribers if the event type matches the types</span></span><br><span class="line"><span class="comment">     * they are interested in. */</span></span><br><span class="line">    moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If notifications for this class of events are off, return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyspace@"</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyevent@"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="Redis内存管理zmalloc"><a href="#Redis内存管理zmalloc" class="headerlink" title="Redis内存管理zmalloc"></a>Redis内存管理zmalloc</h2><p>Redis基于zmalloc系列函数进行内存分配。<br>zmalloc是为了解决什么问题呢？主要是为了做到异常处理和内存统计的功能。<br>下面看<code>zmalloc</code>的实现。<br>可以看到，它会额外分配一个<code>PREFIX_SIZE</code>，用来存储额外信息。<code>zmalloc</code>最终返回的是<code>(char*)ptr+PREFIX_SIZE</code>，这个有点类似于SDS的骚操作。<code>PREFIX_SIZE</code>的大小是由宏来定义的，并且可以通过<code>HAVE_MALLOC_SIZE</code>禁用内存统计的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 如果不记录内存分配大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果记录内存分配大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面仔细查看一下<code>update_zmalloc_stat_alloc</code>函数的实现，不出所料的话，应该是通过一个原子操作来实现更新的。实际上也果不其然，<code>atomicIncr</code>的实现在后面会讲到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) atomicIncr(used_memory,(__n))</span></span><br></pre></td></tr></table></figure><p>还可以看到的是一个用来处理oom的函数<code>zmalloc_oom_handler</code>。对于C语言来说，<code>malloc</code>在内存分配失败后会返回一个0指针，然后我们在进行后续操作的时候要自行判断。基本上对于oom的处理就是打印一条日志然后abort了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisOutOfMemoryHandler</span><span class="params">(<span class="keyword">size_t</span> allocation_size)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Out Of Memory allocating %zu bytes!"</span>,</span><br><span class="line">        allocation_size);</span><br><span class="line">    serverPanic(<span class="string">"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"</span>, </span><br><span class="line">        allocation_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)</span></span><br><span class="line"><span class="comment">// debug.c</span></span><br><span class="line"><span class="keyword">void</span> _serverPanic(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *msg, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,msg);</span><br><span class="line">    <span class="keyword">char</span> fmtmsg[<span class="number">256</span>];</span><br><span class="line">    vsnprintf(fmtmsg,<span class="keyword">sizeof</span>(fmtmsg),msg,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    bugReportStart();</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"!!! Software Failure. Press left mouse button to continue"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Guru Meditation: %s #%s:%d"</span>,fmtmsg,file,line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.crashlog_enabled) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">        logStackTrace(<span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        printCrashReport();</span><br><span class="line">    &#125;</span><br><span class="line">    bugReportEnd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bugReportStart</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bug_report_start_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bug_report_start == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLogRaw(LL_WARNING|LL_RAW,</span><br><span class="line">        <span class="string">"\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n"</span>);</span><br><span class="line">        bug_report_start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bug_report_start_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下本章节中比较有意思的实现：</p><ol><li>LFU算法</li><li>evictPoolEntry中，key和cached的维护</li><li>诸如keyptrDictType和dbDictType这种C形式的OOP的实现</li><li>Redis对OOM的管理</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://my.oschina.net/lscherish/blog/4467394" target="_blank" rel="noopener">https://my.oschina.net/lscherish/blog/4467394</a><br> 对Redis中的LRU和LFU进行了讲解。本文吸纳了其中的部分内容并进行了修订。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为原&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;《Redis底层对象实现原理分析》&lt;/a&gt;太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redisDb，以及在这上面的增删改查&lt;/li&gt;
&lt;li&gt;Redis的expire和evict机制&lt;/li&gt;
&lt;li&gt;Redis的事件机制&lt;/li&gt;
&lt;li&gt;Redis的主从复制(一部分)&lt;br&gt; 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。&lt;br&gt; 本文介绍的部分比如propagate机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文中不介绍的是，它们在系列的其他文章中讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis的对象实现&lt;/li&gt;
&lt;li&gt;Redis Sentinel&lt;/li&gt;
&lt;li&gt;Redis Cluster&lt;/li&gt;
&lt;li&gt;Redis AOF/RDB&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>我们如何消除两个开源项目之间长达 4 年的分叉</title>
    <link href="http://www.calvinneo.com/2022/10/13/decouple-tikv/"/>
    <id>http://www.calvinneo.com/2022/10/13/decouple-tikv/</id>
    <published>2022-10-13T11:20:33.000Z</published>
    <updated>2022-10-24T11:55:08.661Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects" target="_blank" rel="noopener">https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>TiFlash 源码解读：TiFlash Proxy 模块</title>
    <link href="http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/"/>
    <id>http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/</id>
    <published>2022-08-25T11:20:33.000Z</published>
    <updated>2022-10-24T11:53:31.898Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/tiflash-source-code-reading-7" target="_blank" rel="noopener">https://cn.pingcap.com/blog/tiflash-source-code-reading-7</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的文件系统</title>
    <link href="http://www.calvinneo.com/2022/06/21/linux-fs/"/>
    <id>http://www.calvinneo.com/2022/06/21/linux-fs/</id>
    <published>2022-06-21T13:48:56.000Z</published>
    <updated>2022-06-21T13:34:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Linux 文件系统。</p><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cnblogs.com/zl1991/p/10288291.html" target="_blank" rel="noopener">https://www.cnblogs.com/zl1991/p/10288291.html</a><br> O_SYNC 和 O_DIRECT</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Linux 文件系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://www.calvinneo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++中的异常</title>
    <link href="http://www.calvinneo.com/2022/03/19/exception_cpp/"/>
    <id>http://www.calvinneo.com/2022/03/19/exception_cpp/</id>
    <published>2022-03-19T11:20:33.000Z</published>
    <updated>2022-03-18T16:25:23.486Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。</p><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>F1的在线异步DDL</title>
    <link href="http://www.calvinneo.com/2022/01/28/f1-ddl/"/>
    <id>http://www.calvinneo.com/2022/01/28/f1-ddl/</id>
    <published>2022-01-28T15:33:22.000Z</published>
    <updated>2022-07-16T06:06:54.484Z</updated>
    
    <content type="html"><![CDATA[<p>介绍F1的在线异步DDL schema变更。</p><a id="more"></a><h1 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h1><h2 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h2><p>我们需要处理DDL执行进度不一致的问题，比如：</p><ol><li>Node A已经处理了a/b/c三个DDL</li><li>Node B刚处理完a这个DDL</li></ol><p>假定c是创建一个表，那么Node A能看见这个表，而Node B则看不见。那么分别从Node A和B查询，就会发现数据不一致的情况。</p><p>具体来说，有两类不一致问题需要考虑：</p><ol><li>orphan data anomaly<br> 违反1/3/5/7</li><li>integrity anomaly<br> 违反2/4/6</li></ol><p>其中：</p><ol><li>所有 ColumnKV 都能找到一个包含它的 Row 和 Table。</li><li>所有 Row 都包含所有非空列的 ColumnKV。</li><li>所有 IndexKV 都能找到一个包含它的 Index。</li><li>所有 Index 都是完整的(不存在某个 Row 缺少指向它的 IndexKV)。</li><li>所有 IndexKV 都指向有效的 Row。</li><li>没有违反 Constraint 的数据。</li><li>不存在未知的 KV(特指除上述 1，3 以外的未知 KV)。</li></ol><h2 id="分步解决问题"><a href="#分步解决问题" class="headerlink" title="分步解决问题"></a>分步解决问题</h2><p>目标1：在同一时刻改变所有Node的状态。很遗憾，因为各种延迟并不能做到。<br>妥协后的目标1：在某一时刻修改Schema，在确定的时间长度T之后，整个集群中不会有使用旧Schema的Node继续提供服务。这样在T之后这个修改就是确定生效的了。<br>方案：</p><ol><li>定时刷新<br> 每个节点会按照固定时间刷新自己的Schema。<br> 例如，可以选举出一个Owner，每个节点定时向Owner请求当前的Schema。</li><li>强制失败<br> 如果刷新失败，则停止服务，而不是继续按照旧Schema服务。</li></ol><p>目标1.1：在集群间同步最新的Schema<br>方案：借助于Spanner</p><ol><li>每次刷新时，从Spanner上的某个固定位置加载Schema。</li></ol><p>在实现目标1后，发现还是有问题。例如，虽然a/b在a+T/b+T时刻被完成，但在a+T之前的某个时刻，我们仍然不知道当前状态是a已生效，还是ab都已生效。如果在加上个c，那么情况更复杂。</p><p>目标2：在同一时刻，只会有最多两个Schema生效。例如在同一时刻内，最多只有DDL a之前的状态和DDL a之后的状态生效。<br>分析：直接Bruteforce搞就行，比如插一个barrier，等到DDL a确定生效(等到a+T)后，再执行DDL b。<br>方案：</p><ol><li>引入Lease，长度等于DDL确定生效的时间</li><li>每个Lease中只能执行一个DDL</li><li>我们在T+2个Lease时一定可以执行DDL b</li></ol><p>目标2.1：不会产生不合法的DML。<br>方案：write fencing</p><ol><li>事务允许跨越多个Lease。</li><li>但是，如果事务中有写操作，写操作只允许在当前Lease中进行：<ol><li>写操作在他们submit时，转换为Spanner上的KV操作</li><li>如果写操作跨Lease，可能会违反同一时刻集群中最多只有两个Schema版本生效的限制。</li></ol></li></ol><p>通过实现之前的目标进行了问题的分解，不需要处理多个DDL的进度不一致问题了。但仍然存在问题，考虑一个add index的DDL，Node A上已经执行完了，Node B则没有开始执行，然后考虑此刻开始执行的两个DML：</p><ol><li>通过Node A添加一个Row：会添加数据和索引</li><li>通过Node B删除一个Row：只会删除数据，因为尚未得到索引的schema</li></ol><p>现在如果从Node A索引读，那么会读到一开始被写入的索引，但对应的数据却被删除了。于是这里产生了<strong>孤儿索引</strong>的问题，这破坏了数据库的完整性。这是因为不同Node之间同一DDL的进度不同产生的不一致，如何解决呢？</p><p>目标3：将这一个DDL拆成多个Schema Change的步骤。由于Update可以看做是Delete+Insert，所以实际需要考虑Insert、Delete和Query三种操作。</p><p>从孤儿索引的问题可以看出，delete操作需要和insert操作分离，要拆出一个Delete Only状态，这个状态下该DDL的只对Delete操作可见，即该索引只对Delete操作可见：</p><ol><li>从None到Delete Only<br> 增和查都不会使用索引。<br> <strong>所有的删除操作会使用索引</strong>。</li><li>从Delete Only到Public<br> 不会出现孤儿索引问题了。假如Node A在Delete Only状态，它会在删除时一并删除索引；Node B在Public状态，在查询时发现索引被一并删除了。</li></ol><p>但有个新的问题，索引不会“多出来”，<strong>但却可能缺</strong>。这就得需要有个操作帮忙补索引，也就是reorg。<br>这个补索引的过程能发生在Delete Only到Public之间么？假设Node A在Delete Only阶段，它只能响应删除，然后开始为既有数据补索引，直到补完变成Public，同时可以处理增删改查。问题是这个过程中的insert，对应的索引并没有被补上啊。因此，需要引入新的状态Write Only。</p><p>于是引入Write Only状态，这个过程只不允许读：</p><ol><li>从Delete Only到Write Only</li><li>从Write Only到Public<br> 假如Node A在Write Only状态，它的<strong>所有写操作都会涉及索引</strong>。而Node B在Public状态，它也能读到Node A的修改。</li></ol><p>考虑所有节点都到达了Write Only状态，现在就可以做Reorg补上之前的索引数据了，方式很简单，就是取一个现在的Snapshot，然后照着补。此时可能有并发写的冲突问题，但Spanner的Percolator协议可以解决。</p><p>目标4：缩短Lease长度。Lease长度一般都会很长，F1中是分钟级，TiDB中也有45秒。如果完全走Lease的方案，那么一次DDL的时间就是分钟级的了，这显然很难被接受<br>方案1：直接将Lease长度缩短，例如改为1s。<br>这个方案是有问题的：</p><ol><li>在每个Lease结束后，Node需要去加载最新的Schema，这个伴随网络开销，需要时间。如果加载Schema的时间大于Lease的时间，那么就会导致刚加载的又失效了，从而重新加载，极大地降低了性能。</li></ol><p>既然方案1不行，那么就有了方案2<br>方案2：</p><ol><li>Owner在修改完DDL后，主动通知其他节点，并统计ack。如果其他节点都回复了，那么就主动确定了这个ddl在所有节点上都生效了。</li><li>如果有节点没有回复，那么再主动等2个Lease。</li></ol><h1 id="论文证明"><a href="#论文证明" class="headerlink" title="论文证明"></a>论文证明</h1><h2 id="Denotation"><a href="#Denotation" class="headerlink" title="Denotation"></a>Denotation</h2><p>一个 F1 schema 是一系列 table的定义。每个 table 包含一系列 column、index、constraint、optimistic lock。其中 constraint 包含外键以及 unique 约束。</p><h2 id="Schema-elements-and-states"><a href="#Schema-elements-and-states" class="headerlink" title="Schema elements and states"></a>Schema elements and states</h2><p>schema elements 包括 table、column、index、constraint、optimistic lock。每个 element 都可以对应 absent 和 public 两个 state。此外，还有 delete only 和 write only 两个中间态。</p><p>【定义1】一个 delete only 的 table、column 和 index 不能被读，且：</p><ol><li>如果 E 是 table 或 column，则只能被 delete</li><li>如果 E 是 index，则只能被 delete 和 update，<strong>这里的 update 不包含 create</strong><br> 注意这里的范围会更大一点了。</li></ol><p>【定义2】一个 write only 的 column 或 index 可以被 insert、delete、update，但继续不能被读。</p><p>【定义3】一个 write only 的 constraint 会在执行 insert、delete、update 操作应用。但它不能覆盖所有的已有数据。</p><h2 id="Database-consistency"><a href="#Database-consistency" class="headerlink" title="Database consistency"></a>Database consistency</h2><p>【定义4】一个 database representation(可以理解为某个快照) d consistent with respect to schema S，如果</p><ol><li>所有的 column 都属于 row 和 table</li><li>所有的 row 都具有所有 public required 的 column 值</li><li>所有的 index entry(索引数据)在 schema 中都能找到对应的 index<br> 也就是说我们写了条索引，但是 schema 里面却没有定义这一条索引</li><li>所有的 public 的 index 是完整的<br> 也就是说不会存在某一个 row 上没有对应的 index</li><li>所有的 index 都能指向 valid 的 row<br> 实际上就是不会有孤儿索引</li><li>所有的 public 的 constraint 一定是满足的</li><li>不存在未知数据</li></ol><p>这个定义在之前已经提到过了。</p><p>We denote the fact that database representation d is consistent with respect to schema S as d |= S. If d is not consistent with respect to schema S, we denote this as d |/= S.</p><p>【定义5】<strong>从 S1 到 S2 的 schema change，是 consistentcy preserving 的，当且仅当</strong>：</p><ol><li>d 在 schema S1 中任何操作下能够对 schema S2 也能保持 consistency</li><li>d 在 schema S2 中任何操作下能够对 schema S1 也能保持 consistency</li></ol><p>下图描述了不同元素的 schema 的变更。<br><img src="/img/f1/f1_schema_change.png"></p><h2 id="Adding-and-removing-schema-elements"><a href="#Adding-and-removing-schema-elements" class="headerlink" title="Adding and removing schema elements"></a>Adding and removing schema elements</h2><p>我们将 table、column和 index 称为 structural elements。它们可以被理解为决定了 Spanner 上能存储哪些 KV 数据的元素。注意 optimistic lock 因为在处理上和 column 是一致的，所以我们将它包含在 column 中讨论。</p><p>【Claim2】所有从 S1 到 S2 的 schema change，如果涉及到增加或者删除 public 的 structual element E，那么它就不是 consistency preserving 的。在下面的例子中，假设 S2 包含了 E，但 S1 没有。即从 S1 到 S2 的变换是新增。</p><ol><li>E 是 table<br> 如果对 S2 上的 E 做 insert，那么得到的 representation d2 和 S1 是不一致的。因为其中包含的新增的数据 S1 不能解析。违反了 Database consistency 中的第一条。</li><li>E 是 table R 上的 column<br> 同上</li><li>E 是 table R 上的 index<br> 如果在 S2 上的 E 做 insert，那么会同时违反3和4。对于 S1，违反了3，因为我们写入的索引在 schema 里面没找到定义。</li></ol><p>【Claim3】从 S1 到 S2 的 schema change 是 consistency preserving 的，当且仅当它在 S1 和 S2 上都能避免 orphan data 和 integrity anomaly 两种数据不一致的情况。</p><h2 id="Optional-structural-elements"><a href="#Optional-structural-elements" class="headerlink" title="Optional structural elements"></a>Optional structural elements</h2><p>这里的 Optional 指的是 element 是可选的，例如定义了 default，或者是 nullable 的。</p><p>【Claim4】【absent-&gt;delete only】考虑从 schema S1 到 schema S2 的 schema change，它添加了一个 delete only 的 structural element E。对于任意的 representation d，且 d |= S1, d |= S2。那么所有基于 S1 和 S2 在 E 上的操作都不会产生两种异常。</p><p>【Claim5】【delete only-&gt;public】类似 Claim4</p><h2 id="Required-structural-elements"><a href="#Required-structural-elements" class="headerlink" title="Required structural elements"></a>Required structural elements</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://zimulala.github.io/2016/02/02/schema-change-implement/" target="_blank" rel="noopener">http://zimulala.github.io/2016/02/02/schema-change-implement/</a></li><li><a href="https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md" target="_blank" rel="noopener">https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md</a></li><li><a href="https://disksing.com/understanding-f1-schema-change/" target="_blank" rel="noopener">https://disksing.com/understanding-f1-schema-change/</a></li><li><a href="https://tongtianta.site/paper/57876" target="_blank" rel="noopener">https://tongtianta.site/paper/57876</a><br> Online, Asynchronous Schema Change in F1</li><li><a href="https://www.zenlife.tk/schema-lease.md" target="_blank" rel="noopener">https://www.zenlife.tk/schema-lease.md</a></li><li><a href="https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/" target="_blank" rel="noopener">https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/</a></li><li><a href="https://zhuanlan.zhihu.com/p/309831009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/309831009</a><br> 一个翻译</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍F1的在线异步DDL schema变更。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>DPDK-Writing Efficient Code</title>
    <link href="http://www.calvinneo.com/2021/12/13/dpdk-coding/"/>
    <id>http://www.calvinneo.com/2021/12/13/dpdk-coding/</id>
    <published>2021-12-13T15:33:22.000Z</published>
    <updated>2021-12-14T08:21:55.883Z</updated>
    
    <content type="html"><![CDATA[<p>DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。</p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Memory-Copy"><a href="#Memory-Copy" class="headerlink" title="Memory Copy"></a>Memory Copy</h2><p>不要在数据面上使用libc函数，例如memcpy和strcpy等，推荐用<code>rte_memcpy</code>这样的优化实现，实际上就是SIMD的版本。<br>为了使用SIMD，需要保证地址不是虚拟地址，例如malloc等产生的是虚拟地址，那么在物理地址上可能是分散的，就做不了SIMD优化。</p><h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><p>避免使用malloc等在堆上分配内存，毕竟维护堆还是比较麻烦的(CSAPP的Data Lab令我记忆犹新)，并且也不容易做parallel allocation(【Q】这是啥)。<br>更为推荐的做法是对固定大小的对象构建内存池，例如<code>librte_mempool</code>/<code>rte_malloc</code>的实现。在这样的实现中需要考虑内存对齐，无锁访问，NUMA感知，批量读写，每个核心的Cache。</p><h2 id="对同一内存的并发访问"><a href="#对同一内存的并发访问" class="headerlink" title="对同一内存的并发访问"></a>对同一内存的并发访问</h2><h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><h2 id="Distribution-Across-Memory-Channels"><a href="#Distribution-Across-Memory-Channels" class="headerlink" title="Distribution Across Memory Channels"></a>Distribution Across Memory Channels</h2><h1 id="各个核心之间的通信"><a href="#各个核心之间的通信" class="headerlink" title="各个核心之间的通信"></a>各个核心之间的通信</h1><h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><h1 id="锁和原子操作"><a href="#锁和原子操作" class="headerlink" title="锁和原子操作"></a>锁和原子操作</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html" target="_blank" rel="noopener">https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html</a></li><li><a href="https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h" target="_blank" rel="noopener">https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h</a><br> rte_memcpy的源码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="编程" scheme="http://www.calvinneo.com/tags/编程/"/>
    
    <category term="性能" scheme="http://www.calvinneo.com/tags/性能/"/>
    
  </entry>
  
  <entry>
    <title>EPaxos介绍</title>
    <link href="http://www.calvinneo.com/2021/12/04/epaxos/"/>
    <id>http://www.calvinneo.com/2021/12/04/epaxos/</id>
    <published>2021-12-04T11:20:33.000Z</published>
    <updated>2022-01-06T16:26:22.844Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍EPaxos算法。</p><a id="more"></a><h1 id="Epaxos的简介"><a href="#Epaxos的简介" class="headerlink" title="Epaxos的简介"></a>Epaxos的简介</h1><p>EPaxos是一个Leaderless的算法，具有以下的优点：</p><ol><li>Client可以任意选择一个节点发送Command，这个Command的Commit的路径大部分都不会干扰到其他的Command。而在诸如Raft的算法中，必须有一个Master显式向其他节点复制日志。并且也避免了Client可能和一个跨地区的Master交互的情况。</li><li>因为没有Leader选举的过程，所以整个集群的可用性变高了。</li></ol><p>讨论Basic Paxos算法，当收到来自Client的Command后，某个replica会尝试成为一个尚未被使用过的instance的Leader，方式是发送Prepare消息。其他replica对Prepare的返回值，首先包含了它们认为的已经被chosen的Command(如果出现这种情况，Leader后面也需要使用这个Command)。在返回值中还会包含不会再ack早前的Leader发送的更旧的消息的承诺。在收到majority的对Prepare的ack之后，这个Leader会发送Accept消息。当Accept消息再被majority确认后，Leader会在本地记录Command已被Commit，并且异步通知Peer和Client。</p><p>容易发现，Paxos算法需要Prepare和Accept两个阶段，才能完成一个Command的提交。这是不经济的，因为即使从Raft的经验来看，只要Leader一直存在，那么一轮就可以决定一个instance，也就是Log Entry的值了。此外Basic Paxos中如果多个Leader打架，那2轮都不够。因此MultiPaxos中引入了stable leader(又称为distinguished proposer)的机制来处理。</p><p>EPaxos的设计目标是：</p><ol><li>减少Commit时延</li><li>优化Load Balance</li><li>对于较慢甚至故障的节点，提供一个优雅的降级方案</li></ol><p>为此，EPaxos需要做到：</p><ol><li>每个节点都可以同时作为Proposer(Command Leader)</li><li>每个Proposer在和最小数量的节点交流后就可以Commit，并且交流的次数也要最小化<br> 类似generic broadcast算法，以及Generalized Paxos算法，会广播消息。但如果两个Command不互相影响，实际上并没有必要强制他们有一个consistent的顺序。<br> 而在实际workload上，可以认为大部分的Command是这样的，也就是说它们修改的是不同的对象。</li><li>Quorum的组成应当是可变的</li></ol><p>EPaxos做到这些，得益于它给Command定序的方案。在这之前，诸如MultiPaxos和GenerizedPaxos选择通过一个Leader来选择顺序；而在 canonical Paxos和Mencius中选择将这些Command放入已经预先分配好的instance空间中。</p><p>EPaxos的方案是当对一个Command投票时，每个参与者需要附带上对这个Command的Order Constraints。EPaxos能够保证所有正常的节点能够以提交同样的Command和Order Constraints。</p><p>简介一下EPaxos的方案。当一个Command被发送给某个replica时，该replica就被称为Command Leader。这个称呼特意区别于MultiPaxos中的Leader，因为显而易见，同时可能存在多个Command Leader。</p><p>如果Command之间不冲突，如下图的左边所示，两个Command分别更新<code>obj_A</code>和<code>obj_B</code>。为了Commit这个Command，可以走论文中说的Fast Path。Command Leader需要和<code>F + floor((F + 1) / 2)</code>(称为fast-path quorum)个Peer交互。其中F是允许失败的节点的个数，对应到下图，F为2。特别地，对于常见的3节点集群，Fast-path Quorum为2；对于5节点集群，Fast-path Quorum为3，都等于传统的简单多数。</p><p>【Q】这里有个疑问，不同对象的先后顺序，有影响么？比如实际上一个Client先于<code>obj_B</code>写<code>obj_A</code>，但<code>obj_B</code>先于<code>obj_A</code>被Commit，当Client收到<code>obj_B</code>的时候读取<code>obj_A</code>，那么可能读到<code>obj_A</code>的stale的数据呢？可以看下面的Execution linearizability说明。</p><p>如果两个Command互相冲突，如下图的右边所示，C3和C4同时更新<code>obj_A</code>，就不能走Fast Path了。在提交的时候需要附带上Order Constraint。为了保证所有的Replica在存在部分节点故障的情况下，都能提交相同的Order Constraint，需要另一轮的通信。这一轮通信中，Command Leader需要和<code>F + 1</code>个Peer交互。这就是Slow Path，<code>F + 1</code>也就是传统意义上的简单多数Quorum。</p><p><img src="/img/epaxos/f1.png"></p><h2 id="EPaxos和其他算法的比较"><a href="#EPaxos和其他算法的比较" class="headerlink" title="EPaxos和其他算法的比较"></a>EPaxos和其他算法的比较</h2><p>在MultiPaxos中，Leader会负责Propose所有的Command。这样会导致Leader处理O(n)个请求，同时非Leader节点只会处理O(1)个请求，负载十分不均衡。</p><p>为了解决MultiPaxos的问题，Mencius选择逐Command将Paxos Leader在多个节点之间轮换。也就是说节点<br><code>R_id</code>拥有instance i，当i满足<code>(i mod N) = R_id</code>。这里的坏处是，每一次Commit Command A之前都需要询问所有节点。否则按照这个轮换顺序，另一个依赖于A的Command B可能在Command A之前被提交。这个询问过程会产生两个后果，首先是整个Commit的速度由最慢的那个Replica决定；其次是当一个节点Fail后，整个过程将block住，直到其他节点发现这个节点Fail掉了，并替他返回一个NoOp。</p><p>FastPaxos为了解决从Propose到Commit的延迟，选择让Client同时向所有的Replica发送Propose。MultiPaxos一样使用了Stable Leader，不仅用来开启voting round，也用来仲裁各个Acceptor的顺序(考虑到每个Acceptor可能以不同顺序收到)。</p><p>Generalized Paxos的方案是当Command之间不互相影响时，对它们乱序提交。Replicas learn commands after just two message<br>delays—which is optimal—as long as they do not interfere。TODO 后面看不懂了。</p><p>EPaxos相对于Generalized Paxos有三点优势：</p><ol><li>EPaxos的Fast Path Quorum Size比Generalized Paxos的正好小一个，能够减小延迟(应该是木桶效应吧)，以及总的消息量</li><li>EPaxos解决冲突，也就是Slow Path只需要额外一轮，但Generalized Paxos需要两轮</li><li>对于three-site replication而言，EPaxos即使在所有Command都冲突的情况下，只需要和距离Proposer最近的Replica通信一轮，即可Commit</li></ol><p>EPaxos和Fast/Generalized Paxos的<strong>Fast Path</strong>的一个重要区别是，EPaxos需3 message delays来Commit，但Fast等只需要2个。但一般EPaxos的第一个Delay可以忽略掉，因为Client和最接近的Replica通常都在一个数据中心中。</p><p>S-Paxos TODO</p><h1 id="EPaxos的实现"><a href="#EPaxos的实现" class="headerlink" title="EPaxos的实现"></a>EPaxos的实现</h1><p>结合了两篇论文的内容</p><h2 id="预备内容"><a href="#预备内容" class="headerlink" title="预备内容"></a>预备内容</h2><p>在允许F个失效节点的分布式系统中，至少存在N=2F+1个节点。对于每一个节点R，它拥有的instance写为序列R1, R2, …。在每个instance中，只有一个Command能被选出。需要注意的是，R1、R2等instance的order，并不是已经确定的，而是由协议来动态确定。</p><p>Commands γ和δ是interfere的，当存在一系列指令Σ使得顺序执行Σ,γ,δ不等价于顺序执行Σ,δ,γ。这里不等价包含它们会导致不同的状态机状态，或者导致在这些序列中读取到的值是不同的。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>Nontriviality<br> 所有被Commit的Command都由Client发出。</li><li>Stability<br> 对于任意Replica，不会丢失已经Commit的数据。<br> 进一步地，如果在t1时刻，Replica R在Q.i这个instance上提交了Command Y，那么在t1之后的任意时刻t2，R上的instanceQ.i的值也是Command Y。<br> 【Q】这里有个疑问，Q是哪里来的？不应该是R么？应该不矛盾，作为Acceptor，R也会有Q拥有的instance的信息的，不然怎么投票？</li><li>Consistency<br> 同一个instance在Commit之后，就在各个Replica上的值都是一样的。</li><li>Execution consistency<br> 如果两个interfere的Command Y和Z在任意Replica上被成功Commit了，那么所有Replica上的执行顺序是一样的。</li><li>Execution linearizability<br> 如果Client对Command Y和Command Z是serialized的，比如说在Command Y被Commit之后，才会Propose Command Z，那么所有的Replica都会先执行Y再执行Z。</li><li>Liveness<br> 活性</li></ol><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>基础版本的fast-path quorum是<code>2F</code>，后面优化版本的才是<code>F + floor((F + 1) / 2)</code></p><h3 id="Commit-Protocol"><a href="#Commit-Protocol" class="headerlink" title="Commit Protocol"></a>Commit Protocol</h3><p>Commit Protocol解决两个问题：</p><ol><li>Commit Command</li><li>Determine Order Between Commands</li></ol><p>在论文的Figure2中描述了Commit Protocol的整个过程，在Commit过程中，并不是每个过程都会走到。如果一个Command没有冲突，就可以走Fast Path，这也意味着走完Phase 1就能够直接提交了。Slow Path还需要额外的Phase 2(Paxos-Accept phase)。如果我们进行failure recovery，则需要运行Figure3描述的Explicit Prepare过程。</p><p>当一个Replica收到来自Client的Command γ后，会给这个Command γ分配一个全局唯一的instance number，例如R1、Q2等。全局唯一是通过组合Replica的名字，以及在Replica中递增的序列号保证的。这里Replica是可以将多个操作组合到一个instance中的。除了分配instance number之外，Replica还会给Command分配一个dependency set(deps)和一个sequence number(seq)，<strong>称为attribute</strong>。Dependency set包含了每个Replica中<strong>最高的</strong>和自己冲突的instance编号。Sequence number会选取一个大于dependency set中所有值的值作为<strong>初始值</strong>。The originating replica derives the dependency set and sequence number for a new instance from all other instances it has knowledge of。对于每个修改了新Command操作对象的Replica，需要持久化它们的最高的instance number和sequence number。</p><p>Command Leader通过<strong>PreAccept消息</strong>，即<code>(γ,seqγ,depsγ,pre-accepted)</code>，将Command以及deps和seq发送给至少fast-path quorum(在这里是2F)个Replica。每个Replica在收到后，会<strong>根据自己的cmds log</strong>来更新Command γ的deps和seq，并将γ和新的attribute记录在自己的log中，然后回复给Command Leader。</p><p>如果Command Leader满足了fast-path quorum，并且所有更新了的attribute(seq和deps)是一样的(根据Figure2的第10行代码，不包括Command Leader)，那么可以直接Commit。否则就需要走Slow Path。</p><p>在运行Slow Path前，我们得更新seq和deps。其中deps是从每个Replica之间的union，seq取每个Replica过来的最大的seq。然后在Slow Path中，Command Leader会给另外F个Replica发送Accept请求，让它们Accept三元组<code>(γ,seq,deps)</code>。其实这个过程类似于Basic Paxos的Accept阶段。</p><p>在Slow Path完成了取得了F + 1票后，就可以和Fast Path会师了。此时Command Leader会发送Commit消息给所有的Replica，并且返回给Client。</p><p>类似于经典的Paxos，EPaxos也会给每个消息(message)分配一个ballot number。每个Replica会忽略小于它们已经见过的最大的ballot number。这个ballot number格式为<code>epoch.b.R</code>，其中：</p><ol><li>epoch<br> 如果集群的配置有变动，那么epoch会变化</li><li>b<br> 如果某个replica R，在做Explicit Prepare时，需要创建一个新的ballot时，会自增b</li><li>R<br> 表示这个Replica</li></ol><p>每个Replica是自己拥有的instance的<strong>初始</strong>Leader，换言之，对于每个instance <code>R.i</code>，隐式存在一个<code>epoch.0.R</code>。</p><p><img src="/img/epaxos/f2.png"></p><h3 id="Explicit-Prepare过程"><a href="#Explicit-Prepare过程" class="headerlink" title="Explicit Prepare过程"></a>Explicit Prepare过程</h3><p>【这一块还包含了优化部分，比较难懂】<br>假如说Replica L可能宕机了，那么Replica Q会尝试接管它的instance L.i。</p><p>首先，将ballot number设置为epoch.(b + 1).Q，其中epoch.b.R是Q知道的L.i中最大的ballot number。然后，发送<code>Prepare(epoch.(b + 1).Q,L.i)</code>给包括自己在内的所有Replica，并且等待至少<code>floor(N/2) + 1</code>个回复。令R等于the set of replies w/ the highest ballot number：</p><ol><li>如果R中包含了<code>(γ,seqγ,depsγ,committed)</code>，则在L.i对(γ,seqγ,depsγ)运行Commit Phase。</li><li>再如果R中包含了<code>(γ,seqγ,depsγ,accepted)</code>，运行Paxos-Accept phase。</li><li>再如果R包含了至少<code>floor(N / 2)</code>个不同的对<code>L.i</code>上默认的ballot即<code>epoch.0.L</code>的回复<code>(γ,seqγ,depsγ,pre-accepted)</code>，并且没有一个回复是来自于L的，则运行Paxos-Accept phase。<br> 【优化算法】此时，只需要包含<code>floor((F + 1) / 2)</code>个PreAccept了<code>(γ,seqγ,depsγ)</code>这个三元组的Replica即可。在发现他们后，新的Command Leader Q会尝试向其他Replica发送TryPreAccept消息。在某个Replica收到TryPreAccept消息后，会判断这个三元组是否和自己已有的log冲突：一个Command的deps中不包括γ，并且depsγ中也不包括这个Command(简单来说两个Command的deps互相不包含)，那么这个Command就和γ冲突；或者这个Command虽然在depsγ中，但是它的seq大于等于seqγ，那么也是和γ冲突的。只有当自己的log中没有这些冲突Command时，这个Replica才会回复TryPreAccept。<br> 如果真的存在某个Command和三元组冲突，并且这个Command被Commit了，那么Q就知道γ不能再fast path中被提交。但如果这个Command没有被Commit，那么新的Comamnd Leader Q就会defer，知道这个Command被Commit。最后，如果Q能够得到F + 1个Replica(在计算F时，老Command Leader也被计算在内)的PreAccept票后，就可以运行Paxos-Accept phase了。<br> 这里有一个Corner case，也即是当deps中的某个Command修改它的seq，然后比需要Recover的Command γ的seq还要大了。为了阻止这个情况，对于depsγ中的所有Command，至少需要有一个Acceptor记录为Commit状态后，才允许Command Leader走Fast Path提交。对于N小于7的情况，更有效的方案是将更新后的deps放到Accept和AcceptReply消息中，并且保证这些消息的接收方都去缓存了它们。这些信息只会被用来辅助Recovery。<br> 【Q】为啥优化算法只改这一个分支？</li><li>再如果R包含了至少一个<code>(γ,seqγ,depsγ,pre-accepted)</code>，则在L.i上执行Phase1，Command为γ，并且避免fast path。</li><li>最终，则在L.i上执行Phase1，Command为noop，并且避免fast path。</li></ol><p>Replica R, 在收到来自Q的Prepare(epoch.b.Q,L.i)后：</p><ol><li>如果epoch.b.Q比最近接受到来自L.i的请求epoch.x.Y大，则返回PrepareOK(cmdsR[L][i], epoch.x.Y,L.i)</li><li>否则返回NAC</li></ol><p><img src="/img/epaxos/f3.png"></p><h3 id="Execution-Protocol"><a href="#Execution-Protocol" class="headerlink" title="Execution Protocol"></a>Execution Protocol</h3><p>为了执行在R.i这个instance上提交的Command γ，需要执行下面的步骤：</p><ol><li>等待R.i被提交，或者运行Explicit Prepare过程强制这个过程</li><li>构造γ的依赖图，其中需要加入γ的dependency set中的所有Command<br> 注意，这个过程是递归的，也就是我们需要考虑依赖的依赖</li><li>找到所有的SCC，并对这些SCC进行拓扑排序</li><li>根据逆拓扑序，执行：<ol><li>对于SCC中的所有命令，按照sequence number(seq)从低到高排序</li><li>按照这个顺序执行所有尚未被执行的Command，并标记他们为已被执行</li></ol></li></ol><h2 id="关于性质的-Informal-证明"><a href="#关于性质的-Informal-证明" class="headerlink" title="关于性质的(Informal)证明"></a>关于性质的(Informal)证明</h2><h3 id="Nontriviality"><a href="#Nontriviality" class="headerlink" title="Nontriviality"></a>Nontriviality</h3><h3 id="Stability和Consistency"><a href="#Stability和Consistency" class="headerlink" title="Stability和Consistency"></a>Stability和Consistency</h3><p>先证明命题1：如果Replica R通过instance Q.i提交了Commit γ(这里R和Q可能是同一个Replica)，那么对于任意的提交Q.i的Replica R’，它提交的Command γ’一定等于γ。</p><p>证明简要：如果说Command γ能被在Q.i这个instance中提交，一定是因为γ的Phase 1是在instance Q.i中被启动的。这是因为：</p><ol><li>对于每个新Command，Q会自增instance number，也就是这里的i</li><li>如果Q宕机并重启了，那么根据”4.7 Reconfiguring the Replica Set”，它会被分配得到一个新的identifier<br> 【TODO】这里需要详细解释下。</li></ol><p>可以看到，命题1实际上暗示了consistency。进一步地，在Replica崩溃时，Command可能被丢失，所以当Command Log被保存在持久化存储上时，也暗示了stability。</p><p>首先引入一个定义。如果Command γ具有seqγ和depsγ，如果元组(γ,seqγ,depsγ)是Q.i这个instance上唯一被或者可能被commit的元组，那么我们称元组(γ,seqγ,depsγ)在Q.i这个instance上是safe的。</p><p>下面证明命题2：Replica只会提交safe的tuple。首先知道(γ,seqγ,depsγ)如果在Q.i被提交，那么它要么在Paxos Accept phase提交，或者在Phase 1之后提交。</p><ol><li>对于第一种情况，即Slow Path。此时有多于半数的Replica写入了值(Figure2的L20)，这对应了经典Paxos的要求。</li><li>对于第二种情况，即Fast Path。此时Coomand Leader收到了不含自己的N-2个相同的回复(Figure2的L11)。如果此时另外的Replica需要接管这个instance，通常这是因为初始的Leader宕机了，那么新Leader必须执行Prepare过程，并且会发现至少<code>floor(N/2)</code>个Replica都返回(γ,seqγ,depsγ)这个元组。因此新的Leader会认为这个元组可能提交了，并在Paxos-Accept过程中使用这个元组。</li></ol><p>至此我们可以发现，元组们，包括他们的attributes，都会在各个Replica之间被consistently和stable地提交。</p><p>下面我们证明这些consistent和stable的attributes能够保证所有互相interfere的Command，在每个Replica上都按照同样的顺序被提交。</p><h3 id="Execution-consistency和Execution-linearizability"><a href="#Execution-consistency和Execution-linearizability" class="headerlink" title="Execution consistency和Execution linearizability"></a>Execution consistency和Execution linearizability</h3><p>引理1 (Execution consistency)：<br><strong>如果互相interfere的两个Command γ和δ都被成功Commit了(并不一定通过同一个Replica提交)，那么他们在任意Replica上都会以相同的顺序被执行</strong>。</p><p>如果两个Command互相interfere，至少有一个Command的deps中能找到另一个Command。Phase1在这个命令被至少简单多数(注意我们现在讲的还是基础版本的EPaxos，其中Phase1的Fast Path Quorum为2F)个Replica Pre-Accepted后结束，并且这个命令最终的deps集是由至少简单多数个Replica的deps的union。这也同样适用于recovery过程中使用的Explicit Prepare(L32)的情况，因为所有的依赖都是基于那些被可能宕机的Leader初始设置的集合计算得到。所以至少一个Replica同时PreAccept γ和δ，并且它的PreAcceptReplies被用来构造γ和δ的最终的deps集。</p><p>通过执行Execution Algorithm，一个命令只有在自己dependency graph中的所有命令都被Commit后才会执行。主要有三个场景：</p><ol><li>两个Command都在彼此的dependency graph中，这也意味着dependency graph是identical的，并且γ和δ在同一个SCC中。所以当执行一个Command时，另一个Command也会被执行，并且是根据sequence number来执行的。根据命题2，这些已Commit的Command的attribute在所有Replica上都是stable和consistent的。所以所有dependency graph相同的Replica都会在相同的顺序中执行γ和δ。</li><li>γ在δ的dependency graph中(δ依赖γ)，但δ不在γ的dependency graph中。也就是说dependency graph有一个从δ到γ的路径，反之不成立。因此γ和δ来自不同的SCC，在逆拓扑序即实际的执行顺序中，γ在δ前面。补充一点，在一些Replica中，γ在δ被Commit之前就被执行了，这样的场景是没毛病的，因为γ并不依赖于δ。</li><li>δ在γ前面，这个就是上面的对称形式。</li></ol><p>引理2 (Execution linearizability)：<br>如果两个Command γ和δ，被客户端指定了顺序，例如只有在γ被任意Replica Commit之后才会Propose δ，这样的话我们要求所有的Replica都要在δ之前执行γ。</p><p>证明。因为δ是在γ Commit之后被Propose的，所以在任何Replica收到Command δ的PreAccept时，γ的Sequence Number应该是Stable和Consist的。因为一个包含γ的元组，以及它最终的sequence number至少被majority个Replica记录，那么δ的sequence number会最终被更新到大于γ的值，并且delta的deps中会包含γ。所以在执行δ时，δ的dependency graph必须包含γ，并且：</p><ol><li>它们在同一个SCC中</li><li>按照逆拓扑序，γ在δ前面的一个SCC中。</li></ol><p>无论那种情况，γ都会在δ前面执行。</p><h3 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h3><p>只要不是大多数Replica有故障，那么Client会一直重试某个Command，直到被Accept。</p><h2 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h2><p>优化版本会修改Recovery过程，也就是Explicit Prepare Phase。我已经写到“Explicit Prepare过程”上面了。</p><p>当F个Replica宕机后，在Fast Quorum中就只有<code>floor((F + 1) / 2)</code>个存活的成员(可以翻翻前面Fast-Path Quorum的定义)，那么就不能在剩下的Replica中形成多数了。所以，当Command Leader向所有Replica(而不只是Fast Quorum中的Replica)发送PreAccept消息后，Recovery过程不一定能正确地发现，老的Command Leader，是通过哪些Replica的回复，从而Commit了这个instance的。 Still, such redundancy is sometimes desirable because the command leader may not know in advance which replicas are still live or which replicas will reply faster。<br>对于这种情况，需要修改Fast Path的条件：当Command Leader收到<code>F + floor((F + 1) / 2) - 1</code>个满足initial ordering attributes的PreAccept的回复，才会选择Fast Path。并且这些Replica需要被记录到Log中，以便在Recovery过程中只考虑这些Replica。<br>在不发送redundant PreAccept的时候(【Q】什么时候会发送？)，一个三副本的系统永远可以通过Fast Path提交，这是因为在做还有一个Acceptor的集合中肯定不存在disagreement。</p><h1 id="EPaxos的TLA-简介"><a href="#EPaxos的TLA-简介" class="headerlink" title="EPaxos的TLA+简介"></a>EPaxos的TLA+简介</h1><p>如果光读论文就能读懂，那我感觉你真的挺厉害的，反正我是半懂不懂的，特别是对Recovery部分。所以我转过来看TLA+了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>下面是对SlowQuorum和FastQuorum的定义。对于某个Replica r，SlowQuorum(r)表示它作为Command Leader时，所有可能的Slow Path Quorum组成的集合，也就是类似于<code>{ {r,a}, {r,b} }</code>这样的东西。那么，<code>SlowQuorum(r)</code>必须是<code>SUBSET Replica</code>的子集，换句话说，就是不能出现Replica之外的元素。然后对于SlowQuorum中的任意的Quorum SQ，它必须包含r，并且大小为<code>N/2+1</code>，其中N为集群大小。<br>同理，FastQuorum中的大小为<code>N/2 + (N/2+1)/2</code>，这个其实就是把<code>F = N/2</code>带入进去就得到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS FastQuorums(_), SlowQuorums(_)</span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ SlowQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A SQ \in SlowQuorums(r): </span><br><span class="line">    /\ r \in SQ</span><br><span class="line">    /\ Cardinality(SQ) = (Cardinality(Replicas) \div 2) + 1</span><br><span class="line"></span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ FastQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A FQ \in FastQuorums(r):</span><br><span class="line">    /\ r \in FQ</span><br><span class="line">    /\ Cardinality(FQ) = (Cardinality(Replicas) \div 2) + </span><br><span class="line">                         ((Cardinality(Replicas) \div 2) + 1) \div 2</span><br></pre></td></tr></table></figure><p>下面是对一些状态的定义。Commands是一个常量，表示所有可能的命令，在运行前由我们给出。none是一个none Command(也许是Noop？)，对它的定义还挺新颖的，如果是我，可能选择直接CONSTANT了一个Nil的值。<br>Instance是做了一个笛卡尔积，没啥讲的。<br>Status标记了Log中的某个Command可能处于的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS Commands</span><br><span class="line">none == CHOOSE c : c \notin Commands</span><br><span class="line">Instances == Replicas \X (1..Cardinality(Commands))</span><br><span class="line">Status == &#123;&quot;not-seen&quot;, &quot;pre-accepted&quot;, &quot;accepted&quot;, &quot;committed&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面是Replica之间可能发送的消息。这里的TLA+语法可以参考<a href="/2021/06/26/tla/">TwoPhase章节</a>。</p><ol><li>pre-accept、pre-accept-reply<br> Phase1由Command Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,pre-accepted)</code><br> 注意要区分这里的committed字段，和全局的committed变量</li><li>accept、accept-reply<br> Phase2由Commmand Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,accepted)</code></li><li>commit<br>Commit阶段由Command Leader发起的消息，即<code>(γ,seqγ,depsγ,committed)</code></li><li>prepare、prepare-reply<br> Explicit Prepare阶段由新的Command Leader Q发起的消息。</li><li>try-pre-accept、try-pre-accept-reply<br> 优化算法</li></ol><p>一些常见字段的说明：</p><ol><li>src和dst都属于Replicas。</li><li>inst属于Instances表示当前操作的实例。</li><li>ballot应该是指的ballot number，不是<code>epoch.b.R</code>么？看起来是吧epoch和b合并了？</li><li>cmd应该是指instance中包含的command。</li><li>deps和seq就是所谓的attribute，没啥讲的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Message ==</span><br><span class="line">        [type: &#123;&quot;pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;commit&quot;&#125;,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        deps: SUBSET Instances, seq: Nat, committed: SUBSET Instances]</span><br><span class="line">  \cup  [type: &#123;&quot;accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, prev_ballot: Nat \X Replicas,</span><br><span class="line">        status: Status,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, status: Status \cup &#123;&quot;OK&quot;&#125;]</span><br></pre></td></tr></table></figure><p>下面是定义变量，可以结合TypeOK和Init条件看出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VARIABLES cmdLog, proposed, executed, sentMsg, crtInst, leaderOfInst,</span><br><span class="line">          committed, ballots, preparing</span><br><span class="line"></span><br><span class="line">TypeOK ==</span><br><span class="line">    /\ cmdLog \in [Replicas -&gt; SUBSET [inst: Instances, </span><br><span class="line">                                       status: Status,</span><br><span class="line">                                       ballot: Nat \X Replicas,</span><br><span class="line">                                       cmd: Commands \cup &#123;none&#125;,</span><br><span class="line">                                       deps: SUBSET Instances,</span><br><span class="line">                                       seq: Nat]]</span><br><span class="line">    /\ proposed \in SUBSET Commands</span><br><span class="line">    /\ executed \in [Replicas -&gt; SUBSET (Nat \X Commands)]</span><br><span class="line">    /\ sentMsg \in SUBSET Message</span><br><span class="line">    /\ crtInst \in [Replicas -&gt; Nat]</span><br><span class="line">    /\ leaderOfInst \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line">    /\ committed \in [Instances -&gt; SUBSET ((Commands \cup &#123;none&#125;) \X</span><br><span class="line">                                           (SUBSET Instances) \X </span><br><span class="line">                                           Nat)]</span><br><span class="line">    /\ ballots \in Nat</span><br><span class="line">    /\ preparing \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line"></span><br><span class="line">Init ==</span><br><span class="line">  /\ sentMsg = &#123;&#125;</span><br><span class="line">  /\ cmdLog = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ proposed = &#123;&#125;</span><br><span class="line">  /\ executed = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ crtInst = [r \in Replicas |-&gt; 1]</span><br><span class="line">  /\ leaderOfInst = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ committed = [i \in Instances |-&gt; &#123;&#125;]</span><br><span class="line">  /\ ballots = 1</span><br><span class="line">  /\ preparing = [r \in Replicas |-&gt; &#123;&#125;]</span><br></pre></td></tr></table></figure><ol><li>cmdLog<br> 每个Replica上的日志。<br> 每条日志中包含对应的Instance、Status，ballot、Command、以及deps和seq</li><li>proposed<br> 已经被被Propose了的Command</li><li>executed<br> 每个Replica上已经被execute的Command</li><li>sentMsg<br> 所有被发送，但是还没有被接受的消息，理解成Message类型对象的集合</li><li>crtInst<br> 对于每个Replica，它下一个可以使用的instance number(一个数字)，初始值是1</li><li>leaderOfInst<br> 这是从Replicas到SUBSET Instances的一个映射，表示对于每个Replica，它发起但是还没有完成的Instance的集合</li><li>committed<br> 【Q】maps commands to set of commit attributs tuples<br> 从实现上来看，应该是个三元组，表示每个Command被提交时的deps和seq</li><li>ballots<br> 所有Replica中，最大的ballot number，这里指的应该是epoch.b</li><li>preparing<br> 对于每个Replica，它目前正在preparing(例如recovering)的所有Instance</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>Nontriviality的验证，对于任意的Instance，始终(因为有<code>[]</code>)有：在committed中的所有Command，它要么是在proposed集合中(也就是被某个Command Leader主动Propose的)，或者为none</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nontriviality ==</span><br><span class="line">    \A i \in Instances :</span><br><span class="line">        [](\A C \in committed[i] : C \in proposed \/ C = none)</span><br></pre></td></tr></table></figure><p>Stability的验证，是个三层大循环，遍历所有的Replica/Instances/Commands，此时我们检查(replica, i, C)，<strong>始终</strong>满足：<br>在replica的cmdLog[replica]中任选一条记录rec1，它的(inst,cmd)等于(replica, i)，并且status为committed或者executed，那么<strong>始终</strong>存在另一个满足条件的rec2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stability ==</span><br><span class="line">    \A replica \in Replicas :</span><br><span class="line">        \A i \in Instances :</span><br><span class="line">            \A C \in Commands :</span><br><span class="line">                []((\E rec1 \in cmdLog[replica] :</span><br><span class="line">                    /\ rec1.inst = i</span><br><span class="line">                    /\ rec1.cmd = C</span><br><span class="line">                    /\ rec1.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;) =&gt;</span><br><span class="line">                    [](\E rec2 \in cmdLog[replica] :</span><br><span class="line">                        /\ rec2.inst = i</span><br><span class="line">                        /\ rec2.cmd = C</span><br><span class="line">                        /\ rec2.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;))</span><br></pre></td></tr></table></figure><p>Consistency的验证，对于所有的Instance i，始终满足它最多只会被commit一次。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consistency ==</span><br><span class="line">    <span class="string">\A</span> i <span class="string">\in</span> Instances :</span><br><span class="line">        [](Cardinality(committed[i]) &lt;= <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">THEOREM Spec =&gt; ([]TypeOK) <span class="regexp">/\ Nontriviality /</span><span class="string">\</span> Stability /<span class="string">\</span> Consistency</span><br></pre></td></tr></table></figure><h2 id="总体的Action"><a href="#总体的Action" class="headerlink" title="总体的Action"></a>总体的Action</h2><p>可以选择执行Command Leader的某个动作，或者普通Replica的某个动作。Command Leader肯定属于Replica，但我们是按照行为来区分的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Next == </span><br><span class="line">    \/ CommandLeaderAction</span><br><span class="line">    \/ ReplicaAction</span><br></pre></td></tr></table></figure><p>首先是Command Leader的所有可能的动作：</p><ol><li>检查<code>Commands \ proposed</code>，也就是<code>Commands</code>中所有还没被propose的Command，如果存在，则<strong>选择一个C</strong>(<code>\E</code>可以表示选出一个的意思)：<br> 选出一个cleader，对C做状态转移<code>Propose(C, cleader)</code></li><li>在Replicas中选出一个cleader，在cleader为Command Leader的instance中选出一个instance，可以执行下面任意的状态转移：<ol><li>可能走Fast Path</li><li>可能走Slow Path</li><li>可能走Phase2Finalize<br> 【Q】Phase2的Accept啥时候发送的？</li><li>可能走优化路径FinalizeTryPreAccept</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLeaderAction ==</span><br><span class="line">    \/ (\E C \in (Commands \ proposed) :</span><br><span class="line">            \E cleader \in Replicas : Propose(C, cleader))</span><br><span class="line">    \/ (\E cleader \in Replicas : \E inst \in leaderOfInst[cleader] :</span><br><span class="line">            \/ (\E Q \in FastQuorums(cleader) : Phase1Fast(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase1Slow(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase2Finalize(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : FinalizeTryPreAccept(cleader, inst, Q)))</span><br></pre></td></tr></table></figure><p>下面是ReplicaAction，选择一个Replica：</p><ol><li>可能回复Phase1</li><li>可能回复Phase2</li><li>可能对于某个Instance i，<code>i[1]</code>表示Instance这个tuple的第一个元素，也就是Replica；<code>crtInst[i[1]]</code>表示它对应的Replica下一个可以使用的instance number，如果大于i本身的instance number。<br> 这个条件说明这个instance被自己原来的owner start。<br> 则通过SlowQuorum个节点进行SendPrepare。<br> 【Q】不太懂什么意思，但这里无疑就是Explicit Prepare里面的Prepare过程了。</li><li>可以ReplyPrepare</li><li>选择一个正在preparing的Replica<br> 通过SlowQuorum个节点进行PrepareFinalize</li><li>回复ReplyTryPreaccept</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReplicaAction ==</span><br><span class="line">    \E replica \in Replicas :</span><br><span class="line">        (\/ Phase1Reply(replica)</span><br><span class="line">         \/ Phase2Reply(replica)</span><br><span class="line">         \/ \E cmsg \in sentMsg : (cmsg.type = &quot;commit&quot; /\ Commit(replica, cmsg))</span><br><span class="line">         \/ \E i \in Instances : </span><br><span class="line">            /\ crtInst[i[1]] &gt; i[2] (* This condition states that the instance has *) </span><br><span class="line">                                    (* been started by its original owner          *)</span><br><span class="line">            /\ \E Q \in SlowQuorums(replica) : SendPrepare(replica, i, Q)</span><br><span class="line">         \/ ReplyPrepare(replica)</span><br><span class="line">         \/ \E i \in preparing[replica] :</span><br><span class="line">            \E Q \in SlowQuorums(replica) : PrepareFinalize(replica, i, Q)</span><br><span class="line">         \/ ReplyTryPreaccept(replica))</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><h3 id="Propose"><a href="#Propose" class="headerlink" title="Propose"></a>Propose</h3><p>从上文看到，CommandLeaderAction的一个可能的状态转移是Propose。<br>此时，生成newInst和newBallot。新生成的newInst的instance number为crtInst[cleader]，newBallot的<code>epoch.b</code>部分始终为0，看来是不考虑epoch了。<br>然后，将要Propose的Command C添加进proposed中，并且在FastQuorum里面选择一个Quorum，尝试走FastPath。<br>然后，我们自增crtInst，这里的<code>@</code>就是<code>crtInst[cleader]</code>，实际上是一个简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Propose(C, cleader) ==</span><br><span class="line">    LET newInst == &lt;&lt;cleader, crtInst[cleader]&gt;&gt; </span><br><span class="line">        newBallot == &lt;&lt;0, cleader&gt;&gt; </span><br><span class="line">    IN  /\ proposed&apos; = proposed \cup &#123;C&#125;</span><br><span class="line">        /\ (\E Q \in FastQuorums(cleader):</span><br><span class="line">                 StartPhase1(C, cleader, Q, newInst, newBallot, &#123;&#125;))</span><br><span class="line">        /\ crtInst&apos; = [crtInst EXCEPT ![cleader] = @ + 1]</span><br><span class="line">        /\ UNCHANGED &lt;&lt; executed, committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><p>对Phase1的处理起始于<code>StartPhase1</code>，这个状态转移触发的条件有很多，比如上面的Propose。<br>首先，构建依赖deps和seq：</p><ol><li>newDeps是Command Leader即cleader中所有Command的Instance，即<code>rec.inst</code>。<br> 【Q】这是不是太强了点？按照协议，首先要是冲突的，然后只要包含最高冲突Instance的编号就行啊。</li><li>newSeq是cleader中所有Command的seq的最大值，然后还要加1，这是符合协议的论述的。</li><li>oldRecs表示cleader中所有和当前Command的Instance相同的Command。</li></ol><p>然后进行状态转移：</p><ol><li>cmdLog<br> 需要修改cleader的Log。具体来说，需要把同Instance的所有的旧的日志全部干掉。【Q】为啥可能会有同Instance的日志呢？<br> 然后，我们把新的Command加上到日志中，并且设置status为”pre-accepted”。也就是说cleader我PreAccept了这个日志，并不代表其他Replica也PreAccept了这个日志。</li><li>leaderOfInst<br> 显然，对于这个Instance，cleader我是它的Leader。这是显然的，因为Instance二元组里面，Replica是cleader，然后instance number也是自增的。<br> 应该加入到leaderOfInst，表示是我发起的，但还没有完成的Instance。</li><li>sentMsg<br> 显然要往其他的Replica发消息。在此之前，我们先要把oldMsg干掉。如果我们是走Propose过来的，那么oldMsg是空的。但如果是走Explicit Prepare过来的，那么是会传入oldMsg的，这个到时候再说。<br> 这里需要注意，消息的定义是<code>src: Replicas, dst: Replicas</code>，但我们传进来的src和dst实际上是两个集合，这会导致产生一系列新Msg。可以参考<a href="/2021/06/26/tla/">TLA</a>的文档。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StartPhase1(C, cleader, Q, inst, ballot, oldMsg) ==</span><br><span class="line">    LET newDeps == &#123;rec.inst: rec \in cmdLog[cleader]&#125; </span><br><span class="line">        newSeq == 1 + Max(&#123;t.seq: t \in cmdLog[cleader]&#125;) </span><br><span class="line">        oldRecs == &#123;rec \in cmdLog[cleader] : rec.inst = inst&#125; IN</span><br><span class="line">        /\ cmdLog&apos; = [cmdLog EXCEPT ![cleader] = (@ \ oldRecs) \cup </span><br><span class="line">                                &#123;[inst   |-&gt; inst,</span><br><span class="line">                                  status |-&gt; &quot;pre-accepted&quot;,</span><br><span class="line">                                  ballot |-&gt; ballot,</span><br><span class="line">                                  cmd    |-&gt; C,</span><br><span class="line">                                  deps   |-&gt; newDeps,</span><br><span class="line">                                  seq    |-&gt; newSeq ]&#125;]</span><br><span class="line">        /\ leaderOfInst&apos; = [leaderOfInst EXCEPT ![cleader] = @ \cup &#123;inst&#125;]</span><br><span class="line">        /\ sentMsg&apos; = (sentMsg \ oldMsg) \cup </span><br><span class="line">                                [type  : &#123;&quot;pre-accept&quot;&#125;,</span><br><span class="line">                                  src   : &#123;cleader&#125;,</span><br><span class="line">                                  dst   : Q \ &#123;cleader&#125;,</span><br><span class="line">                                  inst  : &#123;inst&#125;,</span><br><span class="line">                                  ballot: &#123;ballot&#125;,</span><br><span class="line">                                  cmd   : &#123;C&#125;,</span><br><span class="line">                                  deps  : &#123;newDeps&#125;,</span><br><span class="line">                                  seq   : &#123;newSeq&#125;]</span><br></pre></td></tr></table></figure><h3 id="Phase1Reply"><a href="#Phase1Reply" class="headerlink" title="Phase1Reply"></a>Phase1Reply</h3><p>Propose是发送PreAccept请求，Phase1Reply是其他Replica处理该请求。<br>任选一个发给replica的type为”pre-accept”的消息msg。<br>oldRec为replica日志中，inst等于msg对应的Instance的日志组成的集合。<br>那么对于oldRec中所有的日志rec，要么它的ballot等于msg里的ballot，要么比msg传过来的ballot要小。否则这个消息就应该被忽略。</p><p>构造newDeps为msg传来的deps，加上当前replica所有的log中的Instance(除去msg.inst)。<br>构造newSeq为Max(msg.seq, replica的所有日志中最大的seq+1)。<br>构造instCom，为replica自己日志中所有status为”committed”或”executed”(其实就是已提交)的日志对应的Instance构成的集合。</p><p>下面是状态转移：</p><ol><li>修改当前replica的cmdLog<br> 主要是将status变成”pre-accepted”，然后deps和seq设置为刚算出来的newDeps和newSeq。</li><li>发送消息<br> 发送一条”pre-accept-reply”消息给msg.src，实际上就是刚才发命令过来的cleader。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Phase1Reply(replica) ==</span><br><span class="line">    <span class="string">\E</span> msg <span class="string">\in</span> sentMsg:</span><br><span class="line">        /<span class="string">\</span> msg.type = <span class="string">"pre-accept"</span></span><br><span class="line">        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">        /<span class="string">\</span> LET oldRec == &#123;rec <span class="string">\in</span> cmdLog[replica]: rec.inst = msg.inst&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rec <span class="string">\in</span> oldRec : </span><br><span class="line">                (rec.ballot = msg.ballot <span class="string">\/rec.ballot[1]</span> &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /<span class="string">\</span> LET newDeps == msg.deps <span class="string">\cup</span> </span><br><span class="line">                            (&#123;t.inst: t <span class="string">\in</span> cmdLog[replica]&#125; <span class="string">\</span> &#123;msg.inst&#125;)</span><br><span class="line">                   newSeq == Max(&#123;msg.seq, </span><br><span class="line">                                  <span class="number">1</span> + Max(&#123;t.seq: t <span class="string">\in</span> cmdLog[replica]&#125;)&#125;)</span><br><span class="line">                   instCom == &#123;t.inst: t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">                              tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125; IN</span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup</span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; msg.inst,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "pre-accepted",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; msg.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; msg.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; newDeps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; newSeq]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> &#123;msg&#125;) <span class="string">\cup</span></span><br><span class="line">                                    &#123;[type  |<span class="function">-&gt;</span> <span class="string">"pre-accept-reply"</span>,</span><br><span class="line">                                      src   |<span class="function">-&gt;</span> replica,</span><br><span class="line">                                      dst   |<span class="function">-&gt;</span> msg.src,</span><br><span class="line">                                      inst  |<span class="function">-&gt;</span> msg.inst,</span><br><span class="line">                                      ballot|<span class="function">-&gt;</span> msg.ballot,</span><br><span class="line">                                      deps  |<span class="function">-&gt;</span> newDeps,</span><br><span class="line">                                      seq   |<span class="function">-&gt;</span> newSeq,</span><br><span class="line">                                      committed|<span class="function">-&gt;</span> instCom]&#125;</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Fast"><a href="#Phase1Fast" class="headerlink" title="Phase1Fast"></a>Phase1Fast</h3><p>Phase1Fast是cleader在其他Replica处理该请求后，尝试通过FastPath提交这个请求。里面包含了是否能够进行FastPath提交的判断，以及提交的状态转移。<br>首先，是一部分简单的Enable条件，校验cleader是不是Instance i的Leader，并检查Q是不是cleader的FastQuorums。<br>然后，选择cleader的某条日志record，日志中的Instance为i、Status为”pre-accepted”、ballot的为0。这些日志肯定是从StartPhase1设置的。并且因为ballot为0，所以肯定是从Propose设置的。<br>Q通过刚才的Phase1Reply发回来的replies，它们是”pre-accept-reply”类型的消息，并且ballot等于record对应的ballot，我们进行下面的检查：</p><ol><li>对于Q中除了cleader之外的replica，在replies中都会有从它发给cleader的”pre-accept-reply”消息。<br> 也就是说Q中的Replica，都回复了cleader的pre-accept请求。<br> 这个检查是必要的，如果说之前cleader通过StartPhase1发过去的ballot比较小，那么有的replica就不会回复，因此这条Enable条件就过不了。</li><li>并且replies中任意两个消息r1和r2，它们的deps和seq是相等的。<br> 这是走FastPath的要求，只有满足该要求，才能进下一步。<br> 这个实际上也是Enable条件，如果不满足那么根本就不会有下面的状态转移。</li><li>CHOOSE replies中的某一个r，基于它构造新的r.deps：<br> 这里可以CHOOSE，是因为大家的deps和seq都一样。<br> 注意已提交的日志，指的是status为”committed”和”executed”的日志。<ol><li>localCom<br> cleader的所有的已提交日志的Instance构成集合。</li><li>extCom<br> Phase1Reply中，replica在回复时，会带上自己日志中所有已提交的日志对应的Instance构成的集合。<br> extCom是这些的并集。</li><li>然后构造新的r.deps集合，为localCom和extCom中所有的Instance</li></ol></li></ol><p>然后基于r构造状态转移：</p><ol><li>cmdLog<br> 更新这个日志状态为committed。<br> 更新当前的record的attribute为r.deps和r.seq。</li><li>sentMsg<br> 产生一条Commit信息，这个消息可能是直接给Client的，所以没有dst和src。</li><li>leaderOfInst<br> 在leaderOfInst[cleader]中移除掉当前的Instance i，表示这个Instance已经提交了。</li><li>committed<br> 将<code>&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;</code>加入已提交的数组中。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Phase1Fast(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> FastQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"pre-accepted"</span></span><br><span class="line">        /<span class="string">\</span> record.ballot[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i</span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"pre-accept-reply"</span></span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader</span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q</span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): </span><br><span class="line">                    <span class="string">\E</span> msg <span class="string">\in</span> replies: msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> r1, r2 <span class="string">\in</span> replies:</span><br><span class="line">                /<span class="string">\</span> r1.deps = r2.deps</span><br><span class="line">                /<span class="string">\</span> r1.seq = r2.seq)</span><br><span class="line">            /<span class="string">\</span> LET r == CHOOSE r <span class="string">\in</span> replies : TRUE IN</span><br><span class="line">                /<span class="string">\</span> LET localCom == &#123;t.inst: </span><br><span class="line">                            t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[cleader] : </span><br><span class="line">                                 tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125;</span><br><span class="line">                       extCom == UNION &#123;msg.committed: msg <span class="string">\in</span> replies&#125; IN</span><br><span class="line">                       (r.deps <span class="string">\subseteq</span> (localCom <span class="string">\cup</span> extCom))    </span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                        &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                          status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                          ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                          cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                          deps   |-&gt; r.deps,</span></span><br><span class="line"><span class="string">                                          seq    |-&gt; r.seq ]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                            &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                            inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                            ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                            cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                            deps    |<span class="function">-&gt;</span> r.deps,</span><br><span class="line">                            seq     |<span class="function">-&gt;</span> r.seq]&#125;</span><br><span class="line">                /<span class="string">\</span> leaderOfInst<span class="string">' = [leaderOfInst EXCEPT ![cleader] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                /\ committed'</span> = [committed EXCEPT ![i] = </span><br><span class="line">                                            @ <span class="string">\cup</span> &#123;&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;&#125;]</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Slow"><a href="#Phase1Slow" class="headerlink" title="Phase1Slow"></a>Phase1Slow</h3><p>Phase1Slow是cleader在其他Replica处理该请求后，尝试通过SlowPath提交这个请求。<br>前面的条件都一样，不再赘述。</p><p>主要不一样的地方是从finalDeps开始的。这里大家的deps和seq都不一定一样了，所以不能像FastPath一样CHOOSE了，而要老老实实取并集、取最大值。</p><ol><li>finalDeps<br> 就是所有来自Replica的回复中的deps的并集。</li><li>finalSeq<br> 就是所有回复中最大的seq。</li></ol><p>下面构造状态转移：</p><ol><li>cmdLog<br> 更新日志状态为”accepted”。<br> 注意，在FastPath中，能够直接进入commited状态，但这里得先是”accepted”，后面再走一轮Phase2才行。</li><li>sentMsg<br> 往除自己之外的SlowQuorum成员发送”accept”形式的消息。并且带上deps和seq为finalDeps和finalSeq。这个消息会在Phase2Reply被Replica处理。</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Phase1Slow(cleader, i, Q) ==</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>i <span class="tag">\<span class="name">in</span></span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>Q <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> record <span class="tag">\<span class="name">in</span></span> cmdLog[cleader]:</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.inst = i</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.status = "pre-accepted"</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>LET replies == &#123;msg <span class="tag">\<span class="name">in</span></span> sentMsg: </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.inst = i </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.type = "pre-accept-reply" </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.dst = cleader </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.src <span class="tag">\<span class="name">in</span></span> Q</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>(<span class="tag">\<span class="name">A</span></span> replica <span class="tag">\<span class="name">in</span></span> (Q <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>): <span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies: msg.src = replica)</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>LET finalDeps == UNION &#123;msg.deps : msg <span class="tag">\<span class="name">in</span></span> replies&#125;</span><br><span class="line">                   finalSeq == Max(&#123;msg.seq : msg <span class="tag">\<span class="name">in</span></span> replies&#125;) IN    </span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![cleader] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;record&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span> </span><br><span class="line">                                        &#123;[inst   |-&gt; i,</span><br><span class="line">                                          status |-&gt; "accepted",</span><br><span class="line">                                          ballot |-&gt; record.ballot,</span><br><span class="line">                                          cmd    |-&gt; record.cmd,</span><br><span class="line">                                          deps   |-&gt; finalDeps,</span><br><span class="line">                                          seq    |-&gt; finalSeq ]&#125;]</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> SQ <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader):</span><br><span class="line">                   (sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                            [type : &#123;"accept"&#125;,</span><br><span class="line">                            src : &#123;cleader&#125;,</span><br><span class="line">                            dst : SQ <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>,</span><br><span class="line">                            inst : &#123;i&#125;,</span><br><span class="line">                            ballot: &#123;record.ballot&#125;,</span><br><span class="line">                            cmd : &#123;record.cmd&#125;,</span><br><span class="line">                            deps : &#123;finalDeps&#125;,</span><br><span class="line">                            seq : &#123;finalSeq&#125;])</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><h3 id="Phase2Reply"><a href="#Phase2Reply" class="headerlink" title="Phase2Reply"></a>Phase2Reply</h3><p>Phase2Reply处理在SlowPath中，从Command Leader发过来的”accept”消息。</p><p>这里的Enable条件是，在自己的日志<code>cmdLog[replica]</code>中按照<code>msg.inst</code>找到对应的记录，要求消息的ballot要么等于，要么大于日志中的ballot。</p><p>如果满足Enable条件，则可以进行状态转移：</p><ol><li>cmdLog<br> 修改自己的日志，状态为”accepted”，并且更新deps和seq为msg中传入的值。这个值是由finalDeps和finalSeq一起计算得到的。</li><li>sentMsg<br> 发送”accept-reply”消息给cleader。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phase2Reply</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg: </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "accept"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica]: <span class="keyword">rec</span>.inst = msg.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec: (<span class="keyword">rec</span>.ballot = msg.ballot \/ </span><br><span class="line">                                    <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                &#123;[inst   |-&gt; msg.inst,</span><br><span class="line">                                  status |-&gt; <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot |-&gt; msg.ballot,</span><br><span class="line">                                  cmd    |-&gt; msg.cmd,</span><br><span class="line">                                  deps   |-&gt; msg.deps,</span><br><span class="line">                                  seq    |-&gt; msg.seq]&#125;]</span><br><span class="line">            /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                                &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "accept-reply",</span></span><br><span class="line">                                  src   |-&gt; replica,</span><br><span class="line">                                  dst   |-&gt; msg.src,</span><br><span class="line">                                  inst  |-&gt; msg.inst,</span><br><span class="line">                                  ballot|-&gt; msg.ballot]&#125;</span><br><span class="line">            /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                            committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase2Finalize"><a href="#Phase2Finalize" class="headerlink" title="Phase2Finalize"></a>Phase2Finalize</h3><p>Phase2Finalize是整个SlowQuorum过程的终点，cleader会收集各个Replica的消息，并提交Command。即对于cleader下的某个Instance i，和SlowQuorum Q，尝试完成Phase2的最终提交。</p><p>照例还是Enable条件，在自己的日志里面看看能不能找到i对应的状态为”accepted”的日志，如果找不到，那么也不用往下看了。<br>如果能找到，就需要在sentMsg中找出所有和这个Instance相关的，类型为”accept-reply”的消息(也就是各个Replica在Phase2Reply过程中发出的消息)。显然，对于Q中除cleader之外的replica，都需要发一条这样的消息才能继续提交。</p><p>下面就是状态转移，和Phase1Fast基本一致，就不另外说明了。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Phase2Finalize(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"accepted"</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i </span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"accept-reply"</span> </span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader </span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q </span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): <span class="string">\E</span> msg <span class="string">\in</span> replies: </span><br><span class="line">                                                        msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; record.deps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; record.seq ]&#125;]</span></span><br><span class="line"><span class="string">            /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                        &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                        inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                        ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                        cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                        deps    |<span class="function">-&gt;</span> record.deps,</span><br><span class="line">                        seq     |<span class="function">-&gt;</span> record.seq]&#125;</span><br><span class="line">            /<span class="string">\</span> committed<span class="string">' = [committed EXCEPT ![i] = @ \cup </span></span><br><span class="line"><span class="string">                               &#123;&lt;&lt;record.cmd, record.deps, record.seq&gt;&gt;&#125;]</span></span><br><span class="line"><span class="string">            /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">            /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>下面是Recovery相关操作。</p><h3 id="SendPrepare"><a href="#SendPrepare" class="headerlink" title="SendPrepare"></a>SendPrepare</h3><p>这里的replica就是论文里面的Replica L。其中，Enable条件：</p><ol><li>replica并不是i这个Instance的Leader<br> 这里注释掉一句，是replica并没有prepare这个instance。【Q】我不清楚为什么这个被注释掉。</li><li>目前使用过的ballots不超过MaxBallot<br> 这个应该是防止最后算法不会终止</li><li>replica当前的日志中，不存在任何Instance为i的日志是已提交的(即其status为”committed”和”executed”)。</li></ol><p>状态转移：</p><ol><li>sentMsg<br> 从这个replica向一个SlowQuorum，即Q发送”prepare”消息。<br> 这里注意，更新ballot为<code>&lt;&lt; ballots, replica &gt;&gt;</code>，这里的ballots是全局最大的ballot值。</li><li>ballots<br> 更新全局最大的ballots，自增1。</li><li>preparing<br> 将当前replica的preparing集合中增加Instance i。</li></ol><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SendPrepare(replica, i, Q) ==</span><br><span class="line">    /<span class="symbol">\ </span>i <span class="symbol">\n</span>otin leaderOfInst[replica]</span><br><span class="line">    <span class="symbol">\*</span>/<span class="symbol">\ </span>i <span class="symbol">\n</span>otin preparing[replica]</span><br><span class="line">    /<span class="symbol">\ </span>ballots &lt;= MaxBallot</span><br><span class="line">    /<span class="symbol">\ </span>~(<span class="symbol">\E</span> rec <span class="symbol">\i</span>n cmdLog[replica] :</span><br><span class="line">                        /<span class="symbol">\ </span>rec.inst = i</span><br><span class="line">                        /<span class="symbol">\ </span>rec.status <span class="symbol">\i</span>n &#123;"committed", "executed"&#125;)</span><br><span class="line">    /<span class="symbol">\ </span>sentMsg' = sentMsg <span class="symbol">\c</span>up</span><br><span class="line">                    [type   : &#123;"prepare"&#125;,</span><br><span class="line">                     src    : &#123;replica&#125;,</span><br><span class="line">                     dst    : Q,</span><br><span class="line">                     inst   : &#123;i&#125;,</span><br><span class="line">                     ballot : &#123;&lt;&lt; ballots, replica &gt;&gt;&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>ballots' = ballots + 1</span><br><span class="line">    /<span class="symbol">\ </span>preparing' = [preparing EXCEPT ![replica] = @ <span class="symbol">\c</span>up &#123;i&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst,</span><br><span class="line">                    leaderOfInst, committed &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyPrepare"><a href="#ReplyPrepare" class="headerlink" title="ReplyPrepare"></a>ReplyPrepare</h3><p>ReplyPrepare处理来自SendPrepare里面replica的”prepare”消息。下面进行讨论：</p><ol><li>如果自己的日志中，存在一条对应于msg里面instance的日志，并且消息中的ballot要大于日志中的ballot。<br> 状态转移：<ol><li>sentMsg<br> 将来自SendPrepare里面replica的”prepare”消息删除，并重新发送一条”prepare-reply”消息给msg.src。<br> 消息中的ballot为自己的msg.ballot，prev_ballot为rec.ballot。根据前文，msg.ballot肯定是大于rec.ballot的。<br> 消息中的deps和seq沿用自己本地日志中的。【Q】这里很奇怪，似乎我们不在ReplyPrepare阶段对deps和seq决议。</li><li>cmdLog<br> 删除自己日志中的rec，并且增加一条新条目。这个新条目和rec大致一样，只是将ballot更新为msg中的ballot。</li><li>leaderOfInst<br> 如果日志中的instance的Command Leader是replica，那么将它移出<code>leaderOfInst[replica]</code>。否则保持不变。<br> 【Q】这里是啥意思，重新选一个Command Leader，还是直接走Basic Paxos那一套提交呢？</li></ol></li><li>如果在自己日志中，不存在对应于msg里面instance的日志。<br> 状态转移：<ol><li>sentMsg<br> 发送”prepare-reply”消息。<br> ballot为消息中传来的ballot，并且prev_ballot为<code>&lt;&lt; 0, replica &gt;&gt;</code>，相当于是一开始的ballot。【Q】msg.ballot肯定是大于rec.ballot的么？<br> 其他的字段也是设置成默认值：status为”not-seen”。cmd为none。deps为<code>{}</code>，seq为0。</li><li>cmdLog<br> 参照sentMsg的变更</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyPrepare</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg : </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "prepare"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ \/ \<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : </span><br><span class="line">                /\ <span class="keyword">rec</span>.inst = msg.inst</span><br><span class="line">                /\ msg.ballot[<span class="number">1</span>] &gt; <span class="keyword">rec</span>.ballot[<span class="number">1</span>]</span><br><span class="line">                /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; <span class="keyword">rec</span>.ballot,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;</span><br><span class="line">                 /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ &#123;<span class="keyword">rec</span>&#125;) \cup</span><br><span class="line">                            &#123;[inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;]</span><br><span class="line">                 /\ <span class="type">IF</span> <span class="keyword">rec</span>.inst \<span class="keyword">in</span> leaderOfInst[replica] <span class="type">THEN</span></span><br><span class="line">                        /\ leaderOfInst' = [leaderOfInst <span class="type">EXCEPT</span> ![replica] = </span><br><span class="line">                                                                @ \ &#123;insrec.t&#125;]</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed,</span><br><span class="line">                                        crtInst, ballots, preparing &gt;&gt;</span><br><span class="line">                    <span class="type">ELSE</span> <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst,</span><br><span class="line">                                      ballots, preparing, leaderOfInst &gt;&gt;</span><br><span class="line">                        </span><br><span class="line">           \/ /\ ~(\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = msg.inst)</span><br><span class="line">              /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; msg.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; &lt;&lt; <span class="number">0</span>, replica &gt;&gt;,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;</span><br><span class="line">              /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = @ \cup</span><br><span class="line">                            &#123;[inst  |-&gt; msg.inst,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;]</span><br><span class="line">              /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                              leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="PrepareFinalize"><a href="#PrepareFinalize" class="headerlink" title="PrepareFinalize"></a>PrepareFinalize</h3><p>SendPrepare里面的replica，也就是所谓的Replica L，在收到对端的”prepare-reply”消息后，会走到PrepareFinalize中。这个函数也是最为复杂的。</p><p>Enable条件：</p><ol><li>i要在preparing[replica]中<br> 也就是确认当前replica是Replica L</li><li>replica的日志中有i这个Instance，并且还没被提交</li><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<br> 下面会讨论四种情况，总体是”越来越惨”的<ol><li>如果这些replies中的某个com的status是已提交(即”committed”, “executed”)<br> 【Q】为什么会有这种情况？感觉应该是因为在FastPath的Phase1Fast或者SlowPath的Phase2Finalize之后，cleader宕机导致的。<br> 那么就将这个Instance i移出preparing[replica]。并且在sentMsg中删除所有的replies。<br> 【Q】感觉这就相当于直接让它往后提交了？</li><li>如果这些replies中<strong>没有</strong>status是已提交(即”committed”, “executed”)，但是存在acc是**”accepted”**的。<br> 同时还需要检查acc的prev_ballot大于等于(如果其他消息不是”accept”状态，那么就默认acc的大)所有其他消息的prev_ballot<br> 状态转移：<ol><li>sentMsg<br> 删除所有的replies，并且对除当前replica之外的所有Q，都发送一条”accept”消息。<br> 这个消息的ballot为自己日志中的ballot。<br> 关键内容，即cmd、deps和seq，都设置为acc传过来的。<br> 【Q】为什么replies里面prev_ballot最大的那个消息是”accpeted”，就可以以它为准走”accept流程”？</li><li>cmdLog<br> 参照sentMsg创建一个新条目。</li></ol></li></ol></li></ol><p>因为太长了，所以后面两种情况拆到下面讨论</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PrepareFinalize(replica, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> preparing[replica]</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">       /<span class="string">\</span> rec.inst = i</span><br><span class="line">       /<span class="string">\</span> rec.status <span class="string">\notin</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">       /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg : </span><br><span class="line">                        /<span class="string">\</span> msg.inst = i</span><br><span class="line">                        /<span class="string">\</span> msg.type = <span class="string">"prepare-reply"</span></span><br><span class="line">                        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">                        /<span class="string">\</span> msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rep <span class="string">\in</span> Q : <span class="string">\E</span> msg <span class="string">\in</span> replies : msg.src = rep)</span><br><span class="line">            <span class="regexp">/\  \/</span> <span class="string">\E</span> com <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> (com.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                        /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                        /\ sentMsg'</span> = sentMsg <span class="string">\</span> replies</span><br><span class="line">                        /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                        committed, ballots &gt;&gt;</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> ~(<span class="string">\E</span> msg <span class="string">\in</span> replies : msg.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\E</span> acc <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> acc.status = <span class="string">"accepted"</span></span><br><span class="line">                        /<span class="string">\</span> (<span class="string">\A</span> msg <span class="string">\in</span> (replies <span class="string">\</span> &#123;acc&#125;) : </span><br><span class="line">                            (msg.prev_ballot[<span class="number">1</span>] &lt;= acc.prev_ballot[<span class="number">1</span>] <span class="string">\/</span> </span><br><span class="line">                             msg.status <span class="comment"># "accepted"))</span></span><br><span class="line">                        /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ replies) \cup</span></span><br><span class="line"><span class="string">                                 [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                                  src   : &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  dst   : Q \ &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                                  ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                                  cmd   : &#123;acc.cmd&#125;,</span></span><br><span class="line"><span class="string">                                  deps  : &#123;acc.deps&#125;,</span></span><br><span class="line"><span class="string">                                  seq   : &#123;acc.seq&#125;]</span></span><br><span class="line"><span class="string">                        /\ cmdLog'</span> = [cmdLog EXCEPT ![replica] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                                &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                                  status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                                  cmd   |<span class="function">-&gt;</span> acc.cmd,</span><br><span class="line">                                  deps  |<span class="function">-&gt;</span> acc.deps,</span><br><span class="line">                                  seq   |<span class="function">-&gt;</span> acc.seq]&#125;]</span><br><span class="line">                         /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                         /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![replica] = @ <span class="string">\cup</span> &#123;i&#125;]</span><br><span class="line">                         /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><p>下面是后两种情况：</p><ol><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<ol><li>第一种情况；已经讨论</li><li>第二种情况：已经讨论</li><li>如果这些replies中，同时没有”committed”、”executed”、”accept”状态，但是有”pre-accepted”<br> 将replies中所有的”pre-accepted”提出来为preaccepts，又分为三种情况：<ol><li>preaccepts里面任意两个的cmd、deps和seq都相等。并且preaccepts中没有一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的。并且Q中所有的replica都发了”pre-accepted”给当前的replica。<br> 执行状态转移：<ol><li>sentMsg<br> 从当前replica向Q中所有其他replica发送”accept”。<br> cmd、deps和seq取其中任意一个就行，因为都相等。</li><li>cmdLog<br> 参照sentMsg</li><li>preparing<br> 在preparing[replica]移除掉Instance i。</li><li>leaderOfInst<br> 在leaderOfInst[replica]移除掉Instance i。</li></ol></li><li>如果和之前一样，但Q中只有大于<code>Cardinality(Q) \div 2</code>个replica发送了”pre-accepted”<br> 执行状态转移：<ol><li>sentMsg<br> <strong>这也是全局唯一会走到ReplyTryPreaccept流程里面的情况，对应了优化算法</strong>。<br> 从当前replica向Q中所有其他replica发送”try-pre-accept”。<br> 注意，这个消息<strong>也要</strong>发送给自己，所以和上一个情况是不同的处理策略。<br> cmd、deps和seq的处理办法和上面是一样的。</li></ol></li><li>如果<code>preaccepts</code>不为空，并且满足下面三个条件之一：连cmd、deps和seq都不完全一样了，<strong>或者</strong><code>Cardinality(preaccepts)</code>也小于<code>Cardinality(Q) \div 2</code>，<strong>或者</strong><code>preaccepts</code>中存在一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的<br> 执行状态转移：<ol><li>在preaccepts中CHOOSE一个cmd不为none的pac，执行StartPhase1<br> 但是和Propose的处理不同，这里会带上rec.ballot, replies作为Ballot和oldMsg参数。<br> 而replies会在StartPhase1中被直接干掉(从sendMsg里面删除掉)。</li><li>preparing<br> 去掉i</li></ol></li></ol></li><li>如果这些replies中，状态都是”not-seen”的<br> 执行状态转移：<ol><li>同样执行StartPhase1，但cmd为none。</li><li>preparing<br> 去掉i</li></ol></li></ol></li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span> /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : </span><br><span class="line">                        msg.status <span class="tag">\<span class="name">in</span></span> &#123;"accepted", "committed", "executed"&#125;)</span><br><span class="line">                   /<span class="tag">\<span class="name"> </span></span>LET preaccepts == &#123;msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "pre-accepted"&#125; IN</span><br><span class="line">                       (<span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts :</span><br><span class="line">                                    p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span>p1.deps = p2.deps /<span class="tag">\<span class="name"> </span></span>p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q <span class="tag">\<span class="name"> </span><span class="string">&#123;replica&#125;</span></span>,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![replica] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;rec&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                        &#123;[inst  |-&gt; i,</span><br><span class="line">                                          status|-&gt; "accepted",</span><br><span class="line">                                          ballot|-&gt; rec.ballot,</span><br><span class="line">                                          cmd   |-&gt; pac.cmd,</span><br><span class="line">                                          deps  |-&gt; pac.deps,</span><br><span class="line">                                          seq   |-&gt; pac.seq]&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span></span><br><span class="line">                                                          p1.deps = p2.deps /<span class="tag">\</span></span><br><span class="line">                                                          p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &lt; Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"try-pre-accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; cmdLog, proposed, executed,</span><br><span class="line">                                                crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd # p2.cmd <span class="tag">\<span class="name">/</span></span> </span><br><span class="line">                                                             p1.deps # p2.deps <span class="tag">\<span class="name">/</span></span></span><br><span class="line">                                                             p1.seq # p2.seq</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1]</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> Cardinality(preaccepts) &lt; Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>preaccepts # &#123;&#125;</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : pac.cmd # none IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>StartPhase1(pac.cmd, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;)</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "not-seen"</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>StartPhase1(none, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyTryPreaccept"><a href="#ReplyTryPreaccept" class="headerlink" title="ReplyTryPreaccept"></a>ReplyTryPreaccept</h3><p>找到发给自己的”try-pre-accept”的请求tpa，首先找到自己日志中所有Instance等于tpa.inst的条目oldRec，进行校验：</p><ol><li>tpa的ballot number要大于等于所有oldRec中的ballot number</li><li>所有oldRec中的状态不能是{“accepted”, “committed”, “executed”}</li></ol><p>然后进行讨论：</p><ol><li>如果在oldRec之外，存在某个rec，和tpa是冲突的<br> 如果tpa.inst不属于rec.deps，并且要么rec.inst不属于tpa.deps，要么rec.seq大于tpa.seq。那么rec和tpa是冲突的。<br> 如果存在冲突的话，则执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply消息。<br> 此时，status为rec.status。</li><li>cmdLog<br> 不做改动，可以认为是拒绝了这个消息。</li></ol></li><li>如果对于oldRec之外的的所有rec，都和tpa不冲突<br> 执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply”消息。<br> 注意，status的值是”OK”，这个和冲突情况不一样。【Q】如果此时status的值为”pre-accepted”，那么在FinalizeTryPreAccept中，这条日志仍有被提交的希望？</li><li>cmdLog<br> 删除所有的oldRec，也就是自己日志中所有有关Instance的日志。<br> 新增一条”pre-accepted”日志，这就相当于走完了StartPhase1。</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyTryPreaccept</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> tpa \<span class="keyword">in</span> sentMsg :</span><br><span class="line">        /\ tpa.<span class="class"><span class="keyword">type</span> = "try-pre-accept" </span></span><br><span class="line">        /\ tpa.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = tpa.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ \<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec : <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt;= tpa.ballot[<span class="number">1</span>] /\ </span><br><span class="line">                                   <span class="keyword">rec</span>.status \notin &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">            /\ \/ (\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec:</span><br><span class="line">                        /\ tpa.inst \notin <span class="keyword">rec</span>.deps</span><br><span class="line">                        /\ \/ <span class="keyword">rec</span>.inst \notin tpa.deps</span><br><span class="line">                           \/ <span class="keyword">rec</span>.seq &gt;= tpa.seq</span><br><span class="line">                        /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="keyword">rec</span>.status]&#125;)</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                        ballots, leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               \/ /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec: </span><br><span class="line">                            tpa.inst \<span class="keyword">in</span> <span class="keyword">rec</span>.deps \/ (<span class="keyword">rec</span>.inst \<span class="keyword">in</span> tpa.deps /\</span><br><span class="line">                                                      <span class="keyword">rec</span>.seq &lt; tpa.seq))</span><br><span class="line">                  /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="string">"OK"</span>]&#125;</span><br><span class="line">                  /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                    &#123;[inst  |-&gt; tpa.inst,</span><br><span class="line">                                      status|-&gt; <span class="string">"pre-accepted"</span>,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      cmd   |-&gt; tpa.cmd,</span><br><span class="line">                                      deps  |-&gt; tpa.deps,</span><br><span class="line">                                      seq   |-&gt; tpa.seq]&#125;]</span><br><span class="line">                  /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="FinalizeTryPreAccept"><a href="#FinalizeTryPreAccept" class="headerlink" title="FinalizeTryPreAccept"></a>FinalizeTryPreAccept</h3><p>选出自己Instance为i的日志rec，在所有”try-pre-accept-reply”回复中，取出Instance为i且ballot为rec.ballot的回复，构成集合tprs。<br>那么对于Q中的任意一个r，tprs中肯定有一条消息是从r中发出的。也就是说必须得Q中每一个Replica都回复了”try-pre-accept-reply”，这个也是老生常谈的条件。</p><p>下面是三种情况的讨论：</p><ol><li><code>\A tpr \in tprs: tpr.status = &quot;OK&quot;</code><br> 这说明在ReplyTryPreaccept中，大家都没冲突。这个类似于PrepareFinalize中的accept流程，也就是论文中所谓的Paxos-Accept phase。执行状态转换：<ol><li>sentMsg<br> 直接发送”accept”消息给Q，后面就是走Phase2Reply的流程。</li><li>cmdLog<br> 设置status为”accepted”</li></ol></li><li>如果在tpr中存在某个status为{“accepted”, “committed”, “executed”}的消息<br> 走StartPhase1</li><li>如果tpr.status不全是”OK”，也有”pre-accepted”<br> 这里应该是冲突了，所以直接干掉。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FinalizeTryPreAccept(cleader, i, Q) ==</span><br><span class="line">    <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> rec.inst = i</span><br><span class="line">        <span class="regexp">/\ LET tprs == &#123;msg \in sentMsg : msg.type = "try-pre-accept-reply" /</span><span class="string">\</span></span><br><span class="line">                            msg.dst = cleader <span class="regexp">/\ msg.inst = i /</span><span class="string">\</span></span><br><span class="line">                            msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> <span class="string">\A</span> r <span class="string">\in</span> Q: <span class="string">\E</span> tpr <span class="string">\in</span> tprs : tpr.src = r</span><br><span class="line">            <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"OK"</span></span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ tprs) \cup</span></span><br><span class="line"><span class="string">                             [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                              src   : &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              dst   : Q \ &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                              ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                              cmd   : &#123;rec.cmd&#125;,</span></span><br><span class="line"><span class="string">                              deps  : &#123;rec.deps&#125;,</span></span><br><span class="line"><span class="string">                              seq   : &#123;rec.seq&#125;]</span></span><br><span class="line"><span class="string">                  /\ cmdLog'</span> = [cmdLog EXCEPT ![cleader] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                            &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                              status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                              ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                              cmd   |<span class="function">-&gt;</span> rec.cmd,</span><br><span class="line">                              deps  |<span class="function">-&gt;</span> rec.deps,</span><br><span class="line">                              seq   |<span class="function">-&gt;</span> rec.seq]&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> StartPhase1(rec.cmd, cleader, Q, i, rec.ballot, tprs)</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"pre-accepted"</span></span><br><span class="line">                  /<span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"OK"</span>, <span class="string">"pre-accepted"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = sentMsg \ tprs</span></span><br><span class="line"><span class="string">                  /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                  ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>There Is More Consensus in Egalitarian Parliaments</li><li>EPaxos Revisited</li><li><a href="https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla" target="_blank" rel="noopener">https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla</a><br> 一份TLA+的说明</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍EPaxos算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="paxos" scheme="http://www.calvinneo.com/tags/paxos/"/>
    
    <category term="epaxos" scheme="http://www.calvinneo.com/tags/epaxos/"/>
    
  </entry>
  
  <entry>
    <title>Mac电脑配置指南</title>
    <link href="http://www.calvinneo.com/2021/10/01/mac-config/"/>
    <id>http://www.calvinneo.com/2021/10/01/mac-config/</id>
    <published>2021-10-01T04:33:22.000Z</published>
    <updated>2021-10-01T14:16:43.182Z</updated>
    
    <content type="html"><![CDATA[<p>总结Mac系统下的配置相关方法。</p><a id="more"></a><h1 id="输入输出相关"><a href="#输入输出相关" class="headerlink" title="输入输出相关"></a>输入输出相关</h1><p>对于普通外接键盘，配置Alt为Command，Win为Option，Capslock为Control。使用Control+Space切换输入法。</p><h1 id="SSH相关"><a href="#SSH相关" class="headerlink" title="SSH相关"></a>SSH相关</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> -i ~/.ssh/id_rsa.pub root@localhost</span><br><span class="line">sudo systemsetup -setremotelogin <span class="keyword">on</span></span><br></pre></td></tr></table></figure><p>然后参照<a href="https://stackoverflow.com/questions/68827166/how-can-i-ssh-rootlocalhost-and-su-root-without-password-on-macos" target="_blank" rel="noopener">这篇文章</a>设置<code>/etc/ssh/sshd_config</code>。</p><h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>有的时候Brew会Update出问题，或者install不了，这时候可以重装Brew</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/Homebrew/</span>Library<span class="regexp">/Taps/</span>homebrew/</span><br><span class="line">rm -rf homebrew-core</span><br><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/Homebrew/homebrew-core.git</span></span><br></pre></td></tr></table></figure><h1 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="为什么不能core？"><a href="#为什么不能core？" class="headerlink" title="为什么不能core？"></a>为什么不能core？</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sysctl kern.coredump=<span class="number">1</span></span><br><span class="line">chmod <span class="number">777</span> /cores</span><br></pre></td></tr></table></figure><h2 id="Finder显示全部路径"><a href="#Finder显示全部路径" class="headerlink" title="Finder显示全部路径"></a>Finder显示全部路径</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com<span class="selector-class">.apple</span><span class="selector-class">.finder</span> _FXShowPosixPathInTitle -bool YES</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结Mac系统下的配置相关方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mac" scheme="http://www.calvinneo.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>物化视图研究</title>
    <link href="http://www.calvinneo.com/2021/08/23/material_view_study/"/>
    <id>http://www.calvinneo.com/2021/08/23/material_view_study/</id>
    <published>2021-08-23T11:20:33.000Z</published>
    <updated>2022-03-01T08:37:22.659Z</updated>
    
    <content type="html"><![CDATA[<p>研究物化视图(materialized view)相关技术。</p><a id="more"></a><h1 id="Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications"><a href="#Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications" class="headerlink" title="Maintenance of Materialized Views: Problems, Techniques, and Applications"></a>Maintenance of Materialized Views: Problems, Techniques, and Applications</h1><p>什么是view，是从base (stored) relation衍生出来的relation。可以理解为从base table到derived table的函数，因此在访问时会涉及重复计算。<br>什么是materialized view？materialized view类似于一个cache，避免重复计算。materialized view上允许构建索引。<br>什么是view maintainance？在更新base relation的同时，更新view。<br>什么是incremental view maintainance？在某些情况下，只更新一部分view，而不是全部view。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol><li>Information</li><li>Modification<br> 我们是直接处理update，还是将它作为先delete再insert来处理呢？</li><li>Language<br> 这个view是如何表示的？是传统的SPJ？是否有聚合函数？有没有UNION？是Set还是Duplicate(即没有DISTINCT语义)？有没有Recursion？</li><li>Instance</li></ol><h3 id="Information和Modification"><a href="#Information和Modification" class="headerlink" title="Information和Modification"></a>Information和Modification</h3><p>考虑如下relation</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(part_no,part_cost,contract)</span></span></span><br></pre></td></tr></table></figure><p>我们创建一个view，列出所有distinct的part_cost大于1000的part_no。注意，这里的Projection带Distinct语义。</p><p>$$<br>expensiveParts (partNo) = \Pi_{partNo} \sigma_{partCost&gt;1000} (part)<br>$$</p><p>考虑insert下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><ol><li>如果只有materialized view<br> 可以用老版本的判断part_no是否在view中。</li><li>如果只有base relation<br> 用relation <code>part</code>去查看是否存在同样的part_no，但是part_cost更大的，如果有，那么就不要更新了。</li><li>如果part_no is the key<br> 可以推断出part_no肯定不在view中。<br> 因为key保证了唯一性，因为我们insert成功了，所以肯定之前没有part_no。</li></ol><p>考虑delete下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">2000</span>,c12)</span></span></span><br></pre></td></tr></table></figure><p>显然p1在materialized view里面，但是不能断定是否还有类似于<code>part(p1,3000,c13)</code>这样的存在，因此不能直接从view中删除p1。事实上不能<strong>仅</strong>依赖materialized view来处理delete的情况。但如果有下面的，则可以：</p><ol><li>relation <code>part</code></li><li>key constraint<br> 【Q】How</li><li>counts of number of view tuple derivations</li></ol><p>考虑update情况，在某些算法中归结为先delete再insert，这种方式会丢失信息。Ref BCL89 UO92 GJM94。</p><h3 id="Language和Instance"><a href="#Language和Instance" class="headerlink" title="Language和Instance"></a>Language和Instance</h3><p>我们创建一个<code>supp_parts</code>，它是supp和part这两个relation的equijoin。列出了至少有一个supp的part的number，并且已经经过了distinct。</p><p>$$<br>suppParts(partNo) = \Pi_{partNo} (supp \bowtie_{partNo} part)<br>$$</p><p>现在考虑仅适用<code>supp_parts</code>，insert下面条目</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><p>如果<code>supp_parts</code>里面已经有了p1，那么无变化。但是如果view中没有p1，并不能仅通过这个view推断是否要insert。</p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><p>使用数学语言来描述。<br>考虑link(a,b)表示从a到b的一个link，定义hop(X,Y)表示从X经过两个link能到达Y，有</p><p>$$<br>hop(X,Y) = \Pi_{X,Y} (link(X,V) \bowtie_{V=W} link(W,Y))<br>$$</p><h2 id="Full-Information"><a href="#Full-Information" class="headerlink" title="Full Information"></a>Full Information</h2><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.wikipedia.org/wiki/Relational_algebra" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Relational_algebra</a><br> 关系术语</li><li><a href="https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join" target="_blank" rel="noopener">https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join</a><br> 介绍Natual join，equijion和inner join。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究物化视图(materialized view)相关技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>Rust - A CPP Programmer&#39;s Perspective</title>
    <link href="http://www.calvinneo.com/2021/08/17/rust-acpppp/"/>
    <id>http://www.calvinneo.com/2021/08/17/rust-acpppp/</id>
    <published>2021-08-17T11:20:33.000Z</published>
    <updated>2022-10-24T11:46:48.070Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。</p><p>本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。</p><a id="more"></a><h1 id="rustup：Toolchain-管理工具"><a href="#rustup：Toolchain-管理工具" class="headerlink" title="rustup：Toolchain 管理工具"></a>rustup：Toolchain 管理工具</h1><p>安装 nightly toolchain</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain install nightly</span><br></pre></td></tr></table></figure><p>然后激活</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure><h2 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h2><p>Toolchain 的选择使用下面：</p><ol><li>在命令行中<a href="https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand" target="_blank" rel="noopener">指定</a>，如<code>cargo +beta</code></li><li>RUSTUP_TOOLCHAIN环境变量</li><li>用 <code>rustup override set</code> 覆盖当前目录以及子目录的设置<br> <code>rustup show</code>和<code>rustup override unset</code>可以查看和取消 override</li><li>rust-toolchain.toml 或者 rust-toolchain</li><li>使用 default toolchain</li></ol><h1 id="Cargo：包管理工具"><a href="#Cargo：包管理工具" class="headerlink" title="Cargo：包管理工具"></a>Cargo：包管理工具</h1><h2 id="workspace、crate-和-mod"><a href="#workspace、crate-和-mod" class="headerlink" title="workspace、crate 和 mod"></a>workspace、crate 和 mod</h2><p>C++ 并没有什么包管理，如果我们想要引用什么东西，代码声明一下，然后确保链接器能够看到定义就行。并且因为模板的引入，很多都是头文件，直接include就行。</p><h3 id="访问-mod"><a href="#访问-mod" class="headerlink" title="访问 mod"></a>访问 mod</h3><h4 id="crate内"><a href="#crate内" class="headerlink" title="crate内"></a>crate内</h4><p>src/main.rs和src/lib.rs被称为crate<strong>根</strong>。</p><p>一个crate下有若干mod，每个mod的成员在对应mod文件夹的mod.rs中列出。<br>例如下面的声明，会查找当前目录下的hello.rs，或者hello目录下的mod.rs。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">mod</span>.rs</span><br><span class="line"><span class="keyword">mod</span> hello;</span><br></pre></td></tr></table></figure><p>可以通过<code>#[path = &quot;foo.rs&quot;]</code>来指定 mod 的位置。这种用法可以在函数中 inline。可以在<a href="https://github.com/CalvinNeo/Ruster/blob/3f228dbd15791f8bea85e56a46527c6c397d7acb/src/main.rs#L1" target="_blank" rel="noopener">这段代码</a>中查看具体用法。</p><h4 id="跨crate"><a href="#跨crate" class="headerlink" title="跨crate"></a>跨crate</h4><p>跨crate访问，需要使用Cargo.toml中定义的crate别名。</p><h3 id="rustc-和-crate"><a href="#rustc-和-crate" class="headerlink" title="rustc 和 crate"></a>rustc 和 crate</h3><p>rustc只接受一个文件，并只生成一个crate。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc hello.rs --crate-<span class="keyword">type</span>=<span class="class"><span class="keyword">lib</span></span></span><br></pre></td></tr></table></figure><h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>workspace不能嵌套。所以如果两个Cargo工程，并且工程A依赖于工程B，比较好的方案是<a href="https://stackoverflow.com/questions/49849878/how-to-deal-with-multiple-nested-workspace-roots" target="_blank" rel="noopener">平行摆放两个工程，并设置dependencies</a>。</p><h4 id="virtual-workspace"><a href="#virtual-workspace" class="headerlink" title="virtual workspace"></a>virtual workspace</h4><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>可以通过 <code>-C debug_info</code> 来指定调试信息的等级，其中0(false)、1、2(true) 分别对应无/行信息以及全部信息。<br>另外，Cargo.toml 中的 <code>[profile]</code> 也可以修改。 </p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h2 id="features"><a href="#features" class="headerlink" title="features"></a>features</h2><p>features用来支持<a href="https://doc.rust-lang.org/reference/conditional-compilation.html" target="_blank" rel="noopener">条件编译</a>和<a href="https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies" target="_blank" rel="noopener">可选依赖</a>。<br>在编译时，可以通过<code>--features</code>去enable某个feature。<br>例如在Cargo.toml中，webp是一个feature，并且它没有enable其他feature。而ico这个feature会enable两个feature即bmp和png。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[features]</span><br><span class="line"># Defines a feature named `webp` that does not enable any other features.</span><br><span class="line">webp = []</span><br><span class="line">ico = [&quot;bmp&quot;, &quot;png&quot;]</span><br></pre></td></tr></table></figure><p>在代码中，可以用下面两种方式，让代码只对webp被enable的情况下生效，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"webp"</span>)]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cfg!</span>(feature = <span class="string">"webp"</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，所有的 feature 都是 disable 的，但可以把 feature 加入 default 中来默认 enable 它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default = [&quot;webp&quot;]</span><br></pre></td></tr></table></figure><p>在编译时，可以指定<code>--no-default-features</code>来disable default feature。</p><h3 id="dependency-features"><a href="#dependency-features" class="headerlink" title="dependency features"></a>dependency features</h3><p>在指定dependency时，也可以指定features。<br>例如下面的配置中，将flate2的default features disable掉，但额外enable了zlib这个feature。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">flate2 = &#123; version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] &#125;</span><br></pre></td></tr></table></figure><h3 id="optional-dependency"><a href="#optional-dependency" class="headerlink" title="optional dependency"></a>optional dependency</h3><p>下面的语句表示gif默认不会作为依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">gif</span> = &#123; version = <span class="string">"0.11.1"</span>, optional = <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>它会隐式定义了如下的feature</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">gif</span> = [<span class="string">"dep:gif"</span>]</span><br></pre></td></tr></table></figure><p>可以通过 <code>cfg(feature = &quot;gif&quot;)</code> 来判断dependency是否被启用，通过 <code>--features gif</code> 来显式启用 dependency。</p><p>如下的代码表示 avif 会 enable ravif 和 rgb 这两个 feature，但因为显式使用了 <code>dep:ravif</code> 和 <code>dep:rgb</code>，所以系统不会隐式生成 <code>ravif</code> 和 <code>rgb</code> 这两个feature。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ravif</span> = &#123; version = <span class="string">"0.6.3"</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="attr">rgb</span> = &#123; version = <span class="string">"0.8.25"</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">avif</span> = [<span class="string">"dep:ravif"</span>, <span class="string">"dep:rgb"</span>]</span><br></pre></td></tr></table></figure><h2 id="Cargo-toml-解读"><a href="#Cargo-toml-解读" class="headerlink" title="Cargo.toml 解读"></a>Cargo.toml 解读</h2><ol><li><p>[dependencies]<br> 依赖的第三方package</p></li><li><p>[dev-dependencies]<br> 只有tests/examples/benchmarks依赖的第三方package</p></li><li><p>[features]<br> 用来支持条件编译和可选依赖</p></li><li><p>[lib]</p></li><li><p>[[test]]<br> 两个中括号说明是表数组，我们可以这样写</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>[package]</p></li><li><p>[workspace]<br> 相对于package而言，workspace是一系列共享同样的Cargo.lock和输出目录的包。<br> 包含members数组</p></li><li><p>[profile]</p></li><li><p>[patch.crates-io]</p></li></ol><h2 id="Cargo-lock-解读"><a href="#Cargo-lock-解读" class="headerlink" title="Cargo.lock 解读"></a>Cargo.lock 解读</h2><p>Cargo.lock 是记录每个 crate 对应版本的工具。例如下面的配置表示依赖一个0.1.0版本的 <code>azure_core</code> 库，可是这个版本具体对应哪个 rev 呢？github 打开发现 master 上已经是0.2.1的版本了，我们显然不可能是用的 master 啊。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">azure_core</span> = &#123; version = <span class="string">"0.1.0"</span>, git = <span class="string">"https://github.com/Azure/azure-sdk-for-rust"</span>&#125;</span><br></pre></td></tr></table></figure><p>此时查看 Cargo.lock 就能发现类似下面的配置，其中具体指出了0.1.0对应的 git commit</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[package]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"azure_core"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">source</span> = <span class="string">"git+https://github.com/Azure/azure-sdk-for-rust#b3c53f4cec4a6b541e49388b51e696dc892f18a3"</span></span><br><span class="line"><span class="attr">dependencies</span> = [</span><br><span class="line"> "async-trait",</span><br><span class="line"> ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>一个 workspace 只在根目录有一个 Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。<br>如果在 Cargo.toml 和 add-one/Cargo.toml 中都增加 rand crate，则 Cargo 会将其都解析为同一版本并记录到唯一的 Cargo.lock 中。</p><h2 id="Cargo-的常见问题"><a href="#Cargo-的常见问题" class="headerlink" title="Cargo 的常见问题"></a>Cargo 的常见问题</h2><p><a href="https://github.com/rust-lang/cargo/issues/3381" target="_blank" rel="noopener">failed to authenticate when downloading repository</a>这样的错误一般出现在和github交互的场景中。使用下面的办法可解决</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br><span class="line">ssh-add</span><br><span class="line">cargo build</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/47565203/cargo-build-hangs-with-blocking-waiting-for-file-lock-on-the-registry-index-a" target="_blank" rel="noopener">Blocking waiting for file lock on the registry index</a> 这样的错误一般删除<code>rm $CARGO_HOME/.package-cache</code>.</p><h1 id="所有权、生命周期"><a href="#所有权、生命周期" class="headerlink" title="所有权、生命周期"></a>所有权、生命周期</h1><p>为了检验是否初步理解Rust所有权，可以尝试自己实现一个双向链表。</p><h2 id="绑定和可变性"><a href="#绑定和可变性" class="headerlink" title="绑定和可变性"></a>绑定和可变性</h2><h3 id="let和let-mut"><a href="#let和let-mut" class="headerlink" title="let和let mut"></a>let和let mut</h3><p><code>let x = y</code>表示把y这个值bound/assign到变量x上，因为let是immutable的，所以就不能修改变量x，也就是再次给它赋值(assign)了。如果需要能re-bound或者re-assign，就需要<code>let mut x = y</code>这种形式。</p><p>对结构体而言，如果它是immutable的，那么它的所有成员也都是immutable的。在C++中，可以声明类中的某个成员是mutable的，这样即使在const类中也可以修改它，但Rust不允许这样。</p><p>由此还派生出了<code>&amp;mut</code>和<code>&amp;</code>两种引用。可以可变或者不可变地借用let mut绑定的值，但只能不可变地借用let绑定的值。</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>下面的语句都在尝试定义一个<code>&amp;mut {interger}</code>类型的a，但第三条语句是编译不过的。原因是它触发了Rust里面的pattern matching。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">ref</span> <span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> a = &amp;<span class="keyword">mut</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> &amp;<span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 下面这个语句肯定编译不过，但可以从错误中得到a的实际类型，所以是个常见的白嫖编译器类型推导的办法</span></span><br><span class="line"><span class="keyword">let</span> _: () = a;</span><br></pre></td></tr></table></figure><p>我们很熟悉对 enum 类型(诸如<code>Option</code>和<code>Result</code>)进行 Pattern Matching 的做法。下面介绍一些不一样的，例如可以 Pattern Match 一个 struct，有点类似 C++ 的 structual binding。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@</code>，可以在 Pattern Matching 的时候同时指定期待的值，并将该值保存到局部变量中，有点类似于 Haskell 的用法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x: xv @ <span class="number">1</span>, y: yv @ <span class="number">2</span>&#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched x &#123;:?&#125; y &#123;:?&#125;"</span>, xv, yv),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        pt @ Point &#123; .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched pt &#123;:?&#125;"</span>, pt),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern bindings after an `@` are unstable</span></span><br><span class="line">    <span class="comment">// https://github.com/rust-lang/rust/issues/65490</span></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        pt @ Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched pt &#123;:?&#125; x &#123;:?&#125; y &#123;:?&#125;"</span>, pt, x, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在pattern matching的时候不move，<a href="https://stackoverflow.com/questions/29662807/how-do-you-borrow-a-mutable-reference-during-a-match" target="_blank" rel="noopener">而是borrow呢</a>？如下所示，<code>g</code>是一个owned值，而不是一个mutable borrow的值。解决方案就是直接<code>match v.intention_mut()</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intention = v.intention_mut();</span><br><span class="line"><span class="keyword">match</span> intention &#123;</span><br><span class="line">    vehicle::Intention::Die =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    vehicle::Intention::Goto(g) =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Variable-shadow"><a href="#Variable-shadow" class="headerlink" title="Variable shadow"></a>Variable shadow</h3><p>在Rust中有如下称为Variable shadow的做法。一个问题油然而生，既然可以直接<code>let mut</code>，为什么还需要如下的做法呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>其实shadow的含义是这个变量的生命周期没变，只是我们无法通过从前的名字访问它了，而let mut在重新assign之后，原来的value就会被析构掉。进一步举个例子，给出下面这个程序，它的输出是啥？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop &#123;&#125;"</span>, <span class="keyword">self</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>为什么呢？对于第一种情况，a被rebound了，但是<code>S {x: 1}</code>只是被shadow了，并没有立即析构。但对于第二种情况，在rebound的时候，<code>S { x: 1 }</code>就被析构了。</p><h2 id="移动和借用"><a href="#移动和借用" class="headerlink" title="移动和借用"></a>移动和借用</h2><p>可以把所有对值的使用方式归纳为三种：复制、移动和引用(或者称为指针)：</p><ol><li>复制的缺点是浪费空间和时间。</li><li>移动的缺点是很多变量的地址会变，这个FFI带来很多麻烦，需要用Box/Pin将一些东西分配到堆上的固定地址，并且传出裸指针。</li><li>引用的缺点是存在NULL，为了避免NULL，又要引入生命周期注解等机制。此外，即使在有了移动语义后，多线程之间依然可以通过引用来访问同一个值，产生并发问题。</li></ol><p>Rust中的<strong>移动可能伴随着内存地址的变化</strong>。很显然，一个对象从A方法通过调用被移动到B方法中，那么肯定出于不同的栈帧中，它的地址肯定会变化，所以要提防这个。而C++中移动更类似金蝉脱壳，将老对象中的东西拆出来用来构建新对象。</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can compile</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can not compile</span></span><br><span class="line"><span class="keyword">let</span> vx = <span class="built_in">vec!</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> vy = vx;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, vx[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用和借用是什么关系呢？<strong>创建一个引用的行为称为借用</strong>，在借用过程中，是不可以访问owned值的，否则出现<code>use of borrowed xxx</code>错误。</p><p>在C++中，引用必须在定义时就绑定，并且，无论它是可变引用<code>T&amp;</code>还是不可变引用<code>const T&amp;</code>，都不能重新绑定。这很难受，并且<code>std::reference_wrapper</code>也不是什么时候都可以用的。Rust中这些都不是问题，例如下面的代码就可以正常运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a: &amp;<span class="built_in">i32</span>;</span><br><span class="line">a = &amp;<span class="number">1</span>;</span><br><span class="line">a = &amp;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="只能有一个可变借用，或多个不可变借用"><a href="#只能有一个可变借用，或多个不可变借用" class="headerlink" title="只能有一个可变借用，或多个不可变借用"></a>只能有一个可变借用，或多个不可变借用</h3><p>考虑下面的Race Condition:</p><ol><li>多个指针访问同一块数据</li><li>至少一个指针被用来修改数据</li><li>没有同步机制</li></ol><p>Rust解决方案是只能同时有一个可变借用，或者多个不可变借用。问题来了，如果Owner在写，有一个可变引用在写，或者有一个不可变引用在读呢？<br>对于对象的成员函数的调用，这种情况是不存在的。<a href="https://stackoverflow.com/questions/55688018/how-does-rust-prevent-data-races-when-the-owner-of-a-value-can-read-it-while-ano" target="_blank" rel="noopener">如下所示</a>，成员函数需要<code>&amp;self</code>或者<code>&amp;mut self</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="string">"123"</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">x.push_str(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"y = &#123;&#125;"</span>, y);</span><br></pre></td></tr></table></figure><p>那么对于primitive types呢？运行下面的代码，发现出现错误提示”use of borrowed <code>aaa</code>“，这也就是说在借用期间，是无法访问owned value的，毕竟被<strong>借走</strong>了嘛。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bbb = &amp;<span class="keyword">mut</span> aaa;</span><br><span class="line">aaa += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"bbb &#123;:?&#125;"</span>, *bbb);</span><br></pre></td></tr></table></figure><p>注意，下面的代码给人一种”可以同时使用借用和owned的值的错觉“，但并不是这样。因为<code>change_aaa</code>对<code>aaa</code>的借用在调用完成之后就结束了，后面<code>aaa = 2</code>的时候就没有其他借用情况了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change_aaa</span></span>(bbb: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>)&#123;</span><br><span class="line">    *bbb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// TODO 是否可以想个办法异步执行</span></span><br><span class="line">    change_aaa(&amp;<span class="keyword">mut</span> aaa)</span><br><span class="line">    aaa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="通过移动来实现析构"><a href="#通过移动来实现析构" class="headerlink" title="通过移动来实现析构"></a>通过移动来实现析构</h4><p><code>std::mem::drop</code>函数用来析构T的对象，这是对移动的应用。在调用drop函数时，<code>_x</code>的所有权会被移入。当然，如果实现了<code>Copy</code>，那么<code>drop</code><a href="https://doc.rust-lang.org/std/mem/fn.drop.html" target="_blank" rel="noopener">就无效了</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>&lt;T&gt;(_x: T) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="借用的demo"><a href="#借用的demo" class="headerlink" title="借用的demo"></a>借用的demo</h4><p>当一个函数接受引用作为参数时，需要显式借用，这一点和C++不一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_takes_ref</span></span>(i: &amp;int) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">fn_takes_ref(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line">fn_takes_ref(&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Clone和Copy"><a href="#Clone和Copy" class="headerlink" title="Clone和Copy"></a>Clone和Copy</h2><h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>Rust有一个叫做<code>std::marker::Copy</code>的特殊trait，其中不带有任何方法，所以基本可以视作是给编译器提供的一个marker。如果一个类型实现了Copy trait，在赋值的时候使用复制语义而不是移动语义。</p><p>Rust不允许自身或其任何部分实现了Drop trait的类型使用Copy trait。这听起来很奇怪，但如果我说Copy trait的实现就是bitwise的Copy，就合理了。所以可以近似理解为Copy只适用于C++中的trivial的对象。</p><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>对于非trivial对象，又想复制怎么办呢？一个方法是实现Clone trait。可以理解为是C++中的拷贝构造函数。</p><p>容易想到，如果仅仅实现深复制，那么实际上就是递归调用所有field的<code>.clone()</code>而已，这其实等价于下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但注意，编译器在要求实现Copy后，Clone的含义也必须代表bitwise memcpy。因此我们通常会通过<code>#[derive(Copy,Clone)]</code>来支持自动生成Copy特性。</p><h2 id="所有权相关设施"><a href="#所有权相关设施" class="headerlink" title="所有权相关设施"></a>所有权相关设施</h2><p>介绍Borrow(.borrow())/BorrowMut(.borrow_mut())/AsRef(.as_ref())/AsMut(.as_mut())/ToOwned(.to_owned())等基础的实现。</p><h3 id="as-ref-as-mut-和借用"><a href="#as-ref-as-mut-和借用" class="headerlink" title="as_ref/as_mut 和借用"></a>as_ref/as_mut 和借用</h3><p>什么时候用 as_ref/as_mut 呢？如下代码所示，如果需要获得容器 Option 持有的对象的借用，那么我们不能先 unwrap 再 &amp;mut 借用，而应该先 as_mut 再 unwrap。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">i32</span>,</span><br><span class="line">    b: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: <span class="built_in">Option</span>&lt;S&gt; = <span class="literal">Some</span>(S &#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">let</span> c = &amp;<span class="keyword">mut</span> b.unwrap();</span><br><span class="line">    <span class="comment">// Ok</span></span><br><span class="line">    <span class="keyword">let</span> c = b.as_mut().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Borrow和AsRef的区别是什么？"><a href="#Borrow和AsRef的区别是什么？" class="headerlink" title="Borrow和AsRef的区别是什么？"></a>Borrow和AsRef的区别是什么？</h3><p>可以看到AsRef和Borrow两个trait的定义不能说非常相似，也可以说是一模一样了，那为什么会分成两个呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">AsRef</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Borrow</span></span>&lt;Borrowed: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Borrowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/rust-lang/rust/issues/24140" target="_blank" rel="noopener">显然这个疑问是普遍的</a>，通常的说法是Borrow更严格，目的是借用；AsRef支持的类型更广，目的是类型转换。但说实话，还是一头雾水。<a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">这篇文章讲解了个例子</a>，概括如下：</p><ol><li>HashMap存储<code>(K, V)</code>对，并且可以通过提供的<code>&amp;K</code>查找对应的<code>&amp;mut V</code>。因为按<code>K</code>写，按<code>&amp;K</code>取，所以需要保证这两个的行为是一致的。<br> 【Q】为什么HashMap要按照<code>&amp;K</code>取呢？</li><li>于此同时，我们可以实现一个<code>CaseInsensitiveString</code>结构，它可以看做是忽略大小写比较的一个String。</li><li>问题来了，我们有<code>impl Borrow&lt;str&gt; for String</code>，那么是否可以实现<code>impl Borrow&lt;str&gt; for CaseInsensitiveString</code>呢？<br> 答案是不可以的，这样会破坏HashMap的一致性。例如我两个只是大小写不同的字符串，按照<code>s: CaseInsensitiveString</code>比较是相等的，按照<code>s.borrow()</code>比较就不相等了。<br> 但这就够了么？难道<code>CaseInsensitiveString</code>不可以转换成<code>&amp;str</code>么？当然可以，所以有AsRef。</li></ol><h3 id="cannot-infer-type-for-type-parameter-Borrowed-declared-on-the-trait-BorrowMut"><a href="#cannot-infer-type-for-type-parameter-Borrowed-declared-on-the-trait-BorrowMut" class="headerlink" title="cannot infer type for type parameter Borrowed declared on the trait BorrowMut"></a>cannot infer type for type parameter <code>Borrowed</code> declared on the trait <code>BorrowMut</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Box</span>::new(RefCell::new(<span class="number">1</span>));</span><br><span class="line">(*a.borrow_mut().get_mut()) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="为什么不能从-amp-mut调用Clone？"><a href="#为什么不能从-amp-mut调用Clone？" class="headerlink" title="为什么不能从&amp;mut调用Clone？"></a>为什么不能从<code>&amp;mut</code>调用Clone？</h3><p>从下面的实现可以看到，标准库没有为<code>&amp;mut</code>提供Clone，原因是会产生指向同一个位置的两个<code>&amp;mut</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Clone</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/69875015/why-cant-we-implement-clone-for-mut" target="_blank" rel="noopener">下面的代码</a>中，如果clone了<code>&amp;mut MyStruct2</code>，会出现多个指向同一个地址的<code>&amp;&#39;a mut MyStruct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    val: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct2</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    struct_reference: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> MyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意，clone的目标不是<code>&amp;T</code>而是<code>T</code>。上面例子为什么会失败，原因是在Clone <code>MyStruct</code>的时候递归地需要Clone <code>&amp;&#39;a mut MyStruct</code>导致的。但如果直接对一个<code>&amp;mut T</code>调用Clone就不会出现编译问题，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoClone</span></span>&#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> dc = DoClone&#123;x:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> mdc = &amp;<span class="keyword">mut</span> dc;</span><br><span class="line">mdc.clone();</span><br></pre></td></tr></table></figure><h3 id="ToOwned和Clone的区别是什么？"><a href="#ToOwned和Clone的区别是什么？" class="headerlink" title="ToOwned和Clone的区别是什么？"></a>ToOwned和Clone的区别是什么？</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">ToOwned</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Owned</span></span>: Borrow&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_owned</span></span>(&amp;<span class="keyword">self</span>) -&gt; Self::Owned;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone_into</span></span>(&amp;<span class="keyword">self</span>, target: &amp;<span class="keyword">mut</span> Self::Owned) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子很经典，<code>&quot;123&quot;</code>是一个<code>&amp;str</code>类型，对它调用clone，还会得到一个<code>&amp;str</code>类型。但调用<code>to_owned</code>则会得到一个String类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> become_str = <span class="string">"123"</span>.clone();</span><br><span class="line"><span class="keyword">let</span> become_String = <span class="string">"123"</span>.to_owned();</span><br></pre></td></tr></table></figure><h2 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h2><h3 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h3><p>如何处理Option呢？</p><ol><li>unwrap+if</li><li>match，并处理<code>Some(e)</code>和<code>None</code></li><li><code>unwrap_or</code></li><li><code>map</code>组合子，<code>and_then</code>组合子</li><li><code>?</code><br> 得到<code>Result&lt;T, NoneError&gt;</code></li></ol><h3 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h3><p>如何处理Result呢？</p><ol><li><code>try!</code></li><li><code>?</code></li></ol><h1 id="指针和智能指针"><a href="#指针和智能指针" class="headerlink" title="指针和智能指针"></a>指针和智能指针</h1><p>C++中，为了突破栈上分配的限制会在堆上分配对象，Rust中为了避免移动，有更进一步的往堆上创建对象的需求。C++不会对指针进行资源管理，后面标准库也只是断断续续支持了一些智能指针，但Rust希望做得更周到一点。</p><p>在Rust中有下面的指针：</p><ol><li><code>*mut T</code>/<code>*const T</code><br> 这是C的裸指针</li><li><code>Box</code></li><li><code>Pin</code></li><li><code>Rc</code></li><li><code>Arc</code><br> 原子引用计数</li><li><code>Ref</code></li><li><code>RefCell</code></li><li><code>Cow</code></li></ol><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><h2 id="trait-Deref-DerefMut"><a href="#trait-Deref-DerefMut" class="headerlink" title="trait Deref/DerefMut"></a>trait Deref/DerefMut</h2><p>Deref是deref操作符<code>*</code>的 trait，比如<code>*v</code>。它的作用是：</p><ol><li>对于实现了Copy对象，获得其拷贝</li><li>对于没有实现Copy的对象，获得其所有权</li></ol><p>如下所示，一个智能指针对象U比如Box，如果它实现了<code>U: Deref&lt;Target=T&gt;</code>，那么Deref能够从它获得一个<code>&amp;T</code>。实现上，我们从一个<code>&amp;Box&lt;T&gt;</code>解两次引用，获得<code>T</code>，再返回<code>&amp;T</code>。抽象一点来说，在实现了Deref后，能将<code>&amp;U</code>变成<code>&amp;T</code>，换种说法<code>*x</code>的效果就是<code>*Deref::deref(&amp;x)</code>。这么做的好处是将所有奇怪的对智能指针的引用都转成<code>&amp;T</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator&gt; Deref <span class="keyword">for</span> <span class="built_in">Box</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;**<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而DerefMut如下所示，它允许我们从智能指针获取一个 <code>&amp;mut T</code>。容易发现，如果一个智能指针没实现DerefMut，那么它实际上是 Immutable 的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DerefMut</span></span>: Deref &#123;</span><br><span class="line">    <span class="comment">/// Mutably dereferences the value.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rc-Arc"><a href="#Rc-Arc" class="headerlink" title="Rc/Arc"></a>Rc/Arc</h2><p>如下图所示，三个list中，<code>b</code> 和 <code>c</code>共享 <code>a</code> 的所有权。我们可以用 Rc 来描述。<br><img src="/img/rust-lang/trpl15-03.svg"></p><p>注意虽然<code>Rc::clone(a)</code>等价于<code>a.clone()</code>，但推荐使用<code>Rc::clone</code>，因为这显式表示它只增加引用计数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和-amp-mut"><a href="#只读和-amp-mut" class="headerlink" title="只读和 &amp;mut"></a>只读和 &amp;mut</h3><p>需要注意的是，Rc 只允许各个所有者之间<strong>只读地</strong>进行共享。否则，如果各个所有者能修改，那么就有可能data race。也就是说，Rc/Arc 不实现 AsMut 和 DerefMut，从而做到禁止可变借用。事实上，Rc 会在<strong>编译期</strong>进行不可变借用的检查。</p><p>例如，如果 Rc 中持有 FnMut，则会导致 “cannot borrow data in an <code>Rc</code> as mutable” 报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> r = Rc::new(|| a += <span class="number">1</span>);</span><br><span class="line">r();</span><br></pre></td></tr></table></figure><p>尽管如此，Rc 还是通过 <code>Rc::get_mut</code> 提供一种获得 <code>&amp;mut T</code> 的方法。它会在运行期用 <code>Rc::is_unique</code> 来判断是否为唯一引用，并返回 <code>Some(&amp;mut T)</code> 或者 <code>None</code>。</p><h2 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h2><p><code>RefCell</code>是类似于<code>Box</code>的指针，但不同于引用和Box类型，RefCell<strong>在运行期检查借用</strong>。具体来说，RefCell在运行期检查：</p><ol><li>在任意时刻只能获得一个<code>&amp;mut</code>或任意个<code>&amp;</code></li><li>引用指向的对象是存在的</li></ol><p>容易想到，RefCell的内部实现肯定会有unsafe块，才能绕过编译期的可变/不可变借用检查，而delay到运行期检查。但检查仍然是要求在任何时候只允许有多个不可变借用或一个可变借用。如果运行时检查出现问题，则会panic，如下所示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic: already borrowed: BorrowMutError</span></span><br><span class="line"><span class="keyword">let</span> y1 = b.borrow_mut();</span><br><span class="line"><span class="keyword">let</span> y2 = b.borrow_mut();</span><br></pre></td></tr></table></figure><p><code>RefCell</code>在自己不可变的情况下，修改内部的值，这也就是<a href="https://kaisery.github.io/trpl-zh-cn/ch15-05-interior-mutability.html" target="_blank" rel="noopener">内部可变性</a>。可以类比为C++中一个const对象里面的mutable成员。那么<code>RefCell</code>也可以用在类似的场景下，例如一些需要存中间状态的状态机、Mocker等。</p><p>对<code>RefCell</code>的<code>&amp;</code>和<code>&amp;mut</code>借用，分别对应了<code>.borrow()</code>和<code>.borrow_mut()</code>方法。</p><p>RefCell是Send/Sync的么？将在Sync/Send章节中介绍。</p><h3 id="RefCell-的-borrow-mut-和-get-mut"><a href="#RefCell-的-borrow-mut-和-get-mut" class="headerlink" title="RefCell 的 borrow_mut 和 get_mut"></a>RefCell 的 borrow_mut 和 get_mut</h3><p>上文介绍了，RefCell 访问对象需要通过 <code>borrow</code> 系列方法，但还有一个 <code>get_mut</code> 方法，它是做啥的呢？<br>根据<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank" rel="noopener">文档</a>可以发现，这个方法直接在编译器从 RefCell 中获取 <code>&amp;mut T</code>。如下所示，这遵循编译期的检查，比如两次 <code>&amp;mut T</code> 会在编译器挡掉而不是在运行期 panic，有点不把它当 RefCell 用的感觉。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> x1 = b.get_mut();</span><br><span class="line"><span class="keyword">let</span> x2 = b.get_mut();</span><br><span class="line"><span class="comment">// Compile Error</span></span><br><span class="line">x1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br><span class="line">x2.store(<span class="literal">true</span>, std::sync::atomic::Ordering::SeqCst);</span><br></pre></td></tr></table></figure><p>如果我们联用，会在编译期报错，不过报错内容比较有趣。它说<code>b.get_mut()</code>是个可变借用，而<code>b.borrow_mut()</code>是个不可变借用。为什么不是两次可变借用的冲突？原因很简单，RefCell 本来就是支持的内部可变性嘛，所以对于 Rust 来讲，这是个不可变借用没问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = b.get_mut();</span><br><span class="line"><span class="keyword">let</span> y1 = b.borrow_mut();</span><br><span class="line">x1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br><span class="line">y1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br></pre></td></tr></table></figure><h3 id="Mutex-可以和-RefCell-联用么？"><a href="#Mutex-可以和-RefCell-联用么？" class="headerlink" title="Mutex 可以和 RefCell 联用么？"></a>Mutex 可以和 RefCell 联用么？</h3><p>Mutex 似乎自带了内部可变性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Mutex::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> lock = a.lock().unwrap();</span><br><span class="line">*(lock.deref_mut()) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Box</span>::new(RefCell::new(<span class="number">1</span>));</span><br><span class="line">(*a.deref().borrow_mut().deref_mut()) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="Rc-RefCell"><a href="#Rc-RefCell" class="headerlink" title="Rc+RefCell"></a>Rc+RefCell</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_value</span></span>(i: <span class="built_in">i32</span>) -&gt; Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">    Rc::new(RefCell::new(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = make_value(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(make_value(<span class="number">1</span>), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(make_value(<span class="number">2</span>), Rc::clone(&amp;a));</span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> z = value.borrow_mut();</span><br><span class="line">    <span class="comment">// *z = 11; // error</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h2><p>【建议在学习Pin之前，了解 Deref 和 DerefMut】<br>一个async fn会产生一个自引用结构<code>AsyncFuture</code>，因此它不能被移动。让一个对象不能被移动的<strong>第一步</strong>是将它分配到堆上，<code>Box</code>可以做到这一点。但这并不够，因为如下所示，<code>std::mem::swap</code>能够移动Box中的对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb2 = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;);</span><br><span class="line">std::mem::swap(rb.as_mut(), rb2.as_mut());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, rb.b, rb2.b); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p>另一方面，很多FFI会跨语言边界传递指针，这<strong>也需要保证地址是不变的</strong>。综上于是就有了Pin。Pin 中包裹了一个指针，如 <code>Pin&lt;&amp;mut T&gt;</code> , <code>Pin&lt;&amp;T&gt;</code> ,<code> Pin&lt;Box&lt;T&gt;&gt;</code>，Pin 保证对应的 T 不会被移动。<br>其实在 C++ 中也会有自引用结构，并且也会造成相同的问题。</p><p>Pin分析了下，诸如<code>std::mem::swap</code>之流为什么能移动，原因是它们都能获得<code>&amp;mut T</code>。所以只要<strong>限制可变借用</strong>，就可以在把对象Pin在堆上。限制获得可变引用简单啊，不实现<code>AsMut</code>就行。</p><h3 id="Unpin-和-Unpin-和-PhantomPinned"><a href="#Unpin-和-Unpin-和-PhantomPinned" class="headerlink" title="Unpin 和 !Unpin 和 PhantomPinned"></a>Unpin 和 !Unpin 和 PhantomPinned</h3><p>大部分的类型都被实现了 Unpin trait，表示能够随意被移动。</p><p>而一个可以被 Pin 住的值需要实现 <code>!Unpin</code>。因为 Rust 中带 <code>!</code> 这样的称为 negative bounds，Rust 对它的支持还没有稳定下来。所以更一般的做法是让结构中持有一个 PhantomPinned 的 marker。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructCanBePinned</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    _marker: PhantomPinned,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::marker::PhantomPinned</code>中被实现了<code>!Unpin</code>，它会是持有它的结构体变成 <code>!Unpin</code>，从而无法被移动。</p><p>以上的容易理解，但为什么会有<code>Unpin</code>和<code>!Unpin</code>呢？原因是需要给类型分类，讨论在Pin之前和之后类型的行为。这肯定难以理解，所以不妨先看看Pin是如何创建的，再回过来看。</p><h3 id="Pin-对象的创建方式"><a href="#Pin-对象的创建方式" class="headerlink" title="Pin 对象的创建方式"></a>Pin 对象的创建方式</h3><p>在下面的代码中，对一个实现了 <code>trait Unpin</code> 的类型 Target，可以直接通过 <code>Pin::new</code> 产生一个 <code>Pin&lt;P&gt;</code> 对象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(pointer) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_unchecked</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    Pin &#123; pointer &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果说是一个<code>!Unpin</code>的对象，<code>Pin::new</code> 会返回错误 “error[E0277]: <code>PhantomPinned</code> cannot be unpinned”；或者错误 “the trait <code>Unpin</code> is not implemented for <code>TestNUnpin</code>“，和”note: consider using <code>Box::pin</code>“。可以通过打开下面代码的注释来检查。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestUnpin</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestNUnpin</span></span> &#123;</span><br><span class="line">    b: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> TestNUnpin &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rp = Pin::new(&amp;<span class="keyword">mut</span> TestUnpin::<span class="keyword">default</span>());</span><br><span class="line">    <span class="comment">// let rnp = Pin::new(&amp;mut TestNUnpin::default());</span></span><br><span class="line">    <span class="comment">// let rnp2 = Pin::new(&amp;TestUnpin::default()); // error[E0277]: `PhantomPinned` cannot be unpinned</span></span><br><span class="line">    <span class="keyword">let</span> rnb = <span class="built_in">Box</span>::pin(TestNUnpin::<span class="keyword">default</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用不安全的-new-unchecked"><a href="#使用不安全的-new-unchecked" class="headerlink" title="使用不安全的 new_unchecked"></a>使用不安全的 new_unchecked</h4><p>我们可以通过 <code>Pin::new_unchecked</code> 来创建 <code>!Unpin</code> 的对象。但这是<a href="https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#safety" target="_blank" rel="noopener">不安全的</a>，因为我们不能保证传入的 <code>pointer: P</code> 指向的数据是被 pin 的。使用这个方法，需要保证 <code>P::Deref/DerefMut</code> 的实现中不能将 self 中的东西进行移动。这是因为 Pin 的 <code>as_mut</code> 和 <code>as_def</code> 会调用 P 的 <code>deref(_mut)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Pin&lt;&amp;<span class="keyword">mut</span> P::Target&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY: see documentation on this function</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.pointer) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以构造出一个 evil 有问题的 case。在 DerefMut 中，我们将 b 的原值 move 了出来。结果打印出来已经有问题了。解决方案也很简单，我们始终 pin 住 <code>&amp;mut T</code> 就行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EvilNUnpin</span></span> &#123;</span><br><span class="line">    b: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> EvilNUnpin &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Deref <span class="keyword">for</span> EvilNUnpin &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Self::Target &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> DerefMut <span class="keyword">for</span> EvilNUnpin &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target &#123;</span><br><span class="line">        <span class="keyword">self</span>.b = <span class="string">"3"</span>.to_owned();</span><br><span class="line">        &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x1 = EvilNUnpin &#123; b: <span class="string">"1"</span>.to_owned() &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x2 = EvilNUnpin &#123; b: <span class="string">"2"</span>.to_owned() &#125;;</span><br><span class="line">    <span class="keyword">let</span> ptr1 = &amp;x1 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">    <span class="keyword">let</span> ptr2 = &amp;x2 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">    <span class="comment">// Ok if we use &amp;mut x1 and &amp;mut x2.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> xp = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(x1) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> xp2 = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(x2) &#125;;</span><br><span class="line">    std::mem::swap(&amp;<span class="keyword">mut</span> xp.as_mut(), &amp;<span class="keyword">mut</span> xp2.as_mut());</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = &amp;*(ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">        <span class="keyword">let</span> n2 = &amp;*(ptr2 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; &#123;:?&#125;"</span>, n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，还需要保证这个 pointer 指向的对象不会再被移动，特别要注意不能以 <code>&amp;mut P::Target</code> 这样的方式被移动，例如通过之前提的 mem::swap。<br>特别地，Pin 需要保证自己维护的指针不会再被移动了，**即使在自己销毁之后，<a href="https://stackoverflow.com/questions/69854787/why-we-use-boxpin-for-unpin-and-pinnew-for-unpin" target="_blank" rel="noopener">也是不能被移动的</a>**，但这个很难在编译期判定。如下代码所示，在两个 Pin 对象析构后，我们又可以移动对象 x1 和 x2 了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x1 = TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin&#123; b: <span class="string">"2"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> ptr1 = &amp;x1 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"><span class="keyword">let</span> ptr2 = &amp;x2 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _pin1 = Pin::new_unchecked(&amp;x1);</span><br><span class="line">    <span class="keyword">let</span> _pin2 = Pin::new_unchecked(&amp;x1);</span><br><span class="line">&#125;</span><br><span class="line">std::mem::swap(&amp;<span class="keyword">mut</span> x1, &amp;<span class="keyword">mut</span> x2);</span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = &amp;*(ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="keyword">let</span> n2 = &amp;*(ptr2 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="comment">// Shoule be 2 and 1.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n1.b, <span class="string">"2"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(n2.b, <span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对-Rc-使用-new-unchecked-也不安全"><a href="#对-Rc-使用-new-unchecked-也不安全" class="headerlink" title="对 Rc 使用 new_unchecked 也不安全"></a>对 Rc<t> 使用 new_unchecked 也不安全</t></h4><p>如下所示，我们可以获得 &amp;mut T，从而又可以乱搞了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = Rc::new(TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;);</span><br><span class="line"><span class="keyword">let</span> pinned = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(Rc::clone(&amp;x)) &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> p = pinned.as_ref();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">drop</span>(pinned);</span><br><span class="line"><span class="comment">// We can get &amp;mut T now.</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(Rc::get_mut(&amp;<span class="keyword">mut</span> x).is_some());</span><br></pre></td></tr></table></figure><h4 id="使用安全的-Box-pin"><a href="#使用安全的-Box-pin" class="headerlink" title="使用安全的 Box::pin"></a>使用安全的 Box::pin</h4><p>使用 <code>Box::pin</code> 会产生一个 <code>Pin&lt;Box&lt;T&gt;&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x1 = TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin&#123; b: <span class="string">"2"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> ptr1 = &amp;x1 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"><span class="keyword">let</span> ptr2 = &amp;x2 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bx1 = <span class="built_in">Box</span>::pin(x1);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bx2 = <span class="built_in">Box</span>::pin(x2);</span><br><span class="line">std::mem::swap(&amp;<span class="keyword">mut</span> bx1, &amp;<span class="keyword">mut</span> bx2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = &amp;*(ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="keyword">let</span> n2 = &amp;*(ptr2 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="comment">// Should still be 1 and 2.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n1.b, <span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(n2.b, <span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 <code>Box::pin</code> 可以 Pin 住 <code>!Unpin</code>？<br>查看 <code>Box::pin</code> 的实现。它传入一个 <code>T</code>，然后创建一个<code>Box&lt;T&gt;</code>并立马 Pin 住它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pin</span></span>(x: T) -&gt; Pin&lt;<span class="built_in">Box</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    (<span class="keyword">box</span> x).into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Pin之前，无法移动T，这是因为只能同时有一个可变借用<code>&amp;mut T</code>。<br>在Pin之后，无法移动T，这是因为Box被实现为owned且unique的。可以参考下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t = TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> mt = &amp;<span class="keyword">mut</span> t;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::pin(&amp;<span class="keyword">mut</span> t);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t2 = TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;;</span><br><span class="line">std::mem::swap(mt, &amp;<span class="keyword">mut</span> t2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, t.b, t2.b);</span><br></pre></td></tr></table></figure><h4 id="使用安全的-pin-utils"><a href="#使用安全的-pin-utils" class="headerlink" title="使用安全的 pin_utils"></a>使用安全的 pin_utils</h4><p>还可以使用 <code>pin_utils::pin_mut!</code>。对于下面的代码，我们考量上述 <code>new_unchecked</code> 安全性的几点保证：</p><ol><li>控制 <code>Deref(Mut)</code><br> pin 的是 <code>&amp;mut T</code> 而不是 <code>T</code>。</li><li>不能取出 <code>&amp;mut T</code><br> 这很简单，因为开始的 <code>$x</code> 已经被 shadow 了。</li><li>不能再次移动 <code>T</code><br> 同上。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> pin_mut &#123;</span><br><span class="line">    ($($x:ident),* $(,)?) =&gt; &#123; $(</span><br><span class="line">        <span class="comment">// Move the value to ensure that it is owned</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> $x = $x;</span><br><span class="line">        <span class="comment">// Shadow the original binding so that it can't be directly accessed</span></span><br><span class="line">        <span class="comment">// ever again.</span></span><br><span class="line">        <span class="meta">#[allow(unused_mut)]</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> $x = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            $crate::core_reexport::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> $x)</span><br><span class="line">        &#125;;</span><br><span class="line">    )* &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 shadow 非常重要，我们用下面的例子来说明。可以看到 <code>xp</code> 并没有 shadow 住 <code>x</code>，因此在它被 drop 后，<code>x</code> 又可以被 mutable borrow 了。所以 <code>pin_mut</code> 的实现中保证了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = TestNUnpin &#123; b: <span class="string">"b"</span>.to_owned() &#125;;</span><br><span class="line"><span class="comment">// mutable borrow begins</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> xp = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> x) &#125;;</span><br><span class="line"><span class="built_in">drop</span>(xp);</span><br><span class="line"><span class="comment">// mutable borrow ends</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(x.b, <span class="string">"b"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin &#123; b: <span class="string">"b2"</span>.to_owned() &#125;;</span><br><span class="line">std::mem::swap(&amp;<span class="keyword">mut</span> x, &amp;<span class="keyword">mut</span> x2);</span><br><span class="line"><span class="built_in">assert_eq!</span>(x.b, <span class="string">"b2"</span>);</span><br></pre></td></tr></table></figure><p>另外，这里的 <code>let mut $x = $x</code> 也很重要，它使得下面的代码可以编译</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> x_mut = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    pin_mut!(x_mut);</span><br><span class="line">    **x_mut = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时它<a href="https://stackoverflow.com/questions/73945397/why-a-ownership-test-is-necessary-in-pin-mut#73950193" target="_blank" rel="noopener">可以拒绝</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> foo = Foo &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    pin_mut!(foo);</span><br><span class="line">    <span class="keyword">let</span> _: Pin&lt;&amp;<span class="keyword">mut</span> Foo&gt; = foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Woops we now have an unprotected Foo when its supposed to be pinned and</span></span><br><span class="line"><span class="comment">// thus can break the guarantees of Pin::new_unchecked</span></span><br><span class="line"><span class="keyword">let</span> foo_ref: &amp;<span class="keyword">mut</span> Foo = &amp;<span class="keyword">mut</span> foo;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结几个疑问：</p><ol><li><p>为什么可以直接 <code>Pin::new</code> 一个 <code>Unpin</code> 对象？<br> 因为对于实现Unpin类型的对象，Pin不做任何保证。</p></li><li><p>为什么不能直接 <code>Pin::new</code> 一个 <code>!Unpin</code> 的对象？<br> 因为这是不安全的，所以要么 unsafe 地 <code>Pin::new_unchecked</code> 来创建，要么借助于诸如 Box::pin 等安全的方法。</p></li><li><p>如果 T 是 Unpin，能获得 Pin 里面的 <code>&amp;mut</code> 么？<br> 可以通过<code>Pin::get_mut</code>获得</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p = TestUnpin&#123; <span class="string">"a"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p2 = TestUnpin&#123; <span class="string">"b"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    Pin::new(&amp;<span class="keyword">mut</span> p)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    Pin::ne(&amp;<span class="keyword">mut</span> p2)</span><br><span class="line">&#125;;</span><br><span class="line">std::mem::swap(Pin::get_mut(rp), Pin::get_mut(rp2));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, p.a, p2.a); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p> 但如果类型是!Unpin，我们就不能调用 <code>Pin::get_mut</code>。</p></li></ol><p>现在回答为什么要有Unpin和!Unpin的问题。对于Unpin类型，它实际上是给Pin做了一个担保，告诉Pin即使我这个类型被移动了也没事，所以Pin对它的作用就是屏蔽了<code>&amp;mut</code>的获取渠道。对于!Unpin和PhantomPinned类型，它们是真的不能被移动的，这不仅要借助Pin，这些类型自己也要提供一个合适的接口，从它们来创建Pin。</p><h3 id="Pin-和内部可变性"><a href="#Pin-和内部可变性" class="headerlink" title="Pin 和内部可变性"></a>Pin 和内部可变性</h3><p>是不是被 Pin 的对象就不可以有内部可变性呢？不妨考虑下面一个更简单的对象，我们修改 a 的值，并不会导致任何地址上的变化，所以这个对象是可以有内部可变性的。<br>Pin 使得下面的代码不可编译，并报错”trait <code>DerefMut</code> is required to modify through a dereference, but it is not implemented for <code>Pin&lt;&amp;mut SimpleNUnPin&gt;</code>“。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleNUnPin</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> SimpleNUnPin &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = SimpleNUnPin &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">    pin_utils::pin_mut!(x);</span><br><span class="line">    x.as_mut().a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们能够通过 RefCell 获得内部可变性么？这其实不安全。</p><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期(lifetime)是编译期中的 borrow checker 用来检查所有的借用都 valid 的结构。<br>当在结构体中持有一个引用时，需要指定生命周期，从而防止悬垂引用。</p><h2 id="计算生命周期"><a href="#计算生命周期" class="headerlink" title="计算生命周期"></a>计算生命周期</h2><p>下面的代码展示了 Lifetime 和 Scope 的区别。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">3</span>; <span class="comment">// Lifetime for `i` starts. ────────────────┐</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow1 = &amp;i; <span class="comment">// `borrow1` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow1: &#123;&#125;"</span>, borrow1); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow1 ends. ──────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow2 = &amp;i; <span class="comment">// `borrow2` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow2: &#123;&#125;"</span>, borrow2); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow2` ends. ─────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">&#125;   <span class="comment">// Lifetime ends. ─────────────────────────────────────┘</span></span><br></pre></td></tr></table></figure><p>如下所示，发生了移动，只有一次析构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;</span><br><span class="line">        <span class="keyword">let</span> s = S &#123;</span><br><span class="line">            a: <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        s</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对于下面的代码，则会返回错误”error[E0597]: <code>s.a</code> does not live long enough”。这应该是 Rust 对自引用结构支持不够的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,</span><br><span class="line">    ra: RefCell&lt;<span class="built_in">Option</span>&lt;&amp;<span class="symbol">'a</span> <span class="built_in">u64</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl&lt;'a&gt; Drop for S&lt;'a&gt; &#123;</span></span><br><span class="line"><span class="comment">//     fn drop(&amp;mut self) &#123;</span></span><br><span class="line"><span class="comment">//         println!("drop!");</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;</span><br><span class="line">        <span class="keyword">let</span> s = S &#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            ra: RefCell::new(<span class="literal">None</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        *s.ra.borrow_mut() = <span class="literal">Some</span>(&amp;s.a);</span><br><span class="line">        s</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(s));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, (*b).a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明周期注解"><a href="#声明周期注解" class="headerlink" title="声明周期注解"></a>声明周期注解</h2><p>下面表示 foo 具有生命周期参数 ‘a 和 ‘b，并且 foo 的 lifetime 不会超过 ‘a 和 ‘b 的 lifetime。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;</span><br><span class="line"><span class="comment">// `foo` has lifetime parameters `'a` and `'b`</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>不考虑省略：</p><ol><li>所有引用参数都需要带一个生命周期参数</li><li>返回的引用要么是’static，要么是和输入一样的生命周期</li></ol><p>下面编译出错。这里，<code>&#39;a</code> must live longer than the function，也就是说函数运行完之后，’a 应该还在 lifetime 中。而这里的 &amp;String 在函数返回前就析构了，所以它肯定不满足 ‘a 的约束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">invalid_output</span></span>&lt;<span class="symbol">'a</span>&gt;() -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">String</span> &#123; &amp;<span class="built_in">String</span>::from(<span class="string">"foo"</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>下面两个代码实际是等价的，所以如果希望 self 的生命周期就是 impl 的，那么应该加上 ‘a。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; Foo&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; Boo&lt;<span class="symbol">'a</span>&gt; &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; Foo&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'b</span>&gt;(&amp;<span class="symbol">'b</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; Boo&lt;<span class="symbol">'b</span>&gt; &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，未必要给 impl 加 lifetime 参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Owner &#123;</span><br><span class="line">    <span class="comment">// Annotate lifetimes as in a standalone function.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="keyword">self</span>.<span class="number">0</span> += <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"`print`: &#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> owner = Owner(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    owner.add_one();</span><br><span class="line">    owner.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Elision"><a href="#Elision" class="headerlink" title="Elision"></a>Elision</h3><h1 id="闭包和函数"><a href="#闭包和函数" class="headerlink" title="闭包和函数"></a>闭包和函数</h1><h2 id="Fn-FnMut-FnOnce"><a href="#Fn-FnMut-FnOnce" class="headerlink" title="Fn/FnMut/FnOnce"></a>Fn/FnMut/FnOnce</h2><p>Rust对<code>a(b,c,d)</code>这样的调用搞了个有点像Haskell中的<code>$</code>的东西，目的是为了<strong>重载“对函数的调用”</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fn</span>::call(&amp;a, (b, c, d))</span><br><span class="line"><span class="built_in">FnMut</span>::call_mut(&amp;<span class="keyword">mut</span> a, (b, c, d))</span><br><span class="line"><span class="built_in">FnOnce</span>::call_once(a, (b, c, d))</span><br></pre></td></tr></table></figure><p><code>FnOnce</code>会获取自由变量的所有权，并且只能调用一次，调用完会把自己释放掉。<br><code>FnMut</code>会可变借用自由变量。<br><code>Fn</code>会不可变借用自由变量。<br><code>FnMut</code>和<code>Fn</code>都可以调用多次。</p><p>可以用下面的代码确定某个函数具体实现了哪个trait，实现了的trait能够通过编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_fn</span> </span>&lt;A, R&gt;(_x: <span class="function"><span class="keyword">fn</span></span>(A) -&gt; R) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_Fn</span> </span>&lt;A, R, F: <span class="built_in">Fn</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnMut</span> </span>&lt;A, R, F: <span class="built_in">FnMut</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnOnce</span> </span>&lt;A, R, F: <span class="built_in">FnOnce</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="/asset/rust/easy_demo.md"></a></p><p>查看代码，发现三者具有继承关系<code>Fn : FnMut : FnOnce</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnOnce</span></span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// The returned type after the call operator is used.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="meta-string">"fn_once_output"</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"fn_once_output"</span>, since = <span class="meta-string">"1.12.0"</span>)]</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_once</span></span>(<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnMut</span></span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Fn</span></span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么是这样的继承关系呢</strong>？<a href="https://stackoverflow.com/questions/31190851/why-is-fn-derived-from-fnmut-which-is-derived-from-fnonce" target="_blank" rel="noopener">这篇回答</a>给出了解释。</p><p>确实可以让FnOnce、FnMut和FnOnce做7种自由组合，但其中只有三种traits是有意义的：</p><ol><li>Fn/FnMut/FnOnce</li><li>FnMut/FnOnce</li><li>FnOnce</li></ol><p>这是因为，如果传入<code>&amp;self</code>可以解决的问题，传入<code>&amp;mut self</code>也可以解决。传入<code>&amp;mut self</code>可以解决的问题，传入<code>self</code>也可以解决。但反之就不一定成立。</p><p>所以 self 是大哥级的人物，动用了伤害很大，它能够解决一切的问题，所以他是最 base 的 trait，而不是最 derive 的 trait。</p><h3 id="闭包对三个trait的实现"><a href="#闭包对三个trait的实现" class="headerlink" title="闭包对三个trait的实现"></a>闭包对三个trait的实现</h3><ol><li>所有的闭包都实现了FnOnce</li><li>如果闭包只移出了所有权，则只实现FnOnce</li><li>如果闭包没移出所捕获变量的所有权，并修改了变量，则实现FnMut</li><li>如果闭包没移出所捕获变量的所有权，且没有修改变量，则实现Fn</li></ol><p><a href="https://doc.rust-lang.org/1.48.0/std/keyword.move.html" target="_blank" rel="noopener">move关键字不会改变闭包具体实现的trait</a>，而只影响变量的捕获方式，我们将在下节讨论。</p><h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p>上面的章节中介绍了闭包可能实现的三个trait，这个章节说明闭包如何捕获环境中的变量。</p><h3 id="C-中捕获的问题"><a href="#C-中捕获的问题" class="headerlink" title="C++中捕获的问题"></a>C++中捕获的问题</h3><p>在C++中，返回一个捕获了Local变量的闭包，是有安全问题的，见<code>get_f()</code>。<br>对于类中的方法，如果<strong>捕获了this指针</strong>(即使是<code>[=]</code>)并传出，在对象析构之后也是有问题的，见<code>print_this_proxy()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    S(<span class="keyword">int</span> x) : x_(x) &#123;&#125;</span><br><span class="line">    ~S() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; print_this_proxy() &#123;</span><br><span class="line">        <span class="keyword">return</span> [=]()&#123;</span><br><span class="line">            <span class="comment">// Capture this-&gt;x_</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"x_ %d"</span>, x_);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; get_f() &#123;</span><br><span class="line">    <span class="function">S <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S %d\n"</span>, s.x_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> f = get_f();</span><br><span class="line">    f(); <span class="comment">// Not safe</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; proxy;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">S <span class="title">s</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        proxy = s.print_this_proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    proxy(); <span class="comment">// Not safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust的捕获"><a href="#Rust的捕获" class="headerlink" title="Rust的捕获"></a>Rust的捕获</h3><p>Rust的捕获相比C++使人比较困惑。首先它没有地方指定捕获哪些变量；另外，还有个move关键字；最后还会加上复制和移动语义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|| <span class="number">42</span>;</span><br><span class="line">|x| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">move</span> |x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><p>闭包按照什么方式捕获，取决于我们打算如何使用捕获后的变量。</p><p>我们不妨看一个例子，首先定义下面的结构。<code>get_number</code>、<code>inc_number</code>和<code>destructor</code>分别需要传入不可变引用，可变引用以及值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MyStruct &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span> </span>(text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, number: <span class="built_in">u32</span>) -&gt; MyStruct &#123;</span><br><span class="line">        MyStruct &#123;</span><br><span class="line">            text: text,</span><br><span class="line">            number: number,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_number</span> </span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">inc_number</span> </span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">destructor</span> </span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Destructing &#123;&#125;"</span>, <span class="keyword">self</span>.text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码展示了类似fn的情况，这里fn并没有捕获任何自由变量，因此下面的代码可以正常编译和运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> closure1 = |x: &amp;MyStruct| x.get_number() + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj1), <span class="number">18</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj2), <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">is_fn(closure1); </span><br><span class="line">is_Fn(&amp;closure1);</span><br><span class="line">is_FnMut(&amp;closure1);</span><br><span class="line">is_FnOnce(&amp;closure1);</span><br></pre></td></tr></table></figure><p>下面的代码展示了Fn的情况，这里closure2捕获了obj1的引用。后面的代码进行验证，仍然可以<code>obj1.get_number()</code>来不可变借用，但需要可变引用的<code>obj1.inc_number()</code>就不能通过编译了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure immutably.</span></span><br><span class="line"><span class="keyword">let</span> closure2 = |x: &amp;MyStruct| x.get_number() + obj1.get_number();</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure2(&amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number();               // ERROR</span></span><br></pre></td></tr></table></figure><p>事实上，闭包类似语法糖，相当于把需要捕获的上下文封装到一个Context里面传给真正的执行单元。例如我们可以改写closure2，得到一个自由函数func2。它接受一个Context对象，里面封装了一个不可变引用，并且其生命周期等于Context的生命周期。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> MyStruct);</span><br><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = Context(&amp;obj1);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span> </span>(context: &amp;Context, x: &amp;MyStruct) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    x.get_number() + context.<span class="number">0</span>.get_number()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number(); // ERROR</span></span><br></pre></td></tr></table></figure><p>其实细心观察，就可以提出反对意见。上面的case中不能<code>obj1.inc_number()</code>原因是我们没有<code>let mut obj1 = ...</code>，如果加上去就能正常编译了。这不就是同时Immutable和Mutable Borrow了么？其实我们在最后加一行，再调用一次<code>func2</code>就能报错了。看起来Rust还蛮智能的，func2虽然可变借用，但后续没有用到了，所以就不影响<code>obj1.get_number()</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>下面的代码展示了FnMut的情况。现在闭包里就直接是可变借用了。在闭包之外，我们既不能可变借用，也不能不变借用，否则都无法编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure mutably.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> closure3 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.inc_number();</span><br><span class="line">    x.get_number() + obj1.get_number()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">26</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">27</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">28</span>);</span><br><span class="line"><span class="comment">// We can't borrow obj1 mutably or immutably</span></span><br><span class="line"><span class="comment">// assert_eq!(obj1.get_number(), 18);   // ERROR</span></span><br><span class="line"><span class="comment">// obj1.inc_number();                   // ERROR</span></span><br></pre></td></tr></table></figure><p>下面的代码展示了FnOnce的情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is owned by the closure</span></span><br><span class="line"><span class="keyword">let</span> closure4 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.destructor();</span><br><span class="line">    x.get_number()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尝试用四个函数检查下，发现上面三个trait的检查都无法通过编译，也就说明closure4没有实现上面三个trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not compile:</span></span><br><span class="line"><span class="comment">// is_fn(closure4);</span></span><br><span class="line"><span class="comment">// is_Fn(&amp;closure4);</span></span><br><span class="line"><span class="comment">// is_FnMut(&amp;closure4);</span></span><br><span class="line"><span class="comment">// Compiles successfully:</span></span><br><span class="line">is_FnOnce(&amp;closure4);</span><br></pre></td></tr></table></figure><p>可以发现，闭包捕获变量按照<code>&amp;T -&gt; &amp;mut T -&gt; T</code>的顺序，和<code>Fn -&gt; FnMut -&gt; FnOnce</code>的继承关系如出一辙。也就是先派小弟尝试捕获，小弟解决不了，再请老大出山的思路。</p><p>当然，可以通过<code>move</code>关键字，强行请老大出山。</p><p>对于move/move async捕获，如果闭包中需要使用某个变量例如p，并且在闭包调用完之后，还需要继续访问，则需要在调用闭包前进行clone，例如得到pp。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug,Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> pp = p.clone();</span><br><span class="line">    <span class="keyword">let</span> total_price = <span class="keyword">move</span> | price: <span class="built_in">i32</span>| &#123;</span><br><span class="line">        p.x * p.y * price</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> price = total_price(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p &#123;:?&#125; price &#123;&#125;"</span>, pp, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包能否被多个线程使用？"><a href="#闭包能否被多个线程使用？" class="headerlink" title="闭包能否被多个线程使用？"></a>闭包能否被多个线程使用？</h3><p><a href="https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads" target="_blank" rel="noopener">https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads</a></p><h1 id="并发与异步"><a href="#并发与异步" class="headerlink" title="并发与异步"></a>并发与异步</h1><h2 id="Send和Sync"><a href="#Send和Sync" class="headerlink" title="Send和Sync"></a>Send和Sync</h2><p><code>trait Send</code>表示该类型的实例可以在线程之间移动。大多数的Rust类型都是Send的，另一些则不可以。比如引用计数智能指针<code>Rc&lt;T&gt;</code>只能在线程内部使用，它就不能被实现为<code>Send</code>的；此外裸指针也不是Send的。由Send类型组成的新类型也是Send的。</p><p><code>trait Sync</code>表示多个线程中拥有该类型实例的引用。换句话说，对于任意类型T，如果<code>&amp;T</code>是Send的，那么<code>T</code>就是Sync的。</p><h3 id="一些常见类型对Send和Sync的支持"><a href="#一些常见类型对Send和Sync的支持" class="headerlink" title="一些常见类型对Send和Sync的支持"></a>一些常见类型对Send和Sync的支持</h3><h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h4><p>Rc并不是Send的。原因是Rc共享同一个引用计数块，并且更新引用计数并不是原子的。如果两个线程同时尝试clone，那么它们可能同时更新引用计数，从而可能会UB。</p><h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h4><p>如果T是Send和Sync的，那么<code>Arc&lt;T&gt;</code>是Send和Sync的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>初看这很奇怪，难道不是为了并发安全才用的Arc么？为什么反过来Arc还需要一个并发安全的类型呢？其实和C++一样，智能指针的线程安全包含两个层面，即智能指针本身实现，特别是引用计数的线程安全；以及智能指针保护的数据的线程安全：</p><ol><li>Arc相对Rc只是保证了引用计数这一块功能是并发安全的</li><li>如果类型不是并发安全的，通常需要配合RwLock和Mutex等使用。</li></ol><h4 id="RefCell-1"><a href="#RefCell-1" class="headerlink" title="RefCell"></a>RefCell</h4><p>从<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank" rel="noopener">定义</a>看，RefCell是Send的，但不是Sync的。很容易理解，一个具有内部可变性的对象的引用被各个线程持有，那岂不是可以瞎改了？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> RefCell&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> RefCell&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h4><p><code>&amp;T</code>需要T是Sync的，这个对应了上面的定义。<br><code>&amp;mut T</code>需要T是Send的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Sync</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h4><p>各类指针都不是Send的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然可以简单包一层，从而间接得到可以Send或Sync的裸指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>(*<span class="keyword">mut</span> <span class="built_in">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="built_in">Send</span> <span class="keyword">for</span> MyBox &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="built_in">Sync</span> <span class="keyword">for</span> MyBox &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用同样的办法，通过negative_impls，取消某些已经被Send/Sync的类型的特性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(negative_impls)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I have some magic semantics for some synchronization primitive!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpecialThreadToken</span></span>(<span class="built_in">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Send</span> <span class="keyword">for</span> SpecialThreadToken &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Sync</span> <span class="keyword">for</span> SpecialThreadToken &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Mutex和RwLock"><a href="#Mutex和RwLock" class="headerlink" title="Mutex和RwLock"></a>Mutex和RwLock</h4><p>Mutex需要Send，但不需要Sync。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Mutex&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Mutex&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>RwLock不仅需要Send，还需要Sync，从而保证能被Reader们共享读取。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> RwLock&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> RwLock&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future的所有权可能在各个线程之间移动，<a href="https://users.rust-lang.org/t/why-future-is-not-send-as-this-value-is-used-across-an-await-and-how-to-fix/40620" target="_blank" rel="noopener">那为什么Future不是Send的呢</a>？</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>因为Rust目前不支持可变参数包，所以<a href="https://stackoverflow.com/questions/70082393/why-cant-stdthreadspawn-accept-arguments-in-rust/70082474#70082474" target="_blank" rel="noopener">只能通过spawn闭包的形式创建线程</a>。</p><p>如果子线程panic了，其他线程是没影响的，除非：</p><ol><li>某个线程join了panic的线程，此时会得到一个包含Err的Result，如果直接unwrap则会panic</li><li>如果线程在获得锁后panic，这种现象称为poison<br> 此时，再次尝试<code>mutex.lock()</code>会得到PoisonError，并且<code>mutex.is_poisoned()</code>会返回true。</li></ol><h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>可以使用类似Go的Channel的方式来通信，也就是所谓的Do not communicate by sharing memory; instead, share memory by communicating。<br>这里mpsc是multiple producer, single consumer的意思。<br>send方法返回一个<code>Result&lt;T, E&gt;</code>类型，所以如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为生产者是可以有多个的，所以<code>tx.clone()</code>可以产生另一个生产之。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>下面展示了两种async的写法，一种是async函数<code>plus_one</code>，另一种是async块<code>plus_two</code>。对async函数，编译器在实现时也会最终转成async块的形式，并且会改写函数签名。<br>所以，可以理解为async函数最终是返回了一个<code>impl Future&lt;Output = ...&gt;</code>类型，<code>impl Future</code>表示这个类型实现了<code>trait Future</code>，这应该就是<strong>impl Trait</strong>这个特性。Output是我们期望这个Future在Ready后实际返回的类型，比如在这里就是i32。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">initial</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        initial().await + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">plus_two</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    initial().await + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plus_one_res</code>和<code>plus_two_res</code>都是Future，可以通过<code>block_on</code>获取结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> plus_one_res = plus_one();</span><br><span class="line">    <span class="keyword">let</span> plus_two_res = plus_two();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_one_res));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_two_res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以通过join同时await多个Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">futures::executor::block_on(async &#123;</span><br><span class="line">    <span class="keyword">let</span> j = futures::future::join(plus_one_res, plus_two_res).await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="trait-Future"><a href="#trait-Future" class="headerlink" title="trait Future"></a>trait Future</h3><p>这里指的是<code>std::future::Future</code>，因为在早前还有<code>futures::future::Future</code>，它是一个“社区版”的时候，后来<code>trait Future</code>被整合到了标准库中，剩余部分整合到了<code>pub trait FutureExt: Future</code>，其中包含了<code>map</code>/<code>then</code>等操作。当然对于<code>trait Future</code>还有其他的扩展，例如async-std。但回过头，先来看看最基础的<code>trait Future</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll函数返回的Poll是个enum，包含<code>Ready(T)</code>和<code>Pending</code>两个状态。但它<strong>并不只有忙等</strong>，如果在一次poll后返回的是<code>Pending</code>，那就会注册<code>cx.waker</code>这个回调，在Future后调用进行通知。</p><p><code>Pin&lt;&amp;mut Self&gt;</code>实际是个指针，它是为了解决自引用结构的问题。</p><h4 id="impl-Future"><a href="#impl-Future" class="headerlink" title="impl Future"></a>impl Future</h4><p>impl了<code>trait Future</code>的类型有很多，例如<code>f.map</code>生成的Map，<code>f.then</code>生成的<code>Then</code>这些组合子都是Future。</p><p>例如，下面代码为Map类型impl Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Map</span></span>&lt;I, F&gt; &#123;</span><br><span class="line">    <span class="comment">// Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) iter: I,</span><br><span class="line">    f: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in futures-0.1.31, src/future/map.rs</span></span><br><span class="line"><span class="comment">// 注意，这是一个较老的版本，所以future.poll的签名也不一样。在futures-0.3.15中该实现被挪到了futures-util中</span></span><br><span class="line"><span class="keyword">impl</span>&lt;U, A, F&gt; Future <span class="keyword">for</span> Map&lt;A, F&gt;</span><br><span class="line">    <span class="keyword">where</span> A: Future,</span><br><span class="line">          F: <span class="built_in">FnOnce</span>(A::Item) -&gt; U,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = U;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = A::Error;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Poll&lt;U, A::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> e = <span class="keyword">match</span> <span class="keyword">self</span>.future.poll() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(Async::NotReady) =&gt; <span class="keyword">return</span> <span class="literal">Ok</span>(Async::NotReady),</span><br><span class="line">            <span class="literal">Ok</span>(Async::Ready(e)) =&gt; <span class="literal">Ok</span>(e),</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">        &#125;;</span><br><span class="line">        e.map(<span class="keyword">self</span>.f.take().expect(<span class="string">"cannot poll Map twice"</span>))</span><br><span class="line">         .map(Async::Ready)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>e.map().map()</code>比较独特，前一个map是把<code>self.f</code>应用到e里面的东西，并且清空<code>self.f</code>，让它成为一次性的调用。后一个是把将map的结果包在<code>Async::Ready</code>里面。</p><h3 id="async的生命周期"><a href="#async的生命周期" class="headerlink" title="async的生命周期"></a>async的生命周期</h3><h3 id="async实现"><a href="#async实现" class="headerlink" title="async实现"></a>async实现</h3><p>我们知道，因为在async实现中会产生自引用结构，所以需要用Pin，那什么是自引用结构？为什么async中会存在这种结构呢？<br>首先得从async的实现讲起</p><h4 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h4><p>看下面代码，f1和f2两个await之间是串行的，那么编译器如何生成<code>f.await</code>的代码呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = async <span class="keyword">move</span> &#123;</span><br><span class="line">    f1.await;</span><br><span class="line">    f2.await;</span><br><span class="line">&#125;</span><br><span class="line">f.await;</span><br></pre></td></tr></table></figure><p>如果是用Then的方式，那么就通过回调实现，但这里Rust使用了状态机的方式，即编译器会生成类似<a href="https://huangjj27.github.io/async-book/04_pinning/01_chapter.html" target="_blank" rel="noopener">下面的代码</a>。<code>AsyncFuture</code>实际上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    fut_one: FutOne,</span><br><span class="line">    fut_two: FutTwo,</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    AwaitingFutOne,</span><br><span class="line">    AwaitingFutTwo,</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> AsyncFuture &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">                State::AwaitingFutOne =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_one.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::AwaitingFutTwo,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::AwaitingFutTwo =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_two.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::Done,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::Done =&gt; <span class="keyword">return</span> Poll::Ready(()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么async实现会涉及自引用结构？"><a href="#为什么async实现会涉及自引用结构？" class="headerlink" title="为什么async实现会涉及自引用结构？"></a>为什么async实现会涉及自引用结构？</h4><p>在之前，已经讨论过编译async的普通情况。考虑下面的代码，应该如何编译呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> read_into_buf_fut = read_into_buf(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<a href="https://huangjj27.github.io/async-book/03_async_await/01_chapter.html" target="_blank" rel="noopener">在await时可能发生线程切换</a>，所以我们需要将<code>x</code>也转移到生成的<code>AsyncFuture</code>中，那么<code>read_into_buf</code>就会产生一个指向<code>x</code>的引用。如果在一个结构中，某个字段是指向另一个字段的引用，这就是一个自引用结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadIntoBuf</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    buf: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>], <span class="comment">// points to `x` below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    x: [<span class="built_in">u8</span>; <span class="number">128</span>],</span><br><span class="line">    read_into_buf_fut: ReadIntoBuf&lt;<span class="symbol">'what_lifetime</span>?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自引用结构"><a href="#自引用结构" class="headerlink" title="自引用结构"></a>自引用结构</h4><p>自引用结构如下，b是一个指向a的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: &amp;<span class="symbol">'a</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很遗憾，Rust现在不支持自引用结构，导致下面的代码会报错(之前在 lifetime 部分也提过)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> _test = Test &#123; a, b: &amp;a &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为workaround，又得用裸指针。但这玩意有个问题，它的地址是绝对的。当Test被移动了，<code>b</code>指向的地址并不会变化。这就好比反过来的刻舟求剑，我们希望b是一个刻在船(Test)上的地址，但实际上它是个GPS坐标。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then用法"><a href="#then用法" class="headerlink" title="then用法"></a>then用法</h3><p>在没有async和await时，可以使用then系列的用法。</p><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><p>数组的签名是<code>[T;N]</code>，和C++一样，数组类型中包含了它的大小，是编译期常量。数组是否是Copy/Clone<a href="https://doc.rust-lang.org/std/primitive.array.html" target="_blank" rel="noopener">取决于其内部的类型</a>，但如果使用<code>[x, N]</code>创建数组，则<code>x</code>对应的类型必须是Copy的。数组引用<code>&amp;[T;N]</code>可以转换为切片引用<code>&amp;[T]</code></p><p>与之对应的是切片<code>&amp;[T]</code>和<code>&amp;mut [T]</code>。</p><h3 id="切片的方法"><a href="#切片的方法" class="headerlink" title="切片的方法"></a>切片的方法</h3><h3 id="Sized、-Sized、-Sized和DST"><a href="#Sized、-Sized、-Sized和DST" class="headerlink" title="Sized、!Sized、?Sized和DST"></a>Sized、!Sized、?Sized和DST</h3><p>Dynamically sized type(DST)，即动态大小类型，表示在编译阶段无法确定大小的类型</p><p>如果一个类型在编译期是已知Size，并且Size固定不变的，那么它会自动实现trait Sized。<br>但有些类型是无法在编译期确定大小的，例如<code>str</code>的大小是未知的(<a href="https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str" target="_blank" rel="noopener">所以我们一般通过<code>&amp;str</code>来访问它</a>)，一个trait的大小也是未知的。</p><p>如果一个类型的大小是未知的，那么它的使用会有限制，例如我们不能<code>Vec&lt;T&gt;</code>，而只能将T放到Box里面，做成<code>Vec&lt;Box&lt;T&gt;&gt;</code>。</p><h3 id="胖指针"><a href="#胖指针" class="headerlink" title="胖指针"></a>胖指针</h3><p>胖指针指的是指向DST的<a href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer" target="_blank" rel="noopener">引用<strong>或者指针</strong></a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_of::&lt;&amp;<span class="built_in">u32</span>&gt;()      = <span class="number">8</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>; <span class="number">2</span>]&gt;() = <span class="number">8</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>]&gt;()    = <span class="number">16</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>]&gt;()       = <span class="number">16</span></span><br><span class="line">size_of::&lt;&amp;<span class="keyword">mut</span> [<span class="built_in">u32</span>]&gt;()   = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>特别强调，指针也是胖的。考虑到C++允许直接使用delete析构POD数组，这也是和C++部分一致的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_of::&lt;*<span class="keyword">const</span> [<span class="built_in">u32</span>]&gt;() = <span class="number">16</span></span><br><span class="line">size_of::&lt;*<span class="keyword">mut</span> [<span class="built_in">u32</span>]&gt;()   = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>&amp;[u32]</code>具有两倍大小，原因是其中还储存了一份长度，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SliceRef</span></span> &#123; </span><br><span class="line">    ptr: *<span class="keyword">const</span> <span class="built_in">u32</span>, </span><br><span class="line">    len: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能直接把变量绑定到一个DST上，因为编译器无法计算出如何分配内存。例如我们经常见到<code>&amp;str</code>，但基本见不到<code>str</code>。</p><p>除了切片，trait object也是DST，它还包含了一个vptr，将在后面讨论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitObjectRef</span></span> &#123;</span><br><span class="line">    data_ptr: *<span class="keyword">const</span> (),</span><br><span class="line">    vptr: *<span class="keyword">const</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust中的字符串"><a href="#Rust中的字符串" class="headerlink" title="Rust中的字符串"></a>Rust中的字符串</h3><p>Rust中的字符串是很好的比较数组和切片的工具。和C++一样，Rust有两种字符串：</p><ol><li>str<br> str是Rust的原生字符串类型。因为是DST，所以通常以<code>&amp;str</code>出现。</li><li>String<br> String类型可以随时修改其长度和内容。</li></ol><h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><p><code>&amp;str</code>相关方法实现在str.rs的<code>impl str</code>中。通过<code>.as_ptr()</code>将其转换为一个<code>*const u8</code>指针，通过<code>.len()</code>获得其长度。</p><p>字符串字面量的类型是<code>&amp;&#39;static str</code></p><p><code>&amp;str</code>和<code>&amp;[u8]</code>可以互相转换。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>略</p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h3 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h3><p>Int 是一个别名，Interger 是一个新的类型。这种形式称为 tuple struct。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Int</span></span> = <span class="built_in">i32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interger</span></span>(<span class="built_in">u32</span>)</span><br></pre></td></tr></table></figure><h2 id="ZST"><a href="#ZST" class="headerlink" title="ZST"></a>ZST</h2><p>在C++中，会接触到这样的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZST</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(ZST)</span><br><span class="line"></span><br><span class="line">&amp;ZST() != &amp;ZST()</span><br></pre></td></tr></table></figure><p>在Rust中</p><p>ZST实例的地址是什么呢？</p><h2 id="never类型和"><a href="#never类型和" class="headerlink" title="never类型和!"></a>never类型和!</h2><p>诸如<code>return</code>、<code>break</code>、<code>continue</code>、<code>panic!()</code>、<code>loop</code> 没有返回值的，或者说返回值类型是<code>never</code>即<code>!</code>，对应到类型理论中就是Bottom类型<br>never类型可以转换为其他任何类型，所以在诸如match中才能下入如下代码而不会产生类型错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="built_in">panic!</span></span><br></pre></td></tr></table></figure><p>如下的发散函数也没有返回值，因此也具有never类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>通过turbofish可以辅助推导，下面列出一些例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x.parse::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">[</span><br><span class="line">    AdminCmdType::CompactLog,</span><br><span class="line">    AdminCmdType::ComputeHash,</span><br><span class="line">    AdminCmdType::VerifyHash,</span><br><span class="line">]</span><br><span class="line">.iter()</span><br><span class="line">.cloned()</span><br><span class="line">.collect::&lt;std::collections::HashSet&lt;AdminCmdType&gt;&gt;()</span><br><span class="line"><span class="comment">// can also use std::collections::HashSet&lt;_&gt;</span></span><br></pre></td></tr></table></figure><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>trait类似于Haskell中的typeclass。</p><h3 id="trait和adhoc多态"><a href="#trait和adhoc多态" class="headerlink" title="trait和adhoc多态"></a>trait和adhoc多态</h3><p>见笔记</p><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>关联类型(associated types)是一个将类型占位符(也就是下面的<code>type Output</code>)与trait相关联的方式。</p><p>考虑如果某个类型impl了trait Add，那么它可以接受一个RHS类型的右操作数，并返回Output类型的结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS, Output&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Output</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">u32</span>, <span class="built_in">u32</span>&gt; <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, ths: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但考虑到trait Add可以接受的RHS可能是多种(例如对String而言可以接受<code>String</code>和<code>&amp;str</code>)，但返回的Output类型是确定的，所以可以将Output类型从由用户指定<strong>改为由实现方指定</strong>。此时就可以定义一个关联类型<code>type Output</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait的继承"><a href="#trait的继承" class="headerlink" title="trait的继承"></a>trait的继承</h3><p>struct不能继承，但是trait可以继承。</p><p>这里涉及到泛型约束的问题，例如我们impl的是两个Father的交集还是并集呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Son</span></span>: Father1 + Father2 &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T: Father1 + Father2&gt; Son <span class="keyword">for</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p>在这里Father1和Father2是取的交集，也就是说对所有实现了Father1和Father2的T实现Son。</p><h3 id="孤儿规则-Orphan-Rule"><a href="#孤儿规则-Orphan-Rule" class="headerlink" title="孤儿规则(Orphan Rule)"></a>孤儿规则(Orphan Rule)</h3><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>例如我们实现sum函数，它只能接受泛型参数T是实现了trait Add的。可以这样写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;T, Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>因为使用了关联参数，所以还可以简写成这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果要写的比较多，可以把里面的东西拿出来，用where来写</p><h3 id="静态分发和动态分发"><a href="#静态分发和动态分发" class="headerlink" title="静态分发和动态分发"></a>静态分发和动态分发</h3><p>静态分发和动态分发是对trait而言的。<br>下面是静态分发，为<code>fly_static::&lt;Pig&gt;</code>和<code>fly_static::&lt;Duck&gt;</code>生成独立的代码。这类似于C++里面的模板实例化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt;(S: T) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是动态分发，在运行期查找<code>fly_dyn(&amp;Fly)</code>对应类型的方法，例如实际传入的是<code>&amp;Duck</code>还是<code>&amp;Pig</code>，是不一样的。这类似C++里面的动态绑定，是有运行时开销的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，这里的<code>&amp;Fly</code>是啥呢？实际上这是后面讨论的trait对象。</p><h2 id="trait作为存在类型-Existential-Type"><a href="#trait作为存在类型-Existential-Type" class="headerlink" title="trait作为存在类型(Existential Type)"></a>trait作为存在类型(Existential Type)</h2><p>存在类型，又被称为无法直接实例化，它的每个实例是具体类型的实例。<br>对于存在类型，编译期无法知道其功能和Size，目前Rust使用trait object和impl Trait处理存在类型。</p><h3 id="trait-object"><a href="#trait-object" class="headerlink" title="trait object"></a>trait object</h3><p>如下所示，<code>fly_dyn</code>中的<code>&amp;Fly</code>参数就是一个trait object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TraitObject 可以看成具有下面的组织结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[allow(missing_debug_implementations)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TraitObject</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> data: *<span class="keyword">mut</span> (),</span><br><span class="line">    <span class="keyword">pub</span> vtable: *<span class="keyword">mut</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable中包含了对象的析构函数、大小、对齐、方法(也就是虚函数指针)等信息。</p><p>只有<strong>对象安全</strong>的trait才可以作为trait object来使用：</p><ol><li>该trait的Self不能被限定为Sized</li><li>该trait的所有方法必须是对象安全的<ol><li>方法受Self: Sized约束</li><li>不包含任何泛型参数</li><li>第一个参数必须为Self类型，或者可以解引用为Self的类型</li><li>Self不能出现在出第一个参数之外的地方，包括返回值中</li></ol></li></ol><h3 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a>impl Trait</h3><p>在目前的版本中，<a href="https://stackoverflow.com/questions/39482131/is-it-possible-to-use-impl-trait-as-a-functions-return-type-in-a-trait-defini" target="_blank" rel="noopener">不能在trait中返回impl Trait</a>，也就是下面的代码无法编译。只能使用Trait Object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Vehicle</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `impl Trait` not allowed outside of function and inherent method return types</span></span><br></pre></td></tr></table></figure><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>默认情况下Rust编译时会link标准库，通过添加<code>no_std</code>属性可以关闭这个行为。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串相关的结构之间的转换"><a href="#字符串相关的结构之间的转换" class="headerlink" title="字符串相关的结构之间的转换"></a>字符串相关的结构之间的转换</h3><p>包括<code>str</code>、<code>String</code>、<code>&amp;[u8]</code>、<code>Vec&lt;u8&gt;</code>。</p><h1 id="macro-宏"><a href="#macro-宏" class="headerlink" title="macro 宏"></a>macro 宏</h1><h2 id="macro-的-import-和-export"><a href="#macro-的-import-和-export" class="headerlink" title="macro 的 import 和 export"></a>macro 的 import 和 export</h2><p>macro 有两种 scope，textual scope 和 path-based scope。这里的 <a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types" target="_blank" rel="noopener">path</a> 有专门的定义，可以理解为类似<code>crate::a::b</code>或者<code>super::a::b</code>这样的东西。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static; <span class="comment">// Path-based import.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> lazy_static &#123; <span class="comment">// Textual definition.</span></span><br><span class="line">    (lazy) =&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static!&#123;lazy&#125; <span class="comment">// Textual lookup finds our macro first.</span></span><br><span class="line">self::lazy_static!&#123;&#125; <span class="comment">// Path-based lookup ignores our macro, finds imported one.</span></span><br></pre></td></tr></table></figure><p>在通过 macro_rules! 定义了 macro <strong>之后</strong>，进入 textual scope，直到退出外层的 scope。这就类似于通过 let 定义变量一样。如果定义多次，那么老的 macro 会被 shadow 掉。</p><p><a href="https://github.com/CalvinNeo/Ruster/blob/2e6ddee60798413f658e0448a684dd69a6f997cc/src/main.rs#L13" target="_blank" rel="noopener">如代码所示</a>，在 mod.rs 中声明了 m 后，<code>pub mod a</code>，于是在 a 中也能使用 m 了。这是因为这里是 textual scope，a 也在 mod_macro 这个 scope 下面。也就是说 textual scope 可以进入子 mod，甚至穿越多个文件</p><p>使用<code>#[macro_use]</code>可以将 <code>mod inner</code> 中的 macro 暴露给外部。<code>#[macro_use]</code>甚至可以从另一个 crate import 指定的或者所有的 macro，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use(lazy_static)]</span> <span class="comment">// Or #[macro_use] to import all macros.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static!&#123;&#125;</span><br><span class="line"><span class="comment">// self::lazy_static!&#123;&#125; // Error: lazy_static is not defined in `self`</span></span><br></pre></td></tr></table></figure><p><code>#[macro_use]</code>需要和<code>#[macro_export]</code>配合使用。<code>#[macro_export]</code>的作用是将 macro 的声明放到 crate root 中，这样就可以通过 <code>crate::macro_name</code> 来访问。<br><a href="https://github.com/CalvinNeo/Ruster/blob/4db2a0ed9de1d70fff4d826ff6f79dcbd9648257/src/main.rs#L14" target="_blank" rel="noopener">下面的代码</a>中，helped 是定义在 mod mod_macro 中的，但它被 export 到了 crate root。所以我们可以通过 crate::helped 来访问。</p><h2 id="macro-语法"><a href="#macro-语法" class="headerlink" title="macro 语法"></a>macro 语法</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>查看定义，MacroRule 就是一个被 match 的 pattern，它支持三种括号。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MacroRules :</span><br><span class="line">   MacroRule ( ; MacroRule )* ;?</span><br><span class="line"></span><br><span class="line">MacroRule :</span><br><span class="line">   MacroMatcher =&gt; MacroTranscriber</span><br><span class="line"></span><br><span class="line">MacroMatcher :</span><br><span class="line">      ( MacroMatch* )</span><br><span class="line">   | [ MacroMatch* ]</span><br><span class="line">   | &#123; MacroMatch* &#125;</span><br></pre></td></tr></table></figure><p>所以可以写如下所示的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add &#123;</span><br><span class="line">    &#123;$a:expr,$b:expr,$c:expr&#125; =&gt; &#123;</span><br><span class="line">        $a+$b</span><br><span class="line">    &#125;;</span><br><span class="line">    [$a:expr,$b:expr] =&gt; &#123;</span><br><span class="line">        $a+$b</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add!&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add![<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add!(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>如下的代码是两种对列表求和的方案。<br>在 MacroTranscriber 中有个结构<code>$(+$a)*</code>，表示给列表的每个元素前面都加上一个<code>+</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add_list &#123;</span><br><span class="line">    ($($a:expr),*) =&gt; &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        $(+$a)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> add_list2 &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr,$($b:expr),+) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">        $(+$b)*</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add_list2!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TT-munchers"><a href="#TT-munchers" class="headerlink" title="TT munchers"></a>TT munchers</h3><p><a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html" target="_blank" rel="noopener">TT munchers</a>指的是<code>$($tail:tt)*</code>这样的结构，它永远可以捕获到还没有被 macro 处理的部分。通过该结构可以“递归”调用 macro。<br>所以可以得到第三种求和方案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add_list3 &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr,$($tail:tt)*) =&gt; &#123;</span><br><span class="line">        $a+add_list3!($($tail)*)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-MacroMatch-的详细说明"><a href="#对-MacroMatch-的详细说明" class="headerlink" title="对 MacroMatch 的详细说明"></a>对 MacroMatch 的详细说明</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacroMatch :</span><br><span class="line">      Tokenexcept $ and delimiters</span><br><span class="line">   | <span class="type">MacroMatcher</span></span><br><span class="line">   | <span class="type">$ ( IDENTIFIER_OR_KEYWORD</span> except crate | <span class="type">RAW_IDENTIFIER</span> | <span class="type">_</span> ) : MacroFragSpec</span><br><span class="line">   | <span class="type">$ ( MacroMatch</span>+ ) MacroRepSep? MacroRepOp</span><br></pre></td></tr></table></figure><p>MacroRepSep 能取什么呢？定义如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacroRepSep :</span><br><span class="line">   Token except delimiters and MacroRepOp</span><br></pre></td></tr></table></figure><p>delimiter 是三个括号，Token 基本上啥都可以是了。但我们可以写出<code>($($a:expr)&gt;&gt;*)</code>或者<code>($($a:expr)%*)</code>么？并不能，原因在”Follow-set Ambiguity Restrictions”中有讲到。</p><h3 id="metavariable"><a href="#metavariable" class="headerlink" title="metavariable"></a>metavariable</h3><ol><li>item<br> 诸如 mod、extern crate、fn、struct、enum、union、trait、macro 这些结构都是 item</li><li>expr</li><li>block</li><li>pat(Pattern)</li><li><a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types" target="_blank" rel="noopener">path</a><br> 类似<code>crate::a::b</code>这样的东西</li><li><a href="https://doc.rust-lang.org/reference/macros.html#macro-invocation" target="_blank" rel="noopener">tt(TokenTree)</a></li></ol><h1 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h1><h2 id="unsafe-操作"><a href="#unsafe-操作" class="headerlink" title="unsafe 操作"></a>unsafe 操作</h2><p>Rust哪些操作是需要unsafe包裹的呢？</p><ol><li>对<code>*mut T</code>解引用<br> 注意，取引用是safe的</li><li>访问全局的<code>static</code>对象</li><li>访问union</li></ol><p>这也对应了Rust的两个机制，所有权(禁止裸指针)和并发安全。</p><h1 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a>FFI</h1><h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>Pure virtual function called。通常是因为对象提前被析构了，导致虚表也被释放了。常常和 invalid memory reference 交替出现。</p><h1 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> panic &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 panic 操作会使得当前线程 panic。<br>诸如 Option 和 Result 的 unwrap 方法，如果结果是 None 或者 Err，则会导致 panic。</p><p>对 panic 的处理，可以是直接 abort，也可以是 unwind。通过<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html" target="_blank" rel="noopener">std::panic::catch_unwind</a>可以捕获 unwind 形式的 panic。<a href="https://doc.rust-lang.org/nomicon/unwinding.html" target="_blank" rel="noopener">在 Rust 1.0 中，panic 只能被父线程捕获</a>，所以如果我们需要捕获 panic，就必须为可能 panic 的代码启动一个新的线程，而 catch_unwind 可以缓解这问题。</p><p><code>catch_unwind</code> 的用法通常是在 FFI 的边界中用来捕获所有的 panic，但我们无法获取和 panic 有关的信息，例如 backtrace。此时可以使用<code>panic::set_hook</code>。</p><h2 id="Exception-Safety"><a href="#Exception-Safety" class="headerlink" title="Exception Safety"></a>Exception Safety</h2><p>考虑下面的代码，在 unsafe 中，clone 可能 panic。一旦它 panic，因为已经 set_len 了，所以我们可能读到一些未初始化的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Clone</span>&gt; <span class="built_in">Vec</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, to_push: &amp;[T]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.reserve(to_push.len());</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// can't overflow because we just reserved this</span></span><br><span class="line">            <span class="keyword">self</span>.set_len(<span class="keyword">self</span>.len() + to_push.len());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i, x) <span class="keyword">in</span> to_push.iter().enumerate() &#123;</span><br><span class="line">                <span class="keyword">self</span>.ptr().add(i).write(x.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="cargo-test"><a href="#cargo-test" class="headerlink" title="cargo test"></a>cargo test</h2><p>相比C++的各种测试库，Cargo直接整合了cargo test。测试一般分为两种：</p><ol><li>单测<br> 一般是某个 mod 下面的 #[cfg(test)] 的 mod。</li><li>集成测试<br> 一般是单独的 crate，名字叫做 tests。</li></ol><p>说到 test feature，有一个坑点。考虑集成测试的情况，我们创建<a href="https://github.com/CalvinNeo/tidb-engine-ext/tree/error_test_trait" target="_blank" rel="noopener">两个 crate：tests 和 raftstore</a>。在集成测试的 tests crate 中开启的 <code>#[cfg(test)]</code>，或者 cargo test 自己带上的 test feature，都不会传递到 raftstore 中。如果有需要，得通过自定义一个 testexport 来传递：</p><ol><li>如果 raftstore 需要感知 test 环境，就定义一个 testexport 在自己的 Cargo.toml</li><li>tests 的 Cargo.toml 去 enable <code>raftstore/testexport</code></li></ol><p>当然，如果是 raftstore 自己内部的单测，就不需要 testexport 了，所以我们常常看到代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(any(test, feature = <span class="meta-string">"testexport"</span>))]</span></span><br></pre></td></tr></table></figure><p>具体进行什么测试，会经过：</p><h3 id="package-selection"><a href="#package-selection" class="headerlink" title="package selection"></a>package selection</h3><p><code>--package</code>表示只测试某个package下面的测试，<code>--workspace</code>测试workspace中的所有测试。<br>如果不给定任何选项，则会根据<code>--manifest-path</code>。如果在没有给定，则使用当前的工作目录。<br>如果工作目录是某个workspace的根，则运行所有的default成员的测试。即<code>[default-members]</code>中列出的项目。如果没有列出，对于virtual workspace会运行所有workspace成员的测试；对于非virtual，则只运行root crate的测试。这里其实有点反直觉，按理说virtual workspace一个都不运行比较好。因为比如我哪天将workspace改成了virtual，那么原来的cargo test脚本可能就会运行很多的测试。</p><h3 id="target-selection"><a href="#target-selection" class="headerlink" title="target selection"></a>target selection</h3><p>如果没有指定 target selection，则TODO</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="线程安全的双向链表"><a href="#线程安全的双向链表" class="headerlink" title="线程安全的双向链表"></a>线程安全的双向链表</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Rust编程之道 by 张汉东</li><li><a href="https://course.rs/" target="_blank" rel="noopener">https://course.rs/</a><br> Rust 语言圣经</li><li><a href="https://learnku.com/docs/rust-async-std/translation-notes/7132" target="_blank" rel="noopener">https://learnku.com/docs/rust-async-std/translation-notes/7132</a><br> 异步rust学习</li><li><a href="https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html</a><br> 同样是异步教程</li><li><a href="https://huangjj27.github.io/async-book/02_execution/02_future.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/02_execution/02_future.html</a><br> 对Future实现的讲解</li><li><a href="https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/" target="_blank" rel="noopener">https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/</a><br> 这个是用Rust写操作系统的教程，这一节讲的是如何移除标准库</li><li><a href="https://www.cnblogs.com/praying/p/14179397.html" target="_blank" rel="noopener">https://www.cnblogs.com/praying/p/14179397.html</a><br> future的实现，不关注async相关，包含各种组合子</li><li><a href="https://cloud.tencent.com/developer/article/1628311" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1628311</a><br> 对pin的讲解</li><li><a href="https://folyd.com/blog/rust-pin-unpin/" target="_blank" rel="noopener">https://folyd.com/blog/rust-pin-unpin/</a><br> 对pin的讲解</li><li><a href="https://doc.rust-lang.org/std/pin/" target="_blank" rel="noopener">https://doc.rust-lang.org/std/pin/</a><br> pin的官方文档</li><li><a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">https://www.zhihu.com/question/470049587</a><br> AsRef/Borrow/Deref的讲解</li><li><a href="https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html" target="_blank" rel="noopener">https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html</a><br> Fn FnOnce FnMut的区别</li><li><a href="https://zhuanlan.zhihu.com/p/341815515" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341815515</a><br> 对闭包的论述</li><li><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759" target="_blank" rel="noopener">https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</a><br> 对闭包的说明</li><li><a href="https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch" target="_blank" rel="noopener">https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch</a><br> Owner和&amp;mut是否可以同时修改？</li><li><a href="https://doc.rust-lang.org/cargo/reference/features.html" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/reference/features.html</a><br> 对features的论述</li><li><a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html" target="_blank" rel="noopener">https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html</a><br> TT munchers</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。&lt;/p&gt;
&lt;p&gt;本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Percolator论文阅读</title>
    <link href="http://www.calvinneo.com/2021/08/14/percolator-reading/"/>
    <id>http://www.calvinneo.com/2021/08/14/percolator-reading/</id>
    <published>2021-08-14T11:20:33.000Z</published>
    <updated>2022-10-24T11:29:22.002Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Percolator论文。</p><a id="more"></a><p>类Percolator系统的环境：</p><ol><li><p>一个KV存储<br> 在Percolator中是BigTable，在TiDB中是TiKV。<br> BigTable可以理解为下面的一个KV映射</p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">row</span><span class="symbol">:string</span>, column<span class="symbol">:string</span>, timestamp<span class="symbol">:int64</span>)-&gt;string</span><br></pre></td></tr></table></figure><p> 在Bigtable中已经提供了针对单行的跨column的事务能力。当然，对于Percolator的跨行跨表的事务，这还是不够的。</p></li><li><p>一个全局授时服务器(TSO)<br> 在Percolator中叫Timestamp Oracle。在TiDB中由PD提供。<br> 这个授时服务可以给每个事务一个全局的时间戳，从而解决时序的问题。</p></li><li><p>Client<br> 作为分布式事务的协调者。在TSO的支持下，这个协调者实现了SI的隔离级别。<br> 所以这个协调者并不是在BigTable里面的，而其他数据库的控制节点和数据节点是放到一起的。<br> Percolator里面的每个节点都会向BigTable进行读写。</p></li></ol><h1 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h1><p>在<a href="/2017/09/20/transaction/">数据库系统中的事务</a>这篇文章中介绍了快照隔离(Snapshot Isolation, SI)。<br>在实现SI时，需要记录两个时间戳，事务开始ST和事务提交CT。SI保护了WW冲突，其他事务在[ST,CT]中的写会和本事务产生冲突。</p><p>如下图所示，SI要求在ST1开始的事务，能看到所有CT2先于(因此ST2肯定也先于)自己的ST1事务的修改。<br><img src="/img/dbtrans/percolator3.png"></p><h1 id="2-2-Transactions"><a href="#2-2-Transactions" class="headerlink" title="2.2 Transactions"></a>2.2 Transactions</h1><p>因为Percolator的协调者是BigTable外部的Client，所以需要自己维护锁。锁具有replicated、distributed、balanced、persistent的要求，BigTable作为存储是支持的，所以这个锁作为meta列一同存放在BigTable的中。</p><p>其实有4个Meta列，如下图所示：</p><p><img src="/img/percolator/f5.png"></p><ol><li>lock<br> 表示一个没提交的事务正在写这个cell。包含了primary lock的位置。</li><li>write<br> 表示是已提交的数据。存放了BigTable的时间戳。</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>先来看一个Demo。Bob给Joe转账7块钱。一开始Joe有2块钱，Bob有10块钱。</p><ol><li>写<code>bal:lock</code>加锁Bob的账户，并且这个锁是primary的。此外，写了<code>bal:data</code>为3，也就是扣了7块钱的Bob。</li><li>下面加锁Joe的账户，在<code>bal:lock</code>里面写一个对Bob账户的primary锁的引用。这样在事务挂掉之后，能够知道primary lock在哪里，并且把它清理掉。</li><li>下面进入提交阶段，首先操作primary lock所在的Bob的账户。需要将<code>bal:lock</code>清理掉，<code>bal:write</code>写上对应的ST。通过这个ST就能找到实际的数据<code>bal:data</code>。<br> 在这之后，Reader们就能看到Bob账户上只有3块钱了。</li><li>下面对Secondary也进行写记录和删除锁的处理。</li></ol><p>【Q】看完Demo，有几个问题：</p><ol><li>为什么要引入primary lock？<br> 这个是为了方便进行失败回滚。当事务提交时，会清空primary lock。因此可以认为如果primary lock还在，则事务尚未提交。<br> 例如老事务挂了，留下了一片狼藉的现场。此时，一个新事务可能会访问到老事务残留的secondary lock，对应有两种情况：<ol><li>指向的primary lock还在，认为这个事务还没有提交成功。</li><li>指向的primary lock不在了，认为这个事务提交成功。那么必须先继续提交老事务。</li></ol></li><li>如果说secondary lock被清了一半，怎么办呢？<br> 没问题，后面会讲</li><li>写write列和清空lock是要原子的么？</li><li>在还没有修改Secondary时就可以访问新版本数据了，这个不破坏一致性么？<br> 同问题2</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Percolator事务的模型也是2PC，下面就分两步来看实现，其实就是对Demo的形式化。<br>整个实现是一个Transaction类，包含几个成员：</p><ol><li><p>writes_<br> 这个事务的所有写入。<code>writes_[0]</code>是primary。<br> 一个Percolator事务类似于</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DML/DQL</span><br><span class="line">...</span><br><span class="line">DML/DQL</span><br><span class="line">Prewrite</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure></li><li><p>start_ts_<br> 整个事务的ST时间戳，在事务创建时初始化。</p></li><li><p>Set<br> 往<code>writes_</code>里面加数据。</p></li><li><p>Get<br> 读</p></li><li><p>Commit<br> 提交，首先调用一阶段的Prewrite，如果全部成功，执行二阶段提交。</p></li><li><p>Prewrite<br> 一阶段，会被Commit调用。</p></li></ol><h3 id="Commit-1"><a href="#Commit-1" class="headerlink" title="Commit 1"></a>Commit 1</h3><p>Commit的前几行是封装了一阶段的Prewrite，省得用户自己去调用了：</p><ol><li>选择<code>writes_[0]</code>作为<code>primary</code>，剩余的作为<code>secondaries</code></li><li>对primary做Prewrite</li><li>对所有secondaries做Prewrite</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> <span class="function"><span class="keyword">bool</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">42</span>   Write primary = writes_[<span class="number">0</span>];</span><br><span class="line"><span class="number">43</span>   <span class="built_in">vector</span>&lt;Write&gt; secondaries(writes_.begin()+<span class="number">1</span>, writes_.end());</span><br><span class="line"><span class="number">44</span>   <span class="keyword">if</span> (!Prewrite(primary, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">45</span>   <span class="keyword">for</span> (Write w : secondaries)</span><br><span class="line"><span class="number">46</span>     <span class="keyword">if</span> (!Prewrite(w, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>【Q】先对primary进行Prewrite这个行为是必要的么？此外，在Commit 2阶段也能看到类似的现象。我们放到Commit 2这部分讲。</p><h3 id="Prewrite"><a href="#Prewrite" class="headerlink" title="Prewrite"></a>Prewrite</h3><p>传入的两个参数，primary是<code>writes_[0]</code>，primary lock会在它上面。</p><p>我们需要lock所有被写的cell，在这之前，先对于所有的cell检查下面两类冲突：</p><ol><li>【Line 32】如果发现cell的<strong>write列</strong>在自己的ST之后已经存在一条记录，执行abort<br> 这实际上是有其他事务已经提交了修改，事务write-write冲突了。根据SI，需要abort。<br> 【Q】这里有个疑问，SI不是要到提交的时候再检查冲突么？</li><li>【Line 34】如果发现cell的<strong>lock列</strong>上有另外的记录，无论timestamp是什么，执行abort<br> 有可能是一个已经提交的事务，并且它的CT比我们ST还要小，但没来得及清理锁，所以并不是冲突。<br> Percolator认为这个不常见，所以还是abort。<br> 在<a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">文章</a>中还提到可能有失败事务的情况。</li></ol><p>可以发现，检查冲突实际上就是处理write列和lock列。<br>如果没有以上两类冲突，才继续进行：</p><ol><li>【Line36】更新data列，写入ST，以及真正的值<code>w.value</code>。</li><li>【Line37】更新lock列，写入primary锁的row和col。</li></ol><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">27 </span>bool Prewrite(<span class="keyword">Write</span> w, <span class="keyword">Write</span> primary) &#123;</span><br><span class="line"><span class="symbol">28 </span>  Column c = w.col;</span><br><span class="line"><span class="symbol">29 </span>  bigtable::Txn T = bigtable::StartRowTransaction(w.row);</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="symbol">31 </span>  // Abort <span class="keyword">on</span> writes after our start timestamp . . .</span><br><span class="line"><span class="symbol">32 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"write"</span>, [start_ts_ , ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="symbol">33 </span>  // . . . <span class="keyword">or</span> locks at any timestamp.</span><br><span class="line"><span class="symbol">34 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="symbol">36 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"data"</span>, start_ts , w.value);</span><br><span class="line"><span class="symbol">37 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"lock"</span>, start_ts ,</span><br><span class="line"><span class="symbol">38 </span>     &#123;primary.row, primary.col&#125;); // The primary’s location.</span><br><span class="line"><span class="symbol">39 </span>  <span class="keyword">return</span> T.Commit();</span><br><span class="line"><span class="symbol">40 </span>&#125;</span><br></pre></td></tr></table></figure><p>接下来，进入Commit 2阶段。</p><h3 id="Commit-2"><a href="#Commit-2" class="headerlink" title="Commit 2"></a>Commit 2</h3><p>后面就是提交的第二阶段：</p><ol><li>【Line48】向TSO请求时间戳，作为CT</li><li>检查lock是否还存在<br> 【Line53】注意，根据“Failure”章节的论述，这里锁可能已经被其他事务清理了。</li><li>对于primary lock<br> 一旦primary对reader可见，说明事务提交了。<ol><li>【Line55】更新write列<br> write列中存放了ST和CT。<br> 存放ST的原因是可以通过ST找到数据，即data列。</li><li>【Line57】移除锁</li><li>【Line58】提交BigTable的行事务，这里就是所谓的commit point。</li></ol></li><li>对于所有secondary lock<ol><li>【Line62】更新write列</li><li>【Line63】移除锁</li></ol></li></ol><p>【Q】为什么在处理primary的时候就提交行事务<code>T.Commit()</code>了？先对primary进行Prewrite这个行为是必要的么？<br>原因是primary的lock列和write列是判断整个事务状态的金标准。在primary写完write、清完lock之后，就认为事务已经提交，所以就<code>T.Commit()</code>了。后面往secondary写，只是起到通知作用。<br>假如往secondary写失败了，也不会影响到整个事务的提交。因为secondary还是会将请求redirect到primary上，然后就能发现primary的已提交状态。</p><p>【Q】写write删lock是原子操作么？如果不是原子操作，它们的顺序是必然的么？是的，因为这是一个 bigtable 事务。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> bool Commit() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span>   int commit ts = oracle.GetTimestamp();</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">50</span>   // Commit primary <span class="built_in">first</span>.</span><br><span class="line"><span class="number">51</span>   Write p = primary;</span><br><span class="line"><span class="number">52</span>   bigtable::Txn T = bigtable::StartRowTransaction(p.<span class="built_in">row</span>);</span><br><span class="line"><span class="number">53</span>   <span class="keyword">if</span> (!T.Read(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, [start_ts , start_ts ]))</span><br><span class="line"><span class="number">54</span>     <span class="built_in">return</span> <span class="literal">false</span>; // aborted <span class="keyword">while</span> working</span><br><span class="line"><span class="number">55</span>   T.Write(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts,</span><br><span class="line"><span class="number">56</span>     start_ts ); // Pointer to data written <span class="built_in">at</span> start_ts .</span><br><span class="line"><span class="number">57</span>   T.Erase(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">58</span>   <span class="keyword">if</span> (!T.Commit()) <span class="built_in">return</span> <span class="literal">false</span>; // commit point</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">60</span>   // Second phase: write out write records <span class="keyword">for</span> secondary cells.</span><br><span class="line"><span class="number">61</span>   <span class="keyword">for</span> (Write w : secondaries) &#123;</span><br><span class="line"><span class="number">62</span>     bigtable::Write(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts, start_ts );</span><br><span class="line"><span class="number">63</span>     bigtable::Erase(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">64</span>   &#125;</span><br><span class="line"><span class="number">65</span>   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><p>【Q】ST和CT的关系是什么，会出现<code>ST1&lt;ST2</code>但是<code>CT1&gt;CT2</code>的情况吗？也就是说 st2 对应的更晚被启动，但是更早被提交，并且在这之前的 st1 反而在它提交之后还能成功提交？其实不会，我们考虑：<br>如果 st2 被提交，说明 st2 设置的lock，没有被清掉。从而 st2 需要能成功设置 lock。从而 st2 事务在 prewrite 时，没有 ts 大于 st2 的 write，在 [0, ∞] 没有 lock。因为 <code>st1&lt;st2</code>，所以实际要求就是在 [0, ∞] 没有 lock。那么就分为两种情况：</p><ol><li>st1 此时已经提交了，那么 ct1 肯定小于 ct2，假设不成立</li><li>st1 此时还没提交<ol><li>如果此时 st1 已经持有 lock，则 st2 不能上锁成功，假设不成立</li><li>所以此时 st1 会卡在【line 35】，一直到 st2 提交完</li></ol></li></ol><p>但这个情况成立么？其实不会，因为我们注意到 Line 39 的 <code>T.Commit()</code>，可以看出从31到38行的代码都是作为 bigtable 事务被整体提交的。</p><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>首先检查[0, ST]区间内有没有锁。<br>如果有，说明另一个事务在写，这个读取事务就要等锁被释放(也就是事务完成)后才能继续执行。注意，不能在这里返回旧数据，<a href="https://pingcap.com/zh/blog/percolator-and-txn" target="_blank" rel="noopener">否则可能导致幻读</a>。<br>【Line19】 如果没有锁，就读取最后一次写的数据<code>latest_write</code>，并且返回对应的data【Line22】。如果没有读到数据，就返回no data。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">8 </span> bool <span class="keyword">Get</span>(Row row, Column c, string* value) &#123;</span><br><span class="line"><span class="symbol">9 </span>   <span class="keyword">while</span> (true) &#123;</span><br><span class="line"><span class="symbol">10 </span>    bigtable::Txn T = bigtable::StartRowTransaction(row);</span><br><span class="line"><span class="symbol">11 </span>    // Check <span class="keyword">for</span> locks that signal concurrent writes.</span><br><span class="line"><span class="symbol">12 </span>    <span class="keyword">if</span> (T.<span class="keyword">Read</span>(row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, start_ts_])) &#123;</span><br><span class="line"><span class="symbol">13 </span>    // There is a pending lock; try <span class="keyword">to</span> clean it <span class="keyword">and</span> <span class="keyword">wait</span></span><br><span class="line"><span class="symbol">14 </span>    BackoffAndMaybeCleanupLock(row, c);</span><br><span class="line"><span class="symbol">15 </span>    continue;</span><br><span class="line"><span class="symbol">16 </span>  &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="symbol">18 </span>  // Find the latest <span class="keyword">write</span> below our start timestamp.</span><br><span class="line"><span class="symbol">19 </span>  latest_write = T.<span class="keyword">Read</span>(row, c+<span class="string">"write"</span>, [<span class="number">0</span>, start_ts_]);</span><br><span class="line"><span class="symbol">20 </span>  <span class="keyword">if</span> (!latest_write.found()) <span class="keyword">return</span> false; // no <span class="keyword">data</span></span><br><span class="line"><span class="symbol">21 </span>  <span class="keyword">int</span> <span class="keyword">data</span> ts = latest_write.start_timestamp();</span><br><span class="line"><span class="symbol">22 </span>  *value = T.<span class="keyword">Read</span>(row, c+<span class="string">"data"</span>, [data_ts, data_ts]);</span><br><span class="line"><span class="symbol">23 </span>  <span class="keyword">return</span> true;</span><br><span class="line"><span class="symbol">24 </span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h2><p>BigTable能处理自身的问题，但还需要处理Client的Failure。<br>如果在提交事务时Client挂了，Percolator需要能够清除遗留的锁，否则可能导致后续的事务被hang住。这个清除的过程是Lazy的，如果事务A在执行时遇到了事务B的冲突锁，那么A会判定事务B是否宕掉，并清除锁。</p><p>A在清除锁时，如果事务B实际并没有宕掉，而且正准备利用这个锁提交事务，会产生race。primary lock就是来解决这个问题的。因为清理或者提交事务都需要通过这个primary lock，所以事务A的清除锁和事务B的利用锁提交事务只有一个可能成功。</p><p>特别注意，在事务B提交前，需要检查lock是否还在【Line53】，然后才能写write。同理，在事务A清理前，也需要检查primary lock是否存在，如果存在，则可以安全清理掉这个primary lock(看起来挺奇怪的，如果一个锁存在，就清理掉这个锁)。</p><p>还有一种情况，当事务已经写完至少一个write列后发生崩溃，此时可能lock还没有全清理完，write可能没有全写完。此时需要roll forward这个事务。</p><p>总之，整个判断的原则就是lock有没有被write取代。</p><h3 id="Lazy-clean和Liveness"><a href="#Lazy-clean和Liveness" class="headerlink" title="Lazy clean和Liveness"></a>Lazy clean和Liveness</h3><p>因为eager clean会导致事务回滚，带来性能开销。所以只有在该事务的锁被认为是属于某个dead worker时，才会被清理。</p><h2 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h2><p>TSO(Timestamp Oracle)服务会阶段性地分配一段区间，并将这段区间的最大值持久化，剩下的时候就可以直接从内存提供服务。当TSO服务重启时，timestamp就会来到持久化了的最大值上。</p><p>为了减少TSO的压力，每个Percolator worker会batch自己的请求为一个RPC发送给TSO服务。当TSO的负载变大时，Percolator的batch大小也会变大。</p><p>Percolator的事务性要求Get()操作会返回它的ST前所有已经被提交的写。考虑一个事务R在TR读，另一个事务W在TW提交了写，且TW &lt; TR，则R能看到W的写。因为TW &lt; TR，那么TW一定在TR的batch，或者TR之前的batch中。因此可以得到下面的顺序</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W <span class="function"><span class="title">lock</span> -&gt;</span> W <span class="function"><span class="title">request</span> TW -&gt;</span> R <span class="function"><span class="title">get</span> TR -&gt;</span> R read</span><br></pre></td></tr></table></figure><p>实际上，在R读取前，W至少已经写完所有的lock了。所以R要么读到锁，要么读到已经被写完的数据。</p><p>从这里，也可以看出加锁的意义之一。考虑下面的执行顺序，如果不加锁，R就不能知道W在写。因为Commit(row1)的CT是小于Get(row)的ST的，根据SI，TR需要能读到Commit(row1)的结果。如果R不管不顾直接读了，而Commit(row1)又是在读取之后发生的，那么R实际上就读到了Commit(row1)之前的结果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction W       Transaction TR</span><br><span class="line">Prewrite(<span class="name">row1</span>)</span><br><span class="line">W request TW</span><br><span class="line">                    R get TR</span><br><span class="line">                    Get(<span class="name">row</span>) with TR</span><br><span class="line">Commit(<span class="name">row1</span>)</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li>Large-scale Incremental Processing Using Distributed Transactions and Notiﬁcations<br> Percolator论文</li><li><a href="http://mysql.taobao.org/monthly/2018/11/02/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/11/02/</a><br> 阿里数据库月报，对Percolator有较为详细的介绍</li><li><a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">https://www.jianshu.com/p/05194f4b29dd</a><br> 一个简单翻译和个人理解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍Percolator论文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="事务" scheme="http://www.calvinneo.com/tags/事务/"/>
    
  </entry>
  
  <entry>
    <title>WSL2使用的一些问题</title>
    <link href="http://www.calvinneo.com/2021/08/11/wsl2-probs/"/>
    <id>http://www.calvinneo.com/2021/08/11/wsl2-probs/</id>
    <published>2021-08-11T11:20:33.000Z</published>
    <updated>2021-08-27T09:40:23.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍WSL2使用的一些问题</p><a id="more"></a><h1 id="Windows-Store相关"><a href="#Windows-Store相关" class="headerlink" title="Windows Store相关"></a>Windows Store相关</h1><h2 id="打不开？"><a href="#打不开？" class="headerlink" title="打不开？"></a>打不开？</h2><p>通常是代理问题。除了网上通用的方案，还需要在“Internet属性-局域网(LAN)设置”中关闭代理。</p><h1 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h1><h2 id="打不开Shell"><a href="#打不开Shell" class="headerlink" title="打不开Shell"></a>打不开Shell</h2><p>具体表现为找不到<code>\\wsl$</code>这个位置，执行<code>wsl</code>或者<code>wsl -l -l</code>无响应。<br>解决方案是彻底重启，也就是按住Shift点关机键。</p><h2 id="与Github交互"><a href="#与Github交互" class="headerlink" title="与Github交互"></a>与Github交互</h2><p>不需要共享宿主的SshKey，直接生成自己的，并且加到Github里面。</p><h2 id="支持多版本GCC"><a href="#支持多版本GCC" class="headerlink" title="支持多版本GCC"></a>支持多版本GCC</h2><p>因为默认的Ubuntu 20是用的GCC-9，如果我们要更低版本的GCC，就需要</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-<span class="number">7</span> g++-<span class="number">7</span></span><br><span class="line">sudo update-alternatives --install <span class="regexp">/usr/</span>bin<span class="regexp">/gcc gcc /u</span>sr<span class="regexp">/bin/g</span>cc-<span class="number">7</span> <span class="number">70</span> --slave <span class="regexp">/usr/</span>bin<span class="regexp">/g++ g++ /u</span>sr<span class="regexp">/bin/g</span>++-<span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="内存占用问题"><a href="#内存占用问题" class="headerlink" title="内存占用问题"></a>内存占用问题</h2><p>为什么我的Vmmem占用内存这么大？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="comment">--shutdown</span></span><br><span class="line">wsl <span class="comment">--terminate Ubuntu</span></span><br></pre></td></tr></table></figure><p>创建一个<code>%UserProfile%\.wslconfig</code>来控制用量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">processors</span>=<span class="number">8</span></span><br><span class="line"><span class="attr">memory</span>=<span class="number">8</span>GB</span><br><span class="line"><span class="attr">swap</span>=<span class="number">8</span>GB</span><br><span class="line"><span class="attr">localhostForwarding</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>也可以清理</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -<span class="keyword">c</span> <span class="string">"echo 3 &gt; /proc/sys/vm/drop_caches"</span></span><br></pre></td></tr></table></figure><p>或者定时清理</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="string">/15</span> * * * * sync; <span class="keyword">echo</span> 3 &gt; <span class="string">/proc/sys/vm/drop_caches</span>; touch <span class="string">/root/drop_caches_last_run</span></span><br></pre></td></tr></table></figure><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a><br> WSL2的官方文档</li><li><a href="https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/</a><br> 共享SSH的问题</li><li><a href="https://blog.csdn.net/fengke549015/article/details/106397903" target="_blank" rel="noopener">https://blog.csdn.net/fengke549015/article/details/106397903</a><br> WSL2定时清理内存</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍WSL2使用的一些问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="WSL2" scheme="http://www.calvinneo.com/tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>Raft的TLA+验证介绍</title>
    <link href="http://www.calvinneo.com/2021/07/28/raft-tla/"/>
    <id>http://www.calvinneo.com/2021/07/28/raft-tla/</id>
    <published>2021-07-28T15:20:37.000Z</published>
    <updated>2021-08-18T07:28:00.813Z</updated>
    
    <content type="html"><![CDATA[<p>介绍使用TLA+对Raft的验证工作。</p><p><a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla" target="_blank" rel="noopener">Ongaro等已经在Github上提供了一版TLA+的实现</a></p><a id="more"></a><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>容易发现，源码里面不包含TLC的Config，但是我们在<a href="https://github.com/ongardie/raft.tla/issues/1" target="_blank" rel="noopener">Issue 1</a>里面能找到一个。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS<span class="built_in"> Server </span>= &#123;r1,r2,r3&#125;</span><br><span class="line">          Value = &#123;v1,v2&#125;</span><br><span class="line">          Follower = Follower</span><br><span class="line">          Candidate = Candidate</span><br><span class="line">          Leader = Leader</span><br><span class="line">          <span class="literal">Nil</span> = <span class="literal">Nil</span></span><br><span class="line">          RequestVoteRequest = RequestVoteRequest</span><br><span class="line">          RequestVoteResponse = RequestVoteResponse</span><br><span class="line">          AppendEntriesRequest = AppendEntriesRequest</span><br><span class="line">          AppendEntriesResponse = AppendEntriesResponse</span><br><span class="line">          TLC_MAX_TERM = 3</span><br><span class="line">          TLC_MAX_ENTRY = 1</span><br><span class="line">          TLC_MAX_MESSAGE = 1</span><br><span class="line">\*          PNat = &#123;1,2,3,4,5&#125;</span><br><span class="line">\*         <span class="built_in"> Nat </span>= &#123;0,1,2,3,4,5&#125;</span><br><span class="line">\*SYMMETRY Perms</span><br><span class="line">SPECIFICATION Spec</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT TermConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT LogConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT MessageConstraint</span><br><span class="line">\*INVARIANT AtMostOneLeaderPerTerm</span><br><span class="line">\*INVARIANT TermAndIndexDeterminesLogPrefix</span><br><span class="line">\*INVARIANT StateMachineSafety</span><br><span class="line">\*INVARIANT NewLeaderHasCompleteLog</span><br><span class="line">\*INVARIANT CommitInOrder</span><br><span class="line"></span><br><span class="line">\*INVARIANT MessageTypeInv</span><br><span class="line">\*INVARIANT TypeInv</span><br></pre></td></tr></table></figure><p>需要限制一下Model</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: Len(log[i]) =&lt; maxLength</span><br><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: currentTerm[i] =&lt; maxTerm</span><br><span class="line">/\ Cardinality(DOMAIN messages) =&lt; maxMessage</span><br><span class="line">/\ restartNum =&lt; maxRestartNum</span><br><span class="line">/\ timeoutNum =&lt; maxTimeoutNum</span><br><span class="line">/\ actionNum =&lt; maxActionNum</span><br></pre></td></tr></table></figure><p>timeoutNum必须至少为1，不然不能触发选举</p><p>列出一下Safety条件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneLeader == Cardinality( &#123;i \<span class="keyword">in</span><span class="built_in"> Server </span>: state[i] = Leader&#125; ) &lt;= 1</span><br></pre></td></tr></table></figure><p>注意如下错误</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The subscript <span class="keyword">of</span> <span class="keyword">the</span> next-state relation specified <span class="keyword">by</span> <span class="keyword">the</span> specification</span><br><span class="line">does <span class="keyword">not</span> seem <span class="built_in">to</span> contain <span class="keyword">the</span> state <span class="built_in">variable</span> xxx</span><br></pre></td></tr></table></figure><p>看看xxx是不是在vars里面</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars</span><br></pre></td></tr></table></figure><p>打印语句</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Print</span><span class="params">(内容, Print语句的值)</span></span></span><br></pre></td></tr></table></figure><p>发现maxMessage必须为1，其他都可以变。</p><h1 id="总体模型"><a href="#总体模型" class="headerlink" title="总体模型"></a>总体模型</h1><h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>下面的变量是全局的：</p><ol><li><p>messages<br> 表示从一个Server发送到另一个Server的消息。因为TLAPS不支持Bags模块(也就是所谓的multiset)，所以这是一个将消息映射为Nat的<strong>函数</strong>。<br> 通过<code>WithMessage(m, msgs)</code>往<code>messages</code>添加一条消息，其中<code>m</code>是我们需要发送的消息，<code>msgs</code>就是<code>messages</code>这个变量。</p> <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WithMessage(m, msgs) ==</span><br><span class="line"><span class="keyword">IF</span> m \<span class="keyword">in</span> DOMAIN msgs <span class="keyword">THEN</span></span><br><span class="line">    [msgs <span class="keyword">EXCEPT</span> ![m] = msgs[m] + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    msgs @@ (m :&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 消息的格式如下图所示</p> <figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">mtype</span>         |-&gt; RequestVoteRequest,</span><br><span class="line"> mterm         |-&gt; currentTerm[<span class="name">i</span>],</span><br><span class="line"> mlastLogTerm  |-&gt; LastTerm(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> mlastLogIndex |-&gt; Len(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> msource       |-&gt; i,</span><br><span class="line"> mdest         |-&gt; j]</span><br></pre></td></tr></table></figure></li><li><p>elections<br> 仅在证明(proof)中需要，实现(implementation)并不需要。<br> 这个用来记录所有成功的选举。包括Leader和Voter的日志。其中一个元素类似下面。</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;[ <span class="function"><span class="title">eterm</span>     |-&gt;</span> currentTerm[i],</span><br><span class="line">   <span class="function"><span class="title">eleader</span>   |-&gt;</span> i,</span><br><span class="line">   <span class="function"><span class="title">elog</span>      |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">   <span class="function"><span class="title">evotes</span>    |-&gt;</span> votesGranted[i],</span><br><span class="line">   <span class="function"><span class="title">evoterLog</span> |-&gt;</span> voterLog[i]]&#125;</span><br></pre></td></tr></table></figure></li><li><p>allLogs<br> 同样仅在证明中需要。<br> 集合了每个Server上的日志</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="literal">all</span>Logs' = <span class="literal">all</span>Logs \cup &#123;<span class="keyword">log</span>[i] : i \<span class="keyword">in</span> Server&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下面的变量是Per Server的：</p><ol><li><p>serverVars<br> 为<code>&lt;&lt;currentTerm, state, votedFor&gt;&gt;</code><br> 在Init中，currentTerm初始化为1，state初始化为Follower，voteFor初始化为Nil。</p></li><li><p>logVars<br> 为<code>&lt;&lt;log, commitIndex&gt;&gt;</code><br> 其中log是A Sequence of log entries，<code>log[i]</code>表示Server i上的日志。<br> 在Init中，log初始化为</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log = [i \<span class="keyword">in</span><span class="built_in"> Server </span>|-&gt; &lt;&lt; &gt;&gt;]</span><br></pre></td></tr></table></figure><p> 每个Log Entry的格式是</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[term  |-&gt; currentTerm[i],</span><br><span class="line"> value |-&gt; v]</span><br></pre></td></tr></table></figure><p> commitIndex初始化为0。</p></li><li><p>candidateVars<br> 为<code>&lt;&lt;votesResponded, votesGranted, voterLog&gt;&gt;</code></p></li><li><p>leaderVars<br> 为<code>&lt;&lt;nextIndex, matchIndex, elections&gt;&gt;</code><br> 在Init中，nextIndex全部被初始化为1，matchIndex全部被初始化为0。</p></li></ol><h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>Quorum实际上是一个集合的集合。表示Server中所有可以形成Quorum的子集。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quorum == &#123;i \<span class="keyword">in</span> SUBSET(<span class="built_in">Server</span>) : Cardinality(i) * <span class="number">2</span> &gt; Cardinality(<span class="built_in">Server</span>)&#125;</span><br></pre></td></tr></table></figure><h1 id="周边Action"><a href="#周边Action" class="headerlink" title="周边Action"></a>周边Action</h1><h2 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a>Spec</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Next == /<span class="symbol">\ </span><span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Restart(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Timeout(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : RequestVote(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : BecomeLeader(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server, v <span class="symbol">\i</span>n Value : ClientRequest(i, v)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : AdvanceCommitIndex(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : AppendEntries(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : Receive(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DuplicateMessage(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DropMessage(m)</span><br><span class="line">           <span class="symbol">\*</span> History variable that tracks every log ever:</span><br><span class="line">        /<span class="symbol">\ </span>allLogs' = allLogs <span class="symbol">\c</span>up &#123;log[i] : i <span class="symbol">\i</span>n Server&#125;</span><br></pre></td></tr></table></figure><h1 id="主要Acttion"><a href="#主要Acttion" class="headerlink" title="主要Acttion"></a>主要Acttion</h1><h2 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h2><p>Enabling条件，就是自己是Leader，并且不能自己给自己发消息。<br><code>SubSeq(s,m,n)</code>表示<code>&lt;&lt; s[m], s[m+1], ..., s[n] &gt;&gt;</code></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AppendEntries(i, j) ==</span><br><span class="line">    /\ i /= j</span><br><span class="line">    /\ state[i] = Leader</span><br><span class="line">    /\ LET prevLogIndex == nextIndex[i][j] - <span class="number">1</span></span><br><span class="line">           prevLogTerm == IF prevLogIndex &gt; <span class="number">0</span> THEN</span><br><span class="line">                              <span class="built_in">log</span>[i][prevLogIndex].term</span><br><span class="line">                          ELSE</span><br><span class="line">                              <span class="number">0</span></span><br><span class="line">           \* Send up to <span class="number">1</span> entry, constrained <span class="keyword">by</span> the end of the <span class="built_in">log</span>.</span><br><span class="line">           lastEntry == Min(&#123;Len(<span class="built_in">log</span>[i]), nextIndex[i][j]&#125;)</span><br><span class="line">           entries == SubSeq(<span class="built_in">log</span>[i], nextIndex[i][j], lastEntry)</span><br><span class="line">       IN S<span class="function"><span class="title">end</span>([mtype          |-&gt;</span> AppendEntriesRequest,</span><br><span class="line">                <span class="function"><span class="title">mterm</span>          |-&gt;</span> currentTerm[i],</span><br><span class="line">                <span class="function"><span class="title">mprevLogIndex</span>  |-&gt;</span> prevLogIndex,</span><br><span class="line">                <span class="function"><span class="title">mprevLogTerm</span>   |-&gt;</span> prevLogTerm,</span><br><span class="line">                <span class="function"><span class="title">mentries</span>       |-&gt;</span> entries,</span><br><span class="line">                \* mlog <span class="keyword">is</span> used <span class="keyword">as</span> a history variable <span class="keyword">for</span> the proof.</span><br><span class="line">                \* It would <span class="built_in">not</span> exist <span class="built_in">in</span> a <span class="keyword">real</span> implementation.</span><br><span class="line">                <span class="function"><span class="title">mlog</span>           |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">                <span class="function"><span class="title">mcommitIndex</span>   |-&gt;</span> Min(&#123;commitIndex[i], lastEntry&#125;),</span><br><span class="line">                <span class="function"><span class="title">msource</span>        |-&gt;</span> i,</span><br><span class="line">                <span class="function"><span class="title">mdest</span>          |-&gt;</span> j])</span><br><span class="line">    /\ UNCHANGED <span class="string">&lt;&lt;serverVars, candidateVars, leaderVars, logVars&gt;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对端处理AppendEntries"><a href="#对端处理AppendEntries" class="headerlink" title="对端处理AppendEntries"></a>对端处理AppendEntries</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">HandleAppendEntriesRequest</span><span class="params">(i, j, m)</span></span> ==</span><br><span class="line">    LET logOk == \/ m<span class="selector-class">.mprevLogIndex</span> = <span class="number">0</span></span><br><span class="line">                 \/ /\ m<span class="selector-class">.mprevLogIndex</span> &gt; <span class="number">0</span></span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogIndex</span> &lt;= Len(log[i])</span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogTerm</span> = log[i][m.mprevLogIndex].term</span><br><span class="line">    IN /\ m<span class="selector-class">.mterm</span> &lt;= currentTerm[i]</span><br></pre></td></tr></table></figure><p>下面处理分为三个部分：<br>拒绝</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">       <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\*</span> reject request</span><br><span class="line">                <span class="string">\/</span> m.mterm &lt; currentTerm[i]</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">                   /<span class="string">\</span> state[i] = Follower</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\lnot</span> logOk</span><br><span class="line">             /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                       mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                       msuccess        |<span class="function">-&gt;</span> FALSE,</span><br><span class="line">                       mmatchIndex     |<span class="function">-&gt;</span> <span class="number">0</span>,</span><br><span class="line">                       msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                       mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                       m)</span><br><span class="line">             /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, logVars&gt;&gt;</span><br></pre></td></tr></table></figure><p>切换为Follower</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          \/ \* return <span class="keyword">to</span> follower <span class="keyword">state</span></span><br><span class="line">             /\ m.mterm = currentTerm[i]</span><br><span class="line">             /\ <span class="keyword">state</span>[i] = Candidate</span><br><span class="line">             /\ <span class="keyword">state</span>' = [<span class="keyword">state</span> EXCEPT ![i] = Follower]</span><br><span class="line">             /\ UNCHANGED <span class="variable">&lt;&lt;currentTerm, votedFor, logVars, messages&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>接受</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          <span class="string">\/</span> <span class="string">\*</span> accept request</span><br><span class="line">             /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">             /<span class="string">\</span> state[i] = Follower</span><br><span class="line">             /<span class="string">\</span> logOk</span><br><span class="line">             /<span class="string">\</span> LET index == m.mprevLogIndex + <span class="number">1</span></span><br><span class="line">                IN <span class="string">\/</span> <span class="string">\*</span> already done <span class="keyword">with</span> request</span><br><span class="line">                       <span class="regexp">/\ \/</span> m.mentries = &lt;&lt; &gt;&gt;</span><br><span class="line">                          <span class="string">\/</span> <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                             /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                             /<span class="string">\</span> log[i][index].term = m.mentries[<span class="number">1</span>].term</span><br><span class="line">                          <span class="string">\*</span> This could make our commitIndex decrease (<span class="keyword">for</span></span><br><span class="line">                          <span class="string">\*</span> example <span class="keyword">if</span> we process an old, duplicated request),</span><br><span class="line">                          <span class="string">\*</span> but <span class="literal">that</span> doesn<span class="string">'t really affect anything.</span></span><br><span class="line"><span class="string">                       /\ commitIndex'</span> = [commitIndex EXCEPT ![i] =</span><br><span class="line">                                              m.mcommitIndex]</span><br><span class="line">                       /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                                 mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                                 msuccess        |<span class="function">-&gt;</span> TRUE,</span><br><span class="line">                                 mmatchIndex     |<span class="function">-&gt;</span> m.mprevLogIndex +</span><br><span class="line">                                                     Len(m.mentries),</span><br><span class="line">                                 msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                                 mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                                 m)</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, log&gt;&gt;</span><br><span class="line">                   <span class="string">\/</span> <span class="string">\*</span> conflict: remove <span class="number">1</span> entry</span><br><span class="line">                       <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                       /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                       <span class="regexp">/\ log[i][index].term /</span>= m.mentries[<span class="number">1</span>].term</span><br><span class="line">                       /<span class="string">\</span> LET <span class="keyword">new</span> == [index2 <span class="string">\in</span> <span class="number">1.</span>.(Len(log[i]) - <span class="number">1</span>) |<span class="function">-&gt;</span></span><br><span class="line">                                          log[i][index2]]</span><br><span class="line">                          IN log<span class="string">' = [log EXCEPT ![i] = new]</span></span><br><span class="line"><span class="string">                       /\ UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span></span><br><span class="line"><span class="string">                   \/ \* no conflict: append entry</span></span><br><span class="line"><span class="string">                       /\ m.mentries /= &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="string">                       /\ Len(log[i]) = m.mprevLogIndex</span></span><br><span class="line"><span class="string">                       /\ log'</span> = [log EXCEPT ![i] =</span><br><span class="line">                                      Append(log[i], m.mentries[<span class="number">1</span>])]</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span><br><span class="line">       /<span class="string">\</span> UNCHANGED &lt;&lt;candidateVars, leaderVars&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="AppendEntries处理对端返回"><a href="#AppendEntries处理对端返回" class="headerlink" title="AppendEntries处理对端返回"></a>AppendEntries处理对端返回</h2><h2 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla</a><br> Raft的Membership Change证明</li><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla</a><br> 一个带有很多Inv的Raft的TLA+</li><li><a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla" target="_blank" rel="noopener">https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla</a><br> Sequences扩展</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍使用TLA+对Raft的验证工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ongardie/raft.tla/blob/master/raft.tla&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ongaro等已经在Github上提供了一版TLA+的实现&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="raft" scheme="http://www.calvinneo.com/tags/raft/"/>
    
    <category term="TLA" scheme="http://www.calvinneo.com/tags/TLA/"/>
    
    <category term="形式验证" scheme="http://www.calvinneo.com/tags/形式验证/"/>
    
  </entry>
  
  <entry>
    <title>TLA用法</title>
    <link href="http://www.calvinneo.com/2021/06/26/tla/"/>
    <id>http://www.calvinneo.com/2021/06/26/tla/</id>
    <published>2021-06-26T15:20:37.000Z</published>
    <updated>2021-12-16T06:57:01.003Z</updated>
    
    <content type="html"><![CDATA[<p>介绍TLA+用法。<br>TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。<br>TLC是TLA+的模型检验工具。</p><a id="more"></a><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>Module，是我们写TLA+ Specification的地方。<br>Model，是我们用TLC检验我们TLA+ Module的地方。</p><h2 id="Model-Value"><a href="#Model-Value" class="headerlink" title="Model Value"></a>Model Value</h2><p>在”What is the model?”中。</p><h2 id="模型-Model-行为"><a href="#模型-Model-行为" class="headerlink" title="模型(Model)行为"></a>模型(Model)行为</h2><p>在”What is the behavior spec?”中。</p><ol><li><p>Ordinary assignment<br> 例如</p> <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RM &lt;- &#123;<span class="string">"r1"</span>, <span class="string">"r2"</span>, <span class="string">"r3"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Model value</p></li><li><p>Set of model values<br> 例如</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RM</span> &lt;- &#123;<span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="built_in">r3</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查项目"><a href="#检查项目" class="headerlink" title="检查项目"></a>检查项目</h2><p>在”What to Check”中：</p><ol><li>Invariants<br> 例如各种Spec</li><li>Properties<br> 例如Termination</li></ol><h2 id="TLC-Option"><a href="#TLC-Option" class="headerlink" title="TLC Option"></a>TLC Option</h2><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>创建一个Spec，写入我们要计算的函数。<br>新建一个Module，设置”What is the behavior spec?”为”No Behavior Spec”。<br>在”Evaluate Constant Expression”中，对我们要计算的函数带入具体值。</p><h2 id="从命令行执行"><a href="#从命令行执行" class="headerlink" title="从命令行执行"></a>从命令行执行</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tlc2<span class="selector-class">.TLC</span> -config .\TESpecSafetyTest<span class="selector-class">.cfg</span> -workers <span class="number">4</span> -dfid <span class="number">10</span> .\TESpecTest.tla</span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h2><ol><li><code>\/</code><br> 表示or。</li><li><code>/\</code><br> 表示and。</li><li><code>\A x \in S: P(x)</code><br> <strong>对于任意的</strong>S中的x，满足<code>P(x)</code>。</li><li><code>\E x \in S: P(x)</code><br> S中<strong>存在</strong>某个x，满足<code>P(x)</code>。<br> 注意，一般会用<code>\E</code>来表示<strong>选择任意一个</strong>元素进行操作的语义。如下所示，我们在<code>AtoB</code>中移除任意一个位置的元素。因此我们进一步能看到，TLA并不是命令式的，而是描述式的。 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\E i \<span class="keyword">in</span> <span class="number">1</span>..Len(A<span class="keyword">to</span>B): A<span class="keyword">to</span>B' = Remove(i, A<span class="keyword">to</span>B)</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数-映射部分"><a href="#函数-映射部分" class="headerlink" title="函数/映射部分"></a>函数/映射部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>函数通常用中括号括起来。</p><ol><li><p><code>F == [x \in S |-&gt; e]</code><br> 对S中的元素应用e，类似于mapper。<br> 函数的执行结果是一个tuple，例如下面函数的结果是<code>&lt;&lt;2, 3&gt;&gt;</code></p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i \in <span class="number">1.</span><span class="number">.2</span> |-&gt; i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>F[x \in S] == e</code></p></li><li><p><code>[S -&gt; T]</code><br> 表示了从S到T的<strong>一系列</strong>函数。<br> <a href="https://learntla.com/tla/functions/" target="_blank" rel="noopener">例如</a>，对于People中的p和Animals中的a，p对a可能like或者hate，我们可以写成下面的形式</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P<span class="function"><span class="title">ref</span> == [People -&gt;</span> [A<span class="function"><span class="title">nimals</span> -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [[person: People, animal: Animals] -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [People \X Animals -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br></pre></td></tr></table></figure><p> 需要区别<code>|-&gt;</code>和<code>-&gt;</code>，前者表示是从DOMAIN到某个特定的RANGE的<strong>一个函数</strong>，后者表示从DOMAIN到RANGE的一系列函数。</p></li><li><p><code>[S EXCEPT ![x] = v]</code><br> 这个语句通常用来表示返回整个集合，但是对集合中的某个特定元素的值进行变化。<br> 如果S是一个集合，表示返回S，除了x等于v。<br> 如果S是一个Record（类似于C里面的struct），表示返回S，除了x等于v。例如</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f EXCEPT !.prof = <span class="string">"RED"</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>@@</code>和<code>:&gt;</code><br> 这两个符号用来定义函数。例如函数定义域是<code>{1,2}</code>，我们可以这么定义<code>f</code></p> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>:&gt; <span class="string">"ab"</span> @@ <span class="number">2</span> :&gt; <span class="string">"cd"</span></span><br></pre></td></tr></table></figure></li><li><p><code>@</code><br> <code>f&#39; = [f EXCEPT ![e1] = f[e1] + 1</code>中，我们就可以写成<code>f&#39; = [f EXCEPT ![e1] = @ + 1]</code></p></li><li><p>直接在集合间映射<br> 例如</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS People, Animals</span><br><span class="line">Pref == [person: People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[<span class="function"><span class="title">person</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>], [person |-&gt;</span> neo]&#125;</span><br></pre></td></tr></table></figure><p> 又例如</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Pref</span> == [People -&gt; People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; (<span class="name">calvin</span> <span class="symbol">:&gt;</span> calvin @@ neo <span class="symbol">:&gt;</span> calvin),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> calvin @@ neo <span class="symbol">:&gt;</span> neo),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> neo @@ neo <span class="symbol">:&gt;</span> calvin),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> neo @@ neo <span class="symbol">:&gt;</span> neo) &#125;</span><br></pre></td></tr></table></figure><p> 又例如</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pref == [<span class="string">message:</span> &#123;<span class="string">"Hello"</span>&#125;, <span class="string">src:</span>People, <span class="string">dst:</span>People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>, dst |-&gt;</span> <span class="function"><span class="title">calvin</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>, dst |-&gt;</span> <span class="function"><span class="title">neo</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">neo</span>, dst |-&gt;</span> <span class="function"><span class="title">calvin</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">neo</span>, dst |-&gt;</span> <span class="function"><span class="title">neo</span>, message |-&gt;</span> <span class="string">"Hello"</span>] &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合-元组-Record部分"><a href="#集合-元组-Record部分" class="headerlink" title="集合/元组/Record部分"></a>集合/元组/Record部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>此外，在第339页开始会介绍标准模块，如Sequences、Bags等。</p><ol><li><p>Record<br> Record类似于C++里面的struct。<br> 如何表示一个Record的实例？</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function"><span class="title">type</span> |-&gt;</span> <span class="string">"Prepared"</span>, <span class="function"><span class="title">rm</span> |-&gt;</span> r]</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;&lt;&quot;a&quot;, 42, {1,2}&gt;&gt;</code><br> 表示一个tuple，在P09a中也被Lamport称为Finite sequence。<br> tuple从1编号。</p></li><li><p><code>{1,2,3}</code><br> 表示一个Set。</p></li><li><p>Tuple简单运算符<br> Head和Tail类似于car和cdr。<br> <code>\o</code>表示concat。如果<code>seq /= &lt;&lt;&gt;&gt;</code>，有<code>seq = &lt;&lt;Head(seq)&gt;&gt; \o Tail(seq)</code>。<br> <code>Append(tuple,elem)</code>表示将elem放到tuple的末尾。<br> <code>Len</code>，返回长度。<br> <code>Remove(i, seq)</code>表示从<code>seq</code>移除<code>i</code>位置的元素之后的新seq。<br> <code>\X</code>表示计算笛卡尔积。<br> Seq表示所有由这个tuple中元素构成的序列。例如<code>Seq({2})</code>是<code>{&lt;&lt;&gt;&gt;,&lt;&lt;3&gt;&gt;, &lt;&lt;3,3&gt;&gt;, &lt;&lt;3,3,3&gt;&gt;, ...}</code>。我们可以进行下面的实验</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br><span class="line">&lt;&lt;<span class="number">2</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>Set运算符<br> <code>SUBSET(S)</code>求出所有子集，例如<code>SUBSET( {1,2,3} )</code>返回</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; &#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p> <code>Cardinality(S)</code>计算一个集合的大小。<br> <code>IsFiniteSet(S)</code>计算一个集合是不是有限集。</p></li><li><p><code>DOMAIN &lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;</code><br> 表示一个集合。Lamport说Math中的DOMAIN，对应于Progamming中的Index Set。</p></li><li><p><code>&lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;[2]</code><br> 表示集合中的第2个元素，即<code>&quot;b&quot;</code>。</p></li><li><p>“构造函数”<code>{e: v \in S}</code><br> 对S中的元素应用e，类似于mapper。<br> 需要区别<code>|-&gt;</code>和<code>:</code>：</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">Rem(i, seq) == [j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span> |-&gt; IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>]</span><br><span class="line">RemSet(i, seq) == &#123;(IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>) : j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>“构造函数”<code>{v \in S: P}</code><br> 类似一个filter。</p></li><li><p><code>UNCHANGED &lt;&lt;x,y&gt;&gt;</code><br> 是一个语法糖，可以理解为</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="string">\</span> x<span class="string">' = x</span></span><br><span class="line"><span class="string">/\ y'</span> = y</span><br></pre></td></tr></table></figure></li><li><p><code>CHOOSE v \in S: P</code><br> 在S中满足P的元素中任选一个v。注意这个CHOOSE是没有随机性的，我们比较</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\E <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : x' = <span class="built_in">i</span></span><br><span class="line">x' = CHOOSE <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : TRUE</span><br></pre></td></tr></table></figure><p> 上面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间任意一个数。<br> 下面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间某个特定的数。<br> CHOOSE主要用法是：S中只有一个v满足P，比如最大值最小值等，我们将这个v取出来。所以一般CHOOSE和TRUE这个Predicate不会连用。<br> 下面，我们通过CHOOSE计算在一段区间中的最大质数。可以在模型中执行<code>LargestPrime(1..1000)</code>，得到结果997。</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">IsPrime(x) == x &gt; <span class="number">1</span> /<span class="string">\</span> ~<span class="string">\E</span> d <span class="string">\in</span> <span class="number">2.</span>.(x-<span class="number">1</span>) : x % d = <span class="number">0</span></span><br><span class="line">LargestPrime(S) == CHOOSE x <span class="string">\in</span> S:</span><br><span class="line">                    /<span class="string">\</span> IsPrime(x)</span><br><span class="line">                    /<span class="string">\</span> <span class="string">\A</span> y <span class="string">\in</span> S:</span><br><span class="line">                        IsPrime(y) =&gt; y &lt;= x</span><br></pre></td></tr></table></figure></li></ol><h2 id="Expression-Spec部分"><a href="#Expression-Spec部分" class="headerlink" title="Expression/Spec部分"></a>Expression/Spec部分</h2><ol><li><p>IF-THEN-ELSE</p></li><li><p>Enabling condition<br> 这是一个概念，例如下面式子中，第一个式子就是enabling condition，因为它并没有涉及下一个状态<code>rmState&#39;</code></p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DecideC(r) == /\ rmState<span class="string">[r]</span> = <span class="string">"prepared"</span></span><br><span class="line">              /\ rmState' = <span class="string">[rmState EXCEPT ![r]</span> = <span class="string">"committed"</span>]</span><br></pre></td></tr></table></figure><p> 如果在state s时满足了这些Enabling条件，则A被enabled，且<code>s-&gt;t</code>是一个A step。</p></li><li><p>Constant expression</p></li><li><p>State expression<br> 能够包含所有Constant expression能够包含的元素。此外，还能包含声明了的变量。<br> 需要注意的还是，在P08b里面，Lamport说一个State表示给variable进行赋值。这里的variable表示所有可能的variable，而不是被定义出来的variable。我觉得实际在说在一个formula里面，如果没有提到其他变量，并不代表不存在其他变量。<br> State的值取决于变量的值。</p></li><li><p>Action expression<br> 能够包含所有State expression能够包含的元素。此外，还能包含<code>&#39;</code>和<code>UNCHANGED</code>。<br> 一个State expression是一个Action expression，它在一个step<code>s-&gt;t</code>上具有一个值，这个值只取决于s。<br> 这里step表示一对状态之间的切换。例如，state s是<code>p &lt;- 42</code>，state t是<code>q &lt;- 24</code>，那么<code>p-q&#39;</code>在step<code>s-&gt;t</code>上具有值<code>42-24</code>。</p></li><li><p>THEOREM<br> 对于一个Temporal formula，<code>THEOREM TF</code>表示<code>TF</code>在每个可能行为下，都是true。<br> 例如下面的THEOREM表示对于每一个behavior，如果<code>TPSpec</code>是true（也就是这个behavior满足TPSpec的条件），那么<code>[]TPTypeOK</code>也是true（也就是对于这个bahavior下的每个state都是true）。</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM TPSpec =&gt; <span class="string">[]</span>TPTypeOK</span><br></pre></td></tr></table></figure><p> 我们进一步理解为，<code>TPTypeOK</code>是关于<code>TpSpec</code>的不变量。<br> 我们还可以说<code>TPSpec</code>实现(implement)了<code>[]TPTypeOK</code>。<br> 为了检查这个THEOREM，有两种方案：</p><ol><li>将<code>[]TPTypeOK</code>/<code>TPSpec</code>加入”<strong>What to check?</strong>“下面的<strong>Properties</strong>中。</li><li>将<code>TPTypeOK</code>加入”<strong>What to check?</strong>“下面的<strong>Invariants</strong>中。</li></ol></li><li><p>Behavior </p></li><li><p>Temporal(时序的) formula<br> 一般写成<code>Spec == Init /\ []Next</code>。<br> 在学习TCommit的时候，我们都是在Module标签页里面”Initial predicate and next-state relation”这个标签里面指定Init和Next的，现在<strong>可以直接在Temporal formula标签里面</strong>直接填我们的Spec了。</p></li><li><p>Stuttering steps<br> 在Temporal formula中，会见到下面的写法，在<code>TCNext</code>周围包围了中括号：</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[]</span><span class="string">[TCNext]</span>_rmState</span><br></pre></td></tr></table></figure><p> 它等价于下面的形式，也就是说满足TCNext，或者保持rmState不变。后者称为stuttering steps。</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TCNext</span> \/ (UNCHANGED rmState)</span><br></pre></td></tr></table></figure><p> 因此，一个常见的Temporal formula写法可以是</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>Stuttering steps和Termination<br> 一个有无限长的Stuttering steps作为结尾的behavior是一个Terminating execution。<br> 这个是容易理解的，在我们的系统停止之后，地球还是照转不误的。所以所有的behavior都是无限长的state构成的序列。</p></li><li><p>May和Must<br> 我觉得这是一个贯穿的思想，也就是Lamport反复强调TLA+是一个数学的，而不是命令的东西。<br> Spec中的主体部分都是May部分，规定了系统可能做什么，而不是必须做什么。可以加入<code>L</code>，作为Must部分</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>L</span><br></pre></td></tr></table></figure><p> 一个Safety Formula断言May发生的事件。<br> 一个Liveness Formula断言Must发生的事件。这表示在任何时候都不能违反的条件。</p></li><li><p><code>[]</code>和<code>~&gt;</code><br> 对于顺序执行的程序来说，只需要满足能够最终终止就行了。这里最终表示为<code>&lt;&gt;</code>。关于<code>&lt;&gt;</code>，有下面的关系</p> <figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;<span class="keyword">P</span> == ~[]~<span class="keyword">P</span></span><br></pre></td></tr></table></figure><p> <code>~&gt;</code>表示lead to。对于ABSpec来说，它的Liveness property是</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li><li><p>Fairness<br> Weak Fairness指，如果Action A持续(continuouesly) enabled（enabled定义见下面），那么一个A step会最终发生。也就是说，下图中的绿色部分一定会发生一个A step。<br> <img src="/img/tla/wf.png"><br> Weak Fairness使用下面的格式，其中vars是这个Spec中涉及的所有变量。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">WF_vars</span><span class="params">(A)</span></span></span><br></pre></td></tr></table></figure><p> 容易看出，Weak Fairness是一个Liveness property。因为它在A step或者A没有被enabled的时候，都是true。<br> 对应的，还有Strong Fairness，如果Action A重复地(repeatedly) enabled，那么一个A step会最终发生。<br> 因此，我们可以总结得到具有Liveness的Spec的格式。其中Fairness是<code>WF_vars(A)</code>和<code>SF_vars(A)</code>的组合，其中A是Next的之动作。</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>Fairness</span><br></pre></td></tr></table></figure><p> 即</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars /<span class="tag">\<span class="name"> </span></span>WF_vars(Next)</span><br></pre></td></tr></table></figure><p> 在检查Liveness条件时，不能使用symmetry set。</p></li><li><p>精化(refinement)关系<br> 为了使用TLC检验在精化映射<code>φ</code>下，ImplSpec到AbsSpec的精化关系，我们在模块ImplModule中添加定义和THEAOREM</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbsSub ==<span class="built_in"> INSTANCE </span>AbsModule</span><br><span class="line">THEOREM ImplSpec =&gt; AbsSub!AbsSpec</span><br></pre></td></tr></table></figure></li></ol><h2 id="尚未归类"><a href="#尚未归类" class="headerlink" title="尚未归类"></a>尚未归类</h2><ol><li>ASSUME<br> 必须是一个布尔量的常量表达式。<br> TLA+会<a href="https://learntla.com/models/constants/" target="_blank" rel="noopener">检查ASSUME中列出的条件是否满足</a>。</li><li>CONSTANTS<br> 定义了一系列常量，这些常量都可以理解为是集合。<br> 根据Lamport的P10a，传统数学中的变量，类似于TLA+中的CONSTANT。传统数学中没有和TLA+中的VARIABLE对应的概念，这个概念属于Temporal Logic(时序逻辑)。</li><li>VARIABLE/VARIABLES<br> 以TCommit为例，我们定义了<code>CONSTANT RM</code>，还定义了<code>VARIABLE rmState</code>。<br> 如何区分VARIABLE和CONSTANTS呢？我们可以理解为<code>rmState</code>是一个数组，这个数组的indexer是我们定义的RM集合，而这个集合是一个常量。    </li><li><code>[]TPNext</code><br> 表示<code>TPNext</code>始终成立。</li><li>EXTENDS<br> 类似于C++里面的<code>#include</code></li><li>INSTANCE<br> 下面的语句表示我们现在的Module实现了TCommit，于是我们将TCommit中的所有定义import到我们当前Module中。 <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE <span class="keyword">TCommit</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="DieHard"><a href="#DieHard" class="headerlink" title="DieHard"></a>DieHard</h1><p>在TLA中，需要在等式<code>==</code>右边指定全部状态。</p><h1 id="TCommit"><a href="#TCommit" class="headerlink" title="TCommit"></a>TCommit</h1><p>对应Lamport的第5节课。<br>TCommit主要定义了事务的提交模型。如下图所示，每个Resource Manager(RM)节点，可以理解为2PC里面的参与者节点，具有working、prepared、committed、aborted四种状态。在这个提交模型中，我们不考虑协调者，也就是只考虑怎么样，不考虑如何做。后者会在下一章中考虑。</p><p><img src="/img/tla/v5commit.png"></p><p>下面定义TypeOK对么？肯定是不对的，因为<code>rmState</code>是RM的集合。我们并不是希望这个集合属于这四个值，而是希望每个<code>rmState[r]</code>属于这四个值之中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TCTypeOK</span> == rmState \in &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCT<span class="function"><span class="title">ypeOK</span> == rmState \<span class="built_in">in</span> [RM -&gt;</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;]</span><br></pre></td></tr></table></figure><p>其实我觉得应该也可以这么写</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCTypeOK == \A r \<span class="keyword">in</span> <span class="string">RM:</span> rmState[r] \<span class="keyword">in</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure><p>在Module中不检查Deadlock，但检查TCConsistent和TCTypeOK。</p><p>注意，源码里面有一些诸如TCSpec的，并不会在这篇文章里面讲解。</p><h1 id="TwoPhase"><a href="#TwoPhase" class="headerlink" title="TwoPhase"></a>TwoPhase</h1><p>首先介绍一下消息：</p><ol><li>Prepared<br> RM-&gt;TM，表示某个RM已经Prepared了。</li><li>Commit<br> TM-&gt;RM</li><li>Abort<br> TM-&gt;RM</li></ol><p>然后介绍下动作：</p><ol><li>TMRcvPrepared<br> TM收到了某个RM的Prepared消息。</li><li>TMCommit<br> TM决定commit事务。<br> 此时TM必须在initial态，并且所有的RM都已经发送了Prepared消息。</li><li>TMAbort<br> TM自发地abort事务。</li><li>RMPrepare<br> 某个RM决定prepare。</li><li>RMChooseToAbort<br> 某个RM决定abort。<br> 注意，此时RM不会发送任何消息。这个是正常的，例如我宕机了，那还怎么发送消息。</li><li>RMRcvCommitMsg<br> 某个RM收到了来自TM的Commit消息。</li><li>RMRcvAbortMsg<br> 某个RM收到了来自TM的Abort消息。</li></ol><p>下面介绍状态：</p><ol><li>rmState<br> 包含<code>{&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;}</code>。</li><li>tmState<br> 包含<code>{&quot;init&quot;, &quot;done&quot;}</code>。<br> done表示TM进行了Commit或者Abort操作。</li><li>tmPrepared<br> TM接受到了哪些RM的准备消息。</li><li>msgs<br> 是一个表示所有已经发送的消息的集合。</li></ol><p>这里面涉及到定义类型，有点类似于Haskell的ADT。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Messages == [<span class="symbol">type:</span> &#123;<span class="string">"Prepared"</span>&#125;, <span class="symbol">rm:</span> RM] \<span class="class"><span class="keyword">union</span> [<span class="title">type</span>: &#123;"<span class="title">Commit</span>", "<span class="title">Abort</span>"&#125;]</span></span><br></pre></td></tr></table></figure><p>这里<code>\subseteq</code>是子集的意思，这两句话实际就是在说<code>tmPrepared</code>和<code>msgs</code>中的值一定属于<code>RM</code>或者<code>Message</code>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TPTypeOK == /<span class="string">\</span> tmPrepared <span class="string">\subseteq</span> RM</span><br><span class="line">            /<span class="string">\</span> msgs <span class="string">\subseteq</span> Messages</span><br></pre></td></tr></table></figure><h1 id="PaxosCommit-P07"><a href="#PaxosCommit-P07" class="headerlink" title="PaxosCommit (P07)"></a>PaxosCommit (P07)</h1><p>通过2PC，我们通过协调者TM去处理事务的提交。但如果TM宕掉怎么办呢？一个通常的实践是在主TM宕机后切换到备份的TM。这个操作的问题是，可能主TM决定Commit后分区/暂停了，但是备份TM决定Abort。但当它发送这个消息后，主TM恢复，并且发送Commit消息。这可能导致某些RM会Commit，另一些会Abort。</p><p>需要检查：</p><ol><li>PCTypeOK</li><li>TCConsistent</li></ol><p>Lamport强调，随着模型的线性增大，运行时间会以指数增大。</p><h1 id="P08a-P08b"><a href="#P08a-P08b" class="headerlink" title="P08a+P08b"></a>P08a+P08b</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><h2 id="Implication"><a href="#Implication" class="headerlink" title="Implication"></a>Implication</h2><p>介绍蕴含关系(implication)，也就是<code>=&gt;</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> =&gt; Q</span><br></pre></td></tr></table></figure><p>等同</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> P <span class="keyword">THEN</span> Q <span class="keyword">ELSE</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p>我们知道原命题的逆否命题成立，即</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="params">Q</span> =&gt;</span> ~P</span><br></pre></td></tr></table></figure><p>其中<code>~</code>也可以表示为<code>\lnot</code>或者<code>\neg</code></p><p>在口语中，implication通常断言因果。但是在数学中，只断言相关性。</p><h2 id="Module-closed-expression"><a href="#Module-closed-expression" class="headerlink" title="Module-closed expression"></a>Module-closed expression</h2><p>一个module-closed formula是一个不二良的module-closed expression。例如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x \in <span class="number">1.</span><span class="number">.42</span>) /\ (y' = x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="P09a"><a href="#P09a" class="headerlink" title="P09a"></a>P09a</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><p>介绍了ABSpec，即AlteringBits这个协议。</p><p>我们需要进行Liveness检查，分为以下步骤</p><ol><li>选择Temporal Formula为<code>FairSpec</code></li><li>设置”What is the model?”为”Set of model values”，但是关闭”Symmetry sets”选项。</li><li>在**”What to check?”<strong>下面的</strong>“Properties”**中填入下面的检查 <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\A</span> v <span class="string">\in</span> Data <span class="string">\X</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;: <span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="P09b"><a href="#P09b" class="headerlink" title="P09b"></a>P09b</h1><p>这一章节介绍AB，也就是AlteringBits这个协议的具体实现。</p><p>这个协议如下所示，A向B同步信息。开始，A和B都是<code>&lt;&lt;&quot;&quot;,0&gt;&gt;</code>。接着A开始发送<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>，会不断重传。当B收到<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>后，就更新自己的值，并且开始不断向A发送1，而不是0。<br><img src="/img/tla/ab2.png"></p><p>在实现完AB之后，需要进行Safety检查。但不能直接检查Spec。这是因为A和B可以不断地给彼此发送消息，并且发送的速度远远比丢包或者对端接收要快，这样的话会导致有无数的可到达状态，我们的TCL程序可能永远不会结束！<br>此时需要打开”Additional Spec Options”标签，在”State Constraint”中设置。这样我们就限制了消息的最大长度。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="built_in">Len</span>(AtoB) =&lt; <span class="number">3</span></span><br><span class="line">/\ <span class="built_in">Len</span>(BtoA) =&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>此外，我们还要在”What to check?”下面的”Properties”中填入<code>ABS!Spec</code>，表示我们要检查ABSpec里面的Spec。</p><p><img src="/img/tla/find_states.png"></p><p>下面进行Liveness检查，也就是添加Fairness条件，从而imply消息能够持续被发送以及接收。<br>此时Weak Fairness是不够的。因为这实际上允许了B一直向A发送1，如下如所示。【Q】为什么呢？稍后解释<br><img src="/img/tla/wf_fail.png"></p><p>因此我们得使用下面的</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  SF_vars<span class="comment">(ARcv)</span> /\ SF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure><p>【Q】能不能改成全是WF呢，如下所示</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  WF_vars<span class="comment">(ARcv)</span> /\ WF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure><p>尝试一下，可以发现下面的错误：<br><img src="/img/tla/all_wf.png"><br>它的路径如下，容易发现形成了循环。</p><ol><li>BSnd: 1</li><li>ASnd: <code>&lt;&lt;a, 1&gt;&gt;</code></li><li>LoseMsg: BtoA from <code>&lt;&lt;1&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code></li><li>BRcv: AtoB from <code>&lt;&lt;&lt;&lt;a, 1&gt;&gt;&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code><br> 回到了状态1</li></ol><p>Why？这是因为<code>WF_var(ASnd)</code>和<code>WF_var(BSnd)</code>是true，因为ASnd和BSnd一直在发生。<br>现在考虑<code>WF_vars(ARcv)</code>。在Init状态，它没有enable，因为BtoA是空的。在B发送消息之后，它enable了，但是如果发生了LostMsg，那么它又不enable了。容易看出，<code>WF_vars(ARcv)</code>也是true，因为<code>ARcv</code>并不能<strong>continuouesly enable</strong>。<br>所以，我们满足了<code>FairSpec</code>，但并不满足<code>ABS!FailSpec</code>，所以下面的THEOREM也不成立了</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM FairSpec =&gt; <span class="keyword">ABS</span>!FailSpec</span><br></pre></td></tr></table></figure><p>因此，我们要引入Strong Fairness。</p><h1 id="P10a"><a href="#P10a" class="headerlink" title="P10a"></a>P10a</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>实现<code>RemoveX</code>，用来移除一个Tuple中的所有<code>&quot;X&quot;</code>。我们需要一个前置声明。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RECURSIVE RemoveX(_)</span><br><span class="line">RemoveX(l) == <span class="keyword">IF</span> l = &lt;&lt;&gt;&gt; <span class="keyword">THEN</span> l</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="keyword">IF</span> Head(l) = <span class="string">"X"</span> <span class="keyword">THEN</span> RemoveX(Tail(l))</span><br><span class="line">                     <span class="keyword">ELSE</span> &lt;&lt;Head(l)&gt;&gt; \o RemoveX(Tail(l))</span><br></pre></td></tr></table></figure><h2 id="代入-Substitution"><a href="#代入-Substitution" class="headerlink" title="代入(Substitution)"></a>代入(Substitution)</h2><p>考虑传统数学中的代入逻辑，即把<code>e</code>导入到<code>f(v)</code>中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">v</span> = e) =&gt; (<span class="name">f</span> = (<span class="name">f</span> WITH v &lt;- e))</span><br></pre></td></tr></table></figure><p>其中WITH是Lamport定义的描述性的语句，其作用如下</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y^<span class="number">3</span>-y) WITH y &lt;- x+<span class="number">2</span> = (x+<span class="number">2</span>)^<span class="number">3</span>-(x+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>因为TLA关注时序的逻辑，我们不能在写TLA+的时候这么进行代换，我们考虑下面的代入：<code>v &lt;- y</code>、<code>e &lt;- x + 2</code>、<code>f &lt;- y&#39;</code>，其实未必是一直成立的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM (<span class="name">y</span> = x + <span class="number">2</span>) =&gt; (<span class="name">y</span>' = (<span class="name">x</span> + <span class="number">2</span>)')</span><br></pre></td></tr></table></figure><p>因此，我们使用Temporal Substitution Law</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="comment">(v = e)</span> =&gt; <span class="comment">(f = (f WITH v &lt;- e)</span>)</span><br></pre></td></tr></table></figure><p>即写成下面的形式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM [] (y = x + <span class="number">2</span>) =&gt; (y<span class="string">' = (x + 2)'</span>)</span><br></pre></td></tr></table></figure><h2 id="AB2"><a href="#AB2" class="headerlink" title="AB2"></a>AB2</h2><p>这个协议旨在处理出现消息损坏(Corrupted)的情况。<br>为此，我们引入了一个新消息Bad。并且Bad一定不等于所有的其他消息。我们用ASSUME来描述这个性质。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME Bad \notin (Data \X &#123;<span class="number">0</span>,<span class="number">1</span>&#125;) \cup &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>此外在运行Module的时候，需要给Bad赋一个不同于所有其他消息的值，一个Idea是用字符串”Bad”来代表。但这会遇到错误”Attempted to check equality of interger 0 with non-integer: “Bad””。所以，实际上我们可以直接用Model Value，即我们给Bad的值就是Bad。</p><p>我们需要保证消息需要在他们Corrupted之前被Receive，这个靠目前的Fairness条件是不够的，我们需要修改Safety条件。<br>首先，我们加入了AtoBgood和BtoAgood用来表示某条信息是不是肯定不会Corrupt。<br>然后，如果我们将AtoB2里面的Bad消息去掉，就可以得到一个等价的AtoB，因此我们得到了SpecH。去掉可以通过<code>RemoveBad</code>，类似于之前提到的<code>RemoveX</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpecH == /<span class="tag">\<span class="name"> </span></span>AB2!Spec</span><br><span class="line">         /<span class="tag">\<span class="name"> </span><span class="string">[]</span></span> /<span class="tag">\<span class="name"> </span></span>AtoB = RemoveBad(AtoB2)</span><br><span class="line">               /<span class="tag">\<span class="name"> </span></span>BtoA = RemoveBad(BtoA2)</span><br></pre></td></tr></table></figure><p>我们的目标是，但此时我们的SpecH并不符合TLA+的Safety检查的格式，即<code>Init /\ [][Next]_vars</code>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM SpecH =&gt; AB!Spec</span><br></pre></td></tr></table></figure><p>为此，我们引入了SpecHH</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpecHH == InitH /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[NextH]</span></span>_varsH</span><br><span class="line">THEOREM SpecHH &lt;=&gt; SpecH</span><br></pre></td></tr></table></figure><p>其中<code>&lt;=&gt;</code>的作用等价于</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ SpecHH =&gt; SpecH</span><br><span class="line">/\ SpecH  =&gt; SpecHH</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.jianshu.com/p/12fda75ddf9e" target="_blank" rel="noopener">https://www.jianshu.com/p/12fda75ddf9e</a><br> 介绍TLA+的语法</li><li><a href="http://lamport.azurewebsites.net/video/videos.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/video/videos.html</a><br> Lamport的视频教学<br> 这里面有课件，以及视频教程里面的代码，这些在<a href="https://github.com/tlaplus/Examples" target="_blank" rel="noopener">https://github.com/tlaplus/Examples</a>并没有。</li><li><a href="https://github.com/parlarjb/tla_workshop" target="_blank" rel="noopener">https://github.com/parlarjb/tla_workshop</a><br> Lamport的代码的整理</li><li><a href="https://learntla.com/tla/" target="_blank" rel="noopener">https://learntla.com/tla/</a><br> 一个TLA+学习的网站</li><li><a href="https://lamport.azurewebsites.net/tla/book-02-08-08.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/book-02-08-08.pdf</a><br> Specifying Systems这本书，这是终极版本的讲义</li><li><a href="http://lamport.azurewebsites.net/tla/newmodule.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/newmodule.html</a><br> TLA中的module的相关说明，包含了很多语法相关的讲解</li><li><a href="http://lamport.azurewebsites.net/tla/book-21-07-04.pdf" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/book-21-07-04.pdf</a><br> Specifying Systems这本书的新版本？</li><li><a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/tla2-guide.pdf</a><br> TLA2</li><li><a href="https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822</a><br> 教学视频，包含P10</li><li><a href="https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822</a><br> 教学视频，不包含P10，但是赠送了对Paxos的讲解</li><li><a href="https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf" target="_blank" rel="noopener">https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf</a></li><li><a href="https://github.com/tlaplus/DrTLAPlus" target="_blank" rel="noopener">https://github.com/tlaplus/DrTLAPlus</a></li><li><a href="https://www.youtube.com/watch?v=6Kwx8zfGW0Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=6Kwx8zfGW0Y</a><br> 从1.07开始有个简单的对Raft的TLA+的讲解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍TLA+用法。&lt;br&gt;TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。&lt;br&gt;TLC是TLA+的模型检验工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="TLA" scheme="http://www.calvinneo.com/tags/TLA/"/>
    
    <category term="形式验证" scheme="http://www.calvinneo.com/tags/形式验证/"/>
    
  </entry>
  
  <entry>
    <title>概率论中的几个有趣问题</title>
    <link href="http://www.calvinneo.com/2021/05/15/probability-problems/"/>
    <id>http://www.calvinneo.com/2021/05/15/probability-problems/</id>
    <published>2021-05-15T11:20:33.000Z</published>
    <updated>2021-11-28T14:51:53.605Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍概率论中一些有趣的问题，其中很多是反直觉的</p><a id="more"></a><h1 id="三门问题"><a href="#三门问题" class="headerlink" title="三门问题"></a>三门问题</h1><h1 id="两个男孩"><a href="#两个男孩" class="headerlink" title="两个男孩"></a>两个男孩</h1><h1 id="基本比率谬误"><a href="#基本比率谬误" class="headerlink" title="基本比率谬误"></a>基本比率谬误</h1><p>假设同性恋染上某病的概率是异性恋的9倍。已知小明染上某病，求小明同性恋的概率。<br>错误的答案是$\frac{9}{10}$。正确答案是无法计算，因为我们并不知道同性恋和异性恋的比例。</p><p>令同性恋是$S$，异性恋是$H$，患某病是$X$。已知</p><p>$$<br>P(X|S) = 9 \quad P(X|H)<br>$$</p><p>求$P(S|X)$</p><p>我们计算</p><p>$$<br>P(S|X) = \frac{P(S)P(X|S)}{P(X)}<br>$$</p><h1 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h1><p>我们考虑另一个问题，我们统计篮球比赛中两个球员的三分球和二分球命中率，假如A的三分球命中率比B高，二分球命中率也比B高，那么A的总命中率比B高么？<br>答案是不确定。我们不如考虑下面这个极端情况：</p><ol><li>A的二分球命中率是100%，B的是99%</li><li>A的三分球命中率是1%，B的是0%</li></ol><p>那B说好的，我田忌赛马了，我就直投二分球，你A只投三分球。结果B的总命中率是99%，而A的是1%。<br>辛普森悖论告诉我们如果一个人犯的错误多，很可能是因为他在做难的事情。所以如果我们老板不懂这个，而只追求bug少，那就会变成no code no bug的场面。</p><h1 id="婚姻-秘书问题或者博士后问题"><a href="#婚姻-秘书问题或者博士后问题" class="headerlink" title="婚姻/秘书问题或者博士后问题"></a>婚姻/秘书问题或者博士后问题</h1><p>我们在海滩捡贝壳，必须在捡贝壳的时候决定留不留下，并且只有一次选择留下的机会，问如何最大化<strong>选到最佳贝壳</strong>的概率。</p><h1 id="贝特朗悖论"><a href="#贝特朗悖论" class="headerlink" title="贝特朗悖论"></a>贝特朗悖论</h1><h1 id="凯利公式"><a href="#凯利公式" class="headerlink" title="凯利公式"></a>凯利公式</h1><h1 id="Arrow不可能原理"><a href="#Arrow不可能原理" class="headerlink" title="Arrow不可能原理"></a>Arrow不可能原理</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://blog.csdn.net/itnerd/article/details/107348933" target="_blank" rel="noopener">https://blog.csdn.net/itnerd/article/details/107348933</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4</a></li><li><a href="https://www.zhihu.com/question/330408241" target="_blank" rel="noopener">https://www.zhihu.com/question/330408241</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍概率论中一些有趣的问题，其中很多是反直觉的&lt;/p&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="http://www.calvinneo.com/tags/机器学习/"/>
    
    <category term="概率论" scheme="http://www.calvinneo.com/tags/概率论/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.calvinneo.com/2021/05/15/redis-replication/"/>
    <id>http://www.calvinneo.com/2021/05/15/redis-replication/</id>
    <published>2021-05-14T17:20:33.000Z</published>
    <updated>2021-08-18T07:28:35.760Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a>这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。</p><p>主从复制涉及到RDB等机制，其中持久化部分在<a href="/2021/03/13/redis-persist/">Redis持久化机制实现</a>中介绍。</p><a id="more"></a><h1 id="Redis主从复制流程简介"><a href="#Redis主从复制流程简介" class="headerlink" title="Redis主从复制流程简介"></a>Redis主从复制流程简介</h1><p>Redis Sentinel是对主从复制流程而言的，所以我们先要理解主从复制的大概流程。这里需要注意，主从复制并不是Redis Cluster。</p><ol><li>Slave接受到SLAVEOF命令</li><li>Slave连接Master</li><li>Slave PING Master</li><li>鉴权</li><li>Slave发送SYNC/PSYNC命令</li></ol><h2 id="PSYNC命令用法"><a href="#PSYNC命令用法" class="headerlink" title="PSYNC命令用法"></a>PSYNC命令用法</h2><p>PSYNC命令如下所示，其中：</p><ol><li>replicationid表示我们断线重连前Master服务器的id</li><li>offset表示Slave接受到最后命令的偏移量，以字节计算</li></ol><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">PSYNC runid <span class="keyword">offset</span></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">PSYNC replicationid <span class="keyword">offset</span></span><br></pre></td></tr></table></figure><p>这里还有个特殊用法，表示我们要触发一次全量复制。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>在Redis 2.8后，提供了PSYNC，这个命令能够支持全量复制和部分复制。这样在Slave断线重连之后，就可以部分复制，从而节省Master的计算资源和带宽。<br>在Redis 4.0版本后，优化了增量复制，主要包括：</p><ol><li>重启后，也可以进行部分复制<br> 之前这种情况，重启后会丢失runid，从而触发<code>PSYNC ? -1</code></li><li>当Slave被promote称为Master后，其他Slave可以从新Master处复制</li></ol><h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><h2 id="主要类以及常数"><a href="#主要类以及常数" class="headerlink" title="主要类以及常数"></a>主要类以及常数</h2><p>在服务器类中定义了<code>masterhost</code>，表示Master节点的地址。如果是NULL，表示自己就是Master。所以这个字段<strong>会被用来判断是MAster还是Slave</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *masteruser;               <span class="comment">/* AUTH with this user and masterauth with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterauth;               <span class="comment">/* AUTH with this password with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterhost;               <span class="comment">/* Hostname of master */</span></span><br><span class="line">    <span class="keyword">int</span> masterport;                 <span class="comment">/* Port of master */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍下<code>repl_state</code>的状态：</p><ol><li><code>REPL_STATE_NONE 0</code><br> 表示现在是SLAVEOF NO ONE的</li><li><code>REPL_STATE_CONNECT 1</code><br> 在<code>replicationCron</code>判断，如果处于这个状态，表示现在要去尝试连接Master了。</li><li><code>REPL_STATE_CONNECTING 2</code></li></ol><p>下面的状态是握手过程中的状态：</p><ol><li><code>REPL_STATE_RECEIVE_PONG 3</code></li><li><code>REPL_STATE_SEND_AUTH 4</code></li><li><code>REPL_STATE_RECEIVE_AUTH 5</code></li><li><code>REPL_STATE_SEND_PORT 6</code></li><li><code>REPL_STATE_RECEIVE_PORT 7</code></li><li><code>REPL_STATE_SEND_IP 8</code></li><li><code>REPL_STATE_RECEIVE_IP 9</code></li><li><code>REPL_STATE_SEND_CAPA 10</code></li><li><code>REPL_STATE_RECEIVE_CAPA 11</code></li><li><code>REPL_STATE_SEND_PSYNC 12</code></li><li><code>REPL_STATE_RECEIVE_PSYNC 13</code></li></ol><p>下面状态是握手完毕的状态：</p><ol><li><code>REPL_STATE_TRANSFER 14</code></li><li><code>REPL_STATE_CONNECTED 15</code></li></ol><h2 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h2><ol><li>connectWithMaster</li></ol><h2 id="Full-Sync流程"><a href="#Full-Sync流程" class="headerlink" title="Full Sync流程"></a>Full Sync流程</h2><h2 id="Partial-Sync流程"><a href="#Partial-Sync流程" class="headerlink" title="Partial Sync流程"></a>Partial Sync流程</h2><h1 id="代码解释-Slave部分"><a href="#代码解释-Slave部分" class="headerlink" title="代码解释 Slave部分"></a>代码解释 Slave部分</h1><h2 id="connectWithMaster-建立套接口连接"><a href="#connectWithMaster-建立套接口连接" class="headerlink" title="connectWithMaster: 建立套接口连接"></a>connectWithMaster: 建立套接口连接</h2><p><code>connConnect</code>系列函数，以及<code>connection</code>类封装了有关网络连接的库。<br>实际上<code>connConnect</code>通过<code>anetTcpNonBlockBestEffortBindConnect</code>尝试建立一个非阻塞的套接字，此时<code>connect</code>函数可能返回<code>EINPROGRESS</code>表示连接还在建立过程中，但我们其实可以不用等。通过<code>aeCreateFileEvent</code>将这个Socket描述符加入到事件循环里面，等到这个套接字可以写之后，会触发对应的回调。<br>等到连接建立后，回调会通过<code>connSocketEventHandler</code>被唤起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectWithMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();</span><br><span class="line">    <span class="keyword">if</span> (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,</span><br><span class="line">                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to connect to MASTER: %s"</span>,</span><br><span class="line">                connGetLastError(server.repl_transfer_s));</span><br><span class="line">        connClose(server.repl_transfer_s);</span><br><span class="line">        server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; REPLICA sync started"</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="syncWithMaster-握手以及准备传输RDB"><a href="#syncWithMaster-握手以及准备传输RDB" class="headerlink" title="syncWithMaster: 握手以及准备传输RDB"></a>syncWithMaster: 握手以及准备传输RDB</h2><p>在连接完毕后，<code>connectWithMaster</code>会回调<code>syncWithMaster</code>，此时状态是<code>REPL_STATE_CONNECTING</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncWithMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>], *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> dfd = <span class="number">-1</span>, maxtries = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> psync_result;</span><br></pre></td></tr></table></figure><p>检查一下，如果现在又是SLAVEOF NO ONE了，就把这个连接关掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If this event fired after the user turned the instance into a master</span></span><br><span class="line"><span class="comment"> * with SLAVEOF NO ONE we must just return ASAP. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">    connClose(conn);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是非阻塞的连接，所以我们要检查一下现在连接的状态。如果失败，就goto error，里面内容是重置状态，例如，<code>server.repl_state</code>会被重置为<code>REPL_STATE_CONNECT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check for errors in the socket: after a non blocking connect() we</span></span><br><span class="line"><span class="comment"> * may find that the socket is in error state. */</span></span><br><span class="line"><span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Error condition on socket for SYNC: %s"</span>,</span><br><span class="line">            connGetLastError(conn));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个状态机的实现。我们在Sentinel中已经见过类似的了，Redis中状态机的实现就是，对于状态X，表示状态X前一个状态已经处理完了，目前正在处理状态X的工作。<strong>当状态机处理完一个状态后</strong>，在最后将状态设置为下一个要做的事情。也就是我们不用类似<code>X_FINISHED</code>这样的状态，因为<code>X_FINISHED</code>根据完成的情形不同，<strong>可能有多种状态转移</strong>。<br>【REPL_STATE_CONNECTING】这个状态下，我们尝试发送一个同步命令PING，然后直接修改状态到<code>REPL_STATE_RECEIVE_PONG</code>。如果这个同步命令发送有问题，就直接goto error了，不会走到下面流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a PING to check the master is able to reply without errors. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Non blocking connect for SYNC fired the event."</span>);</span><br><span class="line">    <span class="comment">/* Delete the writable event so that the readable event remains</span></span><br><span class="line"><span class="comment">     * registered and we can wait for the PONG reply. */</span></span><br><span class="line">    connSetReadHandler(conn, syncWithMaster);</span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</span><br><span class="line">    <span class="comment">/* Send the PING, don't check for errors at all, we have the timeout</span></span><br><span class="line"><span class="comment">     * that will take care about this. */</span></span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PING"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_PONG】我们只要收到对PING的回复，就进入了<code>REPL_STATE_RECEIVE_PONG</code>状态，但这个回复未必是PONG，也可能是一个AUTH错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive the PONG command. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We accept only two replies as valid, a positive +PONG reply</span></span><br><span class="line"><span class="comment">     * (we just check for "+") or an authentication error.</span></span><br><span class="line"><span class="comment">     * Note that older versions of Redis replied with "operation not</span></span><br><span class="line"><span class="comment">     * permitted" instead of using a proper error code, so we test</span></span><br><span class="line"><span class="comment">     * both. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">'+'</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOAUTH"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOPERM"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-ERR operation not permitted"</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error reply to PING from master: '%s'"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master replied to PING, replication can continue..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_AUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_AUTH】如果需要AUTH认证，我们就发送AUTH，进入<code>REPL_STATE_RECEIVE_AUTH</code>。否则直接进入<code>REPL_STATE_SEND_PORT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AUTH with the master if required. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masteruser &amp;&amp; server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,</span><br><span class="line">                                     server.masteruser,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_AUTH】如果验证通过，就进入<code>REPL_STATE_SEND_PORT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive AUTH reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to AUTH to MASTER: %s"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_PORT】下面一步，我们需要发送我们当前的端口，进入<code>REPL_STATE_RECEIVE_PORT</code>状态。<br>在发送完之后，我们在主节点执行<code>INFO replication</code>，会在其中显示我们反馈的port。<br>【Q】<code>slave_announce_port</code>和<code>port</code>的区别是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the slave port, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave listening port correctly. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">if</span> (server.slave_announce_port) port = server.slave_announce_port;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port) port = server.tls_port;</span><br><span class="line">    <span class="keyword">else</span> port = server.port;</span><br><span class="line">    sds portstr = sdsfromlonglong(port);</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"listening-port"</span>,portstr, <span class="literal">NULL</span>);</span><br><span class="line">    sdsfree(portstr);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_PORT】接下来，我们用类似的办法发送IP，这里注意，如果没有指定<code>slave_announce_ip</code>就直接跳转到<code>REPL_STATE_SEND_CAPA</code>，否则跳转到<code>REPL_STATE_SEND_IP</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive REPLCONF listening-port reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF listening-port: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_IP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip REPLCONF ip-address if there is no slave-announce-ip option set. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;</span><br><span class="line">    server.slave_announce_ip == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the slave ip, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave IP address port correctly in case of port forwarding or NAT. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"ip-address"</span>,server.slave_announce_ip, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive REPLCONF ip-address reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF ip-address: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_CAPA】发送IP的过程很类似，我们就不说了。下面这一对状态是<code>REPL_STATE_SEND_CAPA</code>，用来发送Slave的容量。这一对状态结束之后，进入<code>REPL_STATE_SEND_PSYNC</code>状态。<br>【Q】这个容量指的是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inform the master of our (slave) capabilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EOF: supports EOF-style RDB transfer for diskless replication.</span></span><br><span class="line"><span class="comment"> * PSYNC2: supports PSYNC v2, so understands +CONTINUE &lt;new repl ID&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The master will ignore capabilities it does not understand. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"capa"</span>,<span class="string">"eof"</span>,<span class="string">"capa"</span>,<span class="string">"psync2"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive CAPA reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF capa. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                              <span class="string">"REPLCONF capa: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_PSYNC】下面，我们尝试PSYNC。主要就是调用若干次<code>slaveTryPartialResynchronization</code>：第一次传0进去，让它发PSYNC指令，并且设置状态为<code>REPL_STATE_RECEIVE_PSYNC</code>；后面就不断地传1进去，查询结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try a partial resynchonization. If we don't have a cached master</span></span><br><span class="line"><span class="comment"> * slaveTryPartialResynchronization() will at least try to use PSYNC</span></span><br><span class="line"><span class="comment"> * to start a full resynchronization so that we get the master run id</span></span><br><span class="line"><span class="comment"> * and the global offset, to try a partial resync at the next</span></span><br><span class="line"><span class="comment"> * reconnection attempt. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slaveTryPartialResynchronization(conn,<span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">        err = sdsnew(<span class="string">"Write error sending the PSYNC command."</span>);</span><br><span class="line">        <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"syncWithMaster(): state machine error, "</span></span><br><span class="line">                         <span class="string">"state should be RECEIVE_PSYNC but is %d"</span>,</span><br><span class="line">                         server.repl_state);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psync_result = slaveTryPartialResynchronization(conn,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>下面查看返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_WAIT_REPLY) <span class="keyword">return</span>; <span class="comment">/* Try again later... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the master is in an transient error, we should try to PSYNC</span></span><br><span class="line"><span class="comment"> * from scratch later, so go to the error path. This happens when</span></span><br><span class="line"><span class="comment"> * the server is loading the dataset or is not connected with its</span></span><br><span class="line"><span class="comment"> * master and so forth. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_TRY_LATER) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: if PSYNC does not return WAIT_REPLY, it will take care of</span></span><br><span class="line"><span class="comment"> * uninstalling the read handler from the file descriptor. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization."</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Partial Resynchronization accepted. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PSYNC failed or is not supported: we want our slaves to resync with us</span></span><br><span class="line"><span class="comment"> * as well, if we have any sub-slaves. The master may transfer us an</span></span><br><span class="line"><span class="comment"> * entirely different data set and we have no way to incrementally feed</span></span><br><span class="line"><span class="comment"> * our slaves after that. */</span></span><br><span class="line">disconnectSlaves(); <span class="comment">/* Force our slaves to resync with us as well. */</span></span><br><span class="line">freeReplicationBacklog(); <span class="comment">/* Don't allow our chained slaves to PSYNC. */</span></span><br></pre></td></tr></table></figure><p>如果PSYNC能支持，我们前面就返回了，下面对于不支持的情况，我们就得用老的SYNC方法。在开始传输后，进入<code>REPL_STATE_TRANSFER</code>状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC</span></span><br><span class="line"><span class="comment"> * and the server.master_replid and master_initial_offset are</span></span><br><span class="line"><span class="comment"> * already populated. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Retrying with SYNC..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (connSyncWrite(conn,<span class="string">"SYNC\r\n"</span>,<span class="number">6</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"I/O error writing to MASTER: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不支持无盘加载，那么就要在磁盘上创建一个临时文件。<br>查看函数<code>useDisklessLoad</code>，无盘加载需要满足：</p><ol><li><code>repl_diskless_load</code>配置</li><li>所有的模块都能处理读错误</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare a suitable temp file for bulk transfer */</span></span><br><span class="line"><span class="keyword">if</span> (!useDisklessLoad()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,</span><br><span class="line">            <span class="string">"temp-%d.%ld.rdb"</span>,(<span class="keyword">int</span>)server.unixtime,(<span class="keyword">long</span> <span class="keyword">int</span>)getpid());</span><br><span class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</span><br><span class="line">    server.repl_transfer_fd = dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面非阻塞地进行SYNC，设置读取SYNC数据的回调<code>readSyncBulkPayload</code>，如果成功就切换状态为<code>REPL_STATE_TRANSFER</code>。<br>这里，我们设置了<code>repl_transfer_size</code>为1，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the non blocking download of the bulk file. */</span></span><br><span class="line"><span class="keyword">if</span> (connSetReadHandler(conn, readSyncBulkPayload)</span><br><span class="line">        == C_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> conninfo[CONN_INFO_LEN];</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Can't create readable event for SYNC: %s (%s)"</span>,</span><br><span class="line">        strerror(errno), connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.repl_state = REPL_STATE_TRANSFER;</span><br><span class="line">server.repl_transfer_size = <span class="number">-1</span>;</span><br><span class="line">server.repl_transfer_read = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_last_fsync_off = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_lastio = server.unixtime;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>下面是错误处理，需要将状态重置为等待连接的<code>REPL_STATE_CONNECT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (dfd != <span class="number">-1</span>) close(dfd);</span><br><span class="line">    connClose(conn);</span><br><span class="line">    server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_fd != <span class="number">-1</span>)</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_tmpfile)</span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">    server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">write_error: <span class="comment">/* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Sending command to master in replication handshake: %s"</span>, err);</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slaveTryPartialResynchronization-PSYNC分支"><a href="#slaveTryPartialResynchronization-PSYNC分支" class="headerlink" title="slaveTryPartialResynchronization: PSYNC分支"></a>slaveTryPartialResynchronization: PSYNC分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Try a partial resynchronization with the master if we are about to reconnect.</span></span><br><span class="line"><span class="comment"> * If there is no cached master structure, at least try to issue a</span></span><br><span class="line"><span class="comment"> * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC</span></span><br><span class="line"><span class="comment"> * command in order to obtain the master run id and the master replication</span></span><br><span class="line"><span class="comment"> * global offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is designed to be called from syncWithMaster(), so the</span></span><br><span class="line"><span class="comment"> * following assumptions are made:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) We pass the function an already connected socket "fd".</span></span><br><span class="line"><span class="comment"> * 2) This function does not close the file descriptor "fd". However in case</span></span><br><span class="line"><span class="comment"> *    of successful partial resynchronization, the function will reuse</span></span><br><span class="line"><span class="comment"> *    'fd' as file descriptor of the server.master client structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function is split in two halves: if read_reply is 0, the function</span></span><br><span class="line"><span class="comment"> * writes the PSYNC command on the socket, and a new function call is</span></span><br><span class="line"><span class="comment"> * needed, with read_reply set to 1, in order to read the reply of the</span></span><br><span class="line"><span class="comment"> * command. This is useful in order to support non blocking operations, so</span></span><br><span class="line"><span class="comment"> * that we write, return into the event loop, and read when there are data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When read_reply is 0 the function returns PSYNC_WRITE_ERR if there</span></span><br><span class="line"><span class="comment"> * was a write error, or PSYNC_WAIT_REPLY to signal we need another call</span></span><br><span class="line"><span class="comment"> * with read_reply set to 1. However even when read_reply is set to 1</span></span><br><span class="line"><span class="comment"> * the function may return PSYNC_WAIT_REPLY again to signal there were</span></span><br><span class="line"><span class="comment"> * insufficient data to read to complete its work. We should re-enter</span></span><br><span class="line"><span class="comment"> * into the event loop and wait in such a case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PSYNC_CONTINUE: If the PSYNC command succeeded and we can continue.</span></span><br><span class="line"><span class="comment"> * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.</span></span><br><span class="line"><span class="comment"> *                   In this case the master run_id and global replication</span></span><br><span class="line"><span class="comment"> *                   offset is saved.</span></span><br><span class="line"><span class="comment"> * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and</span></span><br><span class="line"><span class="comment"> *                      the caller should fall back to SYNC.</span></span><br><span class="line"><span class="comment"> * PSYNC_WRITE_ERROR: There was an error writing the command to the socket.</span></span><br><span class="line"><span class="comment"> * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.</span></span><br><span class="line"><span class="comment"> * PSYNC_TRY_LATER: Master is currently in a transient error condition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notable side effects:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) As a side effect of the function call the function removes the readable</span></span><br><span class="line"><span class="comment"> *    event handler from "fd", unless the return value is PSYNC_WAIT_REPLY.</span></span><br><span class="line"><span class="comment"> * 2) server.master_initial_offset is set to the right value according</span></span><br><span class="line"><span class="comment"> *    to the master reply. This will be used to populate the 'server.master'</span></span><br><span class="line"><span class="comment"> *    structure replication offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li><code>PSYNC_WRITE_ERROR 0</code><br> 套接口不可写。</li><li><code>PSYNC_WAIT_REPLY 1</code><br> 需要<code>read_erply</code>设置为1，并调用函数。</li><li><code>PSYNC_CONTINUE 2</code></li><li><code>PSYNC_FULLRESYNC 3</code><br> 表示虽然支持PSYNC，但现在仍然需要一次Full SYNC。在这情况下，我们需要保存Master的runid和offset。</li><li><code>PSYNC_NOT_SUPPORTED 4</code><br> 不支持PSYNC。</li><li><code>PSYNC_TRY_LATER 5</code><br> 暂时连不上Master，要重试。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psync_replid;</span><br><span class="line">    <span class="keyword">char</span> psync_offset[<span class="number">32</span>];</span><br><span class="line">    sds reply;</span><br></pre></td></tr></table></figure><p>首先，是写部分。这里的写，指的是往连接里面发送<code>PSYNC</code>指令:</p><ol><li>如果我们缓存了<code>server.master</code>到<code>server.cached_master</code><br> 通常是在<code>replicationCacheMaster</code>中设置的</li><li>如果是第一次连<br> 发送 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Writing half */</span></span><br><span class="line"><span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">    <span class="comment">/* Initially set master_initial_offset to -1 to mark the current</span></span><br><span class="line"><span class="comment">     * master run_id and offset as not valid. Later if we'll be able to do</span></span><br><span class="line"><span class="comment">     * a FULL resync using the PSYNC command we'll set the offset at the</span></span><br><span class="line"><span class="comment">     * right value, so that this information will be propagated to the</span></span><br><span class="line"><span class="comment">     * client structure representing the master into server.master. */</span></span><br><span class="line">    server.master_initial_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cached_master) &#123;</span><br><span class="line">        psync_replid = server.cached_master-&gt;replid;</span><br><span class="line">        <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">"%lld"</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Trying a partial resynchronization (request %s:%s)."</span>, psync_replid, psync_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Partial resynchronization not possible (no cached master)"</span>);</span><br><span class="line">        psync_replid = <span class="string">"?"</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(psync_offset,<span class="string">"-1"</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Issue the PSYNC command */</span></span><br><span class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PSYNC"</span>,psync_replid,psync_offset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to send PSYNC to master: %s"</span>,reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读出Master的回复，如果是空，我们就返回继续等待<code>PSYNC_WAIT_REPLY</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reading half */</span></span><br><span class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* The master may send empty newlines after it receives PSYNC</span></span><br><span class="line"><span class="comment">     * and before to reply, just to keep the connection alive. */</span></span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如果回复是<code>+FULLRESYNC</code>，表示需要一次Full SYNC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+FULLRESYNC"</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">    <span class="keyword">char</span> *replid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FULL RESYNC, parse the reply in order to extract the run id</span></span><br><span class="line"><span class="comment">     * and the replication offset. */</span></span><br><span class="line">    replid = <span class="built_in">strchr</span>(reply,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (replid) &#123;</span><br><span class="line">        replid++;</span><br><span class="line">        offset = <span class="built_in">strchr</span>(replid,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!replid || !offset || (offset-replid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Master replied with wrong +FULLRESYNC syntax."</span>);</span><br><span class="line">        <span class="comment">/* This is an unexpected condition, actually the +FULLRESYNC</span></span><br><span class="line"><span class="comment">         * reply means that the master supports PSYNC, but the reply</span></span><br><span class="line"><span class="comment">         * format seems wrong. To stay safe we blank the master</span></span><br><span class="line"><span class="comment">         * replid to make sure next PSYNCs will fail. */</span></span><br><span class="line">        <span class="built_in">memset</span>(server.master_replid,<span class="number">0</span>,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(server.master_replid, replid, offset-replid<span class="number">-1</span>);</span><br><span class="line">        server.master_replid[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">        server.master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Full resync from master: %s:%lld"</span>,</span><br><span class="line">            server.master_replid,</span><br><span class="line">            server.master_initial_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_FULLRESYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则，我们可以部分同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+CONTINUE"</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Partial resync was accepted. */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Successful partial resynchronization with master."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the new replication ID advertised by the master. If it</span></span><br><span class="line"><span class="comment">     * changed, we need to set the new ID as primary ID, and set or</span></span><br><span class="line"><span class="comment">     * secondary ID as the old master ID up to the current offset, so</span></span><br><span class="line"><span class="comment">     * that our sub-slaves will be able to PSYNC with us after a</span></span><br><span class="line"><span class="comment">     * disconnection. */</span></span><br><span class="line">    <span class="keyword">char</span> *start = reply+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> *end = reply+<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span>(end[<span class="number">0</span>] != <span class="string">'\r'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\n'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\0'</span>) end++;</span><br></pre></td></tr></table></figure><p>这里new表示Master端传来的runid。如果和我们当前的<code>server.replid</code>不一样，我们要重新设置一下，并且将老的<code>server.replid</code>复制给<code>server.replid2</code>。<br>【Q】这里涉及到三个replid，他们的区别是什么呢？</p><ol><li><code>server.replid</code></li><li><code>server.replid2</code></li><li><code>server.cached_master-&gt;replid</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end-start == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">new</span>,start,CONFIG_RUN_ID_SIZE);</span><br><span class="line">    <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">new</span>,server.cached_master-&gt;replid)) &#123;</span><br><span class="line">        <span class="comment">/* Master ID changed. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Master replication ID changed to %s"</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the old ID as our ID2, up to the current offset+1. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid2,server.cached_master-&gt;replid,</span><br><span class="line">            <span class="keyword">sizeof</span>(server.replid2));</span><br><span class="line">        server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the cached master ID and our own primary ID to the</span></span><br><span class="line"><span class="comment">         * new one. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">        <span class="built_in">memcpy</span>(server.cached_master-&gt;replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br></pre></td></tr></table></figure><p>如果当前Slave有Sub Slave，全部断开，让他们重新走PSYNC流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* Disconnect all the sub-slaves: they need to be notified. */</span></span><br><span class="line">                disconnectSlaves();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup the replication to continue. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        replicationResurrectCachedMaster(conn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this instance was restarted and we read the metadata to</span></span><br><span class="line"><span class="comment">         * PSYNC from the persistence file, our replication backlog could</span></span><br><span class="line"><span class="comment">         * be still not initialized. Create it. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">        <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reach this point we received either an error (since the master does</span></span><br><span class="line"><span class="comment">     * not understand PSYNC or because it is in a special state and cannot</span></span><br><span class="line"><span class="comment">     * serve our request), or an unexpected reply from the master.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise</span></span><br><span class="line"><span class="comment">     * return PSYNC_TRY_LATER if we believe this is a transient error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"-NOMASTERLINK"</span>,<span class="number">13</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(reply,<span class="string">"-LOADING"</span>,<span class="number">8</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master is currently unable to PSYNC "</span></span><br><span class="line">            <span class="string">"but should be in the future: %s"</span>, reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_TRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(reply,<span class="string">"-ERR"</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">/* If it's not an error, log the unexpected event. */</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Unexpected reply to PSYNC from master: %s"</span>, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master does not support PSYNC or is in "</span></span><br><span class="line">            <span class="string">"error state (reply: %s)"</span>, reply);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    <span class="keyword">return</span> PSYNC_NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readSyncBulkPayload-SYNC分支-接受RDB"><a href="#readSyncBulkPayload-SYNC分支-接受RDB" class="headerlink" title="readSyncBulkPayload: SYNC分支 接受RDB"></a>readSyncBulkPayload: SYNC分支 接受RDB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronously read the SYNC payload we receive from a master */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) <span class="comment">/* 8 MB */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readSyncBulkPayload</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread, readlen, nwritten;</span><br><span class="line">    <span class="keyword">int</span> use_diskless_load = useDisklessLoad();</span><br><span class="line">    redisDb *diskless_load_backup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :</span><br><span class="line">                                                        EMPTYDB_NO_FLAGS;</span><br><span class="line">    <span class="keyword">off_t</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Static vars used to hold the EOF mark, and the last bytes received</span></span><br><span class="line"><span class="comment">     * form the server: when they match, we reached the end of the transfer. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> eofmark[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> lastbytes[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> usemark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If repl_transfer_size == -1 we still have to read the bulk length</span></span><br><span class="line"><span class="comment">     * from the master reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSyncReadLine(conn,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"I/O error reading bulk count from MASTER: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"MASTER aborted replication with an error: %s"</span>,</span><br><span class="line">                buf+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">/* At this stage just a newline works as a PING in order to take</span></span><br><span class="line"><span class="comment">             * the connection live. So we refresh our last interaction</span></span><br><span class="line"><span class="comment">             * timestamp. */</span></span><br><span class="line">            server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?"</span>, buf);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* There are two possible forms for the bulk payload. One is the</span></span><br><span class="line"><span class="comment">         * usual $&lt;count&gt; bulk format. The other is used for diskless transfers</span></span><br><span class="line"><span class="comment">         * when the master does not know beforehand the size of the file to</span></span><br><span class="line"><span class="comment">         * transfer. In the latter case, the following format is used:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * At the end of the file the announced delimiter is transmitted. The</span></span><br><span class="line"><span class="comment">         * delimiter is long and random enough that the probability of a</span></span><br><span class="line"><span class="comment">         * collision with the actual file content can be ignored. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">"EOF:"</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            usemark = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="comment">/* Set any repl_transfer_size to avoid entering this code path</span></span><br><span class="line"><span class="comment">             * at the next call. */</span></span><br><span class="line">            server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF %s"</span>,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usemark = <span class="number">0</span>;</span><br><span class="line">            server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master %s"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) server.repl_transfer_size,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!use_diskless_load) &#123;</span><br><span class="line">        <span class="comment">/* Read the data from the socket, store it to a file and search</span></span><br><span class="line"><span class="comment">         * for the EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">            readlen = (left &lt; (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nread = connRead(conn,buf,readlen);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">                <span class="comment">/* equivalent to EAGAIN */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"I/O error trying to sync with MASTER: %s"</span>,</span><br><span class="line">                (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"connection lost"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server.stat_net_input_bytes += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When a mark is used, we want to detect EOF asap in order to avoid</span></span><br><span class="line"><span class="comment">         * writing the EOF mark into the file... */</span></span><br><span class="line">        <span class="keyword">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="comment">/* Update the last bytes array, and check if it matches our</span></span><br><span class="line"><span class="comment">             * delimiter. */</span></span><br><span class="line">            <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,</span><br><span class="line">                       CONFIG_RUN_ID_SIZE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">                memmove(lastbytes,lastbytes+nread,rem);</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the last I/O time for the replication transfer (used in</span></span><br><span class="line"><span class="comment">         * order to detect timeouts during replication), and write what we</span></span><br><span class="line"><span class="comment">         * got from the socket to the dump file on disk. */</span></span><br><span class="line">        server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Write error or short write writing to the DB dump file "</span></span><br><span class="line">                <span class="string">"needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                (nwritten == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"short write"</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        server.repl_transfer_read += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the last 40 bytes from the file if we reached EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Error truncating the RDB file received from the master "</span></span><br><span class="line">                    <span class="string">"for SYNC: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sync data on disk from time to time, otherwise at the end of the</span></span><br><span class="line"><span class="comment">         * transfer we may suffer a big delay as the memory buffers are copied</span></span><br><span class="line"><span class="comment">         * into the actual disk. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_transfer_read &gt;=</span><br><span class="line">            server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">off_t</span> sync_size = server.repl_transfer_read -</span><br><span class="line">                              server.repl_transfer_last_fsync_off;</span><br><span class="line">            rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_last_fsync_off, sync_size);</span><br><span class="line">            server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the transfer is now complete */</span></span><br><span class="line">        <span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the transfer is yet not complete, we need to read more, so</span></span><br><span class="line"><span class="comment">         * return ASAP and wait for the handler to be called again. */</span></span><br><span class="line">        <span class="keyword">if</span> (!eof_reached) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We reach this point in one of the following cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. The replica is using diskless replication, that is, it reads data</span></span><br><span class="line"><span class="comment">     *    directly from the socket to the Redis memory, without using</span></span><br><span class="line"><span class="comment">     *    a temporary RDB file on disk. In that case we just block and</span></span><br><span class="line"><span class="comment">     *    read everything from the socket.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. Or when we are done reading from the socket to the RDB file, in</span></span><br><span class="line"><span class="comment">     *    such case we want just to read the RDB file in memory. */</span></span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Flushing old data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to stop any AOF rewriting child before flusing and parsing</span></span><br><span class="line"><span class="comment">     * the RDB, otherwise we'll create a copy-on-write disaster. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF) stopAppendOnly();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When diskless RDB loading is used by replicas, it may be configured</span></span><br><span class="line"><span class="comment">     * in order to save the current DB instead of throwing it away,</span></span><br><span class="line"><span class="comment">     * so that we can restore it in case of failed transfer. */</span></span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load &amp;&amp;</span><br><span class="line">        server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Create a backup of server.db[] and initialize to empty</span></span><br><span class="line"><span class="comment">         * dictionaries */</span></span><br><span class="line">        diskless_load_backup = disklessLoadMakeBackups();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We call to emptyDb even in case of REPL_DISKLESS_LOAD_SWAPDB</span></span><br><span class="line"><span class="comment">     * (Where disklessLoadMakeBackups left server.db empty) because we</span></span><br><span class="line"><span class="comment">     * want to execute all the auxiliary logic of emptyDb (Namely,</span></span><br><span class="line"><span class="comment">     * fire module events) */</span></span><br><span class="line">    emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before loading the DB into memory we need to delete the readable</span></span><br><span class="line"><span class="comment">     * handler, otherwise it will get called recursively since</span></span><br><span class="line"><span class="comment">     * rdbLoad() will call the event loop to process events from time to</span></span><br><span class="line"><span class="comment">     * time for non blocking loading. */</span></span><br><span class="line">    connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Loading DB in memory"</span>);</span><br><span class="line">    rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load) &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line">        rioInitWithConn(&amp;rdb,conn,server.repl_transfer_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the socket in blocking mode to simplify RDB transfer.</span></span><br><span class="line"><span class="comment">         * We'll restore it when the RDB is received. */</span></span><br><span class="line">        connBlock(conn);</span><br><span class="line">        connRecvTimeout(conn, server.repl_timeout*<span class="number">1000</span>);</span><br><span class="line">        startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_REPLICATION,&amp;rsi) != C_OK) &#123;</span><br><span class="line">            <span class="comment">/* RDB loading failed. */</span></span><br><span class="line">            stopLoading(<span class="number">0</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization DB "</span></span><br><span class="line">                <span class="string">"from socket"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">                <span class="comment">/* Restore the backed up databases. */</span></span><br><span class="line">                disklessLoadRestoreBackups(diskless_load_backup,<span class="number">1</span>,</span><br><span class="line">                                           empty_db_flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Remove the half-loaded data in case we started with</span></span><br><span class="line"><span class="comment">                 * an empty replica. */</span></span><br><span class="line">                emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on SYNC</span></span><br><span class="line"><span class="comment">             * failure, it'll be restarted when sync succeeds or the replica</span></span><br><span class="line"><span class="comment">             * gets promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stopLoading(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RDB loading succeeded if we reach this point. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">            <span class="comment">/* Delete the backup databases we created before starting to load</span></span><br><span class="line"><span class="comment">             * the new RDB. Now the RDB was loaded with success so the old</span></span><br><span class="line"><span class="comment">             * data is useless. */</span></span><br><span class="line">            disklessLoadRestoreBackups(diskless_load_backup,<span class="number">0</span>,empty_db_flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify the end mark is correct. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rioRead(&amp;rdb,buf,CONFIG_RUN_ID_SIZE) ||</span><br><span class="line">                <span class="built_in">memcmp</span>(buf,eofmark,CONFIG_RUN_ID_SIZE) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Replication stream EOF marker is broken"</span>);</span><br><span class="line">                cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">                rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup and restore the socket to the original state to continue</span></span><br><span class="line"><span class="comment">         * with the normal replication. */</span></span><br><span class="line">        rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        connRecvTimeout(conn,<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ensure background save doesn't overwrite synced data */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replica is about to load the RDB file received from the "</span></span><br><span class="line">                <span class="string">"master, but there is a pending RDB child running. "</span></span><br><span class="line">                <span class="string">"Killing process %ld and removing its temp file to avoid "</span></span><br><span class="line">                <span class="string">"any race"</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) server.rdb_child_pid);</span><br><span class="line">            killRDBChild();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rename rdb like renaming rewrite aof asynchronously. */</span></span><br><span class="line">        <span class="keyword">int</span> old_rdb_fd = open(server.rdb_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to rename the temp DB into %s in "</span></span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                server.rdb_filename, strerror(errno));</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) close(old_rdb_fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Close old rdb asynchronously. */</span></span><br><span class="line">        <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)old_rdb_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi,RDBFLAGS_REPLICATION) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization "</span></span><br><span class="line">                <span class="string">"DB from disk"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                    <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                    <span class="string">"disabled"</span>);</span><br><span class="line">                bg_unlink(server.rdb_filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on sync failure,</span></span><br><span class="line"><span class="comment">               it'll be restarted when sync succeeds or replica promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                <span class="string">"disabled"</span>);</span><br><span class="line">            bg_unlink(server.rdb_filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">        server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">        server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Final setup of the connected slave &lt;- master link */</span></span><br><span class="line">    replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the master link modules event. */</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* After a full resynchroniziation we use the replication ID and</span></span><br><span class="line"><span class="comment">     * offset of the master. The secondary ID / offset are cleared since</span></span><br><span class="line"><span class="comment">     * we are starting a new history. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(server.replid,server.master-&gt;replid,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">    server.master_repl_offset = server.master-&gt;reploff;</span><br><span class="line">    clearReplicationId2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's create the replication backlog if needed. Slaves need to</span></span><br><span class="line"><span class="comment">     * accumulate the backlog regardless of the fact they have sub-slaves</span></span><br><span class="line"><span class="comment">     * or not, in order to behave correctly if they are promoted to</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Finished with success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Finished with success. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the initial ACK immediately to put this replica in online state. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark) replicationSendAck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restart the AOF subsystem now that we finished the sync. This</span></span><br><span class="line"><span class="comment">     * will trigger an AOF rewrite, and when done will start appending</span></span><br><span class="line"><span class="comment">     * to the new file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_enabled) restartAOFAfterSYNC();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主事件循环"><a href="#主事件循环" class="headerlink" title="主事件循环"></a>主事件循环</h1><h2 id="replicationCron"><a href="#replicationCron" class="headerlink" title="replicationCron"></a>replicationCron</h2><p>主要代码位于replication.c中。<br>主函数<code>replicationCron</code>被<code>serverCron</code>触发，每隔一秒钟触发一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_with_period(<span class="number">1000</span>) replicationCron();</span><br></pre></td></tr></table></figure><p>下面查看主函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replication.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先，下面是几个超时判断：</p><ol><li>建立连接过程中超时</li><li>传输过程中超时</li><li>心跳/数据超时</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">    (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">     slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">     (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">    freeClient(server.master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否需要连接Master。<br><code>connectWithMaster</code>这个函数会将状态设置为<code>REPL_STATE_CONNECTING</code>，并设置回调<code>syncWithMaster</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">        server.masterhost, server.masterport);</span><br><span class="line">    connectWithMaster();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Master支持PSYNC，就定期发送ACK。<br>这个ACK的作用是发送一个<code>REPLCONF ACK</code>命令给Master，从而通知自己当前的复制偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment"> * Note that we do not send periodic acks to masters that don't</span></span><br><span class="line"><span class="comment"> * support PSYNC and replication offsets. */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">    !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">    replicationSendAck();</span><br></pre></td></tr></table></figure><p>下面，我们对所有Slave发送PING。根据注释，如果我们连接了Slave（是不是说明当前节点是Master？），就按时PING它们。这样Slave们能够维护到Master的显式的超时时间，从而在TCP连接并没有真正丢失的时候，检查一个断线的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we have attached slaves, PING them from time to time.</span></span><br><span class="line"><span class="comment"> * So slaves can implement an explicit timeout to masters, and will</span></span><br><span class="line"><span class="comment"> * be able to detect a link disconnection even if the TCP connection</span></span><br><span class="line"><span class="comment"> * will not actually go down. */</span></span><br><span class="line">listIter li;</span><br><span class="line">listNode *ln;</span><br><span class="line">robj *ping_argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First, send PING according to ping_slave_period. */</span></span><br><span class="line"><span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    listLength(server.slaves))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Note that we don't send the PING if the clients are paused during</span></span><br><span class="line"><span class="comment">     * a Redis Cluster manual failover: the PING we send will otherwise</span></span><br><span class="line"><span class="comment">     * alter the replication offsets of master and slave, and will no longer</span></span><br><span class="line"><span class="comment">     * match the one stored into 'mf_master_offset' state. */</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover_in_progress =</span><br><span class="line">        server.cluster_enabled &amp;&amp;</span><br><span class="line">        server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">        clientsArePaused();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manual_failover_in_progress) &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">            ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Second, send a newline to all the slaves in pre-synchronization</span></span><br><span class="line"><span class="comment"> * stage, that is, slaves waiting for the master to create the RDB file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also send the a newline to all the chained slaves we have, if we lost</span></span><br><span class="line"><span class="comment"> * connection from our master, to keep the slaves aware that their</span></span><br><span class="line"><span class="comment"> * master is online. This is needed since sub-slaves only receive proxied</span></span><br><span class="line"><span class="comment"> * data from top-level masters, so there is no explicit pinging in order</span></span><br><span class="line"><span class="comment"> * to avoid altering the replication offsets. This special out of band</span></span><br><span class="line"><span class="comment"> * pings (newlines) can be sent, they will have no effect in the offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The newline will be ignored by the slave but will refresh the</span></span><br><span class="line"><span class="comment"> * last interaction timer preventing a timeout. In this case we ignore the</span></span><br><span class="line"><span class="comment"> * ping period and refresh the connection once per second since certain</span></span><br><span class="line"><span class="comment"> * timeouts are set at a few seconds (example: PSYNC response). */</span></span><br><span class="line">listRewind(server.slaves,&amp;li);</span><br><span class="line"><span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">    client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_presync =</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">         server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_presync) &#123;</span><br><span class="line">        connWrite(slave-&gt;conn, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">"Disconnecting timedout replica: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a master without attached slaves and there is a replication</span></span><br><span class="line"><span class="comment">     * backlog active, in order to reclaim memory we can free it after some</span></span><br><span class="line"><span class="comment">     * (configured) time. Note that this cannot be done for slaves: slaves</span></span><br><span class="line"><span class="comment">     * without sub-slaves attached should still accumulate data into the</span></span><br><span class="line"><span class="comment">     * backlog, in order to reply to PSYNC queries if they are turned into</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp; server.repl_backlog_time_limit &amp;&amp;</span><br><span class="line">        server.repl_backlog &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle = server.unixtime - server.repl_no_slaves_since;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idle &gt; server.repl_backlog_time_limit) &#123;</span><br><span class="line">            <span class="comment">/* When we free the backlog, we always use a new</span></span><br><span class="line"><span class="comment">             * replication ID and clear the ID2. This is needed</span></span><br><span class="line"><span class="comment">             * because when there is no backlog, the master_repl_offset</span></span><br><span class="line"><span class="comment">             * is not updated, but we would still retain our replication</span></span><br><span class="line"><span class="comment">             * ID, leading to the following problem:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. We are a master instance.</span></span><br><span class="line"><span class="comment">             * 2. Our slave is promoted to master. It's repl-id-2 will</span></span><br><span class="line"><span class="comment">             *    be the same as our repl-id.</span></span><br><span class="line"><span class="comment">             * 3. We, yet as master, receive some updates, that will not</span></span><br><span class="line"><span class="comment">             *    increment the master_repl_offset.</span></span><br><span class="line"><span class="comment">             * 4. Later we are turned into a slave, connect to the new</span></span><br><span class="line"><span class="comment">             *    master that will accept our PSYNC request by second</span></span><br><span class="line"><span class="comment">             *    replication ID, but there will be data inconsistency</span></span><br><span class="line"><span class="comment">             *    because we received writes. */</span></span><br><span class="line">            changeReplicationId();</span><br><span class="line">            clearReplicationId2();</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replication backlog freed after %d seconds "</span></span><br><span class="line">                <span class="string">"without connected replicas."</span>,</span><br><span class="line">                (<span class="keyword">int</span>) server.repl_backlog_time_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If AOF is disabled and we no longer have attached slaves, we can</span></span><br><span class="line"><span class="comment">     * free our Replication Script Cache as there is no need to propagate</span></span><br><span class="line"><span class="comment">     * EVALSHA at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.aof_state == AOF_OFF &amp;&amp;</span><br><span class="line">        listLength(server.repl_scriptcache_fifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    replicationStartPendingFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the RDB file used for replication if Redis is not running</span></span><br><span class="line"><span class="comment">     * with any persistence. */</span></span><br><span class="line">    removeRDBUsedToSyncReplicas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    replication_cron_loops++; <span class="comment">/* Incremented with frequency 1 HZ. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如果SLAVEOF自己会怎么样？"><a href="#如果SLAVEOF自己会怎么样？" class="headerlink" title="如果SLAVEOF自己会怎么样？"></a>如果SLAVEOF自己会怎么样？</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li><li><a href="https://youjiali1995.github.io/redis/replication/" target="_blank" rel="noopener">https://youjiali1995.github.io/redis/replication/</a></li><li><a href="https://wenfh2020.com/2020/05/31/redis-replication-next/" target="_blank" rel="noopener">https://wenfh2020.com/2020/05/31/redis-replication-next/</a><br> 有注释</li><li><a href="https://redis.io/commands/psync" target="_blank" rel="noopener">https://redis.io/commands/psync</a></li><li><a href="https://zhuanlan.zhihu.com/p/44105707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44105707</a></li><li><a href="https://zhuanlan.zhihu.com/p/86617437" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86617437</a><br> 讲解sub slave</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。&lt;/p&gt;
&lt;p&gt;主从复制涉及到RDB等机制，其中持久化部分在&lt;a href=&quot;/2021/03/13/redis-persist/&quot;&gt;Redis持久化机制实现&lt;/a&gt;中介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>重庆攻略</title>
    <link href="http://www.calvinneo.com/2021/05/09/meet-in-chongqing/"/>
    <id>http://www.calvinneo.com/2021/05/09/meet-in-chongqing/</id>
    <published>2021-05-08T17:20:33.000Z</published>
    <updated>2021-05-19T10:02:06.830Z</updated>
    
    <content type="html"><![CDATA[<p>今年五一的主题是重庆。<br>因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。</p><a id="more"></a><h1 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h1><p>首先，我们整理了一份重庆景点资料</p><ol><li>江北渝中体系：<br> 主要位于居住点附近的渝中区舌头上，这边人很多，很密集<ol><li>小什字北<br> 洪崖洞<br> 千厮门大桥</li><li>小什字南<br> 解放碑（实际上离小什字还有点远，但可以从那边走，因为下坡）<br> 长江索道<br> 湖广会馆</li><li>朝天门<br> 朝天门<br> 朝天门码头-弹子石码头</li><li>李子坝：<br> 网红轻轨，以及观景台<br> 鹅岭二厂</li><li>两路口地区<br> 山城步道<br> 宋庆龄故居<br> 两路口地铁站大扶梯</li><li>红土地地铁站</li></ol></li><li>东岸体系(实际位于南岸区)：<ol><li>弹子石<br> 杜莎夫人<br> 弹子石老街<br> 法国水师兵营旧址</li><li>南山<br> 一棵树观景园<br> 壹华里</li></ol></li><li>沙坪坝体系<ol><li>磁器口<br> 磁器口古镇<br> 白公馆<br> 渣滓洞</li></ol></li><li>九龙坡体系<ol><li>川美<br> 四川美术学院<br> 涂鸦一条街</li></ol></li></ol><p>总体来讲，重庆的行主要靠打车即可，这边无论是的士还是滴滴都非常便宜。但是需要有两点考量：</p><ol><li>打滴滴接单比较慢，并且如果在一些很有重庆特色的地方，你的定位很容易就不准，建议手动输入旁边的路名。</li><li>节假日下重庆的堵车比较严重，堵车主要分布在<ol><li>渝中区朝天宫-小什字-较场口附近，强烈建议坐地铁出渝中区再打车</li><li>途径千厮门大桥和东水关大桥，建议由地铁六号线过江</li><li>山路，例如壹华里的下山路</li><li>前往涂鸦一条街（根本打不到车，有条件的可以选择做三蹦子）</li></ol></li><li>很多地图上看起来近的点，是需要绕的</li></ol><p>同理，如果走路的话，也需要做好规划，因为高差的原因，很多地方是要绕的，会走断脚，例如：</p><ol><li>长江索道和湖广会馆</li><li>解放碑到长江索道（有个大上坡）</li><li>【打车】南滨路上东水门大桥</li><li>【打车】南滨路去较场口等区域，需要绕行重庆长江大桥</li></ol><p>由于我们住在东原1891时光道，所以我们的行程规划是：</p><ol><li>D1<br> 【午】和记火爆<br> 弹子石老街<br> 法国水师兵营旧址<br> 弹子石码头乘船到朝天门<br> 逛重庆来福士以寻找可以轻松前往地铁站的道路<br> 朝天门地铁到红土地地铁站<br> 红土地地铁站到小什字出<br> 【临时】一只酸奶牛<br> 走到解放碑步行街<br> 【临时】排队买好又来酸辣粉和玫瑰糍粑冰粉，小酥肉<br> 【晚】秦云老太婆摊摊面<br> 南滨路<br> 在小区平台看渝中区夜景</li><li>D2<br> 打车前往较场口地铁站，坐到李子坝站下<br> 观赏李子坝轻轨穿楼<br> 根据小红书上列举的short cut，从李子坝地铁站走到二厂文创公园<br> 【午】大王油茶<br> 游览二厂文创公园<br> 坐地铁前往杨家坪站<br> 【临时】重庆特色的某面包房<br> 在钟书阁排队，并参观<br> 坐233路去涂鸦一条街<br> 在涂鸦一条街寻找真正的涂鸦，发现西洋景<br> 【临时】梯坎豆花，并放弃人太多的交通茶馆<br> 从涂鸦一条街打车去九九牛肉馆<br> 【晚】九九牛肉馆（老店）<br> 从九九牛肉馆打车到壹华里公园<br> 在壹华里公园爬山，玩手机，以及观赏落日<br> 回宾馆打牌</li><li>D3<br> 【午】洪崖洞猴三火锅店<br> 重庆美术馆假装欣赏艺术<br> 在当当网书店喝一只酸奶牛，并旁听自称可能是重庆最好玩的脱口秀<br> 长江索道体验VIP待遇<br> 步行抵达洪崖洞(11楼)<br> 【晚】体验重庆KFC，并手机斗地主和充电<br> 分别参观洪崖洞的4楼和底楼<br> 挤两部电梯回到11楼，并前往千厮门大桥<br> 桥上步行观光，从大剧院站乘搭地铁，观赏洪崖洞<br> 上新街站打车回家</li></ol><h1 id="D0"><a href="#D0" class="headerlink" title="D0"></a>D0</h1><h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><p>在从红土地回来的路上，我们发现明天的长江索道票不知何时已经被定完了，于是我们只能去定人均100的讲解票，票面上说是免排队的，我感觉还是可以的。</p><h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><p>钟书阁是在这个商场的某个正数楼层，这么说是因为商场太古怪了，地下室有B1到B6，向上是L1和L2，也就是我们进来的地方，在往上又从1开始编号了。反正我们很不瑞雪地从B6上来之后，就发现了一条超级长的队——当然是去钟书阁的了。路上我还搜了钟书阁，在上海甚至无锡都有好几家，但从来没听过，所以这帮人来重庆排这家店干嘛。考虑到Z她们去上厕所了，我想着也没事做，就去排了。前面两个人是腾讯的，穿着那个灰色的文化衫，非常有辨识度。队伍的前进速度是意料之外的快，等到Z上完厕所回来，我都快到门口了。中途还有人发了一下旁边一家奶茶店的优惠券。<br>进去之后，就明白为啥这家店这么网红了，原来在一个跨越两层楼的空间的天花板上装上了玻璃，这个玻璃反射了四面墙壁上的书架和扶梯，显得很壮观。</p><p>逛完钟书阁，打算去涂鸦一条街。站在路边打车，拦车，等了好久，都没有响应。是因为打车的人太多了么？旁边倒是挤满了人，但都是往公交站台走的。我看了会两个人下棋，单车对单车单炮，很没意思。最后，我们还是选择了坐公交车，这个体验真的非常酸爽的。公交车相对是比较挤，路又很颠簸。这是一条风情街，附近应该之前是很多工厂，所以路边的人行道上隔三差五放了很多工业零件的雕塑。</p><p>过了一座桥之后，路两边的涂鸦渐渐多了起来。</p><p>到了公交站，发现路两边的房子都涂满了涂鸦，一栋楼一个风格，于是我们满心欢喜打算去涂鸦一条街，没想到这楼的涂鸦已经是巅峰了。</p><p>往前走，路过交通茶馆和蹄花店，人都在排老长的队，所以我们再往前去吃梯坎豆花。这家豆花便宜好吃，才三块钱，另外一定要加上3块钱一碗的调料。调料虽然看起来很红，但实际上并不辣。</p><p>很多清洁工在擦地。</p><p>我们顺着之前的巷子一直往前走。</p><p>越走，标语就越哲学。</p><p>走到了一所中学门边，我们准备打车。对面有人在排长队，我正好找厕所，就去看了下，原来是易烊千玺的一个雕塑在那边，大家都去合影。上完厕所回来，发现这家中学竞赛基本都是省二，但居然有3个清华，看起来重庆教育也不是很卷啊。</p><p>打车去久久牛肉馆。这趟路是最长的，大约有十几公里，但是总共也就花了五十多。</p><h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年五一的主题是重庆。&lt;br&gt;因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://www.calvinneo.com/tags/游记/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之流程概览</title>
    <link href="http://www.calvinneo.com/2021/04/24/leveldb-proc/"/>
    <id>http://www.calvinneo.com/2021/04/24/leveldb-proc/</id>
    <published>2021-04-24T15:09:06.000Z</published>
    <updated>2021-08-18T07:28:38.897Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：</p><ol><li>Memtable</li><li>SSTable</li><li>Compaction机制</li></ol><a id="more"></a><p>先跑一个Demo。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options,<span class="string">"./testdb"</span>,&amp;db);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"calvinneo"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value = <span class="string">"calvinneo@calvinneo.com"</span>;</span><br><span class="line"></span><br><span class="line">status = db-&gt;Put(leveldb::WriteOptions(), key, value);<span class="comment">//添加</span></span><br><span class="line">status = db-&gt;Get(leveldb::ReadOptions(), key, &amp;value);<span class="comment">//获取</span></span><br></pre></td></tr></table></figure><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建的逻辑实际上是在打开逻辑<code>DB::Open</code>里面分出来的。但由于这部分逻辑简单独立，并且有益于理解整个数据库的layout所以提出来单独讲。<br>首先设置几个数：</p><ol><li><code>SetLogNumber</code>将日志号设置为0</li><li><code>DescriptorFileName</code>生成Manifest文件，序号为1</li><li><code>SetNextFile</code>设置为2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::NewDB() &#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);</span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面创建Manifest文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WritableFile* file;</span><br><span class="line">Status s = env_-&gt;NewWritableFile(manifest, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一连串操作，就是把<code>new_db</code>去Encode到<code>log</code>里面，并且刷盘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">  new_db.EncodeTo(&amp;record);</span><br><span class="line">  s = <span class="built_in">log</span>.AddRecord(record);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> file;</span><br></pre></td></tr></table></figure><p>设置CURRENT指向最新的Manifest</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h1><p>调用链如下所示<br><img src="/img/leveldb/proc/recoverlink.png"></p><h2 id="DB-Open"><a href="#DB-Open" class="headerlink" title="DB::Open"></a>DB::Open</h2><p><code>DBImpl</code>的构造函数只是一个初始化成员列表，并不包含其他逻辑了。<br>在得到<code>DBImpl</code>对象后，我们首先<strong>加锁</strong>，并且调用<code>Recover</code>方法。这个方法内容是加载Manifest文件，并恢复故障。<br>值得注意的是<code>save_manifest</code>这个参数，会被通过调用链传得很深，具体作用是：</p><ol><li>在<code>RecoverLogFile</code>中可能出现Memtable被Dump的情况</li><li>在<code>Version::Recover</code>中，如果不能<code>ReuseManifest</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, DB** dbptr) &#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> DBImpl(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.Lock();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  Status s = impl-&gt;Recover(&amp;edit, &amp;save_manifest);</span><br></pre></td></tr></table></figure></li></ol><p>创建一个新的log文件。如果没有Memtable，需要创建一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                   &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetLogNumber(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> MemTable(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Q】有个问题，这里为啥还需要调用LogAndApply？因为在<code>VersionSet::Recover</code>里面已经看到有类似的过程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.SetLogNumber(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    impl-&gt;RemoveObsoleteFiles();</span><br><span class="line">    impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.Unlock();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    assert(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-Recover"><a href="#DBImpl-Recover" class="headerlink" title="DBImpl::Recover"></a>DBImpl::Recover</h2><p>首先创建数据库目录，并且加文件锁，也就是目录下的<code>LOCK</code>文件，这个函数很有意思，后面专门来讲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Recover(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">  env_-&gt;CreateDir(dbname_);</span><br><span class="line">  assert(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面我们检查db目录下有没有CURRENT文件。如果没有，我们认为数据库就不存在，如果此时设置了<code>options_.create_if_missing</code>，就创建，否则返回错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Creating DB %s since it was missing."</span>,</span><br><span class="line">        dbname_.c_str());</span><br><span class="line">    s = NewDB();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(</span><br><span class="line">        dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(dbname_,</span><br><span class="line">                                   <span class="string">"exists (error_if_exists is true)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面调用VersionSet里面的Recover函数。这个函数负责读取Manifest文件，恢复版本信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = versions_-&gt;Recover(save_manifest);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们要分析Log文件，如果有Log文件大于Manifest中记录的值，就说明这些日志是上次关闭时丢失的数据，我们需要恢复这些日志。<br>注意<code>PrevLogNumber</code>不再使用了，但是出于兼容性，我们依旧关注这个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line"><span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line"><span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line">FileType type;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br></pre></td></tr></table></figure><p><code>filenames</code>表示数据库目录下面的所有文件，我们依次遍历这些文件，并用<code>ParseFileName</code>解析出他们的number。这里的number就是诸如<code>MANIFEST-000002</code>里面的2，应该也是对应到<code>FileMetaData</code>里面的number字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">    expected.erase(number);</span><br><span class="line">    <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">      logs.push_back(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!expected.empty()) &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RecoverLogFile</code>的作用是回放日志，既然这样，就需要对日志进行排序。回放日志会修改VersionEdit，并且可能会导致Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line"><span class="built_in">std</span>::sort(logs.begin(), logs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">  s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                     &amp;max_sequence);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>MarkFileNumberUsed</code>的作用就是设置<code>next_file_number_</code>，确保<code>next_file_number_</code>要严格大于传入的<code>logs[i]</code>。即，如果小于等于传入的<code>logs[i]</code>，就将它设置为<code>logs[i]+1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;SetLastSequence(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VersionSet-Recover"><a href="#VersionSet-Recover" class="headerlink" title="VersionSet::Recover"></a>VersionSet::Recover</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::Recover(<span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先读取CURRENT文件内容，得到当前用的Manifest文件。注意，到这里为止，肯定是存在CURRENT文件的，如果不存在，<code>DBImpl::Recover</code>流程就已经会去创建了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read "CURRENT" file, which contains a pointer to the current manifest file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current;</span><br><span class="line">Status s = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current.empty() || current[current.size() - <span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT file does not end with newline"</span>);</span><br><span class="line">&#125;</span><br><span class="line">current.resize(current.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果没找到Manifest，就返回一个错误。<a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">对于这种情况，应该也是能处理的</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dscname = dbname_ + <span class="string">"/"</span> + current;</span><br><span class="line">SequentialFile* file;</span><br><span class="line">s = env_-&gt;NewSequentialFile(dscname, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.IsNotFound()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT points to a non-existent file"</span>,</span><br><span class="line">                              s.ToString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是根据Manifest文件里面的内容，读取并设置VersionSet。<br>【Q】在哪里写入的呢？答案是在<code>VersionEdit::EncodeTo</code>和<code>Writer::AddRecord</code>里面，这个函数在LogAndApply的时候被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"><span class="keyword">int</span> read_records = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.status = &amp;s;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们用一个while循环，从reader中读取记录。<br><code>ReadRecord</code>这个函数，将下一个record读入<code>*record</code>中，如果读取成功，返回true；如果EOF了，就返回false。可能会使用<code>*scratch</code>作为临时存储。<code>*record</code>是有效的，直到下一个对<code>reader</code>的变化操作，或者对<code>*scratch</code>的变化操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Slice record;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</span><br><span class="line">  ++read_records;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  s = edit.DecodeFrom(record);</span><br></pre></td></tr></table></figure><p>Manifest里面会记录当时的Comparator（用文本编辑框打开这个文件，能看到一个类名一样的东西），VersionEdit会比较这两个是否一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">      edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</span><br><span class="line">    s = Status::InvalidArgument(</span><br><span class="line">        edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</span><br><span class="line">        icmp_.user_comparator()-&gt;Name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Q】在LogAndApply实现中，<code>builder.Apply</code>之后还会跟着<code>builder.SaveTo</code>，这里为啥不跟了？稍等，Apply是一条记录Apply一次，SaveTo是最后全搞好了，一次SaveTo。我们往后看，就能看到对<code>SaveTo</code>的调用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      builder.Apply(&amp;edit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">      log_number = edit.log_number_;</span><br><span class="line">      have_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">      prev_log_number = edit.prev_log_number_;</span><br><span class="line">      have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">      next_file = edit.next_file_number_;</span><br><span class="line">      have_next_file = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">      last_sequence = edit.last_sequence_;</span><br><span class="line">      have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，这个文件就读取完毕了，我们释放这个文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line">file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-nextfile entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-lognumber entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no last-sequence-number entry in descriptor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">    prev_log_number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MarkFileNumberUsed(prev_log_number);</span><br><span class="line">  MarkFileNumberUsed(log_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是SaveTo、Finalize、AppendVersion的流程，和<code>LogAndApply</code>是类似的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">  <span class="comment">// Install recovered version</span></span><br><span class="line">  Finalize(v);</span><br><span class="line">  AppendVersion(v);</span><br><span class="line">  manifest_file_number_ = next_file;</span><br><span class="line">  next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">  last_sequence_ = last_sequence;</span><br><span class="line">  log_number_ = log_number;</span><br><span class="line">  prev_log_number_ = prev_log_number;</span><br></pre></td></tr></table></figure><p>检查是继续用现有的Manifest文件，还是重新建一个。这个可能修改<code>descriptor_file_</code>，从而影响到<code>LogAndApply</code>，但是这样的影响只会存在于Recover里面。<br>【Q】这么处理的目的是什么呢？<br>目的是为了解决Manifest文件过大的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error = s.ToString();</span><br><span class="line">    Log(options_-&gt;info_log, <span class="string">"Error recovering version set with %d records: %s"</span>,</span><br><span class="line">        read_records, error.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-RecoverLogFile"><a href="#DBImpl-RecoverLogFile" class="headerlink" title="DBImpl::RecoverLogFile"></a>DBImpl::RecoverLogFile</h2><p>【在阅读这个函数前，需要先学习<code>VersionSet::Recover</code>】<br>RecoverLogFile用于读取Log，并且将应用尚未Apply到版本的Log。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::RecoverLogFile(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</span><br><span class="line">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</span><br><span class="line">                              SequenceNumber* max_sequence) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="comment">// null if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      Log(info_log, <span class="string">"%s%s: dropping %d bytes; %s"</span>,</span><br><span class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">nullptr</span> ? <span class="string">"(ignoring error) "</span> : <span class="string">""</span>), fname,</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.ToString().c_str());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the log file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = LogFileName(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    MaybeIgnoreError(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.c_str();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="comment">// large sequence numbers).</span></span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>, <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Recovering log #%llu"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)log_number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read all the records and add to a memtable</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>现在，我们开始循环读取日志到<code>record</code>中。接着调用<code>InsertInto</code>方法将它写到Memtable中，这个方法原理我们在介绍<code>DB::Write</code>时讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (record.size() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    reporter.Corruption(record.size(),</span><br><span class="line">                        Status::Corruption(<span class="string">"log record too small"</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    mem = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">    mem-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</span><br><span class="line">  MaybeIgnoreError(&amp;status);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着我们更新<code>last_seq</code>。【Q】有点奇怪，这里为啥要加Count？参考写那一部分的分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SequenceNumber last_seq = WriteBatchInternal::Sequence(&amp;batch) +</span><br><span class="line">                                WriteBatchInternal::Count(&amp;batch) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">  *max_sequence = last_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Memtable内存超限了，就开启Minor Compaction。当然，这里是一个局部的Compaction，因为不需要维护版本，所以没有LogAndApply调用。因为也不会产生多余的文件，所以也没有<code>RemoveObsoleteFiles</code>调用。回忆一下WriteLevel0Table的实现，我们实际要做的是：</p><ol><li>生成SSTable</li><li>计算SSTable放到那哪一层</li><li>写VersionEdit</li></ol><p>如果需要将Memtable落盘，那么就要设置<code>save_manifest</code>为true。这个值是从<code>DBImpl::Open</code>开始一层一层传下来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">    compactions++;</span><br><span class="line">    *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">    mem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">      <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止，上面的while循环就结束了，我们释放掉这个日志文件。但是这里同样要看一下是否可以重新利用log文件<code>fname</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if we should keep reusing the last log file.</span></span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</span><br><span class="line">  assert(logfile_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(log_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(mem_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> lfile_size;</span><br><span class="line">  <span class="keyword">if</span> (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;</span><br><span class="line">      env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) &#123;</span><br></pre></td></tr></table></figure><p>如果重新利用Log，就不需要走到后面的<code>WriteLevel0Table</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Log(options_.info_log, <span class="string">"Reusing old log %s \n"</span>, fname.c_str());</span><br><span class="line">    log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(logfile_, lfile_size);</span><br><span class="line">    logfile_number_ = log_number;</span><br><span class="line">    <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mem_ = mem;</span><br><span class="line">      mem = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// mem can be nullptr if lognum exists but was empty.</span></span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><h3 id="PosixLockTable"><a href="#PosixLockTable" class="headerlink" title="PosixLockTable"></a>PosixLockTable</h3><p><code>PosixLockTable</code>这个类用来管理所有通过<code>LockFile</code>锁住的文件。<br>需要注意的是<code>fcntl(F_SETLK)</code>也可以实现文件锁，但是它不能保证同一个进程中的并发访问，所以在此之外，还需要再包一层。<br>【Q】为什么进程中还会有并发访问？在下文中解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PosixLockTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    <span class="keyword">bool</span> succeeded = locked_files_.insert(fname).second;</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">    <span class="keyword">return</span> succeeded;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    locked_files_.erase(fname);</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  port::Mutex mu_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="function">locked_files_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LockFile"><a href="#LockFile" class="headerlink" title="LockFile"></a>LockFile</h3><p>为了加锁，我们首先得往自己进程中的<code>PosixLockTable locks_</code>中加入加锁记录。如果加锁失败，说明这个锁已经被我们进程持有了，就退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LockFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, FileLock** lock)</span> override </span>&#123;</span><br><span class="line">  *lock = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fd = ::open(filename.c_str(), O_RDWR | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> PosixError(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!locks_.Insert(filename)) &#123;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    <span class="keyword">return</span> Status::IOError(<span class="string">"lock "</span> + filename, <span class="string">"already held by process"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们进程没有持有锁，再调用<code>LockOrUnlock</code>加文件锁。如果加锁失败，说明锁已经被其他进程占用了，这时候就要将它从<code>locks_</code>移除出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (LockOrUnlock(fd, <span class="literal">true</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> lock_errno = errno;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    locks_.Remove(filename);</span><br><span class="line">    <span class="keyword">return</span> PosixError(<span class="string">"lock "</span> + filename, lock_errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *lock = <span class="keyword">new</span> PosixFileLock(fd, filename);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixLockTable locks_;</span><br></pre></td></tr></table></figure><h3 id="LockOrUnlock"><a href="#LockOrUnlock" class="headerlink" title="LockOrUnlock"></a>LockOrUnlock</h3><p><code>LockOrUnlock</code>根据传入的<code>lock</code>对文件进行<code>F_SETLK</code>操作。<code>F_SETLK</code>是非阻塞的，还有一个<code>F_SETLKW</code>函数是阻塞的。<br><code>F_SETLK</code>可以锁定文件的某些部分，在这里，设置<code>l_start</code>和<code>l_len</code>都为0，表示锁定整个文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LockOrUnlock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> lock)</span> </span>&#123;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> :</span>:flock file_lock_info;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memset</span>(&amp;file_lock_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(file_lock_info));</span><br><span class="line">  file_lock_info.l_type = (lock ? F_WRLCK : F_UNLCK);</span><br><span class="line">  file_lock_info.l_whence = SEEK_SET;</span><br><span class="line">  file_lock_info.l_start = <span class="number">0</span>;</span><br><span class="line">  file_lock_info.l_len = <span class="number">0</span>;  <span class="comment">// Lock/unlock entire file.</span></span><br><span class="line">  <span class="keyword">return</span> ::fcntl(fd, F_SETLK, &amp;file_lock_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有关Linux进程和线程的补充说明"><a href="#有关Linux进程和线程的补充说明" class="headerlink" title="有关Linux进程和线程的补充说明"></a>有关Linux进程和线程的补充说明</h3><p>这里需要注意，Linux中pthread库创建出来的线程可能具有相同的PID，不同的TID，我们可以从下面的代码看到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gettid() syscall(SYS_gettid)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">99</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg)<span class="number">-1</span>, <span class="string">"thd %d: getpid %d gettid %d\n"</span>, *(<span class="keyword">int</span>*)index, getpid(), gettid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, start_routine, &amp;th1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2;</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, start_routine, &amp;th2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">"main: i am main\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="写"><a href="#写" class="headerlink" title="写"></a>写</h1><p>LevelDB可以通过<code>WriteBatch</code>支持批量更新的功能。当然了，作为对<code>Write</code>函数的一个简易化封装，<code>Put</code>只会更新一个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Put(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.Put(key, value);</span><br><span class="line">  <span class="keyword">return</span> Write(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写数据库的流程：</p><ol><li>写WAL</li><li>写MemTable</li><li>更新Sequence Number</li></ol><p>如下所示，写是可以并发的，因此会有类似于InnoDB中的组提交机制。<br><img src="/img/leveldb/proc/writeproc.png"></p><h2 id="DBImpl-Write"><a href="#DBImpl-Write" class="headerlink" title="DBImpl::Write"></a>DBImpl::Write</h2><p>首先，全局有个<code>writers_</code>队列，维护所有的写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新创建一个<code>DBImpl::Writer</code>这个对象，这个对象中有一个关联到<code>mutex_</code>的条件变量<code>w.cv</code>。<br>接着将这个Writer对象放到<code>writers_</code>中，然后我们等待下面的条件：</p><ol><li><code>w.done()</code><br> 表示其他线程已经帮<code>w</code>写完了。</li><li><code>w == writers_.front()</code><br> 表示这个Writer位于队头，并且抢到了锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Write(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ol><p>所以当一个写线程进入时，首先先要获得锁，这个锁可能会被其他的写入(的部分阶段)持有，或者被后台Compaction(的部分阶段)线程持有。<strong>获得锁之后，它能做的其实也就是把自己的<code>Writer</code>挂到<code>writers_</code>队列上</strong>，然后如果现在不是队头，就要去等待信号量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">writers_.push_back(&amp;w);</span><br><span class="line"><span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果从条件变量上醒过来，还是要再检查一下有没有<code>w.done()</code>，因为可能是另一个条件醒过来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">  <span class="keyword">return</span> w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面调用<code>MakeRoomForWrite</code>，如果<code>updates</code>是nullptr的话，force就是1，强制<code>MakeRoomForWrite</code>进行Compaction。<br>【Q】什么时候<code>updates</code>是nullptr呢？<code>DBImpl::TEST_CompactMemTable</code>里面有个注释，说如果设置为nullptr，就是在催促。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在<code>MakeRoomForWrite</code>之后，肯定是可以往数据库里面写东西的了。<br>我们需要得到一个Sequence Number才能写，我们首先取出上一次写的Sequence Number。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">Writer* last_writer = &amp;w;</span><br></pre></td></tr></table></figure><p><code>BuildBatchGroup</code>会合并队列里的多个写入到<code>tmp_batch_</code>里面。这个batch算作一次更新，具有<strong>全局唯一</strong>的一个Sequence Number，从之前递增而来。在合并的时候需要考虑：</p><ol><li>总写入数据大小</li><li>如果有请求是<code>sync==false</code>了，那么就不加入<code>sync==true</code>的<br>在合并结束后，<code>BuildBatchGroup</code>会更新<code>last_writer</code>，表示最后一个写入。<br>【Q】<strong>是不是可能在Memtable有两个record，他们的Sequence Number是相同的？</strong>现在看来是有可能的，这是因为批量写的话只会有一个Sequence Number。但是假如有Count个一次性写入，那么Sequence Number会在这个之后增加Count次。有点奇怪。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">  WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">  last_sequence += WriteBatchInternal::Count(write_batch);</span><br></pre></td></tr></table></figure></li></ol><p>下面是写日志的操作对应<code>AddRecord</code>。<br>【Q】根据注释，这个操作是不需要加锁的，为什么呢？<a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">文章</a>说，这样可以先让其他请求进入队列中排队。<br>这样做是安全的，因为只有一个写，就是<code>&amp;w</code>。<br>同时，可以看出这一步会给写入速度带来比较好的提升，因为只有拿到锁才能往<code>writers_</code>里面push。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line"><span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line"><span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line"><span class="comment">// into mem_.</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">  <span class="keyword">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">    status = logfile_-&gt;Sync();</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      sync_error = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据库的通用原理，写完日志，状态OK了，才能写Memtable，对应<code>InsertInto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">      <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">      <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">      <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐个弹出<code>writers_</code>里的元素，并唤起等待write的线程，直到遇到<code>last_writer</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Writer* ready = writers_.front();</span><br><span class="line">  writers_.pop_front();</span><br><span class="line">  <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">    ready-&gt;status = status;</span><br><span class="line">    ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    ready-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们处理完<code>writers</code>队列中的一个项目了，应当Signal一下，通知下一个项目进来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.empty()) &#123;</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DBImpl-BuildBatchGroup"><a href="#DBImpl-BuildBatchGroup" class="headerlink" title="DBImpl::BuildBatchGroup"></a>DBImpl::BuildBatchGroup</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: Writer list must be non-empty</span></span><br><span class="line"><span class="comment">// REQUIRES: First writer must have a non-null batch</span></span><br><span class="line">WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  Writer* first = writers_.front();</span><br><span class="line">  WriteBatch* result = first-&gt;batch;</span><br><span class="line">  assert(result != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>讨论第一个batch的大小来设置<code>max_size</code>：</p><ol><li>如果比较小<br> 就设置为<code>size + (128 &lt;&lt; 10)</code></li><li>如果还可以<br> 就设置为<code>1 &lt;&lt; 20</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size = WriteBatchInternal::ByteSize(first-&gt;batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line"><span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line"><span class="comment">// down the small write too much.</span></span><br><span class="line"><span class="keyword">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>)) &#123; <span class="comment">// 128 &lt;&lt; 10 == 1 &lt;&lt; 17</span></span><br><span class="line">  max_size = size + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>first</code>是<code>writers_</code>队头，下面，我们就遍历整个<code>writers_</code>队列，直到：</p><ol><li><strong>如果<code>first</code>是non sync的话，那么我们会在遇到第一个要加入的sync请求的时候就break掉。反之，如果<code>first</code>是sync的话，那么可以兼容non sync的请求的</strong>。</li><li>大小超限<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*last_writer = first;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt;::iterator iter = writers_.begin();</span><br><span class="line">++iter;  <span class="comment">// Advance past "first"</span></span><br><span class="line"><span class="keyword">for</span> (; iter != writers_.end(); ++iter) &#123;</span><br><span class="line">  Writer* w = *iter;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync) &#123;</span><br><span class="line">    <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w-&gt;batch != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    size += WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; max_size) &#123;</span><br><span class="line">      <span class="comment">// Do not make batch too big</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们把这些batch，全部加到<code>result</code>里面。如果涉及多个batch，result就指向<code>tmp_batch_</code>，否则就指向<code>first-&gt;batch</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Append to *result</span></span><br><span class="line">      <span class="keyword">if</span> (result == first-&gt;batch) &#123;</span><br><span class="line">        <span class="comment">// Switch to temporary batch instead of disturbing caller's batch</span></span><br><span class="line">        result = tmp_batch_;</span><br><span class="line">        assert(WriteBatchInternal::Count(result) == <span class="number">0</span>);</span><br><span class="line">        WriteBatchInternal::Append(result, first-&gt;batch);</span><br><span class="line">      &#125;</span><br><span class="line">      WriteBatchInternal::Append(result, w-&gt;batch);</span><br><span class="line">    &#125;</span><br><span class="line">    *last_writer = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-MakeRoomForWrite"><a href="#DBImpl-MakeRoomForWrite" class="headerlink" title="DBImpl::MakeRoomForWrite"></a>DBImpl::MakeRoomForWrite</h2><p><code>MakeRoomForWrite</code>用来确保我们有空间写入，如果此时Memtable满了，就需要去dump成Immutable Memtable。如果现在Level0负荷过重，那么就要延迟一下写入速度。<br>在研究这个函数时，我们要特别注意各个if条件的判断顺序，这体现了优先级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: mutex_ is held</span></span><br><span class="line"><span class="comment">// REQUIRES: this thread is currently at the front of the writer queue</span></span><br><span class="line">Status DBImpl::MakeRoomForWrite(<span class="keyword">bool</span> force) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  <span class="keyword">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br></pre></td></tr></table></figure><p>一进来，首先一个while循环。唔，这个功能为啥要有while？原因是因为里面要等待信号量的。还有一个原因是，当产生Immutable Memtable之后，我们需要等待它刷盘。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Yield previous error</span></span><br><span class="line">    s = bg_error_;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果force为false，也就是不强制执行Compaction，就认为是允许延迟的。【Q】其实我没搞懂这个逻辑。<br>如果允许延迟，并且Level0的文件数达到至少8个，那么就开始慢速写。注意，Level0层最大文件数不是4，这是个误区。当有4个文件的时候开始Compaction，当有12个文件的时候，才停止写入。<br>慢速写的实现就是主线程睡1000ms，这个时候后台的Compaction线程是可以开始Compact的。在睡眠结束之后，要将<code>allow_delay</code>设为false，也就是说对于一次写，我们只慢速一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line">                              config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">  <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">  <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">  <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">  <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">  <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line">  allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">  mutex_.Lock();</span><br></pre></td></tr></table></figure><p>下面，如果不强制Compaction，并且Memtable的大小没有超标，那么就啥都不要做，这个应该是最通常的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">           (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">  <span class="comment">// There is room in current memtable</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果此时上一轮Immutable Memtable还没有Minor Compact完毕，那么我们就在<code>background_work_finished_signal_</code>这个条件变量上面等待。<br>我们注意到在进入这个函数时是持有<code>mutex_</code>的，所以这个生产者消费者模式是安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">  <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Current memtable full; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure><p>同理，如果Level0满了，即达到12个文件了，那我们同样要在信号量上等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Too many L0 files; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure><p>对于剩余的情况，我们要将Memtable改成Immutable Memtable。<br>同时，我们注意到这个分支并不会在最后break掉！这是因为此时有了Immutable Memtable了，我们需要等它被刷成SSTable落盘，所以至少还需要一次while循环。<br>这个这个刷盘过程等到什么时候呢？</p><ol><li>对于<code>CompactMemTable</code>来说，至少要执行完LogAndApply之后，才会将<code>imm_</code>设置为nullptr。</li><li>而这个条件变量，在<code>MaybeScheduleCompaction</code>调用完之后会被Signal。当然，需要注意，在Major Compaction过程中，如果有Immutable Memtable需要落盘，那么还是要先执行<code>CompactMemTable</code>的，在这个之后，也会触发一次Signal。<br>注意，这一次刷盘还可能会导致Level0文件达到上限，那就要等更久了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><ol><li>读要加锁么？<br> 我们首先考虑分布式共识这一块，为了实现一致读写，Raft即使是读请求，也需要走一遍LogEntry的。而ZK的话，可以选择直接读，所以未必是一致读。<br> 当然，这个离题了。我觉得根据LevelDB的MVCC模式，其实至少有一部分是可以不加锁的。</li><li>在哪些地方可以非线性地查找？<br> 在非0层找SSTable时，见FindFile。<br> 在BlockReader返回Iterator之后，可以通过Seek来二分。</li><li>在读取的时候会做缓存么？<br> LevelDB在Table和Block两个层面进行缓存。<br> 在Table层面通过TableCache。<br> 在Block层面通过BlockReader里面的<code>table-&gt;rep_-&gt;options.block_cache</code>分支。</li></ol><h2 id="DBImpl-Get"><a href="#DBImpl-Get" class="headerlink" title="DBImpl::Get"></a>DBImpl::Get</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br></pre></td></tr></table></figure><p>可以看到，在获取了<code>current</code>之后，就可以解锁了。<br>【Q】<strong>这里还取出了<code>mem_</code>和<code>imm_</code>，是不是在MVCC下面，可能同时存在多个<code>mem_</code>和<code>imm_</code>？</strong>此时，永远写最新的Memtable，但是可能会读旧的Memtable。<br>下面就是经典的读取三部曲：</p><ol><li>首先看Memtable</li><li>然后看Immutable Memtable</li><li>然后就去SSTable里面找，具体是调用<code>current-&gt;Get</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">  <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">    have_stat_update = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，锁要重新加回来。<br>【Q】看起来读操作也会触发Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-Get"><a href="#Version-Get" class="headerlink" title="Version::Get"></a>Version::Get</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>这个函数根据smallest和largest找到对应的文件。<br>容易想到<code>func</code>的作用是在文件里面找key。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Version::ForEachOverlapping(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span><br><span class="line">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*)) &#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br></pre></td></tr></table></figure><p>从Compaction一文的介绍中了解到，<code>files_</code>里面存放了当前Version中所有SSTable的元信息。<br>我们首先要遍历第0层的所有文件，放到<code>tmp</code>里面，按照<code>f-&gt;number</code>排序。排完序，我们就开始查找，在文件中查找需要借助于传入的<code>func</code>，实际上是<code>State::Match</code>这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp.reserve(files_[<span class="number">0</span>].size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].size(); i++) &#123;</span><br><span class="line">  FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp.push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，就可以用之前介绍过的<code>FindFile</code>来二分查找了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].size();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State类"><a href="#State类" class="headerlink" title="State类"></a>State类</h3><p>State类中主要定义了从SSTable中找对应Key的函数<code>Match</code>。<br>在研究之前，我们先来复习一下SSTable的格式：</p><ol><li>data block</li><li>meta block</li><li>meta index block</li><li>index block<br> 记录每个data block的“largest”，满足<a href="/2021/04/12/leveldb-sstable/">两个性质</a>。<br> <strong>注意，这里的largest不是单纯的largest，而要进行一些修正</strong>，它实际上是分隔两个Data Block的最短Key，</li><li>footer<br> 记录index block和meta index block的位置</li></ol><p>所以，我们要先通过index block去定位data block，得到这个data block。</p><p>接着，我们复习一下block的格式</p><ol><li>record</li><li>restart</li><li>额外信息<br> num restarts<br> type<br> crc32<br>所以，我们要用LookupKey先去找restart，然后从restart开始找。</li></ol><p>同时，我们注意由于，meta block的存在，会有一些优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">  Saver saver;</span><br><span class="line">  GetStats* stats;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions* options;</span><br><span class="line">  Slice ikey;</span><br><span class="line">  FileMetaData* last_file_read;</span><br><span class="line">  <span class="keyword">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">      state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">      state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">      state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> kNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">      <span class="keyword">case</span> kFound:</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kDeleted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kCorrupt:</span><br><span class="line">        state-&gt;s =</span><br><span class="line">            Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TableCache-Get和TableCache-FindTable"><a href="#TableCache-Get和TableCache-FindTable" class="headerlink" title="TableCache::Get和TableCache::FindTable"></a>TableCache::Get和TableCache::FindTable</h3><p>TableCache这一块是一个缓存层，如果缓存中没有，才去读SSTable，并把它加到缓存里面。Get的第一步是FindTable，先介绍这个。<br>首先在<code>cache_</code>里面查文件的handle，如果没找到，就新建一个，并且调用<code>Table::Open</code>从文件中读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  Slice key(buf, sizeof(buf));</span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;</span><br><span class="line">        s = Status::OK();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>TableAndFile</code>就是打包<code>RandomAccessFile*</code>和<code>Table*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      assert(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看Get函数，现在我们已经能得到对应的<code>Table*</code>了，此时调用<code>InternalGet</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span><br><span class="line">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                             <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;InternalGet(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-InternalGet"><a href="#Table-InternalGet" class="headerlink" title="Table::InternalGet"></a>Table::InternalGet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                          <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                                <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);</span><br><span class="line">  iiter-&gt;Seek(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;Valid()) &#123;</span><br><span class="line">    Slice handle_value = iiter-&gt;value();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br></pre></td></tr></table></figure><p>首先，可以通过布隆过滤器判断这个block里面有没有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">    !filter-&gt;KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">  <span class="comment">// Not found</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>由于布隆过滤器可能假阳，所以这边还需要实际Seek一下。我们<a href="/2021/04/12/leveldb-sstable/">先前</a>介绍过<code>BlockReader</code>，这个函数返回一个Iterator。实际上是一个<code>Block::Iter</code>对象。<br>当时他被用在创建<code>TwoLevelIterator</code>里面，这个双层迭代器实际上就是index block上的迭代器和data block上的迭代器的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      Iterator* block_iter = BlockReader(<span class="keyword">this</span>, options, iiter-&gt;value());</span><br><span class="line">      block_iter-&gt;Seek(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;Valid()) &#123;</span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;key(), block_iter-&gt;value());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = iiter-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-Open"><a href="#Table-Open" class="headerlink" title="Table::Open"></a>Table::Open</h3><p>【这一部分可以先不读，因为所有对SSTable的读key请求，最后都是从Cache里面处理了】<br><code>Table::Open</code>负责读取SSTable到表对象<code>Table</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="line">                   <span class="keyword">uint64_t</span> size, Table** table) &#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先读取footer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">Slice footer_input;</span><br><span class="line">Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                      &amp;footer_input, footer_space);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">Footer footer;</span><br><span class="line">s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><p>再读取block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主体函数"><a href="#主体函数" class="headerlink" title="主体函数"></a>主体函数</h3><p>主要就是构造一个state，然后调用<code>ForEachOverlapping</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats) &#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.internal_key();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  state.saver.user_key = k.user_key();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><h2 id="Manifest损坏-丢失"><a href="#Manifest损坏-丢失" class="headerlink" title="Manifest损坏/丢失"></a>Manifest损坏/丢失</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://luodw.cc/2015/10/30/leveldb-14/" target="_blank" rel="noopener">http://luodw.cc/2015/10/30/leveldb-14/</a><pre><code> 介绍WriteBatch</code></pre></li><li><a href="https://zhuanlan.zhihu.com/p/340804308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340804308</a><pre><code> 介绍Revocer逻辑</code></pre></li><li><a href="https://blog.csdn.net/sparkliang/article/details/9311487" target="_blank" rel="noopener">https://blog.csdn.net/sparkliang/article/details/9311487</a><pre><code> 介绍RecoverLogFile</code></pre></li><li><a href="https://izualzhy.cn/leveldb-write-read" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-write-read</a><br> 介绍了LevelDB读写流程，我使用了它的部分图片</li><li><a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">https://leeshine.github.io/2019/01/24/leveldb-put-get/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_10_details.html</a><br> 讲述多线程写的demo，很值得一看</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://www.cnblogs.com/cobbliu/p/6194072.html" target="_blank" rel="noopener">https://www.cnblogs.com/cobbliu/p/6194072.html</a><br> 介绍SSTable、Block的格式，一张大图，非常屌</li><li><a href="https://blog.csdn.net/weixin_42663840/article/details/82629473" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42663840/article/details/82629473</a><br> 我见过最屌有关读写的注释</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Memtable&lt;/li&gt;
&lt;li&gt;SSTable&lt;/li&gt;
&lt;li&gt;Compaction机制&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之Compaction实现</title>
    <link href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/"/>
    <id>http://www.calvinneo.com/2021/04/18/leveldb-compaction/</id>
    <published>2021-04-18T15:09:06.000Z</published>
    <updated>2021-08-18T07:26:48.196Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：</p><ol><li>Minor Compaction<br> 对应Memtable到SSTable的过程。</li><li>Major Compaction<br> 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。<br> Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。</li></ol><p>在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。</p><p>同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。</p><a id="more"></a><p>我们首先来回顾一下LevelDB的整体架构<br><img src="/img/leveldb/compaction/arch.png"></p><p>之前提到过，当一个Memtable满了之后，会转化为Immutable Memtable。Immutable Memtable会被Dump成SSTable文件，SSTable文件是不可变的。<br>这里<code>GUARDED_BY(m)</code>实际上是<code>__attribute__(guarded_by(m))</code>这个线程安全注解，方便编译器帮助检查有没有遗漏掉加锁的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="LCS和STCS"><a href="#LCS和STCS" class="headerlink" title="LCS和STCS"></a>LCS和STCS</h2><p>有两种Compacton方案：Size-Tiered Compaction Strategy(STCS)和Leveled Compaction Strategy(LCS)。</p><h3 id="STCS"><a href="#STCS" class="headerlink" title="STCS"></a>STCS</h3><p>Memtable刷成小sstable。当这些小的sstable达到一定个数时，会被compact成一个稍大些的sstable。当稍大些的sstable又达到一定个数时，又会被一起compact成更大的sstable。当然，如果说某些Key的更新频率比较高，那么在Compact的时候只会取最新的Sequence Number，这种情况下，可能不会增加太多。<br>下图是STCS的一个示意，可以看到，每层的SSTable<strong>数量不变</strong>，但是大小<strong>越来越大</strong>。<br><img src="/img/leveldb/compaction/STCS.png"></p><h3 id="LCS-Classic-Leveled"><a href="#LCS-Classic-Leveled" class="headerlink" title="LCS(Classic Leveled)"></a>LCS(Classic Leveled)</h3><p>STCS存在一些问题，是可以被优化的：</p><ol><li>存储放大1<br> 因为Compaction时，在新SSTable生成前，旧的SSTable不能删除（当然LevelDB中有Version的概念，其实更复杂点），所以可能会造成额外一倍的开销。<br> 于是我们临机一动，我们增加SSTable数量，而控制大小不变，不就能控制这额外一倍开销的绝对数量么？</li><li>存储放大2<br> 如果Key更新频繁，可能导致同一个Level以及不同Level中的SSTable中存在相同的Key。这里的Key实际上就是LevelDB里面的user key，而不是带有Sequence Number的InternalKey。<br> 【Q】为什么不同Level会存在呢？</li></ol><p>为此，我们就得到了LCS：</p><ol><li>当Level0层数量达到Level0层阈值时，将这些SSTable和L1层的所有SSTable做Compaction。<br> 实际上，具体涉及哪些SSTable，在LevelDB中控制更为精细。并且Compaction的条件也更复杂。</li><li>如果Level1层的SSTable数量还是超过L1层的阈值，再把这些超出的SSTable向上做Compaction。</li><li><strong>除了Level0，其他层的所有SSTable中的key都是不重叠的。</strong></li></ol><p>下图是LCS的一个示意<br><img src="/img/leveldb/compaction/LCS.png"></p><p>我们注意到，LCS中，SSTable的大小不变，但是数量会增多，Level N+1的<strong>文件数量</strong>是Level N的10倍。【Q】这里看上去和LevelDB的实现还有区别，LevelDB里面的<code>MaxBytesForLevel</code>函数更多的是计算了10倍的大小，Why？这个我们在“Major Compaction流程”章节中讨论过了，每个文件大小是固定的，LevelDB通过限制每层的总大小来间接限制文件数量。这是因为我们dump的时候更方便统计大小而不是文件数量。<br>所以，假如Level1有10个文件，Level2就有100个文件。但是key在两个level中都是均匀分布的，因此我Level1拿出一个文件出来，Level2中估计只会有10个文件和它重叠，所以我们只需要合并重叠的这些文件就行了。<br>当然，Level0彼此重叠，所以还是emmmm。。。</p><p>LCS的缺点是写放大会比STCS显著提高。</p><p>【Q】既然LCS的写放大高了很多，为什么说基于LSM的写性能很好呢？可能是因为下面几点</p><ol><li>SSTable是顺序写，性能好【Q】</li><li>根据<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">RocksDB</a>的文档，在一些情况下写放大不是很严重<br> 首先是按key顺序的写，对于这种情况RocksDB可以优化。<br> 其次是有skew的写，会导致只有小部分的key被更新。</li></ol><h3 id="Level-N"><a href="#Level-N" class="headerlink" title="Level-N"></a>Level-N</h3><p>相比LCS(Classic Leveled)有更高的读放大，和更小的写放大。</p><h3 id="Tiered-Leveled"><a href="#Tiered-Leveled" class="headerlink" title="Tiered+Leveled"></a>Tiered+Leveled</h3><h1 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h1><p>需要注意的是，LevelDB是一个单机的数据库，所以实际承载的SSTable文件都位于一台机器上。</p><p><img src="/img/leveldb/compaction/cm.png"></p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType &#123;</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>kLogFile：WAL日志文件，文件名数字.log</li><li>kDBLockFile：db锁文件，文件名LOCK</li><li>kTableFile：SSTable文件，文件名数字.sst</li><li>kDescriptorFile：Manifest文件，存储VersionEdit信息，文件名为MANIFEST-数字<br> 对应<code>descriptor_file_</code>这个字段。<br> Manifest文件中维护了所有的SSTable的key范围，层级，以及其他的元信息。</li><li>kCurrentFile：记录当前的Manifest文件，文件名为CURRENT</li><li>kTempFile：临时文件，db在修复【？】过程中会产生临时文件，文件名为数字.dbtmp</li><li>kInfoLogFile：日志文件，文件名为LOG</li></ol><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>每一个VersionEdit对应Manifest里面的一个Entry，<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">称为Session Record</a>。<br><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">其中第一条Session Record包含当时LevelDB的全量版本信息</a>，这个应该是通过<code>WriteSnapshot</code>来实现的，可以看下面的介绍。</p><p>如下所示，每个Entry包含</p><ol><li>增加的SSTable<br> kNewFile</li><li>删除的SSTable<br> kDeletedFile</li><li>当前Compaction的下标<br> kCompactPointer</li><li>日志文件编号<br> kLogNumber</li><li>数据库已经持久化数据项中最大的Sequence Number<br> kLastSequence</li></ol><p>对应的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/leveldb/compaction/manifest.png"></p><p>写Manifest的代码应该是<code>Writer::AddRecord</code>。<br>读Manifest的代码，例如<code>VersionSet::Recover</code>。</p><h2 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h2><p>记录当前的Manifest文件名。</p><h1 id="MVCC介绍"><a href="#MVCC介绍" class="headerlink" title="MVCC介绍"></a>MVCC介绍</h1><p>参考<a href="/2017/09/20/transaction/">数据库系统中的事务</a></p><h1 id="Version机制"><a href="#Version机制" class="headerlink" title="Version机制"></a>Version机制</h1><p>大前提，Compaction过程是通过独立线程异步并发执行的。因此可能出现压缩前后的新老SSTable并存的情况。同时，我们不能立即删除老的SSTable文件，这可能是因为这个SSTable还在被读取，而要等到老SSTable的引用计数为0才行。因此Version机制可以用来辨别这些SSTable的版本。借助于Version机制，也能实现MVCC。</p><p>新版本New-Version由<code>Version</code>类和<code>VersionEdit</code>类来描述。即<code>VersionEdit</code>是New-Version相对于Version的改动。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-<span class="keyword">Version</span> = <span class="keyword">Version</span> + VersionEdit</span><br></pre></td></tr></table></figure><p><img src="/img/leveldb/compaction/version.png"></p><p>LevelDB将所有的Version置于一个双向链表之中，因此所有的Version组成一个名为VersionSet的集合。这个集合也代表了当前DB的状态，包含了最新的Version，以及其他正在服务的Version。<br><img src="/img/leveldb/compaction/versionset.png"></p><h2 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h2><p>介绍作为桥梁作用的<code>VersionEdit</code>类。这个类里面的方法大部分是用来读写里面的私有成员的，所以只介绍私有成员。</p><ol><li><p><code>std::string comparator_;</code></p></li><li><p><code>uint64_t log_number_;</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure><p> log文件的file number，也就是<code>000003.log</code>的这个3。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">小于这个值的Log是可以被删除的</a><br> 【Q】这个字段的作用是什么呢？<br> 目前来看，在Recover的时候会用到。<br> 【Q】为什么VersionSet里面也有？<br> 其实VersionSet里面的才是主要的，VersionEdit里面的这个字段，是在LogAndApply的时候，由VersionSet设置过来的。<br> 【Q】这个number，和版本的关系是什么，是一一对应的么？比如一次Compaction之后就要换个log？因为在实现上，可以看到<code>NewFileNumber</code>会产生log(<code>DB::Open</code>)和SSTable(<code>WriteLevel0Table</code>)文件的序列号。</p></li><li><p><code>uint64_t prev_log_number_;</code>/<code>bool has_prev_log_number_;</code><br> 包括<code>void SetPrevLogNumber(uint64_t num)</code>这个函数。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">这篇文章</a>说<code>prev_log_number_</code>已经废弃了，出于兼容性才保留的。</p></li><li><p><code>uint64_t next_file_number_;</code>/<code>bool has_next_file_number_;</code><br> 下一个可用的file number。VersionSet里面也有类似字段，详细介绍见VersionSet。<br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>SequenceNumber last_sequence_;</code>/<code>bool has_last_sequence_;</code><br> SSTable 中的最大的Sequence Number。VersionSet里面也有个平行的。</p></li><li><p><code>bool has_comparator_;</code></p></li><li><p><code>bool has_log_number_;</code></p></li><li><p><code>std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</code><br> 主要用于Major Compaction的时候选择文件。first表示每个level。<br> 【Q】在<code>Compaction</code>类和<code>VersionSet</code>类里面也有一个这个字段。它们的作用是什么呢？</p></li><li><p><code>DeletedFileSet deleted_files_;</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br></pre></td></tr></table></figure><p> pair存储了level和file。表示将第level层中的file删除。</p></li><li><p><code>std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</code><br> <code>FileMetaData</code>存储了文件大小，以及文件中最小的Key和最大的Key。</p></li></ol><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h3 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h3><ol><li><p>VersionSet相关<br> 指向这个Version所属的VersionSet，以及双向链表和引用计数。<br> 所以说每个Version只能属于一个VersionSet，这个也是很好理解的，</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"><span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br></pre></td></tr></table></figure></li><li><p>SSTable相关<br> <code>files_</code>表示LevelDB中每一层中所有的SSTable的文件信息。<br> <code>file_to_compact(_level)_</code>标记下一个要Compact的文件以及属于的Level。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure><p> 根据<code>SaveTo</code>函数的<a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">论述</a>，**<code>files_[level]</code>是有序的**。</p></li><li><p>其他字段<br> <code>compaction_score_</code><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">计算最迫切需要Compaction的Level</a>，所以可以决定是否需要发起Major Compaction。这个分数取决于某一层所有SSTable的大小。<br> <code>NeedsCompaction</code>会读取这个字段，计算是否需要根据Version的情况来Compaction，并呈递给<code>MaybeScheduleCompaction</code>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"><span class="comment">// Score &lt; 1 means compaction is not strictly needed.</span></span><br><span class="line"><span class="keyword">double</span> compaction_score_;</span><br><span class="line"><span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure></li></ol><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol><li><code>int PickLevelForMemTableOutput(const Slice&amp; smallest_user_key, const Slice&amp; largest_user_key);</code><br> 给定一个Memtable里面的Key的范围，返回这个Memtable被Dump的话要放到第几层。</li><li><code>Compaction* PickCompaction();</code><br> 用来处理size compaction和seek compaction。<br> 这个函数，在“Compaction主函数”这个章节介绍。</li><li><code>Compaction* CompactRange(int level, const InternalKey* begin, const InternalKey* end);</code></li></ol><h3 id="Version-PickLevelForMemTableOutput"><a href="#Version-PickLevelForMemTableOutput" class="headerlink" title="Version::PickLevelForMemTableOutput"></a>Version::PickLevelForMemTableOutput</h3><h4 id="OverlapInLevel"><a href="#OverlapInLevel" class="headerlink" title="OverlapInLevel"></a>OverlapInLevel</h4><p>先介绍辅助函数<code>OverlapInLevel</code>，作用是判断范围<code>[smallest_user_key,largest_user_key]</code>和level中的文件有没有Overlap。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Version::OverlapInLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span><br><span class="line">                             <span class="keyword">const</span> Slice* largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                               smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SomeFileOverlapsRange"><a href="#SomeFileOverlapsRange" class="headerlink" title="SomeFileOverlapsRange"></a>SomeFileOverlapsRange</h4><p>SomeFileOverlapsRange返回<code>files</code>中有没有在范围<code>[smallest_user_key,largest_user_key]</code>中的key，是<code>OverlapInLevel</code>的辅助函数。<br><code>disjoint_sorted_files</code>表示传入的<code>files</code>里面的key是不是不相交的，一般除了Level0，其他都是不相交的。<br><code>AfterFile</code>和<code>BeforeFile</code>都比较FileMetaData里面的<code>largest</code>/<code>smallest</code>的<code>user_key()</code>字段。他们的类型是<code>InternalKey</code>，也就是不带Sequence Number和Value Type的。<br>对于普通情况，对于一个文件<code>f</code>，如果<code>smallest_user_key</code>大于该文件中的最大值，或者<code>largest_user_key</code>小于最小值，那么认为是不重叠的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SomeFileOverlapsRange</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> disjoint_sorted_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = icmp.user_comparator();</span><br><span class="line">  <span class="keyword">if</span> (!disjoint_sorted_files) &#123;</span><br><span class="line">    <span class="comment">// Need to check against all files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      <span class="keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||</span><br><span class="line">          BeforeFile(ucmp, largest_user_key, f)) &#123;</span><br><span class="line">        <span class="comment">// No overlap</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Overlap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是不相交的文件，就可以基于<code>FindFile</code>对<code>files</code>集合二分查找，<strong>所以我们看到，在某一个Level找SSTable的时候是可以二分的</strong>。<br>可以思考一下我们用什么做二分的key呢？答案是每个file的largest。我们要找到第一个largest大于等于<code>smallest_user_key</code>的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Binary search over file list</span></span><br><span class="line">  <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (smallest_user_key != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Find the earliest possible internal key for smallest_user_key</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">small_key</span><span class="params">(*smallest_user_key, kMaxSequenceNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">                          kValueTypeForSeek)</span></span>;</span><br><span class="line">    index = FindFile(icmp, files, small_key.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= files.size()) &#123;</span><br><span class="line">    <span class="comment">// beginning of range is after all files, so no overlap.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>二分法找到<strong>可能存在</strong>的文件<code>files[index]</code>后，不要忘了在判断下这个文件<strong>实际有没有overlap</strong>。这是二分法的基本规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span><br><span class="line">                                        <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先判断我们要加入的文件的<code>[smallest_user_key,largest_user_key]</code>和Level0有没有交叠。如果有交叠，就进不了这个if，直接放到第一层，等后面Major Compaction了。<br>如果没有交叠，我们尝试能否将它下放到<code>config::kMaxMemCompactLevel</code>之前的层。【Q】为什么我们要设置上限<code>kMaxMemCompactLevel</code>呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为什么会有这个？下面讲。</span></span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断level-2层情况的分支详解"><a href="#判断level-2层情况的分支详解" class="headerlink" title="判断level + 2层情况的分支详解"></a>判断level + 2层情况的分支详解</h4><p>这里需要着重讲解一下<code>level + 2 &lt; config::kNumLevels</code>这个分支的含义。</p><p>作为普通人呢，我觉得判断完<code>OverlapInLevel(level + 1,...</code>就可以直接<code>level++</code>了啊，但是大佬肯定是不平凡的。<br>大佬觉得现在我们想把文件放到level + 1层，但是要先打住，看看level + 2层是什么情况，也就对应到下面的代码。我们要计算所有重叠的文件的总大小，如果这个大小超过了阈值，那么我们就不把这个SSTable进行下放。<br>这是防止level + 1和level + 2的重叠范围太大，导致这两层进行Compaction时涉及的SSTable过多，耗时过长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickLevelForMemTableOutput中的片段代码</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>于是，先要用<code>GetOverlappingInputs</code>这个函数，计算level + 2层中到底有哪些文件和<code>[smallest_user_key,largest_user_key]</code>有交叠，这些文件会放到<code>overlaps</code>里面。<br>而<code>TotalFileSize</code>这个函数就是对<code>FileMetaData::file_size</code>求和。<br>然后，我们和<code>MaxGrandParentOverlapBytes</code>返回的阈值进行比较。</p><h4 id="GetOverlappingInputs-MaxGrandParentOverlapBytes"><a href="#GetOverlappingInputs-MaxGrandParentOverlapBytes" class="headerlink" title="GetOverlappingInputs/MaxGrandParentOverlapBytes"></a>GetOverlappingInputs/MaxGrandParentOverlapBytes</h4><p><code>GetOverlappingInputs</code>的目标是找到level中和<code>[begin,end]</code>重叠的所有文件，并放到<code>inputs</code>里面。这个函数对Level0有特殊的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="keyword">void</span> Version::GetOverlappingInputs(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span><br><span class="line">                                   <span class="keyword">const</span> InternalKey* end,</span><br><span class="line">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs) &#123;</span><br></pre></td></tr></table></figure><p><code>user_begin</code>和<code>user_end</code>是从InternalKey中提取出的user key。如果传入nullptr，表示在比较时<code>begin</code>永远小于任何key。<br>【Q】这里为什么去找的user key而不是InternalKey呢？貌似很多地方都是找user key。在<a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">这篇文章</a>中，作者指出了一个其实我们很容易注意到的性质，就是除了Level0，每一层Level都是有序的。进一步地，由于LevelDB使用leveled策略(LCS)，即强调一个key在每一层至多只有1条记录，不存在冗余记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; config::kNumLevels);</span><br><span class="line">  inputs-&gt;clear();</span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (begin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = begin-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = end-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>默认，我们遍历这一层的所有的文件。前面两个if分别处理文件和range完全不重叠的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>否则就是有重叠的，我们把这个文件加入到<code>inputs</code>里面作为结果返回。对于<code>PickLevelForMemTableOutput</code>的逻辑而言，这里就到此为止了。<br>但是<code>GetOverlappingInputs</code>这个函数还会在<code>CompactRange</code>、<code>SetupOtherInputs</code>这些函数中用到。此时，需要处理Level0的逻辑。<strong>【Q】且慢，我们已经逐文件遍历了啊，还会有什么问题呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">这篇文章</a>中，详细解释了原因。这是因为我们认为Level1的文件是比Level0要旧的，所以<strong>如果要把Level0中的某个文件<code>f</code>移动到Level1中，我们要把Level0中所有和<code>f</code>Overlap的文件都放到Level1里面</strong>。这样，实际上保证了如果我有一个Key在Level0里面，那么inputs里面会包含所有包含这个Key的文件。</p><p>进一步想，在Level0往Level1归并的时候，其实也应该看到这个过程。事实上观看<code>PickCompaction</code>的代码实现，我们也能看到在最后有个<code>if (level == 0)</code>的判断。</p><p>这个应当同样解决我们在<code>IsTrivialMove</code>的一个疑问，也就是为什么Level层有两个的时候，我们不能简单把其中一个文件移动到下层。</p><p>所以，当检查到<code>user_begin</code>在文件<code>[file_start,file_limit]</code>中后，需要将<code>user_begin</code>调整为文件的开头<code>file_start</code>。对<code>user_end</code>也是同理的。</p><h2 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h2><h3 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h3><ol><li><code>Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu)</code><br> 这个函数接受一个VersionEdit。<br> 首先，函数将VersionEdit应用在<code>current_</code>，并借助于<code>VersionSet::Builder</code>生成一个新的Version。Builder类的实现是比较巧妙的，我们会在稍后来讲解。<br> 此后，它会调用<code>Finalize</code>函数更新<code>compaction_level_</code>和<code>compaction_score_</code>。<br> 此后，更新Manifest文件。主要是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。<br> 此后，调用<code>AppendVersion</code>将新版本添加到VersionSet的双向链表中，并且设置新的<code>current_</code>。</li><li><code>std::string compact_pointer_[config::kNumLevels];</code><br> 这个字段在Major Compaction过程中被用到。表示每一层上，下一次Compaction需要开始的key的位置。它要么是一个空串，要么是一个InternalKey。<br> 【Q】在什么时候被设置呢？<br> 根据<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">文章</a>，这个<code>compact_pointer_</code>实际上表示这一层上一次Compact时文件的largest。</li><li><code>Status Recover(bool* save_manifest);</code><br> 关于Recover机制，我们不在这篇文章中介绍。详见“LevelDB之流程概览”这篇文章。</li></ol><p>有关Sequence：</p><ol><li><code>uint64_t LastSequence() const { return last_sequence_; }</code><br> 还有个对应的<code>SetLastSequence</code>方法。<br> 返回最近的Sequence Number。这个是在写入记录的时候会使用并且更新。<br> 【Q】VersionEdit里面也有个平行的，他们之间的关系是什么呢？<br> 首先VersionSet的<code>last_sequence_</code>会随着<code>DBImpl::Write</code>操作更新。<br> 当需要进行Compact的时候，会在<code>LogAndApply</code>中赋给VersionEdit中的对应字段。而VersionEdit的目的，似乎只是持久化这个信息。</li></ol><p>有关日志：</p><ol><li><code>prev_log_number_</code>/<code>log_number_</code><br> 【Q】和VersionEdit里面同名字段的关系是什么？见VersionEdit的解释。</li></ol><p>有关文件编号：</p><ol><li><p><code>next_file_number_</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">    next_file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个字段用来生成系统中下个文件的编号。VersionEdit需要在LogAndApply时传入，以persist。<br> 【Q】这里的file number指的是SSTable的file number么？<a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">看起来并不是的</a>，而是<a href="https://www.wandouip.com/t5i49833/" target="_blank" rel="noopener">Manifest文件、SSTable文件啥的共用一个编号</a>，这也是为什么一开始Log文件是0，Minifest文件是1，SetNextFile是2的原因。</p></li><li><p><code>manifest_file_number_;</code><br> 表示Manifest文件的编号，主要在Recover时用到</p></li></ol><p>疑问：</p><ol><li>VersionSet和DBImpl是一一对应的么？<br> 应该是的，DBImpl持有一个<code>VersionSet*</code>。</li></ol><h3 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h3><p>在前面已经简单介绍过这个函数的功能了。这个函数主要在下面几个地方用到：</p><ol><li><code>DB::Open</code><br> 当DB启动的时候，可能需要从通过<code>DBImpl::Recover</code>从log中恢复一部分数据。这些数据会以VersionEdit的方式被Apply。</li><li><code>DBImpl::CompactMemTable</code><br> Minor Compaction。<br> 一般在下面的地方调用：<ul><li>BackgroundCompaction</li><li>DoCompactionWork：也就是在Major Compaction的过程中也要有限处理Minor Compaction。</li></ul></li><li><code>BackgroundCompaction</code>的非manual情况（平凡情况）<br> 这种情况只是将某个SSTable移动到别的层。</li><li><code>BackgroundCompaction</code>的manual情况（一般情况）<br> 需要归并。</li></ol><p>下面这里讲解一下源码。<br><code>__attribute__((exclusive_locks_required))</code>表示检查在调用<code>LogAndApply</code>函数之前就要持有锁<code>mu</code>。因此同时只会有一个线程执行<code>LogAndApply</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">  <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是把VersionSet的LogNumber传给VersionEdit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们要把VersionSet的<code>last_sequence_</code>传给edit，在对<code>VersionSet::Builder</code>的论述中已经推断过这里的作用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">  Finalize(v);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的<code>descriptor_file_</code>就是一个Manifest文件。<br>如果此时<code>descriptor_log_</code>是NULL，根据注释，这个对应到首次打开数据库的状态。我们要新建一个Manifest文件，此时<code>DescriptorFileName</code>产生一个<code>&quot;/MANIFEST-%06llu&quot;</code>格式的文件名字。<br>通过<code>WriteSnapshot</code>把<code>descriptor_log_</code>写到新的Manifest文件里面，这个实际上就是Current Version的快照。<code>WriteSnapshot</code>里面也会调用<code>EncodeTo</code>和<code>AddRecord</code>。<br>【Q】为什么有这个函数？本文之前介绍了Manifest文件的构造，里面提到第一条Session Record记录了当前数据库的全量数据，我认为这里就是实现这个性质的。<br>【Q】注意，<code>VersionSet::ReuseManifest</code>也会修改这个<code>descriptor_log_</code>，有什么影响呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。这里不是写快照了，而是写一条Log。其实Manifest文件的格式就是Log。<br>在这里，将写文件的操作都集中在一起，期间是不要加锁的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>EncodeTo</code>将信息按照下面的Tag分类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>AddRecord</code>将信息编码到文件中，对应的读取函数是<code>Reader::ReadRecord</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们现在得到了一个新的Version即<code>v</code>，调用<code>AppendVersion</code>将它设置为<code>current_</code>。这个函数还会将<code>v</code>添加到VersionSet里面的那个双向链表里面。<br><a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">文章</a>中有疑问这里遇到多线程怎么办，但LevelDB中Compact只有一条后台线程，并且这里是持有锁的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VersionSet-AppendVersion"><a href="#VersionSet-AppendVersion" class="headerlink" title="VersionSet::AppendVersion"></a>VersionSet::AppendVersion</h3><p>这里<code>dummy_versions_</code>是VersionSet维护的环状链表头，<code>dummy_versions_.prev_</code>就是<code>current_</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::AppendVersion(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">下面的图</a>清晰看出<br><img src="/img/leveldb/compaction/versionset_link.png"></p><h3 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h3><ol><li><code>VersionSet* vset_;</code><br> 在构造时传入的VersionSet。</li><li><code>Version* base_;</code><br> 在构造时传入的，一般为<code>current_</code></li><li><code>LevelState levels_[config::kNumLevels];</code><br> LevelState里面记录了增加和删除的文件。</li><li><code>void Apply(VersionEdit* edit)</code><br> 将<code>edit</code>里面的变动应用到<code>current_</code>。例如要加些什么文件，写到<code>levels_[level].added_files</code>这个列表里面。但是我们不实际加，而是到<code>SaveTo</code>里面再一次性加。<br> 【Q】为什么要这样子呢？原因有2：<ol><li><code>v-&gt;files_[level]</code>这个是有序存储的。</li></ol></li><li><code>void SaveTo(Version* v)</code><br> 注意，从<code>VersionSet::Recover</code>可以看出，Applt和SaveTo并不是一对一的关系。例如我们从一个文件中多个记录里面恢复，那么每读取一个记录就要Apply一次，但最后再SaveTo。</li></ol><h4 id="VersionSet-Builder-Apply"><a href="#VersionSet-Builder-Apply" class="headerlink" title="VersionSet::Builder::Apply"></a>VersionSet::Builder::Apply</h4><p>这个函数设置诸如<code>levels_[level].added_files</code>的字段，表示我们需要做什么改变。<br>首先将VersionEdit记录的<code>compact_pointers_</code>应用到VersionSet。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后把要增加和删除的文件记录到自己的<code>levels_</code>字段里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在增加文件的时候，需要处理<code>allowed_seeks</code>字段。这里的<code>16384U</code>有点奇怪，是啥意思？<br>根据注释，我们假设：</p><ol><li>一次Seek耗时10ms</li><li>读写1MB耗时10ms，也就是我们的IO速度是100MB/s</li><li>一次Compaction，假设是1MB，需要消耗25MB的IO<ol><li>需要从这一层读取1MB</li><li>从下一层读取10-12MB的数据(boundaries may be misaligned)</li><li>写10-12MB的数据到下一层</li></ol></li></ol><p>这说明25次Seek的开销等于1MB数据的Compaction成本，也就是一次Seek大概摊还下来是40KB数据的压缩成本。我们做一些保留，让16KB对应一次Compaction，也就是允许更多的Seek次数。<br>同时，我们将<code>f-&gt;allowed_seeks</code>最小值设为100，这样也不会一直Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// 16*1024</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VersionSet-Builder-SaveTo"><a href="#VersionSet-Builder-SaveTo" class="headerlink" title="VersionSet::Builder::SaveTo"></a>VersionSet::Builder::SaveTo</h4><p><code>SaveTo</code>的最终影响是<code>MaybeAddFile</code>，也就是说将文件添加到Version里面。具体是添加到<code>v-&gt;files_</code>里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  BySmallestKey cmp;</span><br><span class="line">  cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的循环中，我们依次处理每一层的合并。主要内容是：</p><ol><li>将添加的文件合并到<code>files_</code></li><li>删除文件</li></ol><p>之前介绍过<code>base_</code>在构造时传入，一般为CURRENT，我们就是要对<code>base_</code>去应用这些修改。<br>所以，我们是</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_-&gt;files_<span class="string">[level]</span> + (levels_<span class="string">[level]</span>.added_files - levels_<span class="string">[level]</span>.deleted_files) = v-&gt;files_<span class="string">[level]</span></span><br></pre></td></tr></table></figure><p><code>base_iter</code>用来遍历原有的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">    <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们首先<strong>预留最大空间，避免到时候的频繁动态分配</strong>。但是实际上最终未必用到这个空间，因为<code>MaybeAddFile</code>不一定真的添加文件。<br>下面就是插入操作，这个有点奇怪。我们先初始化了<code>bpos</code>，但是循环中自增的却是<code>base_iter</code>，<code>for(A;B;C)</code>里面A和C的主语不一样，很奇怪。其实<code>bpos</code>标记了我们要遍历的终点。具体解释一下，这个函数其实是一个归并的过程，分两步：</p><ol><li>插入原有的<code>base_</code>里面的文件，这些文件要小于等于<code>added_file</code><br> <code>std::upper_bound</code>找到第一个大于<code>added_file</code>的位置<code>bpos</code>，也就是我们的<code>base_iter</code>往后遍历，不会超过<code>bpos</code>。<br> 我们用<code>MaybeAddFile</code>插入，因为这些文件可能已经被标记删除。</li><li>插入<code>added_file</code></li></ol><p>**那么这么做的好处在哪里呢？我认为是减少了比较的次数，从O(n)到了O(logn)**。因为我们这里是<code>BytewiseComparator</code>，是两个Slice之间的比较，所以开销还是比较大的，这里是值得学习的一个Best Practice。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">      <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">               <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">           base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MaybeAddFile(v, level, added_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add remaining base files</span></span><br><span class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">      MaybeAddFile(v, level, *base_iter);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在Debug的状态下，会去检查除Level0之外的层有没有重叠。检查方法也很简单，就是看后一个文件的smallest是不是一定<strong>严格</strong>大于前一个文件的largest。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">        <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                       prev_end.DebugString().c_str(),</span><br><span class="line">                       this_begin.DebugString().c_str());</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VersionSet-Builder-MaybeAddFile"><a href="#VersionSet-Builder-MaybeAddFile" class="headerlink" title="VersionSet::Builder::MaybeAddFile"></a>VersionSet::Builder::MaybeAddFile</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;</span><br><span class="line">      <span class="comment">// Must not overlap</span></span><br><span class="line">      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                  f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;refs++;</span><br><span class="line">    files-&gt;push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VersionSet-Finalize"><a href="#VersionSet-Finalize" class="headerlink" title="VersionSet::Finalize"></a>VersionSet::Finalize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是针对第0层的特殊情况。我们知道LevelDB的第0层最多存在4个文件【Q】（我觉得未必，详见<code>kL0_SlowdownWritesTrigger</code>），这就是由<code>kL0_CompactionTrigger</code>控制的。这里使用文件数量，注释里面列了两个原因：</p><ol><li>允许更大的写buffer，从而减少Level0 Compaction的数量。<br> 这里的写buffer应该是<code>options_.write_buffer_size</code>这个东西。这个阈值控制Memtable何时转换成Immutable Memtable，以及在Recover的时候何时直接dump成SSTable。<br> 佶屈聱牙，实际上的意思是，这个意思是，如果写buffer太大，如果我们用固定的size限制死了的话，可能Level0的文件数量会很少，比如就1个，这样会导致频繁的Level0 Compaction。</li><li>Level0的文件每次读取都会被Merge。我们不希望有很多个小文件(perhaps because of a small write-buffer setting, or very high compression ratios, or lots of overwrites/deletions)。<br> 如果写buffer很小，这样会导致更多的Level0文件。因为Level0的文件是overlap的，所以如果数量过多，每次查询需要Seek的文件数量就越多。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      score = v-&gt;files_[level].size() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger); <span class="comment">// ==4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于第1层以下的层，计算文件总大小，而不是文件数量了。<code>MaxBytesForLevel</code>的大概意思就是Level1总大小是10M，下面每一层翻10倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h3><p>这个函数计算每一层的最大大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>将自己从链表中移除。<br>对于自己管理的所有文件，引用计数减一。【Q】这边不搞个原子操作么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LevelDB对MVCC的实现总结"><a href="#LevelDB对MVCC的实现总结" class="headerlink" title="LevelDB对MVCC的实现总结"></a>LevelDB对MVCC的实现总结</h2><h4 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h4><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">文章</a>中论述了一次版本升级的过程，但我会批注一下具体实现的函数和逻辑</p><ol><li>新建一个Session Record，记录状态变更信息</li><li>讨论版本升级原因<ol><li>Minor Compaction或者日志replay<br> 在Session Record中记录新增的文件信息、最新的journal编号、数据库sequence number以及下一个可用的文件编号。</li><li>Major Compaction<br> 在Session Record中记录新增、删除的文件信息、下一个可用的文件编号即可。</li></ol></li><li>通过VersionEdit生成新版本<br> 相较于旧的版本信息，新的版本信息更改的内容为：<ol><li>每一层的文件信息：在<code>VersionSet::Builder::Apply</code>中。</li><li>每一层的计分信息：在<code>VersionSet::Finalize</code>中。</li></ol></li><li>将Session Record持久化<br> 在<code>VersionSet::Builder::SaveTo</code>中。</li><li>讨论是否是第一条Session Record<br> 在LogAndApply的Finalize调用之后的部分<ol><li>是<br> 新建一个Manifest文件，并将完整的版本信息全部记录进Session Record作为该Manifest的基础状态写入，同时更改Current文件，将其指向新建的Manifest。</li><li>不是<br> 将该条Session Record进行序列化后直接作为一条记录写入即可。</li></ol></li><li>将当前的Version设置为刚创建的Version<br> 这个会修改<code>current_</code>的指向。这个操作应该是原子的（不然最新版本岂不是会不一致么）实际上也在<code>mutex_</code>的保护下。<br> 在LogAndApply对<code>AppendVersion</code>的调用中。</li></ol><h1 id="Snapshot机制"><a href="#Snapshot机制" class="headerlink" title="Snapshot机制"></a>Snapshot机制</h1><p>我们在这里介绍Snapshot机制，主要是为了方便说明它对Compaction的影响：导致同一个user key的不同的Sequence Number版本存在多个。</p><p>Snapshot实际上就是某个特定的Sequence Number。<br>【Q】Sequence Number是全局递增的么？应该是这样的，在Put和Get的实现中，看到的都是读取的<code>VersionSet::LastSequence()</code>这个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Compaction主函数"><a href="#Compaction主函数" class="headerlink" title="Compaction主函数"></a>Compaction主函数</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><ol><li>BackgroundCompaction<ol><li>BackgroundCall<ol><li>BGWork<ol><li>MaybeScheduleCompaction<br> 会Schedule方法<code>BGWork</code>。<br> 这个函数在BackgroundCall，以及诸如Get等读写方法中都会被调用。</li></ol></li></ol></li></ol></li></ol><h3 id="Compaction条件"><a href="#Compaction条件" class="headerlink" title="Compaction条件"></a>Compaction条件</h3><ol><li>Minor Compaction<br> 在Recover过程中<code>ApproximateMemoryUsage</code>检测到<strong>Memtable</strong>超限，会直接触发对Memtable的Compaction。但这个Compaction是局部的，因为我们在恢复过程中，所以不需要诸如LogAndApply这种维护Version的工作。<br> 存在Immutable Memtable</li><li>Manual Compaction<br> CompactRange调用</li><li><code>size_compaction</code><br> 在<code>VersionSet::PickCompaction</code>中检查并启动。<br> 当Level0文件数目过多，或者某个Level的总大小过大。<br> 在函数<code>NeedsCompaction</code>中判断当前Version的<code>compaction_score_ </code>(size compaction)和<code>file_to_compact_</code>(seek compaction)。</li><li><code>seek_compaction</code><br> seek次数太多。我们知道，当一个文件找不到时，就需要到高一级的Level中去查找。假如在<code>Level(n)</code>中没找到，但是在<code>Level(n+1)</code>中找到了，就认为<code>Level(n)</code>有一次未命中。容易发现如果未命中次数多了，就说明Level N和Level N+1<br> 的文件overlap很厉害，这就需要通过一次Major Compaction来解决这个问题。</li></ol><h2 id="DBImpl类"><a href="#DBImpl类" class="headerlink" title="DBImpl类"></a>DBImpl类</h2><p>LevelDB通过<code>class DB</code>对外暴露C++接口，这个<code>DB</code>的实现就是<code>DBImpl</code>。</p><h2 id="DBImpl-BackgroundCall"><a href="#DBImpl-BackgroundCall" class="headerlink" title="DBImpl::BackgroundCall"></a>DBImpl::BackgroundCall</h2><p>BackgroundCall是在后台线程中执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>MakeRoomForWrite</code>函数会在<code>background_work_finished_signal_</code>等待Compaction结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-MaybeScheduleCompaction"><a href="#DBImpl-MaybeScheduleCompaction" class="headerlink" title="DBImpl::MaybeScheduleCompaction"></a>DBImpl::MaybeScheduleCompaction</h2><p>函数<code>MaybeScheduleCompaction</code>决定是否进行Compaction。<br>这里需要加锁，不然可能会导致开两个后台进程，而LevelDB只允许一个后台进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PosixEnv-Schedule"><a href="#PosixEnv-Schedule" class="headerlink" title="PosixEnv::Schedule"></a>PosixEnv::Schedule</h3><p>这里的<code>env_</code>的实现实际上是一个<code>PosixEnv</code>。<br>我们查看源码，原来这个后台进程只有一个<code>started_background_thread_</code>，一开始先检查它是否存在，如果不存在，就创建一个，然后detach掉。<br>接下来就是一个生产者消费者模式。不过有点奇怪，是先Signal，再入队，不应该先修改条件，再Signal么。<br>我在<a href="/2017/12/28/Concurrency-Programming-Compare/">文章</a>中提过<a href="http://www.cppblog.com/Solstice/archive/2015/10/30/203094.html" target="_blank" rel="noopener">陈硕大佬的一篇博客</a>，在CV语境中，<a href="https://gist.github.com/chenshuo/6430925" target="_blank" rel="noopener">先Signal，再设置条件flag(代码里面的Case 6)</a>也是可以的，但只限于单waiter使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::Schedule(</span><br><span class="line">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg) &#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.detach();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放一下消费者的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::BackgroundThreadMain() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixEnv::PosixEnv()</span><br><span class="line">    : background_work_cv_(&amp;background_work_mutex_),</span><br><span class="line">      started_background_thread_(<span class="literal">false</span>),</span><br><span class="line">      mmap_limiter_(MaxMmaps()),</span><br><span class="line">      fd_limiter_(MaxOpenFiles()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="NeedsCompaction"><a href="#NeedsCompaction" class="headerlink" title="NeedsCompaction"></a>NeedsCompaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Compaction类"><a href="#Compaction类" class="headerlink" title="Compaction类"></a>Compaction类</h2><p>定义在version_set.h文件里面。</p><h3 id="主要成员和成员函数"><a href="#主要成员和成员函数" class="headerlink" title="主要成员和成员函数"></a>主要成员和成员函数</h3><ol><li><code>std::vector&lt;FileMetaData*&gt; inputs_[2];</code><br> 表示这个Compaction涉及的两个level的文件，也就是输入。<br> 其中level层是<code>inputs_[0]</code>。level + 1层是<code>inputs_[1]</code>，称为parents。</li><li><code>std::vector&lt;FileMetaData*&gt; grandparents_;</code><br> level + 2层的文件，通常称为grandparents。</li><li><code>int level() const { return level_; }</code><br> 我们将<code>level_</code>和<code>level_+1</code>层进行压缩。</li><li><code>int num_input_files(int which) const</code></li><li><code>bool IsTrivialMove() const;</code><br> 是否可以直接移动，而不涉及merge或者split操作。</li><li><code>bool ShouldStopBefore(const Slice&amp; internal_key);</code></li><li><code>VersionEdit* edit() { return &amp;edit_; }</code>/<code>edit_</code><br> 这个应该很好理解，Compaction肯定会有文件增删，即使是移动，也是跨层的。所以这里需要一个<code>VersionEdit</code>来描述。</li></ol><h3 id="IsTrivialMove"><a href="#IsTrivialMove" class="headerlink" title="IsTrivialMove"></a>IsTrivialMove</h3><p>这个函数用来判断在Major Compaction的时候能不能直接移动老的文件到下面一层，而不归并生成新的文件，条件有三个：</p><ol><li>level层只有一个<br> 【Q】疑问：如果level层有多个，level+1层没有，那么我直接移动到下面一层也是安全的？那么禁止这么做的目的是什么？<br> 检查对<code>GetOverlappingInputs</code>的分析，发现可能是不安全的。如果说Level0的某个文件<code>f</code>和Level1的文件有Overlap，那么就必须要扫描整个Level0层的所有文件，将与<code>f</code>有Overlap的文件都要移到下一层。</li><li>level + 1层没有<br> 这个原因应该好理解，如果level+1层有，那么我们就得比较和这个文件有没有Overlap。</li><li>和level + 2层的overlap没有超过阈值(实际上是20M)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Compaction::IsTrivialMove() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-BackgroundCompaction"><a href="#DBImpl-BackgroundCompaction" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>这个过程是Compaction的主过程，需要全程持锁。</p><h3 id="Minor"><a href="#Minor" class="headerlink" title="Minor"></a>Minor</h3><p>我们首先需要去<code>CompactMemTable</code>，也就是Minor Compaction。这个肯定是优先级更高的，因为我们只有两个Memtable，所以我们肯定想把Immutable Memtable快速腾空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Major"><a href="#Major" class="headerlink" title="Major"></a>Major</h3><p>详见Major Compaction章节</p><h1 id="Minor-Compaction流程"><a href="#Minor-Compaction流程" class="headerlink" title="Minor Compaction流程"></a>Minor Compaction流程</h1><h2 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h2><p>主要流程三部分：</p><ol><li>WriteLevel0Table<ol><li>将Immutable Memtable生成SSTable文件<br> 这个文件的基本信息写到<code>FileMetaData</code>里面，并在最后写入<code>VersionEdit</code>。<br> 注意，在Recover的过程中，这里其实也可以传入Memtable。</li><li>计算添加到哪一层<br> 这个文件未必会放到Level0，可能会直接放到Level1甚至Level2，具体由<code>kMaxMemCompactLevel</code>控制。</li><li>将上面说的<code>FileMetaData</code>写入VersionEdit<br> 因此这个函数的实际返回是传入的<code>VersionEdit* edit</code>。</li></ol></li><li>LogAndApply<br> 用我们得到的<code>VersionEdit</code>，去更新数据库状态，并记录。</li><li>RemoveObsoleteFiles<br> 重置Immutable Memtable。<br> 删除无用文件。主要包括<code>kLogFile</code>/<code>kLogFile</code>/<code>kTableFile</code>等。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::CompactMemTable() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，就是要把<code>edit</code>应用到当前的VersionSet上。<br>【Q】<code>SetPrevLogNumber</code>是啥意思？为啥要设置为0呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h2><p>在前文中，已经介绍过了<code>WriteLevel0Table</code>的作用，下面看实现。</p><p>首先，我们计算出一个<code>NewFileNumber</code>，也就是落盘时体现的文件名。关于这个函数，我们之前已经介绍过了，体现在诸如<code>MANIFEST-xxxxx</code>或者<code>yyyyy.log</code>这里的序号。</p><p><code>pending_outputs_</code>中保存了所有正在Compact的SSTable文件，这些文件不能被删除。这引发了我两个问题：</p><ol><li>什么时候会删除？<br> 在<code>RemoveObsoleteFiles</code>里面，马上就能看到了，不急不急</li><li>为什么在BuildTable之后就可以删除了？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,</span><br><span class="line">                                Version* base) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，<code>BuildTable</code>创建一个<code>TableBuilder</code>写入数据。值得注意的是，这里并没有加锁。我之前认为这是因为<code>BuildTable</code>里面会自带加锁，但是检查代码并没有。这可能是因为Compaction是单独的线程，诸如生成并写SSTable的过程是可以单独提出来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>新生成的文件未必会放到Level0，可能会直接放到Level1。例如，如果新的SSTable文件和Level1中的文件没有重叠，那么就<strong>有可能</strong>被放到Level1，具体还需要查看Level2和新SSTable的重叠情况。因此<code>PickLevelForMemTableOutput</code>会生成一个level，表示放到哪一层。<br>下面的<code>edit-&gt;AddFile</code>就是将这个SSTable加到当前的VersionEdit中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>env_</code>实际上是封装了文件系统等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RemoveObsoleteFiles"><a href="#RemoveObsoleteFiles" class="headerlink" title="RemoveObsoleteFiles"></a>RemoveObsoleteFiles</h2><p>搞清楚几个问题：</p><ol><li>清理文件的范围？看<code>env_-&gt;GetChildren</code>的实现，应该是所有这个db下的文件。</li><li>清理文件的类型？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::RemoveObsoleteFiles() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don't know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;live);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  env_-&gt;GetChildren(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files_to_delete;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;LogNumber()) ||</span><br><span class="line">                  (number == versions_-&gt;PrevLogNumber()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations'</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;ManifestFileNumber());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into "live"</span></span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.push_back(<span class="built_in">std</span>::move(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;Evict(number);</span><br><span class="line">        &#125;</span><br><span class="line">        Log(options_.info_log, <span class="string">"Delete type=%d #%lld\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;RemoveFile(dbname_ + <span class="string">"/"</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Major-Compaction流程"><a href="#Major-Compaction流程" class="headerlink" title="Major Compaction流程"></a>Major Compaction流程</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><p>在开始研究Major Compaction前，我们主动思考这个问题</p><ol><li><p>对于Level0里面的文件，是不是可以直接和Level1中的文件Merge？<br> 答案是不行的，见<code>GetOverlappingInputs</code>的论述。</p></li><li><p>如果level中的某个文件的key的range过大，它可能和level+1层的很多文件有重合，这样的compaction写放大很重，如何解决这个问题？<br> 首先，这也是为什么LevelDB要分成很多层的原因，在Merge的时候，最多和下一层中的所有文件Overlap，写放大是可控的。<br> 其次，在Compact的时候，LevelDB一直关注和level+2层的key的重叠情是否超过一定量，即<code>MaxGrandParentOverlapBytes</code>函数。</p><ul><li>在<code>ShouldStopBefore</code>判断是否要结束当前SSTable写入，新开文件的时候，考虑当前文件和level+2的Overlap，如果过了，就新开文件。</li><li>在<code>IsTrivialMove</code>判断是否可以直接移动文件到下层的时候，考虑要移动的文件和level+2层的Overlap，如果过了，就不能移动。</li><li>在<code>PickLevelForMemTableOutput</code>选择Minor Compaction的层时，考虑这个Immutable Memtable的Overlap，如果过了，就不能放在这一层。</li></ul></li><li><p>从level到level+1的Compaction会对level+2产生什么影响？</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">LevelDB</a>中多个不相干的合并是可以并发进行的，这个的实现是怎样的？<br> 需要注意，Level0文件是彼此Overlap的，所以是相干的。<br> 【Q】那么当一个Major Compaction开始的时候，是如何判定是否相干，如果不相干就不Compact的呢？从LevelDB的代码来看，只有一个后台线程进行Compact操作，所以我认为虽然在设计上LSM树是允许并行Compact的，但是LevelDB并没有实现，但RocksDB肯定是实现的。</p></li><li><p>LevelDB中，每个user key在一层中是不是只会出现一次？<br> 大多数情况是的，有两个例外。<br> 首先，Level0是Overlap的，可能有多个。<br> 其次，如果使用了Snapshot，那么在下层可能也会有user key相同，但是sequence不同的。见<code>AddBoundaryInputs</code>的论述。</p></li><li><p>我们往Manifest文件里面写了什么？</p></li><li><p>LevelDB有容量限制么？<br> <a href="https://stackoverflow.com/questions/31742460/is-there-record-number-limit-in-leveldb" target="_blank" rel="noopener">应该是没有的，但是当最下面一层变得特别大之后，Compaction的开销会很大</a>。</p></li><li><p>LevelDB到底是限制的每一层的文件数量还是大小？<br> 【Q】如果限制的是总大小，如果保证生成的SSTable的大小是大致相同的？<br> 对于Major Compaction来说，是在<code>DoCompactionWork</code>里面通过下面的代码来判断的，也就是说当文件大小达到一定规模后，就会产生新的文件了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">   compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br></pre></td></tr></table></figure><p> 这个调用最后会转到<code>options-&gt;max_file_size</code>上。</p></li><li><p>LevelDB每一层的文件数量有限制么？<br> 首先Level0肯定有，大家说是4个么？我觉得不是。参考下面的代码，4只是表示有4个文件就开始Level0的Compaction。当文件数达到12个，才是上限，这个时候就要停止写了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Soft limit on number of level-0 files.  We slow down writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_SlowdownWritesTrigger = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of level-0 files.  We stop writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_StopWritesTrigger = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>LevelDB底层SSTable中的数据永无出头之日么？<br> 怎么可能，只要数据被修改，那么就会先到Memtable里面。</p></li><li><p>Compaction是如何删除文件的？<br> 注意，即使遍历到有删除标记的，并且这个删除标记的序列号最大。我们也不应该尝试删除，至少要检查下面的层有没有。详见DoCompactionWork</p></li></ol><h2 id="DBImpl-BackgroundCompaction-1"><a href="#DBImpl-BackgroundCompaction-1" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>下面是对Major Compaction的处理。</p><h3 id="计算Compaction对象"><a href="#计算Compaction对象" class="headerlink" title="计算Compaction对象"></a>计算Compaction对象</h3><p>首先，我们要处理Manual Compaction的情况。如果<code>manual_compaction_</code>不是null，就触发Manual Compaction。我没看到非测试的代码里面有设置<code>manual_compaction_</code>的，但是<code>leveldb_compact_range</code>这个api会显示调用<code>CompactRange</code>，并且<code>DB</code>这个接口中也有<code>CompactRange</code>方法，也就是说，LevelDB对外暴露这个方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其次，我们调用<code>PickCompaction</code>处理size compaction和seek compaction的情况。<code>PickCompaction</code>会返回当前要Compact的文件，如果返回null，就啥事都不做。对于<code>PickCompaction</code>而言，如果既没有size compaction，又没有seek compaction，返回null。</p><p><strong>这个过程是持锁的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 前面是对Minor Compaction的处理</span></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="根据Compaction对象进行Compact操作"><a href="#根据Compaction对象进行Compact操作" class="headerlink" title="根据Compaction对象进行Compact操作"></a>根据Compaction对象进行Compact操作</h3><p>经过上面的代码，我们就得到了一个<code>Compaction* c</code>对象。<br>如果之前<code>PickCompaction</code>没给出这个<code>c</code>，那么就说明这一次不要Compact。<br>如果满足<code>IsTrivialMove</code>条件，就可以不生成新的文件，直接将原文件移动到下一层。<br>对于Trivial的情况我们直接更新<code>c-&gt;edit()</code>，不走<code>InstallCompactionResults</code>的逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Nothing to do</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">  <span class="comment">// Move file to next level</span></span><br><span class="line">  assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">  FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">  c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                     f-&gt;largest);</span><br><span class="line">  status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">      status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>如果不满足<code>IsTrivialMove</code>条件，就是一般情况，由<code>DoCompactionWork</code>处理。<br><code>DBImpl::CompactionState</code>这个类又封装了<code>Compaction</code>，这是因为要处理两个Level之间的合并，所以要加一些额外的字段。<br>然后我们要<code>CleanupCompaction</code>，这个除了清空compact对象，还需要根据<code>compact-&gt;outputs</code>，找到<code>pending_outputs_</code>里面对应的文件，并移除出<code>pending_outputs_</code>。我们知道<code>compact-&gt;outputs</code>记录了每个输出文件的元信息，而<code>pending_outputs_</code>记录了正在compact的文件，我们compact结束，就把这些文件移出去。在Major Compaction中，文件是在<code>DoCompactionWork -&gt; OpenCompactionOutputFile</code>中被加入<code>pending_outputs_</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">  status = DoCompactionWork(compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  CleanupCompaction(compact);</span><br><span class="line">  c-&gt;ReleaseInputs();</span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure><h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>如果是Manual的，需要清空Manual状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;done) &#123;</span><br><span class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">      <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">      m-&gt;tmp_storage = manual_end;</span><br><span class="line">      m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">    &#125;</span><br><span class="line">    manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-PickCompaction"><a href="#Version-PickCompaction" class="headerlink" title="Version::PickCompaction"></a>Version::PickCompaction</h2><p>size compaction的优先级是高于seek compaction的。<br>遍历<code>current_-&gt;compaction_level_</code>这一层的所有文件，找到第一个largest大于<code>compact_pointer_[level]</code>的文件，放到<code>Compaction* c</code>的<code>inputs_[0]</code>中。<br>如果一轮循环下来没找到，说明所有的文件的largest都小于<code>compact_pointer_[level]</code>，也就是这一层所有的key都小于<code>compact_pointer_[level]</code>，那就把第一个文件放进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Compaction* VersionSet::PickCompaction() &#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于seek compaction，把要Compact的那个文件加到<code>c-&gt;inputs_[0]</code>就行，逻辑很简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">  level = current_-&gt;file_to_compact_level_;</span><br><span class="line">  c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">  c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Level0，有个特别的处理，这个参考<code>GetOverlappingInputs</code>函数的说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;input_version_ = current_;</span><br><span class="line">c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们已经得到了<code>c-&gt;inputs_[0]</code>。<strong>除了<code>c-&gt;inputs_[0]</code>的情况，否则<code>c-&gt;inputs_[0]</code>里面都只有一个文件</strong>。<br>通过<code>SetupOtherInputs</code>可以计算<code>c-&gt;inputs_[1]</code>，也就是level+1层涉及哪些文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-SetupOtherInputs"><a href="#Version-SetupOtherInputs" class="headerlink" title="Version::SetupOtherInputs"></a>Version::SetupOtherInputs</h2><p><code>SetupOtherInputs</code>计算在Compaction时，level+1层涉及哪些文件。在这个函数之后，我们就得到了正确的<code>c-&gt;inputs_</code>数组、<code>c-&gt;grandparents_</code>字段，以及<code>compact_pointer_</code>字段。在这个函数之后，<code>PickCompaction</code>就结束了，<code>BackgroundCompaction</code>会执行后面的流程，也就是<code>DoCompactionWork</code>。<br>基本的思想是：所有和level层有重叠的level+1层文件都要参与Compact。得到这些文件后，反过来看下，利用这些level+1层的文件，能不能Compact更多level层的文件？<br>这个函数被<code>CompactRange</code>和<code>PickCompaction</code>调用，也就是所有的Major Compaction逻辑都会走到这里。</p><h3 id="GetRange和GetRange2"><a href="#GetRange和GetRange2" class="headerlink" title="GetRange和GetRange2"></a>GetRange和GetRange2</h3><p>GetRange计算<code>inputs_[0]</code>/<code>inputs_[1]</code>的区间。<br>GetRange2计算<code>inputs_[0]</code>和<code>inputs_[1]</code>的区间。<br>GetRange很简单，遍历每一个文件，然后更新smallest和largest，这里注意都需要<code>icmp_.Compare</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span><br><span class="line">                          InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  assert(!inputs.empty());</span><br><span class="line">  smallest-&gt;Clear();</span><br><span class="line">  largest-&gt;Clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</span><br><span class="line">    FileMetaData* f = inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      *smallest = f-&gt;smallest;</span><br><span class="line">      *largest = f-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *smallest = f-&gt;smallest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *largest = f-&gt;largest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetRange2很简单，就直接合并<code>inputs_[0]</code>和<code>inputs_[1]</code>的内容到一个vector里面，然后调用GetRange。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span><br><span class="line">                           InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; all = inputs1;</span><br><span class="line">  all.insert(all.end(), inputs2.begin(), inputs2.end());</span><br><span class="line">  GetRange(all, smallest, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AddBoundaryInputs"><a href="#AddBoundaryInputs" class="headerlink" title="AddBoundaryInputs"></a>AddBoundaryInputs</h3><p>AddBoundaryInputs是一个很重要的函数，但只有很少的Blog能讲明白这个函数的来龙去脉。</p><p>翻译一下<code>AddBoundaryInputs</code>这个函数的注释。他提取出<code>compaction_files</code>里面最大的文件b1，在这里是<code>c-&gt;inputs_[0]</code>里面最大的文件。<br>然后在<code>level_files</code>里面找到一个b2，满足b1和b2的user key是相等的，这样的b2称为boundary file。我们需要将这个b2加入到<code>compaction_files</code>里面，并且继续找上界。<br>如果有两个块（应该就是SSTable）b1和b2，他们的范围分别是<code>(l1, u1)</code>和<code>(l2, u2)</code>，如果我们只Compact b1，不Compact b2，那么在读取的时候就会出错。因为它只会返回b2的结果，而永远不会返回b1的结果，因为b1在b2上层了。与此同时，我们需要注意到b2的结果可能还是一个较旧的数据，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span></span></span><br></pre></td></tr></table></figure><p>【Q】看起来，这个函数做的是和<code>GetOverlappingInputs</code>一样的事情，他们的区别是什么呢？首先，<code>GetOverlappingInputs</code>的初心不是扩展边界而是计算某一层和某个range重合的文件，只是对Level0要特殊处理一下。其次，<a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">这篇文章</a>中进行了解释。</p><p>如下图所示，两个sstable中，出现了user key相同（都为key2）但是Sequence Number不同的两个Internal Key。<br><img src="/img/leveldb/compaction/AddBoundaryInputsProblem.png"></p><p>所以可以看到<code>GetOverlappingInputs</code>的特殊处理关注的是Level0上某一个要Compact的文件中的所有key是否还会出现在其他的SSTable文件中。而<code>AddBoundaryInputs</code>关注的是某个Key的其他版本是否还会出现在其他的SSTable中。</p><p>【Q】这里引发了第二个疑问，为什么同一层中会出现两个相同user key的Key呢？我觉得这个可能是因为这个Key出现在两个SSTable的边界上，所以这个函数叫<code>AddBoundaryInputs</code>吧。</p><p>仔细回顾一下<code>DoCompactionWork</code>的实现，似乎是可能没处理完一个Key，就<code>ShouldStopBefore</code>了的，但即使这样，后面的文件里面也不会再写有关这个user key的内容了。那么究竟在什么情况下会发生这种情况呢？根据<a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">这篇文章</a>中指出Snapshot机制会导致“同一层中会出现两个相同user key的Key”这个问题。</p><p>【Q】这里引发了第三个疑问，出现了两个user key，会不会影响读取呢？实际上只要位于同一层就不影响，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。我们的查找方式允许我们每一次都找到b1里面的值。</p><p>特别值得注意的是，这个问题关系到<a href="https://github.com/google/leveldb/issues/320" target="_blank" rel="noopener">Issue 320</a>和<a href="https://github.com/google/leveldb/pull/339" target="_blank" rel="noopener">PR 339</a>。<code>AddBoundaryInputs</code>函数也是在那个时候引进的。不过值得注意的是，这个patch在2016年就提了，但是2019年才被合进去。</p><h3 id="SetupOtherInputs主体"><a href="#SetupOtherInputs主体" class="headerlink" title="SetupOtherInputs主体"></a>SetupOtherInputs主体</h3><p>首先<code>AddBoundaryInputs</code>扩充一下<code>c-&gt;inputs_[0]</code>。<br>然后获得Level N的range。<br>然后计算Level N+1和Level N重叠的SSTable文件，并放入<code>c-&gt;inputs_[1]</code>。<br>最后，计算Level N和Level N+1合并起来的range。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::SetupOtherInputs(Compaction* c) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure><p>下面的的代码，就是之前说的优化。<br>如果<code>c-&gt;inputs_[1]</code>不为空，也就是Level N+1层有需要进行Merge的文件。我们将level中和所有和<code>[all_start,all_limit]</code>重叠的文件加到expoand0里面，并调用<code>AddBoundaryInputs</code>处理边界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">  <span class="keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[<span class="number">0</span>].size() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br><span class="line">    <span class="keyword">if</span> (expanded1.size() == c-&gt;inputs_[<span class="number">1</span>].size()) &#123;</span><br><span class="line">      Log(options_-&gt;info_log,</span><br><span class="line">          <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">          level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].size()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].size()),</span><br><span class="line">          <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.size()),</span><br><span class="line">          <span class="keyword">int</span>(expanded1.size()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">      smallest = new_start;</span><br><span class="line">      largest = new_limit;</span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">      c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">      GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，设置一下<code>c-&gt;grandparents_</code>这个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line"><span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line"><span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                 &amp;c-&gt;grandparents_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录下一轮的压缩起始文件，也就是设置<code>compact_pointer_</code>。我们在这里立即更新，而不是等到VersionEdit被Apply的时候更新，这样当Compaction失败后，我们能下次能尝试一个不同的key range。</p><ol><li>【Q】什么是压缩起始文件？<br> 查看<code>PickCompaction</code>函数，它会找到largest大于<code>compact_pointer_[level]</code>后的第一个文件。<br> 可以发现，其实每一次要Compaction的文件就是通过<code>compact_pointer_</code>指定的。</li><li>【Q】在这之后，Compaction会因为什么失败？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-CompactionState"><a href="#DBImpl-CompactionState" class="headerlink" title="DBImpl::CompactionState"></a>DBImpl::CompactionState</h2><ol><li><code>SequenceNumber smallest_snapshot;</code><br> 小于<code>smallest_snapshot</code>的Sequence Number是不重要的，因为我们不会为提供<code>smallest_snapshot</code>的snapshot。<br> 所以，如果我们看到Sequence Number小于等于<code>smallest_snapshot</code>的某个<code>S</code>，就可以丢弃小于<code>S</code>的这个key的其他版本。<br> 【Q】这里是不是在说，如果只有S这个独苗，那还是要写进去的？</li><li><code>std::vector&lt;Output&gt; outputs;</code></li><li><code>Output* current_output() { return &amp;outputs[outputs.size() - 1]; }</code><br> 保存每个输出文件的元信息。例如smallest和largest。</li><li><code>WritableFile* outfile;</code><br> Major Compaction过程中，需要输出到level+1层的文件。注意，可能有多个这样的文件，参考<code>ShouldStopBefore</code>。</li><li><code>TableBuilder* builder;</code></li><li><code>uint64_t total_bytes;</code></li></ol><h2 id="DBImpl-DoCompactionWork"><a href="#DBImpl-DoCompactionWork" class="headerlink" title="DBImpl::DoCompactionWork"></a>DBImpl::DoCompactionWork</h2><p>这个对应了一般情况下的Compact过程，来自<code>BackgroundCompaction</code>的调用。<br>那么这个函数做啥呢，不就是个归并排序么？且慢，我们如何处理同一个user key有不同Sequence Number呢？我们的目标肯定是只保留最新的。<br>其中<code>CompactionState</code>封装了<code>Compaction</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::DoCompactionWork(CompactionState* compact) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里要assert一下，即要压缩的Level N层是要有文件的。<br>【Q】这个Snapshot啥回事？<br>根据<a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">文章</a>，如果有Snapshot，则保留大于Snapshot SN的所有Record，以及一个小于Snapshot SN的Record中，SN最大的Record。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行<code>MakeInputIterator</code>，得到的迭代器可以按照key大小遍历所有冲突文件中的每个KV对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line">Status status;</span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br></pre></td></tr></table></figure><p>下面这个while循环遍历刚才得到的迭代器<code>input</code>，进行Major Compaction。<br>但是，且慢，每一次我们都需要先检查有没有Immatable Memtable，如果有的话，就需要先执行Minor Compaction。<strong>这也说明了Minor Compaction的优先级更高</strong>。<br>【Q】我们看到了两个原子量的获取：</p><ol><li><code>shutting_down_</code>，采用了Release-Acquire内存模型，保证了一定的并行顺序。<br> 如果线程A Release Store，线程B Acquire Load，那么<a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">线程A中所有在Release前的(atomic或者非atomic)写</a>，对线程B都可见。</li><li><code>memory_order_relaxed</code>，采用了Relaxed内存模型。<br> 只保证读写的原子性，不保证并发时和其他变量的顺序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">  <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      CompactMemTable();</span><br><span class="line">      <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">      background_work_finished_signal_.SignalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检查当前输出文件(应当位于level+1层)是否与level+2层文件有过多冲突，如果是就要完成当前输出文件，并产生新的输出文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Slice key = input-&gt;key();</span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">    compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是判断是不是能<code>drop</code>，也就是和前面计算的<code>compact-&gt;smallest_snapshot</code>比较。<br>正常情况下<code>ParseInternalKey</code>不会失败，我们跳过这个分支</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.clear();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>下面这个if，判断的是<code>current_user_key</code>第一次出现的情况，包括处理完上一个user key，到达下一个user key，或者刚开始处理第一个user key的情况。我们设置<code>last_sequence_for_key</code>为最大，那么就永远不会触发drop。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">    user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// First occurrence of this user key</span></span><br><span class="line">  current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line">  has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们比较Sequence Number，如果<code>last_sequence_for_key</code>都小于<code>compact-&gt;smallest_snapshot</code>了，那么我这个key肯定更小，这是因为<a href="/2021/04/09/leveldb-memtable/">Sequence Number是按照降序排列的</a>。对于这种情况，我们省点事，直接不要了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">  <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">  drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br></pre></td></tr></table></figure><p>下一个判断复杂点，表示对于特定情况下，一个删除操作也是可以丢掉的。<br><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">如果某个删除操作的版本小于快照版本，并且在更高层没有相同的user key，那么这个删除操作及其之前更早的插入操作可以同时丢弃了</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">             ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">             compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">    <span class="comment">// For this user key:</span></span><br><span class="line">    <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">    <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">    <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">    <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">    <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">    <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">    drop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_sequence_for_key = ikey.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果drop条件不符合，那么就写入到<code>compact-&gt;current_output()</code>里面，同时更新largest。<br>同时我们关注文件大小，如果超限了，就FinishCompactionOutputFile。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input-&gt;Next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至现在，我们已经遍历完迭代器了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">  status = input-&gt;status();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> input;</span><br><span class="line">input = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>更新状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">    stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line">  stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们加锁。所以其实在遍历<code>input</code>这个迭代器的时候，是没有在加锁的。<br><code>InstallCompactionResults</code>是一个关键过程，它将这次Compaction的内容加入到VersionEdit里面，并且最终调用<code>LogAndApply</code>。内容包括什么呢？增加和删除的文件：</p><ol><li><code>InstallCompactionResults</code>会调用<code>Compaction::AddInputDeletions</code>，需要删除的文件，包括<code>input_[0]</code>和<code>input_[1]</code></li><li>向<code>compact-&gt;compaction-&gt;edit()</code>中添加<code>compact-&gt;outputs</code>中的所有文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/34674504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34674504</a></li><li><a href="https://blog.csdn.net/tmshasha/article/details/47703245" target="_blank" rel="noopener">https://blog.csdn.net/tmshasha/article/details/47703245</a></li><li><a href="https://zhuanlan.zhihu.com/p/51573929" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51573929</a></li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/basic.html</a></li><li><a href="https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/" target="_blank" rel="noopener">https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a></li><li><a href="http://blog.jcix.top/2018-05-11/leveldb_paths/" target="_blank" rel="noopener">http://blog.jcix.top/2018-05-11/leveldb_paths/</a></li><li><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">http://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/46718964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46718964</a></li><li><a href="http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html" target="_blank" rel="noopener">http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a><br> 这是一个DB完整执行过程的表述。</li><li><a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">https://www.ravenxrz.ink/archives/1ba074b9.html</a><br> 介绍了Snapshot</li><li><a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-PickCompaction</a><br> 解释了GetOverlappingInputs的原理</li><li><a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-version</a><br> 解释了Version的实现</li><li><a href="http://lerencao.github.io/posts/lsm-tree-compaction-strategy/" target="_blank" rel="noopener">http://lerencao.github.io/posts/lsm-tree-compaction-strategy/</a></li><li><a href="http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/" target="_blank" rel="noopener">http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/</a><br> 上面两篇文章介绍STCS和LCS</li><li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181498475</a><br> 图解Compact过程</li><li><a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction</a><br> RocksDB对Compaction的讲解</li><li><a href="https://blog.csdn.net/weixin_36145588/article/details/78064777" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36145588/article/details/78064777</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html</a><br> 这位同学解释了AddBoundaryInputs的来源</li><li><a href="http://www.petermao.com/leveldb/leveldb-8-snapshot.html" target="_blank" rel="noopener">http://www.petermao.com/leveldb/leveldb-8-snapshot.html</a><br> 介绍了snapshot机制</li><li><a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60188395</a><br> 带Snapshot的Compaction，以及为什么会导致Issue 320的问题</li><li><a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360345923</a><br> 也讲解了AddBoundaryInputs的来源，并且指出了快照会导致Issue 320的问题。</li><li><a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35343043</a><br> 讲解VersionSet/VersionEdit里面出现的各种文件编号</li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a><br> 版本控制相关</li><li><a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-manifest/</a><br> 有关Manifest文件的深入讨论</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://draveness.me/database-concurrency-control/" target="_blank" rel="noopener">https://draveness.me/database-concurrency-control/</a><br> 同样介绍了MVCC，包括乐观锁和悲观锁机制</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Minor Compaction&lt;br&gt; 对应Memtable到SSTable的过程。&lt;/li&gt;
&lt;li&gt;Major Compaction&lt;br&gt; 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。&lt;br&gt; Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。&lt;/p&gt;
&lt;p&gt;同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
</feed>
