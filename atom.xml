<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2022-02-18T09:17:16.400Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>F1的在线异步DDL</title>
    <link href="http://www.calvinneo.com/2022/01/28/f1-ddl/"/>
    <id>http://www.calvinneo.com/2022/01/28/f1-ddl/</id>
    <published>2022-01-28T15:33:22.000Z</published>
    <updated>2022-02-18T09:17:16.400Z</updated>
    
    <content type="html"><![CDATA[<p>介绍F1的在线异步DDL schema变更。</p><a id="more"></a><h1 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h1><h2 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h2><p>我们需要处理DDL执行进度不一致的问题，比如：</p><ol><li>Node A已经处理了a/b/c三个DDL</li><li>Node B刚处理完a这个DDL</li></ol><p>假定c是创建一个表，那么Node A能看见这个表，而Node B则看不见。那么分别从Node A和B查询，就会发现数据不一致的情况。</p><p>具体来说，有两类不一致问题需要考虑：</p><ol><li>orphan data anomaly<br> 违反1/3/5/7</li><li>integrity anomaly<br> 违反2/4/6</li></ol><p>其中：</p><ol><li>所有 ColumnKV 都能找到一个包含它的 Row 和 Table。</li><li>所有 Row 都包含所有非空列的 ColumnKV。</li><li>所有 IndexKV 都能找到一个包含它的 Index。</li><li>所有 Index 都是完整的（不存在某个 Row 缺少指向它的 IndexKV）。</li><li>所有 IndexKV 都指向有效的 Row。</li><li>没有违反 Constraint 的数据。</li><li>不存在未知的 KV（特指除上述 1，3 以外的未知 KV）。</li></ol><h2 id="分步解决问题"><a href="#分步解决问题" class="headerlink" title="分步解决问题"></a>分步解决问题</h2><p>目标1：在同一时刻改变所有Node的状态。很遗憾，因为各种延迟并不能做到。<br>妥协后的目标1：在某一时刻修改Schema，在确定的时间长度T之后，整个集群中不会有使用旧Schema的Node继续提供服务。这样在T之后这个修改就是确定生效的了。<br>方案：</p><ol><li>定时刷新<br> 每个节点会按照固定时间刷新自己的Schema。<br> 例如，可以选举出一个Owner，每个节点定时向Owner请求当前的Schema。</li><li>强制失败<br> 如果刷新失败，则停止服务，而不是继续按照旧Schema服务。</li></ol><p>目标1.1：在集群间同步最新的Schema<br>方案：借助于Spanner</p><ol><li>每次刷新时，从Spanner上的某个固定位置加载Schema。</li></ol><p>在实现目标1后，发现还是有问题。例如，虽然a/b在a+T/b+T时刻被完成，但在a+T之前的某个时刻，我们仍然不知道当前状态是a已生效，还是ab都已生效。如果在加上个c，那么情况更复杂。</p><p>目标2：在同一时刻，只会有最多两个Schema生效。例如在同一时刻内，最多只有DDL a之前的状态和DDL a之后的状态生效。<br>分析：直接Bruteforce搞就行，比如插一个barrier，等到DDL a确定生效(等到a+T)后，再执行DDL b。<br>方案：</p><ol><li>引入Lease，长度等于DDL确定生效的时间</li><li>每个Lease中只能执行一个DDL</li><li>我们在T+2个Lease时一定可以执行DDL b</li></ol><p>目标2.1：不会产生不合法的DML。<br>方案：write fencing</p><ol><li>事务允许跨越多个Lease。</li><li>但是，如果事务中有写操作，写操作只允许在当前Lease中进行：<ol><li>写操作在他们submit时，转换为Spanner上的KV操作</li><li>如果写操作跨Lease，可能会违反同一时刻集群中最多只有两个Schema版本生效的限制。</li></ol></li></ol><p>通过实现之前的目标进行了问题的分解，不需要处理多个DDL的进度不一致问题了。但仍然存在问题，考虑一个add index的DDL，Node A上已经执行完了，Node B则没有开始执行，然后考虑此刻开始执行的两个DML：</p><ol><li>通过Node A添加一个Row：会添加数据和索引</li><li>通过Node B删除一个Row：只会删除数据</li></ol><p>现在如果从Node A索引读，那么会读到一开始被写入的索引，但对应的数据却被删除了。于是这里产生了孤儿索引的问题，这破坏了数据库的完整性。这是因为不同Node之间同一DDL的进度不同产生的不一致，如何解决呢？</p><p>目标3：将这一个DDL拆成多个Schema Change的步骤。由于Update可以看做是Delete+Insert，所以实际需要考虑Insert、Delete和Query三种操作。</p><p>从孤儿索引的问题可以看出，delete操作需要和insert操作分离，要拆出一个Delete Only状态，这个状态下该DDL的只对Delete操作可见，即该索引只对Delete操作可见：</p><ol><li>从None到Delete Only<br> 增和查都不会使用索引。删会使用索引。</li><li>从Delete Only到Public<br> 不会出现孤儿索引问题了。假如Node A在Delete Only状态，它会在删除时一并删除索引；Node B在Public状态，在查询时发现索引被一并删除了。<br> 但有个新的问题，索引不会“多出来”，但却可能缺。这就得需要有个操作帮忙补索引，也就是reorg。<br> 这个补索引的过程能发生在Delete Only到Public之间么？假设Node A在Delete Only阶段，它只能响应删除，然后开始为既有数据补索引，直到补完变成Public，同时可以处理增删改查。问题是这个过程中的insert，对应的索引并没有被补上啊。因此，需要引入新的状态Write Only。</li></ol><p>于是引入Write Only状态，这个过程只不允许读：</p><ol><li>从Delete Only到Write Only</li><li>从Write Only到Public<br> 假如Node A在Write Only状态，它的所有写操作都会涉及索引。而Node B在Public状态，它也能读到Node A的修改。</li></ol><p>考虑所有节点都到达了Write Only状态，现在就可以做Reorg补上之前的索引数据了，方式很简单，就是取一个现在的Snapshot，然后照着补。此时可能有并发写的冲突问题，但Spanner的Percolator协议可以解决。</p><p>目标4：缩短Lease长度。Lease长度一般都会很长，F1中是分钟级，TiDB中也有45秒。如果完全走Lease的方案，那么一次DDL的时间就是分钟级的了，这显然很难被接受<br>方案1：直接将Lease长度缩短，例如改为1s。<br>这个方案是有问题的：</p><ol><li>在每个Lease结束后，Node需要去加载最新的Schema，这个伴随网络开销，需要时间。如果加载Schema的时间大于Lease的时间，那么就会导致刚加载的又失效了，从而重新加载，极大地降低了性能。</li></ol><p>既然方案1不行，那么就有了方案2<br>方案2：</p><ol><li>Owner在修改完DDL后，主动通知其他节点，并统计ack。如果其他节点都回复了，那么就主动确定了这个ddl在所有节点上都生效了。</li><li>如果有节点没有回复，那么再主动等2个Lease。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://zimulala.github.io/2016/02/02/schema-change-implement/" target="_blank" rel="noopener">http://zimulala.github.io/2016/02/02/schema-change-implement/</a></li><li><a href="https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md" target="_blank" rel="noopener">https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md</a></li><li><a href="https://disksing.com/understanding-f1-schema-change/" target="_blank" rel="noopener">https://disksing.com/understanding-f1-schema-change/</a></li><li><a href="https://tongtianta.site/paper/57876" target="_blank" rel="noopener">https://tongtianta.site/paper/57876</a><br> Online, Asynchronous Schema Change in F1</li><li><a href="https://www.zenlife.tk/schema-lease.md" target="_blank" rel="noopener">https://www.zenlife.tk/schema-lease.md</a></li><li><a href="https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/" target="_blank" rel="noopener">https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍F1的在线异步DDL schema变更。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>DPDK-Writing Efficient Code</title>
    <link href="http://www.calvinneo.com/2021/12/13/dpdk-coding/"/>
    <id>http://www.calvinneo.com/2021/12/13/dpdk-coding/</id>
    <published>2021-12-13T15:33:22.000Z</published>
    <updated>2021-12-14T08:21:55.883Z</updated>
    
    <content type="html"><![CDATA[<p>DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。</p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Memory-Copy"><a href="#Memory-Copy" class="headerlink" title="Memory Copy"></a>Memory Copy</h2><p>不要在数据面上使用libc函数，例如memcpy和strcpy等，推荐用<code>rte_memcpy</code>这样的优化实现，实际上就是SIMD的版本。<br>为了使用SIMD，需要保证地址不是虚拟地址，例如malloc等产生的是虚拟地址，那么在物理地址上可能是分散的，就做不了SIMD优化。</p><h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><p>避免使用malloc等在堆上分配内存，毕竟维护堆还是比较麻烦的(CSAPP的Data Lab令我记忆犹新)，并且也不容易做parallel allocation(【Q】这是啥)。<br>更为推荐的做法是对固定大小的对象构建内存池，例如<code>librte_mempool</code>/<code>rte_malloc</code>的实现。在这样的实现中需要考虑内存对齐，无锁访问，NUMA感知，批量读写，每个核心的Cache。</p><h2 id="对同一内存的并发访问"><a href="#对同一内存的并发访问" class="headerlink" title="对同一内存的并发访问"></a>对同一内存的并发访问</h2><h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><h2 id="Distribution-Across-Memory-Channels"><a href="#Distribution-Across-Memory-Channels" class="headerlink" title="Distribution Across Memory Channels"></a>Distribution Across Memory Channels</h2><h1 id="各个核心之间的通信"><a href="#各个核心之间的通信" class="headerlink" title="各个核心之间的通信"></a>各个核心之间的通信</h1><h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><h1 id="锁和原子操作"><a href="#锁和原子操作" class="headerlink" title="锁和原子操作"></a>锁和原子操作</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html" target="_blank" rel="noopener">https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html</a></li><li><a href="https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h" target="_blank" rel="noopener">https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h</a><br> rte_memcpy的源码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>EPaxos介绍</title>
    <link href="http://www.calvinneo.com/2021/12/04/epaxos/"/>
    <id>http://www.calvinneo.com/2021/12/04/epaxos/</id>
    <published>2021-12-04T11:20:33.000Z</published>
    <updated>2022-01-06T16:26:22.844Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍EPaxos算法。</p><a id="more"></a><h1 id="Epaxos的简介"><a href="#Epaxos的简介" class="headerlink" title="Epaxos的简介"></a>Epaxos的简介</h1><p>EPaxos是一个Leaderless的算法，具有以下的优点：</p><ol><li>Client可以任意选择一个节点发送Command，这个Command的Commit的路径大部分都不会干扰到其他的Command。而在诸如Raft的算法中，必须有一个Master显式向其他节点复制日志。并且也避免了Client可能和一个跨地区的Master交互的情况。</li><li>因为没有Leader选举的过程，所以整个集群的可用性变高了。</li></ol><p>讨论Basic Paxos算法，当收到来自Client的Command后，某个replica会尝试成为一个尚未被使用过的instance的Leader，方式是发送Prepare消息。其他replica对Prepare的返回值，首先包含了它们认为的已经被chosen的Command(如果出现这种情况，Leader后面也需要使用这个Command)。在返回值中还会包含不会再ack早前的Leader发送的更旧的消息的承诺。在收到majority的对Prepare的ack之后，这个Leader会发送Accept消息。当Accept消息再被majority确认后，Leader会在本地记录Command已被Commit，并且异步通知Peer和Client。</p><p>容易发现，Paxos算法需要Prepare和Accept两个阶段，才能完成一个Command的提交。这是不经济的，因为即使从Raft的经验来看，只要Leader一直存在，那么一轮就可以决定一个instance，也就是Log Entry的值了。此外Basic Paxos中如果多个Leader打架，那2轮都不够。因此MultiPaxos中引入了stable leader(又称为distinguished proposer)的机制来处理。</p><p>EPaxos的设计目标是：</p><ol><li>减少Commit时延</li><li>优化Load Balance</li><li>对于较慢甚至故障的节点，提供一个优雅的降级方案</li></ol><p>为此，EPaxos需要做到：</p><ol><li>每个节点都可以同时作为Proposer(Command Leader)</li><li>每个Proposer在和最小数量的节点交流后就可以Commit，并且交流的次数也要最小化<br> 类似generic broadcast算法，以及Generalized Paxos算法，会广播消息。但如果两个Command不互相影响，实际上并没有必要强制他们有一个consistent的顺序。<br> 而在实际workload上，可以认为大部分的Command是这样的，也就是说它们修改的是不同的对象。</li><li>Quorum的组成应当是可变的</li></ol><p>EPaxos做到这些，得益于它给Command定序的方案。在这之前，诸如MultiPaxos和GenerizedPaxos选择通过一个Leader来选择顺序；而在 canonical Paxos和Mencius中选择将这些Command放入已经预先分配好的instance空间中。</p><p>EPaxos的方案是当对一个Command投票时，每个参与者需要附带上对这个Command的Order Constraints。EPaxos能够保证所有正常的节点能够以提交同样的Command和Order Constraints。</p><p>简介一下EPaxos的方案。当一个Command被发送给某个replica时，该replica就被称为Command Leader。这个称呼特意区别于MultiPaxos中的Leader，因为显而易见，同时可能存在多个Command Leader。</p><p>如果Command之间不冲突，如下图的左边所示，两个Command分别更新<code>obj_A</code>和<code>obj_B</code>。为了Commit这个Command，可以走论文中说的Fast Path。Command Leader需要和<code>F + floor((F + 1) / 2)</code>(称为fast-path quorum)个Peer交互。其中F是允许失败的节点的个数，对应到下图，F为2。特别地，对于常见的3节点集群，Fast-path Quorum为2；对于5节点集群，Fast-path Quorum为3，都等于传统的简单多数。</p><p>【Q】这里有个疑问，不同对象的先后顺序，有影响么？比如实际上一个Client先于<code>obj_B</code>写<code>obj_A</code>，但<code>obj_B</code>先于<code>obj_A</code>被Commit，当Client收到<code>obj_B</code>的时候读取<code>obj_A</code>，那么可能读到<code>obj_A</code>的stale的数据呢？可以看下面的Execution linearizability说明。</p><p>如果两个Command互相冲突，如下图的右边所示，C3和C4同时更新<code>obj_A</code>，就不能走Fast Path了。在提交的时候需要附带上Order Constraint。为了保证所有的Replica在存在部分节点故障的情况下，都能提交相同的Order Constraint，需要另一轮的通信。这一轮通信中，Command Leader需要和<code>F + 1</code>个Peer交互。这就是Slow Path，<code>F + 1</code>也就是传统意义上的简单多数Quorum。</p><p><img src="/img/epaxos/f1.png"></p><h2 id="EPaxos和其他算法的比较"><a href="#EPaxos和其他算法的比较" class="headerlink" title="EPaxos和其他算法的比较"></a>EPaxos和其他算法的比较</h2><p>在MultiPaxos中，Leader会负责Propose所有的Command。这样会导致Leader处理O(n)个请求，同时非Leader节点只会处理O(1)个请求，负载十分不均衡。</p><p>为了解决MultiPaxos的问题，Mencius选择逐Command将Paxos Leader在多个节点之间轮换。也就是说节点<br><code>R_id</code>拥有instance i，当i满足<code>(i mod N) = R_id</code>。这里的坏处是，每一次Commit Command A之前都需要询问所有节点。否则按照这个轮换顺序，另一个依赖于A的Command B可能在Command A之前被提交。这个询问过程会产生两个后果，首先是整个Commit的速度由最慢的那个Replica决定；其次是当一个节点Fail后，整个过程将block住，直到其他节点发现这个节点Fail掉了，并替他返回一个NoOp。</p><p>FastPaxos为了解决从Propose到Commit的延迟，选择让Client同时向所有的Replica发送Propose。MultiPaxos一样使用了Stable Leader，不仅用来开启voting round，也用来仲裁各个Acceptor的顺序(考虑到每个Acceptor可能以不同顺序收到)。</p><p>Generalized Paxos的方案是当Command之间不互相影响时，对它们乱序提交。Replicas learn commands after just two message<br>delays—which is optimal—as long as they do not interfere。TODO 后面看不懂了。</p><p>EPaxos相对于Generalized Paxos有三点优势：</p><ol><li>EPaxos的Fast Path Quorum Size比Generalized Paxos的正好小一个，能够减小延迟(应该是木桶效应吧)，以及总的消息量</li><li>EPaxos解决冲突，也就是Slow Path只需要额外一轮，但Generalized Paxos需要两轮</li><li>对于three-site replication而言，EPaxos即使在所有Command都冲突的情况下，只需要和距离Proposer最近的Replica通信一轮，即可Commit</li></ol><p>EPaxos和Fast/Generalized Paxos的<strong>Fast Path</strong>的一个重要区别是，EPaxos需3 message delays来Commit，但Fast等只需要2个。但一般EPaxos的第一个Delay可以忽略掉，因为Client和最接近的Replica通常都在一个数据中心中。</p><p>S-Paxos TODO</p><h1 id="EPaxos的实现"><a href="#EPaxos的实现" class="headerlink" title="EPaxos的实现"></a>EPaxos的实现</h1><p>结合了两篇论文的内容</p><h2 id="预备内容"><a href="#预备内容" class="headerlink" title="预备内容"></a>预备内容</h2><p>在允许F个失效节点的分布式系统中，至少存在N=2F+1个节点。对于每一个节点R，它拥有的instance写为序列R1, R2, …。在每个instance中，只有一个Command能被选出。需要注意的是，R1、R2等instance的order，并不是已经确定的，而是由协议来动态确定。</p><p>Commands γ和δ是interfere的，当存在一系列指令Σ使得顺序执行Σ,γ,δ不等价于顺序执行Σ,δ,γ。这里不等价包含它们会导致不同的状态机状态，或者导致在这些序列中读取到的值是不同的。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>Nontriviality<br> 所有被Commit的Command都由Client发出。</li><li>Stability<br> 对于任意Replica，不会丢失已经Commit的数据。<br> 进一步地，如果在t1时刻，Replica R在Q.i这个instance上提交了Command Y，那么在t1之后的任意时刻t2，R上的instanceQ.i的值也是Command Y。<br> 【Q】这里有个疑问，Q是哪里来的？不应该是R么？应该不矛盾，作为Acceptor，R也会有Q拥有的instance的信息的，不然怎么投票？</li><li>Consistency<br> 同一个instance在Commit之后，就在各个Replica上的值都是一样的。</li><li>Execution consistency<br> 如果两个interfere的Command Y和Z在任意Replica上被成功Commit了，那么所有Replica上的执行顺序是一样的。</li><li>Execution linearizability<br> 如果Client对Command Y和Command Z是serialized的，比如说在Command Y被Commit之后，才会Propose Command Z，那么所有的Replica都会先执行Y再执行Z。</li><li>Liveness<br> 活性</li></ol><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>基础版本的fast-path quorum是<code>2F</code>，后面优化版本的才是<code>F + floor((F + 1) / 2)</code></p><h3 id="Commit-Protocol"><a href="#Commit-Protocol" class="headerlink" title="Commit Protocol"></a>Commit Protocol</h3><p>Commit Protocol解决两个问题：</p><ol><li>Commit Command</li><li>Determine Order Between Commands</li></ol><p>在论文的Figure2中描述了Commit Protocol的整个过程，在Commit过程中，并不是每个过程都会走到。如果一个Command没有冲突，就可以走Fast Path，这也意味着走完Phase 1就能够直接提交了。Slow Path还需要额外的Phase 2(Paxos-Accept phase)。如果我们进行failure recovery，则需要运行Figure3描述的Explicit Prepare过程。</p><p>当一个Replica收到来自Client的Command γ后，会给这个Command γ分配一个全局唯一的instance number，例如R1、Q2等。全局唯一是通过组合Replica的名字，以及在Replica中递增的序列号保证的。这里Replica是可以将多个操作组合到一个instance中的。除了分配instance number之外，Replica还会给Command分配一个dependency set(deps)和一个sequence number(seq)，<strong>称为attribute</strong>。Dependency set包含了每个Replica中<strong>最高的</strong>和自己冲突的instance编号。Sequence number会选取一个大于dependency set中所有值的值作为<strong>初始值</strong>。The originating replica derives the dependency set and sequence number for a new instance from all other instances it has knowledge of。对于每个修改了新Command操作对象的Replica，需要持久化它们的最高的instance number和sequence number。</p><p>Command Leader通过<strong>PreAccept消息</strong>，即<code>(γ,seqγ,depsγ,pre-accepted)</code>，将Command以及deps和seq发送给至少fast-path quorum(在这里是2F)个Replica。每个Replica在收到后，会<strong>根据自己的cmds log</strong>来更新Command γ的deps和seq，并将γ和新的attribute记录在自己的log中，然后回复给Command Leader。</p><p>如果Command Leader满足了fast-path quorum，并且所有更新了的attribute(seq和deps)是一样的(根据Figure2的第10行代码，不包括Command Leader)，那么可以直接Commit。否则就需要走Slow Path。</p><p>在运行Slow Path前，我们得更新seq和deps。其中deps是从每个Replica之间的union，seq取每个Replica过来的最大的seq。然后在Slow Path中，Command Leader会给另外F个Replica发送Accept请求，让它们Accept三元组<code>(γ,seq,deps)</code>。其实这个过程类似于Basic Paxos的Accept阶段。</p><p>在Slow Path完成了取得了F + 1票后，就可以和Fast Path会师了。此时Command Leader会发送Commit消息给所有的Replica，并且返回给Client。</p><p>类似于经典的Paxos，EPaxos也会给每个消息(message)分配一个ballot number。每个Replica会忽略小于它们已经见过的最大的ballot number。这个ballot number格式为<code>epoch.b.R</code>，其中：</p><ol><li>epoch<br> 如果集群的配置有变动，那么epoch会变化</li><li>b<br> 如果某个replica R，在做Explicit Prepare时，需要创建一个新的ballot时，会自增b</li><li>R<br> 表示这个Replica</li></ol><p>每个Replica是自己拥有的instance的<strong>初始</strong>Leader，换言之，对于每个instance <code>R.i</code>，隐式存在一个<code>epoch.0.R</code>。</p><p><img src="/img/epaxos/f2.png"></p><h3 id="Explicit-Prepare过程"><a href="#Explicit-Prepare过程" class="headerlink" title="Explicit Prepare过程"></a>Explicit Prepare过程</h3><p>【这一块还包含了优化部分，比较难懂】<br>假如说Replica L可能宕机了，那么Replica Q会尝试接管它的instance L.i。</p><p>首先，将ballot number设置为epoch.(b + 1).Q，其中epoch.b.R是Q知道的L.i中最大的ballot number。然后，发送<code>Prepare(epoch.(b + 1).Q,L.i)</code>给包括自己在内的所有Replica，并且等待至少<code>floor(N/2) + 1</code>个回复。令R等于the set of replies w/ the highest ballot number：</p><ol><li>如果R中包含了<code>(γ,seqγ,depsγ,committed)</code>，则在L.i对(γ,seqγ,depsγ)运行Commit Phase。</li><li>再如果R中包含了<code>(γ,seqγ,depsγ,accepted)</code>，运行Paxos-Accept phase。</li><li>再如果R包含了至少<code>floor(N / 2)</code>个不同的对<code>L.i</code>上默认的ballot即<code>epoch.0.L</code>的回复<code>(γ,seqγ,depsγ,pre-accepted)</code>，并且没有一个回复是来自于L的，则运行Paxos-Accept phase。<br> 【优化算法】此时，只需要包含<code>floor((F + 1) / 2)</code>个PreAccept了<code>(γ,seqγ,depsγ)</code>这个三元组的Replica即可。在发现他们后，新的Command Leader Q会尝试向其他Replica发送TryPreAccept消息。在某个Replica收到TryPreAccept消息后，会判断这个三元组是否和自己已有的log冲突：一个Command的deps中不包括γ，并且depsγ中也不包括这个Command(简单来说两个Command的deps互相不包含)，那么这个Command就和γ冲突；或者这个Command虽然在depsγ中，但是它的seq大于等于seqγ，那么也是和γ冲突的。只有当自己的log中没有这些冲突Command时，这个Replica才会回复TryPreAccept。<br> 如果真的存在某个Command和三元组冲突，并且这个Command被Commit了，那么Q就知道γ不能再fast path中被提交。但如果这个Command没有被Commit，那么新的Comamnd Leader Q就会defer，知道这个Command被Commit。最后，如果Q能够得到F + 1个Replica(在计算F时，老Command Leader也被计算在内)的PreAccept票后，就可以运行Paxos-Accept phase了。<br> 这里有一个Corner case，也即是当deps中的某个Command修改它的seq，然后比需要Recover的Command γ的seq还要大了。为了阻止这个情况，对于depsγ中的所有Command，至少需要有一个Acceptor记录为Commit状态后，才允许Command Leader走Fast Path提交。对于N小于7的情况，更有效的方案是将更新后的deps放到Accept和AcceptReply消息中，并且保证这些消息的接收方都去缓存了它们。这些信息只会被用来辅助Recovery。<br> 【Q】为啥优化算法只改这一个分支？</li><li>再如果R包含了至少一个<code>(γ,seqγ,depsγ,pre-accepted)</code>，则在L.i上执行Phase1，Command为γ，并且避免fast path。</li><li>最终，则在L.i上执行Phase1，Command为noop，并且避免fast path。</li></ol><p>Replica R, 在收到来自Q的Prepare(epoch.b.Q,L.i)后：</p><ol><li>如果epoch.b.Q比最近接受到来自L.i的请求epoch.x.Y大，则返回PrepareOK(cmdsR[L][i], epoch.x.Y,L.i)</li><li>否则返回NAC</li></ol><p><img src="/img/epaxos/f3.png"></p><h3 id="Execution-Protocol"><a href="#Execution-Protocol" class="headerlink" title="Execution Protocol"></a>Execution Protocol</h3><p>为了执行在R.i这个instance上提交的Command γ，需要执行下面的步骤：</p><ol><li>等待R.i被提交，或者运行Explicit Prepare过程强制这个过程</li><li>构造γ的依赖图，其中需要加入γ的dependency set中的所有Command<br> 注意，这个过程是递归的，也就是我们需要考虑依赖的依赖</li><li>找到所有的SCC，并对这些SCC进行拓扑排序</li><li>根据逆拓扑序，执行：<ol><li>对于SCC中的所有命令，按照sequence number(seq)从低到高排序</li><li>按照这个顺序执行所有尚未被执行的Command，并标记他们为已被执行</li></ol></li></ol><h2 id="关于性质的-Informal-证明"><a href="#关于性质的-Informal-证明" class="headerlink" title="关于性质的(Informal)证明"></a>关于性质的(Informal)证明</h2><h3 id="Nontriviality"><a href="#Nontriviality" class="headerlink" title="Nontriviality"></a>Nontriviality</h3><h3 id="Stability和Consistency"><a href="#Stability和Consistency" class="headerlink" title="Stability和Consistency"></a>Stability和Consistency</h3><p>先证明命题1：如果Replica R通过instance Q.i提交了Commit γ(这里R和Q可能是同一个Replica)，那么对于任意的提交Q.i的Replica R’，它提交的Command γ’一定等于γ。</p><p>证明简要：如果说Command γ能被在Q.i这个instance中提交，一定是因为γ的Phase 1是在instance Q.i中被启动的。这是因为：</p><ol><li>对于每个新Command，Q会自增instance number，也就是这里的i</li><li>如果Q宕机并重启了，那么根据”4.7 Reconfiguring the Replica Set”，它会被分配得到一个新的identifier<br> 【TODO】这里需要详细解释下。</li></ol><p>可以看到，命题1实际上暗示了consistency。进一步地，在Replica崩溃时，Command可能被丢失，所以当Command Log被保存在持久化存储上时，也暗示了stability。</p><p>首先引入一个定义。如果Command γ具有seqγ和depsγ，如果元组(γ,seqγ,depsγ)是Q.i这个instance上唯一被或者可能被commit的元组，那么我们称元组(γ,seqγ,depsγ)在Q.i这个instance上是safe的。</p><p>下面证明命题2：Replica只会提交safe的tuple。首先知道(γ,seqγ,depsγ)如果在Q.i被提交，那么它要么在Paxos Accept phase提交，或者在Phase 1之后提交。</p><ol><li>对于第一种情况，即Slow Path。此时有多于半数的Replica写入了值(Figure2的L20)，这对应了经典Paxos的要求。</li><li>对于第二种情况，即Fast Path。此时Coomand Leader收到了不含自己的N-2个相同的回复(Figure2的L11)。如果此时另外的Replica需要接管这个instance，通常这是因为初始的Leader宕机了，那么新Leader必须执行Prepare过程，并且会发现至少<code>floor(N/2)</code>个Replica都返回(γ,seqγ,depsγ)这个元组。因此新的Leader会认为这个元组可能提交了，并在Paxos-Accept过程中使用这个元组。</li></ol><p>至此我们可以发现，元组们，包括他们的attributes，都会在各个Replica之间被consistently和stable地提交。</p><p>下面我们证明这些consistent和stable的attributes能够保证所有互相interfere的Command，在每个Replica上都按照同样的顺序被提交。</p><h3 id="Execution-consistency和Execution-linearizability"><a href="#Execution-consistency和Execution-linearizability" class="headerlink" title="Execution consistency和Execution linearizability"></a>Execution consistency和Execution linearizability</h3><p>引理1 (Execution consistency)：<br><strong>如果互相interfere的两个Command γ和δ都被成功Commit了(并不一定通过同一个Replica提交)，那么他们在任意Replica上都会以相同的顺序被执行</strong>。</p><p>如果两个Command互相interfere，至少有一个Command的deps中能找到另一个Command。Phase1在这个命令被至少简单多数(注意我们现在讲的还是基础版本的EPaxos，其中Phase1的Fast Path Quorum为2F)个Replica Pre-Accepted后结束，并且这个命令最终的deps集是由至少简单多数个Replica的deps的union。这也同样适用于recovery过程中使用的Explicit Prepare(L32)的情况，因为所有的依赖都是基于那些被可能宕机的Leader初始设置的集合计算得到。所以至少一个Replica同时PreAccept γ和δ，并且它的PreAcceptReplies被用来构造γ和δ的最终的deps集。</p><p>通过执行Execution Algorithm，一个命令只有在自己dependency graph中的所有命令都被Commit后才会执行。主要有三个场景：</p><ol><li>两个Command都在彼此的dependency graph中，这也意味着dependency graph是identical的，并且γ和δ在同一个SCC中。所以当执行一个Command时，另一个Command也会被执行，并且是根据sequence number来执行的。根据命题2，这些已Commit的Command的attribute在所有Replica上都是stable和consistent的。所以所有dependency graph相同的Replica都会在相同的顺序中执行γ和δ。</li><li>γ在δ的dependency graph中(δ依赖γ)，但δ不在γ的dependency graph中。也就是说dependency graph有一个从δ到γ的路径，反之不成立。因此γ和δ来自不同的SCC，在逆拓扑序即实际的执行顺序中，γ在δ前面。补充一点，在一些Replica中，γ在δ被Commit之前就被执行了，这样的场景是没毛病的，因为γ并不依赖于δ。</li><li>δ在γ前面，这个就是上面的对称形式。</li></ol><p>引理2 (Execution linearizability)：<br>如果两个Command γ和δ，被客户端指定了顺序，例如只有在γ被任意Replica Commit之后才会Propose δ，这样的话我们要求所有的Replica都要在δ之前执行γ。</p><p>证明。因为δ是在γ Commit之后被Propose的，所以在任何Replica收到Command δ的PreAccept时，γ的Sequence Number应该是Stable和Consist的。因为一个包含γ的元组，以及它最终的sequence number至少被majority个Replica记录，那么δ的sequence number会最终被更新到大于γ的值，并且delta的deps中会包含γ。所以在执行δ时，δ的dependency graph必须包含γ，并且：</p><ol><li>它们在同一个SCC中</li><li>按照逆拓扑序，γ在δ前面的一个SCC中。</li></ol><p>无论那种情况，γ都会在δ前面执行。</p><h3 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h3><p>只要不是大多数Replica有故障，那么Client会一直重试某个Command，直到被Accept。</p><h2 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h2><p>优化版本会修改Recovery过程，也就是Explicit Prepare Phase。我已经写到“Explicit Prepare过程”上面了。</p><p>当F个Replica宕机后，在Fast Quorum中就只有<code>floor((F + 1) / 2)</code>个存活的成员(可以翻翻前面Fast-Path Quorum的定义)，那么就不能在剩下的Replica中形成多数了。所以，当Command Leader向所有Replica(而不只是Fast Quorum中的Replica)发送PreAccept消息后，Recovery过程不一定能正确地发现，老的Command Leader，是通过哪些Replica的回复，从而Commit了这个instance的。 Still, such redundancy is sometimes desirable because the command leader may not know in advance which replicas are still live or which replicas will reply faster。<br>对于这种情况，需要修改Fast Path的条件：当Command Leader收到<code>F + floor((F + 1) / 2) - 1</code>个满足initial ordering attributes的PreAccept的回复，才会选择Fast Path。并且这些Replica需要被记录到Log中，以便在Recovery过程中只考虑这些Replica。<br>在不发送redundant PreAccept的时候(【Q】什么时候会发送？)，一个三副本的系统永远可以通过Fast Path提交，这是因为在做还有一个Acceptor的集合中肯定不存在disagreement。</p><h1 id="EPaxos的TLA-简介"><a href="#EPaxos的TLA-简介" class="headerlink" title="EPaxos的TLA+简介"></a>EPaxos的TLA+简介</h1><p>如果光读论文就能读懂，那我感觉你真的挺厉害的，反正我是半懂不懂的，特别是对Recovery部分。所以我转过来看TLA+了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>下面是对SlowQuorum和FastQuorum的定义。对于某个Replica r，SlowQuorum(r)表示它作为Command Leader时，所有可能的Slow Path Quorum组成的集合，也就是类似于<code>{ {r,a}, {r,b} }</code>这样的东西。那么，<code>SlowQuorum(r)</code>必须是<code>SUBSET Replica</code>的子集，换句话说，就是不能出现Replica之外的元素。然后对于SlowQuorum中的任意的Quorum SQ，它必须包含r，并且大小为<code>N/2+1</code>，其中N为集群大小。<br>同理，FastQuorum中的大小为<code>N/2 + (N/2+1)/2</code>，这个其实就是把<code>F = N/2</code>带入进去就得到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS FastQuorums(_), SlowQuorums(_)</span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ SlowQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A SQ \in SlowQuorums(r): </span><br><span class="line">    /\ r \in SQ</span><br><span class="line">    /\ Cardinality(SQ) = (Cardinality(Replicas) \div 2) + 1</span><br><span class="line"></span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ FastQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A FQ \in FastQuorums(r):</span><br><span class="line">    /\ r \in FQ</span><br><span class="line">    /\ Cardinality(FQ) = (Cardinality(Replicas) \div 2) + </span><br><span class="line">                         ((Cardinality(Replicas) \div 2) + 1) \div 2</span><br></pre></td></tr></table></figure><p>下面是对一些状态的定义。Commands是一个常量，表示所有可能的命令，在运行前由我们给出。none是一个none Command(也许是Noop？)，对它的定义还挺新颖的，如果是我，可能选择直接CONSTANT了一个Nil的值。<br>Instance是做了一个笛卡尔积，没啥讲的。<br>Status标记了Log中的某个Command可能处于的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS Commands</span><br><span class="line">none == CHOOSE c : c \notin Commands</span><br><span class="line">Instances == Replicas \X (1..Cardinality(Commands))</span><br><span class="line">Status == &#123;&quot;not-seen&quot;, &quot;pre-accepted&quot;, &quot;accepted&quot;, &quot;committed&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面是Replica之间可能发送的消息。这里的TLA+语法可以参考<a href="/2021/06/26/tla/">TwoPhase章节</a>。</p><ol><li>pre-accept、pre-accept-reply<br> Phase1由Command Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,pre-accepted)</code><br> 注意要区分这里的committed字段，和全局的committed变量</li><li>accept、accept-reply<br> Phase2由Commmand Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,accepted)</code></li><li>commit<br>Commit阶段由Command Leader发起的消息，即<code>(γ,seqγ,depsγ,committed)</code></li><li>prepare、prepare-reply<br> Explicit Prepare阶段由新的Command Leader Q发起的消息。</li><li>try-pre-accept、try-pre-accept-reply<br> 优化算法</li></ol><p>一些常见字段的说明：</p><ol><li>src和dst都属于Replicas。</li><li>inst属于Instances表示当前操作的实例。</li><li>ballot应该是指的ballot number，不是<code>epoch.b.R</code>么？看起来是吧epoch和b合并了？</li><li>cmd应该是指instance中包含的command。</li><li>deps和seq就是所谓的attribute，没啥讲的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Message ==</span><br><span class="line">        [type: &#123;&quot;pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;commit&quot;&#125;,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        deps: SUBSET Instances, seq: Nat, committed: SUBSET Instances]</span><br><span class="line">  \cup  [type: &#123;&quot;accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, prev_ballot: Nat \X Replicas,</span><br><span class="line">        status: Status,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, status: Status \cup &#123;&quot;OK&quot;&#125;]</span><br></pre></td></tr></table></figure><p>下面是定义变量，可以结合TypeOK和Init条件看出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VARIABLES cmdLog, proposed, executed, sentMsg, crtInst, leaderOfInst,</span><br><span class="line">          committed, ballots, preparing</span><br><span class="line"></span><br><span class="line">TypeOK ==</span><br><span class="line">    /\ cmdLog \in [Replicas -&gt; SUBSET [inst: Instances, </span><br><span class="line">                                       status: Status,</span><br><span class="line">                                       ballot: Nat \X Replicas,</span><br><span class="line">                                       cmd: Commands \cup &#123;none&#125;,</span><br><span class="line">                                       deps: SUBSET Instances,</span><br><span class="line">                                       seq: Nat]]</span><br><span class="line">    /\ proposed \in SUBSET Commands</span><br><span class="line">    /\ executed \in [Replicas -&gt; SUBSET (Nat \X Commands)]</span><br><span class="line">    /\ sentMsg \in SUBSET Message</span><br><span class="line">    /\ crtInst \in [Replicas -&gt; Nat]</span><br><span class="line">    /\ leaderOfInst \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line">    /\ committed \in [Instances -&gt; SUBSET ((Commands \cup &#123;none&#125;) \X</span><br><span class="line">                                           (SUBSET Instances) \X </span><br><span class="line">                                           Nat)]</span><br><span class="line">    /\ ballots \in Nat</span><br><span class="line">    /\ preparing \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line"></span><br><span class="line">Init ==</span><br><span class="line">  /\ sentMsg = &#123;&#125;</span><br><span class="line">  /\ cmdLog = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ proposed = &#123;&#125;</span><br><span class="line">  /\ executed = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ crtInst = [r \in Replicas |-&gt; 1]</span><br><span class="line">  /\ leaderOfInst = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ committed = [i \in Instances |-&gt; &#123;&#125;]</span><br><span class="line">  /\ ballots = 1</span><br><span class="line">  /\ preparing = [r \in Replicas |-&gt; &#123;&#125;]</span><br></pre></td></tr></table></figure><ol><li>cmdLog<br> 每个Replica上的日志。<br> 每条日志中包含对应的Instance、Status，ballot、Command、以及deps和seq</li><li>proposed<br> 已经被被Propose了的Command</li><li>executed<br> 每个Replica上已经被execute的Command</li><li>sentMsg<br> 所有被发送，但是还没有被接受的消息，理解成Message类型对象的集合</li><li>crtInst<br> 对于每个Replica，它下一个可以使用的instance number(一个数字)，初始值是1</li><li>leaderOfInst<br> 这是从Replicas到SUBSET Instances的一个映射，表示对于每个Replica，它发起但是还没有完成的Instance的集合</li><li>committed<br> 【Q】maps commands to set of commit attributs tuples<br> 从实现上来看，应该是个三元组，表示每个Command被提交时的deps和seq</li><li>ballots<br> 所有Replica中，最大的ballot number，这里指的应该是epoch.b</li><li>preparing<br> 对于每个Replica，它目前正在preparing(例如recovering)的所有Instance</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>Nontriviality的验证，对于任意的Instance，始终(因为有<code>[]</code>)有：在committed中的所有Command，它要么是在proposed集合中(也就是被某个Command Leader主动Propose的)，或者为none</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nontriviality ==</span><br><span class="line">    \A i \in Instances :</span><br><span class="line">        [](\A C \in committed[i] : C \in proposed \/ C = none)</span><br></pre></td></tr></table></figure><p>Stability的验证，是个三层大循环，遍历所有的Replica/Instances/Commands，此时我们检查(replica, i, C)，<strong>始终</strong>满足：<br>在replica的cmdLog[replica]中任选一条记录rec1，它的(inst,cmd)等于(replica, i)，并且status为committed或者executed，那么<strong>始终</strong>存在另一个满足条件的rec2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stability ==</span><br><span class="line">    \A replica \in Replicas :</span><br><span class="line">        \A i \in Instances :</span><br><span class="line">            \A C \in Commands :</span><br><span class="line">                []((\E rec1 \in cmdLog[replica] :</span><br><span class="line">                    /\ rec1.inst = i</span><br><span class="line">                    /\ rec1.cmd = C</span><br><span class="line">                    /\ rec1.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;) =&gt;</span><br><span class="line">                    [](\E rec2 \in cmdLog[replica] :</span><br><span class="line">                        /\ rec2.inst = i</span><br><span class="line">                        /\ rec2.cmd = C</span><br><span class="line">                        /\ rec2.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;))</span><br></pre></td></tr></table></figure><p>Consistency的验证，对于所有的Instance i，始终满足它最多只会被commit一次。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consistency ==</span><br><span class="line">    <span class="string">\A</span> i <span class="string">\in</span> Instances :</span><br><span class="line">        [](Cardinality(committed[i]) &lt;= <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">THEOREM Spec =&gt; ([]TypeOK) <span class="regexp">/\ Nontriviality /</span><span class="string">\</span> Stability /<span class="string">\</span> Consistency</span><br></pre></td></tr></table></figure><h2 id="总体的Action"><a href="#总体的Action" class="headerlink" title="总体的Action"></a>总体的Action</h2><p>可以选择执行Command Leader的某个动作，或者普通Replica的某个动作。Command Leader肯定属于Replica，但我们是按照行为来区分的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Next == </span><br><span class="line">    \/ CommandLeaderAction</span><br><span class="line">    \/ ReplicaAction</span><br></pre></td></tr></table></figure><p>首先是Command Leader的所有可能的动作：</p><ol><li>检查<code>Commands \ proposed</code>，也就是<code>Commands</code>中所有还没被propose的Command，如果存在，则<strong>选择一个C</strong>(<code>\E</code>可以表示选出一个的意思)：<br> 选出一个cleader，对C做状态转移<code>Propose(C, cleader)</code></li><li>在Replicas中选出一个cleader，在cleader为Command Leader的instance中选出一个instance，可以执行下面任意的状态转移：<ol><li>可能走Fast Path</li><li>可能走Slow Path</li><li>可能走Phase2Finalize<br> 【Q】Phase2的Accept啥时候发送的？</li><li>可能走优化路径FinalizeTryPreAccept</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLeaderAction ==</span><br><span class="line">    \/ (\E C \in (Commands \ proposed) :</span><br><span class="line">            \E cleader \in Replicas : Propose(C, cleader))</span><br><span class="line">    \/ (\E cleader \in Replicas : \E inst \in leaderOfInst[cleader] :</span><br><span class="line">            \/ (\E Q \in FastQuorums(cleader) : Phase1Fast(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase1Slow(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase2Finalize(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : FinalizeTryPreAccept(cleader, inst, Q)))</span><br></pre></td></tr></table></figure><p>下面是ReplicaAction，选择一个Replica：</p><ol><li>可能回复Phase1</li><li>可能回复Phase2</li><li>可能对于某个Instance i，<code>i[1]</code>表示Instance这个tuple的第一个元素，也就是Replica；<code>crtInst[i[1]]</code>表示它对应的Replica下一个可以使用的instance number，如果大于i本身的instance number。<br> 这个条件说明这个instance被自己原来的owner start。<br> 则通过SlowQuorum个节点进行SendPrepare。<br> 【Q】不太懂什么意思，但这里无疑就是Explicit Prepare里面的Prepare过程了。</li><li>可以ReplyPrepare</li><li>选择一个正在preparing的Replica<br> 通过SlowQuorum个节点进行PrepareFinalize</li><li>回复ReplyTryPreaccept</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReplicaAction ==</span><br><span class="line">    \E replica \in Replicas :</span><br><span class="line">        (\/ Phase1Reply(replica)</span><br><span class="line">         \/ Phase2Reply(replica)</span><br><span class="line">         \/ \E cmsg \in sentMsg : (cmsg.type = &quot;commit&quot; /\ Commit(replica, cmsg))</span><br><span class="line">         \/ \E i \in Instances : </span><br><span class="line">            /\ crtInst[i[1]] &gt; i[2] (* This condition states that the instance has *) </span><br><span class="line">                                    (* been started by its original owner          *)</span><br><span class="line">            /\ \E Q \in SlowQuorums(replica) : SendPrepare(replica, i, Q)</span><br><span class="line">         \/ ReplyPrepare(replica)</span><br><span class="line">         \/ \E i \in preparing[replica] :</span><br><span class="line">            \E Q \in SlowQuorums(replica) : PrepareFinalize(replica, i, Q)</span><br><span class="line">         \/ ReplyTryPreaccept(replica))</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><h3 id="Propose"><a href="#Propose" class="headerlink" title="Propose"></a>Propose</h3><p>从上文看到，CommandLeaderAction的一个可能的状态转移是Propose。<br>此时，生成newInst和newBallot。新生成的newInst的instance number为crtInst[cleader]，newBallot的<code>epoch.b</code>部分始终为0，看来是不考虑epoch了。<br>然后，将要Propose的Command C添加进proposed中，并且在FastQuorum里面选择一个Quorum，尝试走FastPath。<br>然后，我们自增crtInst，这里的<code>@</code>就是<code>crtInst[cleader]</code>，实际上是一个简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Propose(C, cleader) ==</span><br><span class="line">    LET newInst == &lt;&lt;cleader, crtInst[cleader]&gt;&gt; </span><br><span class="line">        newBallot == &lt;&lt;0, cleader&gt;&gt; </span><br><span class="line">    IN  /\ proposed&apos; = proposed \cup &#123;C&#125;</span><br><span class="line">        /\ (\E Q \in FastQuorums(cleader):</span><br><span class="line">                 StartPhase1(C, cleader, Q, newInst, newBallot, &#123;&#125;))</span><br><span class="line">        /\ crtInst&apos; = [crtInst EXCEPT ![cleader] = @ + 1]</span><br><span class="line">        /\ UNCHANGED &lt;&lt; executed, committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><p>对Phase1的处理起始于<code>StartPhase1</code>，这个状态转移触发的条件有很多，比如上面的Propose。<br>首先，构建依赖deps和seq：</p><ol><li>newDeps是Command Leader即cleader中所有Command的Instance，即<code>rec.inst</code>。<br> 【Q】这是不是太强了点？按照协议，首先要是冲突的，然后只要包含最高冲突Instance的编号就行啊。</li><li>newSeq是cleader中所有Command的seq的最大值，然后还要加1，这是符合协议的论述的。</li><li>oldRecs表示cleader中所有和当前Command的Instance相同的Command。</li></ol><p>然后进行状态转移：</p><ol><li>cmdLog<br> 需要修改cleader的Log。具体来说，需要把同Instance的所有的旧的日志全部干掉。【Q】为啥可能会有同Instance的日志呢？<br> 然后，我们把新的Command加上到日志中，并且设置status为”pre-accepted”。也就是说cleader我PreAccept了这个日志，并不代表其他Replica也PreAccept了这个日志。</li><li>leaderOfInst<br> 显然，对于这个Instance，cleader我是它的Leader。这是显然的，因为Instance二元组里面，Replica是cleader，然后instance number也是自增的。<br> 应该加入到leaderOfInst，表示是我发起的，但还没有完成的Instance。</li><li>sentMsg<br> 显然要往其他的Replica发消息。在此之前，我们先要把oldMsg干掉。如果我们是走Propose过来的，那么oldMsg是空的。但如果是走Explicit Prepare过来的，那么是会传入oldMsg的，这个到时候再说。<br> 这里需要注意，消息的定义是<code>src: Replicas, dst: Replicas</code>，但我们传进来的src和dst实际上是两个集合，这会导致产生一系列新Msg。可以参考<a href="/2021/06/26/tla/">TLA</a>的文档。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StartPhase1(C, cleader, Q, inst, ballot, oldMsg) ==</span><br><span class="line">    LET newDeps == &#123;rec.inst: rec \in cmdLog[cleader]&#125; </span><br><span class="line">        newSeq == 1 + Max(&#123;t.seq: t \in cmdLog[cleader]&#125;) </span><br><span class="line">        oldRecs == &#123;rec \in cmdLog[cleader] : rec.inst = inst&#125; IN</span><br><span class="line">        /\ cmdLog&apos; = [cmdLog EXCEPT ![cleader] = (@ \ oldRecs) \cup </span><br><span class="line">                                &#123;[inst   |-&gt; inst,</span><br><span class="line">                                  status |-&gt; &quot;pre-accepted&quot;,</span><br><span class="line">                                  ballot |-&gt; ballot,</span><br><span class="line">                                  cmd    |-&gt; C,</span><br><span class="line">                                  deps   |-&gt; newDeps,</span><br><span class="line">                                  seq    |-&gt; newSeq ]&#125;]</span><br><span class="line">        /\ leaderOfInst&apos; = [leaderOfInst EXCEPT ![cleader] = @ \cup &#123;inst&#125;]</span><br><span class="line">        /\ sentMsg&apos; = (sentMsg \ oldMsg) \cup </span><br><span class="line">                                [type  : &#123;&quot;pre-accept&quot;&#125;,</span><br><span class="line">                                  src   : &#123;cleader&#125;,</span><br><span class="line">                                  dst   : Q \ &#123;cleader&#125;,</span><br><span class="line">                                  inst  : &#123;inst&#125;,</span><br><span class="line">                                  ballot: &#123;ballot&#125;,</span><br><span class="line">                                  cmd   : &#123;C&#125;,</span><br><span class="line">                                  deps  : &#123;newDeps&#125;,</span><br><span class="line">                                  seq   : &#123;newSeq&#125;]</span><br></pre></td></tr></table></figure><h3 id="Phase1Reply"><a href="#Phase1Reply" class="headerlink" title="Phase1Reply"></a>Phase1Reply</h3><p>Propose是发送PreAccept请求，Phase1Reply是其他Replica处理该请求。<br>任选一个发给replica的type为”pre-accept”的消息msg。<br>oldRec为replica日志中，inst等于msg对应的Instance的日志组成的集合。<br>那么对于oldRec中所有的日志rec，要么它的ballot等于msg里的ballot，要么比msg传过来的ballot要小。否则这个消息就应该被忽略。</p><p>构造newDeps为msg传来的deps，加上当前replica所有的log中的Instance(除去msg.inst)。<br>构造newSeq为Max(msg.seq, replica的所有日志中最大的seq+1)。<br>构造instCom，为replica自己日志中所有status为”committed”或”executed”(其实就是已提交)的日志对应的Instance构成的集合。</p><p>下面是状态转移：</p><ol><li>修改当前replica的cmdLog<br> 主要是将status变成”pre-accepted”，然后deps和seq设置为刚算出来的newDeps和newSeq。</li><li>发送消息<br> 发送一条”pre-accept-reply”消息给msg.src，实际上就是刚才发命令过来的cleader。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Phase1Reply(replica) ==</span><br><span class="line">    <span class="string">\E</span> msg <span class="string">\in</span> sentMsg:</span><br><span class="line">        /<span class="string">\</span> msg.type = <span class="string">"pre-accept"</span></span><br><span class="line">        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">        /<span class="string">\</span> LET oldRec == &#123;rec <span class="string">\in</span> cmdLog[replica]: rec.inst = msg.inst&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rec <span class="string">\in</span> oldRec : </span><br><span class="line">                (rec.ballot = msg.ballot <span class="string">\/rec.ballot[1]</span> &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /<span class="string">\</span> LET newDeps == msg.deps <span class="string">\cup</span> </span><br><span class="line">                            (&#123;t.inst: t <span class="string">\in</span> cmdLog[replica]&#125; <span class="string">\</span> &#123;msg.inst&#125;)</span><br><span class="line">                   newSeq == Max(&#123;msg.seq, </span><br><span class="line">                                  <span class="number">1</span> + Max(&#123;t.seq: t <span class="string">\in</span> cmdLog[replica]&#125;)&#125;)</span><br><span class="line">                   instCom == &#123;t.inst: t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">                              tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125; IN</span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup</span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; msg.inst,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "pre-accepted",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; msg.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; msg.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; newDeps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; newSeq]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> &#123;msg&#125;) <span class="string">\cup</span></span><br><span class="line">                                    &#123;[type  |<span class="function">-&gt;</span> <span class="string">"pre-accept-reply"</span>,</span><br><span class="line">                                      src   |<span class="function">-&gt;</span> replica,</span><br><span class="line">                                      dst   |<span class="function">-&gt;</span> msg.src,</span><br><span class="line">                                      inst  |<span class="function">-&gt;</span> msg.inst,</span><br><span class="line">                                      ballot|<span class="function">-&gt;</span> msg.ballot,</span><br><span class="line">                                      deps  |<span class="function">-&gt;</span> newDeps,</span><br><span class="line">                                      seq   |<span class="function">-&gt;</span> newSeq,</span><br><span class="line">                                      committed|<span class="function">-&gt;</span> instCom]&#125;</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Fast"><a href="#Phase1Fast" class="headerlink" title="Phase1Fast"></a>Phase1Fast</h3><p>Phase1Fast是cleader在其他Replica处理该请求后，尝试通过FastPath提交这个请求。里面包含了是否能够进行FastPath提交的判断，以及提交的状态转移。<br>首先，是一部分简单的Enable条件，校验cleader是不是Instance i的Leader，并检查Q是不是cleader的FastQuorums。<br>然后，选择cleader的某条日志record，日志中的Instance为i、Status为”pre-accepted”、ballot的为0。这些日志肯定是从StartPhase1设置的。并且因为ballot为0，所以肯定是从Propose设置的。<br>Q通过刚才的Phase1Reply发回来的replies，它们是”pre-accept-reply”类型的消息，并且ballot等于record对应的ballot，我们进行下面的检查：</p><ol><li>对于Q中除了cleader之外的replica，在replies中都会有从它发给cleader的”pre-accept-reply”消息。<br> 也就是说Q中的Replica，都回复了cleader的pre-accept请求。<br> 这个检查是必要的，如果说之前cleader通过StartPhase1发过去的ballot比较小，那么有的replica就不会回复，因此这条Enable条件就过不了。</li><li>并且replies中任意两个消息r1和r2，它们的deps和seq是相等的。<br> 这是走FastPath的要求，只有满足该要求，才能进下一步。<br> 这个实际上也是Enable条件，如果不满足那么根本就不会有下面的状态转移。</li><li>CHOOSE replies中的某一个r，基于它构造新的r.deps：<br> 这里可以CHOOSE，是因为大家的deps和seq都一样。<br> 注意已提交的日志，指的是status为”committed”和”executed”的日志。<ol><li>localCom<br> cleader的所有的已提交日志的Instance构成集合。</li><li>extCom<br> Phase1Reply中，replica在回复时，会带上自己日志中所有已提交的日志对应的Instance构成的集合。<br> extCom是这些的并集。</li><li>然后构造新的r.deps集合，为localCom和extCom中所有的Instance</li></ol></li></ol><p>然后基于r构造状态转移：</p><ol><li>cmdLog<br> 更新这个日志状态为committed。<br> 更新当前的record的attribute为r.deps和r.seq。</li><li>sentMsg<br> 产生一条Commit信息，这个消息可能是直接给Client的，所以没有dst和src。</li><li>leaderOfInst<br> 在leaderOfInst[cleader]中移除掉当前的Instance i，表示这个Instance已经提交了。</li><li>committed<br> 将<code>&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;</code>加入已提交的数组中。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Phase1Fast(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> FastQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"pre-accepted"</span></span><br><span class="line">        /<span class="string">\</span> record.ballot[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i</span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"pre-accept-reply"</span></span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader</span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q</span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): </span><br><span class="line">                    <span class="string">\E</span> msg <span class="string">\in</span> replies: msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> r1, r2 <span class="string">\in</span> replies:</span><br><span class="line">                /<span class="string">\</span> r1.deps = r2.deps</span><br><span class="line">                /<span class="string">\</span> r1.seq = r2.seq)</span><br><span class="line">            /<span class="string">\</span> LET r == CHOOSE r <span class="string">\in</span> replies : TRUE IN</span><br><span class="line">                /<span class="string">\</span> LET localCom == &#123;t.inst: </span><br><span class="line">                            t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[cleader] : </span><br><span class="line">                                 tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125;</span><br><span class="line">                       extCom == UNION &#123;msg.committed: msg <span class="string">\in</span> replies&#125; IN</span><br><span class="line">                       (r.deps <span class="string">\subseteq</span> (localCom <span class="string">\cup</span> extCom))    </span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                        &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                          status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                          ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                          cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                          deps   |-&gt; r.deps,</span></span><br><span class="line"><span class="string">                                          seq    |-&gt; r.seq ]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                            &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                            inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                            ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                            cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                            deps    |<span class="function">-&gt;</span> r.deps,</span><br><span class="line">                            seq     |<span class="function">-&gt;</span> r.seq]&#125;</span><br><span class="line">                /<span class="string">\</span> leaderOfInst<span class="string">' = [leaderOfInst EXCEPT ![cleader] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                /\ committed'</span> = [committed EXCEPT ![i] = </span><br><span class="line">                                            @ <span class="string">\cup</span> &#123;&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;&#125;]</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Slow"><a href="#Phase1Slow" class="headerlink" title="Phase1Slow"></a>Phase1Slow</h3><p>Phase1Slow是cleader在其他Replica处理该请求后，尝试通过SlowPath提交这个请求。<br>前面的条件都一样，不再赘述。</p><p>主要不一样的地方是从finalDeps开始的。这里大家的deps和seq都不一定一样了，所以不能像FastPath一样CHOOSE了，而要老老实实取并集、取最大值。</p><ol><li>finalDeps<br> 就是所有来自Replica的回复中的deps的并集。</li><li>finalSeq<br> 就是所有回复中最大的seq。</li></ol><p>下面构造状态转移：</p><ol><li>cmdLog<br> 更新日志状态为”accepted”。<br> 注意，在FastPath中，能够直接进入commited状态，但这里得先是”accepted”，后面再走一轮Phase2才行。</li><li>sentMsg<br> 往除自己之外的SlowQuorum成员发送”accept”形式的消息。并且带上deps和seq为finalDeps和finalSeq。这个消息会在Phase2Reply被Replica处理。</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Phase1Slow(cleader, i, Q) ==</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>i <span class="tag">\<span class="name">in</span></span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>Q <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> record <span class="tag">\<span class="name">in</span></span> cmdLog[cleader]:</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.inst = i</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.status = "pre-accepted"</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>LET replies == &#123;msg <span class="tag">\<span class="name">in</span></span> sentMsg: </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.inst = i </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.type = "pre-accept-reply" </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.dst = cleader </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.src <span class="tag">\<span class="name">in</span></span> Q</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>(<span class="tag">\<span class="name">A</span></span> replica <span class="tag">\<span class="name">in</span></span> (Q <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>): <span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies: msg.src = replica)</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>LET finalDeps == UNION &#123;msg.deps : msg <span class="tag">\<span class="name">in</span></span> replies&#125;</span><br><span class="line">                   finalSeq == Max(&#123;msg.seq : msg <span class="tag">\<span class="name">in</span></span> replies&#125;) IN    </span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![cleader] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;record&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span> </span><br><span class="line">                                        &#123;[inst   |-&gt; i,</span><br><span class="line">                                          status |-&gt; "accepted",</span><br><span class="line">                                          ballot |-&gt; record.ballot,</span><br><span class="line">                                          cmd    |-&gt; record.cmd,</span><br><span class="line">                                          deps   |-&gt; finalDeps,</span><br><span class="line">                                          seq    |-&gt; finalSeq ]&#125;]</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> SQ <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader):</span><br><span class="line">                   (sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                            [type : &#123;"accept"&#125;,</span><br><span class="line">                            src : &#123;cleader&#125;,</span><br><span class="line">                            dst : SQ <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>,</span><br><span class="line">                            inst : &#123;i&#125;,</span><br><span class="line">                            ballot: &#123;record.ballot&#125;,</span><br><span class="line">                            cmd : &#123;record.cmd&#125;,</span><br><span class="line">                            deps : &#123;finalDeps&#125;,</span><br><span class="line">                            seq : &#123;finalSeq&#125;])</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><h3 id="Phase2Reply"><a href="#Phase2Reply" class="headerlink" title="Phase2Reply"></a>Phase2Reply</h3><p>Phase2Reply处理在SlowPath中，从Command Leader发过来的”accept”消息。</p><p>这里的Enable条件是，在自己的日志<code>cmdLog[replica]</code>中按照<code>msg.inst</code>找到对应的记录，要求消息的ballot要么等于，要么大于日志中的ballot。</p><p>如果满足Enable条件，则可以进行状态转移：</p><ol><li>cmdLog<br> 修改自己的日志，状态为”accepted”，并且更新deps和seq为msg中传入的值。这个值是由finalDeps和finalSeq一起计算得到的。</li><li>sentMsg<br> 发送”accept-reply”消息给cleader。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phase2Reply</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg: </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "accept"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica]: <span class="keyword">rec</span>.inst = msg.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec: (<span class="keyword">rec</span>.ballot = msg.ballot \/ </span><br><span class="line">                                    <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                &#123;[inst   |-&gt; msg.inst,</span><br><span class="line">                                  status |-&gt; <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot |-&gt; msg.ballot,</span><br><span class="line">                                  cmd    |-&gt; msg.cmd,</span><br><span class="line">                                  deps   |-&gt; msg.deps,</span><br><span class="line">                                  seq    |-&gt; msg.seq]&#125;]</span><br><span class="line">            /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                                &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "accept-reply",</span></span><br><span class="line">                                  src   |-&gt; replica,</span><br><span class="line">                                  dst   |-&gt; msg.src,</span><br><span class="line">                                  inst  |-&gt; msg.inst,</span><br><span class="line">                                  ballot|-&gt; msg.ballot]&#125;</span><br><span class="line">            /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                            committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase2Finalize"><a href="#Phase2Finalize" class="headerlink" title="Phase2Finalize"></a>Phase2Finalize</h3><p>Phase2Finalize是整个SlowQuorum过程的终点，cleader会收集各个Replica的消息，并提交Command。即对于cleader下的某个Instance i，和SlowQuorum Q，尝试完成Phase2的最终提交。</p><p>照例还是Enable条件，在自己的日志里面看看能不能找到i对应的状态为”accepted”的日志，如果找不到，那么也不用往下看了。<br>如果能找到，就需要在sentMsg中找出所有和这个Instance相关的，类型为”accept-reply”的消息(也就是各个Replica在Phase2Reply过程中发出的消息)。显然，对于Q中除cleader之外的replica，都需要发一条这样的消息才能继续提交。</p><p>下面就是状态转移，和Phase1Fast基本一致，就不另外说明了。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Phase2Finalize(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"accepted"</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i </span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"accept-reply"</span> </span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader </span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q </span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): <span class="string">\E</span> msg <span class="string">\in</span> replies: </span><br><span class="line">                                                        msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; record.deps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; record.seq ]&#125;]</span></span><br><span class="line"><span class="string">            /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                        &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                        inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                        ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                        cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                        deps    |<span class="function">-&gt;</span> record.deps,</span><br><span class="line">                        seq     |<span class="function">-&gt;</span> record.seq]&#125;</span><br><span class="line">            /<span class="string">\</span> committed<span class="string">' = [committed EXCEPT ![i] = @ \cup </span></span><br><span class="line"><span class="string">                               &#123;&lt;&lt;record.cmd, record.deps, record.seq&gt;&gt;&#125;]</span></span><br><span class="line"><span class="string">            /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">            /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>下面是Recovery相关操作。</p><h3 id="SendPrepare"><a href="#SendPrepare" class="headerlink" title="SendPrepare"></a>SendPrepare</h3><p>这里的replica就是论文里面的Replica L。其中，Enable条件：</p><ol><li>replica并不是i这个Instance的Leader<br> 这里注释掉一句，是replica并没有prepare这个instance。【Q】我不清楚为什么这个被注释掉。</li><li>目前使用过的ballots不超过MaxBallot<br> 这个应该是防止最后算法不会终止</li><li>replica当前的日志中，不存在任何Instance为i的日志是已提交的(即其status为”committed”和”executed”)。</li></ol><p>状态转移：</p><ol><li>sentMsg<br> 从这个replica向一个SlowQuorum，即Q发送”prepare”消息。<br> 这里注意，更新ballot为<code>&lt;&lt; ballots, replica &gt;&gt;</code>，这里的ballots是全局最大的ballot值。</li><li>ballots<br> 更新全局最大的ballots，自增1。</li><li>preparing<br> 将当前replica的preparing集合中增加Instance i。</li></ol><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SendPrepare(replica, i, Q) ==</span><br><span class="line">    /<span class="symbol">\ </span>i <span class="symbol">\n</span>otin leaderOfInst[replica]</span><br><span class="line">    <span class="symbol">\*</span>/<span class="symbol">\ </span>i <span class="symbol">\n</span>otin preparing[replica]</span><br><span class="line">    /<span class="symbol">\ </span>ballots &lt;= MaxBallot</span><br><span class="line">    /<span class="symbol">\ </span>~(<span class="symbol">\E</span> rec <span class="symbol">\i</span>n cmdLog[replica] :</span><br><span class="line">                        /<span class="symbol">\ </span>rec.inst = i</span><br><span class="line">                        /<span class="symbol">\ </span>rec.status <span class="symbol">\i</span>n &#123;"committed", "executed"&#125;)</span><br><span class="line">    /<span class="symbol">\ </span>sentMsg' = sentMsg <span class="symbol">\c</span>up</span><br><span class="line">                    [type   : &#123;"prepare"&#125;,</span><br><span class="line">                     src    : &#123;replica&#125;,</span><br><span class="line">                     dst    : Q,</span><br><span class="line">                     inst   : &#123;i&#125;,</span><br><span class="line">                     ballot : &#123;&lt;&lt; ballots, replica &gt;&gt;&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>ballots' = ballots + 1</span><br><span class="line">    /<span class="symbol">\ </span>preparing' = [preparing EXCEPT ![replica] = @ <span class="symbol">\c</span>up &#123;i&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst,</span><br><span class="line">                    leaderOfInst, committed &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyPrepare"><a href="#ReplyPrepare" class="headerlink" title="ReplyPrepare"></a>ReplyPrepare</h3><p>ReplyPrepare处理来自SendPrepare里面replica的”prepare”消息。下面进行讨论：</p><ol><li>如果自己的日志中，存在一条对应于msg里面instance的日志，并且消息中的ballot要大于日志中的ballot。<br> 状态转移：<ol><li>sentMsg<br> 将来自SendPrepare里面replica的”prepare”消息删除，并重新发送一条”prepare-reply”消息给msg.src。<br> 消息中的ballot为自己的msg.ballot，prev_ballot为rec.ballot。根据前文，msg.ballot肯定是大于rec.ballot的。<br> 消息中的deps和seq沿用自己本地日志中的。【Q】这里很奇怪，似乎我们不在ReplyPrepare阶段对deps和seq决议。</li><li>cmdLog<br> 删除自己日志中的rec，并且增加一条新条目。这个新条目和rec大致一样，只是将ballot更新为msg中的ballot。</li><li>leaderOfInst<br> 如果日志中的instance的Command Leader是replica，那么将它移出<code>leaderOfInst[replica]</code>。否则保持不变。<br> 【Q】这里是啥意思，重新选一个Command Leader，还是直接走Basic Paxos那一套提交呢？</li></ol></li><li>如果在自己日志中，不存在对应于msg里面instance的日志。<br> 状态转移：<ol><li>sentMsg<br> 发送”prepare-reply”消息。<br> ballot为消息中传来的ballot，并且prev_ballot为<code>&lt;&lt; 0, replica &gt;&gt;</code>，相当于是一开始的ballot。【Q】msg.ballot肯定是大于rec.ballot的么？<br> 其他的字段也是设置成默认值：status为”not-seen”。cmd为none。deps为<code>{}</code>，seq为0。</li><li>cmdLog<br> 参照sentMsg的变更</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyPrepare</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg : </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "prepare"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ \/ \<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : </span><br><span class="line">                /\ <span class="keyword">rec</span>.inst = msg.inst</span><br><span class="line">                /\ msg.ballot[<span class="number">1</span>] &gt; <span class="keyword">rec</span>.ballot[<span class="number">1</span>]</span><br><span class="line">                /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; <span class="keyword">rec</span>.ballot,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;</span><br><span class="line">                 /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ &#123;<span class="keyword">rec</span>&#125;) \cup</span><br><span class="line">                            &#123;[inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;]</span><br><span class="line">                 /\ <span class="type">IF</span> <span class="keyword">rec</span>.inst \<span class="keyword">in</span> leaderOfInst[replica] <span class="type">THEN</span></span><br><span class="line">                        /\ leaderOfInst' = [leaderOfInst <span class="type">EXCEPT</span> ![replica] = </span><br><span class="line">                                                                @ \ &#123;insrec.t&#125;]</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed,</span><br><span class="line">                                        crtInst, ballots, preparing &gt;&gt;</span><br><span class="line">                    <span class="type">ELSE</span> <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst,</span><br><span class="line">                                      ballots, preparing, leaderOfInst &gt;&gt;</span><br><span class="line">                        </span><br><span class="line">           \/ /\ ~(\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = msg.inst)</span><br><span class="line">              /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; msg.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; &lt;&lt; <span class="number">0</span>, replica &gt;&gt;,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;</span><br><span class="line">              /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = @ \cup</span><br><span class="line">                            &#123;[inst  |-&gt; msg.inst,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;]</span><br><span class="line">              /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                              leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="PrepareFinalize"><a href="#PrepareFinalize" class="headerlink" title="PrepareFinalize"></a>PrepareFinalize</h3><p>SendPrepare里面的replica，也就是所谓的Replica L，在收到对端的”prepare-reply”消息后，会走到PrepareFinalize中。这个函数也是最为复杂的。</p><p>Enable条件：</p><ol><li>i要在preparing[replica]中<br> 也就是确认当前replica是Replica L</li><li>replica的日志中有i这个Instance，并且还没被提交</li><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<br> 下面会讨论四种情况，总体是”越来越惨”的<ol><li>如果这些replies中的某个com的status是已提交(即”committed”, “executed”)<br> 【Q】为什么会有这种情况？感觉应该是因为在FastPath的Phase1Fast或者SlowPath的Phase2Finalize之后，cleader宕机导致的。<br> 那么就将这个Instance i移出preparing[replica]。并且在sentMsg中删除所有的replies。<br> 【Q】感觉这就相当于直接让它往后提交了？</li><li>如果这些replies中<strong>没有</strong>status是已提交(即”committed”, “executed”)，但是存在acc是**”accepted”**的。<br> 同时还需要检查acc的prev_ballot大于等于(如果其他消息不是”accept”状态，那么就默认acc的大)所有其他消息的prev_ballot<br> 状态转移：<ol><li>sentMsg<br> 删除所有的replies，并且对除当前replica之外的所有Q，都发送一条”accept”消息。<br> 这个消息的ballot为自己日志中的ballot。<br> 关键内容，即cmd、deps和seq，都设置为acc传过来的。<br> 【Q】为什么replies里面prev_ballot最大的那个消息是”accpeted”，就可以以它为准走”accept流程”？</li><li>cmdLog<br> 参照sentMsg创建一个新条目。</li></ol></li></ol></li></ol><p>因为太长了，所以后面两种情况拆到下面讨论</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PrepareFinalize(replica, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> preparing[replica]</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">       /<span class="string">\</span> rec.inst = i</span><br><span class="line">       /<span class="string">\</span> rec.status <span class="string">\notin</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">       /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg : </span><br><span class="line">                        /<span class="string">\</span> msg.inst = i</span><br><span class="line">                        /<span class="string">\</span> msg.type = <span class="string">"prepare-reply"</span></span><br><span class="line">                        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">                        /<span class="string">\</span> msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rep <span class="string">\in</span> Q : <span class="string">\E</span> msg <span class="string">\in</span> replies : msg.src = rep)</span><br><span class="line">            <span class="regexp">/\  \/</span> <span class="string">\E</span> com <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> (com.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                        /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                        /\ sentMsg'</span> = sentMsg <span class="string">\</span> replies</span><br><span class="line">                        /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                        committed, ballots &gt;&gt;</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> ~(<span class="string">\E</span> msg <span class="string">\in</span> replies : msg.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\E</span> acc <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> acc.status = <span class="string">"accepted"</span></span><br><span class="line">                        /<span class="string">\</span> (<span class="string">\A</span> msg <span class="string">\in</span> (replies <span class="string">\</span> &#123;acc&#125;) : </span><br><span class="line">                            (msg.prev_ballot[<span class="number">1</span>] &lt;= acc.prev_ballot[<span class="number">1</span>] <span class="string">\/</span> </span><br><span class="line">                             msg.status <span class="comment"># "accepted"))</span></span><br><span class="line">                        /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ replies) \cup</span></span><br><span class="line"><span class="string">                                 [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                                  src   : &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  dst   : Q \ &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                                  ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                                  cmd   : &#123;acc.cmd&#125;,</span></span><br><span class="line"><span class="string">                                  deps  : &#123;acc.deps&#125;,</span></span><br><span class="line"><span class="string">                                  seq   : &#123;acc.seq&#125;]</span></span><br><span class="line"><span class="string">                        /\ cmdLog'</span> = [cmdLog EXCEPT ![replica] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                                &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                                  status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                                  cmd   |<span class="function">-&gt;</span> acc.cmd,</span><br><span class="line">                                  deps  |<span class="function">-&gt;</span> acc.deps,</span><br><span class="line">                                  seq   |<span class="function">-&gt;</span> acc.seq]&#125;]</span><br><span class="line">                         /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                         /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![replica] = @ <span class="string">\cup</span> &#123;i&#125;]</span><br><span class="line">                         /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><p>下面是后两种情况：</p><ol><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<ol><li>第一种情况；已经讨论</li><li>第二种情况：已经讨论</li><li>如果这些replies中，同时没有”committed”、”executed”、”accept”状态，但是有”pre-accepted”<br> 将replies中所有的”pre-accepted”提出来为preaccepts，又分为三种情况：<ol><li>preaccepts里面任意两个的cmd、deps和seq都相等。并且preaccepts中没有一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的。并且Q中所有的replica都发了”pre-accepted”给当前的replica。<br> 执行状态转移：<ol><li>sentMsg<br> 从当前replica向Q中所有其他replica发送”accept”。<br> cmd、deps和seq取其中任意一个就行，因为都相等。</li><li>cmdLog<br> 参照sentMsg</li><li>preparing<br> 在preparing[replica]移除掉Instance i。</li><li>leaderOfInst<br> 在leaderOfInst[replica]移除掉Instance i。</li></ol></li><li>如果和之前一样，但Q中只有大于<code>Cardinality(Q) \div 2</code>个replica发送了”pre-accepted”<br> 执行状态转移：<ol><li>sentMsg<br> <strong>这也是全局唯一会走到ReplyTryPreaccept流程里面的情况，对应了优化算法</strong>。<br> 从当前replica向Q中所有其他replica发送”try-pre-accept”。<br> 注意，这个消息<strong>也要</strong>发送给自己，所以和上一个情况是不同的处理策略。<br> cmd、deps和seq的处理办法和上面是一样的。</li></ol></li><li>如果<code>preaccepts</code>不为空，并且满足下面三个条件之一：连cmd、deps和seq都不完全一样了，<strong>或者</strong><code>Cardinality(preaccepts)</code>也小于<code>Cardinality(Q) \div 2</code>，<strong>或者</strong><code>preaccepts</code>中存在一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的<br> 执行状态转移：<ol><li>在preaccepts中CHOOSE一个cmd不为none的pac，执行StartPhase1<br> 但是和Propose的处理不同，这里会带上rec.ballot, replies作为Ballot和oldMsg参数。<br> 而replies会在StartPhase1中被直接干掉(从sendMsg里面删除掉)。</li><li>preparing<br> 去掉i</li></ol></li></ol></li><li>如果这些replies中，状态都是”not-seen”的<br> 执行状态转移：<ol><li>同样执行StartPhase1，但cmd为none。</li><li>preparing<br> 去掉i</li></ol></li></ol></li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span> /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : </span><br><span class="line">                        msg.status <span class="tag">\<span class="name">in</span></span> &#123;"accepted", "committed", "executed"&#125;)</span><br><span class="line">                   /<span class="tag">\<span class="name"> </span></span>LET preaccepts == &#123;msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "pre-accepted"&#125; IN</span><br><span class="line">                       (<span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts :</span><br><span class="line">                                    p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span>p1.deps = p2.deps /<span class="tag">\<span class="name"> </span></span>p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q <span class="tag">\<span class="name"> </span><span class="string">&#123;replica&#125;</span></span>,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![replica] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;rec&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                        &#123;[inst  |-&gt; i,</span><br><span class="line">                                          status|-&gt; "accepted",</span><br><span class="line">                                          ballot|-&gt; rec.ballot,</span><br><span class="line">                                          cmd   |-&gt; pac.cmd,</span><br><span class="line">                                          deps  |-&gt; pac.deps,</span><br><span class="line">                                          seq   |-&gt; pac.seq]&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span></span><br><span class="line">                                                          p1.deps = p2.deps /<span class="tag">\</span></span><br><span class="line">                                                          p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &lt; Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"try-pre-accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; cmdLog, proposed, executed,</span><br><span class="line">                                                crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd # p2.cmd <span class="tag">\<span class="name">/</span></span> </span><br><span class="line">                                                             p1.deps # p2.deps <span class="tag">\<span class="name">/</span></span></span><br><span class="line">                                                             p1.seq # p2.seq</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1]</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> Cardinality(preaccepts) &lt; Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>preaccepts # &#123;&#125;</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : pac.cmd # none IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>StartPhase1(pac.cmd, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;)</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "not-seen"</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>StartPhase1(none, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyTryPreaccept"><a href="#ReplyTryPreaccept" class="headerlink" title="ReplyTryPreaccept"></a>ReplyTryPreaccept</h3><p>找到发给自己的”try-pre-accept”的请求tpa，首先找到自己日志中所有Instance等于tpa.inst的条目oldRec，进行校验：</p><ol><li>tpa的ballot number要大于等于所有oldRec中的ballot number</li><li>所有oldRec中的状态不能是{“accepted”, “committed”, “executed”}</li></ol><p>然后进行讨论：</p><ol><li>如果在oldRec之外，存在某个rec，和tpa是冲突的<br> 如果tpa.inst不属于rec.deps，并且要么rec.inst不属于tpa.deps，要么rec.seq大于tpa.seq。那么rec和tpa是冲突的。<br> 如果存在冲突的话，则执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply消息。<br> 此时，status为rec.status。</li><li>cmdLog<br> 不做改动，可以认为是拒绝了这个消息。</li></ol></li><li>如果对于oldRec之外的的所有rec，都和tpa不冲突<br> 执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply”消息。<br> 注意，status的值是”OK”，这个和冲突情况不一样。【Q】如果此时status的值为”pre-accepted”，那么在FinalizeTryPreAccept中，这条日志仍有被提交的希望？</li><li>cmdLog<br> 删除所有的oldRec，也就是自己日志中所有有关Instance的日志。<br> 新增一条”pre-accepted”日志，这就相当于走完了StartPhase1。</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyTryPreaccept</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> tpa \<span class="keyword">in</span> sentMsg :</span><br><span class="line">        /\ tpa.<span class="class"><span class="keyword">type</span> = "try-pre-accept" </span></span><br><span class="line">        /\ tpa.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = tpa.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ \<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec : <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt;= tpa.ballot[<span class="number">1</span>] /\ </span><br><span class="line">                                   <span class="keyword">rec</span>.status \notin &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">            /\ \/ (\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec:</span><br><span class="line">                        /\ tpa.inst \notin <span class="keyword">rec</span>.deps</span><br><span class="line">                        /\ \/ <span class="keyword">rec</span>.inst \notin tpa.deps</span><br><span class="line">                           \/ <span class="keyword">rec</span>.seq &gt;= tpa.seq</span><br><span class="line">                        /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="keyword">rec</span>.status]&#125;)</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                        ballots, leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               \/ /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec: </span><br><span class="line">                            tpa.inst \<span class="keyword">in</span> <span class="keyword">rec</span>.deps \/ (<span class="keyword">rec</span>.inst \<span class="keyword">in</span> tpa.deps /\</span><br><span class="line">                                                      <span class="keyword">rec</span>.seq &lt; tpa.seq))</span><br><span class="line">                  /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="string">"OK"</span>]&#125;</span><br><span class="line">                  /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                    &#123;[inst  |-&gt; tpa.inst,</span><br><span class="line">                                      status|-&gt; <span class="string">"pre-accepted"</span>,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      cmd   |-&gt; tpa.cmd,</span><br><span class="line">                                      deps  |-&gt; tpa.deps,</span><br><span class="line">                                      seq   |-&gt; tpa.seq]&#125;]</span><br><span class="line">                  /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="FinalizeTryPreAccept"><a href="#FinalizeTryPreAccept" class="headerlink" title="FinalizeTryPreAccept"></a>FinalizeTryPreAccept</h3><p>选出自己Instance为i的日志rec，在所有”try-pre-accept-reply”回复中，取出Instance为i且ballot为rec.ballot的回复，构成集合tprs。<br>那么对于Q中的任意一个r，tprs中肯定有一条消息是从r中发出的。也就是说必须得Q中每一个Replica都回复了”try-pre-accept-reply”，这个也是老生常谈的条件。</p><p>下面是三种情况的讨论：</p><ol><li><code>\A tpr \in tprs: tpr.status = &quot;OK&quot;</code><br> 这说明在ReplyTryPreaccept中，大家都没冲突。这个类似于PrepareFinalize中的accept流程，也就是论文中所谓的Paxos-Accept phase。执行状态转换：<ol><li>sentMsg<br> 直接发送”accept”消息给Q，后面就是走Phase2Reply的流程。</li><li>cmdLog<br> 设置status为”accepted”</li></ol></li><li>如果在tpr中存在某个status为{“accepted”, “committed”, “executed”}的消息<br> 走StartPhase1</li><li>如果tpr.status不全是”OK”，也有”pre-accepted”<br> 这里应该是冲突了，所以直接干掉。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FinalizeTryPreAccept(cleader, i, Q) ==</span><br><span class="line">    <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> rec.inst = i</span><br><span class="line">        <span class="regexp">/\ LET tprs == &#123;msg \in sentMsg : msg.type = "try-pre-accept-reply" /</span><span class="string">\</span></span><br><span class="line">                            msg.dst = cleader <span class="regexp">/\ msg.inst = i /</span><span class="string">\</span></span><br><span class="line">                            msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> <span class="string">\A</span> r <span class="string">\in</span> Q: <span class="string">\E</span> tpr <span class="string">\in</span> tprs : tpr.src = r</span><br><span class="line">            <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"OK"</span></span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ tprs) \cup</span></span><br><span class="line"><span class="string">                             [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                              src   : &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              dst   : Q \ &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                              ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                              cmd   : &#123;rec.cmd&#125;,</span></span><br><span class="line"><span class="string">                              deps  : &#123;rec.deps&#125;,</span></span><br><span class="line"><span class="string">                              seq   : &#123;rec.seq&#125;]</span></span><br><span class="line"><span class="string">                  /\ cmdLog'</span> = [cmdLog EXCEPT ![cleader] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                            &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                              status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                              ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                              cmd   |<span class="function">-&gt;</span> rec.cmd,</span><br><span class="line">                              deps  |<span class="function">-&gt;</span> rec.deps,</span><br><span class="line">                              seq   |<span class="function">-&gt;</span> rec.seq]&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> StartPhase1(rec.cmd, cleader, Q, i, rec.ballot, tprs)</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"pre-accepted"</span></span><br><span class="line">                  /<span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"OK"</span>, <span class="string">"pre-accepted"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = sentMsg \ tprs</span></span><br><span class="line"><span class="string">                  /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                  ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>There Is More Consensus in Egalitarian Parliaments</li><li>EPaxos Revisited</li><li><a href="https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla" target="_blank" rel="noopener">https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla</a><br> 一份TLA+的说明</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍EPaxos算法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Mac电脑配置指南</title>
    <link href="http://www.calvinneo.com/2021/10/01/mac-config/"/>
    <id>http://www.calvinneo.com/2021/10/01/mac-config/</id>
    <published>2021-10-01T04:33:22.000Z</published>
    <updated>2021-10-01T14:16:43.182Z</updated>
    
    <content type="html"><![CDATA[<p>总结Mac系统下的配置相关方法。</p><a id="more"></a><h1 id="输入输出相关"><a href="#输入输出相关" class="headerlink" title="输入输出相关"></a>输入输出相关</h1><p>对于普通外接键盘，配置Alt为Command，Win为Option，Capslock为Control。使用Control+Space切换输入法。</p><h1 id="SSH相关"><a href="#SSH相关" class="headerlink" title="SSH相关"></a>SSH相关</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> -i ~/.ssh/id_rsa.pub root@localhost</span><br><span class="line">sudo systemsetup -setremotelogin <span class="keyword">on</span></span><br></pre></td></tr></table></figure><p>然后参照<a href="https://stackoverflow.com/questions/68827166/how-can-i-ssh-rootlocalhost-and-su-root-without-password-on-macos" target="_blank" rel="noopener">这篇文章</a>设置<code>/etc/ssh/sshd_config</code>。</p><h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>有的时候Brew会Update出问题，或者install不了，这时候可以重装Brew</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/Homebrew/</span>Library<span class="regexp">/Taps/</span>homebrew/</span><br><span class="line">rm -rf homebrew-core</span><br><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/Homebrew/homebrew-core.git</span></span><br></pre></td></tr></table></figure><h1 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="为什么不能core？"><a href="#为什么不能core？" class="headerlink" title="为什么不能core？"></a>为什么不能core？</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sysctl kern.coredump=<span class="number">1</span></span><br><span class="line">chmod <span class="number">777</span> /cores</span><br></pre></td></tr></table></figure><h2 id="Finder显示全部路径"><a href="#Finder显示全部路径" class="headerlink" title="Finder显示全部路径"></a>Finder显示全部路径</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com<span class="selector-class">.apple</span><span class="selector-class">.finder</span> _FXShowPosixPathInTitle -bool YES</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结Mac系统下的配置相关方法。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>物化视图研究</title>
    <link href="http://www.calvinneo.com/2021/08/23/material_view_study/"/>
    <id>http://www.calvinneo.com/2021/08/23/material_view_study/</id>
    <published>2021-08-23T11:20:33.000Z</published>
    <updated>2021-08-24T06:33:00.961Z</updated>
    
    <content type="html"><![CDATA[<p>研究物化视图(materialized view)相关技术。</p><a id="more"></a><h1 id="Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications"><a href="#Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications" class="headerlink" title="Maintenance of Materialized Views: Problems, Techniques, and Applications"></a>Maintenance of Materialized Views: Problems, Techniques, and Applications</h1><p>什么是view，是从base (stored) relation衍生出来的relation。可以理解为从base table到derived table的函数，因此在访问时会涉及重复计算。<br>什么是materialized view？materialized view类似于一个cache，避免重复计算。materialized view上允许构建索引。<br>什么是view maintainance？在更新base relation的同时，更新view。<br>什么是incremental view maintainance？在某些情况下，只更新一部分view，而不是全部view。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol><li>Information</li><li>Modification<br> 我们是直接处理update，还是将它作为先delete再insert来处理呢？</li><li>Language<br> 这个view是如何表示的？是传统的SPJ？是否有聚合函数？有没有UNION？是Set还是Duplicate(即没有DISTINCT语义)？有没有Recursion？</li><li>Instance</li></ol><h3 id="Information和Modification"><a href="#Information和Modification" class="headerlink" title="Information和Modification"></a>Information和Modification</h3><p>考虑如下relation</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(part_no,part_cost,contract)</span></span></span><br></pre></td></tr></table></figure><p>我们创建一个view，列出所有distinct的part_cost大于1000的part_no。注意，这里的Projection带Distinct语义。</p><p>$$<br>expensiveParts (partNo) = \Pi_{partNo} \sigma_{partCost&gt;1000} (part)<br>$$</p><p>考虑insert下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><ol><li>如果只有materialized view<br> 可以用老版本的判断part_no是否在view中。</li><li>如果只有base relation<br> 用relation <code>part</code>去查看是否存在同样的part_no，但是part_cost更大的，如果有，那么就不要更新了。</li><li>如果part_no is the key<br> 可以推断出part_no肯定不在view中。<br> 因为key保证了唯一性，因为我们insert成功了，所以肯定之前没有part_no。</li></ol><p>考虑delete下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">2000</span>,c12)</span></span></span><br></pre></td></tr></table></figure><p>显然p1在materialized view里面，但是不能断定是否还有类似于<code>part(p1,3000,c13)</code>这样的存在，因此不能直接从view中删除p1。事实上不能<strong>仅</strong>依赖materialized view来处理delete的情况。但如果有下面的，则可以：</p><ol><li>relation <code>part</code></li><li>key constraint<br> 【Q】How</li><li>counts of number of view tuple derivations</li></ol><p>考虑update情况，在某些算法中归结为先delete再insert，这种方式会丢失信息。Ref BCL89 UO92 GJM94。</p><h3 id="Language和Instance"><a href="#Language和Instance" class="headerlink" title="Language和Instance"></a>Language和Instance</h3><p>我们创建一个<code>supp_parts</code>，它是supp和part这两个relation的equijoin。列出了至少有一个supp的part的number，并且已经经过了distinct。</p><p>$$<br>suppParts(partNo) = \Pi_{partNo} (supp \bowtie_{partNo} part)<br>$$</p><p>现在考虑仅适用<code>supp_parts</code>，insert下面条目</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><p>如果<code>supp_parts</code>里面已经有了p1，那么无变化。但是如果view中没有p1，并不能仅通过这个view推断是否要insert。</p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><p>使用数学语言来描述。<br>考虑link(a,b)表示从a到b的一个link，定义hop(X,Y)表示从X经过两个link能到达Y，有</p><p>$$<br>hop(X,Y) = \Pi_{X,Y} (link(X,V) \bowtie_{V=W} link(W,Y))<br>$$</p><h2 id="Full-Information"><a href="#Full-Information" class="headerlink" title="Full Information"></a>Full Information</h2><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><p>术语表：</p><ol><li>π，表示Projection<br> 在实现中，Projection并不是返回DISTINCT的值，需要DISTINCT关键字来返回真正的DISTINCT的值。</li><li>ρ，表示Rename</li><li>σ，表示Selection</li><li>⋈，表示Natual Join</li><li>⋉和⋊<br> 当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。</li><li>▷</li><li>÷</li><li>θ-join和equijoin</li></ol><p>概念表：</p><ol><li>equi join/inner join/natual join<br> equijoin是用等于号连接的join，而inner join可以用<code>&lt;</code>这样的符号join。<br> equijoin可能是inner join，也可能是Left Outer或者Right Outer Join。<br> Natual Join是一种equijoin，他会比较所有的同名列。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.wikipedia.org/wiki/Relational_algebra" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Relational_algebra</a><br> 关系术语</li><li><a href="https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join" target="_blank" rel="noopener">https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join</a><br> 介绍Natual join，equijion和inner join。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究物化视图(materialized view)相关技术。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Rust - A CPP Programmer&#39;s Perspective</title>
    <link href="http://www.calvinneo.com/2021/08/17/rust-acpppp/"/>
    <id>http://www.calvinneo.com/2021/08/17/rust-acpppp/</id>
    <published>2021-08-17T11:20:33.000Z</published>
    <updated>2022-02-22T06:53:17.140Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。</p><p>本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。</p><a id="more"></a><h1 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h1><h2 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h2><p>C++并没有什么包管理，如果我们想要引用什么东西，代码声明一下，然后确保链接器能够看到定义就行。并且因为模板的引入，很多都是头文件，直接include就行。</p><h3 id="crate内"><a href="#crate内" class="headerlink" title="crate内"></a>crate内</h3><p>src/main.rs和src/lib.rs被称为crate根。</p><h3 id="跨crate"><a href="#跨crate" class="headerlink" title="跨crate"></a>跨crate</h3><p>跨crate访问，需要使用Cargo.toml中定义的crate别名。</p><h2 id="Cargo-toml解读"><a href="#Cargo-toml解读" class="headerlink" title="Cargo.toml解读"></a>Cargo.toml解读</h2><ol><li><p>[dependencies]<br> 依赖的第三方package</p></li><li><p>[dev-dependencies]<br> 只有tests/examples/benchmarks依赖的第三方package</p></li><li><p>[features]<br> 用来支持条件编译，例如</p> <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#[cfg(<span class="built_in">feature</span> = <span class="string">"xxx"</span>)]</span><br><span class="line"><span class="keyword">if</span> cfg!(<span class="built_in">feature</span> = <span class="string">"yyy"</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>[lib]</p></li><li><p>[[test]]<br> 两个中括号说明是表数组，我们可以这样写</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="所有权、生命周期"><a href="#所有权、生命周期" class="headerlink" title="所有权、生命周期"></a>所有权、生命周期</h1><p>Rust哪些操作是需要unsafe包裹的呢？</p><ol><li>对<code>*mut T</code>解引用<br> 注意，取引用是safe的</li><li>访问全局的<code>static</code>对象</li></ol><p>这也对应了Rust的两个机制，所有权(禁止裸指针)和并发安全。</p><p>为了检验是否初步理解Rust所有权，可以尝试自己实现一个双向链表。</p><h2 id="绑定和可变性"><a href="#绑定和可变性" class="headerlink" title="绑定和可变性"></a>绑定和可变性</h2><h3 id="let和let-mut"><a href="#let和let-mut" class="headerlink" title="let和let mut"></a>let和let mut</h3><p><code>let x = y</code>表示把y这个值bound/assign到变量x上，因为let是immutable的，所以就不能修改变量x，也就是再次给它赋值(assign)了。如果需要能re-bound或者re-assign，就需要<code>let mut x = y</code>这种形式。</p><p>对结构体而言，如果它是immutable的，那么它的所有成员也都是immutable的。在C++中，可以声明类中的某个成员是mutable的，这样即使在const类中也可以修改它，但Rust不允许这样。</p><p>由此还派生出了<code>&amp;mut</code>和<code>&amp;</code>两种引用。可以可变或者不可变地借用let mut绑定的值，但只能不可变地借用let绑定的值。</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>下面的语句都在尝试定义一个<code>&amp;mut {interger}</code>类型的a，但第三条语句是编译不过的。原因是它触发了Rust里面的pattern matching。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">ref</span> <span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> a = &amp;<span class="keyword">mut</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> &amp;<span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 下面这个语句肯定编译不过，但我们可以从错误中得到a的实际类型</span></span><br><span class="line"><span class="keyword">let</span> _: () = a;</span><br></pre></td></tr></table></figure><p>我们会很熟悉对enum类型，诸如<code>Option</code>和<code>Result</code>，进行Pattern Matching的做法。下面介绍一些不一样的，例如可以Pattern Match一个struct。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@</code>，可以在Pattern Match的时候同时指定期待的值，并将该值保存到局部变量中。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: xv @ <span class="number">1</span>,</span><br><span class="line">            y: yv @ <span class="number">2</span>,</span><br><span class="line">        &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched x &#123;:?&#125; y &#123;:?&#125;"</span>, xv, yv),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在pattern matching的时候不move，<a href="https://stackoverflow.com/questions/29662807/how-do-you-borrow-a-mutable-reference-during-a-match" target="_blank" rel="noopener">而是borrow呢</a>？如下所示，<code>g</code>是一个owned值，而不是一个mutable borrow的值。解决方案就是直接<code>match v.intention_mut()</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intention = v.intention_mut();</span><br><span class="line"><span class="keyword">match</span> intention &#123;</span><br><span class="line">    vehicle::Intention::Die =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    vehicle::Intention::Goto(g) =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Variable-shadow"><a href="#Variable-shadow" class="headerlink" title="Variable shadow"></a>Variable shadow</h3><p>在Rust中有如下称为Variable shadow的做法。一个问题油然而生，既然可以直接<code>let mut</code>，为什么还需要如下的做法呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>其实shadow的含义是这个变量的生命周期没变，只是我们无法通过从前的名字访问它了，而let mut在重新assign之后，原来的value就会被析构掉。进一步举个例子，给出下面这个程序，它的输出是啥？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop &#123;&#125;"</span>, <span class="keyword">self</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>为什么呢？对于第一种情况，a被rebound了，但是<code>S {x: 1}</code>只是被shadow了，并没有立即析构。但对于第二种情况，在rebound的时候，<code>S { x: 1 }</code>就被析构了。</p><h2 id="移动和借用"><a href="#移动和借用" class="headerlink" title="移动和借用"></a>移动和借用</h2><p>可以把所有对值的使用方式归纳为三种：复制、移动和引用(或者称为指针)：</p><ol><li>复制的缺点是浪费空间和时间。</li><li>移动的缺点是很多变量的地址会变，这个FFI带来很多麻烦，需要用Box/Pin将一些东西分配到堆上的固定地址，并且传出裸指针。</li><li>引用的缺点是存在NULL，为了避免NULL，又要引入生命周期注解等机制。此外，即使在有了移动语义后，多线程之间依然可以通过引用来访问同一个值，产生并发问题。</li></ol><p>Rust中的<strong>移动可能伴随着内存地址的变化</strong>。很显然，一个对象从A方法通过调用被移动到B方法中，那么肯定出于不同的栈帧中，它的地址肯定会变化，所以要提防这个。而C++中移动更类似金蝉脱壳，将老对象中的东西拆出来用来构建新对象。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用和借用是什么关系呢？<strong>创建一个引用的行为称为借用</strong>，在借用过程中，是不可以访问owned值的，否则出现<code>use of borrowed xxx</code>错误。</p><p>在C++中，引用必须在定义时就绑定，并且，无论它是可变引用<code>T&amp;</code>还是不可变引用<code>const T&amp;</code>，都不能重新绑定。这很难受，并且<code>std::reference_wrapper</code>也不是什么时候都可以用的。Rust中这些都不是问题，例如下面的代码就可以正常运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a: &amp;<span class="built_in">i32</span>;</span><br><span class="line">a = &amp;<span class="number">1</span>;</span><br><span class="line">a = &amp;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="只能有一个可变借用，或多个不可变借用"><a href="#只能有一个可变借用，或多个不可变借用" class="headerlink" title="只能有一个可变借用，或多个不可变借用"></a>只能有一个可变借用，或多个不可变借用</h3><p>考虑下面的Race Condition:</p><ol><li>多个指针访问同一块数据</li><li>至少一个指针被用来修改数据</li><li>没有同步机制</li></ol><p>Rust解决方案是只能同时有一个可变借用，或者多个不可变借用。问题来了，如果Owner在写，有一个可变引用在写，或者有一个不可变引用在读呢？<br>对于对象的成员函数的调用，这种情况是不存在的。<a href="https://stackoverflow.com/questions/55688018/how-does-rust-prevent-data-races-when-the-owner-of-a-value-can-read-it-while-ano" target="_blank" rel="noopener">如下所示</a>，成员函数需要<code>&amp;self</code>或者<code>&amp;mut self</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="string">"123"</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">x.push_str(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"y = &#123;&#125;"</span>, y);</span><br></pre></td></tr></table></figure><p>那么对于primitive types呢？运行下面的代码，发现出现错误提示”use of borrowed <code>aaa</code>“，这也就是说在借用期间，是无法访问owned value的，毕竟被<strong>借走</strong>了嘛。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bbb = &amp;<span class="keyword">mut</span> aaa;</span><br><span class="line">aaa += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"bbb &#123;:?&#125;"</span>, *bbb);</span><br></pre></td></tr></table></figure><p>注意，下面的代码给人一种”可以同时使用借用和owned的值的错觉“，但并不是这样。因为<code>change_aaa</code>对<code>aaa</code>的借用在调用完成之后就结束了，后面<code>aaa = 2</code>的时候就没有其他借用情况了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change_aaa</span></span>(bbb: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>)&#123;</span><br><span class="line">    *bbb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// TODO 是否可以想个办法异步执行</span></span><br><span class="line">    change_aaa(&amp;<span class="keyword">mut</span> aaa)</span><br><span class="line">    aaa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移动的demo"><a href="#移动的demo" class="headerlink" title="移动的demo"></a>移动的demo</h3><p><code>std::mem::drop</code>函数用来析构T的对象，这是对移动的应用。在调用drop函数时，<code>_x</code>的所有权会被移入。当然，如果实现了<code>Copy</code>，那么<code>drop</code><a href="https://doc.rust-lang.org/std/mem/fn.drop.html" target="_blank" rel="noopener">就无效了</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>&lt;T&gt;(_x: T) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="借用的demo"><a href="#借用的demo" class="headerlink" title="借用的demo"></a>借用的demo</h3><p>当一个函数接受引用作为参数时，需要显式借用，这一点和C++不一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_takes_ref</span></span>(i: &amp;int) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">fn_takes_ref(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line">fn_takes_ref(&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Clone和Copy"><a href="#Clone和Copy" class="headerlink" title="Clone和Copy"></a>Clone和Copy</h2><h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>Rust有一个叫做<code>std::marker::Copy</code>的特殊trait，其中不带有任何方法，所以基本可以视作是给编译器提供的一个marker。如果一个类型实现了Copy trait，在赋值的时候使用复制语义而不是移动语义。</p><p>Rust不允许自身或其任何部分实现了Drop trait的类型使用Copy trait。这听起来很奇怪，但如果我说Copy trait的实现就是bitwise的Copy，就合理了。所以可以近似理解为Copy只适用于C++中的trivial的对象。</p><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>对于非trivial对象，又想复制怎么办呢？一个方法是实现Clone trait。可以理解为是C++中的拷贝构造函数。</p><p>容易想到，如果仅仅实现深复制，那么实际上就是递归调用所有field的<code>.clone()</code>而已，这其实等价于下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但注意，编译器在要求实现Copy后，Clone的含义也必须代表bitwise memcpy。因此我们通常会通过<code>#[derive(Copy,Clone)]</code>来支持自动生成Copy特性。</p><h2 id="所有权相关设施"><a href="#所有权相关设施" class="headerlink" title="所有权相关设施"></a>所有权相关设施</h2><p>介绍Borrow(Mut)/AsRef(Mut)/ToOwned等基础的实现。</p><h3 id="Borrow和AsRef的区别是什么？"><a href="#Borrow和AsRef的区别是什么？" class="headerlink" title="Borrow和AsRef的区别是什么？"></a>Borrow和AsRef的区别是什么？</h3><p>可以看到AsRef和Borrow两个trait的定义不能说非常相似，也可以说是一模一样了，那为什么会分成两个呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">AsRef</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Borrow</span></span>&lt;Borrowed: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Borrowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/rust-lang/rust/issues/24140" target="_blank" rel="noopener">显然这个疑问是普遍的</a>，通常的说法是Borrow更严格，目的是借用；AsRef支持的类型更广，目的是类型转换。但说实话，还是一头雾水。<a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">这篇文章讲解了个例子</a>，概括如下：</p><ol><li>HashMap存储<code>(K, V)</code>对，并且可以通过提供的<code>&amp;K</code>查找对应的<code>&amp;mut V</code>。因为按<code>K</code>查，按<code>&amp;K</code>取，所以需要保证这两个的行为是一致的。<br> 【Q】为什么HashMap要按照<code>&amp;K</code>取呢？</li><li>于此同时，我们可以实现一个<code>CaseInsensitiveString</code>结构，它可以看做是忽略大小写比较的一个String。</li><li>问题来了，我们有<code>impl Borrow&lt;str&gt; for String</code>，那么是否可以实现<code>impl Borrow&lt;str&gt; for CaseInsensitiveString</code>呢？<br> 答案是不可以的，这样会破坏HashMap的一致性。<br> 但这就够了么？难道<code>CaseInsensitiveString</code>不可以转换成<code>&amp;str</code>么？当然可以，所以有AsRef。</li></ol><h3 id="为什么不能从-amp-mut调用Clone？"><a href="#为什么不能从-amp-mut调用Clone？" class="headerlink" title="为什么不能从&amp;mut调用Clone？"></a>为什么不能从<code>&amp;mut</code>调用Clone？</h3><p>从下面的实现可以看到，标准库没有为<code>&amp;mut</code>提供Clone，原因是会产生指向同一个位置的两个<code>&amp;mut</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Clone</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/69875015/why-cant-we-implement-clone-for-mut" target="_blank" rel="noopener">下面的代码</a>中，如果clone了<code>&amp;mut MyStruct2</code>，会出现多个指向同一个地址的<code>&amp;&#39;a mut MyStruct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    val: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct2</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    struct_reference: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> MyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意，clone的目标不是<code>&amp;T</code>而是<code>T</code>。上面例子为什么会失败，原因是在Clone <code>MyStruct</code>的时候递归地需要Clone <code>&amp;&#39;a mut MyStruct</code>导致的。但如果直接对一个<code>&amp;mut T</code>调用Clone就不会出现编译问题，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoClone</span></span>&#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> dc = DoClone&#123;x:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> mdc = &amp;<span class="keyword">mut</span> dc;</span><br><span class="line">mdc.clone();</span><br></pre></td></tr></table></figure><h3 id="ToOwned和Clone的区别是什么？"><a href="#ToOwned和Clone的区别是什么？" class="headerlink" title="ToOwned和Clone的区别是什么？"></a>ToOwned和Clone的区别是什么？</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">ToOwned</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Owned</span></span>: Borrow&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_owned</span></span>(&amp;<span class="keyword">self</span>) -&gt; Self::Owned;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone_into</span></span>(&amp;<span class="keyword">self</span>, target: &amp;<span class="keyword">mut</span> Self::Owned) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子很经典，<code>&quot;123&quot;</code>是一个<code>&amp;str</code>类型，对它调用clone，还会得到一个<code>&amp;str</code>类型。但调用<code>to_owned</code>则会得到一个String类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> become_str = <span class="string">"123"</span>.clone();</span><br><span class="line"><span class="keyword">let</span> become_String = <span class="string">"123"</span>.to_owned();</span><br></pre></td></tr></table></figure><h2 id="指针和智能指针"><a href="#指针和智能指针" class="headerlink" title="指针和智能指针"></a>指针和智能指针</h2><p>C++中，为了突破栈上分配的限制会在堆上分配对象，Rust中为了避免移动，有更进一步的往堆上创建对象的需求。C++不会对指针进行资源管理，后面标准库也只是断断续续支持了一些智能指针，但Rust希望做得更周到一点。</p><p>在Rust中有下面的指针：</p><ol><li><code>*mut T</code>/<code>*const T</code><br> 这是C的裸指针</li><li><code>Box</code></li><li><code>Pin</code></li><li><code>Rc</code></li><li><code>Arc</code><br> 原子引用计数</li><li><code>Ref</code></li><li><code>RefCell</code></li><li><code>Cow</code></li></ol><h3 id="trait-Deref-DerefMut"><a href="#trait-Deref-DerefMut" class="headerlink" title="trait Deref/DerefMut"></a>trait Deref/DerefMut</h3><p>Deref是deref操作符<code>*</code>的 trait，比如<code>*v</code>。它的作用是：</p><ol><li>对于实现了Copy对象，获得其拷贝</li><li>对于没有实现Copy的对象，获得其所有权</li></ol><p>如下所示，一个智能指针对象U比如Box，如果它实现了<code>U: Deref&lt;Target=T&gt;</code>，那么Deref能够从它获得一个<code>&amp;T</code>。实现上，我们从一个<code>&amp;Box&lt;T&gt;</code>解两次引用，获得<code>T</code>，再返回<code>&amp;T</code>。抽象一点来说，在实现了Deref后，能将<code>&amp;U</code>变成<code>&amp;T</code>，换种说法<code>*x</code>的效果就是<code>*Deref::deref(&amp;x)</code>。这么做的好处是将所有奇怪的对智能指针的引用都转成<code>&amp;T</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator&gt; Deref <span class="keyword">for</span> <span class="built_in">Box</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;**<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p><code>RefCell</code>是类似于<code>Box</code>的指针，但相比引用和Box类型在编译期检查借用，RefCell<strong>在运行期检查</strong>。具体来说，RefCell在运行期检查：</p><ol><li>在任意时刻只能获得一个<code>&amp;mut</code>或任意个<code>&amp;</code></li><li>引用指向的对象是存在的</li></ol><p>容易发现<code>RefCell</code>能够帮助用户获得多个<code>&amp;mut</code>，从而实现<a href="https://kaisery.github.io/trpl-zh-cn/ch15-05-interior-mutability.html" target="_blank" rel="noopener">内部可变性</a>。</p><h3 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h3><p>【建议在学习Pin之前，了解Deref和DerefMut】<br>我们知道，一个async fn会产生一个自引用结构<code>AsyncFuture</code>，因此它不能被移动。让一个对象不能被移动的第一步是将它分配到堆上，但<code>Box</code>还不够，因为如下所示，<code>std::mem::swap</code>能够移动Box中的对象。如果我心怀歹意，那其实是可以移动Box中的对象的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb2 = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;);</span><br><span class="line">std::mem::swap(rb.as_mut(), rb2.as_mut());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, rb.b, rb2.b); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p>另一方面，很多FFI的实现<strong>也需要保证地址是不变的</strong>，综上于是就有了Pin。</p><p>Pin分析了下，诸如<code>std::mem::swap</code>之流为什么能移动，原因是它们都能获得<code>&amp;mut T</code>。所以只要限制可变借用，就可以在把对象Pin在堆上。限制获得可变引用简单啊，不实现<code>AsMut</code>就行。</p><p>以上的容易理解，但为什么会有<code>Unpin</code>和<code>!Unpin</code>呢？原因是需要给类型分类，讨论在Pin之前和之后类型的行为。这肯定难以理解，所以不妨先看看Pin是如何创建的，再回过来看。</p><p>在下面的代码中，对一个实现了<code>trait Unpin</code>的类型Target，可以直接通过<code>Pin::new</code>产生一个<code>Pin&lt;P&gt;</code>对象。但如果说是一个<code>!Unpin</code>的对象，反而需要通过<code>Box::pin</code>或者<code>pin_utils::pin_mut!</code>来pin住。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(pointer) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_unchecked</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    Pin &#123; pointer &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下代码展示了这一点</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestUnpin</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestNUnpin</span></span> &#123;</span><br><span class="line">    b: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> TestNUnpin &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rp = std::pin::Pin::new(&amp;<span class="keyword">mut</span> TestUnpin&#123;a: <span class="string">"a"</span>.to_owned()&#125;);</span><br><span class="line">    <span class="comment">// let rnp = std::pin::Pin::new(&amp;mut TestNUnpin&#123;b: "b".to_owned()&#125;);</span></span><br><span class="line">    <span class="keyword">let</span> rnb = <span class="built_in">Box</span>::pin(TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容易产生几个疑问：</p><ol><li><p>为什么可以直接Pin::new一个Unpin对象？<br> 因为对于Unpin，Pin不做任何保证。</p></li><li><p>为什么不能直接Pin::new一个!Unpin的对象？<br> 因为这是不安全的，所以需要用<code>Pin::new_unchecked</code>来创建。<br> 另外，Pin需要保证自己维护的指针不会再被移动了，**即使在自己销毁之后，<a href="https://stackoverflow.com/questions/69854787/why-we-use-boxpin-for-unpin-and-pinnew-for-unpin" target="_blank" rel="noopener">也是不能被移动的</a>**，但这个很难在编译期判定。</p></li><li><p>如果对一个Unpin做了Pin::new，能获得里面的&amp;mut么？<br> 可以通过<code>Pin::get_mut</code>获得</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p = TestUnpin&#123;a: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p2 = TestUnpin&#123;a: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    std::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> p)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    std::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> p2)</span><br><span class="line">&#125;;</span><br><span class="line">std::mem::swap(Pin::get_mut(rp), Pin::get_mut(rp2));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, p.a, p2.a); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p> 但如果类型是!Unpin，则不行</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> np = TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> np2 = TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rnp = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    std::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> np)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rnp2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    std::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> np2)</span><br><span class="line">&#125;;</span><br><span class="line">std::mem::swap(Pin::get_mut(rnp), Pin::get_mut(rnp2));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, rnp.b, rnp2.b); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure></li><li><p>为什么Box::pin可以Pin住!Unpin？<br> <code>Box::pin</code>的实现是传入一个<code>&amp;mut T</code>，然后创建一个<code>Box&lt;&amp;mut T&gt;</code>并立马Pin住它。<br> 在Pin之前，无法移动T，这是因为只能同时有一个可变借用<code>&amp;mut T</code>。<br> 在Pin之后，无法移动T，这是因为Box被实现为owned且unique的。可以参考下面的代码</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t = TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> mt = &amp;<span class="keyword">mut</span> t;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::pin(&amp;<span class="keyword">mut</span> t);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t2 = TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;;</span><br><span class="line">std::mem::swap(mt, &amp;<span class="keyword">mut</span> t2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, t.b, t2.b);</span><br></pre></td></tr></table></figure></li></ol><p>现在回答为什么要有Unpin和!Unpin的问题。对于Unpin类型，它实际上是给Pin做了一个担保，告诉Pin即使我这个类型被移动了也没事，所以Pin对它的作用就是屏蔽了<code>&amp;mut</code>的获取渠道。对于!Unpin和PhantomPinned类型，它们是真的不能被移动的，这不仅要借助Pin，这些类型自己也要提供一个合适的接口，从它们来创建Pin。</p><p>这里另外提一句，!Unpin这样的称为negative bounds，Rust对它的支持还没有稳定下来。</p><h1 id="闭包和函数"><a href="#闭包和函数" class="headerlink" title="闭包和函数"></a>闭包和函数</h1><h2 id="Fn-FnMut-FnOnce"><a href="#Fn-FnMut-FnOnce" class="headerlink" title="Fn/FnMut/FnOnce"></a>Fn/FnMut/FnOnce</h2><p>Rust对<code>a(b,c,d)</code>这样的调用搞了个有点像Haskell中的<code>$</code>的东西，目的是为了<strong>重载“对函数的调用”</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fn</span>::call(&amp;a, (b, c, d))</span><br><span class="line"><span class="built_in">FnMut</span>::call_mut(&amp;<span class="keyword">mut</span> a, (b, c, d))</span><br><span class="line"><span class="built_in">FnOnce</span>::call_once(a, (b, c, d))</span><br></pre></td></tr></table></figure><p><code>FnOnce</code>会获取自由变量的所有权，并且只能调用一次，调用完会把自己释放掉。<br><code>FnMut</code>会可变借用自由变量。<br><code>Fn</code>会不可变借用自由变量。<br><code>FnMut</code>和<code>Fn</code>都可以调用多次。</p><p>可以用下面的代码确定某个函数具体实现了哪个trait，实现了的trait能够通过编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_fn</span> </span>&lt;A, R&gt;(_x: <span class="function"><span class="keyword">fn</span></span>(A) -&gt; R) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_Fn</span> </span>&lt;A, R, F: <span class="built_in">Fn</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnMut</span> </span>&lt;A, R, F: <span class="built_in">FnMut</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnOnce</span> </span>&lt;A, R, F: <span class="built_in">FnOnce</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="/asset/rust/easy_demo.md"></a></p><p>查看代码，发现三者具有继承关系<code>Fn : FnMut : FnOnce</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnOnce</span></span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// The returned type after the call operator is used.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="meta-string">"fn_once_output"</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"fn_once_output"</span>, since = <span class="meta-string">"1.12.0"</span>)]</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_once</span></span>(<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnMut</span></span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Fn</span></span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么是这样的继承关系呢</strong>？<a href="https://stackoverflow.com/questions/31190851/why-is-fn-derived-from-fnmut-which-is-derived-from-fnonce" target="_blank" rel="noopener">这篇回答</a>给出了解释。</p><p>确实可以让FnOnce、FnMut和FnOnce做7种自由组合，但其中只有三种traits是有意义的：</p><ol><li>Fn/FnMut/FnOnce</li><li>FnMut/FnOnce</li><li>FnOnce</li></ol><p>这是因为，如果传入<code>&amp;self</code>可以解决的问题，传入<code>&amp;mut self</code>也可以解决。传入<code>&amp;mut self</code>可以解决的问题，传入<code>self</code>也可以解决。但反之就不一定成立。</p><p>所以self是大哥级的人物，动用了伤害很大，它能够解决一切的问题，所以他是最base的trait，而不是最derive的trait。</p><h3 id="闭包对三个trait的实现"><a href="#闭包对三个trait的实现" class="headerlink" title="闭包对三个trait的实现"></a>闭包对三个trait的实现</h3><ol><li>所有的闭包都实现了FnOnce</li><li>如果闭包只移出了所有权，则只实现FnOnce</li><li>如果闭包没移出所捕获变量的所有权，并修改了变量，则实现FnMut</li><li>如果闭包没移出所捕获变量的所有权，且没有修改变量，则实现Fn</li></ol><p><a href="https://doc.rust-lang.org/1.48.0/std/keyword.move.html" target="_blank" rel="noopener">move关键字不会改变闭包具体实现的trait</a>，而只影响变量的捕获方式，我们将在下节讨论。</p><h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p>上面的章节中介绍了闭包可能实现的三个trait，这个章节说明闭包如何捕获环境中的变量。</p><h3 id="C-中捕获的问题"><a href="#C-中捕获的问题" class="headerlink" title="C++中捕获的问题"></a>C++中捕获的问题</h3><p>在C++中，返回一个捕获了Local变量的闭包，是有安全问题的，见<code>get_f()</code>。<br>对于类中的方法，如果<strong>捕获了this指针</strong>(即使是<code>[=]</code>)并传出，在对象析构之后也是有问题的，见<code>print_this_proxy()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    S(<span class="keyword">int</span> x) : x_(x) &#123;&#125;</span><br><span class="line">    ~S() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; print_this_proxy() &#123;</span><br><span class="line">        <span class="keyword">return</span> [=]()&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"x_ %d"</span>, x_);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; get_f() &#123;</span><br><span class="line">    <span class="function">S <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S %d\n"</span>, s.x_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> f = get_f();</span><br><span class="line">    f(); <span class="comment">// Not safe</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; proxy;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">S <span class="title">s</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        proxy = s.print_this_proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    proxy(); <span class="comment">// Not safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust的捕获"><a href="#Rust的捕获" class="headerlink" title="Rust的捕获"></a>Rust的捕获</h3><p>Rust的捕获相比C++使人比较困惑。首先它没有地方指定捕获哪些变量；另外，还有个move关键字；最后还会加上复制和移动语义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|| <span class="number">42</span>;</span><br><span class="line">|x| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">move</span> |x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><p>闭包按照什么方式捕获，取决于我们打算如何使用捕获后的变量。</p><p>我们不妨看一个例子，首先定义下面的结构。<code>get_number</code>、<code>inc_number</code>和<code>destructor</code>分别需要传入不可变引用，可变引用以及值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MyStruct &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span> </span>(text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, number: <span class="built_in">u32</span>) -&gt; MyStruct &#123;</span><br><span class="line">        MyStruct &#123;</span><br><span class="line">            text: text,</span><br><span class="line">            number: number,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_number</span> </span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">inc_number</span> </span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">destructor</span> </span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Destructing &#123;&#125;"</span>, <span class="keyword">self</span>.text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码展示了类似fn的情况，这里fn并没有捕获任何自由变量，因此下面的代码可以正常编译和运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> closure1 = |x: &amp;MyStruct| x.get_number() + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj1), <span class="number">18</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj2), <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">is_fn(closure1); </span><br><span class="line">is_Fn(&amp;closure1);</span><br><span class="line">is_FnMut(&amp;closure1);</span><br><span class="line">is_FnOnce(&amp;closure1);</span><br></pre></td></tr></table></figure><p>下面的代码展示了Fn的情况，这里closure2捕获了obj1的引用。后面的代码进行验证，仍然可以<code>obj1.get_number()</code>来不可变借用，但需要可变引用的<code>obj1.inc_number()</code>就不能通过编译了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure immutably.</span></span><br><span class="line"><span class="keyword">let</span> closure2 = |x: &amp;MyStruct| x.get_number() + obj1.get_number();</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure2(&amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number();               // ERROR</span></span><br></pre></td></tr></table></figure><p>事实上，闭包类似语法糖，相当于把需要捕获的上下文封装到一个Context里面传给真正的执行单元。例如我们可以改写closure2，得到一个自由函数func2。它接受一个Context对象，里面封装了一个不可变引用，并且其生命周期等于Context的生命周期。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> MyStruct);</span><br><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = Context(&amp;obj1);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span> </span>(context: &amp;Context, x: &amp;MyStruct) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    x.get_number() + context.<span class="number">0</span>.get_number()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number(); // ERROR</span></span><br></pre></td></tr></table></figure><p>其实细心观察，就可以提出反对意见。上面的case中不能<code>obj1.inc_number()</code>原因是我们没有<code>let mut obj1 = ...</code>，如果加上去就能正常编译了。这不就是同时Immutable和Mutable Borrow了么？其实我们在最后加一行，再调用一次<code>func2</code>就能报错了。看起来Rust还蛮智能的，func2虽然可变借用，但后续没有用到了，所以就不影响<code>obj1.get_number()</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>下面的代码展示了FnMut的情况。现在闭包里就直接是可变借用了。在闭包之外，我们既不能可变借用，也不能不变借用，否则都无法编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure mutably.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> closure3 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.inc_number();</span><br><span class="line">    x.get_number() + obj1.get_number()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">26</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">27</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">28</span>);</span><br><span class="line"><span class="comment">// We can't borrow obj1 mutably or immutably</span></span><br><span class="line"><span class="comment">// assert_eq!(obj1.get_number(), 18);   // ERROR</span></span><br><span class="line"><span class="comment">// obj1.inc_number();                   // ERROR</span></span><br></pre></td></tr></table></figure><p>下面的代码展示了FnOnce的情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is owned by the closure</span></span><br><span class="line"><span class="keyword">let</span> closure4 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.destructor();</span><br><span class="line">    x.get_number()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尝试用四个函数检查下，发现上面三个trait的检查都无法通过编译，也就说明closure4没有实现上面三个trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not compile:</span></span><br><span class="line"><span class="comment">// is_fn(closure4);</span></span><br><span class="line"><span class="comment">// is_Fn(&amp;closure4);</span></span><br><span class="line"><span class="comment">// is_FnMut(&amp;closure4);</span></span><br><span class="line"><span class="comment">// Compiles successfully:</span></span><br><span class="line">is_FnOnce(&amp;closure4);</span><br></pre></td></tr></table></figure><p>可以发现，闭包捕获变量按照<code>&amp;T -&gt; &amp;mut T -&gt; T</code>的顺序，和<code>Fn -&gt; FnMut -&gt; FnOnce</code>的继承关系如出一辙。也就是先派小弟尝试捕获，小弟解决不了，再请老大出山的思路。</p><p>当然，可以通过<code>move</code>关键字，强行请老大出山。</p><h3 id="闭包能否被多个线程使用？"><a href="#闭包能否被多个线程使用？" class="headerlink" title="闭包能否被多个线程使用？"></a>闭包能否被多个线程使用？</h3><p><a href="https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads" target="_blank" rel="noopener">https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads</a></p><h1 id="并发与异步"><a href="#并发与异步" class="headerlink" title="并发与异步"></a>并发与异步</h1><h2 id="Send和Sync"><a href="#Send和Sync" class="headerlink" title="Send和Sync"></a>Send和Sync</h2><p><code>trait Send</code>表示该类型的实例可以在线程之间移动。大多数的Rust类型都是Send的，另一些则不可以。比如引用计数智能指针<code>Rc&lt;T&gt;</code>只能在线程内部使用，它就不能被实现为<code>Send</code>的；此外裸指针也不是Send的。由Send类型组成的新类型也是Send的。</p><p><code>trait Sync</code>表示多个线程中拥有该类型实例的引用。换句话说，对于任意类型T，如果<code>&amp;T</code>是Send的，那么<code>T</code>就是Sync的。</p><p>不妨看几个Demo：</p><ol><li><p>如果T是Send和Sync的，那么<code>Arc&lt;T&gt;</code>是Send和Sync的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p> 初看这很奇怪，难道不是为了并发安全才用的Arc么？为什么反过来Arc还需要一个并发安全的类型呢？其实Arc相对Rc只是保证了引用计数这一块功能是并发安全的，所以如果类型不是并发安全的，通常需要配合RwLock和Mutex等使用。</p></li><li><p>为各类引用实现Send<br> <code>&amp;T</code>需要T是Sync的，这个对应了上面的定义。<br> <code>&amp;mut T</code>需要T是Send的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Sync</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>各类指针都不是Send的</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>Future的所有权可能在各个线程之间移动，<a href="https://users.rust-lang.org/t/why-future-is-not-send-as-this-value-is-used-across-an-await-and-how-to-fix/40620" target="_blank" rel="noopener">那为什么Future不是Send的呢</a>？</p></li></ol><h2 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h2><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>因为Rust目前不支持可变参数包，所以<a href="https://stackoverflow.com/questions/70082393/why-cant-stdthreadspawn-accept-arguments-in-rust/70082474#70082474" target="_blank" rel="noopener">只能通过spawn闭包的形式创建线程</a>。</p><p>如果子线程panic了，其他线程是没影响的，除非：</p><ol><li>某个线程join了panic的线程，此时会得到一个包含Err的Result，如果直接unwrap则会panic</li><li>如果线程在获得锁后panic，这种现象称为poison<br> 此时，再次尝试<code>mutex.lock()</code>会得到PoisonError，并且<code>mutex.is_poisoned()</code>会返回true。</li></ol><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>下面展示了两种async的写法，一种是async函数<code>plus_one</code>，另一种是async块<code>plus_two</code>。对async函数，编译器在实现时也会最终转成async块的形式，并且会改写函数签名。<br>所以，可以理解为async函数最终是返回了一个<code>impl Future&lt;Output = ...&gt;</code>类型，<code>impl Future</code>表示这个类型实现了<code>trait Future</code>，这应该就是<strong>impl Trait</strong>这个特性。Output是我们期望这个Future在Ready后实际返回的类型，比如在这里就是i32。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">initial</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        initial().await + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">plus_two</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    initial().await + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plus_one_res</code>和<code>plus_two_res</code>都是Future，可以通过<code>block_on</code>获取结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> plus_one_res = plus_one();</span><br><span class="line">    <span class="keyword">let</span> plus_two_res = plus_two();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_one_res));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_two_res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以通过join同时await多个Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">futures::executor::block_on(async &#123;</span><br><span class="line">    <span class="keyword">let</span> j = futures::future::join(plus_one_res, plus_two_res).await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="trait-Future"><a href="#trait-Future" class="headerlink" title="trait Future"></a>trait Future</h3><p>这里指的是<code>std::future::Future</code>，因为在早前还有<code>futures::future::Future</code>，它是一个“社区版”的时候，后来<code>trait Future</code>被整合到了标准库中，剩余部分整合到了<code>pub trait FutureExt: Future</code>，其中包含了<code>map</code>/<code>then</code>等操作。当然对于<code>trait Future</code>还有其他的扩展，例如async-std。但回过头，先来看看最基础的<code>trait Future</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll函数返回的Poll是个enum，包含<code>Ready(T)</code>和<code>Pending</code>两个状态。但它<strong>并不只有忙等</strong>，如果在一次poll后返回的是<code>Pending</code>，那就会注册<code>cx.waker</code>这个回调，在Future后调用进行通知。</p><p><code>Pin&lt;&amp;mut Self&gt;</code>实际是个指针，它是为了解决自引用结构的问题。</p><h4 id="impl-Future"><a href="#impl-Future" class="headerlink" title="impl Future"></a>impl Future</h4><p>impl了<code>trait Future</code>的类型有很多，例如<code>f.map</code>生成的Map，<code>f.then</code>生成的<code>Then</code>这些组合子都是Future。</p><p>例如，下面代码为Map类型impl Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Map</span></span>&lt;I, F&gt; &#123;</span><br><span class="line">    <span class="comment">// Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) iter: I,</span><br><span class="line">    f: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in futures-0.1.31, src/future/map.rs</span></span><br><span class="line"><span class="comment">// 注意，这是一个较老的版本，所以future.poll的签名也不一样。在futures-0.3.15中该实现被挪到了futures-util中</span></span><br><span class="line"><span class="keyword">impl</span>&lt;U, A, F&gt; Future <span class="keyword">for</span> Map&lt;A, F&gt;</span><br><span class="line">    <span class="keyword">where</span> A: Future,</span><br><span class="line">          F: <span class="built_in">FnOnce</span>(A::Item) -&gt; U,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = U;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = A::Error;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Poll&lt;U, A::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> e = <span class="keyword">match</span> <span class="keyword">self</span>.future.poll() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(Async::NotReady) =&gt; <span class="keyword">return</span> <span class="literal">Ok</span>(Async::NotReady),</span><br><span class="line">            <span class="literal">Ok</span>(Async::Ready(e)) =&gt; <span class="literal">Ok</span>(e),</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">        &#125;;</span><br><span class="line">        e.map(<span class="keyword">self</span>.f.take().expect(<span class="string">"cannot poll Map twice"</span>))</span><br><span class="line">         .map(Async::Ready)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>e.map().map()</code>比较独特，前一个map是把<code>self.f</code>应用到e里面的东西，并且清空<code>self.f</code>，让它成为一次性的调用。后一个是把将map的结果包在<code>Async::Ready</code>里面。</p><h3 id="async的生命周期"><a href="#async的生命周期" class="headerlink" title="async的生命周期"></a>async的生命周期</h3><h3 id="async实现"><a href="#async实现" class="headerlink" title="async实现"></a>async实现</h3><p>我们知道，因为在async实现中会产生自引用结构，所以需要用Pin，那什么是自引用结构？为什么async中会存在这种结构呢？<br>首先得从async的实现讲起</p><h4 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h4><p>看下面代码，f1和f2两个await之间是串行的，那么编译器如何生成<code>f.await</code>的代码呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = async <span class="keyword">move</span> &#123;</span><br><span class="line">    f1.await;</span><br><span class="line">    f2.await;</span><br><span class="line">&#125;</span><br><span class="line">f.await;</span><br></pre></td></tr></table></figure><p>如果是用Then的方式，那么就通过回调实现，但这里Rust使用了状态机的方式，即编译器会生成类似<a href="https://huangjj27.github.io/async-book/04_pinning/01_chapter.html" target="_blank" rel="noopener">下面的代码</a>。<code>AsyncFuture</code>实际上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    fut_one: FutOne,</span><br><span class="line">    fut_two: FutTwo,</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    AwaitingFutOne,</span><br><span class="line">    AwaitingFutTwo,</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> AsyncFuture &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">                State::AwaitingFutOne =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_one.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::AwaitingFutTwo,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::AwaitingFutTwo =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_two.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::Done,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::Done =&gt; <span class="keyword">return</span> Poll::Ready(()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么async实现会涉及自引用结构？"><a href="#为什么async实现会涉及自引用结构？" class="headerlink" title="为什么async实现会涉及自引用结构？"></a>为什么async实现会涉及自引用结构？</h4><p>在之前，已经讨论过编译async的普通情况。考虑下面的代码，应该如何编译呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> read_into_buf_fut = read_into_buf(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<a href="https://huangjj27.github.io/async-book/03_async_await/01_chapter.html" target="_blank" rel="noopener">在await时可能发生线程切换</a>，所以我们需要将<code>x</code>也转移到生成的<code>AsyncFuture</code>中，那么<code>read_into_buf</code>就会产生一个指向<code>x</code>的引用。如果在一个结构中，某个字段是指向另一个字段的引用，这就是一个自引用结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadIntoBuf</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    buf: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>], <span class="comment">// points to `x` below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    x: [<span class="built_in">u8</span>; <span class="number">128</span>],</span><br><span class="line">    read_into_buf_fut: ReadIntoBuf&lt;<span class="symbol">'what_lifetime</span>?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自引用结构"><a href="#自引用结构" class="headerlink" title="自引用结构"></a>自引用结构</h4><p>自引用结构如下，b是一个指向a的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: &amp;<span class="symbol">'a</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很遗憾，Rust现在不支持自引用结构，导致下面的代码会报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> _test = Test &#123; a, b: &amp;a &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为workaround，又得用裸指针。但这玩意有个问题，它的地址是绝对的。当Test被移动了，<code>b</code>指向的地址并不会变化。这就好比反过来的刻舟求剑，我们希望b是一个刻在船(Test)上的地址，但实际上它是个GPS坐标。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then用法"><a href="#then用法" class="headerlink" title="then用法"></a>then用法</h3><p>在没有async和await时，可以使用then系列的用法。</p><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><p>数组的签名是<code>[T;N]</code>，和C++一样，数组类型中包含了它的大小，是编译期常量。数组是否是Copy/Clone<a href="https://doc.rust-lang.org/std/primitive.array.html" target="_blank" rel="noopener">取决于其内部的类型</a>，但如果使用<code>[x, N]</code>创建数组，则<code>x</code>对应的类型必须是Copy的。数组引用<code>&amp;[T;N]</code>可以转换为切片引用<code>&amp;[T]</code></p><p>与之对应的是切片<code>&amp;[T]</code>和<code>&amp;mut [T]</code>。</p><h3 id="Sized、-Sized、-Sized和DST"><a href="#Sized、-Sized、-Sized和DST" class="headerlink" title="Sized、!Sized、?Sized和DST"></a>Sized、!Sized、?Sized和DST</h3><p>Dynamically sized type(DST)，即动态大小类型，表示在编译阶段无法确定大小的类型</p><p>如果一个类型在编译期是已知Size，并且Size固定不变的，那么它会自动实现trait Sized。<br>但有些类型是无法在编译期确定大小的，例如<code>str</code>的大小是未知的(<a href="https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str" target="_blank" rel="noopener">所以我们一般通过<code>&amp;str</code>来访问它</a>)，一个trait的大小也是未知的。</p><p>如果一个类型的大小是未知的，那么它的使用会有限制，例如我们不能<code>Vec&lt;T&gt;</code>，而只能将T放到Box里面，做成<code>Vec&lt;Box&lt;T&gt;&gt;</code>。</p><h3 id="胖指针"><a href="#胖指针" class="headerlink" title="胖指针"></a>胖指针</h3><p>胖指针指的是指向DST的<a href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer" target="_blank" rel="noopener">引用<strong>或者指针</strong></a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_of::&lt;&amp;<span class="built_in">u32</span>&gt;()      = <span class="number">8</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>; <span class="number">2</span>]&gt;() = <span class="number">8</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>]&gt;()    = <span class="number">16</span></span><br><span class="line">size_of::&lt;&amp;[<span class="built_in">u32</span>]&gt;()       = <span class="number">16</span></span><br><span class="line">size_of::&lt;&amp;<span class="keyword">mut</span> [<span class="built_in">u32</span>]&gt;()   = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>特别强调，指针也是胖的。考虑到C++允许直接使用delete析构POD数组，这也是和C++部分一致的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_of::&lt;*<span class="keyword">const</span> [<span class="built_in">u32</span>]&gt;() = <span class="number">16</span></span><br><span class="line">size_of::&lt;*<span class="keyword">mut</span> [<span class="built_in">u32</span>]&gt;()   = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>&amp;[u32]</code>具有两倍大小，原因是其中还储存了一份长度，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SliceRef</span></span> &#123; </span><br><span class="line">    ptr: *<span class="keyword">const</span> <span class="built_in">u32</span>, </span><br><span class="line">    len: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能直接把变量绑定到一个DST上，因为编译器无法计算出如何分配内存。例如我们经常见到<code>&amp;str</code>，但基本见不到<code>str</code>。</p><p>除了切片，trait object也是DST，它还包含了一个vptr，将在后面讨论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitObjectRef</span></span> &#123;</span><br><span class="line">    data_ptr: *<span class="keyword">const</span> (),</span><br><span class="line">    vptr: *<span class="keyword">const</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust中的字符串"><a href="#Rust中的字符串" class="headerlink" title="Rust中的字符串"></a>Rust中的字符串</h3><p>Rust中的字符串是很好的比较数组和切片的工具。和C++一样，Rust有两种字符串：</p><ol><li>str<br> str是Rust的原生字符串类型。因为是DST，所以通常以<code>&amp;str</code>出现。</li><li>String<br> String类型可以随时修改其长度和内容。</li></ol><h4 id="str"><a href="#str" class="headerlink" title="str"></a>str</h4><p><code>&amp;str</code>相关方法实现在str.rs的<code>impl str</code>中。通过<code>.as_ptr()</code>将其转换为一个<code>*const u8</code>指针，通过<code>.len()</code>获得其长度。</p><p>字符串字面量的类型是<code>&amp;&#39;static str</code></p><p><code>&amp;str</code>和<code>&amp;[u8]</code>可以互相转换。</p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>略</p><h2 id="ZST"><a href="#ZST" class="headerlink" title="ZST"></a>ZST</h2><p>在C++中，会接触到这样的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZST</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(ZST)</span><br><span class="line"></span><br><span class="line">&amp;ZST() != &amp;ZST()</span><br></pre></td></tr></table></figure><p>在Rust中</p><p>ZST实例的地址是什么呢？</p><h2 id="never类型和"><a href="#never类型和" class="headerlink" title="never类型和!"></a>never类型和!</h2><p>诸如<code>return</code>、<code>break</code>、<code>continue</code>、<code>panic!()</code>、<code>loop</code> 没有返回值的，或者说返回值类型是<code>never</code>即<code>!</code>，对应到类型理论中就是Bottom类型<br>never类型可以转换为其他任何类型，所以在诸如match中才能下入如下代码而不会产生类型错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="built_in">panic!</span></span><br></pre></td></tr></table></figure><p>如下的发散函数也没有返回值，因此也具有never类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>通过turbofish可以辅助推导，下面列出一些例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x.parse::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">[</span><br><span class="line">    AdminCmdType::CompactLog,</span><br><span class="line">    AdminCmdType::ComputeHash,</span><br><span class="line">    AdminCmdType::VerifyHash,</span><br><span class="line">]</span><br><span class="line">.iter()</span><br><span class="line">.cloned()</span><br><span class="line">.collect::&lt;std::collections::HashSet&lt;AdminCmdType&gt;&gt;()</span><br></pre></td></tr></table></figure><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>trait类似于Haskell中的typeclass。</p><h3 id="trait和adhoc多态"><a href="#trait和adhoc多态" class="headerlink" title="trait和adhoc多态"></a>trait和adhoc多态</h3><p>见笔记</p><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>关联类型(associated types)是一个将类型占位符(也就是下面的<code>type Output</code>)与trait相关联的方式。</p><p>考虑如果某个类型impl了trait Add，那么它可以接受一个RHS类型的右操作数，并返回Output类型的结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS, Output&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Output</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">u32</span>, <span class="built_in">u32</span>&gt; <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, ths: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但考虑到trait Add可以接受的RHS可能是多种(例如对String而言可以接受<code>String</code>和<code>&amp;str</code>)，但返回的Output类型是确定的，所以可以将Output类型从由用户指定<strong>改为由实现方指定</strong>。此时就可以定义一个关联类型<code>type Output</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait的继承"><a href="#trait的继承" class="headerlink" title="trait的继承"></a>trait的继承</h3><p>struct不能继承，但是trait可以继承。</p><p>这里涉及到泛型约束的问题，例如我们impl的是两个Father的交集还是并集呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Son</span></span>: Father1 + Father2 &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T: Father1 + Father2&gt; Son <span class="keyword">for</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p>在这里Father1和Father2是取的交集，也就是说对所有实现了Father1和Father2的T实现Son。</p><h3 id="孤儿规则-Orphan-Rule"><a href="#孤儿规则-Orphan-Rule" class="headerlink" title="孤儿规则(Orphan Rule)"></a>孤儿规则(Orphan Rule)</h3><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>例如我们实现sum函数，它只能接受泛型参数T是实现了trait Add的。可以这样写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;T, Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>因为使用了关联参数，所以还可以简写成这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果要写的比较多，可以把里面的东西拿出来，用where来写</p><h3 id="静态分发和动态分发"><a href="#静态分发和动态分发" class="headerlink" title="静态分发和动态分发"></a>静态分发和动态分发</h3><p>静态分发和动态分发是对trait而言的。<br>下面是静态分发，为<code>fly_static::&lt;Pig&gt;</code>和<code>fly_static::&lt;Duck&gt;</code>生成独立的代码。这类似于C++里面的模板实例化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt;(S: T) -&gt; <span class="built_in">bool</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是动态分发，在运行期查找<code>fly_dyn(&amp;Fly)</code>对应类型的方法，例如实际传入的是<code>&amp;Duck</code>还是<code>&amp;Pig</code>，是不一样的。这类似C++里面的动态绑定，是有运行时开销的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，这里的<code>&amp;Fly</code>是啥呢？实际上这是后面讨论的trait对象。</p><h2 id="trait作为存在类型-Existential-Type"><a href="#trait作为存在类型-Existential-Type" class="headerlink" title="trait作为存在类型(Existential Type)"></a>trait作为存在类型(Existential Type)</h2><p>存在类型，又被称为无法直接实例化，它的每个实例是具体类型的实例。<br>对于存在类型，编译期无法知道其功能和Size，目前Rust使用trait object和impl Trait处理存在类型。</p><h3 id="trait-object"><a href="#trait-object" class="headerlink" title="trait object"></a>trait object</h3><p>如下所示，<code>fly_dyn</code>中的<code>&amp;Fly</code>参数就是一个trait object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[allow(missing_debug_implementations)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TraitObject</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> data: *<span class="keyword">mut</span> (),</span><br><span class="line">    <span class="keyword">pub</span> vtable: *<span class="keyword">mut</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable中包含了对象的析构函数、大小、对齐、方法(也就是虚函数指针)等信息。</p><p>只有<strong>对象安全</strong>的trait才可以作为trait object来使用：</p><ol><li>该trait的Self不能被限定为Sized</li><li>该trait的所有方法必须是对象安全的<ol><li>方法受Self: Sized约束</li><li>不包含任何泛型参数</li><li>第一个参数必须为Self类型，或者可以解引用为Self的类型</li><li>Self不能出现在出第一个参数之外的地方，包括返回值中</li></ol></li></ol><h3 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a>impl Trait</h3><p>在目前的版本中，<a href="https://stackoverflow.com/questions/39482131/is-it-possible-to-use-impl-trait-as-a-functions-return-type-in-a-trait-defini" target="_blank" rel="noopener">不能在trait中返回impl Trait</a>，也就是下面的代码无法编译。只能使用Trait Object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Vehicle</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `impl Trait` not allowed outside of function and inherent method return types</span></span><br></pre></td></tr></table></figure><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>默认情况下Rust编译时会link标准库，通过添加<code>no_std</code>属性可以关闭这个行为。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串相关的结构之间的转换"><a href="#字符串相关的结构之间的转换" class="headerlink" title="字符串相关的结构之间的转换"></a>字符串相关的结构之间的转换</h3><p>包括<code>str</code>、<code>String</code>、<code>&amp;[u8]</code>、<code>Vec&lt;u8&gt;</code>。</p><h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><p>如何处理Option呢？</p><ol><li>unwrap+if</li><li>match，并处理<code>Some(e)</code>和<code>None</code></li><li><code>unwrap_or</code></li><li><code>map</code>组合子，<code>and_then</code>组合子</li><li><code>?</code><br> 得到<code>Result&lt;T, NoneError&gt;</code></li></ol><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>如何处理Result呢？</p><ol><li><code>try!</code></li><li><code>?</code></li></ol><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>相比C++的各种测试库，Cargo直接整合了cargo test。</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="线程安全的双向链表"><a href="#线程安全的双向链表" class="headerlink" title="线程安全的双向链表"></a>线程安全的双向链表</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Rust编程之道 by 张汉东</li><li><a href="https://learnku.com/docs/rust-async-std/translation-notes/7132" target="_blank" rel="noopener">https://learnku.com/docs/rust-async-std/translation-notes/7132</a><br> 异步rust学习</li><li><a href="https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html</a><br> 同样是异步教程</li><li><a href="https://huangjj27.github.io/async-book/02_execution/02_future.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/02_execution/02_future.html</a><br> 对Future实现的讲解</li><li><a href="https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/" target="_blank" rel="noopener">https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/</a><br> 这个是用Rust写操作系统的教程，这一节讲的是如何移除标准库</li><li><a href="https://www.cnblogs.com/praying/p/14179397.html" target="_blank" rel="noopener">https://www.cnblogs.com/praying/p/14179397.html</a><br> future的实现，不关注async相关，包含各种组合子</li><li><a href="https://cloud.tencent.com/developer/article/1628311" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1628311</a><br> 对pin的讲解</li><li><a href="https://folyd.com/blog/rust-pin-unpin/" target="_blank" rel="noopener">https://folyd.com/blog/rust-pin-unpin/</a><br> 对pin的讲解</li><li><a href="https://doc.rust-lang.org/std/pin/" target="_blank" rel="noopener">https://doc.rust-lang.org/std/pin/</a><br> pin的官方文档</li><li><a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">https://www.zhihu.com/question/470049587</a><br> AsRef/Borrow/Deref的讲解</li><li><a href="https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html" target="_blank" rel="noopener">https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html</a><br> Fn FnOnce FnMut的区别</li><li><a href="https://zhuanlan.zhihu.com/p/341815515" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341815515</a><br> 对闭包的论述</li><li><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759" target="_blank" rel="noopener">https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</a><br> 对闭包的说明</li><li><a href="https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch" target="_blank" rel="noopener">https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch</a><br> Owner和&amp;mut是否可以同时修改？</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。&lt;/p&gt;
&lt;p&gt;本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Percolator论文阅读</title>
    <link href="http://www.calvinneo.com/2021/08/14/percolator-reading/"/>
    <id>http://www.calvinneo.com/2021/08/14/percolator-reading/</id>
    <published>2021-08-14T11:20:33.000Z</published>
    <updated>2022-02-18T12:55:25.523Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Percolator论文。</p><a id="more"></a><p>类Percolator系统的环境：</p><ol><li><p>一个KV存储<br> 在Percolator中是BigTable，在TiDB中是TiKV。<br> BigTable可以理解为下面的一个KV映射</p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">row</span><span class="symbol">:string</span>, column<span class="symbol">:string</span>, timestamp<span class="symbol">:int64</span>)-&gt;string</span><br></pre></td></tr></table></figure><p> 在Bigtable中已经提供了针对单行的跨column的事务能力。当然，对于Percolator的跨行跨表的事务，这还是不够的。</p></li><li><p>一个全局授时服务器(TSO)<br> 在Percolator中叫Timestamp Oracle。在TiDB中由PD提供。<br> 这个授时服务可以给每个事务一个全局的时间戳，从而解决时序的问题。</p></li><li><p>Client<br> 作为分布式事务的协调者。在TSO的支持下，这个协调者实现了SI的隔离级别。<br> 所以这个协调者并不是在BigTable里面的，而其他数据库的控制节点和数据节点是放到一起的。<br> Percolator里面的每个节点都会向BigTable进行读写。</p></li></ol><h1 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h1><p>在<a href="/2017/09/20/transaction/">数据库系统中的事务</a>这篇文章中介绍了快照隔离(Snapshot Isolation, SI)。<br>在实现SI时，需要记录两个时间戳，事务开始ST和事务提交CT。SI保护了WW冲突，其他事务在[ST,CT]中的写会和本事务产生冲突。</p><p>如下图所示，SI要求在ST1开始的事务，能看到所有CT2先于(因此ST2肯定也先于)自己的ST1事务的修改。<br><img src="/img/dbtrans/percolator3.png"></p><h1 id="2-2-Transactions"><a href="#2-2-Transactions" class="headerlink" title="2.2 Transactions"></a>2.2 Transactions</h1><p>因为Percolator的协调者是BigTable外部的Client，所以需要自己维护锁。锁具有replicated、distributed、balanced、persistent的要求，BigTable作为存储是支持的，所以这个锁作为meta列一同存放在BigTable的中。</p><p>其实有4个Meta列，如下图所示：</p><p><img src="/img/percolator/f5.png"></p><ol><li>lock<br> 表示一个没提交的事务正在写这个cell。包含了primary lock的位置。</li><li>write<br> 表示是已提交的数据。存放了BigTable的时间戳。</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>先来看一个Demo。Bob给Joe转账7块钱。一开始Joe有2块钱，Bob有10块钱。</p><ol><li>写<code>bal:lock</code>加锁Bob的账户，并且这个锁是primary的。此外，写了<code>bal:data</code>为3，也就是扣了7块钱的Bob。</li><li>下面加锁Joe的账户，在<code>bal:lock</code>里面写一个对Bob账户的primary锁的引用。这样在事务挂掉之后，能够知道primary lock在哪里，并且把它清理掉。</li><li>下面进入提交阶段，首先操作primary lock所在的Bob的账户。需要将<code>bal:lock</code>清理掉，<code>bal:write</code>写上对应的ST。通过这个ST就能找到实际的数据<code>bal:data</code>。<br> 在这之后，Reader们就能看到Bob账户上只有3块钱了。</li><li>下面对Secondary也进行写记录和删除锁的处理。</li></ol><p>【Q】看完Demo，有几个问题：</p><ol><li>为什么要引入primary lock？<br> 这个是为了方便进行失败回滚。当事务提交时，会清空primary lock。因此可以认为如果primary lock还在，则事务尚未提交。<br> 例如老事务挂了，留下了一片狼藉的现场。此时，一个新事务可能会访问到老事务残留的secondary lock，对应有两种情况：<ol><li>指向的primary lock还在，认为这个事务还没有提交成功。</li><li>指向的primary lock不在了，认为这个事务提交成功。那么必须先继续提交老事务。</li></ol></li><li>如果说secondary lock被清了一半，怎么办呢？<br> 没问题，后面会讲</li><li>写write列和清空lock是要原子的么？</li><li>在还没有修改Secondary时就可以访问新版本数据了，这个不破坏一致性么？<br> 同问题2</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Percolator事务的模型也是2PC，下面就分两步来看实现，其实就是对Demo的形式化。<br>整个实现是一个Transaction类，包含几个成员：</p><ol><li><p>writes_<br> 这个事务的所有写入。<code>writes_[0]</code>是primary。<br> 一个Percolator事务类似于</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DML/DQL</span><br><span class="line">...</span><br><span class="line">DML/DQL</span><br><span class="line">Prewrite</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure></li><li><p>start_ts_<br> 整个事务的ST时间戳，在事务创建时初始化。</p></li><li><p>Set<br> 往<code>writes_</code>里面加数据。</p></li><li><p>Get<br> 读</p></li><li><p>Commit<br> 提交，首先调用一阶段的Prewrite，如果全部成功，执行二阶段提交。</p></li><li><p>Prewrite<br> 一阶段，会被Commit调用。</p></li></ol><h3 id="Commit-1"><a href="#Commit-1" class="headerlink" title="Commit 1"></a>Commit 1</h3><p>Commit的前几行是封装了一阶段的Prewrite，省得用户自己去调用了：</p><ol><li>选择<code>writes_[0]</code>作为<code>primary</code>，剩余的作为<code>secondaries</code></li><li>对primary做Prewrite</li><li>对所有secondaries做Prewrite</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> <span class="function"><span class="keyword">bool</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">42</span>   Write primary = writes_[<span class="number">0</span>];</span><br><span class="line"><span class="number">43</span>   <span class="built_in">vector</span>&lt;Write&gt; secondaries(writes_.begin()+<span class="number">1</span>, writes_.end());</span><br><span class="line"><span class="number">44</span>   <span class="keyword">if</span> (!Prewrite(primary, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">45</span>   <span class="keyword">for</span> (Write w : secondaries)</span><br><span class="line"><span class="number">46</span>     <span class="keyword">if</span> (!Prewrite(w, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>【Q】先对primary进行Prewrite这个行为是必要的么？此外，在Commit 2阶段也能看到类似的现象。我们放到Commit 2这部分讲。</p><h3 id="Prewrite"><a href="#Prewrite" class="headerlink" title="Prewrite"></a>Prewrite</h3><p>传入的两个参数，primary是<code>writes_[0]</code>，primary lock会在它上面。</p><p>我们需要lock所有被写的cell。</p><p>对于所有的cell检查下面两类冲突：</p><ol><li>【Line 32】如果发现cell的<strong>write列</strong>在自己的ST之后已经存在一条记录，执行abort<br> 这实际上是有其他事务已经提交了修改，事务write-write冲突了。根据SI，需要abort。<br> 【Q】这里有个疑问，SI不是要到提交的时候再检查冲突么？</li><li>【Line 34】如果发现cell的<strong>lock列</strong>上有另外的记录，无论timestamp是什么，执行abort<br> 有可能是一个已经提交的事务，并且它的CT比我们ST还要小，但没来得及清理锁，所以并不是冲突。<br> Percolator认为这个不常见，所以还是abort。<br> 在<a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">文章</a>中还提到可能有失败事务的情况。</li></ol><p>可以发现，检查冲突实际上就是处理write列和lock列。<br>如果没有以上两类冲突，才继续进行：</p><ol><li>【Line36】更新data列，写入ST，以及真正的值<code>w.value</code>。</li><li>【Line37】更新lock列，写入primary锁的row和col。</li></ol><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">27 </span>bool Prewrite(<span class="keyword">Write</span> w, <span class="keyword">Write</span> primary) &#123;</span><br><span class="line"><span class="symbol">28 </span>  Column c = w.col;</span><br><span class="line"><span class="symbol">29 </span>  bigtable::Txn T = bigtable::StartRowTransaction(w.row);</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="symbol">31 </span>  // Abort <span class="keyword">on</span> writes after our start timestamp . . .</span><br><span class="line"><span class="symbol">32 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"write"</span>, [start_ts_ , ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="symbol">33 </span>  // . . . <span class="keyword">or</span> locks at any timestamp.</span><br><span class="line"><span class="symbol">34 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="symbol">36 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"data"</span>, start_ts , w.value);</span><br><span class="line"><span class="symbol">37 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"lock"</span>, start_ts ,</span><br><span class="line"><span class="symbol">38 </span>     &#123;primary.row, primary.col&#125;); // The primary’s location.</span><br><span class="line"><span class="symbol">39 </span>  <span class="keyword">return</span> T.Commit();</span><br><span class="line"><span class="symbol">40 </span>&#125;</span><br></pre></td></tr></table></figure><p>接下来，进入Commit 2阶段。</p><h3 id="Commit-2"><a href="#Commit-2" class="headerlink" title="Commit 2"></a>Commit 2</h3><p>后面就是提交的第二阶段：</p><ol><li>【Line48】向TSO请求时间戳，作为CT</li><li>检查lock是否还存在<br> 【Line53】注意，根据“Failure”章节的论述，这里锁可能已经被其他事务清理了。</li><li>对于primary lock<br> 一旦primary对reader可见，说明事务提交了。<ol><li>【Line55】更新write列<br> write列中存放了ST和CT。<br> 存放ST的原因是可以通过ST找到数据，即data列。</li><li>【Line57】移除锁</li><li>【Line58】提交BigTable的行事务，这里就是所谓的commit point。</li></ol></li><li>对于所有secondary lock<ol><li>【Line62】更新write列</li><li>【Line63】移除锁</li></ol></li></ol><p>【Q】为什么在处理primary的时候就提交行事务<code>T.Commit()</code>了？先对primary进行Prewrite这个行为是必要的么？<br>原因是primary的lock列和write列是判断整个事务状态的金标准。在primary写完write、清完lock之后，就认为事务已经提交，所以就<code>T.Commit()</code>了。后面往secondary写，只是起到通知作用。<br>假如往secondary写失败了，也不会影响到整个事务的提交。因为secondary还是会将请求redirect到primary上，然后就能发现primary的已提交状态。</p><p>【Q】写write删lock是原子操作么？如果不是原子操作，它们的顺序是必然的么？</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> bool Commit() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span>   int commit ts = oracle.GetTimestamp();</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">50</span>   // Commit primary <span class="built_in">first</span>.</span><br><span class="line"><span class="number">51</span>   Write p = primary;</span><br><span class="line"><span class="number">52</span>   bigtable::Txn T = bigtable::StartRowTransaction(p.<span class="built_in">row</span>);</span><br><span class="line"><span class="number">53</span>   <span class="keyword">if</span> (!T.Read(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, [start_ts , start_ts ]))</span><br><span class="line"><span class="number">54</span>     <span class="built_in">return</span> <span class="literal">false</span>; // aborted <span class="keyword">while</span> working</span><br><span class="line"><span class="number">55</span>   T.Write(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts,</span><br><span class="line"><span class="number">56</span>     start_ts ); // Pointer to data written <span class="built_in">at</span> start_ts .</span><br><span class="line"><span class="number">57</span>   T.Erase(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">58</span>   <span class="keyword">if</span> (!T.Commit()) <span class="built_in">return</span> <span class="literal">false</span>; // commit point</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">60</span>   // Second phase: write out write records <span class="keyword">for</span> secondary cells.</span><br><span class="line"><span class="number">61</span>   <span class="keyword">for</span> (Write w : secondaries) &#123;</span><br><span class="line"><span class="number">62</span>     bigtable::Write(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts, start_ts );</span><br><span class="line"><span class="number">63</span>     bigtable::Erase(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">64</span>   &#125;</span><br><span class="line"><span class="number">65</span>   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>首先检查[0, ST]区间内有没有锁。<br>如果有，说明另一个事务在写，这个读取事务就要等锁被释放(也就是事务完成)后才能继续执行。注意，不能在这里返回旧数据，<a href="https://pingcap.com/zh/blog/percolator-and-txn" target="_blank" rel="noopener">否则可能导致幻读</a>。<br>【Line19】 如果没有锁，就读取最后一次写的数据<code>latest_write</code>，并且返回对应的data【Line22】。如果没有读到数据，就返回no data。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">8 </span> bool <span class="keyword">Get</span>(Row row, Column c, string* value) &#123;</span><br><span class="line"><span class="symbol">9 </span>   <span class="keyword">while</span> (true) &#123;</span><br><span class="line"><span class="symbol">10 </span>    bigtable::Txn T = bigtable::StartRowTransaction(row);</span><br><span class="line"><span class="symbol">11 </span>    // Check <span class="keyword">for</span> locks that signal concurrent writes.</span><br><span class="line"><span class="symbol">12 </span>    <span class="keyword">if</span> (T.<span class="keyword">Read</span>(row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, start_ts_])) &#123;</span><br><span class="line"><span class="symbol">13 </span>    // There is a pending lock; try <span class="keyword">to</span> clean it <span class="keyword">and</span> <span class="keyword">wait</span></span><br><span class="line"><span class="symbol">14 </span>    BackoffAndMaybeCleanupLock(row, c);</span><br><span class="line"><span class="symbol">15 </span>    continue;</span><br><span class="line"><span class="symbol">16 </span>  &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="symbol">18 </span>  // Find the latest <span class="keyword">write</span> below our start timestamp.</span><br><span class="line"><span class="symbol">19 </span>  latest_write = T.<span class="keyword">Read</span>(row, c+<span class="string">"write"</span>, [<span class="number">0</span>, start_ts_]);</span><br><span class="line"><span class="symbol">20 </span>  <span class="keyword">if</span> (!latest_write.found()) <span class="keyword">return</span> false; // no <span class="keyword">data</span></span><br><span class="line"><span class="symbol">21 </span>  <span class="keyword">int</span> <span class="keyword">data</span> ts = latest_write.start_timestamp();</span><br><span class="line"><span class="symbol">22 </span>  *value = T.<span class="keyword">Read</span>(row, c+<span class="string">"data"</span>, [data_ts, data_ts]);</span><br><span class="line"><span class="symbol">23 </span>  <span class="keyword">return</span> true;</span><br><span class="line"><span class="symbol">24 </span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h2><p>BigTable能处理自身的问题，但还需要处理Client的Failure。<br>如果在提交事务时Client挂了，Percolator需要能够清除遗留的锁，否则可能导致后续的事务被hang住。这个清除的过程是Lazy的，如果事务A在执行时遇到了事务B的冲突锁，那么A会判定事务B是否宕掉，并清除锁。</p><p>A在清除锁时，如果事务B实际并没有宕掉，而且正准备利用这个锁提交事务，会产生race。primary lock就是来解决这个问题的。因为清理或者提交事务都需要通过这个primary lock，所以事务A的清除锁和事务B的利用锁提交事务只有一个可能成功。</p><p>特别注意，在事务B提交前，需要检查lock是否还在【Line53】，然后才能写write。同理，在事务A清理前，也需要检查primary lock是否存在，如果存在，则可以安全清理掉这个primary lock(看起来挺奇怪的，如果一个锁存在，就清理掉这个锁)。</p><p>还有一种情况，当事务已经写完至少一个write列后发生崩溃，此时可能lock还没有全清理完，write可能没有全写完。此时需要roll forward这个事务。</p><p>总之，整个判断的原则就是lock有没有被write取代。</p><h3 id="Lazy-clean和Liveness"><a href="#Lazy-clean和Liveness" class="headerlink" title="Lazy clean和Liveness"></a>Lazy clean和Liveness</h3><p>因为eager clean会导致事务回滚，带来性能开销。所以只有在该事务的锁被认为是属于某个dead worker时，才会被清理。</p><h2 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h2><p>TSO(Timestamp Oracle)服务会阶段性地分配一段区间，并将这段区间的最大值持久化，剩下的时候就可以直接从内存提供服务。当TSO服务重启时，timestamp就会来到持久化了的最大值上。</p><p>为了减少TSO的压力，每个Percolator worker会batch自己的请求为一个RPC发送给TSO服务。当TSO的负载变大时，Percolator的batch大小也会变大。</p><p>Percolator的事务性要求Get()操作会返回它的ST前所有已经被提交的写。考虑一个事务R在TR读，另一个事务W在TW提交了写，且TW &lt; TR，则R能看到W的写。因为TW &lt; TR，那么TW一定在TR的batch，或者TR之前的batch中。因此可以得到下面的顺序</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W <span class="function"><span class="title">lock</span> -&gt;</span> W <span class="function"><span class="title">request</span> TW -&gt;</span> R <span class="function"><span class="title">get</span> TR -&gt;</span> R read</span><br></pre></td></tr></table></figure><p>实际上，在R读取前，W至少已经写完所有的lock了。所以R要么读到锁，要么读到已经被写完的数据。</p><p>从这里，也可以看出加锁的意义之一。考虑下面的执行顺序，如果不加锁，R就不能知道W在写。因为Commit(row1)的CT是小于Get(row)的ST的，根据SI，TR需要能读到Commit(row1)的结果。如果R不管不顾直接读了，而Commit(row1)又是在读取之后发生的，那么R实际上就读到了Commit(row1)之前的结果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction W       Transaction TR</span><br><span class="line">Prewrite(<span class="name">row1</span>)</span><br><span class="line">W request TW</span><br><span class="line">                    R get TR</span><br><span class="line">                    Get(<span class="name">row</span>) with TR</span><br><span class="line">Commit(<span class="name">row1</span>)</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li>Large-scale Incremental Processing Using Distributed Transactions and Notiﬁcations<br> Percolator论文</li><li><a href="http://mysql.taobao.org/monthly/2018/11/02/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/11/02/</a><br> 阿里数据库月报，对Percolator有较为详细的介绍</li><li><a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">https://www.jianshu.com/p/05194f4b29dd</a><br> 一个简单翻译和个人理解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍Percolator论文。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>WSL2使用的一些问题</title>
    <link href="http://www.calvinneo.com/2021/08/11/wsl2-probs/"/>
    <id>http://www.calvinneo.com/2021/08/11/wsl2-probs/</id>
    <published>2021-08-11T11:20:33.000Z</published>
    <updated>2021-08-27T09:40:23.066Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍WSL2使用的一些问题</p><a id="more"></a><h1 id="Windows-Store相关"><a href="#Windows-Store相关" class="headerlink" title="Windows Store相关"></a>Windows Store相关</h1><h2 id="打不开？"><a href="#打不开？" class="headerlink" title="打不开？"></a>打不开？</h2><p>通常是代理问题。除了网上通用的方案，还需要在“Internet属性-局域网(LAN)设置”中关闭代理。</p><h1 id="使用相关"><a href="#使用相关" class="headerlink" title="使用相关"></a>使用相关</h1><h2 id="打不开Shell"><a href="#打不开Shell" class="headerlink" title="打不开Shell"></a>打不开Shell</h2><p>具体表现为找不到<code>\\wsl$</code>这个位置，执行<code>wsl</code>或者<code>wsl -l -l</code>无响应。<br>解决方案是彻底重启，也就是按住Shift点关机键。</p><h2 id="与Github交互"><a href="#与Github交互" class="headerlink" title="与Github交互"></a>与Github交互</h2><p>不需要共享宿主的SshKey，直接生成自己的，并且加到Github里面。</p><h2 id="支持多版本GCC"><a href="#支持多版本GCC" class="headerlink" title="支持多版本GCC"></a>支持多版本GCC</h2><p>因为默认的Ubuntu 20是用的GCC-9，如果我们要更低版本的GCC，就需要</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc-<span class="number">7</span> g++-<span class="number">7</span></span><br><span class="line">sudo update-alternatives --install <span class="regexp">/usr/</span>bin<span class="regexp">/gcc gcc /u</span>sr<span class="regexp">/bin/g</span>cc-<span class="number">7</span> <span class="number">70</span> --slave <span class="regexp">/usr/</span>bin<span class="regexp">/g++ g++ /u</span>sr<span class="regexp">/bin/g</span>++-<span class="number">7</span></span><br></pre></td></tr></table></figure><h2 id="内存占用问题"><a href="#内存占用问题" class="headerlink" title="内存占用问题"></a>内存占用问题</h2><p>为什么我的Vmmem占用内存这么大？</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="comment">--shutdown</span></span><br><span class="line">wsl <span class="comment">--terminate Ubuntu</span></span><br></pre></td></tr></table></figure><p>创建一个<code>%UserProfile%\.wslconfig</code>来控制用量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[wsl2]</span></span><br><span class="line"><span class="attr">processors</span>=<span class="number">8</span></span><br><span class="line"><span class="attr">memory</span>=<span class="number">8</span>GB</span><br><span class="line"><span class="attr">swap</span>=<span class="number">8</span>GB</span><br><span class="line"><span class="attr">localhostForwarding</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>也可以清理</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -<span class="keyword">c</span> <span class="string">"echo 3 &gt; /proc/sys/vm/drop_caches"</span></span><br></pre></td></tr></table></figure><p>或者定时清理</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="string">/15</span> * * * * sync; <span class="keyword">echo</span> 3 &gt; <span class="string">/proc/sys/vm/drop_caches</span>; touch <span class="string">/root/drop_caches_last_run</span></span><br></pre></td></tr></table></figure><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a><br> WSL2的官方文档</li><li><a href="https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/</a><br> 共享SSH的问题</li><li><a href="https://blog.csdn.net/fengke549015/article/details/106397903" target="_blank" rel="noopener">https://blog.csdn.net/fengke549015/article/details/106397903</a><br> WSL2定时清理内存</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍WSL2使用的一些问题&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Raft的TLA+验证介绍</title>
    <link href="http://www.calvinneo.com/2021/07/28/raft-tla/"/>
    <id>http://www.calvinneo.com/2021/07/28/raft-tla/</id>
    <published>2021-07-28T15:20:37.000Z</published>
    <updated>2021-08-18T07:28:00.813Z</updated>
    
    <content type="html"><![CDATA[<p>介绍使用TLA+对Raft的验证工作。</p><p><a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla" target="_blank" rel="noopener">Ongaro等已经在Github上提供了一版TLA+的实现</a></p><a id="more"></a><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>容易发现，源码里面不包含TLC的Config，但是我们在<a href="https://github.com/ongardie/raft.tla/issues/1" target="_blank" rel="noopener">Issue 1</a>里面能找到一个。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS<span class="built_in"> Server </span>= &#123;r1,r2,r3&#125;</span><br><span class="line">          Value = &#123;v1,v2&#125;</span><br><span class="line">          Follower = Follower</span><br><span class="line">          Candidate = Candidate</span><br><span class="line">          Leader = Leader</span><br><span class="line">          <span class="literal">Nil</span> = <span class="literal">Nil</span></span><br><span class="line">          RequestVoteRequest = RequestVoteRequest</span><br><span class="line">          RequestVoteResponse = RequestVoteResponse</span><br><span class="line">          AppendEntriesRequest = AppendEntriesRequest</span><br><span class="line">          AppendEntriesResponse = AppendEntriesResponse</span><br><span class="line">          TLC_MAX_TERM = 3</span><br><span class="line">          TLC_MAX_ENTRY = 1</span><br><span class="line">          TLC_MAX_MESSAGE = 1</span><br><span class="line">\*          PNat = &#123;1,2,3,4,5&#125;</span><br><span class="line">\*         <span class="built_in"> Nat </span>= &#123;0,1,2,3,4,5&#125;</span><br><span class="line">\*SYMMETRY Perms</span><br><span class="line">SPECIFICATION Spec</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT TermConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT LogConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT MessageConstraint</span><br><span class="line">\*INVARIANT AtMostOneLeaderPerTerm</span><br><span class="line">\*INVARIANT TermAndIndexDeterminesLogPrefix</span><br><span class="line">\*INVARIANT StateMachineSafety</span><br><span class="line">\*INVARIANT NewLeaderHasCompleteLog</span><br><span class="line">\*INVARIANT CommitInOrder</span><br><span class="line"></span><br><span class="line">\*INVARIANT MessageTypeInv</span><br><span class="line">\*INVARIANT TypeInv</span><br></pre></td></tr></table></figure><p>需要限制一下Model</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: Len(log[i]) =&lt; maxLength</span><br><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: currentTerm[i] =&lt; maxTerm</span><br><span class="line">/\ Cardinality(DOMAIN messages) =&lt; maxMessage</span><br><span class="line">/\ restartNum =&lt; maxRestartNum</span><br><span class="line">/\ timeoutNum =&lt; maxTimeoutNum</span><br><span class="line">/\ actionNum =&lt; maxActionNum</span><br></pre></td></tr></table></figure><p>timeoutNum必须至少为1，不然不能触发选举</p><p>列出一下Safety条件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneLeader == Cardinality( &#123;i \<span class="keyword">in</span><span class="built_in"> Server </span>: state[i] = Leader&#125; ) &lt;= 1</span><br></pre></td></tr></table></figure><p>注意如下错误</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The subscript <span class="keyword">of</span> <span class="keyword">the</span> next-state relation specified <span class="keyword">by</span> <span class="keyword">the</span> specification</span><br><span class="line">does <span class="keyword">not</span> seem <span class="built_in">to</span> contain <span class="keyword">the</span> state <span class="built_in">variable</span> xxx</span><br></pre></td></tr></table></figure><p>看看xxx是不是在vars里面</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars</span><br></pre></td></tr></table></figure><p>打印语句</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Print</span><span class="params">(内容, Print语句的值)</span></span></span><br></pre></td></tr></table></figure><p>发现maxMessage必须为1，其他都可以变。</p><h1 id="总体模型"><a href="#总体模型" class="headerlink" title="总体模型"></a>总体模型</h1><h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>下面的变量是全局的：</p><ol><li><p>messages<br> 表示从一个Server发送到另一个Server的消息。因为TLAPS不支持Bags模块(也就是所谓的multiset)，所以这是一个将消息映射为Nat的<strong>函数</strong>。<br> 通过<code>WithMessage(m, msgs)</code>往<code>messages</code>添加一条消息，其中<code>m</code>是我们需要发送的消息，<code>msgs</code>就是<code>messages</code>这个变量。</p> <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WithMessage(m, msgs) ==</span><br><span class="line"><span class="keyword">IF</span> m \<span class="keyword">in</span> DOMAIN msgs <span class="keyword">THEN</span></span><br><span class="line">    [msgs <span class="keyword">EXCEPT</span> ![m] = msgs[m] + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    msgs @@ (m :&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 消息的格式如下图所示</p> <figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">mtype</span>         |-&gt; RequestVoteRequest,</span><br><span class="line"> mterm         |-&gt; currentTerm[<span class="name">i</span>],</span><br><span class="line"> mlastLogTerm  |-&gt; LastTerm(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> mlastLogIndex |-&gt; Len(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> msource       |-&gt; i,</span><br><span class="line"> mdest         |-&gt; j]</span><br></pre></td></tr></table></figure></li><li><p>elections<br> 仅在证明(proof)中需要，实现(implementation)并不需要。<br> 这个用来记录所有成功的选举。包括Leader和Voter的日志。其中一个元素类似下面。</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;[ <span class="function"><span class="title">eterm</span>     |-&gt;</span> currentTerm[i],</span><br><span class="line">   <span class="function"><span class="title">eleader</span>   |-&gt;</span> i,</span><br><span class="line">   <span class="function"><span class="title">elog</span>      |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">   <span class="function"><span class="title">evotes</span>    |-&gt;</span> votesGranted[i],</span><br><span class="line">   <span class="function"><span class="title">evoterLog</span> |-&gt;</span> voterLog[i]]&#125;</span><br></pre></td></tr></table></figure></li><li><p>allLogs<br> 同样仅在证明中需要。<br> 集合了每个Server上的日志</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="literal">all</span>Logs' = <span class="literal">all</span>Logs \cup &#123;<span class="keyword">log</span>[i] : i \<span class="keyword">in</span> Server&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下面的变量是Per Server的：</p><ol><li><p>serverVars<br> 为<code>&lt;&lt;currentTerm, state, votedFor&gt;&gt;</code><br> 在Init中，currentTerm初始化为1，state初始化为Follower，voteFor初始化为Nil。</p></li><li><p>logVars<br> 为<code>&lt;&lt;log, commitIndex&gt;&gt;</code><br> 其中log是A Sequence of log entries，<code>log[i]</code>表示Server i上的日志。<br> 在Init中，log初始化为</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log = [i \<span class="keyword">in</span><span class="built_in"> Server </span>|-&gt; &lt;&lt; &gt;&gt;]</span><br></pre></td></tr></table></figure><p> 每个Log Entry的格式是</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[term  |-&gt; currentTerm[i],</span><br><span class="line"> value |-&gt; v]</span><br></pre></td></tr></table></figure><p> commitIndex初始化为0。</p></li><li><p>candidateVars<br> 为<code>&lt;&lt;votesResponded, votesGranted, voterLog&gt;&gt;</code></p></li><li><p>leaderVars<br> 为<code>&lt;&lt;nextIndex, matchIndex, elections&gt;&gt;</code><br> 在Init中，nextIndex全部被初始化为1，matchIndex全部被初始化为0。</p></li></ol><h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>Quorum实际上是一个集合的集合。表示Server中所有可以形成Quorum的子集。</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quorum == &#123;i \<span class="keyword">in</span> SUBSET(<span class="built_in">Server</span>) : Cardinality(i) * <span class="number">2</span> &gt; Cardinality(<span class="built_in">Server</span>)&#125;</span><br></pre></td></tr></table></figure><h1 id="周边Action"><a href="#周边Action" class="headerlink" title="周边Action"></a>周边Action</h1><h2 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a>Spec</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Next == /<span class="symbol">\ </span><span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Restart(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Timeout(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : RequestVote(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : BecomeLeader(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server, v <span class="symbol">\i</span>n Value : ClientRequest(i, v)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : AdvanceCommitIndex(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : AppendEntries(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : Receive(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DuplicateMessage(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DropMessage(m)</span><br><span class="line">           <span class="symbol">\*</span> History variable that tracks every log ever:</span><br><span class="line">        /<span class="symbol">\ </span>allLogs' = allLogs <span class="symbol">\c</span>up &#123;log[i] : i <span class="symbol">\i</span>n Server&#125;</span><br></pre></td></tr></table></figure><h1 id="主要Acttion"><a href="#主要Acttion" class="headerlink" title="主要Acttion"></a>主要Acttion</h1><h2 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h2><p>Enabling条件，就是自己是Leader，并且不能自己给自己发消息。<br><code>SubSeq(s,m,n)</code>表示<code>&lt;&lt; s[m], s[m+1], ..., s[n] &gt;&gt;</code></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AppendEntries(i, j) ==</span><br><span class="line">    /\ i /= j</span><br><span class="line">    /\ state[i] = Leader</span><br><span class="line">    /\ LET prevLogIndex == nextIndex[i][j] - <span class="number">1</span></span><br><span class="line">           prevLogTerm == IF prevLogIndex &gt; <span class="number">0</span> THEN</span><br><span class="line">                              <span class="built_in">log</span>[i][prevLogIndex].term</span><br><span class="line">                          ELSE</span><br><span class="line">                              <span class="number">0</span></span><br><span class="line">           \* Send up to <span class="number">1</span> entry, constrained <span class="keyword">by</span> the end of the <span class="built_in">log</span>.</span><br><span class="line">           lastEntry == Min(&#123;Len(<span class="built_in">log</span>[i]), nextIndex[i][j]&#125;)</span><br><span class="line">           entries == SubSeq(<span class="built_in">log</span>[i], nextIndex[i][j], lastEntry)</span><br><span class="line">       IN S<span class="function"><span class="title">end</span>([mtype          |-&gt;</span> AppendEntriesRequest,</span><br><span class="line">                <span class="function"><span class="title">mterm</span>          |-&gt;</span> currentTerm[i],</span><br><span class="line">                <span class="function"><span class="title">mprevLogIndex</span>  |-&gt;</span> prevLogIndex,</span><br><span class="line">                <span class="function"><span class="title">mprevLogTerm</span>   |-&gt;</span> prevLogTerm,</span><br><span class="line">                <span class="function"><span class="title">mentries</span>       |-&gt;</span> entries,</span><br><span class="line">                \* mlog <span class="keyword">is</span> used <span class="keyword">as</span> a history variable <span class="keyword">for</span> the proof.</span><br><span class="line">                \* It would <span class="built_in">not</span> exist <span class="built_in">in</span> a <span class="keyword">real</span> implementation.</span><br><span class="line">                <span class="function"><span class="title">mlog</span>           |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">                <span class="function"><span class="title">mcommitIndex</span>   |-&gt;</span> Min(&#123;commitIndex[i], lastEntry&#125;),</span><br><span class="line">                <span class="function"><span class="title">msource</span>        |-&gt;</span> i,</span><br><span class="line">                <span class="function"><span class="title">mdest</span>          |-&gt;</span> j])</span><br><span class="line">    /\ UNCHANGED <span class="string">&lt;&lt;serverVars, candidateVars, leaderVars, logVars&gt;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="对端处理AppendEntries"><a href="#对端处理AppendEntries" class="headerlink" title="对端处理AppendEntries"></a>对端处理AppendEntries</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">HandleAppendEntriesRequest</span><span class="params">(i, j, m)</span></span> ==</span><br><span class="line">    LET logOk == \/ m<span class="selector-class">.mprevLogIndex</span> = <span class="number">0</span></span><br><span class="line">                 \/ /\ m<span class="selector-class">.mprevLogIndex</span> &gt; <span class="number">0</span></span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogIndex</span> &lt;= Len(log[i])</span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogTerm</span> = log[i][m.mprevLogIndex].term</span><br><span class="line">    IN /\ m<span class="selector-class">.mterm</span> &lt;= currentTerm[i]</span><br></pre></td></tr></table></figure><p>下面处理分为三个部分：<br>拒绝</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">       <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\*</span> reject request</span><br><span class="line">                <span class="string">\/</span> m.mterm &lt; currentTerm[i]</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">                   /<span class="string">\</span> state[i] = Follower</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\lnot</span> logOk</span><br><span class="line">             /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                       mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                       msuccess        |<span class="function">-&gt;</span> FALSE,</span><br><span class="line">                       mmatchIndex     |<span class="function">-&gt;</span> <span class="number">0</span>,</span><br><span class="line">                       msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                       mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                       m)</span><br><span class="line">             /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, logVars&gt;&gt;</span><br></pre></td></tr></table></figure><p>切换为Follower</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          \/ \* return <span class="keyword">to</span> follower <span class="keyword">state</span></span><br><span class="line">             /\ m.mterm = currentTerm[i]</span><br><span class="line">             /\ <span class="keyword">state</span>[i] = Candidate</span><br><span class="line">             /\ <span class="keyword">state</span>' = [<span class="keyword">state</span> EXCEPT ![i] = Follower]</span><br><span class="line">             /\ UNCHANGED <span class="variable">&lt;&lt;currentTerm, votedFor, logVars, messages&gt;</span>&gt;</span><br></pre></td></tr></table></figure><p>接受</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          <span class="string">\/</span> <span class="string">\*</span> accept request</span><br><span class="line">             /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">             /<span class="string">\</span> state[i] = Follower</span><br><span class="line">             /<span class="string">\</span> logOk</span><br><span class="line">             /<span class="string">\</span> LET index == m.mprevLogIndex + <span class="number">1</span></span><br><span class="line">                IN <span class="string">\/</span> <span class="string">\*</span> already done <span class="keyword">with</span> request</span><br><span class="line">                       <span class="regexp">/\ \/</span> m.mentries = &lt;&lt; &gt;&gt;</span><br><span class="line">                          <span class="string">\/</span> <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                             /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                             /<span class="string">\</span> log[i][index].term = m.mentries[<span class="number">1</span>].term</span><br><span class="line">                          <span class="string">\*</span> This could make our commitIndex decrease (<span class="keyword">for</span></span><br><span class="line">                          <span class="string">\*</span> example <span class="keyword">if</span> we process an old, duplicated request),</span><br><span class="line">                          <span class="string">\*</span> but <span class="literal">that</span> doesn<span class="string">'t really affect anything.</span></span><br><span class="line"><span class="string">                       /\ commitIndex'</span> = [commitIndex EXCEPT ![i] =</span><br><span class="line">                                              m.mcommitIndex]</span><br><span class="line">                       /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                                 mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                                 msuccess        |<span class="function">-&gt;</span> TRUE,</span><br><span class="line">                                 mmatchIndex     |<span class="function">-&gt;</span> m.mprevLogIndex +</span><br><span class="line">                                                     Len(m.mentries),</span><br><span class="line">                                 msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                                 mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                                 m)</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, log&gt;&gt;</span><br><span class="line">                   <span class="string">\/</span> <span class="string">\*</span> conflict: remove <span class="number">1</span> entry</span><br><span class="line">                       <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                       /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                       <span class="regexp">/\ log[i][index].term /</span>= m.mentries[<span class="number">1</span>].term</span><br><span class="line">                       /<span class="string">\</span> LET <span class="keyword">new</span> == [index2 <span class="string">\in</span> <span class="number">1.</span>.(Len(log[i]) - <span class="number">1</span>) |<span class="function">-&gt;</span></span><br><span class="line">                                          log[i][index2]]</span><br><span class="line">                          IN log<span class="string">' = [log EXCEPT ![i] = new]</span></span><br><span class="line"><span class="string">                       /\ UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span></span><br><span class="line"><span class="string">                   \/ \* no conflict: append entry</span></span><br><span class="line"><span class="string">                       /\ m.mentries /= &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="string">                       /\ Len(log[i]) = m.mprevLogIndex</span></span><br><span class="line"><span class="string">                       /\ log'</span> = [log EXCEPT ![i] =</span><br><span class="line">                                      Append(log[i], m.mentries[<span class="number">1</span>])]</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span><br><span class="line">       /<span class="string">\</span> UNCHANGED &lt;&lt;candidateVars, leaderVars&gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="AppendEntries处理对端返回"><a href="#AppendEntries处理对端返回" class="headerlink" title="AppendEntries处理对端返回"></a>AppendEntries处理对端返回</h2><h2 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla</a><br> Raft的Membership Change证明</li><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla</a><br> 一个带有很多Inv的Raft的TLA+</li><li><a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla" target="_blank" rel="noopener">https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla</a><br> Sequences扩展</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍使用TLA+对Raft的验证工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ongardie/raft.tla/blob/master/raft.tla&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ongaro等已经在Github上提供了一版TLA+的实现&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>TLA用法</title>
    <link href="http://www.calvinneo.com/2021/06/26/tla/"/>
    <id>http://www.calvinneo.com/2021/06/26/tla/</id>
    <published>2021-06-26T15:20:37.000Z</published>
    <updated>2021-12-16T06:57:01.003Z</updated>
    
    <content type="html"><![CDATA[<p>介绍TLA+用法。<br>TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。<br>TLC是TLA+的模型检验工具。</p><a id="more"></a><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>Module，是我们写TLA+ Specification的地方。<br>Model，是我们用TLC检验我们TLA+ Module的地方。</p><h2 id="Model-Value"><a href="#Model-Value" class="headerlink" title="Model Value"></a>Model Value</h2><p>在”What is the model?”中。</p><h2 id="模型-Model-行为"><a href="#模型-Model-行为" class="headerlink" title="模型(Model)行为"></a>模型(Model)行为</h2><p>在”What is the behavior spec?”中。</p><ol><li><p>Ordinary assignment<br> 例如</p> <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RM &lt;- &#123;<span class="string">"r1"</span>, <span class="string">"r2"</span>, <span class="string">"r3"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Model value</p></li><li><p>Set of model values<br> 例如</p> <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RM</span> &lt;- &#123;<span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="built_in">r3</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查项目"><a href="#检查项目" class="headerlink" title="检查项目"></a>检查项目</h2><p>在”What to Check”中：</p><ol><li>Invariants<br> 例如各种Spec</li><li>Properties<br> 例如Termination</li></ol><h2 id="TLC-Option"><a href="#TLC-Option" class="headerlink" title="TLC Option"></a>TLC Option</h2><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>创建一个Spec，写入我们要计算的函数。<br>新建一个Module，设置”What is the behavior spec?”为”No Behavior Spec”。<br>在”Evaluate Constant Expression”中，对我们要计算的函数带入具体值。</p><h2 id="从命令行执行"><a href="#从命令行执行" class="headerlink" title="从命令行执行"></a>从命令行执行</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tlc2<span class="selector-class">.TLC</span> -config .\TESpecSafetyTest<span class="selector-class">.cfg</span> -workers <span class="number">4</span> -dfid <span class="number">10</span> .\TESpecTest.tla</span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h2><ol><li><code>\/</code><br> 表示or。</li><li><code>/\</code><br> 表示and。</li><li><code>\A x \in S: P(x)</code><br> <strong>对于任意的</strong>S中的x，满足<code>P(x)</code>。</li><li><code>\E x \in S: P(x)</code><br> S中<strong>存在</strong>某个x，满足<code>P(x)</code>。<br> 注意，一般会用<code>\E</code>来表示<strong>选择任意一个</strong>元素进行操作的语义。如下所示，我们在<code>AtoB</code>中移除任意一个位置的元素。因此我们进一步能看到，TLA并不是命令式的，而是描述式的。 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\E i \<span class="keyword">in</span> <span class="number">1</span>..Len(A<span class="keyword">to</span>B): A<span class="keyword">to</span>B' = Remove(i, A<span class="keyword">to</span>B)</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数-映射部分"><a href="#函数-映射部分" class="headerlink" title="函数/映射部分"></a>函数/映射部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>函数通常用中括号括起来。</p><ol><li><p><code>F == [x \in S |-&gt; e]</code><br> 对S中的元素应用e，类似于mapper。<br> 函数的执行结果是一个tuple，例如下面函数的结果是<code>&lt;&lt;2, 3&gt;&gt;</code></p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i \in <span class="number">1.</span><span class="number">.2</span> |-&gt; i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>F[x \in S] == e</code></p></li><li><p><code>[S -&gt; T]</code><br> 表示了从S到T的<strong>一系列</strong>函数。<br> <a href="https://learntla.com/tla/functions/" target="_blank" rel="noopener">例如</a>，对于People中的p和Animals中的a，p对a可能like或者hate，我们可以写成下面的形式</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P<span class="function"><span class="title">ref</span> == [People -&gt;</span> [A<span class="function"><span class="title">nimals</span> -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [[person: People, animal: Animals] -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [People \X Animals -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br></pre></td></tr></table></figure><p> 需要区别<code>|-&gt;</code>和<code>-&gt;</code>，前者表示是从DOMAIN到某个特定的RANGE的<strong>一个函数</strong>，后者表示从DOMAIN到RANGE的一系列函数。</p></li><li><p><code>[S EXCEPT ![x] = v]</code><br> 这个语句通常用来表示返回整个集合，但是对集合中的某个特定元素的值进行变化。<br> 如果S是一个集合，表示返回S，除了x等于v。<br> 如果S是一个Record（类似于C里面的struct），表示返回S，除了x等于v。例如</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f EXCEPT !.prof = <span class="string">"RED"</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>@@</code>和<code>:&gt;</code><br> 这两个符号用来定义函数。例如函数定义域是<code>{1,2}</code>，我们可以这么定义<code>f</code></p> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>:&gt; <span class="string">"ab"</span> @@ <span class="number">2</span> :&gt; <span class="string">"cd"</span></span><br></pre></td></tr></table></figure></li><li><p><code>@</code><br> <code>f&#39; = [f EXCEPT ![e1] = f[e1] + 1</code>中，我们就可以写成<code>f&#39; = [f EXCEPT ![e1] = @ + 1]</code></p></li><li><p>直接在集合间映射<br> 例如</p> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS People, Animals</span><br><span class="line">Pref == [person: People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;[<span class="function"><span class="title">person</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>], [person |-&gt;</span> neo]&#125;</span><br></pre></td></tr></table></figure><p> 又例如</p> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Pref</span> == [People -&gt; People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; (<span class="name">calvin</span> <span class="symbol">:&gt;</span> calvin @@ neo <span class="symbol">:&gt;</span> calvin),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> calvin @@ neo <span class="symbol">:&gt;</span> neo),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> neo @@ neo <span class="symbol">:&gt;</span> calvin),</span><br><span class="line"> (<span class="name">calvin</span> <span class="symbol">:&gt;</span> neo @@ neo <span class="symbol">:&gt;</span> neo) &#125;</span><br></pre></td></tr></table></figure><p> 又例如</p> <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pref == [<span class="string">message:</span> &#123;<span class="string">"Hello"</span>&#125;, <span class="string">src:</span>People, <span class="string">dst:</span>People]</span><br></pre></td></tr></table></figure><p> 打印出来是</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>, dst |-&gt;</span> <span class="function"><span class="title">calvin</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">calvin</span>, dst |-&gt;</span> <span class="function"><span class="title">neo</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">neo</span>, dst |-&gt;</span> <span class="function"><span class="title">calvin</span>, message |-&gt;</span> <span class="string">"Hello"</span>],</span><br><span class="line"> [<span class="function"><span class="title">src</span> |-&gt;</span> <span class="function"><span class="title">neo</span>, dst |-&gt;</span> <span class="function"><span class="title">neo</span>, message |-&gt;</span> <span class="string">"Hello"</span>] &#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="集合-元组-Record部分"><a href="#集合-元组-Record部分" class="headerlink" title="集合/元组/Record部分"></a>集合/元组/Record部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>此外，在第339页开始会介绍标准模块，如Sequences、Bags等。</p><ol><li><p>Record<br> Record类似于C++里面的struct。<br> 如何表示一个Record的实例？</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function"><span class="title">type</span> |-&gt;</span> <span class="string">"Prepared"</span>, <span class="function"><span class="title">rm</span> |-&gt;</span> r]</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;&lt;&quot;a&quot;, 42, {1,2}&gt;&gt;</code><br> 表示一个tuple，在P09a中也被Lamport称为Finite sequence。<br> tuple从1编号。</p></li><li><p><code>{1,2,3}</code><br> 表示一个Set。</p></li><li><p>Tuple简单运算符<br> Head和Tail类似于car和cdr。<br> <code>\o</code>表示concat。如果<code>seq /= &lt;&lt;&gt;&gt;</code>，有<code>seq = &lt;&lt;Head(seq)&gt;&gt; \o Tail(seq)</code>。<br> <code>Append(tuple,elem)</code>表示将elem放到tuple的末尾。<br> <code>Len</code>，返回长度。<br> <code>Remove(i, seq)</code>表示从<code>seq</code>移除<code>i</code>位置的元素之后的新seq。<br> <code>\X</code>表示计算笛卡尔积。<br> Seq表示所有由这个tuple中元素构成的序列。例如<code>Seq({2})</code>是<code>{&lt;&lt;&gt;&gt;,&lt;&lt;3&gt;&gt;, &lt;&lt;3,3&gt;&gt;, &lt;&lt;3,3,3&gt;&gt;, ...}</code>。我们可以进行下面的实验</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br><span class="line">&lt;&lt;<span class="number">2</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>Set运算符<br> <code>SUBSET(S)</code>求出所有子集，例如<code>SUBSET( {1,2,3} )</code>返回</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; &#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p> <code>Cardinality(S)</code>计算一个集合的大小。<br> <code>IsFiniteSet(S)</code>计算一个集合是不是有限集。</p></li><li><p><code>DOMAIN &lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;</code><br> 表示一个集合。Lamport说Math中的DOMAIN，对应于Progamming中的Index Set。</p></li><li><p><code>&lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;[2]</code><br> 表示集合中的第2个元素，即<code>&quot;b&quot;</code>。</p></li><li><p>“构造函数”<code>{e: v \in S}</code><br> 对S中的元素应用e，类似于mapper。<br> 需要区别<code>|-&gt;</code>和<code>:</code>：</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">Rem(i, seq) == [j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span> |-&gt; IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>]</span><br><span class="line">RemSet(i, seq) == &#123;(IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>) : j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>“构造函数”<code>{v \in S: P}</code><br> 类似一个filter。</p></li><li><p><code>UNCHANGED &lt;&lt;x,y&gt;&gt;</code><br> 是一个语法糖，可以理解为</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="string">\</span> x<span class="string">' = x</span></span><br><span class="line"><span class="string">/\ y'</span> = y</span><br></pre></td></tr></table></figure></li><li><p><code>CHOOSE v \in S: P</code><br> 在S中满足P的元素中任选一个v。注意这个CHOOSE是没有随机性的，我们比较</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\E <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : x' = <span class="built_in">i</span></span><br><span class="line">x' = CHOOSE <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : TRUE</span><br></pre></td></tr></table></figure><p> 上面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间任意一个数。<br> 下面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间某个特定的数。<br> CHOOSE主要用法是：S中只有一个v满足P，比如最大值最小值等，我们将这个v取出来。所以一般CHOOSE和TRUE这个Predicate不会连用。<br> 下面，我们通过CHOOSE计算在一段区间中的最大质数。可以在模型中执行<code>LargestPrime(1..1000)</code>，得到结果997。</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">IsPrime(x) == x &gt; <span class="number">1</span> /<span class="string">\</span> ~<span class="string">\E</span> d <span class="string">\in</span> <span class="number">2.</span>.(x-<span class="number">1</span>) : x % d = <span class="number">0</span></span><br><span class="line">LargestPrime(S) == CHOOSE x <span class="string">\in</span> S:</span><br><span class="line">                    /<span class="string">\</span> IsPrime(x)</span><br><span class="line">                    /<span class="string">\</span> <span class="string">\A</span> y <span class="string">\in</span> S:</span><br><span class="line">                        IsPrime(y) =&gt; y &lt;= x</span><br></pre></td></tr></table></figure></li></ol><h2 id="Expression-Spec部分"><a href="#Expression-Spec部分" class="headerlink" title="Expression/Spec部分"></a>Expression/Spec部分</h2><ol><li><p>IF-THEN-ELSE</p></li><li><p>Enabling condition<br> 这是一个概念，例如下面式子中，第一个式子就是enabling condition，因为它并没有涉及下一个状态<code>rmState&#39;</code></p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DecideC(r) == /\ rmState<span class="string">[r]</span> = <span class="string">"prepared"</span></span><br><span class="line">              /\ rmState' = <span class="string">[rmState EXCEPT ![r]</span> = <span class="string">"committed"</span>]</span><br></pre></td></tr></table></figure><p> 如果在state s时满足了这些Enabling条件，则A被enabled，且<code>s-&gt;t</code>是一个A step。</p></li><li><p>Constant expression</p></li><li><p>State expression<br> 能够包含所有Constant expression能够包含的元素。此外，还能包含声明了的变量。<br> 需要注意的还是，在P08b里面，Lamport说一个State表示给variable进行赋值。这里的variable表示所有可能的variable，而不是被定义出来的variable。我觉得实际在说在一个formula里面，如果没有提到其他变量，并不代表不存在其他变量。<br> State的值取决于变量的值。</p></li><li><p>Action expression<br> 能够包含所有State expression能够包含的元素。此外，还能包含<code>&#39;</code>和<code>UNCHANGED</code>。<br> 一个State expression是一个Action expression，它在一个step<code>s-&gt;t</code>上具有一个值，这个值只取决于s。<br> 这里step表示一对状态之间的切换。例如，state s是<code>p &lt;- 42</code>，state t是<code>q &lt;- 24</code>，那么<code>p-q&#39;</code>在step<code>s-&gt;t</code>上具有值<code>42-24</code>。</p></li><li><p>THEOREM<br> 对于一个Temporal formula，<code>THEOREM TF</code>表示<code>TF</code>在每个可能行为下，都是true。<br> 例如下面的THEOREM表示对于每一个behavior，如果<code>TPSpec</code>是true（也就是这个behavior满足TPSpec的条件），那么<code>[]TPTypeOK</code>也是true（也就是对于这个bahavior下的每个state都是true）。</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM TPSpec =&gt; <span class="string">[]</span>TPTypeOK</span><br></pre></td></tr></table></figure><p> 我们进一步理解为，<code>TPTypeOK</code>是关于<code>TpSpec</code>的不变量。<br> 我们还可以说<code>TPSpec</code>实现(implement)了<code>[]TPTypeOK</code>。<br> 为了检查这个THEOREM，有两种方案：</p><ol><li>将<code>[]TPTypeOK</code>/<code>TPSpec</code>加入”<strong>What to check?</strong>“下面的<strong>Properties</strong>中。</li><li>将<code>TPTypeOK</code>加入”<strong>What to check?</strong>“下面的<strong>Invariants</strong>中。</li></ol></li><li><p>Behavior </p></li><li><p>Temporal(时序的) formula<br> 一般写成<code>Spec == Init /\ []Next</code>。<br> 在学习TCommit的时候，我们都是在Module标签页里面”Initial predicate and next-state relation”这个标签里面指定Init和Next的，现在<strong>可以直接在Temporal formula标签里面</strong>直接填我们的Spec了。</p></li><li><p>Stuttering steps<br> 在Temporal formula中，会见到下面的写法，在<code>TCNext</code>周围包围了中括号：</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[]</span><span class="string">[TCNext]</span>_rmState</span><br></pre></td></tr></table></figure><p> 它等价于下面的形式，也就是说满足TCNext，或者保持rmState不变。后者称为stuttering steps。</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TCNext</span> \/ (UNCHANGED rmState)</span><br></pre></td></tr></table></figure><p> 因此，一个常见的Temporal formula写法可以是</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>Stuttering steps和Termination<br> 一个有无限长的Stuttering steps作为结尾的behavior是一个Terminating execution。<br> 这个是容易理解的，在我们的系统停止之后，地球还是照转不误的。所以所有的behavior都是无限长的state构成的序列。</p></li><li><p>May和Must<br> 我觉得这是一个贯穿的思想，也就是Lamport反复强调TLA+是一个数学的，而不是命令的东西。<br> Spec中的主体部分都是May部分，规定了系统可能做什么，而不是必须做什么。可以加入<code>L</code>，作为Must部分</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>L</span><br></pre></td></tr></table></figure><p> 一个Safety Formula断言May发生的事件。<br> 一个Liveness Formula断言Must发生的事件。这表示在任何时候都不能违反的条件。</p></li><li><p><code>[]</code>和<code>~&gt;</code><br> 对于顺序执行的程序来说，只需要满足能够最终终止就行了。这里最终表示为<code>&lt;&gt;</code>。关于<code>&lt;&gt;</code>，有下面的关系</p> <figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;<span class="keyword">P</span> == ~[]~<span class="keyword">P</span></span><br></pre></td></tr></table></figure><p> <code>~&gt;</code>表示lead to。对于ABSpec来说，它的Liveness property是</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li><li><p>Fairness<br> Weak Fairness指，如果Action A持续(continuouesly) enabled（enabled定义见下面），那么一个A step会最终发生。也就是说，下图中的绿色部分一定会发生一个A step。<br> <img src="/img/tla/wf.png"><br> Weak Fairness使用下面的格式，其中vars是这个Spec中涉及的所有变量。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">WF_vars</span><span class="params">(A)</span></span></span><br></pre></td></tr></table></figure><p> 容易看出，Weak Fairness是一个Liveness property。因为它在A step或者A没有被enabled的时候，都是true。<br> 对应的，还有Strong Fairness，如果Action A重复地(repeatedly) enabled，那么一个A step会最终发生。<br> 因此，我们可以总结得到具有Liveness的Spec的格式。其中Fairness是<code>WF_vars(A)</code>和<code>SF_vars(A)</code>的组合，其中A是Next的之动作。</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>Fairness</span><br></pre></td></tr></table></figure><p> 即</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars /<span class="tag">\<span class="name"> </span></span>WF_vars(Next)</span><br></pre></td></tr></table></figure><p> 在检查Liveness条件时，不能使用symmetry set。</p></li><li><p>精化(refinement)关系<br> 为了使用TLC检验在精化映射<code>φ</code>下，ImplSpec到AbsSpec的精化关系，我们在模块ImplModule中添加定义和THEAOREM</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbsSub ==<span class="built_in"> INSTANCE </span>AbsModule</span><br><span class="line">THEOREM ImplSpec =&gt; AbsSub!AbsSpec</span><br></pre></td></tr></table></figure></li></ol><h2 id="尚未归类"><a href="#尚未归类" class="headerlink" title="尚未归类"></a>尚未归类</h2><ol><li>ASSUME<br> 必须是一个布尔量的常量表达式。<br> TLA+会<a href="https://learntla.com/models/constants/" target="_blank" rel="noopener">检查ASSUME中列出的条件是否满足</a>。</li><li>CONSTANTS<br> 定义了一系列常量，这些常量都可以理解为是集合。<br> 根据Lamport的P10a，传统数学中的变量，类似于TLA+中的CONSTANT。传统数学中没有和TLA+中的VARIABLE对应的概念，这个概念属于Temporal Logic(时序逻辑)。</li><li>VARIABLE/VARIABLES<br> 以TCommit为例，我们定义了<code>CONSTANT RM</code>，还定义了<code>VARIABLE rmState</code>。<br> 如何区分VARIABLE和CONSTANTS呢？我们可以理解为<code>rmState</code>是一个数组，这个数组的indexer是我们定义的RM集合，而这个集合是一个常量。    </li><li><code>[]TPNext</code><br> 表示<code>TPNext</code>始终成立。</li><li>EXTENDS<br> 类似于C++里面的<code>#include</code></li><li>INSTANCE<br> 下面的语句表示我们现在的Module实现了TCommit，于是我们将TCommit中的所有定义import到我们当前Module中。 <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE <span class="keyword">TCommit</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="DieHard"><a href="#DieHard" class="headerlink" title="DieHard"></a>DieHard</h1><p>在TLA中，需要在等式<code>==</code>右边指定全部状态。</p><h1 id="TCommit"><a href="#TCommit" class="headerlink" title="TCommit"></a>TCommit</h1><p>对应Lamport的第5节课。<br>TCommit主要定义了事务的提交模型。如下图所示，每个Resource Manager(RM)节点，可以理解为2PC里面的参与者节点，具有working、prepared、committed、aborted四种状态。在这个提交模型中，我们不考虑协调者，也就是只考虑怎么样，不考虑如何做。后者会在下一章中考虑。</p><p><img src="/img/tla/v5commit.png"></p><p>下面定义TypeOK对么？肯定是不对的，因为<code>rmState</code>是RM的集合。我们并不是希望这个集合属于这四个值，而是希望每个<code>rmState[r]</code>属于这四个值之中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TCTypeOK</span> == rmState \in &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure><p>所以我们需要</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCT<span class="function"><span class="title">ypeOK</span> == rmState \<span class="built_in">in</span> [RM -&gt;</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;]</span><br></pre></td></tr></table></figure><p>其实我觉得应该也可以这么写</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCTypeOK == \A r \<span class="keyword">in</span> <span class="string">RM:</span> rmState[r] \<span class="keyword">in</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure><p>在Module中不检查Deadlock，但检查TCConsistent和TCTypeOK。</p><p>注意，源码里面有一些诸如TCSpec的，并不会在这篇文章里面讲解。</p><h1 id="TwoPhase"><a href="#TwoPhase" class="headerlink" title="TwoPhase"></a>TwoPhase</h1><p>首先介绍一下消息：</p><ol><li>Prepared<br> RM-&gt;TM，表示某个RM已经Prepared了。</li><li>Commit<br> TM-&gt;RM</li><li>Abort<br> TM-&gt;RM</li></ol><p>然后介绍下动作：</p><ol><li>TMRcvPrepared<br> TM收到了某个RM的Prepared消息。</li><li>TMCommit<br> TM决定commit事务。<br> 此时TM必须在initial态，并且所有的RM都已经发送了Prepared消息。</li><li>TMAbort<br> TM自发地abort事务。</li><li>RMPrepare<br> 某个RM决定prepare。</li><li>RMChooseToAbort<br> 某个RM决定abort。<br> 注意，此时RM不会发送任何消息。这个是正常的，例如我宕机了，那还怎么发送消息。</li><li>RMRcvCommitMsg<br> 某个RM收到了来自TM的Commit消息。</li><li>RMRcvAbortMsg<br> 某个RM收到了来自TM的Abort消息。</li></ol><p>下面介绍状态：</p><ol><li>rmState<br> 包含<code>{&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;}</code>。</li><li>tmState<br> 包含<code>{&quot;init&quot;, &quot;done&quot;}</code>。<br> done表示TM进行了Commit或者Abort操作。</li><li>tmPrepared<br> TM接受到了哪些RM的准备消息。</li><li>msgs<br> 是一个表示所有已经发送的消息的集合。</li></ol><p>这里面涉及到定义类型，有点类似于Haskell的ADT。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Messages == [<span class="symbol">type:</span> &#123;<span class="string">"Prepared"</span>&#125;, <span class="symbol">rm:</span> RM] \<span class="class"><span class="keyword">union</span> [<span class="title">type</span>: &#123;"<span class="title">Commit</span>", "<span class="title">Abort</span>"&#125;]</span></span><br></pre></td></tr></table></figure><p>这里<code>\subseteq</code>是子集的意思，这两句话实际就是在说<code>tmPrepared</code>和<code>msgs</code>中的值一定属于<code>RM</code>或者<code>Message</code>。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TPTypeOK == /<span class="string">\</span> tmPrepared <span class="string">\subseteq</span> RM</span><br><span class="line">            /<span class="string">\</span> msgs <span class="string">\subseteq</span> Messages</span><br></pre></td></tr></table></figure><h1 id="PaxosCommit-P07"><a href="#PaxosCommit-P07" class="headerlink" title="PaxosCommit (P07)"></a>PaxosCommit (P07)</h1><p>通过2PC，我们通过协调者TM去处理事务的提交。但如果TM宕掉怎么办呢？一个通常的实践是在主TM宕机后切换到备份的TM。这个操作的问题是，可能主TM决定Commit后分区/暂停了，但是备份TM决定Abort。但当它发送这个消息后，主TM恢复，并且发送Commit消息。这可能导致某些RM会Commit，另一些会Abort。</p><p>需要检查：</p><ol><li>PCTypeOK</li><li>TCConsistent</li></ol><p>Lamport强调，随着模型的线性增大，运行时间会以指数增大。</p><h1 id="P08a-P08b"><a href="#P08a-P08b" class="headerlink" title="P08a+P08b"></a>P08a+P08b</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><h2 id="Implication"><a href="#Implication" class="headerlink" title="Implication"></a>Implication</h2><p>介绍蕴含关系(implication)，也就是<code>=&gt;</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> =&gt; Q</span><br></pre></td></tr></table></figure><p>等同</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> P <span class="keyword">THEN</span> Q <span class="keyword">ELSE</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure><p>我们知道原命题的逆否命题成立，即</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="params">Q</span> =&gt;</span> ~P</span><br></pre></td></tr></table></figure><p>其中<code>~</code>也可以表示为<code>\lnot</code>或者<code>\neg</code></p><p>在口语中，implication通常断言因果。但是在数学中，只断言相关性。</p><h2 id="Module-closed-expression"><a href="#Module-closed-expression" class="headerlink" title="Module-closed expression"></a>Module-closed expression</h2><p>一个module-closed formula是一个不二良的module-closed expression。例如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x \in <span class="number">1.</span><span class="number">.42</span>) /\ (y' = x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="P09a"><a href="#P09a" class="headerlink" title="P09a"></a>P09a</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><p>介绍了ABSpec，即AlteringBits这个协议。</p><p>我们需要进行Liveness检查，分为以下步骤</p><ol><li>选择Temporal Formula为<code>FairSpec</code></li><li>设置”What is the model?”为”Set of model values”，但是关闭”Symmetry sets”选项。</li><li>在**”What to check?”<strong>下面的</strong>“Properties”**中填入下面的检查 <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\A</span> v <span class="string">\in</span> Data <span class="string">\X</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;: <span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="P09b"><a href="#P09b" class="headerlink" title="P09b"></a>P09b</h1><p>这一章节介绍AB，也就是AlteringBits这个协议的具体实现。</p><p>这个协议如下所示，A向B同步信息。开始，A和B都是<code>&lt;&lt;&quot;&quot;,0&gt;&gt;</code>。接着A开始发送<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>，会不断重传。当B收到<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>后，就更新自己的值，并且开始不断向A发送1，而不是0。<br><img src="/img/tla/ab2.png"></p><p>在实现完AB之后，需要进行Safety检查。但不能直接检查Spec。这是因为A和B可以不断地给彼此发送消息，并且发送的速度远远比丢包或者对端接收要快，这样的话会导致有无数的可到达状态，我们的TCL程序可能永远不会结束！<br>此时需要打开”Additional Spec Options”标签，在”State Constraint”中设置。这样我们就限制了消息的最大长度。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="built_in">Len</span>(AtoB) =&lt; <span class="number">3</span></span><br><span class="line">/\ <span class="built_in">Len</span>(BtoA) =&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure><p>此外，我们还要在”What to check?”下面的”Properties”中填入<code>ABS!Spec</code>，表示我们要检查ABSpec里面的Spec。</p><p><img src="/img/tla/find_states.png"></p><p>下面进行Liveness检查，也就是添加Fairness条件，从而imply消息能够持续被发送以及接收。<br>此时Weak Fairness是不够的。因为这实际上允许了B一直向A发送1，如下如所示。【Q】为什么呢？稍后解释<br><img src="/img/tla/wf_fail.png"></p><p>因此我们得使用下面的</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  SF_vars<span class="comment">(ARcv)</span> /\ SF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure><p>【Q】能不能改成全是WF呢，如下所示</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  WF_vars<span class="comment">(ARcv)</span> /\ WF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure><p>尝试一下，可以发现下面的错误：<br><img src="/img/tla/all_wf.png"><br>它的路径如下，容易发现形成了循环。</p><ol><li>BSnd: 1</li><li>ASnd: <code>&lt;&lt;a, 1&gt;&gt;</code></li><li>LoseMsg: BtoA from <code>&lt;&lt;1&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code></li><li>BRcv: AtoB from <code>&lt;&lt;&lt;&lt;a, 1&gt;&gt;&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code><br> 回到了状态1</li></ol><p>Why？这是因为<code>WF_var(ASnd)</code>和<code>WF_var(BSnd)</code>是true，因为ASnd和BSnd一直在发生。<br>现在考虑<code>WF_vars(ARcv)</code>。在Init状态，它没有enable，因为BtoA是空的。在B发送消息之后，它enable了，但是如果发生了LostMsg，那么它又不enable了。容易看出，<code>WF_vars(ARcv)</code>也是true，因为<code>ARcv</code>并不能<strong>continuouesly enable</strong>。<br>所以，我们满足了<code>FairSpec</code>，但并不满足<code>ABS!FailSpec</code>，所以下面的THEOREM也不成立了</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM FairSpec =&gt; <span class="keyword">ABS</span>!FailSpec</span><br></pre></td></tr></table></figure><p>因此，我们要引入Strong Fairness。</p><h1 id="P10a"><a href="#P10a" class="headerlink" title="P10a"></a>P10a</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>实现<code>RemoveX</code>，用来移除一个Tuple中的所有<code>&quot;X&quot;</code>。我们需要一个前置声明。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RECURSIVE RemoveX(_)</span><br><span class="line">RemoveX(l) == <span class="keyword">IF</span> l = &lt;&lt;&gt;&gt; <span class="keyword">THEN</span> l</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="keyword">IF</span> Head(l) = <span class="string">"X"</span> <span class="keyword">THEN</span> RemoveX(Tail(l))</span><br><span class="line">                     <span class="keyword">ELSE</span> &lt;&lt;Head(l)&gt;&gt; \o RemoveX(Tail(l))</span><br></pre></td></tr></table></figure><h2 id="代入-Substitution"><a href="#代入-Substitution" class="headerlink" title="代入(Substitution)"></a>代入(Substitution)</h2><p>考虑传统数学中的代入逻辑，即把<code>e</code>导入到<code>f(v)</code>中</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">v</span> = e) =&gt; (<span class="name">f</span> = (<span class="name">f</span> WITH v &lt;- e))</span><br></pre></td></tr></table></figure><p>其中WITH是Lamport定义的描述性的语句，其作用如下</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y^<span class="number">3</span>-y) WITH y &lt;- x+<span class="number">2</span> = (x+<span class="number">2</span>)^<span class="number">3</span>-(x+<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>因为TLA关注时序的逻辑，我们不能在写TLA+的时候这么进行代换，我们考虑下面的代入：<code>v &lt;- y</code>、<code>e &lt;- x + 2</code>、<code>f &lt;- y&#39;</code>，其实未必是一直成立的</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM (<span class="name">y</span> = x + <span class="number">2</span>) =&gt; (<span class="name">y</span>' = (<span class="name">x</span> + <span class="number">2</span>)')</span><br></pre></td></tr></table></figure><p>因此，我们使用Temporal Substitution Law</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="comment">(v = e)</span> =&gt; <span class="comment">(f = (f WITH v &lt;- e)</span>)</span><br></pre></td></tr></table></figure><p>即写成下面的形式</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM [] (y = x + <span class="number">2</span>) =&gt; (y<span class="string">' = (x + 2)'</span>)</span><br></pre></td></tr></table></figure><h2 id="AB2"><a href="#AB2" class="headerlink" title="AB2"></a>AB2</h2><p>这个协议旨在处理出现消息损坏(Corrupted)的情况。<br>为此，我们引入了一个新消息Bad。并且Bad一定不等于所有的其他消息。我们用ASSUME来描述这个性质。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME Bad \notin (Data \X &#123;<span class="number">0</span>,<span class="number">1</span>&#125;) \cup &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure><p>此外在运行Module的时候，需要给Bad赋一个不同于所有其他消息的值，一个Idea是用字符串”Bad”来代表。但这会遇到错误”Attempted to check equality of interger 0 with non-integer: “Bad””。所以，实际上我们可以直接用Model Value，即我们给Bad的值就是Bad。</p><p>我们需要保证消息需要在他们Corrupted之前被Receive，这个靠目前的Fairness条件是不够的，我们需要修改Safety条件。<br>首先，我们加入了AtoBgood和BtoAgood用来表示某条信息是不是肯定不会Corrupt。<br>然后，如果我们将AtoB2里面的Bad消息去掉，就可以得到一个等价的AtoB，因此我们得到了SpecH。去掉可以通过<code>RemoveBad</code>，类似于之前提到的<code>RemoveX</code>。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpecH == /<span class="tag">\<span class="name"> </span></span>AB2!Spec</span><br><span class="line">         /<span class="tag">\<span class="name"> </span><span class="string">[]</span></span> /<span class="tag">\<span class="name"> </span></span>AtoB = RemoveBad(AtoB2)</span><br><span class="line">               /<span class="tag">\<span class="name"> </span></span>BtoA = RemoveBad(BtoA2)</span><br></pre></td></tr></table></figure><p>我们的目标是，但此时我们的SpecH并不符合TLA+的Safety检查的格式，即<code>Init /\ [][Next]_vars</code>。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM SpecH =&gt; AB!Spec</span><br></pre></td></tr></table></figure><p>为此，我们引入了SpecHH</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpecHH == InitH /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[NextH]</span></span>_varsH</span><br><span class="line">THEOREM SpecHH &lt;=&gt; SpecH</span><br></pre></td></tr></table></figure><p>其中<code>&lt;=&gt;</code>的作用等价于</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ SpecHH =&gt; SpecH</span><br><span class="line">/\ SpecH  =&gt; SpecHH</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.jianshu.com/p/12fda75ddf9e" target="_blank" rel="noopener">https://www.jianshu.com/p/12fda75ddf9e</a><br> 介绍TLA+的语法</li><li><a href="http://lamport.azurewebsites.net/video/videos.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/video/videos.html</a><br> Lamport的视频教学<br> 这里面有课件，以及视频教程里面的代码，这些在<a href="https://github.com/tlaplus/Examples" target="_blank" rel="noopener">https://github.com/tlaplus/Examples</a>并没有。</li><li><a href="https://github.com/parlarjb/tla_workshop" target="_blank" rel="noopener">https://github.com/parlarjb/tla_workshop</a><br> Lamport的代码的整理</li><li><a href="https://learntla.com/tla/" target="_blank" rel="noopener">https://learntla.com/tla/</a><br> 一个TLA+学习的网站</li><li><a href="https://lamport.azurewebsites.net/tla/book-02-08-08.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/book-02-08-08.pdf</a><br> Specifying Systems这本书，这是终极版本的讲义</li><li><a href="http://lamport.azurewebsites.net/tla/newmodule.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/newmodule.html</a><br> TLA中的module的相关说明，包含了很多语法相关的讲解</li><li><a href="http://lamport.azurewebsites.net/tla/book-21-07-04.pdf" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/book-21-07-04.pdf</a><br> Specifying Systems这本书的新版本？</li><li><a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/tla2-guide.pdf</a><br> TLA2</li><li><a href="https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822</a><br> 教学视频，包含P10</li><li><a href="https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822</a><br> 教学视频，不包含P10，但是赠送了对Paxos的讲解</li><li><a href="https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf" target="_blank" rel="noopener">https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf</a></li><li><a href="https://github.com/tlaplus/DrTLAPlus" target="_blank" rel="noopener">https://github.com/tlaplus/DrTLAPlus</a></li><li><a href="https://www.youtube.com/watch?v=6Kwx8zfGW0Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=6Kwx8zfGW0Y</a><br> 从1.07开始有个简单的对Raft的TLA+的讲解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍TLA+用法。&lt;br&gt;TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。&lt;br&gt;TLC是TLA+的模型检验工具。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>概率论中的几个有趣问题</title>
    <link href="http://www.calvinneo.com/2021/05/15/probability-problems/"/>
    <id>http://www.calvinneo.com/2021/05/15/probability-problems/</id>
    <published>2021-05-15T11:20:33.000Z</published>
    <updated>2021-11-28T14:51:53.605Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍概率论中一些有趣的问题，其中很多是反直觉的</p><a id="more"></a><h1 id="三门问题"><a href="#三门问题" class="headerlink" title="三门问题"></a>三门问题</h1><h1 id="两个男孩"><a href="#两个男孩" class="headerlink" title="两个男孩"></a>两个男孩</h1><h1 id="基本比率谬误"><a href="#基本比率谬误" class="headerlink" title="基本比率谬误"></a>基本比率谬误</h1><p>假设同性恋染上某病的概率是异性恋的9倍。已知小明染上某病，求小明同性恋的概率。<br>错误的答案是$\frac{9}{10}$。正确答案是无法计算，因为我们并不知道同性恋和异性恋的比例。</p><p>令同性恋是$S$，异性恋是$H$，患某病是$X$。已知</p><p>$$<br>P(X|S) = 9 \quad P(X|H)<br>$$</p><p>求$P(S|X)$</p><p>我们计算</p><p>$$<br>P(S|X) = \frac{P(S)P(X|S)}{P(X)}<br>$$</p><h1 id="辛普森悖论"><a href="#辛普森悖论" class="headerlink" title="辛普森悖论"></a>辛普森悖论</h1><p>我们考虑另一个问题，我们统计篮球比赛中两个球员的三分球和二分球命中率，假如A的三分球命中率比B高，二分球命中率也比B高，那么A的总命中率比B高么？<br>答案是不确定。我们不如考虑下面这个极端情况：</p><ol><li>A的二分球命中率是100%，B的是99%</li><li>A的三分球命中率是1%，B的是0%</li></ol><p>那B说好的，我田忌赛马了，我就直投二分球，你A只投三分球。结果B的总命中率是99%，而A的是1%。<br>辛普森悖论告诉我们如果一个人犯的错误多，很可能是因为他在做难的事情。所以如果我们老板不懂这个，而只追求bug少，那就会变成no code no bug的场面。</p><h1 id="婚姻-秘书问题或者博士后问题"><a href="#婚姻-秘书问题或者博士后问题" class="headerlink" title="婚姻/秘书问题或者博士后问题"></a>婚姻/秘书问题或者博士后问题</h1><p>我们在海滩捡贝壳，必须在捡贝壳的时候决定留不留下，并且只有一次选择留下的机会，问如何最大化<strong>选到最佳贝壳</strong>的概率。</p><h1 id="贝特朗悖论"><a href="#贝特朗悖论" class="headerlink" title="贝特朗悖论"></a>贝特朗悖论</h1><h1 id="凯利公式"><a href="#凯利公式" class="headerlink" title="凯利公式"></a>凯利公式</h1><h1 id="Arrow不可能原理"><a href="#Arrow不可能原理" class="headerlink" title="Arrow不可能原理"></a>Arrow不可能原理</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://blog.csdn.net/itnerd/article/details/107348933" target="_blank" rel="noopener">https://blog.csdn.net/itnerd/article/details/107348933</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4</a></li><li><a href="https://www.zhihu.com/question/330408241" target="_blank" rel="noopener">https://www.zhihu.com/question/330408241</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍概率论中一些有趣的问题，其中很多是反直觉的&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.calvinneo.com/2021/05/15/redis-replication/"/>
    <id>http://www.calvinneo.com/2021/05/15/redis-replication/</id>
    <published>2021-05-14T17:20:33.000Z</published>
    <updated>2021-08-18T07:28:35.760Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a>这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。</p><p>主从复制涉及到RDB等机制，其中持久化部分在<a href="/2021/03/13/redis-persist/">Redis持久化机制实现</a>中介绍。</p><a id="more"></a><h1 id="Redis主从复制流程简介"><a href="#Redis主从复制流程简介" class="headerlink" title="Redis主从复制流程简介"></a>Redis主从复制流程简介</h1><p>Redis Sentinel是对主从复制流程而言的，所以我们先要理解主从复制的大概流程。这里需要注意，主从复制并不是Redis Cluster。</p><ol><li>Slave接受到SLAVEOF命令</li><li>Slave连接Master</li><li>Slave PING Master</li><li>鉴权</li><li>Slave发送SYNC/PSYNC命令</li></ol><h2 id="PSYNC命令用法"><a href="#PSYNC命令用法" class="headerlink" title="PSYNC命令用法"></a>PSYNC命令用法</h2><p>PSYNC命令如下所示，其中：</p><ol><li>replicationid表示我们断线重连前Master服务器的id</li><li>offset表示Slave接受到最后命令的偏移量，以字节计算</li></ol><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">PSYNC runid <span class="keyword">offset</span></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">PSYNC replicationid <span class="keyword">offset</span></span><br></pre></td></tr></table></figure><p>这里还有个特殊用法，表示我们要触发一次全量复制。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>在Redis 2.8后，提供了PSYNC，这个命令能够支持全量复制和部分复制。这样在Slave断线重连之后，就可以部分复制，从而节省Master的计算资源和带宽。<br>在Redis 4.0版本后，优化了增量复制，主要包括：</p><ol><li>重启后，也可以进行部分复制<br> 之前这种情况，重启后会丢失runid，从而触发<code>PSYNC ? -1</code></li><li>当Slave被promote称为Master后，其他Slave可以从新Master处复制</li></ol><h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><h2 id="主要类以及常数"><a href="#主要类以及常数" class="headerlink" title="主要类以及常数"></a>主要类以及常数</h2><p>在服务器类中定义了<code>masterhost</code>，表示Master节点的地址。如果是NULL，表示自己就是Master。所以这个字段<strong>会被用来判断是MAster还是Slave</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *masteruser;               <span class="comment">/* AUTH with this user and masterauth with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterauth;               <span class="comment">/* AUTH with this password with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterhost;               <span class="comment">/* Hostname of master */</span></span><br><span class="line">    <span class="keyword">int</span> masterport;                 <span class="comment">/* Port of master */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>介绍下<code>repl_state</code>的状态：</p><ol><li><code>REPL_STATE_NONE 0</code><br> 表示现在是SLAVEOF NO ONE的</li><li><code>REPL_STATE_CONNECT 1</code><br> 在<code>replicationCron</code>判断，如果处于这个状态，表示现在要去尝试连接Master了。</li><li><code>REPL_STATE_CONNECTING 2</code></li></ol><p>下面的状态是握手过程中的状态：</p><ol><li><code>REPL_STATE_RECEIVE_PONG 3</code></li><li><code>REPL_STATE_SEND_AUTH 4</code></li><li><code>REPL_STATE_RECEIVE_AUTH 5</code></li><li><code>REPL_STATE_SEND_PORT 6</code></li><li><code>REPL_STATE_RECEIVE_PORT 7</code></li><li><code>REPL_STATE_SEND_IP 8</code></li><li><code>REPL_STATE_RECEIVE_IP 9</code></li><li><code>REPL_STATE_SEND_CAPA 10</code></li><li><code>REPL_STATE_RECEIVE_CAPA 11</code></li><li><code>REPL_STATE_SEND_PSYNC 12</code></li><li><code>REPL_STATE_RECEIVE_PSYNC 13</code></li></ol><p>下面状态是握手完毕的状态：</p><ol><li><code>REPL_STATE_TRANSFER 14</code></li><li><code>REPL_STATE_CONNECTED 15</code></li></ol><h2 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h2><ol><li>connectWithMaster</li></ol><h2 id="Full-Sync流程"><a href="#Full-Sync流程" class="headerlink" title="Full Sync流程"></a>Full Sync流程</h2><h2 id="Partial-Sync流程"><a href="#Partial-Sync流程" class="headerlink" title="Partial Sync流程"></a>Partial Sync流程</h2><h1 id="代码解释-Slave部分"><a href="#代码解释-Slave部分" class="headerlink" title="代码解释 Slave部分"></a>代码解释 Slave部分</h1><h2 id="connectWithMaster-建立套接口连接"><a href="#connectWithMaster-建立套接口连接" class="headerlink" title="connectWithMaster: 建立套接口连接"></a>connectWithMaster: 建立套接口连接</h2><p><code>connConnect</code>系列函数，以及<code>connection</code>类封装了有关网络连接的库。<br>实际上<code>connConnect</code>通过<code>anetTcpNonBlockBestEffortBindConnect</code>尝试建立一个非阻塞的套接字，此时<code>connect</code>函数可能返回<code>EINPROGRESS</code>表示连接还在建立过程中，但我们其实可以不用等。通过<code>aeCreateFileEvent</code>将这个Socket描述符加入到事件循环里面，等到这个套接字可以写之后，会触发对应的回调。<br>等到连接建立后，回调会通过<code>connSocketEventHandler</code>被唤起。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectWithMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();</span><br><span class="line">    <span class="keyword">if</span> (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,</span><br><span class="line">                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to connect to MASTER: %s"</span>,</span><br><span class="line">                connGetLastError(server.repl_transfer_s));</span><br><span class="line">        connClose(server.repl_transfer_s);</span><br><span class="line">        server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; REPLICA sync started"</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="syncWithMaster-握手以及准备传输RDB"><a href="#syncWithMaster-握手以及准备传输RDB" class="headerlink" title="syncWithMaster: 握手以及准备传输RDB"></a>syncWithMaster: 握手以及准备传输RDB</h2><p>在连接完毕后，<code>connectWithMaster</code>会回调<code>syncWithMaster</code>，此时状态是<code>REPL_STATE_CONNECTING</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncWithMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>], *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> dfd = <span class="number">-1</span>, maxtries = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> psync_result;</span><br></pre></td></tr></table></figure><p>检查一下，如果现在又是SLAVEOF NO ONE了，就把这个连接关掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If this event fired after the user turned the instance into a master</span></span><br><span class="line"><span class="comment"> * with SLAVEOF NO ONE we must just return ASAP. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">    connClose(conn);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是非阻塞的连接，所以我们要检查一下现在连接的状态。如果失败，就goto error，里面内容是重置状态，例如，<code>server.repl_state</code>会被重置为<code>REPL_STATE_CONNECT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check for errors in the socket: after a non blocking connect() we</span></span><br><span class="line"><span class="comment"> * may find that the socket is in error state. */</span></span><br><span class="line"><span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Error condition on socket for SYNC: %s"</span>,</span><br><span class="line">            connGetLastError(conn));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一个状态机的实现。我们在Sentinel中已经见过类似的了，Redis中状态机的实现就是，对于状态X，表示状态X前一个状态已经处理完了，目前正在处理状态X的工作。<strong>当状态机处理完一个状态后</strong>，在最后将状态设置为下一个要做的事情。也就是我们不用类似<code>X_FINISHED</code>这样的状态，因为<code>X_FINISHED</code>根据完成的情形不同，<strong>可能有多种状态转移</strong>。<br>【REPL_STATE_CONNECTING】这个状态下，我们尝试发送一个同步命令PING，然后直接修改状态到<code>REPL_STATE_RECEIVE_PONG</code>。如果这个同步命令发送有问题，就直接goto error了，不会走到下面流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a PING to check the master is able to reply without errors. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Non blocking connect for SYNC fired the event."</span>);</span><br><span class="line">    <span class="comment">/* Delete the writable event so that the readable event remains</span></span><br><span class="line"><span class="comment">     * registered and we can wait for the PONG reply. */</span></span><br><span class="line">    connSetReadHandler(conn, syncWithMaster);</span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</span><br><span class="line">    <span class="comment">/* Send the PING, don't check for errors at all, we have the timeout</span></span><br><span class="line"><span class="comment">     * that will take care about this. */</span></span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PING"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_PONG】我们只要收到对PING的回复，就进入了<code>REPL_STATE_RECEIVE_PONG</code>状态，但这个回复未必是PONG，也可能是一个AUTH错误。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive the PONG command. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We accept only two replies as valid, a positive +PONG reply</span></span><br><span class="line"><span class="comment">     * (we just check for "+") or an authentication error.</span></span><br><span class="line"><span class="comment">     * Note that older versions of Redis replied with "operation not</span></span><br><span class="line"><span class="comment">     * permitted" instead of using a proper error code, so we test</span></span><br><span class="line"><span class="comment">     * both. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">'+'</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOAUTH"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOPERM"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-ERR operation not permitted"</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error reply to PING from master: '%s'"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master replied to PING, replication can continue..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_AUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_AUTH】如果需要AUTH认证，我们就发送AUTH，进入<code>REPL_STATE_RECEIVE_AUTH</code>。否则直接进入<code>REPL_STATE_SEND_PORT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AUTH with the master if required. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masteruser &amp;&amp; server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,</span><br><span class="line">                                     server.masteruser,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_AUTH】如果验证通过，就进入<code>REPL_STATE_SEND_PORT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive AUTH reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to AUTH to MASTER: %s"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_PORT】下面一步，我们需要发送我们当前的端口，进入<code>REPL_STATE_RECEIVE_PORT</code>状态。<br>在发送完之后，我们在主节点执行<code>INFO replication</code>，会在其中显示我们反馈的port。<br>【Q】<code>slave_announce_port</code>和<code>port</code>的区别是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the slave port, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave listening port correctly. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">if</span> (server.slave_announce_port) port = server.slave_announce_port;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port) port = server.tls_port;</span><br><span class="line">    <span class="keyword">else</span> port = server.port;</span><br><span class="line">    sds portstr = sdsfromlonglong(port);</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"listening-port"</span>,portstr, <span class="literal">NULL</span>);</span><br><span class="line">    sdsfree(portstr);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_RECEIVE_PORT】接下来，我们用类似的办法发送IP，这里注意，如果没有指定<code>slave_announce_ip</code>就直接跳转到<code>REPL_STATE_SEND_CAPA</code>，否则跳转到<code>REPL_STATE_SEND_IP</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive REPLCONF listening-port reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF listening-port: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_IP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip REPLCONF ip-address if there is no slave-announce-ip option set. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;</span><br><span class="line">    server.slave_announce_ip == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the slave ip, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave IP address port correctly in case of port forwarding or NAT. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"ip-address"</span>,server.slave_announce_ip, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive REPLCONF ip-address reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF ip-address: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_CAPA】发送IP的过程很类似，我们就不说了。下面这一对状态是<code>REPL_STATE_SEND_CAPA</code>，用来发送Slave的容量。这一对状态结束之后，进入<code>REPL_STATE_SEND_PSYNC</code>状态。<br>【Q】这个容量指的是什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inform the master of our (slave) capabilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EOF: supports EOF-style RDB transfer for diskless replication.</span></span><br><span class="line"><span class="comment"> * PSYNC2: supports PSYNC v2, so understands +CONTINUE &lt;new repl ID&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The master will ignore capabilities it does not understand. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"capa"</span>,<span class="string">"eof"</span>,<span class="string">"capa"</span>,<span class="string">"psync2"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive CAPA reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF capa. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                              <span class="string">"REPLCONF capa: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【REPL_STATE_SEND_PSYNC】下面，我们尝试PSYNC。主要就是调用若干次<code>slaveTryPartialResynchronization</code>：第一次传0进去，让它发PSYNC指令，并且设置状态为<code>REPL_STATE_RECEIVE_PSYNC</code>；后面就不断地传1进去，查询结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try a partial resynchonization. If we don't have a cached master</span></span><br><span class="line"><span class="comment"> * slaveTryPartialResynchronization() will at least try to use PSYNC</span></span><br><span class="line"><span class="comment"> * to start a full resynchronization so that we get the master run id</span></span><br><span class="line"><span class="comment"> * and the global offset, to try a partial resync at the next</span></span><br><span class="line"><span class="comment"> * reconnection attempt. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slaveTryPartialResynchronization(conn,<span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">        err = sdsnew(<span class="string">"Write error sending the PSYNC command."</span>);</span><br><span class="line">        <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"syncWithMaster(): state machine error, "</span></span><br><span class="line">                         <span class="string">"state should be RECEIVE_PSYNC but is %d"</span>,</span><br><span class="line">                         server.repl_state);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psync_result = slaveTryPartialResynchronization(conn,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>下面查看返回值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_WAIT_REPLY) <span class="keyword">return</span>; <span class="comment">/* Try again later... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the master is in an transient error, we should try to PSYNC</span></span><br><span class="line"><span class="comment"> * from scratch later, so go to the error path. This happens when</span></span><br><span class="line"><span class="comment"> * the server is loading the dataset or is not connected with its</span></span><br><span class="line"><span class="comment"> * master and so forth. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_TRY_LATER) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: if PSYNC does not return WAIT_REPLY, it will take care of</span></span><br><span class="line"><span class="comment"> * uninstalling the read handler from the file descriptor. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization."</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Partial Resynchronization accepted. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PSYNC failed or is not supported: we want our slaves to resync with us</span></span><br><span class="line"><span class="comment"> * as well, if we have any sub-slaves. The master may transfer us an</span></span><br><span class="line"><span class="comment"> * entirely different data set and we have no way to incrementally feed</span></span><br><span class="line"><span class="comment"> * our slaves after that. */</span></span><br><span class="line">disconnectSlaves(); <span class="comment">/* Force our slaves to resync with us as well. */</span></span><br><span class="line">freeReplicationBacklog(); <span class="comment">/* Don't allow our chained slaves to PSYNC. */</span></span><br></pre></td></tr></table></figure><p>如果PSYNC能支持，我们前面就返回了，下面对于不支持的情况，我们就得用老的SYNC方法。在开始传输后，进入<code>REPL_STATE_TRANSFER</code>状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC</span></span><br><span class="line"><span class="comment"> * and the server.master_replid and master_initial_offset are</span></span><br><span class="line"><span class="comment"> * already populated. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Retrying with SYNC..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (connSyncWrite(conn,<span class="string">"SYNC\r\n"</span>,<span class="number">6</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"I/O error writing to MASTER: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不支持无盘加载，那么就要在磁盘上创建一个临时文件。<br>查看函数<code>useDisklessLoad</code>，无盘加载需要满足：</p><ol><li><code>repl_diskless_load</code>配置</li><li>所有的模块都能处理读错误</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare a suitable temp file for bulk transfer */</span></span><br><span class="line"><span class="keyword">if</span> (!useDisklessLoad()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,</span><br><span class="line">            <span class="string">"temp-%d.%ld.rdb"</span>,(<span class="keyword">int</span>)server.unixtime,(<span class="keyword">long</span> <span class="keyword">int</span>)getpid());</span><br><span class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</span><br><span class="line">    server.repl_transfer_fd = dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面非阻塞地进行SYNC，设置读取SYNC数据的回调<code>readSyncBulkPayload</code>，如果成功就切换状态为<code>REPL_STATE_TRANSFER</code>。<br>这里，我们设置了<code>repl_transfer_size</code>为1，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the non blocking download of the bulk file. */</span></span><br><span class="line"><span class="keyword">if</span> (connSetReadHandler(conn, readSyncBulkPayload)</span><br><span class="line">        == C_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> conninfo[CONN_INFO_LEN];</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Can't create readable event for SYNC: %s (%s)"</span>,</span><br><span class="line">        strerror(errno), connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.repl_state = REPL_STATE_TRANSFER;</span><br><span class="line">server.repl_transfer_size = <span class="number">-1</span>;</span><br><span class="line">server.repl_transfer_read = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_last_fsync_off = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_lastio = server.unixtime;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>下面是错误处理，需要将状态重置为等待连接的<code>REPL_STATE_CONNECT</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (dfd != <span class="number">-1</span>) close(dfd);</span><br><span class="line">    connClose(conn);</span><br><span class="line">    server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_fd != <span class="number">-1</span>)</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_tmpfile)</span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">    server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">write_error: <span class="comment">/* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Sending command to master in replication handshake: %s"</span>, err);</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="slaveTryPartialResynchronization-PSYNC分支"><a href="#slaveTryPartialResynchronization-PSYNC分支" class="headerlink" title="slaveTryPartialResynchronization: PSYNC分支"></a>slaveTryPartialResynchronization: PSYNC分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Try a partial resynchronization with the master if we are about to reconnect.</span></span><br><span class="line"><span class="comment"> * If there is no cached master structure, at least try to issue a</span></span><br><span class="line"><span class="comment"> * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC</span></span><br><span class="line"><span class="comment"> * command in order to obtain the master run id and the master replication</span></span><br><span class="line"><span class="comment"> * global offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is designed to be called from syncWithMaster(), so the</span></span><br><span class="line"><span class="comment"> * following assumptions are made:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) We pass the function an already connected socket "fd".</span></span><br><span class="line"><span class="comment"> * 2) This function does not close the file descriptor "fd". However in case</span></span><br><span class="line"><span class="comment"> *    of successful partial resynchronization, the function will reuse</span></span><br><span class="line"><span class="comment"> *    'fd' as file descriptor of the server.master client structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function is split in two halves: if read_reply is 0, the function</span></span><br><span class="line"><span class="comment"> * writes the PSYNC command on the socket, and a new function call is</span></span><br><span class="line"><span class="comment"> * needed, with read_reply set to 1, in order to read the reply of the</span></span><br><span class="line"><span class="comment"> * command. This is useful in order to support non blocking operations, so</span></span><br><span class="line"><span class="comment"> * that we write, return into the event loop, and read when there are data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When read_reply is 0 the function returns PSYNC_WRITE_ERR if there</span></span><br><span class="line"><span class="comment"> * was a write error, or PSYNC_WAIT_REPLY to signal we need another call</span></span><br><span class="line"><span class="comment"> * with read_reply set to 1. However even when read_reply is set to 1</span></span><br><span class="line"><span class="comment"> * the function may return PSYNC_WAIT_REPLY again to signal there were</span></span><br><span class="line"><span class="comment"> * insufficient data to read to complete its work. We should re-enter</span></span><br><span class="line"><span class="comment"> * into the event loop and wait in such a case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PSYNC_CONTINUE: If the PSYNC command succeeded and we can continue.</span></span><br><span class="line"><span class="comment"> * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.</span></span><br><span class="line"><span class="comment"> *                   In this case the master run_id and global replication</span></span><br><span class="line"><span class="comment"> *                   offset is saved.</span></span><br><span class="line"><span class="comment"> * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and</span></span><br><span class="line"><span class="comment"> *                      the caller should fall back to SYNC.</span></span><br><span class="line"><span class="comment"> * PSYNC_WRITE_ERROR: There was an error writing the command to the socket.</span></span><br><span class="line"><span class="comment"> * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.</span></span><br><span class="line"><span class="comment"> * PSYNC_TRY_LATER: Master is currently in a transient error condition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notable side effects:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) As a side effect of the function call the function removes the readable</span></span><br><span class="line"><span class="comment"> *    event handler from "fd", unless the return value is PSYNC_WAIT_REPLY.</span></span><br><span class="line"><span class="comment"> * 2) server.master_initial_offset is set to the right value according</span></span><br><span class="line"><span class="comment"> *    to the master reply. This will be used to populate the 'server.master'</span></span><br><span class="line"><span class="comment"> *    structure replication offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li><code>PSYNC_WRITE_ERROR 0</code><br> 套接口不可写。</li><li><code>PSYNC_WAIT_REPLY 1</code><br> 需要<code>read_erply</code>设置为1，并调用函数。</li><li><code>PSYNC_CONTINUE 2</code></li><li><code>PSYNC_FULLRESYNC 3</code><br> 表示虽然支持PSYNC，但现在仍然需要一次Full SYNC。在这情况下，我们需要保存Master的runid和offset。</li><li><code>PSYNC_NOT_SUPPORTED 4</code><br> 不支持PSYNC。</li><li><code>PSYNC_TRY_LATER 5</code><br> 暂时连不上Master，要重试。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psync_replid;</span><br><span class="line">    <span class="keyword">char</span> psync_offset[<span class="number">32</span>];</span><br><span class="line">    sds reply;</span><br></pre></td></tr></table></figure><p>首先，是写部分。这里的写，指的是往连接里面发送<code>PSYNC</code>指令:</p><ol><li>如果我们缓存了<code>server.master</code>到<code>server.cached_master</code><br> 通常是在<code>replicationCacheMaster</code>中设置的</li><li>如果是第一次连<br> 发送 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Writing half */</span></span><br><span class="line"><span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">    <span class="comment">/* Initially set master_initial_offset to -1 to mark the current</span></span><br><span class="line"><span class="comment">     * master run_id and offset as not valid. Later if we'll be able to do</span></span><br><span class="line"><span class="comment">     * a FULL resync using the PSYNC command we'll set the offset at the</span></span><br><span class="line"><span class="comment">     * right value, so that this information will be propagated to the</span></span><br><span class="line"><span class="comment">     * client structure representing the master into server.master. */</span></span><br><span class="line">    server.master_initial_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cached_master) &#123;</span><br><span class="line">        psync_replid = server.cached_master-&gt;replid;</span><br><span class="line">        <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">"%lld"</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Trying a partial resynchronization (request %s:%s)."</span>, psync_replid, psync_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Partial resynchronization not possible (no cached master)"</span>);</span><br><span class="line">        psync_replid = <span class="string">"?"</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(psync_offset,<span class="string">"-1"</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Issue the PSYNC command */</span></span><br><span class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PSYNC"</span>,psync_replid,psync_offset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to send PSYNC to master: %s"</span>,reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读出Master的回复，如果是空，我们就返回继续等待<code>PSYNC_WAIT_REPLY</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reading half */</span></span><br><span class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* The master may send empty newlines after it receives PSYNC</span></span><br><span class="line"><span class="comment">     * and before to reply, just to keep the connection alive. */</span></span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如果回复是<code>+FULLRESYNC</code>，表示需要一次Full SYNC。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+FULLRESYNC"</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">    <span class="keyword">char</span> *replid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FULL RESYNC, parse the reply in order to extract the run id</span></span><br><span class="line"><span class="comment">     * and the replication offset. */</span></span><br><span class="line">    replid = <span class="built_in">strchr</span>(reply,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (replid) &#123;</span><br><span class="line">        replid++;</span><br><span class="line">        offset = <span class="built_in">strchr</span>(replid,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!replid || !offset || (offset-replid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Master replied with wrong +FULLRESYNC syntax."</span>);</span><br><span class="line">        <span class="comment">/* This is an unexpected condition, actually the +FULLRESYNC</span></span><br><span class="line"><span class="comment">         * reply means that the master supports PSYNC, but the reply</span></span><br><span class="line"><span class="comment">         * format seems wrong. To stay safe we blank the master</span></span><br><span class="line"><span class="comment">         * replid to make sure next PSYNCs will fail. */</span></span><br><span class="line">        <span class="built_in">memset</span>(server.master_replid,<span class="number">0</span>,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(server.master_replid, replid, offset-replid<span class="number">-1</span>);</span><br><span class="line">        server.master_replid[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">        server.master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Full resync from master: %s:%lld"</span>,</span><br><span class="line">            server.master_replid,</span><br><span class="line">            server.master_initial_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_FULLRESYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则，我们可以部分同步。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+CONTINUE"</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Partial resync was accepted. */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Successful partial resynchronization with master."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the new replication ID advertised by the master. If it</span></span><br><span class="line"><span class="comment">     * changed, we need to set the new ID as primary ID, and set or</span></span><br><span class="line"><span class="comment">     * secondary ID as the old master ID up to the current offset, so</span></span><br><span class="line"><span class="comment">     * that our sub-slaves will be able to PSYNC with us after a</span></span><br><span class="line"><span class="comment">     * disconnection. */</span></span><br><span class="line">    <span class="keyword">char</span> *start = reply+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> *end = reply+<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span>(end[<span class="number">0</span>] != <span class="string">'\r'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\n'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\0'</span>) end++;</span><br></pre></td></tr></table></figure><p>这里new表示Master端传来的runid。如果和我们当前的<code>server.replid</code>不一样，我们要重新设置一下，并且将老的<code>server.replid</code>复制给<code>server.replid2</code>。<br>【Q】这里涉及到三个replid，他们的区别是什么呢？</p><ol><li><code>server.replid</code></li><li><code>server.replid2</code></li><li><code>server.cached_master-&gt;replid</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end-start == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">new</span>,start,CONFIG_RUN_ID_SIZE);</span><br><span class="line">    <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">new</span>,server.cached_master-&gt;replid)) &#123;</span><br><span class="line">        <span class="comment">/* Master ID changed. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Master replication ID changed to %s"</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the old ID as our ID2, up to the current offset+1. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid2,server.cached_master-&gt;replid,</span><br><span class="line">            <span class="keyword">sizeof</span>(server.replid2));</span><br><span class="line">        server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the cached master ID and our own primary ID to the</span></span><br><span class="line"><span class="comment">         * new one. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">        <span class="built_in">memcpy</span>(server.cached_master-&gt;replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br></pre></td></tr></table></figure><p>如果当前Slave有Sub Slave，全部断开，让他们重新走PSYNC流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* Disconnect all the sub-slaves: they need to be notified. */</span></span><br><span class="line">                disconnectSlaves();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup the replication to continue. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        replicationResurrectCachedMaster(conn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this instance was restarted and we read the metadata to</span></span><br><span class="line"><span class="comment">         * PSYNC from the persistence file, our replication backlog could</span></span><br><span class="line"><span class="comment">         * be still not initialized. Create it. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">        <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reach this point we received either an error (since the master does</span></span><br><span class="line"><span class="comment">     * not understand PSYNC or because it is in a special state and cannot</span></span><br><span class="line"><span class="comment">     * serve our request), or an unexpected reply from the master.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise</span></span><br><span class="line"><span class="comment">     * return PSYNC_TRY_LATER if we believe this is a transient error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"-NOMASTERLINK"</span>,<span class="number">13</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(reply,<span class="string">"-LOADING"</span>,<span class="number">8</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master is currently unable to PSYNC "</span></span><br><span class="line">            <span class="string">"but should be in the future: %s"</span>, reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_TRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(reply,<span class="string">"-ERR"</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">/* If it's not an error, log the unexpected event. */</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Unexpected reply to PSYNC from master: %s"</span>, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master does not support PSYNC or is in "</span></span><br><span class="line">            <span class="string">"error state (reply: %s)"</span>, reply);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    <span class="keyword">return</span> PSYNC_NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readSyncBulkPayload-SYNC分支-接受RDB"><a href="#readSyncBulkPayload-SYNC分支-接受RDB" class="headerlink" title="readSyncBulkPayload: SYNC分支 接受RDB"></a>readSyncBulkPayload: SYNC分支 接受RDB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronously read the SYNC payload we receive from a master */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) <span class="comment">/* 8 MB */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readSyncBulkPayload</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread, readlen, nwritten;</span><br><span class="line">    <span class="keyword">int</span> use_diskless_load = useDisklessLoad();</span><br><span class="line">    redisDb *diskless_load_backup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :</span><br><span class="line">                                                        EMPTYDB_NO_FLAGS;</span><br><span class="line">    <span class="keyword">off_t</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Static vars used to hold the EOF mark, and the last bytes received</span></span><br><span class="line"><span class="comment">     * form the server: when they match, we reached the end of the transfer. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> eofmark[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> lastbytes[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> usemark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If repl_transfer_size == -1 we still have to read the bulk length</span></span><br><span class="line"><span class="comment">     * from the master reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSyncReadLine(conn,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"I/O error reading bulk count from MASTER: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"MASTER aborted replication with an error: %s"</span>,</span><br><span class="line">                buf+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">/* At this stage just a newline works as a PING in order to take</span></span><br><span class="line"><span class="comment">             * the connection live. So we refresh our last interaction</span></span><br><span class="line"><span class="comment">             * timestamp. */</span></span><br><span class="line">            server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?"</span>, buf);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* There are two possible forms for the bulk payload. One is the</span></span><br><span class="line"><span class="comment">         * usual $&lt;count&gt; bulk format. The other is used for diskless transfers</span></span><br><span class="line"><span class="comment">         * when the master does not know beforehand the size of the file to</span></span><br><span class="line"><span class="comment">         * transfer. In the latter case, the following format is used:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * At the end of the file the announced delimiter is transmitted. The</span></span><br><span class="line"><span class="comment">         * delimiter is long and random enough that the probability of a</span></span><br><span class="line"><span class="comment">         * collision with the actual file content can be ignored. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">"EOF:"</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            usemark = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="comment">/* Set any repl_transfer_size to avoid entering this code path</span></span><br><span class="line"><span class="comment">             * at the next call. */</span></span><br><span class="line">            server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF %s"</span>,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usemark = <span class="number">0</span>;</span><br><span class="line">            server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master %s"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) server.repl_transfer_size,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!use_diskless_load) &#123;</span><br><span class="line">        <span class="comment">/* Read the data from the socket, store it to a file and search</span></span><br><span class="line"><span class="comment">         * for the EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">            readlen = (left &lt; (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nread = connRead(conn,buf,readlen);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">                <span class="comment">/* equivalent to EAGAIN */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"I/O error trying to sync with MASTER: %s"</span>,</span><br><span class="line">                (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"connection lost"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server.stat_net_input_bytes += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When a mark is used, we want to detect EOF asap in order to avoid</span></span><br><span class="line"><span class="comment">         * writing the EOF mark into the file... */</span></span><br><span class="line">        <span class="keyword">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="comment">/* Update the last bytes array, and check if it matches our</span></span><br><span class="line"><span class="comment">             * delimiter. */</span></span><br><span class="line">            <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,</span><br><span class="line">                       CONFIG_RUN_ID_SIZE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">                memmove(lastbytes,lastbytes+nread,rem);</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the last I/O time for the replication transfer (used in</span></span><br><span class="line"><span class="comment">         * order to detect timeouts during replication), and write what we</span></span><br><span class="line"><span class="comment">         * got from the socket to the dump file on disk. */</span></span><br><span class="line">        server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Write error or short write writing to the DB dump file "</span></span><br><span class="line">                <span class="string">"needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                (nwritten == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"short write"</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        server.repl_transfer_read += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the last 40 bytes from the file if we reached EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Error truncating the RDB file received from the master "</span></span><br><span class="line">                    <span class="string">"for SYNC: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sync data on disk from time to time, otherwise at the end of the</span></span><br><span class="line"><span class="comment">         * transfer we may suffer a big delay as the memory buffers are copied</span></span><br><span class="line"><span class="comment">         * into the actual disk. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_transfer_read &gt;=</span><br><span class="line">            server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">off_t</span> sync_size = server.repl_transfer_read -</span><br><span class="line">                              server.repl_transfer_last_fsync_off;</span><br><span class="line">            rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_last_fsync_off, sync_size);</span><br><span class="line">            server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the transfer is now complete */</span></span><br><span class="line">        <span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the transfer is yet not complete, we need to read more, so</span></span><br><span class="line"><span class="comment">         * return ASAP and wait for the handler to be called again. */</span></span><br><span class="line">        <span class="keyword">if</span> (!eof_reached) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We reach this point in one of the following cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. The replica is using diskless replication, that is, it reads data</span></span><br><span class="line"><span class="comment">     *    directly from the socket to the Redis memory, without using</span></span><br><span class="line"><span class="comment">     *    a temporary RDB file on disk. In that case we just block and</span></span><br><span class="line"><span class="comment">     *    read everything from the socket.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. Or when we are done reading from the socket to the RDB file, in</span></span><br><span class="line"><span class="comment">     *    such case we want just to read the RDB file in memory. */</span></span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Flushing old data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to stop any AOF rewriting child before flusing and parsing</span></span><br><span class="line"><span class="comment">     * the RDB, otherwise we'll create a copy-on-write disaster. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF) stopAppendOnly();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When diskless RDB loading is used by replicas, it may be configured</span></span><br><span class="line"><span class="comment">     * in order to save the current DB instead of throwing it away,</span></span><br><span class="line"><span class="comment">     * so that we can restore it in case of failed transfer. */</span></span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load &amp;&amp;</span><br><span class="line">        server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Create a backup of server.db[] and initialize to empty</span></span><br><span class="line"><span class="comment">         * dictionaries */</span></span><br><span class="line">        diskless_load_backup = disklessLoadMakeBackups();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We call to emptyDb even in case of REPL_DISKLESS_LOAD_SWAPDB</span></span><br><span class="line"><span class="comment">     * (Where disklessLoadMakeBackups left server.db empty) because we</span></span><br><span class="line"><span class="comment">     * want to execute all the auxiliary logic of emptyDb (Namely,</span></span><br><span class="line"><span class="comment">     * fire module events) */</span></span><br><span class="line">    emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before loading the DB into memory we need to delete the readable</span></span><br><span class="line"><span class="comment">     * handler, otherwise it will get called recursively since</span></span><br><span class="line"><span class="comment">     * rdbLoad() will call the event loop to process events from time to</span></span><br><span class="line"><span class="comment">     * time for non blocking loading. */</span></span><br><span class="line">    connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Loading DB in memory"</span>);</span><br><span class="line">    rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load) &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line">        rioInitWithConn(&amp;rdb,conn,server.repl_transfer_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the socket in blocking mode to simplify RDB transfer.</span></span><br><span class="line"><span class="comment">         * We'll restore it when the RDB is received. */</span></span><br><span class="line">        connBlock(conn);</span><br><span class="line">        connRecvTimeout(conn, server.repl_timeout*<span class="number">1000</span>);</span><br><span class="line">        startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_REPLICATION,&amp;rsi) != C_OK) &#123;</span><br><span class="line">            <span class="comment">/* RDB loading failed. */</span></span><br><span class="line">            stopLoading(<span class="number">0</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization DB "</span></span><br><span class="line">                <span class="string">"from socket"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">                <span class="comment">/* Restore the backed up databases. */</span></span><br><span class="line">                disklessLoadRestoreBackups(diskless_load_backup,<span class="number">1</span>,</span><br><span class="line">                                           empty_db_flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Remove the half-loaded data in case we started with</span></span><br><span class="line"><span class="comment">                 * an empty replica. */</span></span><br><span class="line">                emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on SYNC</span></span><br><span class="line"><span class="comment">             * failure, it'll be restarted when sync succeeds or the replica</span></span><br><span class="line"><span class="comment">             * gets promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stopLoading(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RDB loading succeeded if we reach this point. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">            <span class="comment">/* Delete the backup databases we created before starting to load</span></span><br><span class="line"><span class="comment">             * the new RDB. Now the RDB was loaded with success so the old</span></span><br><span class="line"><span class="comment">             * data is useless. */</span></span><br><span class="line">            disklessLoadRestoreBackups(diskless_load_backup,<span class="number">0</span>,empty_db_flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify the end mark is correct. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rioRead(&amp;rdb,buf,CONFIG_RUN_ID_SIZE) ||</span><br><span class="line">                <span class="built_in">memcmp</span>(buf,eofmark,CONFIG_RUN_ID_SIZE) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Replication stream EOF marker is broken"</span>);</span><br><span class="line">                cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">                rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup and restore the socket to the original state to continue</span></span><br><span class="line"><span class="comment">         * with the normal replication. */</span></span><br><span class="line">        rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        connRecvTimeout(conn,<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ensure background save doesn't overwrite synced data */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replica is about to load the RDB file received from the "</span></span><br><span class="line">                <span class="string">"master, but there is a pending RDB child running. "</span></span><br><span class="line">                <span class="string">"Killing process %ld and removing its temp file to avoid "</span></span><br><span class="line">                <span class="string">"any race"</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) server.rdb_child_pid);</span><br><span class="line">            killRDBChild();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rename rdb like renaming rewrite aof asynchronously. */</span></span><br><span class="line">        <span class="keyword">int</span> old_rdb_fd = open(server.rdb_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to rename the temp DB into %s in "</span></span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                server.rdb_filename, strerror(errno));</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) close(old_rdb_fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Close old rdb asynchronously. */</span></span><br><span class="line">        <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)old_rdb_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi,RDBFLAGS_REPLICATION) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization "</span></span><br><span class="line">                <span class="string">"DB from disk"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                    <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                    <span class="string">"disabled"</span>);</span><br><span class="line">                bg_unlink(server.rdb_filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on sync failure,</span></span><br><span class="line"><span class="comment">               it'll be restarted when sync succeeds or replica promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                <span class="string">"disabled"</span>);</span><br><span class="line">            bg_unlink(server.rdb_filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">        server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">        server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Final setup of the connected slave &lt;- master link */</span></span><br><span class="line">    replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the master link modules event. */</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* After a full resynchroniziation we use the replication ID and</span></span><br><span class="line"><span class="comment">     * offset of the master. The secondary ID / offset are cleared since</span></span><br><span class="line"><span class="comment">     * we are starting a new history. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(server.replid,server.master-&gt;replid,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">    server.master_repl_offset = server.master-&gt;reploff;</span><br><span class="line">    clearReplicationId2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's create the replication backlog if needed. Slaves need to</span></span><br><span class="line"><span class="comment">     * accumulate the backlog regardless of the fact they have sub-slaves</span></span><br><span class="line"><span class="comment">     * or not, in order to behave correctly if they are promoted to</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Finished with success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Finished with success. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the initial ACK immediately to put this replica in online state. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark) replicationSendAck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restart the AOF subsystem now that we finished the sync. This</span></span><br><span class="line"><span class="comment">     * will trigger an AOF rewrite, and when done will start appending</span></span><br><span class="line"><span class="comment">     * to the new file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_enabled) restartAOFAfterSYNC();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主事件循环"><a href="#主事件循环" class="headerlink" title="主事件循环"></a>主事件循环</h1><h2 id="replicationCron"><a href="#replicationCron" class="headerlink" title="replicationCron"></a>replicationCron</h2><p>主要代码位于replication.c中。<br>主函数<code>replicationCron</code>被<code>serverCron</code>触发，每隔一秒钟触发一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_with_period(<span class="number">1000</span>) replicationCron();</span><br></pre></td></tr></table></figure><p>下面查看主函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replication.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>首先，下面是几个超时判断：</p><ol><li>建立连接过程中超时</li><li>传输过程中超时</li><li>心跳/数据超时</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">    (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">     slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">     (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">    freeClient(server.master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否需要连接Master。<br><code>connectWithMaster</code>这个函数会将状态设置为<code>REPL_STATE_CONNECTING</code>，并设置回调<code>syncWithMaster</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">        server.masterhost, server.masterport);</span><br><span class="line">    connectWithMaster();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Master支持PSYNC，就定期发送ACK。<br>这个ACK的作用是发送一个<code>REPLCONF ACK</code>命令给Master，从而通知自己当前的复制偏移。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment"> * Note that we do not send periodic acks to masters that don't</span></span><br><span class="line"><span class="comment"> * support PSYNC and replication offsets. */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">    !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">    replicationSendAck();</span><br></pre></td></tr></table></figure><p>下面，我们对所有Slave发送PING。根据注释，如果我们连接了Slave（是不是说明当前节点是Master？），就按时PING它们。这样Slave们能够维护到Master的显式的超时时间，从而在TCP连接并没有真正丢失的时候，检查一个断线的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we have attached slaves, PING them from time to time.</span></span><br><span class="line"><span class="comment"> * So slaves can implement an explicit timeout to masters, and will</span></span><br><span class="line"><span class="comment"> * be able to detect a link disconnection even if the TCP connection</span></span><br><span class="line"><span class="comment"> * will not actually go down. */</span></span><br><span class="line">listIter li;</span><br><span class="line">listNode *ln;</span><br><span class="line">robj *ping_argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First, send PING according to ping_slave_period. */</span></span><br><span class="line"><span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    listLength(server.slaves))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Note that we don't send the PING if the clients are paused during</span></span><br><span class="line"><span class="comment">     * a Redis Cluster manual failover: the PING we send will otherwise</span></span><br><span class="line"><span class="comment">     * alter the replication offsets of master and slave, and will no longer</span></span><br><span class="line"><span class="comment">     * match the one stored into 'mf_master_offset' state. */</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover_in_progress =</span><br><span class="line">        server.cluster_enabled &amp;&amp;</span><br><span class="line">        server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">        clientsArePaused();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manual_failover_in_progress) &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">            ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Second, send a newline to all the slaves in pre-synchronization</span></span><br><span class="line"><span class="comment"> * stage, that is, slaves waiting for the master to create the RDB file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also send the a newline to all the chained slaves we have, if we lost</span></span><br><span class="line"><span class="comment"> * connection from our master, to keep the slaves aware that their</span></span><br><span class="line"><span class="comment"> * master is online. This is needed since sub-slaves only receive proxied</span></span><br><span class="line"><span class="comment"> * data from top-level masters, so there is no explicit pinging in order</span></span><br><span class="line"><span class="comment"> * to avoid altering the replication offsets. This special out of band</span></span><br><span class="line"><span class="comment"> * pings (newlines) can be sent, they will have no effect in the offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The newline will be ignored by the slave but will refresh the</span></span><br><span class="line"><span class="comment"> * last interaction timer preventing a timeout. In this case we ignore the</span></span><br><span class="line"><span class="comment"> * ping period and refresh the connection once per second since certain</span></span><br><span class="line"><span class="comment"> * timeouts are set at a few seconds (example: PSYNC response). */</span></span><br><span class="line">listRewind(server.slaves,&amp;li);</span><br><span class="line"><span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">    client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_presync =</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">         server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_presync) &#123;</span><br><span class="line">        connWrite(slave-&gt;conn, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">"Disconnecting timedout replica: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a master without attached slaves and there is a replication</span></span><br><span class="line"><span class="comment">     * backlog active, in order to reclaim memory we can free it after some</span></span><br><span class="line"><span class="comment">     * (configured) time. Note that this cannot be done for slaves: slaves</span></span><br><span class="line"><span class="comment">     * without sub-slaves attached should still accumulate data into the</span></span><br><span class="line"><span class="comment">     * backlog, in order to reply to PSYNC queries if they are turned into</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp; server.repl_backlog_time_limit &amp;&amp;</span><br><span class="line">        server.repl_backlog &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle = server.unixtime - server.repl_no_slaves_since;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idle &gt; server.repl_backlog_time_limit) &#123;</span><br><span class="line">            <span class="comment">/* When we free the backlog, we always use a new</span></span><br><span class="line"><span class="comment">             * replication ID and clear the ID2. This is needed</span></span><br><span class="line"><span class="comment">             * because when there is no backlog, the master_repl_offset</span></span><br><span class="line"><span class="comment">             * is not updated, but we would still retain our replication</span></span><br><span class="line"><span class="comment">             * ID, leading to the following problem:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. We are a master instance.</span></span><br><span class="line"><span class="comment">             * 2. Our slave is promoted to master. It's repl-id-2 will</span></span><br><span class="line"><span class="comment">             *    be the same as our repl-id.</span></span><br><span class="line"><span class="comment">             * 3. We, yet as master, receive some updates, that will not</span></span><br><span class="line"><span class="comment">             *    increment the master_repl_offset.</span></span><br><span class="line"><span class="comment">             * 4. Later we are turned into a slave, connect to the new</span></span><br><span class="line"><span class="comment">             *    master that will accept our PSYNC request by second</span></span><br><span class="line"><span class="comment">             *    replication ID, but there will be data inconsistency</span></span><br><span class="line"><span class="comment">             *    because we received writes. */</span></span><br><span class="line">            changeReplicationId();</span><br><span class="line">            clearReplicationId2();</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replication backlog freed after %d seconds "</span></span><br><span class="line">                <span class="string">"without connected replicas."</span>,</span><br><span class="line">                (<span class="keyword">int</span>) server.repl_backlog_time_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If AOF is disabled and we no longer have attached slaves, we can</span></span><br><span class="line"><span class="comment">     * free our Replication Script Cache as there is no need to propagate</span></span><br><span class="line"><span class="comment">     * EVALSHA at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.aof_state == AOF_OFF &amp;&amp;</span><br><span class="line">        listLength(server.repl_scriptcache_fifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    replicationStartPendingFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the RDB file used for replication if Redis is not running</span></span><br><span class="line"><span class="comment">     * with any persistence. */</span></span><br><span class="line">    removeRDBUsedToSyncReplicas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    replication_cron_loops++; <span class="comment">/* Incremented with frequency 1 HZ. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如果SLAVEOF自己会怎么样？"><a href="#如果SLAVEOF自己会怎么样？" class="headerlink" title="如果SLAVEOF自己会怎么样？"></a>如果SLAVEOF自己会怎么样？</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li><li><a href="https://youjiali1995.github.io/redis/replication/" target="_blank" rel="noopener">https://youjiali1995.github.io/redis/replication/</a></li><li><a href="https://wenfh2020.com/2020/05/31/redis-replication-next/" target="_blank" rel="noopener">https://wenfh2020.com/2020/05/31/redis-replication-next/</a><br> 有注释</li><li><a href="https://redis.io/commands/psync" target="_blank" rel="noopener">https://redis.io/commands/psync</a></li><li><a href="https://zhuanlan.zhihu.com/p/44105707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44105707</a></li><li><a href="https://zhuanlan.zhihu.com/p/86617437" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86617437</a><br> 讲解sub slave</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。&lt;/p&gt;
&lt;p&gt;主从复制涉及到RDB等机制，其中持久化部分在&lt;a href=&quot;/2021/03/13/redis-persist/&quot;&gt;Redis持久化机制实现&lt;/a&gt;中介绍。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>重庆攻略</title>
    <link href="http://www.calvinneo.com/2021/05/09/meet-in-chongqing/"/>
    <id>http://www.calvinneo.com/2021/05/09/meet-in-chongqing/</id>
    <published>2021-05-08T17:20:33.000Z</published>
    <updated>2021-05-19T10:02:06.830Z</updated>
    
    <content type="html"><![CDATA[<p>今年五一的主题是重庆。<br>因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。</p><a id="more"></a><h1 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h1><p>首先，我们整理了一份重庆景点资料</p><ol><li>江北渝中体系：<br> 主要位于居住点附近的渝中区舌头上，这边人很多，很密集<ol><li>小什字北<br> 洪崖洞<br> 千厮门大桥</li><li>小什字南<br> 解放碑（实际上离小什字还有点远，但可以从那边走，因为下坡）<br> 长江索道<br> 湖广会馆</li><li>朝天门<br> 朝天门<br> 朝天门码头-弹子石码头</li><li>李子坝：<br> 网红轻轨，以及观景台<br> 鹅岭二厂</li><li>两路口地区<br> 山城步道<br> 宋庆龄故居<br> 两路口地铁站大扶梯</li><li>红土地地铁站</li></ol></li><li>东岸体系(实际位于南岸区)：<ol><li>弹子石<br> 杜莎夫人<br> 弹子石老街<br> 法国水师兵营旧址</li><li>南山<br> 一棵树观景园<br> 壹华里</li></ol></li><li>沙坪坝体系<ol><li>磁器口<br> 磁器口古镇<br> 白公馆<br> 渣滓洞</li></ol></li><li>九龙坡体系<ol><li>川美<br> 四川美术学院<br> 涂鸦一条街</li></ol></li></ol><p>总体来讲，重庆的行主要靠打车即可，这边无论是的士还是滴滴都非常便宜。但是需要有两点考量：</p><ol><li>打滴滴接单比较慢，并且如果在一些很有重庆特色的地方，你的定位很容易就不准，建议手动输入旁边的路名。</li><li>节假日下重庆的堵车比较严重，堵车主要分布在<ol><li>渝中区朝天宫-小什字-较场口附近，强烈建议坐地铁出渝中区再打车</li><li>途径千厮门大桥和东水关大桥，建议由地铁六号线过江</li><li>山路，例如壹华里的下山路</li><li>前往涂鸦一条街（根本打不到车，有条件的可以选择做三蹦子）</li></ol></li><li>很多地图上看起来近的点，是需要绕的</li></ol><p>同理，如果走路的话，也需要做好规划，因为高差的原因，很多地方是要绕的，会走断脚，例如：</p><ol><li>长江索道和湖广会馆</li><li>解放碑到长江索道（有个大上坡）</li><li>【打车】南滨路上东水门大桥</li><li>【打车】南滨路去较场口等区域，需要绕行重庆长江大桥</li></ol><p>由于我们住在东原1891时光道，所以我们的行程规划是：</p><ol><li>D1<br> 【午】和记火爆<br> 弹子石老街<br> 法国水师兵营旧址<br> 弹子石码头乘船到朝天门<br> 逛重庆来福士以寻找可以轻松前往地铁站的道路<br> 朝天门地铁到红土地地铁站<br> 红土地地铁站到小什字出<br> 【临时】一只酸奶牛<br> 走到解放碑步行街<br> 【临时】排队买好又来酸辣粉和玫瑰糍粑冰粉，小酥肉<br> 【晚】秦云老太婆摊摊面<br> 南滨路<br> 在小区平台看渝中区夜景</li><li>D2<br> 打车前往较场口地铁站，坐到李子坝站下<br> 观赏李子坝轻轨穿楼<br> 根据小红书上列举的short cut，从李子坝地铁站走到二厂文创公园<br> 【午】大王油茶<br> 游览二厂文创公园<br> 坐地铁前往杨家坪站<br> 【临时】重庆特色的某面包房<br> 在钟书阁排队，并参观<br> 坐233路去涂鸦一条街<br> 在涂鸦一条街寻找真正的涂鸦，发现西洋景<br> 【临时】梯坎豆花，并放弃人太多的交通茶馆<br> 从涂鸦一条街打车去九九牛肉馆<br> 【晚】九九牛肉馆（老店）<br> 从九九牛肉馆打车到壹华里公园<br> 在壹华里公园爬山，玩手机，以及观赏落日<br> 回宾馆打牌</li><li>D3<br> 【午】洪崖洞猴三火锅店<br> 重庆美术馆假装欣赏艺术<br> 在当当网书店喝一只酸奶牛，并旁听自称可能是重庆最好玩的脱口秀<br> 长江索道体验VIP待遇<br> 步行抵达洪崖洞(11楼)<br> 【晚】体验重庆KFC，并手机斗地主和充电<br> 分别参观洪崖洞的4楼和底楼<br> 挤两部电梯回到11楼，并前往千厮门大桥<br> 桥上步行观光，从大剧院站乘搭地铁，观赏洪崖洞<br> 上新街站打车回家</li></ol><h1 id="D0"><a href="#D0" class="headerlink" title="D0"></a>D0</h1><h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><p>在从红土地回来的路上，我们发现明天的长江索道票不知何时已经被定完了，于是我们只能去定人均100的讲解票，票面上说是免排队的，我感觉还是可以的。</p><h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><p>钟书阁是在这个商场的某个正数楼层，这么说是因为商场太古怪了，地下室有B1到B6，向上是L1和L2，也就是我们进来的地方，在往上又从1开始编号了。反正我们很不瑞雪地从B6上来之后，就发现了一条超级长的队——当然是去钟书阁的了。路上我还搜了钟书阁，在上海甚至无锡都有好几家，但从来没听过，所以这帮人来重庆排这家店干嘛。考虑到Z她们去上厕所了，我想着也没事做，就去排了。前面两个人是腾讯的，穿着那个灰色的文化衫，非常有辨识度。队伍的前进速度是意料之外的快，等到Z上完厕所回来，我都快到门口了。中途还有人发了一下旁边一家奶茶店的优惠券。<br>进去之后，就明白为啥这家店这么网红了，原来在一个跨越两层楼的空间的天花板上装上了玻璃，这个玻璃反射了四面墙壁上的书架和扶梯，显得很壮观。</p><p>逛完钟书阁，打算去涂鸦一条街。站在路边打车，拦车，等了好久，都没有响应。是因为打车的人太多了么？旁边倒是挤满了人，但都是往公交站台走的。我看了会两个人下棋，单车对单车单炮，很没意思。最后，我们还是选择了坐公交车，这个体验真的非常酸爽的。公交车相对是比较挤，路又很颠簸。这是一条风情街，附近应该之前是很多工厂，所以路边的人行道上隔三差五放了很多工业零件的雕塑。</p><p>过了一座桥之后，路两边的涂鸦渐渐多了起来。</p><p>到了公交站，发现路两边的房子都涂满了涂鸦，一栋楼一个风格，于是我们满心欢喜打算去涂鸦一条街，没想到这楼的涂鸦已经是巅峰了。</p><p>往前走，路过交通茶馆和蹄花店，人都在排老长的队，所以我们再往前去吃梯坎豆花。这家豆花便宜好吃，才三块钱，另外一定要加上3块钱一碗的调料。调料虽然看起来很红，但实际上并不辣。</p><p>很多清洁工在擦地。</p><p>我们顺着之前的巷子一直往前走。</p><p>越走，标语就越哲学。</p><p>走到了一所中学门边，我们准备打车。对面有人在排长队，我正好找厕所，就去看了下，原来是易烊千玺的一个雕塑在那边，大家都去合影。上完厕所回来，发现这家中学竞赛基本都是省二，但居然有3个清华，看起来重庆教育也不是很卷啊。</p><p>打车去久久牛肉馆。这趟路是最长的，大约有十几公里，但是总共也就花了五十多。</p><h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年五一的主题是重庆。&lt;br&gt;因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LevelDB之流程概览</title>
    <link href="http://www.calvinneo.com/2021/04/24/leveldb-proc/"/>
    <id>http://www.calvinneo.com/2021/04/24/leveldb-proc/</id>
    <published>2021-04-24T15:09:06.000Z</published>
    <updated>2021-08-18T07:28:38.897Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：</p><ol><li>Memtable</li><li>SSTable</li><li>Compaction机制</li></ol><a id="more"></a><p>先跑一个Demo。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options,<span class="string">"./testdb"</span>,&amp;db);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"calvinneo"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value = <span class="string">"calvinneo@calvinneo.com"</span>;</span><br><span class="line"></span><br><span class="line">status = db-&gt;Put(leveldb::WriteOptions(), key, value);<span class="comment">//添加</span></span><br><span class="line">status = db-&gt;Get(leveldb::ReadOptions(), key, &amp;value);<span class="comment">//获取</span></span><br></pre></td></tr></table></figure><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建的逻辑实际上是在打开逻辑<code>DB::Open</code>里面分出来的。但由于这部分逻辑简单独立，并且有益于理解整个数据库的layout所以提出来单独讲。<br>首先设置几个数：</p><ol><li><code>SetLogNumber</code>将日志号设置为0</li><li><code>DescriptorFileName</code>生成Manifest文件，序号为1</li><li><code>SetNextFile</code>设置为2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::NewDB() &#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);</span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面创建Manifest文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WritableFile* file;</span><br><span class="line">Status s = env_-&gt;NewWritableFile(manifest, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面一连串操作，就是把<code>new_db</code>去Encode到<code>log</code>里面，并且刷盘</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">  new_db.EncodeTo(&amp;record);</span><br><span class="line">  s = <span class="built_in">log</span>.AddRecord(record);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> file;</span><br></pre></td></tr></table></figure><p>设置CURRENT指向最新的Manifest</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h1><p>调用链如下所示<br><img src="/img/leveldb/proc/recoverlink.png"></p><h2 id="DB-Open"><a href="#DB-Open" class="headerlink" title="DB::Open"></a>DB::Open</h2><p><code>DBImpl</code>的构造函数只是一个初始化成员列表，并不包含其他逻辑了。<br>在得到<code>DBImpl</code>对象后，我们首先<strong>加锁</strong>，并且调用<code>Recover</code>方法。这个方法内容是加载Manifest文件，并恢复故障。<br>值得注意的是<code>save_manifest</code>这个参数，会被通过调用链传得很深，具体作用是：</p><ol><li>在<code>RecoverLogFile</code>中可能出现Memtable被Dump的情况</li><li>在<code>Version::Recover</code>中，如果不能<code>ReuseManifest</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, DB** dbptr) &#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> DBImpl(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.Lock();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  Status s = impl-&gt;Recover(&amp;edit, &amp;save_manifest);</span><br></pre></td></tr></table></figure></li></ol><p>创建一个新的log文件。如果没有Memtable，需要创建一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                   &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetLogNumber(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> MemTable(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Q】有个问题，这里为啥还需要调用LogAndApply？因为在<code>VersionSet::Recover</code>里面已经看到有类似的过程了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.SetLogNumber(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    impl-&gt;RemoveObsoleteFiles();</span><br><span class="line">    impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.Unlock();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    assert(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-Recover"><a href="#DBImpl-Recover" class="headerlink" title="DBImpl::Recover"></a>DBImpl::Recover</h2><p>首先创建数据库目录，并且加文件锁，也就是目录下的<code>LOCK</code>文件，这个函数很有意思，后面专门来讲。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Recover(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">  env_-&gt;CreateDir(dbname_);</span><br><span class="line">  assert(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面我们检查db目录下有没有CURRENT文件。如果没有，我们认为数据库就不存在，如果此时设置了<code>options_.create_if_missing</code>，就创建，否则返回错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Creating DB %s since it was missing."</span>,</span><br><span class="line">        dbname_.c_str());</span><br><span class="line">    s = NewDB();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(</span><br><span class="line">        dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(dbname_,</span><br><span class="line">                                   <span class="string">"exists (error_if_exists is true)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面调用VersionSet里面的Recover函数。这个函数负责读取Manifest文件，恢复版本信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = versions_-&gt;Recover(save_manifest);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们要分析Log文件，如果有Log文件大于Manifest中记录的值，就说明这些日志是上次关闭时丢失的数据，我们需要恢复这些日志。<br>注意<code>PrevLogNumber</code>不再使用了，但是出于兼容性，我们依旧关注这个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line"><span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line"><span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line">FileType type;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br></pre></td></tr></table></figure><p><code>filenames</code>表示数据库目录下面的所有文件，我们依次遍历这些文件，并用<code>ParseFileName</code>解析出他们的number。这里的number就是诸如<code>MANIFEST-000002</code>里面的2，应该也是对应到<code>FileMetaData</code>里面的number字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">    expected.erase(number);</span><br><span class="line">    <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">      logs.push_back(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!expected.empty()) &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RecoverLogFile</code>的作用是回放日志，既然这样，就需要对日志进行排序。回放日志会修改VersionEdit，并且可能会导致Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line"><span class="built_in">std</span>::sort(logs.begin(), logs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">  s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                     &amp;max_sequence);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>MarkFileNumberUsed</code>的作用就是设置<code>next_file_number_</code>，确保<code>next_file_number_</code>要严格大于传入的<code>logs[i]</code>。即，如果小于等于传入的<code>logs[i]</code>，就将它设置为<code>logs[i]+1</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;SetLastSequence(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="VersionSet-Recover"><a href="#VersionSet-Recover" class="headerlink" title="VersionSet::Recover"></a>VersionSet::Recover</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::Recover(<span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先读取CURRENT文件内容，得到当前用的Manifest文件。注意，到这里为止，肯定是存在CURRENT文件的，如果不存在，<code>DBImpl::Recover</code>流程就已经会去创建了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read "CURRENT" file, which contains a pointer to the current manifest file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current;</span><br><span class="line">Status s = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current.empty() || current[current.size() - <span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT file does not end with newline"</span>);</span><br><span class="line">&#125;</span><br><span class="line">current.resize(current.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>如果没找到Manifest，就返回一个错误。<a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">对于这种情况，应该也是能处理的</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dscname = dbname_ + <span class="string">"/"</span> + current;</span><br><span class="line">SequentialFile* file;</span><br><span class="line">s = env_-&gt;NewSequentialFile(dscname, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.IsNotFound()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT points to a non-existent file"</span>,</span><br><span class="line">                              s.ToString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是根据Manifest文件里面的内容，读取并设置VersionSet。<br>【Q】在哪里写入的呢？答案是在<code>VersionEdit::EncodeTo</code>和<code>Writer::AddRecord</code>里面，这个函数在LogAndApply的时候被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"><span class="keyword">int</span> read_records = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.status = &amp;s;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们用一个while循环，从reader中读取记录。<br><code>ReadRecord</code>这个函数，将下一个record读入<code>*record</code>中，如果读取成功，返回true；如果EOF了，就返回false。可能会使用<code>*scratch</code>作为临时存储。<code>*record</code>是有效的，直到下一个对<code>reader</code>的变化操作，或者对<code>*scratch</code>的变化操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Slice record;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</span><br><span class="line">  ++read_records;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  s = edit.DecodeFrom(record);</span><br></pre></td></tr></table></figure><p>Manifest里面会记录当时的Comparator（用文本编辑框打开这个文件，能看到一个类名一样的东西），VersionEdit会比较这两个是否一致。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">      edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</span><br><span class="line">    s = Status::InvalidArgument(</span><br><span class="line">        edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</span><br><span class="line">        icmp_.user_comparator()-&gt;Name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Q】在LogAndApply实现中，<code>builder.Apply</code>之后还会跟着<code>builder.SaveTo</code>，这里为啥不跟了？稍等，Apply是一条记录Apply一次，SaveTo是最后全搞好了，一次SaveTo。我们往后看，就能看到对<code>SaveTo</code>的调用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      builder.Apply(&amp;edit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">      log_number = edit.log_number_;</span><br><span class="line">      have_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">      prev_log_number = edit.prev_log_number_;</span><br><span class="line">      have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">      next_file = edit.next_file_number_;</span><br><span class="line">      have_next_file = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">      last_sequence = edit.last_sequence_;</span><br><span class="line">      have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，这个文件就读取完毕了，我们释放这个文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line">file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-nextfile entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-lognumber entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no last-sequence-number entry in descriptor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">    prev_log_number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MarkFileNumberUsed(prev_log_number);</span><br><span class="line">  MarkFileNumberUsed(log_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是SaveTo、Finalize、AppendVersion的流程，和<code>LogAndApply</code>是类似的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">  <span class="comment">// Install recovered version</span></span><br><span class="line">  Finalize(v);</span><br><span class="line">  AppendVersion(v);</span><br><span class="line">  manifest_file_number_ = next_file;</span><br><span class="line">  next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">  last_sequence_ = last_sequence;</span><br><span class="line">  log_number_ = log_number;</span><br><span class="line">  prev_log_number_ = prev_log_number;</span><br></pre></td></tr></table></figure><p>检查是继续用现有的Manifest文件，还是重新建一个。这个可能修改<code>descriptor_file_</code>，从而影响到<code>LogAndApply</code>，但是这样的影响只会存在于Recover里面。<br>【Q】这么处理的目的是什么呢？<br>目的是为了解决Manifest文件过大的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error = s.ToString();</span><br><span class="line">    Log(options_-&gt;info_log, <span class="string">"Error recovering version set with %d records: %s"</span>,</span><br><span class="line">        read_records, error.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-RecoverLogFile"><a href="#DBImpl-RecoverLogFile" class="headerlink" title="DBImpl::RecoverLogFile"></a>DBImpl::RecoverLogFile</h2><p>【在阅读这个函数前，需要先学习<code>VersionSet::Recover</code>】<br>RecoverLogFile用于读取Log，并且将应用尚未Apply到版本的Log。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::RecoverLogFile(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</span><br><span class="line">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</span><br><span class="line">                              SequenceNumber* max_sequence) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="comment">// null if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      Log(info_log, <span class="string">"%s%s: dropping %d bytes; %s"</span>,</span><br><span class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">nullptr</span> ? <span class="string">"(ignoring error) "</span> : <span class="string">""</span>), fname,</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.ToString().c_str());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the log file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = LogFileName(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    MaybeIgnoreError(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.c_str();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="comment">// large sequence numbers).</span></span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>, <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Recovering log #%llu"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)log_number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read all the records and add to a memtable</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>现在，我们开始循环读取日志到<code>record</code>中。接着调用<code>InsertInto</code>方法将它写到Memtable中，这个方法原理我们在介绍<code>DB::Write</code>时讲解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (record.size() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    reporter.Corruption(record.size(),</span><br><span class="line">                        Status::Corruption(<span class="string">"log record too small"</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    mem = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">    mem-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</span><br><span class="line">  MaybeIgnoreError(&amp;status);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>接着我们更新<code>last_seq</code>。【Q】有点奇怪，这里为啥要加Count？参考写那一部分的分析。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SequenceNumber last_seq = WriteBatchInternal::Sequence(&amp;batch) +</span><br><span class="line">                                WriteBatchInternal::Count(&amp;batch) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">  *max_sequence = last_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Memtable内存超限了，就开启Minor Compaction。当然，这里是一个局部的Compaction，因为不需要维护版本，所以没有LogAndApply调用。因为也不会产生多余的文件，所以也没有<code>RemoveObsoleteFiles</code>调用。回忆一下WriteLevel0Table的实现，我们实际要做的是：</p><ol><li>生成SSTable</li><li>计算SSTable放到那哪一层</li><li>写VersionEdit</li></ol><p>如果需要将Memtable落盘，那么就要设置<code>save_manifest</code>为true。这个值是从<code>DBImpl::Open</code>开始一层一层传下来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">    compactions++;</span><br><span class="line">    *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">    mem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">      <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到现在为止，上面的while循环就结束了，我们释放掉这个日志文件。但是这里同样要看一下是否可以重新利用log文件<code>fname</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if we should keep reusing the last log file.</span></span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</span><br><span class="line">  assert(logfile_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(log_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(mem_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> lfile_size;</span><br><span class="line">  <span class="keyword">if</span> (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;</span><br><span class="line">      env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) &#123;</span><br></pre></td></tr></table></figure><p>如果重新利用Log，就不需要走到后面的<code>WriteLevel0Table</code>了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Log(options_.info_log, <span class="string">"Reusing old log %s \n"</span>, fname.c_str());</span><br><span class="line">    log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(logfile_, lfile_size);</span><br><span class="line">    logfile_number_ = log_number;</span><br><span class="line">    <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mem_ = mem;</span><br><span class="line">      mem = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// mem can be nullptr if lognum exists but was empty.</span></span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><h3 id="PosixLockTable"><a href="#PosixLockTable" class="headerlink" title="PosixLockTable"></a>PosixLockTable</h3><p><code>PosixLockTable</code>这个类用来管理所有通过<code>LockFile</code>锁住的文件。<br>需要注意的是<code>fcntl(F_SETLK)</code>也可以实现文件锁，但是它不能保证同一个进程中的并发访问，所以在此之外，还需要再包一层。<br>【Q】为什么进程中还会有并发访问？在下文中解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PosixLockTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    <span class="keyword">bool</span> succeeded = locked_files_.insert(fname).second;</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">    <span class="keyword">return</span> succeeded;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    locked_files_.erase(fname);</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  port::Mutex mu_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="function">locked_files_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LockFile"><a href="#LockFile" class="headerlink" title="LockFile"></a>LockFile</h3><p>为了加锁，我们首先得往自己进程中的<code>PosixLockTable locks_</code>中加入加锁记录。如果加锁失败，说明这个锁已经被我们进程持有了，就退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LockFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, FileLock** lock)</span> override </span>&#123;</span><br><span class="line">  *lock = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fd = ::open(filename.c_str(), O_RDWR | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> PosixError(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!locks_.Insert(filename)) &#123;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    <span class="keyword">return</span> Status::IOError(<span class="string">"lock "</span> + filename, <span class="string">"already held by process"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果我们进程没有持有锁，再调用<code>LockOrUnlock</code>加文件锁。如果加锁失败，说明锁已经被其他进程占用了，这时候就要将它从<code>locks_</code>移除出去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (LockOrUnlock(fd, <span class="literal">true</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> lock_errno = errno;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    locks_.Remove(filename);</span><br><span class="line">    <span class="keyword">return</span> PosixError(<span class="string">"lock "</span> + filename, lock_errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *lock = <span class="keyword">new</span> PosixFileLock(fd, filename);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixLockTable locks_;</span><br></pre></td></tr></table></figure><h3 id="LockOrUnlock"><a href="#LockOrUnlock" class="headerlink" title="LockOrUnlock"></a>LockOrUnlock</h3><p><code>LockOrUnlock</code>根据传入的<code>lock</code>对文件进行<code>F_SETLK</code>操作。<code>F_SETLK</code>是非阻塞的，还有一个<code>F_SETLKW</code>函数是阻塞的。<br><code>F_SETLK</code>可以锁定文件的某些部分，在这里，设置<code>l_start</code>和<code>l_len</code>都为0，表示锁定整个文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LockOrUnlock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> lock)</span> </span>&#123;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> :</span>:flock file_lock_info;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memset</span>(&amp;file_lock_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(file_lock_info));</span><br><span class="line">  file_lock_info.l_type = (lock ? F_WRLCK : F_UNLCK);</span><br><span class="line">  file_lock_info.l_whence = SEEK_SET;</span><br><span class="line">  file_lock_info.l_start = <span class="number">0</span>;</span><br><span class="line">  file_lock_info.l_len = <span class="number">0</span>;  <span class="comment">// Lock/unlock entire file.</span></span><br><span class="line">  <span class="keyword">return</span> ::fcntl(fd, F_SETLK, &amp;file_lock_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有关Linux进程和线程的补充说明"><a href="#有关Linux进程和线程的补充说明" class="headerlink" title="有关Linux进程和线程的补充说明"></a>有关Linux进程和线程的补充说明</h3><p>这里需要注意，Linux中pthread库创建出来的线程可能具有相同的PID，不同的TID，我们可以从下面的代码看到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gettid() syscall(SYS_gettid)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">99</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg)<span class="number">-1</span>, <span class="string">"thd %d: getpid %d gettid %d\n"</span>, *(<span class="keyword">int</span>*)index, getpid(), gettid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, start_routine, &amp;th1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2;</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, start_routine, &amp;th2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">"main: i am main\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="写"><a href="#写" class="headerlink" title="写"></a>写</h1><p>LevelDB可以通过<code>WriteBatch</code>支持批量更新的功能。当然了，作为对<code>Write</code>函数的一个简易化封装，<code>Put</code>只会更新一个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Put(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.Put(key, value);</span><br><span class="line">  <span class="keyword">return</span> Write(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写数据库的流程：</p><ol><li>写WAL</li><li>写MemTable</li><li>更新Sequence Number</li></ol><p>如下所示，写是可以并发的，因此会有类似于InnoDB中的组提交机制。<br><img src="/img/leveldb/proc/writeproc.png"></p><h2 id="DBImpl-Write"><a href="#DBImpl-Write" class="headerlink" title="DBImpl::Write"></a>DBImpl::Write</h2><p>首先，全局有个<code>writers_</code>队列，维护所有的写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们新创建一个<code>DBImpl::Writer</code>这个对象，这个对象中有一个关联到<code>mutex_</code>的条件变量<code>w.cv</code>。<br>接着将这个Writer对象放到<code>writers_</code>中，然后我们等待下面的条件：</p><ol><li><code>w.done()</code><br> 表示其他线程已经帮<code>w</code>写完了。</li><li><code>w == writers_.front()</code><br> 表示这个Writer位于队头，并且抢到了锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Write(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ol><p>所以当一个写线程进入时，首先先要获得锁，这个锁可能会被其他的写入(的部分阶段)持有，或者被后台Compaction(的部分阶段)线程持有。<strong>获得锁之后，它能做的其实也就是把自己的<code>Writer</code>挂到<code>writers_</code>队列上</strong>，然后如果现在不是队头，就要去等待信号量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">writers_.push_back(&amp;w);</span><br><span class="line"><span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果从条件变量上醒过来，还是要再检查一下有没有<code>w.done()</code>，因为可能是另一个条件醒过来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">  <span class="keyword">return</span> w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面调用<code>MakeRoomForWrite</code>，如果<code>updates</code>是nullptr的话，force就是1，强制<code>MakeRoomForWrite</code>进行Compaction。<br>【Q】什么时候<code>updates</code>是nullptr呢？<code>DBImpl::TEST_CompactMemTable</code>里面有个注释，说如果设置为nullptr，就是在催促。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>在<code>MakeRoomForWrite</code>之后，肯定是可以往数据库里面写东西的了。<br>我们需要得到一个Sequence Number才能写，我们首先取出上一次写的Sequence Number。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">Writer* last_writer = &amp;w;</span><br></pre></td></tr></table></figure><p><code>BuildBatchGroup</code>会合并队列里的多个写入到<code>tmp_batch_</code>里面。这个batch算作一次更新，具有<strong>全局唯一</strong>的一个Sequence Number，从之前递增而来。在合并的时候需要考虑：</p><ol><li>总写入数据大小</li><li>如果有请求是<code>sync==false</code>了，那么就不加入<code>sync==true</code>的<br>在合并结束后，<code>BuildBatchGroup</code>会更新<code>last_writer</code>，表示最后一个写入。<br>【Q】<strong>是不是可能在Memtable有两个record，他们的Sequence Number是相同的？</strong>现在看来是有可能的，这是因为批量写的话只会有一个Sequence Number。但是假如有Count个一次性写入，那么Sequence Number会在这个之后增加Count次。有点奇怪。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">  WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">  last_sequence += WriteBatchInternal::Count(write_batch);</span><br></pre></td></tr></table></figure></li></ol><p>下面是写日志的操作对应<code>AddRecord</code>。<br>【Q】根据注释，这个操作是不需要加锁的，为什么呢？<a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">文章</a>说，这样可以先让其他请求进入队列中排队。<br>这样做是安全的，因为只有一个写，就是<code>&amp;w</code>。<br>同时，可以看出这一步会给写入速度带来比较好的提升，因为只有拿到锁才能往<code>writers_</code>里面push。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line"><span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line"><span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line"><span class="comment">// into mem_.</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">  <span class="keyword">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">    status = logfile_-&gt;Sync();</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      sync_error = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据库的通用原理，写完日志，状态OK了，才能写Memtable，对应<code>InsertInto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">      <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">      <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">      <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐个弹出<code>writers_</code>里的元素，并唤起等待write的线程，直到遇到<code>last_writer</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Writer* ready = writers_.front();</span><br><span class="line">  writers_.pop_front();</span><br><span class="line">  <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">    ready-&gt;status = status;</span><br><span class="line">    ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    ready-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们处理完<code>writers</code>队列中的一个项目了，应当Signal一下，通知下一个项目进来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.empty()) &#123;</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DBImpl-BuildBatchGroup"><a href="#DBImpl-BuildBatchGroup" class="headerlink" title="DBImpl::BuildBatchGroup"></a>DBImpl::BuildBatchGroup</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: Writer list must be non-empty</span></span><br><span class="line"><span class="comment">// REQUIRES: First writer must have a non-null batch</span></span><br><span class="line">WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  Writer* first = writers_.front();</span><br><span class="line">  WriteBatch* result = first-&gt;batch;</span><br><span class="line">  assert(result != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>讨论第一个batch的大小来设置<code>max_size</code>：</p><ol><li>如果比较小<br> 就设置为<code>size + (128 &lt;&lt; 10)</code></li><li>如果还可以<br> 就设置为<code>1 &lt;&lt; 20</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size = WriteBatchInternal::ByteSize(first-&gt;batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line"><span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line"><span class="comment">// down the small write too much.</span></span><br><span class="line"><span class="keyword">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>)) &#123; <span class="comment">// 128 &lt;&lt; 10 == 1 &lt;&lt; 17</span></span><br><span class="line">  max_size = size + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>first</code>是<code>writers_</code>队头，下面，我们就遍历整个<code>writers_</code>队列，直到：</p><ol><li><strong>如果<code>first</code>是non sync的话，那么我们会在遇到第一个要加入的sync请求的时候就break掉。反之，如果<code>first</code>是sync的话，那么可以兼容non sync的请求的</strong>。</li><li>大小超限<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*last_writer = first;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt;::iterator iter = writers_.begin();</span><br><span class="line">++iter;  <span class="comment">// Advance past "first"</span></span><br><span class="line"><span class="keyword">for</span> (; iter != writers_.end(); ++iter) &#123;</span><br><span class="line">  Writer* w = *iter;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync) &#123;</span><br><span class="line">    <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w-&gt;batch != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    size += WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; max_size) &#123;</span><br><span class="line">      <span class="comment">// Do not make batch too big</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们把这些batch，全部加到<code>result</code>里面。如果涉及多个batch，result就指向<code>tmp_batch_</code>，否则就指向<code>first-&gt;batch</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Append to *result</span></span><br><span class="line">      <span class="keyword">if</span> (result == first-&gt;batch) &#123;</span><br><span class="line">        <span class="comment">// Switch to temporary batch instead of disturbing caller's batch</span></span><br><span class="line">        result = tmp_batch_;</span><br><span class="line">        assert(WriteBatchInternal::Count(result) == <span class="number">0</span>);</span><br><span class="line">        WriteBatchInternal::Append(result, first-&gt;batch);</span><br><span class="line">      &#125;</span><br><span class="line">      WriteBatchInternal::Append(result, w-&gt;batch);</span><br><span class="line">    &#125;</span><br><span class="line">    *last_writer = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-MakeRoomForWrite"><a href="#DBImpl-MakeRoomForWrite" class="headerlink" title="DBImpl::MakeRoomForWrite"></a>DBImpl::MakeRoomForWrite</h2><p><code>MakeRoomForWrite</code>用来确保我们有空间写入，如果此时Memtable满了，就需要去dump成Immutable Memtable。如果现在Level0负荷过重，那么就要延迟一下写入速度。<br>在研究这个函数时，我们要特别注意各个if条件的判断顺序，这体现了优先级。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: mutex_ is held</span></span><br><span class="line"><span class="comment">// REQUIRES: this thread is currently at the front of the writer queue</span></span><br><span class="line">Status DBImpl::MakeRoomForWrite(<span class="keyword">bool</span> force) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  <span class="keyword">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br></pre></td></tr></table></figure><p>一进来，首先一个while循环。唔，这个功能为啥要有while？原因是因为里面要等待信号量的。还有一个原因是，当产生Immutable Memtable之后，我们需要等待它刷盘。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Yield previous error</span></span><br><span class="line">    s = bg_error_;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果force为false，也就是不强制执行Compaction，就认为是允许延迟的。【Q】其实我没搞懂这个逻辑。<br>如果允许延迟，并且Level0的文件数达到至少8个，那么就开始慢速写。注意，Level0层最大文件数不是4，这是个误区。当有4个文件的时候开始Compaction，当有12个文件的时候，才停止写入。<br>慢速写的实现就是主线程睡1000ms，这个时候后台的Compaction线程是可以开始Compact的。在睡眠结束之后，要将<code>allow_delay</code>设为false，也就是说对于一次写，我们只慢速一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line">                              config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">  <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">  <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">  <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">  <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">  <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line">  allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">  mutex_.Lock();</span><br></pre></td></tr></table></figure><p>下面，如果不强制Compaction，并且Memtable的大小没有超标，那么就啥都不要做，这个应该是最通常的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">           (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">  <span class="comment">// There is room in current memtable</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>如果此时上一轮Immutable Memtable还没有Minor Compact完毕，那么我们就在<code>background_work_finished_signal_</code>这个条件变量上面等待。<br>我们注意到在进入这个函数时是持有<code>mutex_</code>的，所以这个生产者消费者模式是安全的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">  <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Current memtable full; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure><p>同理，如果Level0满了，即达到12个文件了，那我们同样要在信号量上等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Too many L0 files; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure><p>对于剩余的情况，我们要将Memtable改成Immutable Memtable。<br>同时，我们注意到这个分支并不会在最后break掉！这是因为此时有了Immutable Memtable了，我们需要等它被刷成SSTable落盘，所以至少还需要一次while循环。<br>这个这个刷盘过程等到什么时候呢？</p><ol><li>对于<code>CompactMemTable</code>来说，至少要执行完LogAndApply之后，才会将<code>imm_</code>设置为nullptr。</li><li>而这个条件变量，在<code>MaybeScheduleCompaction</code>调用完之后会被Signal。当然，需要注意，在Major Compaction过程中，如果有Immutable Memtable需要落盘，那么还是要先执行<code>CompactMemTable</code>的，在这个之后，也会触发一次Signal。<br>注意，这一次刷盘还可能会导致Level0文件达到上限，那就要等更久了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><ol><li>读要加锁么？<br> 我们首先考虑分布式共识这一块，为了实现一致读写，Raft即使是读请求，也需要走一遍LogEntry的。而ZK的话，可以选择直接读，所以未必是一致读。<br> 当然，这个离题了。我觉得根据LevelDB的MVCC模式，其实至少有一部分是可以不加锁的。</li><li>在哪些地方可以非线性地查找？<br> 在非0层找SSTable时，见FindFile。<br> 在BlockReader返回Iterator之后，可以通过Seek来二分。</li><li>在读取的时候会做缓存么？<br> LevelDB在Table和Block两个层面进行缓存。<br> 在Table层面通过TableCache。<br> 在Block层面通过BlockReader里面的<code>table-&gt;rep_-&gt;options.block_cache</code>分支。</li></ol><h2 id="DBImpl-Get"><a href="#DBImpl-Get" class="headerlink" title="DBImpl::Get"></a>DBImpl::Get</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br></pre></td></tr></table></figure><p>可以看到，在获取了<code>current</code>之后，就可以解锁了。<br>【Q】<strong>这里还取出了<code>mem_</code>和<code>imm_</code>，是不是在MVCC下面，可能同时存在多个<code>mem_</code>和<code>imm_</code>？</strong>此时，永远写最新的Memtable，但是可能会读旧的Memtable。<br>下面就是经典的读取三部曲：</p><ol><li>首先看Memtable</li><li>然后看Immutable Memtable</li><li>然后就去SSTable里面找，具体是调用<code>current-&gt;Get</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">  <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">    have_stat_update = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，锁要重新加回来。<br>【Q】看起来读操作也会触发Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-Get"><a href="#Version-Get" class="headerlink" title="Version::Get"></a>Version::Get</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>这个函数根据smallest和largest找到对应的文件。<br>容易想到<code>func</code>的作用是在文件里面找key。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Version::ForEachOverlapping(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span><br><span class="line">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*)) &#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br></pre></td></tr></table></figure><p>从Compaction一文的介绍中了解到，<code>files_</code>里面存放了当前Version中所有SSTable的元信息。<br>我们首先要遍历第0层的所有文件，放到<code>tmp</code>里面，按照<code>f-&gt;number</code>排序。排完序，我们就开始查找，在文件中查找需要借助于传入的<code>func</code>，实际上是<code>State::Match</code>这个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp.reserve(files_[<span class="number">0</span>].size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].size(); i++) &#123;</span><br><span class="line">  FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp.push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，就可以用之前介绍过的<code>FindFile</code>来二分查找了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].size();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="State类"><a href="#State类" class="headerlink" title="State类"></a>State类</h3><p>State类中主要定义了从SSTable中找对应Key的函数<code>Match</code>。<br>在研究之前，我们先来复习一下SSTable的格式：</p><ol><li>data block</li><li>meta block</li><li>meta index block</li><li>index block<br> 记录每个data block的“largest”，满足<a href="/2021/04/12/leveldb-sstable/">两个性质</a>。<br> <strong>注意，这里的largest不是单纯的largest，而要进行一些修正</strong>，它实际上是分隔两个Data Block的最短Key，</li><li>footer<br> 记录index block和meta index block的位置</li></ol><p>所以，我们要先通过index block去定位data block，得到这个data block。</p><p>接着，我们复习一下block的格式</p><ol><li>record</li><li>restart</li><li>额外信息<br> num restarts<br> type<br> crc32<br>所以，我们要用LookupKey先去找restart，然后从restart开始找。</li></ol><p>同时，我们注意由于，meta block的存在，会有一些优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">  Saver saver;</span><br><span class="line">  GetStats* stats;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions* options;</span><br><span class="line">  Slice ikey;</span><br><span class="line">  FileMetaData* last_file_read;</span><br><span class="line">  <span class="keyword">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">      state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">      state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">      state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> kNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">      <span class="keyword">case</span> kFound:</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kDeleted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kCorrupt:</span><br><span class="line">        state-&gt;s =</span><br><span class="line">            Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TableCache-Get和TableCache-FindTable"><a href="#TableCache-Get和TableCache-FindTable" class="headerlink" title="TableCache::Get和TableCache::FindTable"></a>TableCache::Get和TableCache::FindTable</h3><p>TableCache这一块是一个缓存层，如果缓存中没有，才去读SSTable，并把它加到缓存里面。Get的第一步是FindTable，先介绍这个。<br>首先在<code>cache_</code>里面查文件的handle，如果没找到，就新建一个，并且调用<code>Table::Open</code>从文件中读取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  Slice key(buf, sizeof(buf));</span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;</span><br><span class="line">        s = Status::OK();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>TableAndFile</code>就是打包<code>RandomAccessFile*</code>和<code>Table*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      assert(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看Get函数，现在我们已经能得到对应的<code>Table*</code>了，此时调用<code>InternalGet</code>方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span><br><span class="line">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                             <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;InternalGet(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-InternalGet"><a href="#Table-InternalGet" class="headerlink" title="Table::InternalGet"></a>Table::InternalGet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                          <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                                <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);</span><br><span class="line">  iiter-&gt;Seek(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;Valid()) &#123;</span><br><span class="line">    Slice handle_value = iiter-&gt;value();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br></pre></td></tr></table></figure><p>首先，可以通过布隆过滤器判断这个block里面有没有。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">    !filter-&gt;KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">  <span class="comment">// Not found</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>由于布隆过滤器可能假阳，所以这边还需要实际Seek一下。我们<a href="/2021/04/12/leveldb-sstable/">先前</a>介绍过<code>BlockReader</code>，这个函数返回一个Iterator。实际上是一个<code>Block::Iter</code>对象。<br>当时他被用在创建<code>TwoLevelIterator</code>里面，这个双层迭代器实际上就是index block上的迭代器和data block上的迭代器的组合。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      Iterator* block_iter = BlockReader(<span class="keyword">this</span>, options, iiter-&gt;value());</span><br><span class="line">      block_iter-&gt;Seek(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;Valid()) &#123;</span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;key(), block_iter-&gt;value());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = iiter-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-Open"><a href="#Table-Open" class="headerlink" title="Table::Open"></a>Table::Open</h3><p>【这一部分可以先不读，因为所有对SSTable的读key请求，最后都是从Cache里面处理了】<br><code>Table::Open</code>负责读取SSTable到表对象<code>Table</code>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="line">                   <span class="keyword">uint64_t</span> size, Table** table) &#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先读取footer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">Slice footer_input;</span><br><span class="line">Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                      &amp;footer_input, footer_space);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">Footer footer;</span><br><span class="line">s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><p>再读取block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="主体函数"><a href="#主体函数" class="headerlink" title="主体函数"></a>主体函数</h3><p>主要就是构造一个state，然后调用<code>ForEachOverlapping</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats) &#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.internal_key();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  state.saver.user_key = k.user_key();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><h2 id="Manifest损坏-丢失"><a href="#Manifest损坏-丢失" class="headerlink" title="Manifest损坏/丢失"></a>Manifest损坏/丢失</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://luodw.cc/2015/10/30/leveldb-14/" target="_blank" rel="noopener">http://luodw.cc/2015/10/30/leveldb-14/</a><pre><code> 介绍WriteBatch</code></pre></li><li><a href="https://zhuanlan.zhihu.com/p/340804308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340804308</a><pre><code> 介绍Revocer逻辑</code></pre></li><li><a href="https://blog.csdn.net/sparkliang/article/details/9311487" target="_blank" rel="noopener">https://blog.csdn.net/sparkliang/article/details/9311487</a><pre><code> 介绍RecoverLogFile</code></pre></li><li><a href="https://izualzhy.cn/leveldb-write-read" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-write-read</a><br> 介绍了LevelDB读写流程，我使用了它的部分图片</li><li><a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">https://leeshine.github.io/2019/01/24/leveldb-put-get/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_10_details.html</a><br> 讲述多线程写的demo，很值得一看</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://www.cnblogs.com/cobbliu/p/6194072.html" target="_blank" rel="noopener">https://www.cnblogs.com/cobbliu/p/6194072.html</a><br> 介绍SSTable、Block的格式，一张大图，非常屌</li><li><a href="https://blog.csdn.net/weixin_42663840/article/details/82629473" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42663840/article/details/82629473</a><br> 我见过最屌有关读写的注释</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Memtable&lt;/li&gt;
&lt;li&gt;SSTable&lt;/li&gt;
&lt;li&gt;Compaction机制&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LevelDB之Compaction实现</title>
    <link href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/"/>
    <id>http://www.calvinneo.com/2021/04/18/leveldb-compaction/</id>
    <published>2021-04-18T15:09:06.000Z</published>
    <updated>2021-08-18T07:26:48.196Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：</p><ol><li>Minor Compaction<br> 对应Memtable到SSTable的过程。</li><li>Major Compaction<br> 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。<br> Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。</li></ol><p>在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。</p><p>同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。</p><a id="more"></a><p>我们首先来回顾一下LevelDB的整体架构<br><img src="/img/leveldb/compaction/arch.png"></p><p>之前提到过，当一个Memtable满了之后，会转化为Immutable Memtable。Immutable Memtable会被Dump成SSTable文件，SSTable文件是不可变的。<br>这里<code>GUARDED_BY(m)</code>实际上是<code>__attribute__(guarded_by(m))</code>这个线程安全注解，方便编译器帮助检查有没有遗漏掉加锁的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="LCS和STCS"><a href="#LCS和STCS" class="headerlink" title="LCS和STCS"></a>LCS和STCS</h2><p>有两种Compacton方案：Size-Tiered Compaction Strategy(STCS)和Leveled Compaction Strategy(LCS)。</p><h3 id="STCS"><a href="#STCS" class="headerlink" title="STCS"></a>STCS</h3><p>Memtable刷成小sstable。当这些小的sstable达到一定个数时，会被compact成一个稍大些的sstable。当稍大些的sstable又达到一定个数时，又会被一起compact成更大的sstable。当然，如果说某些Key的更新频率比较高，那么在Compact的时候只会取最新的Sequence Number，这种情况下，可能不会增加太多。<br>下图是STCS的一个示意，可以看到，每层的SSTable<strong>数量不变</strong>，但是大小<strong>越来越大</strong>。<br><img src="/img/leveldb/compaction/STCS.png"></p><h3 id="LCS-Classic-Leveled"><a href="#LCS-Classic-Leveled" class="headerlink" title="LCS(Classic Leveled)"></a>LCS(Classic Leveled)</h3><p>STCS存在一些问题，是可以被优化的：</p><ol><li>存储放大1<br> 因为Compaction时，在新SSTable生成前，旧的SSTable不能删除（当然LevelDB中有Version的概念，其实更复杂点），所以可能会造成额外一倍的开销。<br> 于是我们临机一动，我们增加SSTable数量，而控制大小不变，不就能控制这额外一倍开销的绝对数量么？</li><li>存储放大2<br> 如果Key更新频繁，可能导致同一个Level以及不同Level中的SSTable中存在相同的Key。这里的Key实际上就是LevelDB里面的user key，而不是带有Sequence Number的InternalKey。<br> 【Q】为什么不同Level会存在呢？</li></ol><p>为此，我们就得到了LCS：</p><ol><li>当Level0层数量达到Level0层阈值时，将这些SSTable和L1层的所有SSTable做Compaction。<br> 实际上，具体涉及哪些SSTable，在LevelDB中控制更为精细。并且Compaction的条件也更复杂。</li><li>如果Level1层的SSTable数量还是超过L1层的阈值，再把这些超出的SSTable向上做Compaction。</li><li><strong>除了Level0，其他层的所有SSTable中的key都是不重叠的。</strong></li></ol><p>下图是LCS的一个示意<br><img src="/img/leveldb/compaction/LCS.png"></p><p>我们注意到，LCS中，SSTable的大小不变，但是数量会增多，Level N+1的<strong>文件数量</strong>是Level N的10倍。【Q】这里看上去和LevelDB的实现还有区别，LevelDB里面的<code>MaxBytesForLevel</code>函数更多的是计算了10倍的大小，Why？这个我们在“Major Compaction流程”章节中讨论过了，每个文件大小是固定的，LevelDB通过限制每层的总大小来间接限制文件数量。这是因为我们dump的时候更方便统计大小而不是文件数量。<br>所以，假如Level1有10个文件，Level2就有100个文件。但是key在两个level中都是均匀分布的，因此我Level1拿出一个文件出来，Level2中估计只会有10个文件和它重叠，所以我们只需要合并重叠的这些文件就行了。<br>当然，Level0彼此重叠，所以还是emmmm。。。</p><p>LCS的缺点是写放大会比STCS显著提高。</p><p>【Q】既然LCS的写放大高了很多，为什么说基于LSM的写性能很好呢？可能是因为下面几点</p><ol><li>SSTable是顺序写，性能好【Q】</li><li>根据<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">RocksDB</a>的文档，在一些情况下写放大不是很严重<br> 首先是按key顺序的写，对于这种情况RocksDB可以优化。<br> 其次是有skew的写，会导致只有小部分的key被更新。</li></ol><h3 id="Level-N"><a href="#Level-N" class="headerlink" title="Level-N"></a>Level-N</h3><p>相比LCS(Classic Leveled)有更高的读放大，和更小的写放大。</p><h3 id="Tiered-Leveled"><a href="#Tiered-Leveled" class="headerlink" title="Tiered+Leveled"></a>Tiered+Leveled</h3><h1 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h1><p>需要注意的是，LevelDB是一个单机的数据库，所以实际承载的SSTable文件都位于一台机器上。</p><p><img src="/img/leveldb/compaction/cm.png"></p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType &#123;</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>kLogFile：WAL日志文件，文件名数字.log</li><li>kDBLockFile：db锁文件，文件名LOCK</li><li>kTableFile：SSTable文件，文件名数字.sst</li><li>kDescriptorFile：Manifest文件，存储VersionEdit信息，文件名为MANIFEST-数字<br> 对应<code>descriptor_file_</code>这个字段。<br> Manifest文件中维护了所有的SSTable的key范围，层级，以及其他的元信息。</li><li>kCurrentFile：记录当前的Manifest文件，文件名为CURRENT</li><li>kTempFile：临时文件，db在修复【？】过程中会产生临时文件，文件名为数字.dbtmp</li><li>kInfoLogFile：日志文件，文件名为LOG</li></ol><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>每一个VersionEdit对应Manifest里面的一个Entry，<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">称为Session Record</a>。<br><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">其中第一条Session Record包含当时LevelDB的全量版本信息</a>，这个应该是通过<code>WriteSnapshot</code>来实现的，可以看下面的介绍。</p><p>如下所示，每个Entry包含</p><ol><li>增加的SSTable<br> kNewFile</li><li>删除的SSTable<br> kDeletedFile</li><li>当前Compaction的下标<br> kCompactPointer</li><li>日志文件编号<br> kLogNumber</li><li>数据库已经持久化数据项中最大的Sequence Number<br> kLastSequence</li></ol><p>对应的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/img/leveldb/compaction/manifest.png"></p><p>写Manifest的代码应该是<code>Writer::AddRecord</code>。<br>读Manifest的代码，例如<code>VersionSet::Recover</code>。</p><h2 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h2><p>记录当前的Manifest文件名。</p><h1 id="MVCC介绍"><a href="#MVCC介绍" class="headerlink" title="MVCC介绍"></a>MVCC介绍</h1><p>参考<a href="/2017/09/20/transaction/">数据库系统中的事务</a></p><h1 id="Version机制"><a href="#Version机制" class="headerlink" title="Version机制"></a>Version机制</h1><p>大前提，Compaction过程是通过独立线程异步并发执行的。因此可能出现压缩前后的新老SSTable并存的情况。同时，我们不能立即删除老的SSTable文件，这可能是因为这个SSTable还在被读取，而要等到老SSTable的引用计数为0才行。因此Version机制可以用来辨别这些SSTable的版本。借助于Version机制，也能实现MVCC。</p><p>新版本New-Version由<code>Version</code>类和<code>VersionEdit</code>类来描述。即<code>VersionEdit</code>是New-Version相对于Version的改动。</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-<span class="keyword">Version</span> = <span class="keyword">Version</span> + VersionEdit</span><br></pre></td></tr></table></figure><p><img src="/img/leveldb/compaction/version.png"></p><p>LevelDB将所有的Version置于一个双向链表之中，因此所有的Version组成一个名为VersionSet的集合。这个集合也代表了当前DB的状态，包含了最新的Version，以及其他正在服务的Version。<br><img src="/img/leveldb/compaction/versionset.png"></p><h2 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h2><p>介绍作为桥梁作用的<code>VersionEdit</code>类。这个类里面的方法大部分是用来读写里面的私有成员的，所以只介绍私有成员。</p><ol><li><p><code>std::string comparator_;</code></p></li><li><p><code>uint64_t log_number_;</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure><p> log文件的file number，也就是<code>000003.log</code>的这个3。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">小于这个值的Log是可以被删除的</a><br> 【Q】这个字段的作用是什么呢？<br> 目前来看，在Recover的时候会用到。<br> 【Q】为什么VersionSet里面也有？<br> 其实VersionSet里面的才是主要的，VersionEdit里面的这个字段，是在LogAndApply的时候，由VersionSet设置过来的。<br> 【Q】这个number，和版本的关系是什么，是一一对应的么？比如一次Compaction之后就要换个log？因为在实现上，可以看到<code>NewFileNumber</code>会产生log(<code>DB::Open</code>)和SSTable(<code>WriteLevel0Table</code>)文件的序列号。</p></li><li><p><code>uint64_t prev_log_number_;</code>/<code>bool has_prev_log_number_;</code><br> 包括<code>void SetPrevLogNumber(uint64_t num)</code>这个函数。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">这篇文章</a>说<code>prev_log_number_</code>已经废弃了，出于兼容性才保留的。</p></li><li><p><code>uint64_t next_file_number_;</code>/<code>bool has_next_file_number_;</code><br> 下一个可用的file number。VersionSet里面也有类似字段，详细介绍见VersionSet。<br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>SequenceNumber last_sequence_;</code>/<code>bool has_last_sequence_;</code><br> SSTable 中的最大的Sequence Number。VersionSet里面也有个平行的。</p></li><li><p><code>bool has_comparator_;</code></p></li><li><p><code>bool has_log_number_;</code></p></li><li><p><code>std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</code><br> 主要用于Major Compaction的时候选择文件。first表示每个level。<br> 【Q】在<code>Compaction</code>类和<code>VersionSet</code>类里面也有一个这个字段。它们的作用是什么呢？</p></li><li><p><code>DeletedFileSet deleted_files_;</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br></pre></td></tr></table></figure><p> pair存储了level和file。表示将第level层中的file删除。</p></li><li><p><code>std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</code><br> <code>FileMetaData</code>存储了文件大小，以及文件中最小的Key和最大的Key。</p></li></ol><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h3 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h3><ol><li><p>VersionSet相关<br> 指向这个Version所属的VersionSet，以及双向链表和引用计数。<br> 所以说每个Version只能属于一个VersionSet，这个也是很好理解的，</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"><span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br></pre></td></tr></table></figure></li><li><p>SSTable相关<br> <code>files_</code>表示LevelDB中每一层中所有的SSTable的文件信息。<br> <code>file_to_compact(_level)_</code>标记下一个要Compact的文件以及属于的Level。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure><p> 根据<code>SaveTo</code>函数的<a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">论述</a>，**<code>files_[level]</code>是有序的**。</p></li><li><p>其他字段<br> <code>compaction_score_</code><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">计算最迫切需要Compaction的Level</a>，所以可以决定是否需要发起Major Compaction。这个分数取决于某一层所有SSTable的大小。<br> <code>NeedsCompaction</code>会读取这个字段，计算是否需要根据Version的情况来Compaction，并呈递给<code>MaybeScheduleCompaction</code>。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"><span class="comment">// Score &lt; 1 means compaction is not strictly needed.</span></span><br><span class="line"><span class="keyword">double</span> compaction_score_;</span><br><span class="line"><span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure></li></ol><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol><li><code>int PickLevelForMemTableOutput(const Slice&amp; smallest_user_key, const Slice&amp; largest_user_key);</code><br> 给定一个Memtable里面的Key的范围，返回这个Memtable被Dump的话要放到第几层。</li><li><code>Compaction* PickCompaction();</code><br> 用来处理size compaction和seek compaction。<br> 这个函数，在“Compaction主函数”这个章节介绍。</li><li><code>Compaction* CompactRange(int level, const InternalKey* begin, const InternalKey* end);</code></li></ol><h3 id="Version-PickLevelForMemTableOutput"><a href="#Version-PickLevelForMemTableOutput" class="headerlink" title="Version::PickLevelForMemTableOutput"></a>Version::PickLevelForMemTableOutput</h3><h4 id="OverlapInLevel"><a href="#OverlapInLevel" class="headerlink" title="OverlapInLevel"></a>OverlapInLevel</h4><p>先介绍辅助函数<code>OverlapInLevel</code>，作用是判断范围<code>[smallest_user_key,largest_user_key]</code>和level中的文件有没有Overlap。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Version::OverlapInLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span><br><span class="line">                             <span class="keyword">const</span> Slice* largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                               smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SomeFileOverlapsRange"><a href="#SomeFileOverlapsRange" class="headerlink" title="SomeFileOverlapsRange"></a>SomeFileOverlapsRange</h4><p>SomeFileOverlapsRange返回<code>files</code>中有没有在范围<code>[smallest_user_key,largest_user_key]</code>中的key，是<code>OverlapInLevel</code>的辅助函数。<br><code>disjoint_sorted_files</code>表示传入的<code>files</code>里面的key是不是不相交的，一般除了Level0，其他都是不相交的。<br><code>AfterFile</code>和<code>BeforeFile</code>都比较FileMetaData里面的<code>largest</code>/<code>smallest</code>的<code>user_key()</code>字段。他们的类型是<code>InternalKey</code>，也就是不带Sequence Number和Value Type的。<br>对于普通情况，对于一个文件<code>f</code>，如果<code>smallest_user_key</code>大于该文件中的最大值，或者<code>largest_user_key</code>小于最小值，那么认为是不重叠的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SomeFileOverlapsRange</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> disjoint_sorted_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = icmp.user_comparator();</span><br><span class="line">  <span class="keyword">if</span> (!disjoint_sorted_files) &#123;</span><br><span class="line">    <span class="comment">// Need to check against all files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      <span class="keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||</span><br><span class="line">          BeforeFile(ucmp, largest_user_key, f)) &#123;</span><br><span class="line">        <span class="comment">// No overlap</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Overlap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果是不相交的文件，就可以基于<code>FindFile</code>对<code>files</code>集合二分查找，<strong>所以我们看到，在某一个Level找SSTable的时候是可以二分的</strong>。<br>可以思考一下我们用什么做二分的key呢？答案是每个file的largest。我们要找到第一个largest大于等于<code>smallest_user_key</code>的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Binary search over file list</span></span><br><span class="line">  <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (smallest_user_key != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Find the earliest possible internal key for smallest_user_key</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">small_key</span><span class="params">(*smallest_user_key, kMaxSequenceNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">                          kValueTypeForSeek)</span></span>;</span><br><span class="line">    index = FindFile(icmp, files, small_key.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= files.size()) &#123;</span><br><span class="line">    <span class="comment">// beginning of range is after all files, so no overlap.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>二分法找到<strong>可能存在</strong>的文件<code>files[index]</code>后，不要忘了在判断下这个文件<strong>实际有没有overlap</strong>。这是二分法的基本规则。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span><br><span class="line">                                        <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先判断我们要加入的文件的<code>[smallest_user_key,largest_user_key]</code>和Level0有没有交叠。如果有交叠，就进不了这个if，直接放到第一层，等后面Major Compaction了。<br>如果没有交叠，我们尝试能否将它下放到<code>config::kMaxMemCompactLevel</code>之前的层。【Q】为什么我们要设置上限<code>kMaxMemCompactLevel</code>呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为什么会有这个？下面讲。</span></span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断level-2层情况的分支详解"><a href="#判断level-2层情况的分支详解" class="headerlink" title="判断level + 2层情况的分支详解"></a>判断level + 2层情况的分支详解</h4><p>这里需要着重讲解一下<code>level + 2 &lt; config::kNumLevels</code>这个分支的含义。</p><p>作为普通人呢，我觉得判断完<code>OverlapInLevel(level + 1,...</code>就可以直接<code>level++</code>了啊，但是大佬肯定是不平凡的。<br>大佬觉得现在我们想把文件放到level + 1层，但是要先打住，看看level + 2层是什么情况，也就对应到下面的代码。我们要计算所有重叠的文件的总大小，如果这个大小超过了阈值，那么我们就不把这个SSTable进行下放。<br>这是防止level + 1和level + 2的重叠范围太大，导致这两层进行Compaction时涉及的SSTable过多，耗时过长。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickLevelForMemTableOutput中的片段代码</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>于是，先要用<code>GetOverlappingInputs</code>这个函数，计算level + 2层中到底有哪些文件和<code>[smallest_user_key,largest_user_key]</code>有交叠，这些文件会放到<code>overlaps</code>里面。<br>而<code>TotalFileSize</code>这个函数就是对<code>FileMetaData::file_size</code>求和。<br>然后，我们和<code>MaxGrandParentOverlapBytes</code>返回的阈值进行比较。</p><h4 id="GetOverlappingInputs-MaxGrandParentOverlapBytes"><a href="#GetOverlappingInputs-MaxGrandParentOverlapBytes" class="headerlink" title="GetOverlappingInputs/MaxGrandParentOverlapBytes"></a>GetOverlappingInputs/MaxGrandParentOverlapBytes</h4><p><code>GetOverlappingInputs</code>的目标是找到level中和<code>[begin,end]</code>重叠的所有文件，并放到<code>inputs</code>里面。这个函数对Level0有特殊的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="keyword">void</span> Version::GetOverlappingInputs(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span><br><span class="line">                                   <span class="keyword">const</span> InternalKey* end,</span><br><span class="line">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs) &#123;</span><br></pre></td></tr></table></figure><p><code>user_begin</code>和<code>user_end</code>是从InternalKey中提取出的user key。如果传入nullptr，表示在比较时<code>begin</code>永远小于任何key。<br>【Q】这里为什么去找的user key而不是InternalKey呢？貌似很多地方都是找user key。在<a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">这篇文章</a>中，作者指出了一个其实我们很容易注意到的性质，就是除了Level0，每一层Level都是有序的。进一步地，由于LevelDB使用leveled策略(LCS)，即强调一个key在每一层至多只有1条记录，不存在冗余记录。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; config::kNumLevels);</span><br><span class="line">  inputs-&gt;clear();</span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (begin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = begin-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = end-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>默认，我们遍历这一层的所有的文件。前面两个if分别处理文件和range完全不重叠的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>否则就是有重叠的，我们把这个文件加入到<code>inputs</code>里面作为结果返回。对于<code>PickLevelForMemTableOutput</code>的逻辑而言，这里就到此为止了。<br>但是<code>GetOverlappingInputs</code>这个函数还会在<code>CompactRange</code>、<code>SetupOtherInputs</code>这些函数中用到。此时，需要处理Level0的逻辑。<strong>【Q】且慢，我们已经逐文件遍历了啊，还会有什么问题呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">这篇文章</a>中，详细解释了原因。这是因为我们认为Level1的文件是比Level0要旧的，所以<strong>如果要把Level0中的某个文件<code>f</code>移动到Level1中，我们要把Level0中所有和<code>f</code>Overlap的文件都放到Level1里面</strong>。这样，实际上保证了如果我有一个Key在Level0里面，那么inputs里面会包含所有包含这个Key的文件。</p><p>进一步想，在Level0往Level1归并的时候，其实也应该看到这个过程。事实上观看<code>PickCompaction</code>的代码实现，我们也能看到在最后有个<code>if (level == 0)</code>的判断。</p><p>这个应当同样解决我们在<code>IsTrivialMove</code>的一个疑问，也就是为什么Level层有两个的时候，我们不能简单把其中一个文件移动到下层。</p><p>所以，当检查到<code>user_begin</code>在文件<code>[file_start,file_limit]</code>中后，需要将<code>user_begin</code>调整为文件的开头<code>file_start</code>。对<code>user_end</code>也是同理的。</p><h2 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h2><h3 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h3><ol><li><code>Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu)</code><br> 这个函数接受一个VersionEdit。<br> 首先，函数将VersionEdit应用在<code>current_</code>，并借助于<code>VersionSet::Builder</code>生成一个新的Version。Builder类的实现是比较巧妙的，我们会在稍后来讲解。<br> 此后，它会调用<code>Finalize</code>函数更新<code>compaction_level_</code>和<code>compaction_score_</code>。<br> 此后，更新Manifest文件。主要是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。<br> 此后，调用<code>AppendVersion</code>将新版本添加到VersionSet的双向链表中，并且设置新的<code>current_</code>。</li><li><code>std::string compact_pointer_[config::kNumLevels];</code><br> 这个字段在Major Compaction过程中被用到。表示每一层上，下一次Compaction需要开始的key的位置。它要么是一个空串，要么是一个InternalKey。<br> 【Q】在什么时候被设置呢？<br> 根据<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">文章</a>，这个<code>compact_pointer_</code>实际上表示这一层上一次Compact时文件的largest。</li><li><code>Status Recover(bool* save_manifest);</code><br> 关于Recover机制，我们不在这篇文章中介绍。详见“LevelDB之流程概览”这篇文章。</li></ol><p>有关Sequence：</p><ol><li><code>uint64_t LastSequence() const { return last_sequence_; }</code><br> 还有个对应的<code>SetLastSequence</code>方法。<br> 返回最近的Sequence Number。这个是在写入记录的时候会使用并且更新。<br> 【Q】VersionEdit里面也有个平行的，他们之间的关系是什么呢？<br> 首先VersionSet的<code>last_sequence_</code>会随着<code>DBImpl::Write</code>操作更新。<br> 当需要进行Compact的时候，会在<code>LogAndApply</code>中赋给VersionEdit中的对应字段。而VersionEdit的目的，似乎只是持久化这个信息。</li></ol><p>有关日志：</p><ol><li><code>prev_log_number_</code>/<code>log_number_</code><br> 【Q】和VersionEdit里面同名字段的关系是什么？见VersionEdit的解释。</li></ol><p>有关文件编号：</p><ol><li><p><code>next_file_number_</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">    next_file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个字段用来生成系统中下个文件的编号。VersionEdit需要在LogAndApply时传入，以persist。<br> 【Q】这里的file number指的是SSTable的file number么？<a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">看起来并不是的</a>，而是<a href="https://www.wandouip.com/t5i49833/" target="_blank" rel="noopener">Manifest文件、SSTable文件啥的共用一个编号</a>，这也是为什么一开始Log文件是0，Minifest文件是1，SetNextFile是2的原因。</p></li><li><p><code>manifest_file_number_;</code><br> 表示Manifest文件的编号，主要在Recover时用到</p></li></ol><p>疑问：</p><ol><li>VersionSet和DBImpl是一一对应的么？<br> 应该是的，DBImpl持有一个<code>VersionSet*</code>。</li></ol><h3 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h3><p>在前面已经简单介绍过这个函数的功能了。这个函数主要在下面几个地方用到：</p><ol><li><code>DB::Open</code><br> 当DB启动的时候，可能需要从通过<code>DBImpl::Recover</code>从log中恢复一部分数据。这些数据会以VersionEdit的方式被Apply。</li><li><code>DBImpl::CompactMemTable</code><br> Minor Compaction。<br> 一般在下面的地方调用：<ul><li>BackgroundCompaction</li><li>DoCompactionWork：也就是在Major Compaction的过程中也要有限处理Minor Compaction。</li></ul></li><li><code>BackgroundCompaction</code>的非manual情况（平凡情况）<br> 这种情况只是将某个SSTable移动到别的层。</li><li><code>BackgroundCompaction</code>的manual情况（一般情况）<br> 需要归并。</li></ol><p>下面这里讲解一下源码。<br><code>__attribute__((exclusive_locks_required))</code>表示检查在调用<code>LogAndApply</code>函数之前就要持有锁<code>mu</code>。因此同时只会有一个线程执行<code>LogAndApply</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">  <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是把VersionSet的LogNumber传给VersionEdit。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们要把VersionSet的<code>last_sequence_</code>传给edit，在对<code>VersionSet::Builder</code>的论述中已经推断过这里的作用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">  Finalize(v);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的<code>descriptor_file_</code>就是一个Manifest文件。<br>如果此时<code>descriptor_log_</code>是NULL，根据注释，这个对应到首次打开数据库的状态。我们要新建一个Manifest文件，此时<code>DescriptorFileName</code>产生一个<code>&quot;/MANIFEST-%06llu&quot;</code>格式的文件名字。<br>通过<code>WriteSnapshot</code>把<code>descriptor_log_</code>写到新的Manifest文件里面，这个实际上就是Current Version的快照。<code>WriteSnapshot</code>里面也会调用<code>EncodeTo</code>和<code>AddRecord</code>。<br>【Q】为什么有这个函数？本文之前介绍了Manifest文件的构造，里面提到第一条Session Record记录了当前数据库的全量数据，我认为这里就是实现这个性质的。<br>【Q】注意，<code>VersionSet::ReuseManifest</code>也会修改这个<code>descriptor_log_</code>，有什么影响呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。这里不是写快照了，而是写一条Log。其实Manifest文件的格式就是Log。<br>在这里，将写文件的操作都集中在一起，期间是不要加锁的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>EncodeTo</code>将信息按照下面的Tag分类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>AddRecord</code>将信息编码到文件中，对应的读取函数是<code>Reader::ReadRecord</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们现在得到了一个新的Version即<code>v</code>，调用<code>AppendVersion</code>将它设置为<code>current_</code>。这个函数还会将<code>v</code>添加到VersionSet里面的那个双向链表里面。<br><a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">文章</a>中有疑问这里遇到多线程怎么办，但LevelDB中Compact只有一条后台线程，并且这里是持有锁的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VersionSet-AppendVersion"><a href="#VersionSet-AppendVersion" class="headerlink" title="VersionSet::AppendVersion"></a>VersionSet::AppendVersion</h3><p>这里<code>dummy_versions_</code>是VersionSet维护的环状链表头，<code>dummy_versions_.prev_</code>就是<code>current_</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::AppendVersion(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过<a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">下面的图</a>清晰看出<br><img src="/img/leveldb/compaction/versionset_link.png"></p><h3 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h3><ol><li><code>VersionSet* vset_;</code><br> 在构造时传入的VersionSet。</li><li><code>Version* base_;</code><br> 在构造时传入的，一般为<code>current_</code></li><li><code>LevelState levels_[config::kNumLevels];</code><br> LevelState里面记录了增加和删除的文件。</li><li><code>void Apply(VersionEdit* edit)</code><br> 将<code>edit</code>里面的变动应用到<code>current_</code>。例如要加些什么文件，写到<code>levels_[level].added_files</code>这个列表里面。但是我们不实际加，而是到<code>SaveTo</code>里面再一次性加。<br> 【Q】为什么要这样子呢？原因有2：<ol><li><code>v-&gt;files_[level]</code>这个是有序存储的。</li></ol></li><li><code>void SaveTo(Version* v)</code><br> 注意，从<code>VersionSet::Recover</code>可以看出，Applt和SaveTo并不是一对一的关系。例如我们从一个文件中多个记录里面恢复，那么每读取一个记录就要Apply一次，但最后再SaveTo。</li></ol><h4 id="VersionSet-Builder-Apply"><a href="#VersionSet-Builder-Apply" class="headerlink" title="VersionSet::Builder::Apply"></a>VersionSet::Builder::Apply</h4><p>这个函数设置诸如<code>levels_[level].added_files</code>的字段，表示我们需要做什么改变。<br>首先将VersionEdit记录的<code>compact_pointers_</code>应用到VersionSet。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后把要增加和删除的文件记录到自己的<code>levels_</code>字段里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在增加文件的时候，需要处理<code>allowed_seeks</code>字段。这里的<code>16384U</code>有点奇怪，是啥意思？<br>根据注释，我们假设：</p><ol><li>一次Seek耗时10ms</li><li>读写1MB耗时10ms，也就是我们的IO速度是100MB/s</li><li>一次Compaction，假设是1MB，需要消耗25MB的IO<ol><li>需要从这一层读取1MB</li><li>从下一层读取10-12MB的数据(boundaries may be misaligned)</li><li>写10-12MB的数据到下一层</li></ol></li></ol><p>这说明25次Seek的开销等于1MB数据的Compaction成本，也就是一次Seek大概摊还下来是40KB数据的压缩成本。我们做一些保留，让16KB对应一次Compaction，也就是允许更多的Seek次数。<br>同时，我们将<code>f-&gt;allowed_seeks</code>最小值设为100，这样也不会一直Compaction。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// 16*1024</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VersionSet-Builder-SaveTo"><a href="#VersionSet-Builder-SaveTo" class="headerlink" title="VersionSet::Builder::SaveTo"></a>VersionSet::Builder::SaveTo</h4><p><code>SaveTo</code>的最终影响是<code>MaybeAddFile</code>，也就是说将文件添加到Version里面。具体是添加到<code>v-&gt;files_</code>里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  BySmallestKey cmp;</span><br><span class="line">  cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的循环中，我们依次处理每一层的合并。主要内容是：</p><ol><li>将添加的文件合并到<code>files_</code></li><li>删除文件</li></ol><p>之前介绍过<code>base_</code>在构造时传入，一般为CURRENT，我们就是要对<code>base_</code>去应用这些修改。<br>所以，我们是</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_-&gt;files_<span class="string">[level]</span> + (levels_<span class="string">[level]</span>.added_files - levels_<span class="string">[level]</span>.deleted_files) = v-&gt;files_<span class="string">[level]</span></span><br></pre></td></tr></table></figure><p><code>base_iter</code>用来遍历原有的文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">    <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们首先<strong>预留最大空间，避免到时候的频繁动态分配</strong>。但是实际上最终未必用到这个空间，因为<code>MaybeAddFile</code>不一定真的添加文件。<br>下面就是插入操作，这个有点奇怪。我们先初始化了<code>bpos</code>，但是循环中自增的却是<code>base_iter</code>，<code>for(A;B;C)</code>里面A和C的主语不一样，很奇怪。其实<code>bpos</code>标记了我们要遍历的终点。具体解释一下，这个函数其实是一个归并的过程，分两步：</p><ol><li>插入原有的<code>base_</code>里面的文件，这些文件要小于等于<code>added_file</code><br> <code>std::upper_bound</code>找到第一个大于<code>added_file</code>的位置<code>bpos</code>，也就是我们的<code>base_iter</code>往后遍历，不会超过<code>bpos</code>。<br> 我们用<code>MaybeAddFile</code>插入，因为这些文件可能已经被标记删除。</li><li>插入<code>added_file</code></li></ol><p>**那么这么做的好处在哪里呢？我认为是减少了比较的次数，从O(n)到了O(logn)**。因为我们这里是<code>BytewiseComparator</code>，是两个Slice之间的比较，所以开销还是比较大的，这里是值得学习的一个Best Practice。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">      <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">               <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">           base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MaybeAddFile(v, level, added_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add remaining base files</span></span><br><span class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">      MaybeAddFile(v, level, *base_iter);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在Debug的状态下，会去检查除Level0之外的层有没有重叠。检查方法也很简单，就是看后一个文件的smallest是不是一定<strong>严格</strong>大于前一个文件的largest。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">        <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                       prev_end.DebugString().c_str(),</span><br><span class="line">                       this_begin.DebugString().c_str());</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="VersionSet-Builder-MaybeAddFile"><a href="#VersionSet-Builder-MaybeAddFile" class="headerlink" title="VersionSet::Builder::MaybeAddFile"></a>VersionSet::Builder::MaybeAddFile</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;</span><br><span class="line">      <span class="comment">// Must not overlap</span></span><br><span class="line">      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                  f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;refs++;</span><br><span class="line">    files-&gt;push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VersionSet-Finalize"><a href="#VersionSet-Finalize" class="headerlink" title="VersionSet::Finalize"></a>VersionSet::Finalize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是针对第0层的特殊情况。我们知道LevelDB的第0层最多存在4个文件【Q】（我觉得未必，详见<code>kL0_SlowdownWritesTrigger</code>），这就是由<code>kL0_CompactionTrigger</code>控制的。这里使用文件数量，注释里面列了两个原因：</p><ol><li>允许更大的写buffer，从而减少Level0 Compaction的数量。<br> 这里的写buffer应该是<code>options_.write_buffer_size</code>这个东西。这个阈值控制Memtable何时转换成Immutable Memtable，以及在Recover的时候何时直接dump成SSTable。<br> 佶屈聱牙，实际上的意思是，这个意思是，如果写buffer太大，如果我们用固定的size限制死了的话，可能Level0的文件数量会很少，比如就1个，这样会导致频繁的Level0 Compaction。</li><li>Level0的文件每次读取都会被Merge。我们不希望有很多个小文件(perhaps because of a small write-buffer setting, or very high compression ratios, or lots of overwrites/deletions)。<br> 如果写buffer很小，这样会导致更多的Level0文件。因为Level0的文件是overlap的，所以如果数量过多，每次查询需要Seek的文件数量就越多。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      score = v-&gt;files_[level].size() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger); <span class="comment">// ==4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于第1层以下的层，计算文件总大小，而不是文件数量了。<code>MaxBytesForLevel</code>的大概意思就是Level1总大小是10M，下面每一层翻10倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h3><p>这个函数计算每一层的最大大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>将自己从链表中移除。<br>对于自己管理的所有文件，引用计数减一。【Q】这边不搞个原子操作么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LevelDB对MVCC的实现总结"><a href="#LevelDB对MVCC的实现总结" class="headerlink" title="LevelDB对MVCC的实现总结"></a>LevelDB对MVCC的实现总结</h2><h4 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h4><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">文章</a>中论述了一次版本升级的过程，但我会批注一下具体实现的函数和逻辑</p><ol><li>新建一个Session Record，记录状态变更信息</li><li>讨论版本升级原因<ol><li>Minor Compaction或者日志replay<br> 在Session Record中记录新增的文件信息、最新的journal编号、数据库sequence number以及下一个可用的文件编号。</li><li>Major Compaction<br> 在Session Record中记录新增、删除的文件信息、下一个可用的文件编号即可。</li></ol></li><li>通过VersionEdit生成新版本<br> 相较于旧的版本信息，新的版本信息更改的内容为：<ol><li>每一层的文件信息：在<code>VersionSet::Builder::Apply</code>中。</li><li>每一层的计分信息：在<code>VersionSet::Finalize</code>中。</li></ol></li><li>将Session Record持久化<br> 在<code>VersionSet::Builder::SaveTo</code>中。</li><li>讨论是否是第一条Session Record<br> 在LogAndApply的Finalize调用之后的部分<ol><li>是<br> 新建一个Manifest文件，并将完整的版本信息全部记录进Session Record作为该Manifest的基础状态写入，同时更改Current文件，将其指向新建的Manifest。</li><li>不是<br> 将该条Session Record进行序列化后直接作为一条记录写入即可。</li></ol></li><li>将当前的Version设置为刚创建的Version<br> 这个会修改<code>current_</code>的指向。这个操作应该是原子的（不然最新版本岂不是会不一致么）实际上也在<code>mutex_</code>的保护下。<br> 在LogAndApply对<code>AppendVersion</code>的调用中。</li></ol><h1 id="Snapshot机制"><a href="#Snapshot机制" class="headerlink" title="Snapshot机制"></a>Snapshot机制</h1><p>我们在这里介绍Snapshot机制，主要是为了方便说明它对Compaction的影响：导致同一个user key的不同的Sequence Number版本存在多个。</p><p>Snapshot实际上就是某个特定的Sequence Number。<br>【Q】Sequence Number是全局递增的么？应该是这样的，在Put和Get的实现中，看到的都是读取的<code>VersionSet::LastSequence()</code>这个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Compaction主函数"><a href="#Compaction主函数" class="headerlink" title="Compaction主函数"></a>Compaction主函数</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><ol><li>BackgroundCompaction<ol><li>BackgroundCall<ol><li>BGWork<ol><li>MaybeScheduleCompaction<br> 会Schedule方法<code>BGWork</code>。<br> 这个函数在BackgroundCall，以及诸如Get等读写方法中都会被调用。</li></ol></li></ol></li></ol></li></ol><h3 id="Compaction条件"><a href="#Compaction条件" class="headerlink" title="Compaction条件"></a>Compaction条件</h3><ol><li>Minor Compaction<br> 在Recover过程中<code>ApproximateMemoryUsage</code>检测到<strong>Memtable</strong>超限，会直接触发对Memtable的Compaction。但这个Compaction是局部的，因为我们在恢复过程中，所以不需要诸如LogAndApply这种维护Version的工作。<br> 存在Immutable Memtable</li><li>Manual Compaction<br> CompactRange调用</li><li><code>size_compaction</code><br> 在<code>VersionSet::PickCompaction</code>中检查并启动。<br> 当Level0文件数目过多，或者某个Level的总大小过大。<br> 在函数<code>NeedsCompaction</code>中判断当前Version的<code>compaction_score_ </code>(size compaction)和<code>file_to_compact_</code>(seek compaction)。</li><li><code>seek_compaction</code><br> seek次数太多。我们知道，当一个文件找不到时，就需要到高一级的Level中去查找。假如在<code>Level(n)</code>中没找到，但是在<code>Level(n+1)</code>中找到了，就认为<code>Level(n)</code>有一次未命中。容易发现如果未命中次数多了，就说明Level N和Level N+1<br> 的文件overlap很厉害，这就需要通过一次Major Compaction来解决这个问题。</li></ol><h2 id="DBImpl类"><a href="#DBImpl类" class="headerlink" title="DBImpl类"></a>DBImpl类</h2><p>LevelDB通过<code>class DB</code>对外暴露C++接口，这个<code>DB</code>的实现就是<code>DBImpl</code>。</p><h2 id="DBImpl-BackgroundCall"><a href="#DBImpl-BackgroundCall" class="headerlink" title="DBImpl::BackgroundCall"></a>DBImpl::BackgroundCall</h2><p>BackgroundCall是在后台线程中执行的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>MakeRoomForWrite</code>函数会在<code>background_work_finished_signal_</code>等待Compaction结束。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-MaybeScheduleCompaction"><a href="#DBImpl-MaybeScheduleCompaction" class="headerlink" title="DBImpl::MaybeScheduleCompaction"></a>DBImpl::MaybeScheduleCompaction</h2><p>函数<code>MaybeScheduleCompaction</code>决定是否进行Compaction。<br>这里需要加锁，不然可能会导致开两个后台进程，而LevelDB只允许一个后台进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PosixEnv-Schedule"><a href="#PosixEnv-Schedule" class="headerlink" title="PosixEnv::Schedule"></a>PosixEnv::Schedule</h3><p>这里的<code>env_</code>的实现实际上是一个<code>PosixEnv</code>。<br>我们查看源码，原来这个后台进程只有一个<code>started_background_thread_</code>，一开始先检查它是否存在，如果不存在，就创建一个，然后detach掉。<br>接下来就是一个生产者消费者模式。不过有点奇怪，是先Signal，再入队，不应该先修改条件，再Signal么。<br>我在<a href="/2017/12/28/Concurrency-Programming-Compare/">文章</a>中提过<a href="http://www.cppblog.com/Solstice/archive/2015/10/30/203094.html" target="_blank" rel="noopener">陈硕大佬的一篇博客</a>，在CV语境中，<a href="https://gist.github.com/chenshuo/6430925" target="_blank" rel="noopener">先Signal，再设置条件flag(代码里面的Case 6)</a>也是可以的，但只限于单waiter使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::Schedule(</span><br><span class="line">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg) &#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.detach();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面放一下消费者的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::BackgroundThreadMain() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixEnv::PosixEnv()</span><br><span class="line">    : background_work_cv_(&amp;background_work_mutex_),</span><br><span class="line">      started_background_thread_(<span class="literal">false</span>),</span><br><span class="line">      mmap_limiter_(MaxMmaps()),</span><br><span class="line">      fd_limiter_(MaxOpenFiles()) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="NeedsCompaction"><a href="#NeedsCompaction" class="headerlink" title="NeedsCompaction"></a>NeedsCompaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Compaction类"><a href="#Compaction类" class="headerlink" title="Compaction类"></a>Compaction类</h2><p>定义在version_set.h文件里面。</p><h3 id="主要成员和成员函数"><a href="#主要成员和成员函数" class="headerlink" title="主要成员和成员函数"></a>主要成员和成员函数</h3><ol><li><code>std::vector&lt;FileMetaData*&gt; inputs_[2];</code><br> 表示这个Compaction涉及的两个level的文件，也就是输入。<br> 其中level层是<code>inputs_[0]</code>。level + 1层是<code>inputs_[1]</code>，称为parents。</li><li><code>std::vector&lt;FileMetaData*&gt; grandparents_;</code><br> level + 2层的文件，通常称为grandparents。</li><li><code>int level() const { return level_; }</code><br> 我们将<code>level_</code>和<code>level_+1</code>层进行压缩。</li><li><code>int num_input_files(int which) const</code></li><li><code>bool IsTrivialMove() const;</code><br> 是否可以直接移动，而不涉及merge或者split操作。</li><li><code>bool ShouldStopBefore(const Slice&amp; internal_key);</code></li><li><code>VersionEdit* edit() { return &amp;edit_; }</code>/<code>edit_</code><br> 这个应该很好理解，Compaction肯定会有文件增删，即使是移动，也是跨层的。所以这里需要一个<code>VersionEdit</code>来描述。</li></ol><h3 id="IsTrivialMove"><a href="#IsTrivialMove" class="headerlink" title="IsTrivialMove"></a>IsTrivialMove</h3><p>这个函数用来判断在Major Compaction的时候能不能直接移动老的文件到下面一层，而不归并生成新的文件，条件有三个：</p><ol><li>level层只有一个<br> 【Q】疑问：如果level层有多个，level+1层没有，那么我直接移动到下面一层也是安全的？那么禁止这么做的目的是什么？<br> 检查对<code>GetOverlappingInputs</code>的分析，发现可能是不安全的。如果说Level0的某个文件<code>f</code>和Level1的文件有Overlap，那么就必须要扫描整个Level0层的所有文件，将与<code>f</code>有Overlap的文件都要移到下一层。</li><li>level + 1层没有<br> 这个原因应该好理解，如果level+1层有，那么我们就得比较和这个文件有没有Overlap。</li><li>和level + 2层的overlap没有超过阈值(实际上是20M)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Compaction::IsTrivialMove() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-BackgroundCompaction"><a href="#DBImpl-BackgroundCompaction" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>这个过程是Compaction的主过程，需要全程持锁。</p><h3 id="Minor"><a href="#Minor" class="headerlink" title="Minor"></a>Minor</h3><p>我们首先需要去<code>CompactMemTable</code>，也就是Minor Compaction。这个肯定是优先级更高的，因为我们只有两个Memtable，所以我们肯定想把Immutable Memtable快速腾空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Major"><a href="#Major" class="headerlink" title="Major"></a>Major</h3><p>详见Major Compaction章节</p><h1 id="Minor-Compaction流程"><a href="#Minor-Compaction流程" class="headerlink" title="Minor Compaction流程"></a>Minor Compaction流程</h1><h2 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h2><p>主要流程三部分：</p><ol><li>WriteLevel0Table<ol><li>将Immutable Memtable生成SSTable文件<br> 这个文件的基本信息写到<code>FileMetaData</code>里面，并在最后写入<code>VersionEdit</code>。<br> 注意，在Recover的过程中，这里其实也可以传入Memtable。</li><li>计算添加到哪一层<br> 这个文件未必会放到Level0，可能会直接放到Level1甚至Level2，具体由<code>kMaxMemCompactLevel</code>控制。</li><li>将上面说的<code>FileMetaData</code>写入VersionEdit<br> 因此这个函数的实际返回是传入的<code>VersionEdit* edit</code>。</li></ol></li><li>LogAndApply<br> 用我们得到的<code>VersionEdit</code>，去更新数据库状态，并记录。</li><li>RemoveObsoleteFiles<br> 重置Immutable Memtable。<br> 删除无用文件。主要包括<code>kLogFile</code>/<code>kLogFile</code>/<code>kTableFile</code>等。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::CompactMemTable() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，就是要把<code>edit</code>应用到当前的VersionSet上。<br>【Q】<code>SetPrevLogNumber</code>是啥意思？为啥要设置为0呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h2><p>在前文中，已经介绍过了<code>WriteLevel0Table</code>的作用，下面看实现。</p><p>首先，我们计算出一个<code>NewFileNumber</code>，也就是落盘时体现的文件名。关于这个函数，我们之前已经介绍过了，体现在诸如<code>MANIFEST-xxxxx</code>或者<code>yyyyy.log</code>这里的序号。</p><p><code>pending_outputs_</code>中保存了所有正在Compact的SSTable文件，这些文件不能被删除。这引发了我两个问题：</p><ol><li>什么时候会删除？<br> 在<code>RemoveObsoleteFiles</code>里面，马上就能看到了，不急不急</li><li>为什么在BuildTable之后就可以删除了？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,</span><br><span class="line">                                Version* base) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，<code>BuildTable</code>创建一个<code>TableBuilder</code>写入数据。值得注意的是，这里并没有加锁。我之前认为这是因为<code>BuildTable</code>里面会自带加锁，但是检查代码并没有。这可能是因为Compaction是单独的线程，诸如生成并写SSTable的过程是可以单独提出来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>新生成的文件未必会放到Level0，可能会直接放到Level1。例如，如果新的SSTable文件和Level1中的文件没有重叠，那么就<strong>有可能</strong>被放到Level1，具体还需要查看Level2和新SSTable的重叠情况。因此<code>PickLevelForMemTableOutput</code>会生成一个level，表示放到哪一层。<br>下面的<code>edit-&gt;AddFile</code>就是将这个SSTable加到当前的VersionEdit中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>env_</code>实际上是封装了文件系统等操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RemoveObsoleteFiles"><a href="#RemoveObsoleteFiles" class="headerlink" title="RemoveObsoleteFiles"></a>RemoveObsoleteFiles</h2><p>搞清楚几个问题：</p><ol><li>清理文件的范围？看<code>env_-&gt;GetChildren</code>的实现，应该是所有这个db下的文件。</li><li>清理文件的类型？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::RemoveObsoleteFiles() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don't know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;live);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  env_-&gt;GetChildren(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files_to_delete;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;LogNumber()) ||</span><br><span class="line">                  (number == versions_-&gt;PrevLogNumber()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations'</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;ManifestFileNumber());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into "live"</span></span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.push_back(<span class="built_in">std</span>::move(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;Evict(number);</span><br><span class="line">        &#125;</span><br><span class="line">        Log(options_.info_log, <span class="string">"Delete type=%d #%lld\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;RemoveFile(dbname_ + <span class="string">"/"</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Major-Compaction流程"><a href="#Major-Compaction流程" class="headerlink" title="Major Compaction流程"></a>Major Compaction流程</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><p>在开始研究Major Compaction前，我们主动思考这个问题</p><ol><li><p>对于Level0里面的文件，是不是可以直接和Level1中的文件Merge？<br> 答案是不行的，见<code>GetOverlappingInputs</code>的论述。</p></li><li><p>如果level中的某个文件的key的range过大，它可能和level+1层的很多文件有重合，这样的compaction写放大很重，如何解决这个问题？<br> 首先，这也是为什么LevelDB要分成很多层的原因，在Merge的时候，最多和下一层中的所有文件Overlap，写放大是可控的。<br> 其次，在Compact的时候，LevelDB一直关注和level+2层的key的重叠情是否超过一定量，即<code>MaxGrandParentOverlapBytes</code>函数。</p><ul><li>在<code>ShouldStopBefore</code>判断是否要结束当前SSTable写入，新开文件的时候，考虑当前文件和level+2的Overlap，如果过了，就新开文件。</li><li>在<code>IsTrivialMove</code>判断是否可以直接移动文件到下层的时候，考虑要移动的文件和level+2层的Overlap，如果过了，就不能移动。</li><li>在<code>PickLevelForMemTableOutput</code>选择Minor Compaction的层时，考虑这个Immutable Memtable的Overlap，如果过了，就不能放在这一层。</li></ul></li><li><p>从level到level+1的Compaction会对level+2产生什么影响？</p></li><li><p><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">LevelDB</a>中多个不相干的合并是可以并发进行的，这个的实现是怎样的？<br> 需要注意，Level0文件是彼此Overlap的，所以是相干的。<br> 【Q】那么当一个Major Compaction开始的时候，是如何判定是否相干，如果不相干就不Compact的呢？从LevelDB的代码来看，只有一个后台线程进行Compact操作，所以我认为虽然在设计上LSM树是允许并行Compact的，但是LevelDB并没有实现，但RocksDB肯定是实现的。</p></li><li><p>LevelDB中，每个user key在一层中是不是只会出现一次？<br> 大多数情况是的，有两个例外。<br> 首先，Level0是Overlap的，可能有多个。<br> 其次，如果使用了Snapshot，那么在下层可能也会有user key相同，但是sequence不同的。见<code>AddBoundaryInputs</code>的论述。</p></li><li><p>我们往Manifest文件里面写了什么？</p></li><li><p>LevelDB有容量限制么？<br> <a href="https://stackoverflow.com/questions/31742460/is-there-record-number-limit-in-leveldb" target="_blank" rel="noopener">应该是没有的，但是当最下面一层变得特别大之后，Compaction的开销会很大</a>。</p></li><li><p>LevelDB到底是限制的每一层的文件数量还是大小？<br> 【Q】如果限制的是总大小，如果保证生成的SSTable的大小是大致相同的？<br> 对于Major Compaction来说，是在<code>DoCompactionWork</code>里面通过下面的代码来判断的，也就是说当文件大小达到一定规模后，就会产生新的文件了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">   compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br></pre></td></tr></table></figure><p> 这个调用最后会转到<code>options-&gt;max_file_size</code>上。</p></li><li><p>LevelDB每一层的文件数量有限制么？<br> 首先Level0肯定有，大家说是4个么？我觉得不是。参考下面的代码，4只是表示有4个文件就开始Level0的Compaction。当文件数达到12个，才是上限，这个时候就要停止写了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Soft limit on number of level-0 files.  We slow down writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_SlowdownWritesTrigger = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of level-0 files.  We stop writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_StopWritesTrigger = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>LevelDB底层SSTable中的数据永无出头之日么？<br> 怎么可能，只要数据被修改，那么就会先到Memtable里面。</p></li><li><p>Compaction是如何删除文件的？<br> 注意，即使遍历到有删除标记的，并且这个删除标记的序列号最大。我们也不应该尝试删除，至少要检查下面的层有没有。详见DoCompactionWork</p></li></ol><h2 id="DBImpl-BackgroundCompaction-1"><a href="#DBImpl-BackgroundCompaction-1" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>下面是对Major Compaction的处理。</p><h3 id="计算Compaction对象"><a href="#计算Compaction对象" class="headerlink" title="计算Compaction对象"></a>计算Compaction对象</h3><p>首先，我们要处理Manual Compaction的情况。如果<code>manual_compaction_</code>不是null，就触发Manual Compaction。我没看到非测试的代码里面有设置<code>manual_compaction_</code>的，但是<code>leveldb_compact_range</code>这个api会显示调用<code>CompactRange</code>，并且<code>DB</code>这个接口中也有<code>CompactRange</code>方法，也就是说，LevelDB对外暴露这个方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>其次，我们调用<code>PickCompaction</code>处理size compaction和seek compaction的情况。<code>PickCompaction</code>会返回当前要Compact的文件，如果返回null，就啥事都不做。对于<code>PickCompaction</code>而言，如果既没有size compaction，又没有seek compaction，返回null。</p><p><strong>这个过程是持锁的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 前面是对Minor Compaction的处理</span></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="根据Compaction对象进行Compact操作"><a href="#根据Compaction对象进行Compact操作" class="headerlink" title="根据Compaction对象进行Compact操作"></a>根据Compaction对象进行Compact操作</h3><p>经过上面的代码，我们就得到了一个<code>Compaction* c</code>对象。<br>如果之前<code>PickCompaction</code>没给出这个<code>c</code>，那么就说明这一次不要Compact。<br>如果满足<code>IsTrivialMove</code>条件，就可以不生成新的文件，直接将原文件移动到下一层。<br>对于Trivial的情况我们直接更新<code>c-&gt;edit()</code>，不走<code>InstallCompactionResults</code>的逻辑了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Nothing to do</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">  <span class="comment">// Move file to next level</span></span><br><span class="line">  assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">  FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">  c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                     f-&gt;largest);</span><br><span class="line">  status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">      status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>如果不满足<code>IsTrivialMove</code>条件，就是一般情况，由<code>DoCompactionWork</code>处理。<br><code>DBImpl::CompactionState</code>这个类又封装了<code>Compaction</code>，这是因为要处理两个Level之间的合并，所以要加一些额外的字段。<br>然后我们要<code>CleanupCompaction</code>，这个除了清空compact对象，还需要根据<code>compact-&gt;outputs</code>，找到<code>pending_outputs_</code>里面对应的文件，并移除出<code>pending_outputs_</code>。我们知道<code>compact-&gt;outputs</code>记录了每个输出文件的元信息，而<code>pending_outputs_</code>记录了正在compact的文件，我们compact结束，就把这些文件移出去。在Major Compaction中，文件是在<code>DoCompactionWork -&gt; OpenCompactionOutputFile</code>中被加入<code>pending_outputs_</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">  status = DoCompactionWork(compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  CleanupCompaction(compact);</span><br><span class="line">  c-&gt;ReleaseInputs();</span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure><h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>如果是Manual的，需要清空Manual状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;done) &#123;</span><br><span class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">      <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">      m-&gt;tmp_storage = manual_end;</span><br><span class="line">      m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">    &#125;</span><br><span class="line">    manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-PickCompaction"><a href="#Version-PickCompaction" class="headerlink" title="Version::PickCompaction"></a>Version::PickCompaction</h2><p>size compaction的优先级是高于seek compaction的。<br>遍历<code>current_-&gt;compaction_level_</code>这一层的所有文件，找到第一个largest大于<code>compact_pointer_[level]</code>的文件，放到<code>Compaction* c</code>的<code>inputs_[0]</code>中。<br>如果一轮循环下来没找到，说明所有的文件的largest都小于<code>compact_pointer_[level]</code>，也就是这一层所有的key都小于<code>compact_pointer_[level]</code>，那就把第一个文件放进去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Compaction* VersionSet::PickCompaction() &#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于seek compaction，把要Compact的那个文件加到<code>c-&gt;inputs_[0]</code>就行，逻辑很简单。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">  level = current_-&gt;file_to_compact_level_;</span><br><span class="line">  c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">  c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Level0，有个特别的处理，这个参考<code>GetOverlappingInputs</code>函数的说明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;input_version_ = current_;</span><br><span class="line">c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们已经得到了<code>c-&gt;inputs_[0]</code>。<strong>除了<code>c-&gt;inputs_[0]</code>的情况，否则<code>c-&gt;inputs_[0]</code>里面都只有一个文件</strong>。<br>通过<code>SetupOtherInputs</code>可以计算<code>c-&gt;inputs_[1]</code>，也就是level+1层涉及哪些文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Version-SetupOtherInputs"><a href="#Version-SetupOtherInputs" class="headerlink" title="Version::SetupOtherInputs"></a>Version::SetupOtherInputs</h2><p><code>SetupOtherInputs</code>计算在Compaction时，level+1层涉及哪些文件。在这个函数之后，我们就得到了正确的<code>c-&gt;inputs_</code>数组、<code>c-&gt;grandparents_</code>字段，以及<code>compact_pointer_</code>字段。在这个函数之后，<code>PickCompaction</code>就结束了，<code>BackgroundCompaction</code>会执行后面的流程，也就是<code>DoCompactionWork</code>。<br>基本的思想是：所有和level层有重叠的level+1层文件都要参与Compact。得到这些文件后，反过来看下，利用这些level+1层的文件，能不能Compact更多level层的文件？<br>这个函数被<code>CompactRange</code>和<code>PickCompaction</code>调用，也就是所有的Major Compaction逻辑都会走到这里。</p><h3 id="GetRange和GetRange2"><a href="#GetRange和GetRange2" class="headerlink" title="GetRange和GetRange2"></a>GetRange和GetRange2</h3><p>GetRange计算<code>inputs_[0]</code>/<code>inputs_[1]</code>的区间。<br>GetRange2计算<code>inputs_[0]</code>和<code>inputs_[1]</code>的区间。<br>GetRange很简单，遍历每一个文件，然后更新smallest和largest，这里注意都需要<code>icmp_.Compare</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span><br><span class="line">                          InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  assert(!inputs.empty());</span><br><span class="line">  smallest-&gt;Clear();</span><br><span class="line">  largest-&gt;Clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</span><br><span class="line">    FileMetaData* f = inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      *smallest = f-&gt;smallest;</span><br><span class="line">      *largest = f-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *smallest = f-&gt;smallest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *largest = f-&gt;largest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>GetRange2很简单，就直接合并<code>inputs_[0]</code>和<code>inputs_[1]</code>的内容到一个vector里面，然后调用GetRange。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span><br><span class="line">                           InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; all = inputs1;</span><br><span class="line">  all.insert(all.end(), inputs2.begin(), inputs2.end());</span><br><span class="line">  GetRange(all, smallest, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AddBoundaryInputs"><a href="#AddBoundaryInputs" class="headerlink" title="AddBoundaryInputs"></a>AddBoundaryInputs</h3><p>AddBoundaryInputs是一个很重要的函数，但只有很少的Blog能讲明白这个函数的来龙去脉。</p><p>翻译一下<code>AddBoundaryInputs</code>这个函数的注释。他提取出<code>compaction_files</code>里面最大的文件b1，在这里是<code>c-&gt;inputs_[0]</code>里面最大的文件。<br>然后在<code>level_files</code>里面找到一个b2，满足b1和b2的user key是相等的，这样的b2称为boundary file。我们需要将这个b2加入到<code>compaction_files</code>里面，并且继续找上界。<br>如果有两个块（应该就是SSTable）b1和b2，他们的范围分别是<code>(l1, u1)</code>和<code>(l2, u2)</code>，如果我们只Compact b1，不Compact b2，那么在读取的时候就会出错。因为它只会返回b2的结果，而永远不会返回b1的结果，因为b1在b2上层了。与此同时，我们需要注意到b2的结果可能还是一个较旧的数据，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span></span></span><br></pre></td></tr></table></figure><p>【Q】看起来，这个函数做的是和<code>GetOverlappingInputs</code>一样的事情，他们的区别是什么呢？首先，<code>GetOverlappingInputs</code>的初心不是扩展边界而是计算某一层和某个range重合的文件，只是对Level0要特殊处理一下。其次，<a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">这篇文章</a>中进行了解释。</p><p>如下图所示，两个sstable中，出现了user key相同（都为key2）但是Sequence Number不同的两个Internal Key。<br><img src="/img/leveldb/compaction/AddBoundaryInputsProblem.png"></p><p>所以可以看到<code>GetOverlappingInputs</code>的特殊处理关注的是Level0上某一个要Compact的文件中的所有key是否还会出现在其他的SSTable文件中。而<code>AddBoundaryInputs</code>关注的是某个Key的其他版本是否还会出现在其他的SSTable中。</p><p>【Q】这里引发了第二个疑问，为什么同一层中会出现两个相同user key的Key呢？我觉得这个可能是因为这个Key出现在两个SSTable的边界上，所以这个函数叫<code>AddBoundaryInputs</code>吧。</p><p>仔细回顾一下<code>DoCompactionWork</code>的实现，似乎是可能没处理完一个Key，就<code>ShouldStopBefore</code>了的，但即使这样，后面的文件里面也不会再写有关这个user key的内容了。那么究竟在什么情况下会发生这种情况呢？根据<a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">这篇文章</a>中指出Snapshot机制会导致“同一层中会出现两个相同user key的Key”这个问题。</p><p>【Q】这里引发了第三个疑问，出现了两个user key，会不会影响读取呢？实际上只要位于同一层就不影响，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。我们的查找方式允许我们每一次都找到b1里面的值。</p><p>特别值得注意的是，这个问题关系到<a href="https://github.com/google/leveldb/issues/320" target="_blank" rel="noopener">Issue 320</a>和<a href="https://github.com/google/leveldb/pull/339" target="_blank" rel="noopener">PR 339</a>。<code>AddBoundaryInputs</code>函数也是在那个时候引进的。不过值得注意的是，这个patch在2016年就提了，但是2019年才被合进去。</p><h3 id="SetupOtherInputs主体"><a href="#SetupOtherInputs主体" class="headerlink" title="SetupOtherInputs主体"></a>SetupOtherInputs主体</h3><p>首先<code>AddBoundaryInputs</code>扩充一下<code>c-&gt;inputs_[0]</code>。<br>然后获得Level N的range。<br>然后计算Level N+1和Level N重叠的SSTable文件，并放入<code>c-&gt;inputs_[1]</code>。<br>最后，计算Level N和Level N+1合并起来的range。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::SetupOtherInputs(Compaction* c) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure><p>下面的的代码，就是之前说的优化。<br>如果<code>c-&gt;inputs_[1]</code>不为空，也就是Level N+1层有需要进行Merge的文件。我们将level中和所有和<code>[all_start,all_limit]</code>重叠的文件加到expoand0里面，并调用<code>AddBoundaryInputs</code>处理边界。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">  <span class="keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[<span class="number">0</span>].size() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br><span class="line">    <span class="keyword">if</span> (expanded1.size() == c-&gt;inputs_[<span class="number">1</span>].size()) &#123;</span><br><span class="line">      Log(options_-&gt;info_log,</span><br><span class="line">          <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">          level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].size()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].size()),</span><br><span class="line">          <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.size()),</span><br><span class="line">          <span class="keyword">int</span>(expanded1.size()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">      smallest = new_start;</span><br><span class="line">      largest = new_limit;</span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">      c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">      GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，设置一下<code>c-&gt;grandparents_</code>这个字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line"><span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line"><span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                 &amp;c-&gt;grandparents_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记录下一轮的压缩起始文件，也就是设置<code>compact_pointer_</code>。我们在这里立即更新，而不是等到VersionEdit被Apply的时候更新，这样当Compaction失败后，我们能下次能尝试一个不同的key range。</p><ol><li>【Q】什么是压缩起始文件？<br> 查看<code>PickCompaction</code>函数，它会找到largest大于<code>compact_pointer_[level]</code>后的第一个文件。<br> 可以发现，其实每一次要Compaction的文件就是通过<code>compact_pointer_</code>指定的。</li><li>【Q】在这之后，Compaction会因为什么失败？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-CompactionState"><a href="#DBImpl-CompactionState" class="headerlink" title="DBImpl::CompactionState"></a>DBImpl::CompactionState</h2><ol><li><code>SequenceNumber smallest_snapshot;</code><br> 小于<code>smallest_snapshot</code>的Sequence Number是不重要的，因为我们不会为提供<code>smallest_snapshot</code>的snapshot。<br> 所以，如果我们看到Sequence Number小于等于<code>smallest_snapshot</code>的某个<code>S</code>，就可以丢弃小于<code>S</code>的这个key的其他版本。<br> 【Q】这里是不是在说，如果只有S这个独苗，那还是要写进去的？</li><li><code>std::vector&lt;Output&gt; outputs;</code></li><li><code>Output* current_output() { return &amp;outputs[outputs.size() - 1]; }</code><br> 保存每个输出文件的元信息。例如smallest和largest。</li><li><code>WritableFile* outfile;</code><br> Major Compaction过程中，需要输出到level+1层的文件。注意，可能有多个这样的文件，参考<code>ShouldStopBefore</code>。</li><li><code>TableBuilder* builder;</code></li><li><code>uint64_t total_bytes;</code></li></ol><h2 id="DBImpl-DoCompactionWork"><a href="#DBImpl-DoCompactionWork" class="headerlink" title="DBImpl::DoCompactionWork"></a>DBImpl::DoCompactionWork</h2><p>这个对应了一般情况下的Compact过程，来自<code>BackgroundCompaction</code>的调用。<br>那么这个函数做啥呢，不就是个归并排序么？且慢，我们如何处理同一个user key有不同Sequence Number呢？我们的目标肯定是只保留最新的。<br>其中<code>CompactionState</code>封装了<code>Compaction</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::DoCompactionWork(CompactionState* compact) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这里要assert一下，即要压缩的Level N层是要有文件的。<br>【Q】这个Snapshot啥回事？<br>根据<a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">文章</a>，如果有Snapshot，则保留大于Snapshot SN的所有Record，以及一个小于Snapshot SN的Record中，SN最大的Record。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们执行<code>MakeInputIterator</code>，得到的迭代器可以按照key大小遍历所有冲突文件中的每个KV对。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line">Status status;</span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br></pre></td></tr></table></figure><p>下面这个while循环遍历刚才得到的迭代器<code>input</code>，进行Major Compaction。<br>但是，且慢，每一次我们都需要先检查有没有Immatable Memtable，如果有的话，就需要先执行Minor Compaction。<strong>这也说明了Minor Compaction的优先级更高</strong>。<br>【Q】我们看到了两个原子量的获取：</p><ol><li><code>shutting_down_</code>，采用了Release-Acquire内存模型，保证了一定的并行顺序。<br> 如果线程A Release Store，线程B Acquire Load，那么<a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">线程A中所有在Release前的(atomic或者非atomic)写</a>，对线程B都可见。</li><li><code>memory_order_relaxed</code>，采用了Relaxed内存模型。<br> 只保证读写的原子性，不保证并发时和其他变量的顺序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">  <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      CompactMemTable();</span><br><span class="line">      <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">      background_work_finished_signal_.SignalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检查当前输出文件(应当位于level+1层)是否与level+2层文件有过多冲突，如果是就要完成当前输出文件，并产生新的输出文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Slice key = input-&gt;key();</span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">    compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是判断是不是能<code>drop</code>，也就是和前面计算的<code>compact-&gt;smallest_snapshot</code>比较。<br>正常情况下<code>ParseInternalKey</code>不会失败，我们跳过这个分支</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.clear();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure><p>下面这个if，判断的是<code>current_user_key</code>第一次出现的情况，包括处理完上一个user key，到达下一个user key，或者刚开始处理第一个user key的情况。我们设置<code>last_sequence_for_key</code>为最大，那么就永远不会触发drop。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">    user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// First occurrence of this user key</span></span><br><span class="line">  current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line">  has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们比较Sequence Number，如果<code>last_sequence_for_key</code>都小于<code>compact-&gt;smallest_snapshot</code>了，那么我这个key肯定更小，这是因为<a href="/2021/04/09/leveldb-memtable/">Sequence Number是按照降序排列的</a>。对于这种情况，我们省点事，直接不要了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">  <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">  drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br></pre></td></tr></table></figure><p>下一个判断复杂点，表示对于特定情况下，一个删除操作也是可以丢掉的。<br><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">如果某个删除操作的版本小于快照版本，并且在更高层没有相同的user key，那么这个删除操作及其之前更早的插入操作可以同时丢弃了</a>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">             ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">             compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">    <span class="comment">// For this user key:</span></span><br><span class="line">    <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">    <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">    <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">    <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">    <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">    <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">    drop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_sequence_for_key = ikey.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果drop条件不符合，那么就写入到<code>compact-&gt;current_output()</code>里面，同时更新largest。<br>同时我们关注文件大小，如果超限了，就FinishCompactionOutputFile。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input-&gt;Next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至现在，我们已经遍历完迭代器了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">  status = input-&gt;status();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> input;</span><br><span class="line">input = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>更新状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">    stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line">  stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们加锁。所以其实在遍历<code>input</code>这个迭代器的时候，是没有在加锁的。<br><code>InstallCompactionResults</code>是一个关键过程，它将这次Compaction的内容加入到VersionEdit里面，并且最终调用<code>LogAndApply</code>。内容包括什么呢？增加和删除的文件：</p><ol><li><code>InstallCompactionResults</code>会调用<code>Compaction::AddInputDeletions</code>，需要删除的文件，包括<code>input_[0]</code>和<code>input_[1]</code></li><li>向<code>compact-&gt;compaction-&gt;edit()</code>中添加<code>compact-&gt;outputs</code>中的所有文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/34674504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34674504</a></li><li><a href="https://blog.csdn.net/tmshasha/article/details/47703245" target="_blank" rel="noopener">https://blog.csdn.net/tmshasha/article/details/47703245</a></li><li><a href="https://zhuanlan.zhihu.com/p/51573929" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51573929</a></li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/basic.html</a></li><li><a href="https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/" target="_blank" rel="noopener">https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a></li><li><a href="http://blog.jcix.top/2018-05-11/leveldb_paths/" target="_blank" rel="noopener">http://blog.jcix.top/2018-05-11/leveldb_paths/</a></li><li><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">http://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/46718964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46718964</a></li><li><a href="http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html" target="_blank" rel="noopener">http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a><br> 这是一个DB完整执行过程的表述。</li><li><a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">https://www.ravenxrz.ink/archives/1ba074b9.html</a><br> 介绍了Snapshot</li><li><a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-PickCompaction</a><br> 解释了GetOverlappingInputs的原理</li><li><a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-version</a><br> 解释了Version的实现</li><li><a href="http://lerencao.github.io/posts/lsm-tree-compaction-strategy/" target="_blank" rel="noopener">http://lerencao.github.io/posts/lsm-tree-compaction-strategy/</a></li><li><a href="http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/" target="_blank" rel="noopener">http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/</a><br> 上面两篇文章介绍STCS和LCS</li><li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181498475</a><br> 图解Compact过程</li><li><a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction</a><br> RocksDB对Compaction的讲解</li><li><a href="https://blog.csdn.net/weixin_36145588/article/details/78064777" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36145588/article/details/78064777</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html</a><br> 这位同学解释了AddBoundaryInputs的来源</li><li><a href="http://www.petermao.com/leveldb/leveldb-8-snapshot.html" target="_blank" rel="noopener">http://www.petermao.com/leveldb/leveldb-8-snapshot.html</a><br> 介绍了snapshot机制</li><li><a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60188395</a><br> 带Snapshot的Compaction，以及为什么会导致Issue 320的问题</li><li><a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360345923</a><br> 也讲解了AddBoundaryInputs的来源，并且指出了快照会导致Issue 320的问题。</li><li><a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35343043</a><br> 讲解VersionSet/VersionEdit里面出现的各种文件编号</li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a><br> 版本控制相关</li><li><a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-manifest/</a><br> 有关Manifest文件的深入讨论</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://draveness.me/database-concurrency-control/" target="_blank" rel="noopener">https://draveness.me/database-concurrency-control/</a><br> 同样介绍了MVCC，包括乐观锁和悲观锁机制</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Minor Compaction&lt;br&gt; 对应Memtable到SSTable的过程。&lt;/li&gt;
&lt;li&gt;Major Compaction&lt;br&gt; 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。&lt;br&gt; Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。&lt;/p&gt;
&lt;p&gt;同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LevelDB之SSTable实现</title>
    <link href="http://www.calvinneo.com/2021/04/12/leveldb-sstable/"/>
    <id>http://www.calvinneo.com/2021/04/12/leveldb-sstable/</id>
    <published>2021-04-12T15:09:06.000Z</published>
    <updated>2021-08-18T07:28:44.617Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍LevelDB的SSTable相关功能。<br>SSTable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。Level0的SSTable是没有经过归并的，各个Key可能互相重叠。经过Compaction达到Level1之后，就是有序的了。</p><a id="more"></a><h1 id="SSTable格式"><a href="#SSTable格式" class="headerlink" title="SSTable格式"></a>SSTable格式</h1><p>SSTable体现在后缀为.sst或者.ldb的文件。<br>其实在<a href="https://github.com/google/leveldb/blob/master/doc/table_format.md" target="_blank" rel="noopener">官方文档</a>中，对SSTable的格式已经有了介绍。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">beginning_of_file&gt;</span></span><br><span class="line"><span class="keyword">[data </span><span class="keyword">block </span><span class="number">1</span>]</span><br><span class="line">[<span class="meta">data</span> <span class="keyword">block </span><span class="number">2</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">[<span class="meta">data</span> <span class="keyword">block </span>N]</span><br><span class="line">[meta <span class="keyword">block </span><span class="number">1</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">[meta <span class="keyword">block </span>K]</span><br><span class="line">[metaindex <span class="keyword">block]</span></span><br><span class="line"><span class="keyword">[index </span><span class="keyword">block]</span></span><br><span class="line"><span class="keyword">[Footer] </span>       (fixed size<span class="comment">; starts at file_size - sizeof(Footer))</span></span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><ol><li><p>data block<br> 放KV对，是有序的（doc里面说的）。因此在查询SSTable文件的时候，也可以二分。【待确认】<br> 关于Block的组织，我们将专门讨论。</p></li><li><p>meta block<br> 用来快速定位key是否在data block中</p></li><li><p>metaindex block<br> 每个metaindex block一条记录。其中K是meta block的名字，V是指向这个meta block的BlockHandle。<br> BlockHandle类似于指针，具有下面的结构。容易看到，这里面也用了VarInt结构。</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">offset:</span>   varint64</span><br><span class="line"><span class="symbol">size:</span>     varint64</span><br></pre></td></tr></table></figure><p> 有两种meta block类型，filter和stats:</p><ol><li>如果在数据库启动时指定了某个<code>FilterPolicy</code>，就会创建一个filter block。</li><li>统计信息</li></ol></li><li><p>index block<br> 每个data block一条entry。这个index block entry的<code>.key()</code><strong>大于等于</strong>指向的data block最后一个K【性质1】，但是<strong>严格小于</strong>下一个data block的第一个K【性质2】。<br> 因此，我们可以通过和index block比较来快速定位data block。</p></li><li><p>footer<br> 包含：</p><ol><li>metaindex handle</li><li>index handle</li><li>padding</li><li>magic number</li></ol></li></ol><h1 id="Block实现"><a href="#Block实现" class="headerlink" title="Block实现"></a>Block实现</h1><p>SST的构建主要集中在<code>table_builder.h/cc</code>和<code>block_builder.h/cc</code>中。<br>SST的读取主要集中在<code>table.h/cc</code>和<code>block.h/cc</code>中。<br>从前面可以看到，SSTable主要有两层结构，Table(SSTable)和Block(data/index等)。<br>Table由多个Block构成，所以从Block开始分析。</p><h2 id="BlockBuilder-Block原理"><a href="#BlockBuilder-Block原理" class="headerlink" title="BlockBuilder/Block原理"></a>BlockBuilder/Block原理</h2><p>BlockBuilder负责生成诸如data block、index block等所有block。<br>Block对象负责读取这些block。</p><h3 id="共享前缀"><a href="#共享前缀" class="headerlink" title="共享前缀"></a>共享前缀</h3><p>因为BlockBuilder是有序的，所以可以使用共享前缀来节约空间，我们比较下面两种方式：</p><ol><li><p>普通</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello William</span></span><br></pre></td></tr></table></figure></li><li><p>共享</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">       illiam</span></span><br></pre></td></tr></table></figure></li></ol><p>Block的构造如下图所示<br><img src="/img/leveldb/sstable/suf.png"></p><p>其中：</p><ol><li>shared_bytes<br> Key的共享前缀的长度，这里的共享指的是上一个entry</li><li>key_delta/unshared_bytes<br> Key共享前缀后的剩余串和其长度</li><li>value/value_length<br> 值的串和其长度</li></ol><p>那么如何读呢？</p><ol><li><p>最坏状况，我们需要读到第一个Entry，考虑下面的Key</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">ab</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li><li><p>最好状况，我们读当前的就行</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></li></ol><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>可见共享前缀会给读带来困难，因此又引入restart机制，即每隔<code>block_restart_interval</code>之后会去存储一次完整的key，对应的entry的位置称为restart point。在block中，会存储下所有的restart point。<br>因为数字存储是有序的，所以我们能通过二分restart point来加速读取，具体代码在<code>Block::Iter</code>中。读取需求一般是给定target，要求找到第一个K大于等于target的entry。因此我们可以得到如下二分</p><ol><li><code>mid &lt; target</code><br> 则搜索<code>[mid, right]</code></li><li><code>mid &gt;= target</code><br> 搜索<code>[left, mid-1]</code><br>因为这是一个TTT…F/T的二分，所以我们要令<code>mid = (left + right + 1)/2</code></li></ol><h3 id="filter-block"><a href="#filter-block" class="headerlink" title="filter block"></a>filter block</h3><p>在每个data block内部，借助于二分restart可以实现$log(n)$复杂度的查询，那么能在data block之间二分么？</p><p>可以通过filter block来判断某个key是否属于该data block，实现是bloom filter。</p><h2 id="BlockBuilder实现"><a href="#BlockBuilder实现" class="headerlink" title="BlockBuilder实现"></a>BlockBuilder实现</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><code>void Add(const Slice&amp; key, const Slice&amp; value);</code><br> 每一次Add的Key，必须是有序的，从小到大的。</li><li><code>Slice Finish();</code></li><li><code>void Reset();</code></li></ol><h3 id="BlockBuilder-Add"><a href="#BlockBuilder-Add" class="headerlink" title="BlockBuilder::Add"></a>BlockBuilder::Add</h3><p>首先是三个assert：</p><ol><li>第一个很好理解，如果<code>finished_</code>，相当于已经调用了Finish或者Abandon等方法。</li><li><code>block_restart_interval</code>表示每过多少个key就要设置一个restarts。设置完之后，<code>counter_</code>会被重置为0，所以这个不等式是成立的。</li><li>最后一个是有序性检验，要不是空的，要不新来的<code>key</code>要大于老的<code>last_key_piece</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlockBuilder::Add(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  assert(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面判断要不要restart：</p><ol><li>如果不要，和前一个key即<code>last_key_</code>比较，算出来能share多少长度。</li><li>如果要，就restart。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line">  <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">  <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">    shared++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Restart compression</span></span><br><span class="line">  restarts_.push_back(buffer_.size());</span><br><span class="line">  counter_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</span><br></pre></td></tr></table></figure></li></ol><p>下面就是往<code>buffer_</code>里面写数据了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></span><br><span class="line">PutVarint32(&amp;buffer_, shared);</span><br><span class="line">PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">PutVarint32(&amp;buffer_, value.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">buffer_.append(value.data(), value.size());</span><br></pre></td></tr></table></figure><p>下面这个优化点也很有趣，首先<code>last_key_</code>保存的是一个完整的key。但是我们可以复用之前一个key的shared部分，这个是安全的。接着我们把non shared部分append上去。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockBuilder-Finish"><a href="#BlockBuilder-Finish" class="headerlink" title="BlockBuilder::Finish"></a>BlockBuilder::Finish</h3><p>为啥<code>restarts_</code>不用VarInt存呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Slice BlockBuilder::Finish() &#123;</span><br><span class="line">  <span class="comment">// Append restart array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  PutFixed32(&amp;buffer_, restarts_.size());</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Slice(buffer_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Block实现-1"><a href="#Block实现-1" class="headerlink" title="Block实现"></a>Block实现</h2><ol><li><p><code>uint32_t NumRestarts() const;</code><br> 之前了解过block的结构，在Block的最后，是restart点的个数。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> Block::NumRestarts() <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(size_ &gt;= <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  <span class="keyword">return</span> DecodeFixed32(data_ + size_ - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const char* data_;</code>/<code>size_t size_</code>;<br> 也就是这个Block的指针和长度。</p></li><li><p><code>uint32_t restart_offset_;</code><br> 表示restart的开始位置</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>bool owned_;</code><br> 取决于构造函数传入的<code>BlockContents</code>的<code>owned_</code>字段。</p></li></ol><h3 id="Block-Iter"><a href="#Block-Iter" class="headerlink" title="Block::Iter"></a>Block::Iter</h3><h4 id="Seek"><a href="#Seek" class="headerlink" title="Seek"></a>Seek</h4><p>这个函数是一个二分的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> override </span>&#123;</span><br><span class="line">  <span class="comment">// Binary search in restart array to find the last restart point</span></span><br><span class="line">  <span class="comment">// with a key &lt; target</span></span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> current_key_compare = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Valid()) &#123;</span><br><span class="line">    <span class="comment">// If we're already scanning, use the current position as a starting</span></span><br><span class="line">    <span class="comment">// point. This is beneficial if the key we're seeking to is ahead of the</span></span><br><span class="line">    <span class="comment">// current position.</span></span><br><span class="line">    current_key_compare = Compare(key_, target);</span><br><span class="line">    <span class="keyword">if</span> (current_key_compare &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// key_ is smaller than target</span></span><br><span class="line">      left = restart_index_;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_key_compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      right = restart_index_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We're seeking to the key we're already at.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> region_offset = GetRestartPoint(mid);</span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr =</span><br><span class="line">        DecodeEntry(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                    &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">      CorruptionError();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (Compare(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at "mid" is smaller than "target".  Therefore all</span></span><br><span class="line">      <span class="comment">// blocks before "mid" are uninteresting.</span></span><br><span class="line">      left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at "mid" is &gt;= "target".  Therefore all blocks at or</span></span><br><span class="line">      <span class="comment">// after "mid" are uninteresting.</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might be able to use our current position within the restart block.</span></span><br><span class="line">  <span class="comment">// This is true if we determined the key we desire is in the current block</span></span><br><span class="line">  <span class="comment">// and is after than the current key.</span></span><br><span class="line">  assert(current_key_compare == <span class="number">0</span> || Valid());</span><br><span class="line">  <span class="keyword">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!skip_seek) &#123;</span><br><span class="line">    SeekToRestartPoint(left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ParseNextKey()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Compare(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Table实现"><a href="#Table实现" class="headerlink" title="Table实现"></a>Table实现</h1><h2 id="TableBuilder"><a href="#TableBuilder" class="headerlink" title="TableBuilder"></a>TableBuilder</h2><p>对于Add/Flush/Finish/Abandon，此时Adandon和Finish不能已经被调用。</p><ol><li><code>Status ChangeOptions(const Options&amp; options);</code><br> 修改option，但是只有某些可以在构建之后被修改。对于那些不能修改的，会报错。</li><li><code>void Add(const Slice&amp; key, const Slice&amp; value);</code><br> 增加一个KV对。<br> key is after any previously added key according to comparator，往TableBuilder里面加KV，必须是有序的？</li><li><code>void Flush();</code><br> 刷盘，一般不直接用。主要被用来保证两个相邻的Entry不会在同一个data block中。</li><li><code>Status status() const;</code></li><li><code>Status Finish();</code><br> 结束当前表的构建。</li><li><code>void Abandon();</code><br> 表示需要丢弃当前缓存内容，并且结束表的构建。</li><li><code>uint64_t NumEntries() const;</code><br> Add了多少次，实际上返回的是<code>TableBuilder::Rep</code>里面的<code>num_entries</code></li><li><code>uint64_t FileSize() const;</code></li><li><code>void WriteBlock(BlockBuilder* block, BlockHandle* handle);</code></li><li><code>void WriteRawBlock(const Slice&amp; data, CompressionType, BlockHandle* handle);</code></li></ol><p>此外，TableBuilder持有一个Req类型的对象指针，用来隐藏相关实现。</p><h2 id="TableBuilder-Rep"><a href="#TableBuilder-Rep" class="headerlink" title="TableBuilder::Rep"></a>TableBuilder::Rep</h2><p>具有下面的：</p><ol><li><code>Options options;</code></li><li><code>Options index_block_options;</code></li><li><code>WritableFile* file;</code><br> <code>WritableFile</code>是一个接口，具体实现可以分为随机读写文件，顺序读写文件等。</li><li><code>uint64_t offset;</code></li><li><code>Status status;</code><br> 是<code>ok()</code>的返回值，表示是否发生了错误。一般，错误会在<code>file</code>里面的Append和Flush方法中出现。</li><li><code>BlockBuilder data_block;</code></li><li><code>BlockBuilder index_block;</code></li><li><code>std::string last_key;</code><br> 每一次Add会更新这个字段。因为Add是有序的，所以实际上就表示了当前最大的key。</li><li><code>int64_t num_entries;</code><br> 见<code>NumEntries</code>。</li><li><code>bool closed;</code><br> Finish和Abandon会设置为true。</li><li><code>FilterBlockBuilder* filter_block;</code></li><li><code>bool pending_index_entry;</code><br> 当写完一个data block之后，设置<code>pending_index_entry</code>，表示需要更新index block。<br> 因此这里有个不变量，当且仅当<code>data_block</code>为空的时候<code>pending_index_entry</code>才是true。也就是说当写入一个data block后（注意一个table中有多个data block），设置<code>pending_index_entry</code>为true，之后更新index block。<br> 原因是直到我们见到下一个data block的第一个key的时候才能写index。这样我们可以在写index的时候用尽可能短的key。例如我们已经知道第一个data block中最大的是”the quick brown fox”，而第二个data block中最小的是”the who”。这样通过之前提到的<code>FindShortestSeparator</code>，我们就可以用”the r”作为index block中的entry。这个entry满足条件，即大于等于第一个block中的所有key，并且小于第二个block中的所有key。<br> 因此，顺序是：<ol><li>写一个data block</li><li>接到下一个Add请求</li><li>根据<code>last_key</code>和当前传入的Key，写index</li><li>正常处理该Add请求</li></ol></li><li><code>BlockHandle pending_handle;</code><br> Handle to add to index block。不是说用这个handle来写index block，而是会把这个handle里面的值写到index block里面作为index。</li><li><code>std::string compressed_output;</code></li></ol><h3 id="TableBuilder-Add"><a href="#TableBuilder-Add" class="headerlink" title="TableBuilder::Add"></a>TableBuilder::Add</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::Add(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果<code>pending_index_entry</code>是true，说明之前已经写入了一个data block。于是我们就要插入index，并且清空<code>pending_index_entry</code>标志。这一部分原理在<code>pending_index_entry</code>讲解过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">  assert(r-&gt;data_block.empty());</span><br><span class="line">  r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">  r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">  r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">  r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是添加的逻辑，先处理filter block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后设置<code>last_key</code>，并向当前的data block中添加KV。<br>估算当前data block的大小，如果超过配置的阈值<code>options.block_size</code>就进行dump。这个估算实际上就是统计所有entry以及restart的总大小。相比<a href="/2019/08/06/spark-sql/">Spark里面的</a>大小估计，感觉LevelDB/Redis里面的大小估计要简单很多，感觉得益于C/C++能自己管理内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TableBuilder-WriteBlock"><a href="#TableBuilder-WriteBlock" class="headerlink" title="TableBuilder::WriteBlock"></a>TableBuilder::WriteBlock</h3><h4 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h4><p>Table要写某个Block，首先Finish这个block，也就是说把所有restart都写到文件里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) &#123;</span><br><span class="line">  assert(ok());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;Finish();</span><br></pre></td></tr></table></figure><p>接着，是写data block。实际写入的<code>block_contents</code>可能是被压缩了的，也可能是没有被压缩的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Slice block_contents;</span><br><span class="line">CompressionType type = r-&gt;options.compression;</span><br><span class="line"><span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> kNoCompression:</span><br><span class="line">    block_contents = raw;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">    <span class="keyword">if</span> (port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;</span><br><span class="line">        compressed-&gt;size() &lt; raw.size() - (raw.size() / <span class="number">8u</span>)) &#123;</span><br><span class="line">      block_contents = *compressed;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">      <span class="comment">// store uncompressed form</span></span><br><span class="line">      block_contents = raw;</span><br><span class="line">      type = kNoCompression;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">WriteRawBlock(block_contents, type, handle);</span><br><span class="line">r-&gt;compressed_output.clear();</span><br></pre></td></tr></table></figure><p>清空这个block里面<code>buffer_</code>、<code>restarts_</code>等状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  block-&gt;Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TableBuilder-WriteRawBlock"><a href="#TableBuilder-WriteRawBlock" class="headerlink" title="TableBuilder::WriteRawBlock"></a>TableBuilder::WriteRawBlock</h4><p>每一个block包含：</p><ol><li>data</li><li>type 表示有没有压缩</li><li>crc32<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::WriteRawBlock(<span class="keyword">const</span> Slice&amp; block_contents,</span><br><span class="line">                                 CompressionType type, BlockHandle* handle) &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.size());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::Value(block_contents.data(), block_contents.size());</span><br><span class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.size() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TableBuilder-Flush"><a href="#TableBuilder-Flush" class="headerlink" title="TableBuilder::Flush"></a>TableBuilder::Flush</h3><p>前面是判断一些条件。如果说data block是空的，那么就直接返回。接着断言<code>pending_index_entry</code>这个是true，这个是之前提到的不变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::Flush() &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br></pre></td></tr></table></figure><p>根据<code>pending_handle</code>的说明，它的值会被写到index block里面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TableBuilder-Finish"><a href="#TableBuilder-Finish" class="headerlink" title="TableBuilder::Finish"></a>TableBuilder::Finish</h3><p>Finish操作用来生成一个SSTable。<br>首先先Flush，也就是把<code>data_block</code>写盘。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status TableBuilder::Finish() &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Flush();</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>什么时候不ok呢？也就是发生错误的情况。<br>下面，写入filter block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"><span class="comment">// Write filter block</span></span><br><span class="line"><span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                &amp;filter_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的写入是成功的，接着写入meta index block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write metaindex block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">    key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    meta_index_block.Add(key, handle_encoding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">  WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的写入是成功的，接着写入index block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write index block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面的写入是成功的，接着写入footer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.size();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>下面介绍Table类，它的作用是负责读取SSTable。</p><ol><li><code>static Status Open(const Options&amp; options, RandomAccessFile* file, uint64_t file_size, Table** table);</code><br> 解析传入的<code>file</code>。<br> 如果成功，返回ok，并且设置<code>*table</code>，这是一个指针，由调用方释放。<br> 如果失败，返回一个非ok，并且设置<code>*table</code>为nullptr。<br> Does not take ownership of “*source”, but the client must ensure that “source” remains live for the duration of the returned table’s lifetime.</li><li><code>Iterator* NewIterator(const ReadOptions&amp;) const;</code></li><li><code>uint64_t ApproximateOffsetOf(const Slice&amp; key) const;</code><br> 传入一个key，返回它在文件中的大概位置。对不存在的key，返回如果存在，那么大概在的位置。</li><li><code>static Iterator* BlockReader(void*, const ReadOptions&amp;, const Slice&amp;);</code><br> TwoLevelIterator需要这个函数，通过它来构建一个<code>data_iter_</code></li><li><code>Status InternalGet(const ReadOptions&amp;, const Slice&amp; key, void* arg, void (*handle_result)(void* arg, const Slice&amp; k, const Slice&amp; v));</code></li><li><code>void ReadMeta(const Footer&amp; footer);</code></li><li><code>void ReadFilter(const Slice&amp; filter_handle_value);</code></li></ol><h3 id="Table-Rep"><a href="#Table-Rep" class="headerlink" title="Table::Rep"></a>Table::Rep</h3><ol><li><code>Options options;</code></li><li><code>Status status;</code></li><li><code>RandomAccessFile* file;</code></li><li><code>uint64_t cache_id;</code></li><li><code>FilterBlockReader* filter;</code></li><li><code>const char* filter_data;</code></li><li><code>BlockHandle metaindex_handle;</code></li><li><code>Block* index_block;</code></li></ol><h3 id="Table-Open"><a href="#Table-Open" class="headerlink" title="Table::Open"></a>Table::Open</h3><p>首先解析出footer。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="line">                   <span class="keyword">uint64_t</span> size, Table** table) &#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure><p>接下来，解析index block。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the index block</span></span><br><span class="line">BlockContents index_block_contents;</span><br><span class="line">ReadOptions opt;</span><br><span class="line"><span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">  opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br></pre></td></tr></table></figure><p>初始化<code>rep_</code>字段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Table-NewIterator"><a href="#Table-NewIterator" class="headerlink" title="Table::NewIterator"></a>Table::NewIterator</h2><p>实际上调用<code>NewTwoLevelIterator</code>得到一个<code>TwoLevelIterator</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator* Table::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</span><br><span class="line">      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockFunction block_function, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> ReadOptions&amp; options)</span></span>;</span><br></pre></td></tr></table></figure><p>方法<code>NewIterator</code>的实现如下。如果没有restart点，那么就创建一个空的迭代器，否则创建一个<code>Block::Iter</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* Block::NewIterator(<span class="keyword">const</span> Comparator* comparator) &#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewErrorIterator(Status::Corruption(<span class="string">"bad block contents"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = NumRestarts();</span><br><span class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewEmptyIterator();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iter(comparator, data_, restart_offset_, num_restarts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个Level的含义是：</p><ol><li><code>IteratorWrapper index_iter_</code>负责查询index block，找到key所在的data block。<br> <code>IteratorWrapper</code>封装了<code>Iterator</code>，可以理解为一层对<code>valid()</code>和<code>key()</code>的cache。<code>Iterator</code>是个接口，实际类型应该是<code>Block::Iter</code>【待确认】。</li><li><code>IteratorWrapper data_iter_</code>负责在这个block里面查找。</li></ol><h3 id="TwoLevelIterator"><a href="#TwoLevelIterator" class="headerlink" title="TwoLevelIterator"></a>TwoLevelIterator</h3><ol><li><code>BlockFunction block_function_;</code><br> 由<code>block_function_</code>可以从一个<code>index_iter_</code>创建一个<code>data_iter_</code>。<br> 在Table的实现中，是<code>Table::BlockReader</code>这个函数。我们将在后面详细分析这个函数。</li><li><code>void* arg_;</code><br> 在Table的实现中，传入了<code>Table* this</code>。</li><li><code>const ReadOptions options_;</code></li><li><code>Status status_;</code></li><li><code>IteratorWrapper index_iter_;</code></li><li><code>IteratorWrapper data_iter_;</code></li><li><code>std::string data_block_handle_;</code><br> 如果<code>data_iter_</code>不是null，那么<code>data_block_handle_</code>持有传给<code>block_function_</code>的那个<code>index_iter_</code>的值。</li></ol><h4 id="TwoLevelIterator-Next"><a href="#TwoLevelIterator-Next" class="headerlink" title="TwoLevelIterator::Next"></a>TwoLevelIterator::Next</h4><p>存在一个问题，如果我们一直<code>data_iter_.Next()</code>，我们迟早会碰到一个Block的右边界，这样后面迭代器就Invalid了。因此需要检查如果<code>data_iter_</code>当前已经失效了，那么就递增<code>index_iter_</code>，获取下一个<code>data_iter_</code>，具体实现见下面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::Next() &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  data_iter_.Next();</span><br><span class="line">  SkipEmptyDataBlocksForward();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TwoLevelIterator-SkipEmptyDataBlocksForward"><a href="#TwoLevelIterator-SkipEmptyDataBlocksForward" class="headerlink" title="TwoLevelIterator::SkipEmptyDataBlocksForward"></a>TwoLevelIterator::SkipEmptyDataBlocksForward</h4><p>【Q】在上面说过这个函数的作用了，但是为啥这里实现是<code>while</code>而不是<code>if</code>呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::SkipEmptyDataBlocksForward() &#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.iter() == <span class="literal">nullptr</span> || !data_iter_.Valid()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>SetDataIterator</code>函数接受一个迭代器作为参数，如果迭代器不是空，那么就设置为<code>data_iter_</code>，并且释放掉原来的<code>iter_</code>内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</span><br><span class="line">      SetDataIterator(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.Next();</span><br><span class="line">    InitDataBlock();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>需要注意，这里需要显式将<code>data_iter_</code>移动到当前data block的开头。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span>) data_iter_.SeekToFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TwoLevelIterator-InitDataBlock"><a href="#TwoLevelIterator-InitDataBlock" class="headerlink" title="TwoLevelIterator::InitDataBlock"></a>TwoLevelIterator::InitDataBlock</h4><p><code>InitDataBlock</code>作用是从<code>index_iter_</code>构建（解析）出一个data block。<br>如果<code>index_iter_</code>无效，那么设置<code>data_iter_</code>也无效。<br>如果<code>data_iter_</code>不为空，并且等于之前的<code>data_block_handle_</code>，说明<code>data_iter_</code>现在就指向的这个data block，那么就跳过。<br>否则，以<code>index_iter_</code>为参数，通过<code>block_function_</code>生成一个新的<code>data_iter_</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::InitDataBlock() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</span><br><span class="line">    SetDataIterator(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slice handle = index_iter_.value();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        handle.compare(data_block_handle_) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Iterator* iter = (*block_function_)(arg_, options_, handle);</span><br><span class="line">      data_block_handle_.assign(handle.data(), handle.size());</span><br><span class="line">      SetDataIterator(iter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TwoLevelIterator-Seek"><a href="#TwoLevelIterator-Seek" class="headerlink" title="TwoLevelIterator::Seek"></a>TwoLevelIterator::Seek</h4><p>首先，在index block层Seek。下面证明只要找这个<code>index_iter_</code>指向的data block就行，也就是说，target不会出现在<code>(index_iter_ - 1)</code>和<code>(index_iter_ + 1)</code>指向的data block里面。</p><ol><li>因为LevelDB中的性质，Seek得到的是第一个大于等于target的指针。此时，<code>(index_iter_ - 1)</code>中的<code>.key()</code>是<strong>严格</strong>小于target的。而根据index block的【性质1】，这个index block entry指向的data block中的所有K都<strong>小于等于</strong><code>(index_iter_ - 1).key()</code>。因此，<code>(index_iter_ - 1)</code>指向的data block里面所有的K，都小于target。</li><li>此外，<code>index_iter_.key()</code>是大于等于target的。</li><li>下面，还要证明<code>(index_iter_ + 1).key()</code>指向的data block里面的所有K都大于target。根据【性质2】我们知道<code>index_iter_.key()</code>会严格小于它指向的下一个data block中的所有K，根据我们上一条结论可以知道target严格小于下一个data block中的所有K，所以target如果存在的话，一定是当前data block上的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::Seek(<span class="keyword">const</span> Slice&amp; target) &#123;</span><br><span class="line">  index_iter_.Seek(target);</span><br></pre></td></tr></table></figure></li></ol><p>接着初始化<code>data_iter_</code>。接着在data block层Seek。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  InitDataBlock();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span>) data_iter_.Seek(target);</span><br><span class="line">  SkipEmptyDataBlocksForward();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Table-BlockReader"><a href="#Table-BlockReader" class="headerlink" title="Table::BlockReader"></a>Table::BlockReader</h3><p>接受三个参数：</p><ol><li><code>arg</code><br> 这个类型设置就很奇怪，实际上是一个<code>Table*</code>，表示我们现在读的那个Table的上下文。</li><li><code>index_value</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line">Iterator* Table::BlockReader(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                             <span class="keyword">const</span> Slice&amp; index_value) &#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.DecodeFrom(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      Slice key(cache_key_buffer, sizeof(cache_key_buffer));</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;size(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  Iterator* iter;</span><br><span class="line">  <span class="keyword">if</span> (block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    iter = block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = NewErrorIterator(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://izualzhy.cn/leveldb-block" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-block</a></li><li><a href="https://izualzhy.cn/leveldb-sstable" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-sstable</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍LevelDB的SSTable相关功能。&lt;br&gt;SSTable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。Level0的SSTable是没有经过归并的，各个Key可能互相重叠。经过Compaction达到Level1之后，就是有序的了。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>LevelDB之Memtable实现</title>
    <link href="http://www.calvinneo.com/2021/04/09/leveldb-memtable/"/>
    <id>http://www.calvinneo.com/2021/04/09/leveldb-memtable/</id>
    <published>2021-04-09T15:09:06.000Z</published>
    <updated>2021-08-18T07:28:47.298Z</updated>
    
    <content type="html"><![CDATA[<p>作为LevelDB源码分析系列的第一篇文章，介绍Memtable的实现，以及其中涉及到的数据结构和辅助函数。</p><p>Memtable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="VarInt"><a href="#VarInt" class="headerlink" title="VarInt"></a>VarInt</h2><p>LevelDB的VarInt机制，用一个char数组存放整数，主要目的不是支持大整数，而是压缩小整数的存储空间。例如小于128的unsigned int，只要一个字节就行，但如果数比较大，。<br>具体实现就是读char数组，如果最高位是1，那么就说明这个VarInt还没有结束，于是就接着读下一位。<br><code>GetVarint32Ptr</code>的函数签名，传入的limit表示这个VarInt数组有多长。因为VarInt最多占用5个字节，所以一般传入都是<code>p + 5</code>。我们需要注意，合法的<code>limit</code>应当始终大于<code>p</code>。<br>一开始是一个优化分支，如果只有一个char，那么直接返回了，否则调用<code>GetVarint32PtrFallback</code>。<br>这个函数返回的前进后的<code>p</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice定义在include/leveldb/slice.h里面，可以理解为对<code>const char*</code>的View。</p><h1 id="Memtable类"><a href="#Memtable类" class="headerlink" title="Memtable类"></a>Memtable类</h1><p>Memtable类定义在memtable.h/cc里面。接口如下</p><ol><li><code>size_t ApproximateMemoryUsage()</code><br> 估计大小，在被修改的时候也可以调用。</li><li><code>Iterator* NewIterator()</code></li><li><code>void Add(SequenceNumber seq, ValueType type, const Slice&amp; key, const Slice&amp; value)</code><br> 负责插入记录。<ol><li>type<br> 普通插入<code>type</code>为kTypeValue。<br> 删除操作实际上是插入<code>type</code>为<code>kTypeDeletion</code>的记录。</li><li>key</li></ol></li><li><code>bool Get(const LookupKey&amp; key, std::string* value, Status* s)</code><br> 如果存在key对应的记录，返回true，并且将值存在<code>*value</code>上。<br> 如果存在key被删除的记录，返回true，并且在<code>*status</code>存入<code>NotFound()</code>。<br> 否则返回false。<br> 这里<code>LookupKey</code>的设计较为复杂，稍后讲解。</li><li><code>void Ref()</code></li><li><code>void Unref()</code></li></ol><p>Memtable还有下面一些成员：</p><ol><li><p><code>KeyComparator comparator_</code><br> 封装了个<code>InternalKeyComparator</code>，这一块后面介绍</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">  explicit KeyComparator(const InternalKeyComparator&amp; c) : comparator(c) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>int refs_</code></p></li><li><p><code>Arena arena_</code></p></li><li><p><code>Table table_</code><br> 实际上是个跳表。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>Memtable在跳表中索引的Key中存放三个数据：</p><ol><li><p>User Key<br> 用户实际传入的key。</p></li><li><p>Sequence Number</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> SequenceNumber;</span><br></pre></td></tr></table></figure></li><li><p>Value Type<br> 表示是不是删除。<br> 对于C而言，enum的大小取决于里面定义的范围。对于C++，可以显式指定实际使用的类型。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ValueType &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这些数据是按顺序编码的，这样方便比较。</p><p><code>InternalKey</code>把这些打包到一个<code>std::string</code>里面。<br><code>ParseInternalKey</code>把<code>InternalKey</code>转成<code>ParsedInternalKey</code>，后者可以直接读取上面三个字段。<br><code>AppendInternalKey</code>可以从<code>ParsedInternalKey</code>构建<code>InternalKey</code>。</p><p>为了方便查找，还将User Key和Sequence Number合并，组成LookupKey。</p><ol><li><p><code>start_</code><br> 指向klength，klength表示userkey长度。注意，这里userkey也可以存放InternalKey，所以<code>LookupKey</code>可以表示一个Memtable Key。</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">klength  varint32               &lt;<span class="comment">-- start_</span></span><br><span class="line">userkey  <span class="keyword">char</span>[klength]          &lt;<span class="comment">-- kstart_</span></span><br><span class="line">tag      uint64</span><br><span class="line">                                &lt;<span class="comment">-- end_</span></span><br></pre></td></tr></table></figure></li><li><p><code>kstart_</code></p></li><li><p><code>end_</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookupKey</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></span><br><span class="line">  <span class="comment">// the specified sequence number.</span></span><br><span class="line">  LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</span><br><span class="line"></span><br><span class="line">  LookupKey(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  LookupKey&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~LookupKey();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></span><br><span class="line">  <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></span><br><span class="line">  <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the user key</span></span><br><span class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结一下，一个Key中的信息包括：</p><ol><li>klength</li><li>User Key</li><li>Tag<ol><li>Sequence Number</li><li>Value Type</li></ol></li></ol><p><img src="/img/leveldb/memtable/memtable.png"></p><p>其中：</p><ol><li>Memtable Key<br> 1+2+3</li><li>Internal Key<br> 2+3</li><li>User Key<br> 2</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>我们合成了一个包含三个部分的Internal Key，如果仅仅是这样，直接比较也许还是可行的，毕竟User Key、Seq、Value Type啥的都是有层级的。但是，这些东西是用VarInt存储的，这就不好直接bitwise比较了。</p><p><code>Comparator</code>接口定义在include/leveldb/comparator.h里面。包含下面一些成员</p><ol><li><code>int Compare(const Slice&amp; a, const Slice&amp; b) const</code><br> 比较函数</li><li><code>void FindShortestSeparator(std::string* start, const Slice&amp; limit)</code><br> 目的是节约空间。如果<code>*start</code>这个字符串小于<code>limit</code>字符串，那么就修改<code>*start</code>，变成大小在<code>*start</code>和<code>limit</code>之间，<a href="https://zhuanlan.zhihu.com/p/79362747" target="_blank" rel="noopener">但是长度最短的字符串</a>。<br> 其方法基于公共前缀，如果<code>*start</code>是<code>helloWorld</code>，<code>limit</code>是<code>helloZookeeper</code>，那么旧改<code>*start</code>为<code>helloX</code>，也就是后面的<code>World</code>不要了。<br> 【Q】这个功能会用到哪里呢？我觉得在插入是用不上的，因为会涉及修改Key的值。</li><li><code>void FindShortSuccessor(std::string* key)</code></li></ol><p><code>data</code>在开头存了对应字符串的长度。所以<code>GetLengthPrefixedSlice</code>会先读取长度到<code>len</code>里面，这个时候<code>p</code>前进指向了实际的字符串，然后创建一个Slice。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = data;</span><br><span class="line">  p = GetVarint32Ptr(p, p + <span class="number">5</span>, &amp;len);  <span class="comment">// +5: we assume "p" is not corrupted</span></span><br><span class="line">  <span class="keyword">return</span> Slice(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MemTable::KeyComparator</code>就是获取对应的字符串，然后调用<code>InternalKeyComparator</code>比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MemTable::KeyComparator::<span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">char</span>* aptr,</span><br><span class="line">                                        <span class="keyword">const</span> <span class="keyword">char</span>* bptr) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// Internal keys are encoded as length-prefixed strings.</span></span><br><span class="line">  Slice a = GetLengthPrefixedSlice(aptr);</span><br><span class="line">  Slice b = GetLengthPrefixedSlice(bptr);</span><br><span class="line">  <span class="keyword">return</span> comparator.Compare(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较的顺序是:</p><ol><li>User Key升序</li><li>Sequence Number降序<br> 这样，会倾向于找新的</li><li>ValueType降序<br> 但考虑到Sequence Number，大概率用不到。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InternalKeyComparator::Compare(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，在<code>InternalKeyComparator</code>里面，还会调用<code>user_comparator_-&gt;Compare</code>去比较User Key。它默认是<code>BytewiseComparator</code>类型的。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>现在我们有一个KV对<code>key</code>和<code>value</code>，都用Slice运载的。我们要把它放到跳表中。<br>有点类似于Spark将K和V连续放在两个slot上，LevelDB直接将K和V编码到一起存放。因此，我们可以看到总长度<code>encoded_len</code>需要计算下面几部分：</p><ol><li>K的长度，用VarInt存<br> 这里<code>internal_key_size</code>为啥要加上8呢？这是因为Sequence Number和Type分别占用了7个byte和1个byte。所以从User Key生成Internal Key的时候要加上这两部分。<br> 这就是Memtable Key，相对于Internal Key多存储的一块数据。</li><li>K本身<br> 也就是Internal Key。</li><li>V的长度</li><li>V本身<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MemTable::Add(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.size();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.size();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>下面，就是从Memtable里面的Arena中分配一块内存<code>buf</code>，然后把上面说的四个字段填进去，最后把<code>buf</code>添加到跳表<code>table_</code>里面。跳表插入只需要实现比较操作，这个之前已经定义过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = EncodeVarint32(p, val_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>首先，从LookupKey中取得<code>memtable_key</code>，这个是包含了4个部分的。接着获得跳表的迭代器<code>iter</code>，定位到第一个大于等于<code>memkey</code>的位置。<br>我们得到<code>key_ptr</code>指向Internal Key，<code>key_length</code>为Internal Key的长度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MemTable::Get(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s) &#123;</span><br><span class="line">  Slice memkey = key.memtable_key();</span><br><span class="line">  Table::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">  iter.Seek(memkey.data());</span><br><span class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br></pre></td></tr></table></figure><p>接着我们比较Value Type，它在tag的最后一个字节。注意tag的组装方式是<code>(seq &lt;&lt; 8) | type</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line">            Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">          value-&gt;assign(v.data(), v.size());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">          *s = Status::NotFound(Slice());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://izualzhy.cn/memtable-leveldb" target="_blank" rel="noopener">https://izualzhy.cn/memtable-leveldb</a></li><li><a href="https://github.com/yingshin/leveldb_more_annotation/blob/master/db/memtable.h" target="_blank" rel="noopener">https://github.com/yingshin/leveldb_more_annotation/blob/master/db/memtable.h</a></li><li><a href="https://zhuanlan.zhihu.com/p/79362747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79362747</a></li><li><a href="https://github.com/balloonwj/CppGuide/blob/master/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904.md" target="_blank" rel="noopener">https://github.com/balloonwj/CppGuide/blob/master/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904.md</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为LevelDB源码分析系列的第一篇文章，介绍Memtable的实现，以及其中涉及到的数据结构和辅助函数。&lt;/p&gt;
&lt;p&gt;Memtable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis事务的实现</title>
    <link href="http://www.calvinneo.com/2021/03/23/redis-transaction/"/>
    <id>http://www.calvinneo.com/2021/03/23/redis-transaction/</id>
    <published>2021-03-22T17:20:33.000Z</published>
    <updated>2021-08-18T07:28:24.953Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍Redis事务的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。<br>这是Redis源码分析的系列文章的第四篇，前三篇分别是</p><ol><li><a href="/2018/07/23/redis_learn_object/">Redis底层对象实现原理分析</a></li><li><a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a></li><li><a href="/2021/03/13/redis-persist/">Redis持久化机制实现</a></li></ol><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>事务在执行期间<a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">不会主动中断</a>，也就是说服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。<br>需要注意的是，Redis并<strong>没有原子性</strong>。原因之一是Redis不支持事务回滚。有人说Redis不是有DISCARD的么？但这个DISCARD只是在命令入队的阶段，等到真正执行事务的时候，Redis并不支持执行到一般就退出。</p><h2 id="multi"><a href="#multi" class="headerlink" title="multi"></a>multi</h2><p>总的来说，就是multi开始事务，最后exec提交事务或者discard放弃事务。在发送完multi后，后面发送的命令都不会被立即执行，而是返回QUEUED状态。当收到exec后，事务会将这个队列中的命令按照fifo的顺序执行。并发结果放入一个回复队列中返回给客户端。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>在multi前监控一些key，如果这些key被修改，则事务回滚。</p><h1 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h1><h2 id="multiState"><a href="#multiState" class="headerlink" title="multiState"></a>multiState</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* MINREPLICAS for synchronous replication */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* MINREPLICAS timeout as unixtime. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>主要涉及下面一些字段：</p><ol><li><code>commands</code><br> 这个是<code>multiCmd</code>数组，表示事务中的FIFO的队列。</li><li><code>count</code><br> multi命令的数量，表示commands的长度？</li><li><code>cmd_flags</code></li></ol><h2 id="multiCmd"><a href="#multiCmd" class="headerlink" title="multiCmd"></a>multiCmd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><h1 id="redisCmd"><a href="#redisCmd" class="headerlink" title="redisCmd"></a>redisCmd</h1><h1 id="事务开始和结束的实现"><a href="#事务开始和结束的实现" class="headerlink" title="事务开始和结束的实现"></a>事务开始和结束的实现</h1><h2 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h2><p>可以看到，在<code>processCommand</code>中，如果被设置了MULTI，那么就不会调用<code>call</code>，而是调用<code>queueMultiCommand</code>将指令入队。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>multi指令，会给客户端打上<code>CLIENT_MULTI</code>这个flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="discardTransaction"><a href="#discardTransaction" class="headerlink" title="discardTransaction"></a>discardTransaction</h3><p>先调用<code>discardTransaction</code>清空<code>multiCmd</code>数组。<br>再调用<code>initClientMultiState</code>清除<code>multiState</code>里面的其他内容。<br>再取消所有事务相关的flag。这边的flag都是什么意思？</p><ol><li><code>CLIENT_MULTI</code> </li><li><code>CLIENT_DIRTY_CAS</code><br> 表示被watch的字段发生了修改。</li><li><code>CLIENT_DIRTY_EXEC</code><br> 由<code>flagTransaction</code>产生，表示在先前操作中，出现了错误，所以不能exec。包含下面情况：<ol><li>rejectCommand<br> 在下面的场景下被调用：<ol><li>shared.noautherr</li><li>shared.oomerr</li><li>shared.bgsaveerr</li><li>等等</li></ol></li><li>rejectCommandFormat</li><li>processCommand中，涉及Redis Cluster相关。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">/* Need to propagate MULTI/EXEC to AOF / slaves? */</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检查flags，discard掉有问题的事务：</p><ol><li>对于<code>CLIENT_DIRTY_CAS</code>返回空数组<br> 因为这个不能算作是错误，只能作为一种特殊的表现。</li><li>对于<code>CLIENT_DIRTY_EXEC</code>返回EXECABORT<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment"> * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment"> * in the second an EXECABORT error is returned. */</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">    addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                               shared.nullarray[c-&gt;resp]);</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为已经检查了，取消客户端对所有键的监视。<br>因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要备份这些命令和参数。<br>下面开始处理<code>multiState</code>下面所有的<code>multiCmd</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exec all the queued commands */</span></span><br><span class="line">unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line">orig_argv = c-&gt;argv;</span><br><span class="line">orig_argc = c-&gt;argc;</span><br><span class="line">orig_cmd = c-&gt;cmd;</span><br><span class="line">addReplyArrayLen(c,c-&gt;mstate.count);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">    c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">    c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">    c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br></pre></td></tr></table></figure><p>当我们遇到第一个不是<code>CMD_READONLY</code>或者<code>CMD_ADMIN</code>的请求时，传播multi指令。【Q】这里readonly又出现了，为啥这么特殊呢？我觉得readonly指令一般指的是get之类的不涉及修改的指令。而一旦涉及修改或者增加等的指令，我们一定要把这个变动propagate出去。<br>这样，我们可以将<code>MULTI/..../EXEC</code>打包成一整个，并且AOF和Slave都具有相同的一致性和原子性的要求。为啥呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!must_propagate &amp;&amp;</span><br><span class="line">    !server.loading &amp;&amp;</span><br><span class="line">    !(c-&gt;cmd-&gt;flags &amp; (CMD_READONLY|CMD_ADMIN)))</span><br><span class="line">&#123;</span><br><span class="line">    execCommandPropagateMulti(c);</span><br><span class="line">    must_propagate = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ACLCheckCommandPerm</code>主要检查权限，包含：</p><ol><li>执行命令的权限</li><li>对某个key的权限</li></ol><p>如果检查通过，我们就用call来执行命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> acl_keypos;</span><br><span class="line"><span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line"><span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">    addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">    addReplyErrorFormat(c,</span><br><span class="line">        <span class="string">"-NOPERM ACLs rules changed between the moment the "</span></span><br><span class="line">        <span class="string">"transaction was accumulated and the EXEC call. "</span></span><br><span class="line">        <span class="string">"This command is no longer allowed for the "</span></span><br><span class="line">        <span class="string">"following reason: %s"</span>,</span><br><span class="line">        (acl_retval == ACL_DENIED_CMD) ?</span><br><span class="line">        <span class="string">"no permission to execute the command or subcommand"</span> :</span><br><span class="line">        <span class="string">"no permission to touch the specified keys"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为执行后命令、命令参数可能会被改变，比如<code>SPOP</code>会被改写为<code>SREM</code>，所以这里需要更新事务队列中的命令和参数，确保Slave和AOF的数据一致性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">    c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">    c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">    c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个循环结束之后，事务执行完了，我们还原命令，并且清空事务状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;argv = orig_argv;</span><br><span class="line">c-&gt;argc = orig_argc;</span><br><span class="line">c-&gt;cmd = orig_cmd;</span><br><span class="line">discardTransaction(c);</span><br></pre></td></tr></table></figure><p>下面，如果我们需要propagate的话，就增加<code>dirty</code>。先前我们知道，在call结束之后，如果有dirty，会去触发检测是否propagate的逻辑。而call也是可以嵌套调用的。<br>这里有一个特殊情况需要考虑。就是在multi/exec块中，这个实例突然从Master切换成了Slave（可能是来自Sentinel的<code>SLAVEOF</code>指令）。此时，原来Master收到的multi指令已经被传播到了replication backlog里面，但是后面的可能还没来得及传。对于这种情况，我们需要保证至少通过exec来结束这个backlog。【Q】为啥不用discard呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated. */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd,<span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="comment">/* Send EXEC to clients waiting data from MONITOR. We do it here</span></span><br><span class="line"><span class="comment">     * since the natural order of commands execution is actually:</span></span><br><span class="line"><span class="comment">     * MUTLI, EXEC, ... commands inside transaction ...</span></span><br><span class="line"><span class="comment">     * Instead EXEC is flagged as CMD_SKIP_MONITOR in the command</span></span><br><span class="line"><span class="comment">     * table, and we do it here with correct ordering. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详细介绍Redis事务的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。&lt;br&gt;这是Redis源码分析的系列文章的第四篇，前三篇分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;Redis底层对象实现原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2021/03/13/redis-persist/&quot;&gt;Redis持久化机制实现&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL查询</title>
    <link href="http://www.calvinneo.com/2021/03/15/mysql-query/"/>
    <id>http://www.calvinneo.com/2021/03/15/mysql-query/</id>
    <published>2021-03-14T16:01:30.000Z</published>
    <updated>2021-03-14T16:20:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍MySQL InnoDB下索引、查询的实现以及优化。</p><a id="more"></a><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="回表查询和覆盖索引"><a href="#回表查询和覆盖索引" class="headerlink" title="回表查询和覆盖索引"></a>回表查询和覆盖索引</h2><p>什么是回表查询？InnoDB中的主键(Primary Key, PK)使用了聚簇索引，即主键索引的叶子节点存放的是行数据<strong>本身</strong>。因此通过主键进行SELECT是很快的。<br>但是对于其他的索引，它们的叶子节点存放的是主键ID。这个是显然的，不然我每创建一个索引就得重新建立一个表结构了。在这种情况下访问行数据，就得通过主键ID去聚簇索引中再查一次，这个也就是所谓的回表查询。</p><p>看到这里不禁有一个想法，我们能不能把主键的索引做成哈希的，这样的话它的复杂度是<code>O(1)</code>，能减小回表开销，主要有下面的考虑：</p><ol><li>自增主键往往规律可循，能够设计出很好的哈希函数。</li><li>因为自增索引不像银行卡号码或者手机号码那样具有实际的意义，所以B+树提供的一些范围查询的性能未必常用。</li><li>B+树毕竟是<code>O(log n)</code>的复杂度，如果使用哈希索引，能够提高回表查询的效率。</li><li>哈希索引更好做分区。</li></ol><p>那有没有其他办法减少回表查询的开销呢？一个方案是通过覆盖索引(Covering Index)。</p><p>为了介绍覆盖索引，首先介绍联合索引。对于下面的语句生成的索引，可以用来加速<code>c1</code>、<code>c1,c2</code>、<code>c1,c2,c3</code>这三个查询。这个也是好理解的，例如我们在查询字典的时候，可以先查询第一个字母，然后再查询第二个字母；反之，没办法直接查第二个字母和第三个字母，即用不了<code>c2,c3</code>这样的索引。这启示我们，在设计联合索引的时候，应当把最常用或者最宽泛的条件放到最左边。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c1_c2_c3 <span class="keyword">on</span> table1(c1,c2,c3);</span><br></pre></td></tr></table></figure><p>通过覆盖索引，通过非聚簇索引查询数据也不需要再回表了，这得益于联合索引。例如<code>index_c1_c2_c3</code>就包含了<code>c1</code>、<code>c2</code>、<code>c3</code>这三个字段的值，那么如果我们只需要查询这些值的话，就不需要回表了。</p><h2 id="Extra总结"><a href="#Extra总结" class="headerlink" title="Extra总结"></a>Extra总结</h2><h3 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h3><p>需要创建临时表。</p><h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><p>文件排序，通常出现在不能使用索引排序的情况。<br>一个通常的情况是使用查询索引之外的Key去做<code>ORDER BY</code>时。<br>文件排序一般有几种实现方式，令被排序的键是<code>S</code>，主键是<code>ref</code>，需要返回的列是<code>addon1</code>、<code>addon2</code>、<code>addon3</code>，则有</p><ol><li><code>(S,ref)</code>，即original filesort algorithm，回表排序<br> 这种方式占用空间较小，但需要在排序后根据<code>ref</code>回表查询，从而产生很多随机IO。</li><li><code>(S,addon1,addon2,addon3)</code>，即modified filesort algorithm，不回表排序<br> 这种方案不需要回表，但是对排序空间要求高。当然，对于诸如varchar类型的addon字段，是可以压缩(pack)一下的，但是对于搜索排序键是不行的。</li></ol><p>具体选择哪种方案，主要是看<code>S</code>和所有addon字段的长度总和是否超过一定的阈值。</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>使用覆盖索引获取所需要的数据。</p><h3 id="Using-Index-Condition"><a href="#Using-Index-Condition" class="headerlink" title="Using Index Condition"></a>Using Index Condition</h3><p>这个实际上运用了索引下推(Index Condition Pushdown)技术。这个技术是MySQL 5.7之后的一个优化，涉及了服务器层和存储引擎层。<br>首先来先看下没有这个优化的select where过程：</p><ol><li>首先读取下一行的index tuple，然后用index tuple去定位并读取整个行。</li><li>检查所有的WHERE条件，如果该条件属于这张表，就进行检测是否符合条件。<br>在有了这个优化之后，新的过程是：</li><li>首先读取下一行的index tuple，但不需要再去读取整个行。</li><li>检查所有的WHERE条件，如果该条件属于这张表，并且能够根据当前使用的索引就能检测，就直接检测了。如果条件不满足，直接看下一行。</li><li>如果条件满足，用index tuple去定位并读取整个行。</li><li>使用刚才剩下来没有被用到的WHERE条件，检测是否符合条件。</li></ol><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>表示MySQL需要在收到存储引擎返回的结果后，对这个结果进行后过滤(Post filter)。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>首先构造样例，在db1中创建表<code>table1_noindex</code>、<code>table1</code>、<code>table2_noindex</code>。对表table1创建联合索引<code>index_c1_c2_c3</code>和索引<code>index_c5</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">DATABASE</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1_noindex;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> table1_noindex(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    c1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c2 <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c3 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c5 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> table2_noindex(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    c5 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1 <span class="keyword">LIKE</span> table1_noindex;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1_noindex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c1_c2_c3 <span class="keyword">on</span> table1(c1,c2,c3);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c5 <span class="keyword">on</span> table1(c5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="literal">NULL</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="keyword">NOW</span>(), <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1_noindex <span class="keyword">values</span> (<span class="literal">NULL</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="keyword">NOW</span>(), <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>查看索引</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show keys from table1;</span><br></pre></td></tr></table></figure><ol><li><p>使用主键或者UNIQUE键</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from table1 where id=1\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p> 需要注意的是，使用UNIQUE键，同样会是const类型而不是eq_ref</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c5 from table1 where c5=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: c5</span><br><span class="line">          key: c5</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure></li><li><p>使用索引<br> Extra中的Using index表示单纯用索引即可获得所有数据，不需要回表查询，这也就是之前提到的覆盖索引。下面我们介绍覆盖索引</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure><p> 但是，如果我们加上c4，就必须要回表了</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c4 from table1 where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p> 此外，如果我们对索引列进行计算或者应用函数，也会导致不能使用索引</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c1*2=2 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 99</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure></li><li><p>使用索引下推<br> 为了规避掉覆盖索引直接返回，我们这次用了<code>select *</code>。当然，也可以select索引之外的列，比如<code>c4</code>。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from table1 where c1=1 and c2 like "a*"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br></pre></td></tr></table></figure></li><li><p>不使用索引<br> 可以发现，type是个ALL，表示发生了全表扫描。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1_noindex where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1_noindex</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure></li><li><p>破坏了最左匹配原则<br> 这一次，type是index，这表示仍然需要进行全表扫描。但不同的是扫描是按照索引的顺序，也就是说不需要对结果排序了。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c3=DATE('2012-12-21 00:00:00')\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 99</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure><p> 当然如果我们执行一下下面的语句，type又会变成ref</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c3 <span class="keyword">on</span> table1(c3);</span><br></pre></td></tr></table></figure></li><li><p>多表查询</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select table2_noindex.c5 from table1,table2_noindex where table1.c5=table2_noindex.c5;</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table          | partitions | type   | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | table1         | NULL       | index  | c5            | c5   | 4       | NULL          |    1 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | table2_noindex | NULL       | eq_ref | c5            | c5   | 4       | db1.table1.c5 |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,table2_noindex.c5 from table1,table2_noindex where table1.c5=table2_noindex.c5;</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table          | partitions | type   | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | table1         | NULL       | ALL    | c5            | NULL | NULL    | NULL          |    1 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | table2_noindex | NULL       | eq_ref | c5            | c5   | 4       | db1.table1.c5 |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍MySQL InnoDB下索引、查询的实现以及优化。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL锁</title>
    <link href="http://www.calvinneo.com/2021/03/14/mysql-lock/"/>
    <id>http://www.calvinneo.com/2021/03/14/mysql-lock/</id>
    <published>2021-03-13T16:01:30.000Z</published>
    <updated>2021-03-22T16:08:31.617Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍MySQL InnoDB下锁的实现以及优化。</p><p>【未完待续】</p><a id="more"></a><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>InnoDB在RR级别下，通过Next Key Lock(Record Lock+Gap Lock)提供了等价于Serializable的能力。Serializable被用在分布式事务上，即<a href="https://www.zhihu.com/question/58308824" target="_blank" rel="noopener">对于分布式事务，MySQL要求Serializable隔离级别</a>。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验修改自<a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">文章</a>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1(</span><br><span class="line">    c1 <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">key</span> index_c1(c1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="number">1</span>),(<span class="number">3</span>),(<span class="number">5</span>),(<span class="number">8</span>),(<span class="number">11</span>);</span><br></pre></td></tr></table></figure><p>Session1，使用for update会强制加行锁（如果存在）或者间隙锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1 <span class="keyword">where</span> c1 = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure><p>Session2</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>Session2会被Session1阻塞。如果没有间隙锁，那么只会锁住c1为8的这一行。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍MySQL InnoDB下锁的实现以及优化。&lt;/p&gt;
&lt;p&gt;【未完待续】&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
