<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2023-02-01T02:54:37.454Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>停机问题</title>
    <link href="http://www.calvinneo.com/2023/02/01/the-halt-problem/"/>
    <id>http://www.calvinneo.com/2023/02/01/the-halt-problem/</id>
    <published>2023-02-01T15:20:37.000Z</published>
    <updated>2023-02-01T02:54:37.454Z</updated>
    
    <content type="html"><![CDATA[<p>介绍停机问题相关证明。</p><a id="more"></a><h1 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h1><p>令<code>H(P, I)</code>，返回对于程序<code>P</code>在输入<code>I</code>的情况下是否可停机，假如<code>P(I)</code>能停机，则<code>H</code>停机，否则<code>H</code>死循环。</p><p>不妨假设<code>U(X) = H(X, X)</code>。现在考虑<code>U(X)</code>的定义：</p><ol><li>如果<code>H(X, X)</code>停机，则<code>U(X)</code>死循环。</li><li>如果<code>H(X, X)</code>死循环，则<code>U(X)</code>停机。</li></ol><p>也就是<code>U(X)</code>是对<code>H(X, X)</code>取反。</p><p>下面考虑<code>U(U)</code>的结果：</p><ol><li>如果<code>H(U,U)</code>停机，那么<code>U(U)</code>应该输出死循环。</li><li>但是考虑<code>H(U,U)</code>的定义是<code>U</code>在输入为<code>U</code>的情况下是否停机，如果<code>H(U,U)</code>停机了，说明<code>U(U)</code>是可以停机的。</li></ol><p>于是上面两者矛盾。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍停机问题相关证明。&lt;/p&gt;</summary>
    
    
    
    
    <category term="高并发" scheme="http://www.calvinneo.com/tags/高并发/"/>
    
  </entry>
  
  <entry>
    <title>valgrind 用法</title>
    <link href="http://www.calvinneo.com/2023/01/26/valgrind-usage/"/>
    <id>http://www.calvinneo.com/2023/01/26/valgrind-usage/</id>
    <published>2023-01-26T02:04:26.000Z</published>
    <updated>2023-01-30T16:09:25.326Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。</p><a id="more"></a><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>功能是：</p><ol><li>未允许的内存访问，例如 overrun 或者 underrun 堆内存，或者 oveerrun 栈顶，或者访问已经被释放的内存。</li><li>使用未定义的值，例如没有被初始化的值，或者从其他未初始化的值派生出来的值。</li><li>错误释放堆内存，类似于 double free，或者错误搭配 new/new[]/malloc。</li><li>在内存分配时，传入负数作为大小。</li><li>内存泄露。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --track-origins=yes</span><br></pre></td></tr></table></figure><h2 id="Illegal-read-Illegal-write-errors"><a href="#Illegal-read-Illegal-write-errors" class="headerlink" title="Illegal read / Illegal write errors"></a>Illegal read / Illegal write errors</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, *(<span class="keyword">int</span>*)(&amp;y + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==25724== Invalid read of size 4</span><br><span class="line">==25724==    at 0x400674: main</span><br><span class="line">==25724==  Address 0x0 is not stack&apos;d, malloc&apos;d or (recently) free&apos;d</span><br></pre></td></tr></table></figure><h2 id="Use-of-uninitialised-values"><a href="#Use-of-uninitialised-values" class="headerlink" title="Use of uninitialised values"></a>Use of uninitialised values</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">==38591== Use of uninitialised value of size 8</span><br><span class="line">==38591==    at 0x571A32B: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line"></span><br><span class="line">==38591== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==38591==    at 0x571A335: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line">==38591==  Uninitialised value was created by a stack allocation</span><br><span class="line">==38591==    at 0x400667: main</span><br></pre></td></tr></table></figure><p>在程序操作未初始化的数据时，memcheck 会记录这些数据，但不会输出错误。只有当这个程序尝试使用这些未初始化的数据，并且会影响这个程序的外部可见性时，才会报错。在这个例子中，x 没有被初始化。memcheck 观察到这个值被传给 printf 和 vfprintf，但并没有输出错误。当 vfprintf 检查 x 的值，并且试图将其转换为 ASCII 字符串时，memcheck 才会输出错误。</p><p>可以通过设置 <code>--track-origins=yes</code> 来检查这些未初始化的数据。它会使得 memcheck 跑得更慢，但更容易发现问题。</p><h2 id="Use-of-uninitialised-or-unaddressable-values-in-system-calls"><a href="#Use-of-uninitialised-or-unaddressable-values-in-system-calls" class="headerlink" title="Use of uninitialised or unaddressable values in system calls"></a>Use of uninitialised or unaddressable values in system calls</h2><p>Memcheck 检查 system call 中所有的未初始化变量，包括：</p><ol><li>所有的直接变量。</li><li>或者，如果一个 system call 需要读取程序中的某一段缓存，memcheck 会检查整个缓存是否 addressable，并且其内容是否被初始化。</li><li>或者，如果这个 system call 需要写到用户提供的某一段缓存中，memcheck 需要检查这段缓存是否 addressable。</li></ol><h2 id="Illegal-frees"><a href="#Illegal-frees" class="headerlink" title="Illegal frees"></a>Illegal frees</h2><p>Memcheck 记录通过 malloc 和 new 分配的所有块，所以他可以知道某个 free 或者 delete 是否合法。在这里，出现了 double free。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在出现非法读写的错误时，memcheck 会尝试解析被释放的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==27728== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006E4: main</span><br><span class="line">==27728==  Address 0x5ab1c80 is 0 bytes inside a block of size 10 free&apos;d</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006D8: main</span><br><span class="line">==27728==  Block was alloc&apos;d at</span><br><span class="line">==27728==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27728==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><p>注意，如果我们释放的是指向某个堆空间内部的指针，则也会出现类似的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，报错为 <code>is 1 bytes inside ... alloc&#39;d</code>。这样的报错说明不是 double free 的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==31870== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==31870==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==31870==    by 0x4006DC: main</span><br><span class="line">==31870==  Address 0x5ab1c81 is 1 bytes inside a block of size 10 alloc&apos;d</span><br><span class="line">==31870==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==31870==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==12625== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x400705: main</span><br><span class="line">==12625==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 free&apos;d</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x4006F2: main</span><br><span class="line">==12625==  Block was alloc&apos;d at</span><br><span class="line">==12625==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==12625==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] (x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==18227== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==18227==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==18227==    by 0x4006FC: main</span><br><span class="line">==18227==  Address 0x5ab1c84 is 4 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==18227==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==18227==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h2 id="When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function"><a href="#When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function" class="headerlink" title="When a heap block is freed with an inappropriate deallocation function"></a>When a heap block is freed with an inappropriate deallocation function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==29865== Mismatched free() / delete / delete []</span><br><span class="line">==29865==    at 0x4C2B6DF: operator delete(void*, unsigned long) (vg_replace_malloc.c:595)</span><br><span class="line">==29865==    by 0x400710: main</span><br><span class="line">==29865==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==29865==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==29865==    by 0x4006E8: main</span><br></pre></td></tr></table></figure><p>C++ 中的 allocate 和 deallocate 操作包含：</p><ol><li>If allocated with malloc, calloc, realloc, valloc or memalign, you must deallocate with free.</li><li>If allocated with new, you must deallocate with delete.</li><li>If allocated with new[], you must deallocate with delete[].</li></ol><p>最要命的是在 Linux 中其实无所谓搞混这些 allocate 和 deallocate 操作。但是这样错误的搭配在其他平台比如 Solaris 上则会导致 crash。</p><h2 id="Overlapping-source-and-destination-blocks"><a href="#Overlapping-source-and-destination-blocks" class="headerlink" title="Overlapping source and destination blocks"></a>Overlapping source and destination blocks</h2><p>在 <code>memcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code> 中，指向 src 和 dst 的指针不能 overlap。</p><p>比较奇怪的是下面的代码并不会出现这样的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(x + <span class="number">1</span>, x, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">void</span> * y = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(y + <span class="number">1</span>, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 gcc 会把 memcpy 优化掉，通过 <code>-fno-builtin-memcpy</code> 可以禁用这个性质。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==15974== Source and destination overlap in memcpy(0x5ab1c81, 0x5ab1c80, 2)</span><br><span class="line">==15974==    at 0x4C2E81D: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1035)</span><br><span class="line">==15974==    by 0x40075E: main</span><br><span class="line">==15974==</span><br></pre></td></tr></table></figure><h2 id="Fishy-argument-values"><a href="#Fishy-argument-values" class="headerlink" title="Fishy argument values"></a>Fishy argument values</h2><p>所有的内存分配函数都需要指定需要分配的大小，而这个大小肯定是一个非负数，并且不会特别大。例如我们不太可能在64位机器上分配 <code>2**23</code> 个字节。这样的大小通常来自于一个人为的错误，而这样的值就被称为 fishy value。在 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>memalign</code>、<code>new</code>、<code>new []</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==27571== Argument &apos;size&apos; of function malloc has a fishy (possibly negative) value: -2</span><br><span class="line">==27571==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27571==    by 0x40067A: main</span><br></pre></td></tr></table></figure><p>但同时注意到编译器也会触发警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: argument 1 value ‘18446744073709551614’ exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]</span><br><span class="line">void * x = malloc(-2);</span><br></pre></td></tr></table></figure><h2 id="Memory-leak-detection"><a href="#Memory-leak-detection" class="headerlink" title="Memory leak detection"></a>Memory leak detection</h2><p>Memcheck 会记录所有分配的堆对象。<br>通过设置 <code>--leak-check</code>，对于在结束时尚未被释放的 block，Memcheck 会检查这个 block 是否可以从 root set 被访问。这里的 root set 包括：</p><ol><li>通用寄存器</li><li>在所有可访问内存，包括栈中的 initialised, aligned, pointer-sized data words</li></ol><p>有两种方法可以访问一个 block：</p><ol><li>start-pointer，也就是指向 block 开始位置的指针</li><li>interior-pointer，也就是指向 block 中间位置的指针</li></ol><p>一个 interior-pointer 是如何产生的呢？</p><ol><li>它可能开始是一个 start-pointer，但后来被程序故意或者非故意地向前移动<br> 比如如果程序使用 tagged pointer。因为对齐的缘故，指针最右边的几位通常是0，所以会被用来存储额外的信息。这些信息可能导致指针被前进。</li><li>可能是内存中的某个垃圾</li><li>【stdstring】可能是指向 std::string 内部持有的 char[] 的指针<br> 例如某些编译期会在 std::string 的头部存3个字段，分别表示数组的 length、capacity 和 refcount，在这3个字段之后再放置真正的 char[]。但是它返回的指针是指向 char[] 的。这个有点类似 Redis 的 SDS 的实现。</li><li>【length64】Some code might allocate a block of memory, and use the first 8 bytes to store (block size - 8) as a 64bit number. sqlite3MemMalloc does this.</li><li>【newarray】可能是执行某个 T[] 中的指针。这里的 T 是一个 C++ 对象，它具有自定义的析构函数，并使用 new[] 分配，delete[] 删除<br> 在这种情况下，一些编译器会在指针的前面放一个 magic cookie，用来存放长度。</li><li>【multipleinheritance】It might be a pointer to an inner part of a C++ object using multiple inheritance.</li></ol><p>You can optionally activate heuristics to use during the leak search to detect the interior pointers corresponding to the stdstring, length64, newarray and multipleinheritance cases. If the heuristic detects that an interior pointer corresponds to such a case, the block will be considered as reachable by the interior pointer. In other words, the interior pointer will be treated as if it were a start pointer.</p><p>下面一张图阐释了几种内存泄露的情况：</p><ol><li><code>DR</code>: Directly reachable</li><li><code>IR</code>: Indirectly reachable</li><li><code>DL</code>: Directly lost</li><li><code>IL</code>: Indirectly lost</li><li><code>(y)XY</code>: it’s XY if the interior-pointer is a real pointer</li><li><code>(n)XY</code>: it’s XY if the interior-pointer is not a real pointer</li><li><code>(_)XY</code>: it’s XY in either case</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(1)  RRR ------------&gt; BBB                    DR</span><br><span class="line">(2)  RRR ---&gt; AAA ---&gt; BBB    DR              IR</span><br><span class="line">(3)  RRR               BBB                    DL</span><br><span class="line">(4)  RRR      AAA ---&gt; BBB    DL              IL</span><br><span class="line">(5)  RRR ------?-----&gt; BBB                    (y)DR, (n)DL</span><br><span class="line">(6)  RRR ---&gt; AAA -?-&gt; BBB    DR              (y)IR, (n)DL</span><br><span class="line">(7)  RRR -?-&gt; AAA ---&gt; BBB    (y)DR, (n)DL    (y)IR, (n)IL</span><br><span class="line">(8)  RRR -?-&gt; AAA -?-&gt; BBB    (y)DR, (n)DL    (y,y)IR, (n,y)IL, (_,n)DL</span><br><span class="line">(9)  RRR      AAA -?-&gt; BBB    DL              (y)IL, (n)DL</span><br><span class="line"></span><br><span class="line">Pointer chain legend:</span><br><span class="line">- RRR: a root set node or DR block</span><br><span class="line">- AAA, BBB: heap blocks</span><br><span class="line">- ---&gt;: a start-pointer</span><br><span class="line">- -?-&gt;: an interior-pointer</span><br></pre></td></tr></table></figure><p>前四行比较简单。<br>第5行，如果这个 interior pointer 是一个 real pointer，则是 directly reachable。如果不是 real pointer 则是 directly lost。<br>第6行，相当于是2+5，没啥特殊的。<br>第7行，相当于是5+1，没啥特殊的。<br>第8行，可以分成三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(8)  RRR -?-&gt; AAA -?n-&gt; BBB   (y)DR, (n)DL    DL</span><br><span class="line">(8)  RRR -?y-&gt; AAA -?y-&gt; BBB  DR              IR</span><br><span class="line">(8)  RRR -?n-&gt; AAA -?y-&gt; BBB  DL              IL</span><br></pre></td></tr></table></figure><p>但实际输出的时候，不会按照上面9个情况来输出，而是设计为如下的形式：</p><ol><li>Still reachable 1-2行</li><li>Definitely lost 3行</li><li>Indirectly lost 4/9行</li><li>Possibly lost 5-8行<br> 这种情况下可能存在1或者多个指针构成的链，但其中至少有一个指针是 interior pointer。这个可能只是内存中的随机值，并恰巧指向了某个块。</li></ol><h2 id="Details-of-Memcheck’s-checking-machinery"><a href="#Details-of-Memcheck’s-checking-machinery" class="headerlink" title="Details of Memcheck’s checking machinery"></a>Details of Memcheck’s checking machinery</h2><p>这一节介绍 Memcheck 的原理。</p><h3 id="Valid-value-V-bits"><a href="#Valid-value-V-bits" class="headerlink" title="Valid-value (V) bits"></a>Valid-value (V) bits</h3><p>It is simplest to think of Memcheck implementing a synthetic CPU which is identical to a real CPU, except for one crucial detail. Every bit (literally) of data processed, stored and handled by the real CPU has, in the synthetic CPU, an associated “valid-value” bit, which says whether or not the accompanying bit has a legitimate value. In the discussions which follow, this bit is referred to as the V (valid-value) bit.</p><p>Each byte in the system therefore has a 8 V bits which follow it wherever it goes. For example, when the CPU loads a word-size item (4 bytes) from memory, it also loads the corresponding 32 V bits from a bitmap which stores the V bits for the process’ entire address space. If the CPU should later write the whole or some part of that value to memory at a different address, the relevant V bits will be stored back in the V-bit bitmap.</p><p>In short, each bit in the system has (conceptually) an associated V bit, which follows it around everywhere, even inside the CPU. Yes, all the CPU’s registers (integer, floating point, vector and condition registers) have their own V bit vectors. For this to work, Memcheck uses a great deal of compression to represent the V bits compactly.</p><p>Copying values around does not cause Memcheck to check for, or report on, errors. However, when a value is used in a way which might conceivably affect your program’s externally-visible behaviour, the associated V bits are immediately checked. If any of these indicate that the value is undefined (even partially), an error is reported.</p><h3 id="Valid-address-A-bits"><a href="#Valid-address-A-bits" class="headerlink" title="Valid-address (A) bits"></a>Valid-address (A) bits</h3><h3 id="结合-VV-和-VA"><a href="#结合-VV-和-VA" class="headerlink" title="结合 VV 和 VA"></a>结合 VV 和 VA</h3><h2 id="Debugging-MPI-Parallel-Programs-with-Valgrind"><a href="#Debugging-MPI-Parallel-Programs-with-Valgrind" class="headerlink" title="Debugging MPI Parallel Programs with Valgrind"></a>Debugging MPI Parallel Programs with Valgrind</h2><h1 id="Callgrind"><a href="#Callgrind" class="headerlink" title="Callgrind"></a>Callgrind</h1><p>检查程序中函数调用过程中出现的问题。</p><h1 id="Cachegrind"><a href="#Cachegrind" class="headerlink" title="Cachegrind"></a>Cachegrind</h1><p>检查程序中缓存使用出现的问题。</p><h1 id="Helgrind"><a href="#Helgrind" class="headerlink" title="Helgrind"></a>Helgrind</h1><p>检查多线程程序中出现的竞争问题。</p><h1 id="Massif"><a href="#Massif" class="headerlink" title="Massif"></a>Massif</h1><p>检查程序中堆栈使用中出现的问题。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs" target="_blank" rel="noopener">https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="valgrind" scheme="http://www.calvinneo.com/tags/valgrind/"/>
    
    <category term="工具" scheme="http://www.calvinneo.com/tags/工具/"/>
    
  </entry>
  
  <entry>
    <title>高并发场景</title>
    <link href="http://www.calvinneo.com/2023/01/12/high-concurrency/"/>
    <id>http://www.calvinneo.com/2023/01/12/high-concurrency/</id>
    <published>2023-01-12T15:20:37.000Z</published>
    <updated>2023-01-16T15:49:50.663Z</updated>
    
    <content type="html"><![CDATA[<p>WIP 介绍高并发场景下的 design 和 troubleshotting。</p><p>如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。</p><a id="more"></a><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>这些工具主要是：</p><ol><li>O11y</li></ol><h2 id="Trace-任意函数的执行时间"><a href="#Trace-任意函数的执行时间" class="headerlink" title="Trace 任意函数的执行时间"></a>Trace 任意函数的执行时间</h2><p>该方案整理自某同事的 idea。</p><p>考虑下面的场景，我们需要查看某动态链接库 <code>/path/to/libtiflash_proxy.so</code> 中 <code>handle_pending_applies</code> 函数每次调用的耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perf probe --del <span class="string">'probe_libtiflash_proxy:*'</span></span><br><span class="line">BIN=/path/to/libtiflash_proxy.so</span><br><span class="line">TOKEN=handle_pending_applies</span><br><span class="line">ITER=0</span><br><span class="line">objdump <span class="variable">$BIN</span> --syms | grep <span class="variable">$TOKEN</span> | awk <span class="string">'&#123;print $6&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> -r tok ; <span class="keyword">do</span></span><br><span class="line">    ITER=$(expr <span class="variable">$ITER</span> + 1)</span><br><span class="line">    NAME=<span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$NAME</span>, <span class="variable">$TOKEN</span>, <span class="variable">$ITER</span>, <span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span>%<span class="built_in">return</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">perf record -e probe_libtiflash_proxy:\* -aR sleep 10</span><br><span class="line">perf script -s perf-script.py</span><br></pre></td></tr></table></figure><p><a href="/asset/highconcurrency/perf-script.py">附上 perf-script.py</a></p><h2 id="分析某段时刻的调用栈"><a href="#分析某段时刻的调用栈" class="headerlink" title="分析某段时刻的调用栈"></a>分析某段时刻的调用栈</h2><h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;WIP 介绍高并发场景下的 design 和 troubleshotting。&lt;/p&gt;
&lt;p&gt;如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="高并发" scheme="http://www.calvinneo.com/tags/高并发/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 const 的用法</title>
    <link href="http://www.calvinneo.com/2022/11/20/C++-const/"/>
    <id>http://www.calvinneo.com/2022/11/20/C++-const/</id>
    <published>2022-11-19T16:29:16.000Z</published>
    <updated>2022-11-20T08:08:47.176Z</updated>
    
    <content type="html"><![CDATA[<p>把<a href="/2016/12/22/C++-meta-programming/">文章</a>中的相关部分独立出来。</p><a id="more"></a><h1 id="const不是编译期常量"><a href="#const不是编译期常量" class="headerlink" title="const不是编译期常量"></a>const不是编译期常量</h1><p>在<a href="/2016/12/30/C++%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/">C++初始化方式</a>中已经提到常量<code>const</code>是不能在构造函数体中初始化的，但可以在初始化列表中可以进行初始化，对于常量数组或者标准库的<code>std::vector</code>等容器，现在可以使用花括号<code>{}</code>进行初始化。<br>需要额外说明的是<code>const</code>甚至不能作为模板参数等编译期常量使用。例如在MSVC2015中，下面的代码是无法通过编译的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    C(<span class="keyword">int</span> _x) :x(_x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a[c.x];</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是在<code>C.x</code>虽然是常量，但是要到运行期才能知道，这里应该使用的是<code>static const</code>或者<code>constexpr</code>，<code>const</code>修饰符实际上的意义更接近于<code>readonly</code>。如果说<code>const</code>能够“节省空间”，那是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="noopener">const对象实际上并不发生复制</a>，但只<code>const</code>修饰的类成员仍然是占空间的。</p><h1 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h1><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="noopener">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;文章&lt;/a&gt;中的相关部分独立出来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决 bindgen 的一个奇怪问题</title>
    <link href="http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/"/>
    <id>http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/</id>
    <published>2022-10-31T12:20:33.000Z</published>
    <updated>2023-01-16T15:46:27.391Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。</p><a id="more"></a><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><ol><li>没有问题的版本(旧版本)<br> <a href="https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a" target="_blank" rel="noopener">https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a</a></li><li>有问题的版本(新版本)<br> <a href="https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen" target="_blank" rel="noopener">https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen</a></li></ol><p>具体报错如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Finished dev [unoptimized] target(s) <span class="keyword">in</span> <span class="number">2.51</span>s</span><br><span class="line">     Running `target<span class="regexp">/debug/</span>gen_proxy_ffi`</span><br><span class="line"><span class="string">dyld:</span> Library not <span class="string">loaded:</span> <span class="meta">@rpath</span>/libclang.dylib</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>calvin<span class="regexp">/tidb-engine-ext/</span>target<span class="regexp">/debug/</span>gen_proxy_ffi</span><br><span class="line"><span class="symbol">  Reason:</span> image not found</span><br><span class="line"><span class="string">zsh:</span> abort      cargo run --<span class="keyword">package</span> gen-proxy-ffi --bin gen_proxy_ffi</span><br></pre></td></tr></table></figure><p>首先，这两个版本之间的区别是啥呢？主要两点：</p><ol><li>将 workspace 改成 virtual</li><li>将 cargo dependency 从 path 改成 git</li></ol><p>它们都不涉及 gen-proxy-ffi 这个 crate。</p><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><h2 id="深入了解情况"><a href="#深入了解情况" class="headerlink" title="深入了解情况"></a>深入了解情况</h2><p>“dyld: Library not loaded” 这个错误表示 gen-proxy-ffi 依赖 libclang 这个库，也就是所谓的 clang-sys，并且要在运行期加载，但我们并没有在运行期找到这个库。我们可以通过类似 ldd 的指令来确认这一点。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">otool -L target/debug/gen_proxy_ffi</span><br><span class="line">target/debug/<span class="symbol">gen_proxy_ffi:</span></span><br><span class="line"> @rpath/libclang.dylib (compatibility version <span class="number">1.0</span>.<span class="number">0</span>, current version <span class="number">1205.0</span>.<span class="number">22</span>)</span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libSystem</span>.<span class="title">B</span>.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 1.0.0, <span class="title">current</span> <span class="title">version</span> 1292.100.5)</span></span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libiconv</span>.2.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 7.0.0, <span class="title">current</span> <span class="title">version</span> 7.0.0)</span></span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libresolv</span>.9.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 1.0.0, <span class="title">current</span> <span class="title">version</span> 1.0.0)</span></span><br></pre></td></tr></table></figure><p>从 <a href="https://github.com/rust-lang/rust-bindgen/tree/v0.57.0" target="_blank" rel="noopener">https://github.com/rust-lang/rust-bindgen/tree/v0.57.0</a> 可以看到，这个项目确实依赖 clang-sys</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clang-sys</span> = &#123; version = <span class="string">"1"</span>, features = [<span class="string">"clang_6_0"</span>] &#125;</span><br></pre></td></tr></table></figure><p>所以我们的问题是，为啥旧版本能跑呢？</p><h2 id="通过-unit-graph-分析"><a href="#通过-unit-graph-分析" class="headerlink" title="通过 unit-graph 分析"></a>通过 unit-graph 分析</h2><p>可以通过<code>--unit-graph</code>命令来检查编译时实际的依赖</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">cargo</span> <span class="comment">build</span> <span class="literal">-</span><span class="comment">Z</span> <span class="comment">unstable</span><span class="literal">-</span><span class="comment">options</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">unit</span><span class="literal">-</span><span class="comment">graph</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">package</span> <span class="comment">gen</span><span class="literal">-</span><span class="comment">proxy</span><span class="literal">-</span><span class="comment">ffi</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="comment">gen_proxy_ffi</span></span><br></pre></td></tr></table></figure><p>通过下面的代码可以找到所有的 bindgen。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bindgens = [v <span class="keyword">for</span> v <span class="keyword">in</span> j[<span class="string">'units'</span>] <span class="keyword">if</span> v[<span class="string">'pkg_id'</span>].startswith(<span class="string">"bindgen"</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> bindgens:</span><br><span class="line">    print(x)</span><br><span class="line">    print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>对于旧版本，我们发现有两个 bindgen 的项目。其中一个 bindgen 依赖 index 为 4 和 11 的两个项目，而另一个则不依赖任何项目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">False</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">4</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">11</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'run-custom-build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里很多 extern_crate_name 都是 build_script_build，具体看不出究竟是什么。但可以通过 index 直接对应到 “units” 这个数组的下标。检查发现，其中包含了 clang-sys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">False</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [<span class="string">u'clang_3_5'</span>, <span class="string">u'clang_3_6'</span>, <span class="string">u'clang_3_7'</span>, <span class="string">u'clang_3_8'</span>, <span class="string">u'clang_3_9'</span>, <span class="string">u'clang_4_0'</span>, <span class="string">u'clang_5_0'</span>, <span class="string">u'clang_6_0'</span>], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">12</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'run-custom-build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'clang-sys 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/clang-sys-1.1.1/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2015'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>对于新版本，发现只有一个 bindgen 项目，可以看到它会依赖 clang_sys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="number">4</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">3</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">5</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'bitflags'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">9</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'cexpr'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">10</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'clang_sys'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">18</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'lazy_static'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">19</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'lazycell'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">29</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'peeking_take_while'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">30</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'proc_macro2'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">33</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'quote'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">34</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'regex'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">36</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'rustc_hash'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">38</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'shlex'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'lib'</span>], <span class="string">u'name'</span>: <span class="string">u'bindgen'</span>, <span class="string">u'doc'</span>: <span class="keyword">True</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/src/lib.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">True</span>, <span class="string">u'test'</span>: <span class="keyword">True</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'lib'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>至此可以得出猜测，老版本之所以能运行原因是 gen-proxy-ffi 链接到了不依赖 clang-sys 的 bindgen 上了。</p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>可为什么依赖 clang-sys 的 bindgen 可以实际上不依赖 clang-sys 呢？为此，我们首先怀疑 build.rs，可并没有发现什么异常。</p><p>然后尝试从源码中搜索 clang 关键词，发现了下面的代码。似乎我们可以在代码运行过程中，用类似 dlopen 的方式懒加载 libclang。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"runtime"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ensure_libclang_is_loaded</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> clang_sys::is_loaded() &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX (issue #350): Ensure that our dynamically loaded `libclang`</span></span><br><span class="line">    <span class="comment">// doesn't get dropped prematurely, nor is loaded multiple times</span></span><br><span class="line">    <span class="comment">// across different threads.</span></span><br><span class="line"></span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> LIBCLANG: std::sync::Arc&lt;clang_sys::SharedLibrary&gt; = &#123;</span><br><span class="line">            clang_sys::load().expect(<span class="string">"Unable to find libclang"</span>);</span><br><span class="line">            clang_sys::get_library().expect(</span><br><span class="line">                <span class="string">"We just loaded libclang and it had better still be \</span></span><br><span class="line"><span class="string">                 here!"</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clang_sys::set_library(<span class="literal">Some</span>(LIBCLANG.clone()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是恍然大悟，如果指定让程序懒加载 libclang，但实际上我们又不会真的去用到它，那样老版本代码确实可以这么很苟地运行。因此我们去掉了<code>default-features = false</code>，结果运行正常了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中类型和类型转换</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-type-cast/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-type-cast/</id>
    <published>2022-10-25T12:06:10.000Z</published>
    <updated>2023-01-24T14:20:36.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++ 中的类型转换。<br>部分内容来自<a href="/2016/12/22/C++-meta-programming/">C++元编程</a>。隐式转换部分和重载决议有关，需要结合起来看。</p><a id="more"></a><h1 id="涉及-type-的一些概念"><a href="#涉及-type-的一些概念" class="headerlink" title="涉及 type 的一些概念"></a>涉及 type 的一些概念</h1><h2 id="Incomplete-type"><a href="#Incomplete-type" class="headerlink" title="Incomplete type"></a>Incomplete type</h2><ol><li>void 以及其 cv-qualified 形式</li><li>incompletely-defined object type<br> 一个 class 被声明(比如一个前向声明)，却没有定义。<br> bound 未知的数组。<br> imcomplete type 构成的数组。<br> enum，从它的声明，到它的 underlying type 被确定期间。</li></ol><p>这里说明一下，bound 未知的数组未必是 flex 数组。它可能是如下面这种 extern 形式定义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x[];      <span class="comment">// the type of x is "array of unknown bound of int"</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is "array of 3 int"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure><p>Incomplete type 经常让人头大，需要各种头文件魔法或者 pimpl 来解决。</p><p>在下列情况下，需要类型是 Complete 的：</p><ol><li>TODO</li></ol><h2 id="typd-id"><a href="#typd-id" class="headerlink" title="typd-id"></a>typd-id</h2><p>我们可以通过 class/union/enum/typedef/using(type alias) 这些方式定义一个具名的类型。但是在 C++ 中，我们经常使用那些不具名的类型，例如下面的情况。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is "int (*(*[2])())[3]"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id "void(int)"</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">auto</span>(<span class="keyword">int</span>) -&gt; <span class="keyword">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;); <span class="comment">// type-id is "std::vector&lt;int&gt;"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="keyword">sizeof</span>(struct &#123; <span class="keyword">int</span> x; &#125;);   <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = struct &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">static</span> <span class="keyword">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</span><br></pre></td></tr></table></figure><p>此外，RTTI 机制还提供了一个 typeid 运算符(不是函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>&amp;) != <span class="keyword">typeid</span>(<span class="keyword">int</span>*));</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><p>显式转换有几种类型：</p><p><code>(new-type) expr</code>型。这是 C-style 的，C++ 会按顺序尝试：</p><ol><li>const_cast</li><li>static_cast(增强的)<br> 注意，子类的指针或者引用，可以被转成无歧义的基类，即使基类不可访问。对于成员函数的指针也同样适用</li><li>static_cast(增强的) + const_cast</li><li>reinterpret_cast</li><li>reinterpret_cast + const_cast</li></ol><p><code>new-type (expr)</code>型。</p><p>需要注意，这种 function-style cast expression 容易和声明产生歧义。此时，这些歧义都会被视作声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">M</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">L</span> &#123;</span> L(M&amp;); &#125;;</span><br><span class="line"> </span><br><span class="line">M n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    M(m);    <span class="comment">// declaration, equivalent to M m;</span></span><br><span class="line">    L(n);    <span class="comment">// ill-formed declaration</span></span><br><span class="line">    L(l)(m); <span class="comment">// still a declaration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【C++11起】<code>new-type {expr}</code>型。</p><p>一个显式类型转换的类型是什么呢？</p><ol><li>对于 lvalue reference，结果是一个 lvalue</li><li>对于函数的 rvalue reference，结果是一个 lvalue</li><li>对于 rvalue reference，结果是一个 xvalue</li><li>对于其他情况，结果是一个 prvalue</li></ol><h1 id="Value-categories"><a href="#Value-categories" class="headerlink" title="Value categories"></a>Value categories</h1><p>为了介绍隐式类型转换，介绍<a href="/2017/02/11/C++-rvalue/">Value categories</a>。</p><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>一个隐式类型转换序列包含：</p><ol><li>一系列 standard conversion sequence</li><li>可选的 user-defined conversion</li><li>一系列 standard conversion sequence</li></ol><p><img src="/img/cpp_meta_programming/implicit_conversion_cat11.jpg"></p><p>When considering the argument to a constructor or to a user-defined conversion function, only a standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one non-class type to another non-class type, only a standard conversion sequence is allowed.</p><p>Standard conversion 的顺序：</p><ol><li>zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion;</li><li>zero or one numeric promotion or numeric conversion;</li><li>【C++17】zero or one function pointer conversion;</li><li>zero or one qualification conversion.</li></ol><p>一个 user-defined conversion 由0或1个单参数的类型转换构造函数，或者一个 non-explicit conversion function call 构成。</p><p>An expression e is said to be implicitly convertible to T2 if and only if T2 can be copy-initialized from e, that is the declaration T2 t = e; is well-formed (can be compiled), for some invented temporary t. Note that this is different from direct initialization (T2 t(e)), where explicit constructors and conversion functions would additionally be considered.</p><h2 id="decay"><a href="#decay" class="headerlink" title="decay"></a>decay</h2><p>首先来看一下什么是decay。例如，对于数组<code>T a[n]</code>，除了<code>sizeof</code>、<code>alignof</code>、引用限定符<code>&amp;</code>以及字符串常量等<a href="https://stackoverflow.com/questions/16570716/c-warning-format-s-expects-type-char-but-argument-2-has-type-char" target="_blank" rel="noopener">少数情形</a>外，<code>a</code>出现时会被decay成指向T的指针。例如下面代码往<code>char s[N]</code>数组中读入了数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br></pre></td></tr></table></figure><p>而很多人会误写为以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;s);</span><br></pre></td></tr></table></figure><p>此时，<code>s</code>的类型实际上是<code>char (*) [N]</code>（pointer to an array of char），而<code>scanf</code>希望接受到的是<code>char *</code>（pointer to char）类型。</p><h2 id="各种-convertion-类型"><a href="#各种-convertion-类型" class="headerlink" title="各种 convertion 类型"></a>各种 convertion 类型</h2><h3 id="Contextual-conversions"><a href="#Contextual-conversions" class="headerlink" title="Contextual conversions"></a>Contextual conversions</h3><p>Case1: 【C++11】从 T 到 bool 的转换。如果 <code>bool t(e)</code> 是 well-formed，也就是说存在 <code>explicit T::operator bool() const;</code>。在下列场景中，这样的表达式 e 会被转换为 bool：</p><ol><li>if、while、for 的条件</li><li>逻辑运算符</li><li>三目运算符的条件</li><li>static_assert</li><li>noexcept</li><li>【C++20】explicit 表达式</li></ol><p>Case2: In the following contexts, a context-specific type T is expected, and the expression e of class type E is only allowed if：</p><ol><li>【until C++14】E has a single non-explicit (since C++11) user-defined conversion function to an allowable type.</li><li>【since C++14】对于 E 的所有的 non-explicit conversion functions，如果它们的返回类型是都是 T，或者带 CV 和引用修饰的 T，这样的 e 可以 implicitly convertible to T。</li></ol><p>Such expression e is said to be contextually implicitly converted to the specified type T. 【C++11】Note that explicit conversion functions are not considered, even though they are considered in contextual conversions to bool.</p><ol><li>the argument of the delete-expression (T is any object pointer type);</li><li>integral constant expression, where a literal class is used (T is any integral or unscoped (since C++11) enumeration type, the selected user-defined conversion function must be constexpr);</li><li>the controlling expression of the switch statement (T is any integral or enumeration type).</li></ol><h3 id="Value-transformations"><a href="#Value-transformations" class="headerlink" title="Value transformations"></a>Value transformations</h3><h4 id="Lvalue-to-rvalue-conversion"><a href="#Lvalue-to-rvalue-conversion" class="headerlink" title="Lvalue-to-rvalue conversion"></a>Lvalue-to-rvalue conversion</h4><p>不考虑旧版本，从 C++11 开始说。<br>一个非 function 且非 array 类型的 glvalue T 可以被隐式转换为一个 prvalue。此时：</p><ol><li>如果 T 不是 class type, 那么这个 prvalue 的类型是 T，但会去掉 cv 限定符。</li><li>如果 T 是 class type，那么这个 prvalue 的类型是 T。</li></ol><p>If an lvalue-to-rvalue conversion from an incomplete type is required by a program, that program is ill-formed.</p><p>When an lvalue-to-rvalue conversion is applied to an expression E, the value contained in the referenced object is not accessed if:</p><ol><li>E is not <a href="https://en.cppreference.com/w/cpp/language/expressions#Potentially-evaluated_expressions" target="_blank" rel="noopener">potentially evaluated</a>，也就是它是 unevaluated operand，或者 unevaluated operand 中的子表达式。</li><li>the evaluation of E results in the evaluation of a member Ex of the set of potential results of E, and Ex names a variable x that is not <a href="https://en.cppreference.com/w/cpp/language/definition#ODR-use" target="_blank" rel="noopener">odr-used</a> by Ex.</li></ol><h4 id="Array-to-pointer-conversion"><a href="#Array-to-pointer-conversion" class="headerlink" title="Array-to-pointer conversion"></a>Array-to-pointer conversion</h4><p>An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be implicitly converted to a prvalue of type “pointer to T”.<br>【C++17】If the array is a prvalue, temporary materialization occurs.<br>The resulting pointer refers to the first element of the array (see array to pointer decay for details)</p><h5 id="temporary-materialization"><a href="#temporary-materialization" class="headerlink" title="temporary materialization"></a>temporary materialization</h5><p>A prvalue of any complete type T can be converted to an xvalue of the same type T.<br>This conversion initializes a temporary object of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. </p><p>If T is a class or array of class type, it must have an accessible and non-deleted destructor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> m; &#125;;</span><br><span class="line"><span class="keyword">int</span> i = S().m; <span class="comment">// member access expects glvalue as of C++17;</span></span><br><span class="line">               <span class="comment">// S() prvalue is converted to xvalue</span></span><br></pre></td></tr></table></figure><h4 id="Function-to-pointer-conversion"><a href="#Function-to-pointer-conversion" class="headerlink" title="Function-to-pointer conversion"></a>Function-to-pointer conversion</h4><h3 id="Numeric-promotions"><a href="#Numeric-promotions" class="headerlink" title="Numeric promotions"></a>Numeric promotions</h3><h4 id="Integral-promotion"><a href="#Integral-promotion" class="headerlink" title="Integral promotion"></a>Integral promotion</h4><h4 id="Floating-point-promotion"><a href="#Floating-point-promotion" class="headerlink" title="Floating-point promotion"></a>Floating-point promotion</h4><h3 id="Numeric-conversions"><a href="#Numeric-conversions" class="headerlink" title="Numeric conversions"></a>Numeric conversions</h3><h4 id="Integral-conversions"><a href="#Integral-conversions" class="headerlink" title="Integral conversions"></a>Integral conversions</h4><h4 id="Floating-point-conversions"><a href="#Floating-point-conversions" class="headerlink" title="Floating-point conversions"></a>Floating-point conversions</h4><h4 id="Floating–integral-conversions"><a href="#Floating–integral-conversions" class="headerlink" title="Floating–integral conversions"></a>Floating–integral conversions</h4><h4 id="Pointer-conversions"><a href="#Pointer-conversions" class="headerlink" title="Pointer conversions"></a>Pointer conversions</h4><h4 id="Pointer-to-member-conversions"><a href="#Pointer-to-member-conversions" class="headerlink" title="Pointer-to-member conversions"></a>Pointer-to-member conversions</h4><h4 id="Boolean-conversions"><a href="#Boolean-conversions" class="headerlink" title="Boolean conversions"></a>Boolean conversions</h4><h3 id="Qualification-conversions"><a href="#Qualification-conversions" class="headerlink" title="Qualification conversions"></a>Qualification conversions</h3><h3 id="【C-17】Function-pointer-conversions"><a href="#【C-17】Function-pointer-conversions" class="headerlink" title="【C++17】Function pointer conversions"></a>【C++17】Function pointer conversions</h3><h2 id="重载决议的顺序-rank"><a href="#重载决议的顺序-rank" class="headerlink" title="重载决议的顺序(rank)"></a>重载决议的顺序(rank)</h2><p>在<a href="https://en.cppreference.com/w/cpp/language/overload_resolution" target="_blank" rel="noopener">重载决议</a>时，采取下列顺序，可参考 Ranking of implicit conversion sequences 章节。<br>任何一个 standard conversion sequence 被划分为下面三个 rank：</p><ol><li><p>精确匹配<br> 此时，不需要进行任何的转换。<br> 下面列举出了几种情况：</p><ol><li>无转换</li><li>Lvalue-to-rvalue conversion</li><li>【C++17】function pointer conversion</li><li>user-defined conversion of class type to the same class</li><li>Qualification conversions，即限定符转换<br> 我们可以为任意类型加上CV限定符。对于多重指针来说，前面的重数的限制要高于后面重数的限制，如 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>** p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** p1 = p; <span class="comment">// error: level 2 more cv-qualified but level 1 is not const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> * p2 = p; <span class="comment">// OK: level 2 more cv-qualified and const added at level 1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Promotion<br> 即Numeric promotions，包含Integral promotion和Floating-point promotion<br> 这里注意，<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">非promotion的整数之间转换都作为conversion</a>，如<code>char -&gt; int</code></p></li><li><p>Conversion</p><ol><li>integral conversion</li><li>floating-point conversion</li><li>floating-integral conversion</li><li>pointer conversion</li><li>pointer-to-member conversion</li><li>boolean conversion</li><li>user-defined conversion of a derived class to its base</li></ol></li></ol><p>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to three conversions)</p><p>注意能进行隐式类型转换<strong>并不意味着类型相同</strong>，所以使用<code>std::is_same</code>进行的判断都是false，例如下面的代码输出都是false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/explicit_cast" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/explicit_cast</a></li><li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li><li><a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/type</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++ 中的类型转换。&lt;br&gt;部分内容来自&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;C++元编程&lt;/a&gt;。隐式转换部分和重载决议有关，需要结合起来看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto关键字的用法</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-auto/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-auto/</id>
    <published>2022-10-25T11:06:10.000Z</published>
    <updated>2022-10-25T16:04:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>auto 的作用：</p><ol><li>对于变量，自动推导其类型</li><li>【C++14起】对于函数，自动推导返回值</li><li>【C++17起】对于非类型模板参数，自动推导其类型</li></ol><p>有两种用法<br>【C++11起】auto<br>基于<a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts" target="_blank" rel="noopener">template type deduction</a>进行推导。</p><p>在推导变量类型时，这种推导方式会将每个 auto 出现的地方代换做一个模板参数 U。U 的类型可以从等号左边的 P(<code>下面的const auto&amp;</code>) 和等号右边的 A(下面的<code>1+2</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// P = const U&amp;, A = 1 + 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">const</span> <span class="title">U</span>&amp; <span class="title">u</span>) &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = f(<span class="number">1</span> + <span class="number">2</span>); <span class="comment">// U = int, so the type of x is const int&amp;</span></span><br></pre></td></tr></table></figure><p>特别地，对于 copy-list-initialization 的情况，auto 要被代换为 <code>initializer_list&lt;U&gt;</code>。U 的类型同样可以从 P 和 A 推导出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = &#123;<span class="number">13</span>&#125;; <span class="comment">// P = std::initializer_list&lt;U&gt;, A = &#123;13&#125;:</span></span><br><span class="line">               <span class="comment">// deduced U = int, the type of l is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x1 = &#123;<span class="number">3</span>&#125;; <span class="comment">// x1 is std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对于 direct-list-initialization 的情况，大括号内只允许有一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// error: not a single element</span></span><br><span class="line"><span class="keyword">auto</span> x3&#123;<span class="number">3</span>&#125;;    <span class="comment">// x3 is int</span></span><br><span class="line">               <span class="comment">// (before N3922 x2 and x3 were both std::initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure><p>在推导返回值类型时，同样用模板参数 U 去替换。这个时候 A 就是 return 后面跟的表达式。如果有多个 return，那么它们推导出来必须是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// P = auto, A = 42:</span></span><br><span class="line">                        <span class="comment">// deduced U = int, the return type of f is int</span></span><br></pre></td></tr></table></figure><p>【C++14起】decltype(auto)<br>类型是<code>decltype(expr)</code>，expr 就是用来初始化的表达式。它不走上面的 template type deduction 逻辑。<br>那么这个到底有啥用呢？<a href="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto" target="_blank" rel="noopener">举几个例子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">auto</span> x3a = i;                  <span class="comment">// decltype(x3a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x3d = i;        <span class="comment">// decltype(x3d) is int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x4a = (i);                <span class="comment">// decltype(x4a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x4d = (i);      <span class="comment">// decltype(x4d) is int&amp;</span></span><br></pre></td></tr></table></figure><p>如果一个函数返回右值引用，则其<code>decltype(auto)</code>是右值引用，但<code>auto</code>推导为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x5a = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5a), <span class="keyword">int</span>&gt;::value, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x5b = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5b), <span class="keyword">int</span>&amp;&amp;&gt;::value, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>对于大括号的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x6a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;           <span class="comment">// decltype(x6a) is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x6d = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// error, &#123; 1, 2 &#125; is not an expression</span></span><br></pre></td></tr></table></figure><p>此外，<code>decltype(auto)</code>不能有其他的修饰了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *x7a = &amp;i;                <span class="comment">// decltype(x7a) is int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)*x7d = &amp;i;       <span class="comment">// error, declared type is not plain decltype(auto)</span></span><br></pre></td></tr></table></figure><p>【C++23】auto 可以被用作显式类型转换。如<code>auto (expr)</code>和<code>auto {expr}</code></p><p>注意，在 trailing return type 中，auto 会在开头来开始这个声明。但它同样可以作为 placeholder 出现在尾部，虽然我也不知道意义在哪里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> (*p)() -&gt; <span class="keyword">int</span>; <span class="comment">// declares p as pointer to function returning int</span></span><br><span class="line"><span class="keyword">auto</span> (*q)() -&gt; <span class="keyword">auto</span> = p; <span class="comment">// declares q as pointer to function returning T</span></span><br><span class="line">                         <span class="comment">// where T is deduced from the type of p</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/auto" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/auto</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础机制分析</title>
    <link href="http://www.calvinneo.com/2022/10/15/redis-common/"/>
    <id>http://www.calvinneo.com/2022/10/15/redis-common/</id>
    <published>2022-10-15T15:52:20.000Z</published>
    <updated>2022-10-29T07:34:18.735Z</updated>
    
    <content type="html"><![CDATA[<p>因为原<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：</p><ol><li>redisDb，以及在这上面的增删改查</li><li>Redis的expire和evict机制</li><li>Redis的事件机制</li><li>Redis的主从复制(一部分)<br> 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。<br> 本文介绍的部分比如propagate机制。</li></ol><p>本文中不介绍的是，它们在系列的其他文章中讲解：</p><ol><li>Redis的对象实现</li><li>Redis Sentinel</li><li>Redis Cluster</li><li>Redis AOF/RDB</li></ol><a id="more"></a><h1 id="Redis源码结构"><a href="#Redis源码结构" class="headerlink" title="Redis源码结构"></a>Redis源码结构</h1><p>在3.0版本中，redis的主要结构都定义在redis.h中，在新版本中，它们被放到了server.h中。</p><p>我们主要介绍</p><ol><li>一些常用的类<ol><li>redisServer</li><li>redisDb</li><li>redisObject<br> 包含添加对象的逻辑</li></ol></li><li>删除逻辑<br> 包含对同步删除和异步删除的讨论。</li><li>查找逻辑</li><li>expire</li><li>evict</li><li>propagate</li><li>事件机制</li><li>内存管理</li></ol><h1 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h1><p>这个章节中介绍Redis数据库顶层键的架构和增删改查的实现，主要包括：</p><h2 id="redisDb类"><a href="#redisDb类" class="headerlink" title="redisDb类"></a>redisDb类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间，字典的键为键，字典的值为过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 用来服务诸如BLPOP的命令，记录目前被阻塞的键 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均TTL，统计信息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>可以发现，<code>redisDb</code>本身就依赖<code>dict</code>和<code>list</code>等Redis底层结构的实现，说明Redis的复用性还是很好的。</p><h2 id="client类"><a href="#client类" class="headerlink" title="client类"></a>client类</h2><p>client类对应了3.0版本中的<code>redisClient</code>类。因为Redis对IO是多路复用的，所以需要为每个客户端连接维护一个状态，所以<code>client</code>实际上类似于session一样，是在服务器端维护的一个状态。而真正的Redis客户端定义在redis-cli.c这个文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="keyword">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br></pre></td></tr></table></figure><h2 id="redisServer类"><a href="#redisServer类" class="headerlink" title="redisServer类"></a>redisServer类</h2><p><code>server</code>是一个全局对象，它的类型是<code>redisServer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span> <span class="comment">/* Server global state */</span></span><br></pre></td></tr></table></figure><h1 id="Redis基础类"><a href="#Redis基础类" class="headerlink" title="Redis基础类"></a>Redis基础类</h1><h2 id="增删改查涉及的系统梳理"><a href="#增删改查涉及的系统梳理" class="headerlink" title="增删改查涉及的系统梳理"></a>增删改查涉及的系统梳理</h2><ol><li>DB部分<br> 更新dirty</li><li>Cluster部分</li><li>事件部分<br> signalModifiedKey：包含通知WATCH列表、通知客户端更新缓存<br> notifyKeyspaceEvent：通过PUBLUSH发送消息</li><li>主从复制/持久化部分<br> propagate对应命令（在call中处理）</li><li>Module部分</li></ol><h2 id="Redis-Object"><a href="#Redis-Object" class="headerlink" title="Redis Object"></a>Redis Object</h2><p>诸如<code>dict</code>、<code>sds</code>之类的对象，在db层面实际上是用<code>redisObject</code>封装的，需要的时候通过<code>robj-&gt;ptr</code>获取实际需要的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 由OBJ_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 由OBJ_ENCODING_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure><p>Redis对象的类型是用<code>OBJ_</code>宏来列出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The "module" object type is a special one that signals that the object</span></span><br><span class="line"><span class="comment"> * is one directly managed by a Redis module. In this case the value points</span></span><br><span class="line"><span class="comment"> * to a moduleValue struct, which contains the object value (which is only</span></span><br><span class="line"><span class="comment"> * handled by the module itself) and the RedisModuleType struct which lists</span></span><br><span class="line"><span class="comment"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span></span><br><span class="line"><span class="comment"> * free the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span></span><br><span class="line"><span class="comment"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span></span><br><span class="line"><span class="comment"> * in order to dispatch the loading to the right module, plus a 10 bits</span></span><br><span class="line"><span class="comment"> * encoding version. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br></pre></td></tr></table></figure><p>Redis对象实际使用的内部结构是用<code>OBJ_ENCODING_</code>宏来表示的，如前文所列举的，同一个对象可能有不同的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">// OBJ_ENCODING_RAW是普通的SDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="comment">// embstr是对短字符串的一种优化编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>有两种特殊的引用计数值：</p><ol><li><code>OBJ_SHARED_REFCOUNT</code><br> 由<code>makeObjectShared</code>函数生成，在这种情况下这个对象是immutable的，因此可以不加锁地进行访问。这种对象也不受<code>incrRefCount</code>/<code>decrRefCount</code>控制。<br> 注意，这种对象设为immutable是合理的，它的一个通常作用是共享小整数对象，例如Redis会共享0到9999。</li><li><code>OBJ_STATIC_REFCOUNT</code><br> 一般由<code>initStaticStringObject</code>宏生成。看上去这个一般用在在栈上面分配的临时对象的refcount，我对此也不是很确定。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX     <span class="comment">/* Global object never destroyed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STATIC_REFCOUNT (INT_MAX-1) <span class="comment">/* Object allocated in the stack. */</span></span></span><br><span class="line"><span class="comment">// 第一个有特殊含义的refcount值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT</span></span><br></pre></td></tr></table></figure></li></ol><p>一般来说，使用引用计数可能存在循环引用的问题。Redis巧妙地避免了这个问题，首先在Redis的所有<code>redisObject</code>里面，只有String会被嵌入到其他类型中，也就是说ZSET等其他的数据类型不会互相引用（在Geo等新数据结构里面也是这样的么？）。而Redis对String类型引入对象共享机制，保证了不会产生互相引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt; OBJ_FIRST_SPECIAL_REFCOUNT) &#123;</span><br><span class="line">        o-&gt;refcount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount == OBJ_SHARED_REFCOUNT) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do: this refcount is immutable. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;refcount == OBJ_STATIC_REFCOUNT) &#123;</span><br><span class="line">            serverPanic(<span class="string">"You tried to retain an object allocated in the stack"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decrRefCount</code>还负责销毁对象，步骤是<code>freeXXXObject</code>，然后在<code>zfree</code>。前者用来释放<code>o-&gt;ptr</code>指向的对象的内存，后者用来释放<code>o</code>的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解<code>incr/decrRefCount</code>，如果我们创建或者复制一个对象，就要incr，如果我们要删除一个对象就要decr。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过<code>createObject</code>创建对象，<code>refcount</code>设为1。<code>encoding</code>设为<code>OBJ_ENCODING_RAW</code>，也就是普通SDS字符串。传入的<code>type</code>是<code>OBJ_</code>宏的某个特定值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在创建完对象后，还需要通过<code>dbAdd</code>将它插入到数据库里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the key to the DB. It's up to the caller to increment the reference</span></span><br><span class="line"><span class="comment"> * counter of the value if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The program is aborted if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,retval == DICT_OK);</span><br><span class="line">    signalKeyAsReady(db, key, val-&gt;type);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key-&gt;ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象装箱拆箱"><a href="#对象装箱拆箱" class="headerlink" title="对象装箱拆箱"></a>对象装箱拆箱</h3><p>这个都是返回一个“新”对象，这里“新”的意思是在使用完这个对象都应该<code>decrRefCount</code>。<br>如果是原生encoding储存的，就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果使用SDS保存的整数，实际上里面是个long long，那么就需要先<code>ll2string</code>把这个转换成字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h2><h3 id="redisCommand对象"><a href="#redisCommand对象" class="headerlink" title="redisCommand对象"></a>redisCommand对象</h3><p>redisCommand对象有新旧很多种版本，新旧版本中存在一些区别，例如<code>sflag</code>的内容，我们以新版本为主。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags; <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * 通常用在Redis Cluster转发过程中 */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br></pre></td></tr></table></figure><p>command id，是从0开始递增的，作用是检查ACL。一个connection在执行命令前，服务器先要检查第<code>id</code>位有没有设置，如果设置了，说明这个connection有对应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释如下：</p><ol><li><code>sflags</code>是字符串格式的，表示这个命令的一些特性<br> <a href="https://segmentfault.com/a/1190000017104165" target="_blank" rel="noopener">例如</a>：<br> write对应CMD_WRITE<br> read-only对应CMD_READONLY</li><li><code>flags</code>是通过<code>populateCommandTableParseFlags</code><strong>从<code>sflags</code>生成的二进制表示</strong>。详见server.h中的<code>CMD_</code>定义，我们在下面会讲解。</li><li>下面是key三元组：<code>firstkey</code>表示第一个key参数的位置，<code>lastkey</code>表示最后一个key参数的位置，<code>keystep</code>表示key参数步长。通过上面三个参数，可以拿到所有的key。通常发生在<code>getKeysFromCommand</code>到<code>getKeysUsingCommandTable</code>函数调用链中。引入这个三元组的目的是有一些指令（如<code>mset</code>和<code>msetnx</code>的<code>keystep</code>取2）是支持在一个命令中对多个key/value对进行赋值的。我们需要注意的是诸如<code>ZADD</code>的指令虽然可以同时添加很多个<code>(score, member)</code>对，但是实际上他们是对一个key添加的，所以它们的三元组都是1。</li><li><code>getkeys_proc</code>表示<a href="https://developer.aliyun.com/article/754089" target="_blank" rel="noopener">从命令中判断命令的key</a>，实际上就是当<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>不能描述的时候，就会用到这个，返回一个<code>int*</code>表示所有key。例如后面举的eval的例子。</li><li><code>microseconds</code>表示该命令的调用总时间</li><li><code>calls</code>表示该命令的调用总次数</li><li><code>id</code>是在运行时给每个指令分配的id</li></ol><h4 id="flags枚举"><a href="#flags枚举" class="headerlink" title="flags枚举"></a>flags枚举</h4><p>从sflags可以解析得到flags，枚举如下：</p><ol><li><code>CMD_WRITE (1ULL&lt;&lt;0)</code></li><li><code>CMD_READONLY (1ULL&lt;&lt;1)</code><br> 对应read-only，一般包括所有的非特殊的命令，例如返回keys的值，或者返回一些其他信息，例如TIME等。诸如admin、transaction相关的信息，也不会被标记为readonly，因为他们会影响服务器状态。<br> 只读命令和非只读命令在主从复制时，<a href="https://luoming1224.github.io/2019/04/08/[redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0]redis%E4%B8%ADGeo%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">是不一样的</a>。</li><li><code>CMD_DENYOOM (1ULL&lt;&lt;2)</code><br> 对应use-memory，表示这个命令可能导致内存增加。需要在发生OOM的时候拒绝掉。</li><li><code>CMD_MODULE (1ULL&lt;&lt;3)</code></li><li><code>CMD_ADMIN (1ULL&lt;&lt;4)</code><br> 对应admin，诸如SAVE或者SHUTDOWN的命令。</li><li><code>CMD_PUBSUB (1ULL&lt;&lt;5)</code><br> SUBSCRIBE、UNSUBSCRIBE</li><li><code>CMD_NOSCRIPT (1ULL&lt;&lt;6)</code><br> 这样的命令不能在lua脚本中使用，例如AUTH、SAVE等。</li><li><code>CMD_RANDOM (1ULL&lt;&lt;7)</code><br> 对应random，有的命令即使在相同的情况下的运行结果也是不确定的，诸如SPOP、RANDOMKEY。</li><li><code>CMD_SORT_FOR_SCRIPT (1ULL&lt;&lt;8)</code><br> 对应to-sort，需要对输出序列进行排序。</li><li><code>CMD_LOADING (1ULL&lt;&lt;9)</code><br> 在服务器启动载入过程中可以执行的命令。如果没标记该项目的命令，启动过程中不能执行。</li><li><code>CMD_STALE (1ULL&lt;&lt;10)</code></li><li><code>CMD_SKIP_MONITOR (1ULL&lt;&lt;11)</code><br> no-monitor，不自动将这个命令propagate到MONITOR。</li><li><code>CMD_SKIP_SLOWLOG (1ULL&lt;&lt;12)</code><br> no-slowlog，不自动将这个命令propagate到slowlog。比如EXEC、AUTH之类的命。</li><li><code>CMD_ASKING (1ULL&lt;&lt;13)</code></li><li><code>CMD_FAST (1ULL&lt;&lt;14)</code><br> 这个命令是O(1)或者O(log(N))复杂度的，他们不会延误执行。注意所有可能导致DEL操作的并不是FAST命令，例如SET。</li><li><code>CMD_NO_AUTH (1ULL&lt;&lt;15)</code></li></ol><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>我们结合一个具体的定义来了解这个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"module"</span>,moduleCommand,<span class="number">-2</span>, <span class="comment">// -2表示大于等于2个参数</span></span><br><span class="line">     <span class="string">"admin no-script"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>, <span class="comment">// 这个叫get的指令对应到void getCommand(client *c)，有2个参数</span></span><br><span class="line">     <span class="string">"read-only fast @string"</span>, <span class="comment">// sflags 中是只读的，fast表示命令执行时间超过阈值时，会记录延迟事件。</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// flags</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">// getkeys_proc</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// firstkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// lastkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// keystep</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// microseconds</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// calls</span></span><br><span class="line">     <span class="number">0</span> <span class="comment">// id</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment">     * implicit DEL of a large key. */</span></span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"write use-memory @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"eval"</span>,evalCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"no-script @scripting"</span>,</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     evalGetKeys, <span class="comment">// eval无法通过key三元组描述，所以这里指定一个特殊的getkeys_proc</span></span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">"zadd"</span>,zaddCommand,<span class="number">-4</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @sortedset"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="命令的处理顺序"><a href="#命令的处理顺序" class="headerlink" title="命令的处理顺序"></a>命令的处理顺序</h3><ol><li>call<ol><li>processCommand<ol><li>processCommandAndResetClient<ol><li>processInputBuffer<ol><li>readQueryFromClient</li><li>handleClientsWithPendingReadsUsingThreads</li></ol></li><li>handleClientsWithPendingReadsUsingThreads<ol><li>stopThreadedIO</li><li>beforeSleep</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="processCommand"><a href="#processCommand" class="headerlink" title="processCommand"></a>processCommand</h3><p>这个函数很复杂：</p><ol><li>通过call执行命令</li><li>准备从客户端进行一次读取</li></ol><p>返回<code>C_OK</code>表示这个客户端还存在，否则表示这个客户端没了。</p><p>首先需要特别处理quit命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The QUIT command is handled separately. Normal command procs will</span></span><br><span class="line"><span class="comment">     * go through checking for replication and QUIT will cause trouble</span></span><br><span class="line"><span class="comment">     * when FORCE_REPLICATION is enabled and would be implemented in</span></span><br><span class="line"><span class="comment">     * a regular command proc. */</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面通过<code>lookupCommand</code>查找对应的命令结构，并处理找不到或者命令格式错误的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment"> * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line">c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">    sds args = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; <span class="number">128</span>; i++)</span><br><span class="line">        args = sdscatprintf(args, <span class="string">"`%.*s`, "</span>, <span class="number">128</span>-(<span class="keyword">int</span>)sdslen(args), (<span class="keyword">char</span>*)c-&gt;argv[i]-&gt;ptr);</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"unknown command `%s`, with args beginning with: %s"</span>,</span><br><span class="line">        (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr, args);</span><br><span class="line">    sdsfree(args);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">           (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">        c-&gt;cmd-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断命令的性质，是只读的，还是可写的等性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_write_command = (c-&gt;cmd-&gt;flags &amp; CMD_WRITE) ||</span><br><span class="line">                       (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_WRITE));</span><br><span class="line"><span class="keyword">int</span> is_denyoom_command = (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) ||</span><br><span class="line">                         (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_DENYOOM));</span><br><span class="line"><span class="keyword">int</span> is_denystale_command = !(c-&gt;cmd-&gt;flags &amp; CMD_STALE) ||</span><br><span class="line">                           (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_STALE));</span><br><span class="line"><span class="keyword">int</span> is_denyloading_command = !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING) ||</span><br><span class="line">                             (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_LOADING));</span><br></pre></td></tr></table></figure><p>进行auth和ACL检查。<br>auth也就是登录状态检查。<br>ACL，即Access Control List，有一系列条件规则组成，用来具体控制某些用户是否可以运行某些命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Check if the user is authenticated. This check is skipped in case</span></span><br><span class="line"><span class="comment">     * the default user is flagged as "nopass" and is active. */</span></span><br><span class="line">    <span class="keyword">int</span> auth_required = (!(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) ||</span><br><span class="line">                          (DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED)) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    <span class="keyword">if</span> (auth_required) &#123;</span><br><span class="line">        <span class="comment">/* AUTH and HELLO and no auth modules are valid even in</span></span><br><span class="line"><span class="comment">         * non-authenticated state. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;cmd-&gt;flags &amp; CMD_NO_AUTH)) &#123;</span><br><span class="line">            rejectCommand(c,shared.noautherr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the user can run this command according to the current</span></span><br><span class="line"><span class="comment">     * ACLs. */</span></span><br><span class="line">    <span class="keyword">int</span> acl_keypos;</span><br><span class="line">    <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">    <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">        addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval == ACL_DENIED_CMD)</span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to run "</span></span><br><span class="line">                <span class="string">"the '%s' command or its subcommand"</span>, c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to access "</span></span><br><span class="line">                <span class="string">"one of the keys used as arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果启用了Redis Cluster，就要进行转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* If cluster is enabled perform the cluster redirection here.</span></span><br><span class="line"><span class="comment">     * However we don't perform the redirection if:</span></span><br><span class="line"><span class="comment">     * 1) The sender of this command is our master.</span></span><br><span class="line"><span class="comment">     * 2) The command has no key arguments. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hashslot;</span><br><span class="line">        <span class="keyword">int</span> error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>处理oom相关行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Handle the maxmemory directive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we do not want to reclaim memory if we are here re-entering</span></span><br><span class="line"><span class="comment">     * the event loop since there is a busy Lua script running in timeout</span></span><br><span class="line"><span class="comment">     * condition, to avoid mixing the propagation of scripts with the</span></span><br><span class="line"><span class="comment">     * propagation of DELs due to eviction. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="keyword">int</span> out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;</span><br><span class="line">        <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span></span><br><span class="line"><span class="comment">         * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> reject_cmd_on_oom = is_denyoom_command;</span><br><span class="line">        <span class="comment">/* If client is in MULTI/EXEC context, queuing may consume an unlimited</span></span><br><span class="line"><span class="comment">         * amount of memory, so we want to stop that.</span></span><br><span class="line"><span class="comment">         * However, we never want to reject DISCARD, or even EXEC (unless it</span></span><br><span class="line"><span class="comment">         * contains denied commands, in which case is_denyoom_command is already</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != execCommand &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != discardCommand) &#123;</span><br><span class="line">            reject_cmd_on_oom = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save out_of_memory result at script start, otherwise if we check OOM</span></span><br><span class="line"><span class="comment">         * untill first write within script, memory used by lua stack and</span></span><br><span class="line"><span class="comment">         * arguments might interfere. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == evalCommand || c-&gt;cmd-&gt;proc == evalShaCommand) &#123;</span><br><span class="line">            server.lua_oom = out_of_memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use a reasonable amount of memory for client side</span></span><br><span class="line"><span class="comment">     * caching metadata. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.tracking_clients) trackingLimitUsedSlots();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are problems persisting on disk</span></span><br><span class="line"><span class="comment">     * and if this is a master instance. */</span></span><br><span class="line">    <span class="keyword">int</span> deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">    <span class="keyword">if</span> (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span><br><span class="line">        server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (is_write_command ||c-&gt;cmd-&gt;proc == pingCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deny_write_type == DISK_ERROR_TYPE_RDB)</span><br><span class="line">            rejectCommand(c, shared.bgsaveerr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-MISCONF Errors writing to the AOF file: %s"</span>,</span><br><span class="line">                strerror(server.aof_last_write_errno));</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are not enough good slaves and</span></span><br><span class="line"><span class="comment">     * user configured the min-slaves-to-write option. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_to_write &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_max_lag &amp;&amp;</span><br><span class="line">        is_write_command &amp;&amp;</span><br><span class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.noreplicaserr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if this is a read only slave. But</span></span><br><span class="line"><span class="comment">     * accept write commands if this is our master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        is_write_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.roslaveerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow a subset of commands in the context of Pub/Sub if the</span></span><br><span class="line"><span class="comment">     * connection is in RESP2 mode. With RESP3 there are no limits. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp; c-&gt;resp == <span class="number">2</span>) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</span><br><span class="line">        rejectCommandFormat(c,</span><br><span class="line">            <span class="string">"Can't execute '%s': only (P)SUBSCRIBE / "</span></span><br><span class="line">            <span class="string">"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow commands with flag "t", such as INFO, SLAVEOF and so on,</span></span><br><span class="line"><span class="comment">     * when slave-serve-stale-data is no and we are a slave with a broken</span></span><br><span class="line"><span class="comment">     * link with master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        server.repl_serve_stale_data == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_denystale_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.masterdownerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loading DB? Return an error if the command has not the</span></span><br><span class="line"><span class="comment">     * CMD_LOADING flag. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; is_denyloading_command) &#123;</span><br><span class="line">        rejectCommand(c, shared.loadingerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lua script too slow? Only allow a limited number of commands.</span></span><br><span class="line"><span class="comment">     * Note that we need to allow the transactions commands, otherwise clients</span></span><br><span class="line"><span class="comment">     * sending a transaction with pipelining without error checking, may have</span></span><br><span class="line"><span class="comment">     * the MULTI plus a few initial commands refused, then the timeout</span></span><br><span class="line"><span class="comment">     * condition resolves, and the bottom-half of the transaction gets</span></span><br><span class="line"><span class="comment">     * executed, see Github PR #7022. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != multiCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != unwatchCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'n'</span>) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'k'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.slowscripterr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面才是真正的执行，对于非multi，会调用call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code>就是调用指令的函数，有一系列的flag：</p><ol><li><code>CMD_CALL_NONE</code></li><li><code>CMD_CALL_SLOWLOG</code><br> 检查指令执行的速度，是否记录到slow log中呢？</li><li><code>CMD_CALL_STATS</code><br> Populate command stats.</li><li><code>CMD_CALL_PROPAGATE_AOF</code><br> 如果对数据有改动（可以通过<code>server.dirty</code>字段看出），或者client有一个强迫propagate的<code>CLIENT_FORCE_AOF</code>，就加到AOF上。<br> 相应的，如果client设置了<code>CLIENT_PREVENT_AOF_PROP</code>，那么即使数据集变动了，也不会写AOF。<br> 注意，无论client设置了什么，如果没有<code>CMD_CALL_PROPAGATE_AOF</code>，那么永远不会写AOF。</li><li><code>CMD_CALL_PROPAGATE_REPL</code><br> 同理，但是对Slave。同样有<code>CLIENT_FORCE_REPL</code>/<code>CLIENT_PREVENT_REPL_PROP</code>。</li><li><code>CMD_CALL_PROPAGATE</code><br> 相当于<code>PROPAGATE_AOF|PROPAGATE_REPL</code></li><li><code>CMD_CALL_FULL</code><br> 相当于<code>SLOWLOG|STATS|PROPAGATE</code></li></ol><p><code>call</code>主要就是用<code>c-&gt;cmd-&gt;proc(c)</code>执行命令，后者实际上就是<code>xxxCommand()</code>这样的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="keyword">ustime_t</span> start, duration;</span><br><span class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">real_cmd</span> = <span class="title">c</span>-&gt;<span class="title">cmd</span>;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>fixed_time_expire</code>在expire机制中见到过的，如果有命令在执行过程中，这个值就不是0。<br>还会把除了ADMIN之外的命令发送给MONITOR，ADMIN命令展示出来太危险了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.fixed_time_expire++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the command to clients in MONITOR mode if applicable.</span></span><br><span class="line"><span class="comment">     * Administrative commands are considered too dangerous to be shown. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些初始化和执行工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Initialization: clear the flags that must be set by the command on</span></span><br><span class="line"><span class="comment">     * demand, and initialize the array for additional commands propagation. */</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    redisOpArray prev_also_propagate = server.also_propagate;</span><br><span class="line">    redisOpArrayInit(&amp;server.also_propagate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the command. */</span></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    updateCachedTime(<span class="number">0</span>);</span><br><span class="line">    start = server.ustime;</span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在执行后，统计数据库被修改的次数<code>dirty</code>。在<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>中看到，比如我新加一个元素，或者修改一个元素，都会导致<code>dirty</code>增加。也就对应了数据的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    duration = ustime()-start;</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When EVAL is called loading the AOF we don't want commands called</span></span><br><span class="line"><span class="comment">     * from Lua to go into the slowlog or to populate statistics. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span><br><span class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the caller is Lua, we want to force the EVAL caller to propagate</span></span><br><span class="line"><span class="comment">     * the script if the command flag or client flag are forcing the</span></span><br><span class="line"><span class="comment">     * propagation. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>记录延迟信息，并记录slowlog。其中<code>latencyAddSampleIfNeeded</code>在适当的时候调用<code>latencyAddSample</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Log the command into the Slow log if needed, and populate the</span></span><br><span class="line"><span class="comment">     * per-command statistics that we show in INFO commandstats. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_SKIP_SLOWLOG)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_STATS) &#123;</span><br><span class="line">        <span class="comment">/* use the real command that was executed (cmd and lastamc) may be</span></span><br><span class="line"><span class="comment">         * different, in case of MULTI-EXEC or re-written commands such as</span></span><br><span class="line"><span class="comment">         * EXPIRE, GEOADD, etc. */</span></span><br><span class="line">        real_cmd-&gt;microseconds += duration;</span><br><span class="line">        real_cmd-&gt;calls++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理propagate的情况，这个对应了<code>CALL_</code>开头的一些规则，就不详解了。最终会计算得到一个<code>propagate_flags</code>传给<code>propagate</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">         * set for replication / AOF propagation. */</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">         * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* However prevent AOF / replication propagation if the command</span></span><br><span class="line"><span class="comment">         * implementations called preventCommandPropagation() or similar,</span></span><br><span class="line"><span class="comment">         * or if we don't have the call() flags to do so. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">         * propagation is needed. Note that modules commands handle replication</span></span><br><span class="line"><span class="comment">         * in an explicit way, so we never replicate them automatically. */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在结束之后，我们需要还原一下有关propagate的相关flag，因为<code>call</code>可能被递归调用。<br>【Q】我觉得这里一个典型的例子就是这里的multi、exec。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Restore the old replication flags, since call() can be executed</span></span><br><span class="line"><span class="comment"> * recursively. */</span></span><br><span class="line">c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">    (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br></pre></td></tr></table></figure><p><code>alsoPropagate</code>函数可以往<code>server.also_propagate</code>里面加一些其他的op。下面就处理<code>alsoPropagate</code>的逻辑，也就是当propagate完当前的命令之后，还可以再去propagate一些命令。并且这些命令不被<code>CLIENT_PREVENT_PROP</code>影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.also_propagate.numops) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    redisOp *rop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">        <span class="keyword">int</span> multi_emitted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果说已经被包在了MULTI里面，就不在继续包在<code>also_propagate</code>里面propagate了。<br><code>execCommandPropagateMulti</code>实际上就是下面的propagate调用。这里的<code>shared.multi</code>或者<code>shared.exec</code>实际上是缓存的字符串对象<code>EXEC</code>和<code>MULTI</code>，减少频繁的内存分配的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateMulti</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.multiCommand,c-&gt;db-&gt;id,&amp;shared.multi,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateExec</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.execCommand,c-&gt;db-&gt;id,&amp;shared.exec,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是做propagate。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="comment">/* Wrap the commands in server.also_propagate array,</span></span><br><span class="line"><span class="comment">             * but don't wrap it if we are already in MULTI context,</span></span><br><span class="line"><span class="comment">             * in case the nested MULTI/EXEC.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * And if the array contains only one command, no need to</span></span><br><span class="line"><span class="comment">             * wrap it, since the single command is atomic. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.also_propagate.numops &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE) &amp;&amp;</span><br><span class="line">                !(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span><br><span class="line">                !(flags &amp; CMD_CALL_NOWRAP))</span><br><span class="line">            &#123;</span><br><span class="line">                execCommandPropagateMulti(c);</span><br><span class="line">                multi_emitted = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">                rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">                <span class="keyword">int</span> target = rop-&gt;target;</span><br><span class="line">                <span class="comment">/* Whatever the command wish is, we honor the call() flags. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">                <span class="keyword">if</span> (target)</span><br><span class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (multi_emitted) &#123;</span><br><span class="line">                execCommandPropagateExec(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line">    &#125;</span><br><span class="line">    server.also_propagate = prev_also_propagate;</span><br></pre></td></tr></table></figure><p>这个应该是和客户端缓存有关的，如果client提供了keys tracking功能，要通知。这个函数里面维护了一个tracking invalidation表，这样客户端会收到一个invalidation信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* If the client has keys tracking enabled for client side caching,</span></span><br><span class="line"><span class="comment">     * make sure to remember the keys it fetched via this command. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">        client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                            server.lua_caller : c;</span><br><span class="line">        <span class="keyword">if</span> (caller-&gt;flags &amp; CLIENT_TRACKING &amp;&amp;</span><br><span class="line">            !(caller-&gt;flags &amp; CLIENT_TRACKING_BCAST))</span><br><span class="line">        &#123;</span><br><span class="line">            trackingRememberKeys(caller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.fixed_time_expire--;</span><br><span class="line">    server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除逻辑实现"><a href="#删除逻辑实现" class="headerlink" title="删除逻辑实现"></a>删除逻辑实现</h1><p>为了理解下面论述中涉及到的expire相关实现，我们需要先介绍一些<code>UNLINK</code>和<code>DEL</code>的实现。<br>delGenericCommand的实现是比较Legacy的，从<code>c-&gt;argv</code>中读取所有需要被删除的key，然后调用dbAsyncDelete或者dbSyncDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>容易发现，删除有两种模式：异步(lazy)删除和同步删除。异步删除的情况包括：</p><ol><li>delete逻辑<ol><li><code>delGenericCommand</code>中传入lazy<br> 如果是unlink命令，那么一定是异步删除。<br> 如果是del命令，则取决于<code>server.lazyfree_lazy_user_del</code>。</li><li><code>dbDelete</code>中设置了<code>server.lazyfree_lazy_server_del</code></li></ol></li><li>expire逻辑<ol><li><code>expireIfNeeded</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应了Redis的lazy过期策略。</li><li><code>activeExpireCycleTryExpire</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应着Redis的定期循环，主动过期策略。</li><li><code>expireGenericCommand</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 直接运行expire命令，主动检查一下有没有过期。</li></ol></li><li>evict逻辑<ol><li><code>freeMemoryIfNeeded</code>中如果设置<code>server.lazyfree_lazy_eviction</code>，则使用异步删除</li></ol></li><li>其他<ol><li><code>RM_UnlinkKey</code></li></ol></li></ol><p>这些<code>lazyfree_lazy_</code>开头的配置，默认都是0。也就是说这些情况下默认都是同步删除。</p><p>同步删除的情况类似，除了“其他”中发生了变化：</p><ol><li>其他<ol><li><code>rdbLoadRio</code></li></ol></li></ol><p>下面的代码会进行事件通知，我们将专门进行介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【续】delGenericCommand函数</span></span><br><span class="line">...</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>del和unlink的唯一区别是，unlink一定是lazy删除的，但是del取决于配置<code>lazyfree_lazy_user_del</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlinkCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步删除"><a href="#同步删除" class="headerlink" title="同步删除"></a>同步删除</h2><p>看简单的同步实现。<br>首先，如果<code>db-&gt;expires</code>非空，从<code>db-&gt;expires</code>里面删除<code>key</code>，实际上是删除的过期时间。<br>这里有个注释，说从<code>db-&gt;expires</code>中删除一个entry不会释放<code>key-&gt;ptr</code>这个sds，因为它和<code>db-&gt;dict</code>是共享的。这里应该说的是在<code>setExpire</code>里面往<code>db-&gt;expires</code>添加key的时候，加的实际上是指向<code>db-&gt;dict</code>中的指针。<br>但果真是这样的么？继续看<code>dictDelete</code>最终调用<code>dictGenericDelete</code>。查看<code>dictDelete</code>实际上是<code>dictGenericDelete</code>的实现(在“dict的其他相关方法”这个章节中介绍)，发现新版本的代码肯定会调用<code>dictFreeKey</code>(Redis3.0里面有个<code>dictFreeEntryKey</code>，不要混淆了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>检查dictFreeKey的实现发现，这个函数调用<code>keyDestructor</code>，它似乎一定会导致对应sds的析构。看上去和上面的注释是矛盾的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br></pre></td></tr></table></figure><p>究竟是怎么回事呢？我们看下keyptrDictType和dbDictType这两个dict类型就有了答案。原来对于<code>db-&gt;expires</code>，它实际的类型就没有设置keyDestructor，所以不会析构key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line">server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;expires */</span></span><br><span class="line">dictType keyptrDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></span><br><span class="line">dictType dbDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></span><br><span class="line">    dictObjectDestructor   <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以说一下<code>#define DICT_NOTUSED(V) ((void) V)</code>是经典的关闭编译器unused variable warning的办法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSdsDestructor</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接着看<code>dbSyncDelete</code>的逻辑，刚才是删除的<code>db-&gt;expires</code>，还需要删除<code>db-&gt;dict</code>。<br>此外<code>server.cluster_enabled</code>的情况进行了额外的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再从db-&gt;dict里面删除key</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// Redis Cluster相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h2><p>异步删除的核心是调用<code>dictUnlink</code>而不是<code>dictDelete</code>。<br>前面的是大差不差的，删除<code>db-&gt;expires</code>里面的字段，因为他们的dictType不一样，他们的析构行为(<code>keyDestructor</code>)也不一样。这就导致expire可以直接dictDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazyfree.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB.</span></span><br><span class="line"><span class="comment"> * If there are enough allocations to free the value object may be put into</span></span><br><span class="line"><span class="comment"> * a lazy free list instead of being freed synchronously. The lazy free list</span></span><br><span class="line"><span class="comment"> * will be reclaimed in a different bio.c thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面调用<code>dictUnlink</code>而不是<code>dictDelete</code>了。这里注意区别一下<code>dictUnlink</code>和前面提到的UNLINK命令。<code>dictUnlink</code>的作用是将对应的key从dict中删除，但不会释放对应的结构，而是直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>拿到这个<code>de</code>，我们手动来析构。会首先使用<code>lazyfreeGetFreeEffort</code>来计算析构的代价，如果代价过高，就将这个对象放到lazy free list里面让它后台去析构。不然的话就在后面的代码中同步析构，这是因为如果对象很小，那么再搞这一套异步反而更耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先来看lazy的实现，如果算出来值得，那么就lazy。但这里还有个特殊情况我们不能异步删除，根据注释，如果这个对象是被共享的(<code>val-&gt;refcount</code>就是一个大于1的值)，我们不能就直接把它现在就回收掉。这个倒不经常发生，但确实Redis的一些实现代码会用<code>incrRefCount</code>来保护对象，然后调用<code>dbDelete</code>。在这种情况下我们会fall through到下面<code>dictFreeUnlinkedEntry</code>的调用，它的最终效果相当于直接调用<code>decrRefCount</code>。<br>经过了上述的判断，我们就可以使用bioCreateBackgroundJob来异步删除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就是同步删除的实现。<code>dictFreeUnlinkedEntry</code>这一块就是给之前<code>nofree</code>没做的事情擦一下屁股，包含调用<code>dictFreeKey</code>啥的来释放key和value所占用的内存。<br><code>slotToKeyDel</code>这个是Redis Cluster的实现逻辑，用来算出来这个key在哪个slot上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    zfree(he);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及的几个函数来讲解一下</p><h3 id="lazyfreeGetFreeEffort"><a href="#lazyfreeGetFreeEffort" class="headerlink" title="lazyfreeGetFreeEffort"></a>lazyfreeGetFreeEffort</h3><p>这个函数计算并返回释放一个对象的代价。返回值不一定是这个对象对应的内存分配次数，但是和这个量成比例的。具体来说：</p><ol><li>对于字符串，函数永远返回1。</li><li>对于用诸如哈希表等数据结构表示的聚合对象，返回组成该对象元素的数量。</li><li>对于只需要一次内存分配就产生的对象，认为是独立的一个对象，即使实际上是由多个造成的。</li><li>对于列表对象，返回quicklist里面的元素数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> lazyfreeGetFreeEffort(robj *obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">        quicklist *ql = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> ql-&gt;len;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_SET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br></pre></td></tr></table></figure><p>对于ZSET，如果是跳表实现，就返回跳表的长度。如果是ziplist实现就返回1？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_ZSET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_SKIPLIST)&#123;</span><br><span class="line">        zset *zs = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> zs-&gt;zsl-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_HASH &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_STREAM) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> effort = <span class="number">0</span>;</span><br><span class="line">        stream *s = obj-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make a best effort estimate to maintain constant runtime. Every macro</span></span><br><span class="line"><span class="comment">         * node in the Stream is one allocation. */</span></span><br><span class="line">        effort += s-&gt;rax-&gt;numnodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Every consumer group is an allocation and so are the entries in its</span></span><br><span class="line"><span class="comment">         * PEL. We use size of the first group's PEL as an estimate for all</span></span><br><span class="line"><span class="comment">         * others. */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;cgroups) &#123;</span><br><span class="line">            raxIterator ri;</span><br><span class="line">            streamCG *cg;</span><br><span class="line">            raxStart(&amp;ri,s-&gt;cgroups);</span><br><span class="line">            raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* There must be at least one group so the following should always</span></span><br><span class="line"><span class="comment">             * work. */</span></span><br><span class="line">            serverAssert(raxNext(&amp;ri));</span><br><span class="line">            cg = ri.data;</span><br><span class="line">            effort += raxSize(s-&gt;cgroups)*(<span class="number">1</span>+raxSize(cg-&gt;pel));</span><br><span class="line">            raxStop(&amp;ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> effort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Everything else is a single allocation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="atomicIncr"><a href="#atomicIncr" class="headerlink" title="atomicIncr"></a>atomicIncr</h3><p>是一个原子操作，更新lazyfree里面的一个static变量<code>lazyfree_objects</code>。根据不同的操作系统的支持，有三种实现：<br>如果支持atomic语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><p>如果有sync语义，一般是gcc的一个内置宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __sync_add_and_fetch(&amp;var,(count))</span></span><br></pre></td></tr></table></figure><p>如果什么都没有，用mutex，mutex的名字是变量名加上<code>_mutex</code>，这些mutex随着变量名一起被定义，只是可能不会被用到，如lazyfree_objects_mutex。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</span><br><span class="line">    var += (count); \</span><br><span class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="bioCreateBackgroundJob"><a href="#bioCreateBackgroundJob" class="headerlink" title="bioCreateBackgroundJob"></a>bioCreateBackgroundJob</h3><p>所有的bio开头的函数表示Redis的Background IO服务。根据注释，将来也许会迁移到libeio。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictSetVal"><a href="#dictSetVal" class="headerlink" title="dictSetVal"></a>dictSetVal</h3><p>见dict相关</p><h3 id="slotToKeyDel"><a href="#slotToKeyDel" class="headerlink" title="slotToKeyDel"></a>slotToKeyDel</h3><p>见 Redis Cluster 相关</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>lookUpKey相关方法根据查找目的是读或者写区分了<code>lookupKeyRead</code>、<code>lookupKeyWrite</code>两个方向的函数，此外还根据是否<code>WithFlags</code>或者<code>OrReply</code>派生出其他几种函数。</p><p>对于<code>lookupKeyWrite</code>来讲，有一个副作用，就是会先检查一下要不要expire，如果需要就直接expire掉。<br>对于<code>lookupKeyRead</code>来讲，也要处理expire的问题，但是因为涉及到主从复制的问题，所以要进行额外处理。【Q】为什么不需要对写处理呢？我想应该是因为只有Master处理写，处理完再发指令给Slave。</p><p>直接介绍带Flags的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WithFlags</code>目前只包含了<code>LOOKUP_NONE</code>和<code>LOOKUP_NOTOUCH</code>两个选项。：</p><ol><li><code>LOOKUP_NONE</code></li><li><code>LOOKUP_NOTOUCH</code><br> 表示这次访问不要更新LRU啥的，例如type这样的命令就带上这个参数。</li></ol><h2 id="lookupKeyReadWithFlags"><a href="#lookupKeyReadWithFlags" class="headerlink" title="lookupKeyReadWithFlags"></a>lookupKeyReadWithFlags</h2><p>下面查看<code>lookupKeyReadWithFlags</code>的实现，相比于写要复杂点，因为要处理键过期的时候读的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Master的<code>masterhost</code>肯定是NULL，这是一个经典判定。首先考虑Master的情况，如果key过期了，那么就直接安全地返回NULL，并且触发一个keymiss事件。这里注释上说在Master情况下，<code>expireIfNeeded</code>返回0当且只当这个key不存在。<br>为什么强调Master呢，实际上可以结合<code>expireIfNeeded</code>的实现来看。提前说一下，<strong>对Slave而言</strong>，<code>expireIfNeeded</code>并<strong>不会真的让key过期并删除</strong>，而只是返回key在逻辑上是过期的，而真正的过期是由Master来同步的，其目的是保持Slave和Master的一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Key expired. If we are in the context of a master, expireIfNeeded()</span></span><br><span class="line"><span class="comment">         * returns 0 only when the key does not exist at all, so it's safe</span></span><br><span class="line"><span class="comment">         * to return NULL ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更新统计信息，<code>server.stat_keyspace_misses</code>可以通过<code>INFO keyspace_misses</code>命令来查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是对Master情况的处理，下面是对Slave的情况。我们已经知道，Slave并不会真的删除过期key，而是等待Master的Del指令。所以即使<code>expireIfNeeded</code>返回1表示过期，<br>但根据注释，对Slave而言，作为一个额外的安全措施，如果相关指令是只读的，还是可以在这里安全地返回NULL。Redis的说法是：对于只读命令，这样可以向client提供一个更加一致性的行为。这个会包含GETS，当使用Slave来扩容读的时候。我的理解就是尽管slave上还没有删除，但是过期就是过期，我们要和Master一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookupKeyWriteWithFlags"><a href="#lookupKeyWriteWithFlags" class="headerlink" title="lookupKeyWriteWithFlags"></a>lookupKeyWriteWithFlags</h2><p>首先查看<code>lookupKeyWriteWithFlags</code>的实现，直接先检查下expire，然后调用<code>lookupKey</code>。这里的<code>expireIfNeeded</code>也是Redis的lazy过期策略的实现，在每次查找的时候都会调用，检查这个键是不是已经过期了。<br>不同于<code>lookupKeyReadWithFlags</code>，这里就不会统计keymiss啥的了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookUpKey"><a href="#lookUpKey" class="headerlink" title="lookUpKey"></a>lookUpKey</h2><p><code>lookUpKey</code>的主要内容包括从db里面找到对应的key，并且维护LRU或LFU。它是一个较为底层的 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从db中获得key对应的entry</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了，就取出val</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有设置</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是LRU和LFU的实现，更新每个key的访问情况，从而方便后续evict。详细见有关updateLFU的实现见”Redis的LRU和LFU实现”这一章节。<br>但先要做一些判断：</p><ol><li>如果设置了<code>LOOKUP_NOTOUCH</code>。</li><li>如果有子进程正在进行保存，就不进行LFU操作，以免破坏COW。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h1><h2 id="如何判断键已过期？"><a href="#如何判断键已过期？" class="headerlink" title="如何判断键已过期？"></a>如何判断键已过期？</h2><p>诸如<code>EXPIRE</code>/<code>RENAME</code>等的实现中会调用<code>setExpire</code>函数设置过期时间。<code>setExpire</code>会把每个键的过期时间都被存在<code>db-&gt;expires</code>这个字典里面。<br>通过<code>getExpire</code>可以从字典中读取到过期时间。</p><h3 id="getExpire"><a href="#getExpire" class="headerlink" title="getExpire"></a>getExpire</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the expire time of the specified key, or -1 if no expire</span></span><br><span class="line"><span class="comment"> * is associated with this key (i.e. the key is non volatile) */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keyIsExpired"><a href="#keyIsExpired" class="headerlink" title="keyIsExpired"></a>keyIsExpired</h3><p>keyIsExpired作用是判断某个键有没有过期。主要功能就是比较现在的时间，和获得的key的过期时间。被expireIfNeeded调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面一段代码的目的是：如果在执行lua脚本，将时间设置成脚本执行开始的时间，这样在脚本执行过程中就不会expire。这么做的原因是源自Github上面的<a href="https://github.com/redis/redis/issues/1525" target="_blank" rel="noopener">Issue1525</a>。作者发现这个脚本在Master和Slave上的执行是不一样的。原因是在Master上第一次执行可能key存在，第二次就不存在了。这导致<code>incr</code>实际只被执行了一次。但是因为此时Master会合成一个DEL指令，让Slave也删除并过期这个Key。此时，如果相同的脚本运行在Slave上面，那么<code>incr</code>一次也不会被执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保障向Slave和AOF的propagate是一致的，首先在执行lua脚本的时候，要禁止expire(就是这里的行为)；但是在执行脚本之前，先要对涉及的key做下<code>expireIfNeeded</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are in the middle of a command execution, we still want to use</span></span><br><span class="line"><span class="comment">     * a reference time that does not change: in that case we just use the</span></span><br><span class="line"><span class="comment">     * cached time, that we update before each call in the call() function.</span></span><br><span class="line"><span class="comment">     * This way we avoid that commands such as RPOPLPUSH or similar, that</span></span><br><span class="line"><span class="comment">     * may re-open the same key multiple times, can invalidate an already</span></span><br><span class="line"><span class="comment">     * open object in a next call, if the next call will see the key expired,</span></span><br><span class="line"><span class="comment">     * while the first did not. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For the other cases, we want to use the most fresh time we have. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key expired if the current (virtual or real) time is greater</span></span><br><span class="line"><span class="comment">     * than the expire time of the key. */</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="expireIfNeeded"><a href="#expireIfNeeded" class="headerlink" title="expireIfNeeded"></a>expireIfNeeded</h2><p><code>expireIfNeeded</code>用来删除过期的键，它是<strong>被动expire</strong>的关键步骤。返回0表示键有效(键未过期，或永不过期)，否则返回1表示已经过期并被删除。<br>对于Master，如果找到的键是expire的，会被从数据库中evict掉。并且会导致想AOF和Slave流propagate一条DEL或者UNLINK指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>如果没有过期，就返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先，通过<code>keyIsExpired</code>检测是不是已经过期了，如果还没有过期，上面就直接返回0了，再往下就是处理过期的情况。<br>根据注释，如果Redis运行在主从模式下，并且是在Slave上，<code>expireIfNeeded</code>直接返回，而不是继续删除键。这是因为Slave上的key过期是由Master控制的，Slave并不直接处理key的过期。Master会发送一个同步的<code>DEL</code>命令给Slave来删除某个键，Slave等到那时候再删除，<strong>这样做的目的是出于一致性的考量</strong>。<br>但尽管如此，对Slave调用<code>expireIfNeeded</code>也应该返回一个正确的值，也就是这个时候键应不应该过期。因此，Slave上是先过期，然后再删除键的，这其中存在一个窗口时间，因为Slave还没有来得及收到并处理Master的<code>DEL</code>。<br>下面肯定对应了已经过期的情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面负责通知删除事件，这里还出现了<code>propagateExpire</code>函数，我们也统一在后面讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 向AOF文件和Slave节点传播过期信息，实际会调用propagate函数</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是真正的过期删除的过程。这里根据<code>server.lazyfree_lazy_expire</code>的配置，可以选择异步删除或者同步删除，这类似于上面讨论过的<code>UNLINK</code>和<code>DEL</code>的实现。事实上在<code>expireGenericCommand</code>上就可以看到对应的映射关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);     </span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主动expire实现"><a href="#主动expire实现" class="headerlink" title="主动expire实现"></a>主动expire实现</h2><p>在<code>databasesCron</code>可以看到，如果开启了主动expire，并且自己是master，则会定时运行activeExpireCycle。<br>介绍<a href="https://stackoverflow.com/questions/33370047/configuring-redis-expire-algorithm" target="_blank" rel="noopener">参数</a>：<br><code>active_expire_effort</code>默认值为1，表示<a href="https://docs.aws.amazon.com/memorydb/latest/devguide/parametergroups.redis.html" target="_blank" rel="noopener">避免有超过<code>10%</code>的过期key，同时CPU占用不超过25%</a>。<br><code>config_keys_per_loop</code>表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    effort = server.active_expire_effort<span class="number">-1</span>, <span class="comment">/* Rescale from 0 to 9. */</span></span><br><span class="line">    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +</span><br><span class="line">                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +</span><br><span class="line">                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +</span><br><span class="line">                                  <span class="number">2</span>*effort,</span><br><span class="line">    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-</span><br><span class="line">                                    effort;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是几个全局变量：</p><ol><li>timelimit_exit表示是否已经超时了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></span><br><span class="line"><span class="comment">     * incrementally across calls. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>如果所有的clients停止了，那么我们的主动expire循环也要停止，从而保持数据库是静态的。没搞懂为啥这么设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里，Redis的主动过期策略分为了fast和slow两个模式。第一种在key比较少的情况下尝试是用较少的cpu，一旦这些过期的键的数量小于某个给定值，就退出。第二种更激进一点，以减少内存占用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exit</span></span><br><span class="line"><span class="comment">         * for time limit, unless the percentage of estimated stale keys is</span></span><br><span class="line"><span class="comment">         * too high. Also never repeat a fast cycle for the same period</span></span><br><span class="line"><span class="comment">         * as the fast cycle total duration itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit &amp;&amp;</span><br><span class="line">            server.stat_expired_stale_perc &lt; config_cycle_acceptable_stale)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + (<span class="keyword">long</span> <span class="keyword">long</span>)config_cycle_fast_duration*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每次扫多少db呢？默认<code>dbs_per_call</code>为CRON_DBS_PER_CALL，即16：</p><ol><li><code>dbs_per_call</code>不能超过总的db数。</li><li>如果<code>timelimit_exit</code>，需要扫描全部db<br> 我的理解是如果上次active expire都超时了，说明肯定有很多expire key等待清理，我们全部做一遍，以免占用太多内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We usually should test CRON_DBS_PER_CALL per iteration, with</span></span><br><span class="line"><span class="comment">     * two exceptions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Don't test more DBs than we have.</span></span><br><span class="line"><span class="comment">     * 2) If last time we hit the time limit, we want to scan all DBs</span></span><br><span class="line"><span class="comment">     * in this iteration, as there is work to do in some DB and we don't want</span></span><br><span class="line"><span class="comment">     * expired keys to use memory for too much time. */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里通过计算耗时，来限制active expire循环对CPU的占用。默认CPU限制是ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC。我们最多在这个函数中只能用timelimit这么多<strong>微秒</strong>。<code>server.hz</code>指的是表示一秒钟被触发多少次，<code>config_cycle_slow_time_perc</code>是个CPU的百分比，也就是每次迭代中只能用<code>config_cycle_slow_time_perc/100</code>这么久。因为每次迭代的耗时是<code>1/server.hz</code>秒，即<code>1000000/server.hz</code>微秒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We can use at max 'config_cycle_slow_time_perc' percentage of CPU</span></span><br><span class="line"><span class="comment">     * time per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span></span><br><span class="line">    timelimit = config_cycle_slow_time_perc*<span class="number">1000000</span>/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = config_cycle_fast_duration; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accumulate some global stats as we expire keys, to have some idea</span></span><br><span class="line"><span class="comment">     * about the number of keys that are already logically expired, but still</span></span><br><span class="line"><span class="comment">     * existing inside the database. */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>外层的循环，遍历所有的数据库。如果<code>timelimit_exit</code>为1，说明内层循环中已经发现执行超时了，外层循坏也退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="comment">/* Expired and checked in a single loop. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> expired, sampled;</span><br><span class="line"></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></span><br><span class="line"><span class="comment">         * in the current DB we'll restart from the next. This allows to</span></span><br><span class="line"><span class="comment">         * distribute the time evenly across DBs. */</span></span><br><span class="line">        current_db++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内层的循环，如果每次循环结束，还是有很高的没有处理的过期的key，就需要继续做。但我们也不能一直这么做下去，所以每过16次，就会检查是否超过timelimit。如果是的话，就设置timelimit_exit为1，然后退出当前循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">            <span class="keyword">int</span> ttl_samples;</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When there are less than 1% filled slots, sampling the key</span></span><br><span class="line"><span class="comment">             * space is expensive, so stop here waiting for better times...</span></span><br><span class="line"><span class="comment">             * The dictionary will be resized asap. */</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. */</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            sampled = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个db最多抽样这么多个</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; config_keys_per_loop)</span><br><span class="line">                num = config_keys_per_loop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Here we access the low level representation of the hash table</span></span><br><span class="line"><span class="comment">             * for speed concerns: this makes this code coupled with dict.c,</span></span><br><span class="line"><span class="comment">             * but it hardly changed in ten years.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Note that certain places of the hash table may be empty,</span></span><br><span class="line"><span class="comment">             * so we want also a stop condition about the number of</span></span><br><span class="line"><span class="comment">             * buckets that we scanned. However scanning for free buckets</span></span><br><span class="line"><span class="comment">             * is very fast: we are in the cache line scanning a sequential</span></span><br><span class="line"><span class="comment">             * array of NULL pointers, so we can scan a lot more buckets</span></span><br><span class="line"><span class="comment">             * than keys in the same time. */</span></span><br><span class="line">            <span class="keyword">long</span> max_buckets = num*<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">long</span> checked_buckets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> table = <span class="number">0</span>; table &lt; <span class="number">2</span>; table++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == <span class="number">1</span> &amp;&amp; !dictIsRehashing(db-&gt;expires)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx = db-&gt;expires_cursor;</span><br><span class="line">                    idx &amp;= db-&gt;expires-&gt;ht[table].sizemask;</span><br><span class="line">                    dictEntry *de = db-&gt;expires-&gt;ht[table].table[idx];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Scan the current bucket of the current table. */</span></span><br><span class="line">                    checked_buckets++;</span><br><span class="line">                    <span class="keyword">while</span>(de) &#123;</span><br><span class="line">                        <span class="comment">/* Get the next entry now since this entry may get</span></span><br><span class="line"><span class="comment">                         * deleted. */</span></span><br><span class="line">                        dictEntry *e = de;</span><br><span class="line">                        de = de-&gt;next;</span><br><span class="line"></span><br><span class="line">                        ttl = dictGetSignedIntegerVal(e)-now;</span><br><span class="line">                        <span class="keyword">if</span> (activeExpireCycleTryExpire(db,e,now)) expired++;</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">/* We want the average TTL of keys yet</span></span><br><span class="line"><span class="comment">                             * not expired. */</span></span><br><span class="line">                            ttl_sum += ttl;</span><br><span class="line">                            ttl_samples++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sampled++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                db-&gt;expires_cursor++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            total_sampled += sampled;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Do a simple running average with a few samples.</span></span><br><span class="line"><span class="comment">                 * We just use the current estimate with a weight of 2%</span></span><br><span class="line"><span class="comment">                 * and the previous estimate with a weight of 98%. */</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就是检查并设置timelimit_exit</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (sampled == <span class="number">0</span> ||</span><br><span class="line">                 (expired*<span class="number">100</span>/sampled) &gt; config_cycle_acceptable_stale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed = ustime()-start;</span><br><span class="line">    server.stat_expire_cycle_time_used += elapsed;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update our estimate of keys existing but yet to be expired.</span></span><br><span class="line"><span class="comment">     * Running average with this sample accounting for 5%. */</span></span><br><span class="line">    <span class="keyword">double</span> current_perc;</span><br><span class="line">    <span class="keyword">if</span> (total_sampled) &#123;</span><br><span class="line">        current_perc = (<span class="keyword">double</span>)total_expired/total_sampled;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        current_perc = <span class="number">0</span>;</span><br><span class="line">    server.stat_expired_stale_perc = (current_perc*<span class="number">0.05</span>)+</span><br><span class="line">                                     (server.stat_expired_stale_perc*<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="propagateExpire"><a href="#propagateExpire" class="headerlink" title="propagateExpire"></a>propagateExpire</h2><p>在前面的代码中，还看到<code>propagateExpire</code>的使用。我们知道，在主从结构下，键实际的expire操作是在Master完成的。在expire之后，Master会发送DEL指令给Slave和AOF，也就是这个函数。<br>在注释中还指出，因为AOF，以及Master到Slave的连接都是保证有序的，所以即使有操作去写已经失效的key，都能保证结果是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    robj *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    argv[<span class="number">0</span>] = lazy ? shared.unlink : shared.del;</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    incrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    propagate(server.delCommand,db-&gt;id,argv,<span class="number">2</span>,PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="propagate机制"><a href="#propagate机制" class="headerlink" title="propagate机制"></a>propagate机制</h1><p>在expire中，提到了<code>propagate</code>函数，因此这里也顺便介绍一些propagate机制。<br>propagate机制是Redis主从复制逻辑的一部分，通常来说，Redis主从复制<a href="http://redisbook.com/preview/replication/replicate-before-2-8.html" target="_blank" rel="noopener">包含两个机制</a>：</p><ol><li>sync/psync机制<br> 用来处理sync和psync指令，也就是刚开始同步的情况，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>propagate机制<br> 将指令从Master同步到Slave或者AOF文件。</li></ol><p>propagate机制将特定的指令传播给AOF或者Slave，这些指令有下面几种：</p><ol><li><code>PROPAGATE_NONE</code><br> 压根就不传播。</li><li><code>PROPAGATE_AOF</code><br> 如果开启了AOF，就传播给AOF。此时就会调用AOF的主入口函数<code>feedAppendOnlyFile</code>。关于RDB和AOF机制，我们在专门的文章介绍。</li><li><code>PROPAGATE_REPL</code><br> 传播给Slave。同样调用<code>replicationFeedSlaves</code>函数。</li></ol><p>根据注释，不能够在各个command的实现代码中使用这个函数，因为它不会wrap the resulting commands in MULTI/EXEC，如果需要，应该用<code>alsoPropagate</code>、<code>preventCommandPropagation</code>、<code>forceCommandPropagation</code>等。<br>However for functions that need to (also) propagate out of the context of a command execution, for example when serving a blocked client, you want to use propagate().</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="evict实现"><a href="#evict实现" class="headerlink" title="evict实现"></a>evict实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis对当前执行环节的判断</p><ol><li><code>server.masterhost == NULL</code><br> 常常被用来判断是不是Master服务器</li><li><code>server.current_client != server.master</code><br> 根据注释，这是指的服务器的当前客户端，仅用于崩溃报告。</li><li><code>sentinelRedisInstance-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)</code></li><li><code>sentinelRedisInstance-&gt;slave_master_host</code></li></ol><p>大家都知道，Redis里面有下面<a href="https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/" target="_blank" rel="noopener">几种evict policy</a>：</p><ol><li>noeviction<br> 这是默认情况。<br> 内存爆了，就直接报错。</li><li>allkeys-lru<br> 对所有的键做LRU。</li><li>allkeys-lfu<br> 对所有的键做LFU。</li><li>allkeys-random<br> 对所有的key做随机删除。</li><li>volatile-lru/volatile-lfu/volatile-random<br> 这是对有expire的键做对应的操作。</li><li>volatile-ttl<br> 删除剩余生命最短的键。</li></ol><p>而对应的实现，就在<code>freeMemoryIfNeeded</code>中。根据注释，这个函数被定时调用，当发现超出最大使用内存后，就会释放相关内存。如果释放内存成功，或者我们不需要释放内存，那么返回<code>C_OK</code>；如果我们没有能够释放足够的内存，那么返回<code>C_ERR</code>。总之一堆废话。。。其实我们想了解的是这几个问题：</p><ol><li>如何计算现在已经使用了多少内存？</li><li>如何实现LFU和LRU？</li><li>释放内存会对其他模块产生什么影响？</li></ol><h2 id="LRU和LFU的一般实现及优缺点讨论"><a href="#LRU和LFU的一般实现及优缺点讨论" class="headerlink" title="LRU和LFU的一般实现及优缺点讨论"></a>LRU和LFU的一般实现及优缺点讨论</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>对于LRU，一个队列就行了，我们把最近用到的元素放到队列尾部，需要evict的时候就弹出头部，一般用双向队列就行。但这样查找一个Key就变成<code>O(n)</code>的了，但这也不难，我们只需要用一个map记录一下对应元素在队列中的位置就行。也就是说，用hash+双向链表来维护。hash用来实现O(1)查询，双向链表用来维护顺序。</p><p>Redis并没有采用这个办法来维护一个LRU，显然内存开销很大，这是值得的么？<a href="https://juejin.cn/post/6844903454654087182" target="_blank" rel="noopener">文章</a>中提到，当<code>maxmemory-samples</code>数为<a href="https://segmentfault.com/a/1190000017555834" target="_blank" rel="noopener">10</a>的时候，近似LRU算法的性能已经很好了。此外，Redis实际上是记录了最后一次访问某个key的时间戳的(倒不是因为复用LFU的空间了，毕竟LRU是先有的)。到了我们这个版本的代码，近似LRU又被优化了，出现了一个<code>evictionPoolEntry</code>。这个pool的容量是16，里面的key是按照lru有序排列的。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>对于LFU，我们需要记录对应的访问次数，在淘汰时，选择最少访问次数的键值对。此时，队列的性质就不够用了，但可以考虑下面的方案</p><ol><li>用优先队列，把访问次数作为key，大不了手动实现一个二叉堆嘛。</li><li>用一个双层链表，第一层是从0开始的访问次数，第二层是具有这个访问次数的所有键值对的开链表。为了节约空间，第一层可以是哈希表的形式。</li></ol><h2 id="Redis的LRU和LFU实现"><a href="#Redis的LRU和LFU实现" class="headerlink" title="Redis的LRU和LFU实现"></a>Redis的LRU和LFU实现</h2><p>本章介绍了Redis对LRU和LFU数据结构的维护，这是必要的前置知识。<br>这一部分的实现是在先前介绍过的<code>lookupKey</code>函数中。根据<code>server.maxmemory_policy</code>分别用LRU和LFU进行维护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lookUpKey</span></span><br><span class="line"><span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        updateLFU(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的evict的时刻是<code>freeMemoryIfNeeded</code>函数。<br>Redis对每个<code>robj</code>对象去维护了一个<code>lru:LRU_BITS</code>字段。在3.0版本，这个字段被用来存储当前秒级别的时间戳。在往后的版本中还支持LFU模式，会复用这个字段。</p><p>维护了的LRU或者是LFU在<code>evictionPoolPopulate</code>中起作用，会分别根据<code>estimateObjectIdleTime</code>和<code>255-LFUDecrAndReturn(e)</code>进行排序</p><h3 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h3><p><code>LRU_CLOCK</code>这里会选择是直接用<code>server.lruclock</code>(也是在<code>serverCron</code>里面调用<code>getLRUClock</code>设置的)，或者直接自己调用一次<code>getLRUClock</code>。这个比较是怎么来的呢？有必要介绍一下，毕竟诸如<code>run_with_period</code>里面也有这样的比较。<br>首先，在<a href="/2020/10/18/redis-sentinel/">文章</a>中已经介绍过，<code>server.hz</code>指的是表示一秒钟被触发多少次。那么<code>1000/server.hz</code>就表示触发1次要多少毫秒。<code>LRU_CLOCK_RESOLUTION</code>的默认值是1000，表示时钟精度是1000毫秒调用一次。所以只要LRU的精度小于server调用的精度，就可以复用server.lruclock，从而少调用一次getLRUClock。<br>【Q】岂不是大多数情况下都可以复用server的时钟？毕竟hz不会为0.5啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        lruclock = server.lruclock;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-1"><a href="#LFU-1" class="headerlink" title="LFU"></a>LFU</h3><p>在访问一个对象的时候，用<code>updateLFU</code>更新<code>lru</code>字段。这个函数会在高16位存一个分钟级别的时间戳ldt，在低8位存访问计数counter。这两个值被存放在一个字段中完全是为了节省空间和复用字段，其组合后的值整体上没有实际意义。<br>更新<code>lru</code>需要注意两点，<strong>即要根据时间衰减，但也要根据访问次数增长</strong>。首先，通过<code>LFUDecrAndReturn</code>，计算通过当前时间和ldt的差值去减少<code>counter</code>。然后通过<code>LFULogIncr</code>以一定概率增加counter。最后，将最新的counter和ldt重新组装起来存入<code>-&gt;lru</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 组装lru字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加counter"><a href="#增加counter" class="headerlink" title="增加counter"></a>增加counter</h4><p>介绍<code>counter</code>随访问次数的增长。<br>每次访问，都需要增加访问计数，但<code>counter</code>的增长并不是访问一次就+1。而是每次访问以<code>[0,1]</code>之间的概率<code>p</code>来增长，当它大于随机<code>r</code>的阈值后才会自增<code>counter</code>。<br>其中<code>p</code>的值是<code>1.0/(baseval*lfu_log_factor+1)</code>，其中<code>baseval</code>为<code>max(0,counter-LFU_INIT_VAL)</code>。</p><p>不妨讨论下baseval：</p><ol><li>baseval=0，p=1</li><li>baseval=1，p=0.09</li><li>baseval=10，p=0.009</li></ol><p>可以看到：</p><ol><li><code>counter</code>越大，<code>counter</code>的自增概率就越小。</li><li><code>lfu_log_factor</code>越大，<code>counter</code>的自增概率就越小<br> 所以为了支持存储更高的访问频次，我们就需要设置更大的<code>lfu_log_factor</code>。</li></ol><p>事实上<code>counter</code>的增长和访问次数是<strong>成对数关系</strong>的。所以这8 bits足够存储很大的命中次数。<br>在更新版本的<a href="https://github.com/redis/redis/blob/9ab873d9d35e789a228c5281d57c9c4fdc1e4ce1/redis.conf#L2156" target="_blank" rel="noopener">redis.conf</a>中，列出了不同<code>lfu_log_factor</code>取值下，若干次hit之后，counter增加的数量。</p><p>因为r是随机取的，所以可能用数学计算挺困难的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | <span class="number">100</span> hits   | <span class="number">1000</span> hits  | <span class="number">100</span>K hits  | <span class="number">1</span>M hits    | <span class="number">10</span>M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">0</span>      | <span class="number">104</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">1</span>      | <span class="number">18</span>         | <span class="number">49</span>         | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">10</span>     | <span class="number">10</span>         | <span class="number">18</span>         | <span class="number">142</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">100</span>    | <span class="number">8</span>          | <span class="number">11</span>         | <span class="number">49</span>         | <span class="number">143</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><p>还需要特别介绍下<code>LFU_INIT_VAL</code>，每个对象在初始化时，对应的counter是<code>LFU_INIT_VAL</code>即5。没有这个，那么在<code>LFUDecrAndReturn</code>的时候，counter就会因为很小而被淘汰掉。但因为偏移了这个5，所以在<code>LFULogIncr</code>我们需要将它还原回实际的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="comment">// 确保不会回绕</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 随机数r</span></span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p小于该随机数r才增长</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-log-factor"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_log_factor, <span class="number">10</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h4 id="衰减counter"><a href="#衰减counter" class="headerlink" title="衰减counter"></a>衰减counter</h4><p><code>LFUDecrAndReturn</code>返回<code>counter</code>，表示当前对象的frequency。<br>此外，如果到了需要减少<code>counter</code>的时候，会尝试减少<code>num_periods</code>。它也不完全是两个时间相减，而是要除以<code>lfu_decay_time</code>。<br><code>server.lfu_decay_time</code>是个衰变因子，默认是1，也就是不衰减。这时候对<code>counter</code>的减少就是经过的分钟数。它还有个特殊值0，表示每次都不衰减(文档上可能错了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出老的分钟时间戳</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 取出老的计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? </span><br><span class="line">        LFUTimeElapsed(ldt) / server.lfu_decay_time : </span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-decay-time"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_decay_time, <span class="number">1</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>简单介绍<code>LFUTimeElapsed</code>，用来计算从<code>ldt</code>开始经过了多少分钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得从ldt开始经过了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="comment">// 如果now小了，就当成已经wrap了刚好一次，这个和estimateObjectIdleTime的实现是类似的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="evictionPoolEntry和evictionPoolPopulate"><a href="#evictionPoolEntry和evictionPoolPopulate" class="headerlink" title="evictionPoolEntry和evictionPoolPopulate"></a>evictionPoolEntry和evictionPoolPopulate</h2><p>来看<code>evictionPoolPopulate</code>这个函数，它作用是往<code>evictionPool</code>里面加一些<code>evictionPoolEntry</code>条目。<code>evictionPool</code>由一系列<code>evictionPoolEntry</code>组成，后者表示某个数据库中的某个键。在<code>evictionPool</code>中的entry都是按照<code>idle</code>排序的，左边的idle time最小，从小到大升序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><ol><li><code>idle</code><br> 表示每个对象的空闲时间。pool里面只能加入具有更大idle time的键。如果还有空余空间，就始终加入。</li><li><code>cached</code><br> <strong>这是一个有趣的优化</strong><br> 如果key的长度比较小，它就会被存在预分配好空间的cached结构中，从而避免在key中分配空间的开销。</li><li><code>dbid</code><br> 表示这个键所属的数据库。</li></ol><p>如何根据LRU或者LFU计算idle呢？</p><ol><li><p>如果采用LRU<br> 调用<code>estimateObjectIdleTime</code>函数计算，实际上就是乘以一个<code>LRU_CLOCK_RESOLUTION</code>。这里实现上还处理了一下回绕wrap的情况。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果采用LFU<br> 这里要反向一下，就是用255减一下<code>LFUDecrAndReturn(o)</code>。因为idle和访问频率是相反的。</p></li></ol><p>输入参数：</p><ol><li><code>sampledict</code>表示从哪个dict里面进行采样，根据策略不同，可能是dict(allkeys策略)或者expire(volatile策略)。</li><li><code>keydict</code>只能是对应的dict。因为expire里面只是存一个”引用”。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code>这个函数从dict里面任意取出若干个entry。<code>server.maxmemory_samples</code>默认被设置成5个。在取出这些entry到<code>samples</code>后，我们挨个尝试将它们插入pool中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的一段代码计算这个对象的<code>idle</code>时间。首先需要讨论是否需要回dict表再查一次，得到<code>keydict</code>中的entry <code>de</code>，以及key对应的val <code>o</code>：</p><ol><li>回表的情况<br> 显然，只要<code>sampledict</code>不等于<code>keydict</code>就需要回表。因为<code>sampledict</code>肯定是expire。</li><li>不回表的情况</li><li>特殊情况：volatile-ttl策略<br> 前面两种情况都是用的<code>keydict</code>中对应的entry、key和val，但这里我们直接用<code>sampledict</code>的。</li></ol><p>然后需要讨论具体的策略，这个在前面讲过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment">         * idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment">         * just a score where an higher score means better candidate. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码计算出了当前key对应的<code>idle</code>时间，接下来将元素插入到池中。这是一个类似<strong>插入排序</strong>的过程。<br>首先，找到第一个空bucket，或者找到第一个<code>idle &lt;= pool[k].idle</code>，可以插到它前面。下面的循环能够跳过所有不满足以上条件的情况。【Q】这里能直接二分么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理两种特殊情况，第一种是我们的<code>idle</code>比pool里面所有的idle都要小，并且也没有空余的格子给我们了。第二种是bucket完全空的情况，我们可以直接用最左边的格子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，因为<code>key</code>和<code>cache</code>有点类似于<strong>自引用结构</strong>的关系，但其实不是。因为key和cached实际上都是sds，也就是个<code>char*</code>。移动或者复制sds，并没有改变sds指向的内容。所以，我们只需要保证<strong>只要它不释放就行</strong>。<br>当然，发散一下，如果<code>key</code>是一个指向<code>cached</code>的<code>sds*</code>，那就真的是自引用结构了。但也并不需要绑定<code>key</code>和它可能指向的<code>cached</code>在一个结构中，因为这两个是一一对应的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| key <span class="number">1</span> | key <span class="number">2</span> | key <span class="number">3</span> | nul k |</span><br><span class="line">| nul c | cac <span class="number">3</span> | cac <span class="number">2</span> | cac <span class="number">1</span> |</span><br></pre></td></tr></table></figure><p>此时<code>k</code>是第一个满足<code>idle &lt;= pool[k].idle</code>，我们的新entry应该插入在<code>k</code>之前。下面就插入排序，把待插入的<code>de</code>插入，然后把原来<code>k</code>以及之后的数字往右边移动。这里使用了memmove，它能自动检测src内存和dest内存重叠的情况并处理，所以是更安全的memcpy。<br>分为两种情况：</p><ol><li>最右边还有空位，将[k,)整体右移一格，新entry预计插入<code>k</code>处<br> 尽管这时候最右边的cached是空，但我们还是需要备份。否则就会泄露掉那一块内存。</li><li>最右边没有空位，将整个数组右移一格，新entry预计插入在<code>k-1</code>处<br> 此时最左边是idle最小的，将它从pool里面去掉，换成idle更大的。<br> 但同时，也要保证最左边的cached不被意外释放。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，将新entry插入pool中。这里说明下cached的使用：</p><ol><li>如果<code>key</code>的长度大于<code>EVPOOL_CACHED_SDS_SIZE</code><br> 则复制<code>key</code>到<code>pool[k].key</code></li><li>如果<code>key</code>的长度较小，就可以尝试做优化，将它放在<code>cached</code>中，然后让把<code>cache</code>赋值给<code>key</code>，从而避免复制底层的字符串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">// 尝试复用pool entry中的cached SDS。因为内存分配和回收还是开销比较大的。</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictGetSomeKeys"><a href="#dictGetSomeKeys" class="headerlink" title="dictGetSomeKeys"></a>dictGetSomeKeys</h3><p><code>dictGetSomeKeys</code>这个函数，是对一个dict来说的，而不是对db来说的。<br>它不保证一定返回正好count个，也不保证返回的元素都不重复。返回值被存到<code>des</code>里面，需要保证这个数组至少能容纳<code>count</code>个。<br>取出来的指针存在<code>des</code>中返回。<code>des</code>必须预分配至少<code>count</code>个空间，尽管函数可能未必能取到<code>count</code>个。其原因可能是本来就没那么多个，或者我们经过多轮迭代没添加完。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is not suitable when you need a good distribution</span></span><br><span class="line"><span class="comment"> * of the returned items, but only when you need to "sample" a given number</span></span><br><span class="line"><span class="comment"> * of continuous elements to run some kind of algorithm or to produce</span></span><br><span class="line"><span class="comment"> * statistics. However the function is much faster than dictGetRandomKey()</span></span><br><span class="line"><span class="comment"> * at producing N elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; <span class="comment">/* internal hash table id, 0 or 1. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; <span class="comment">/* 1 or 2 tables? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>首先，执行一点渐进式rehash。然后将<code>maxsizemask</code>设置为所有ht(没有rehash是1个，有是2个)的最大容量。<br>将<code>i</code>设置为随机一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Try to do a rehashing work proportional to 'count'. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">    <span class="comment">/* Pick a random point inside the larger table. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面进入主循环，循环条件有两个，一个是取满count个，一个是执行最多<code>maxsteps=count*10</code>次。<br>在每一次迭代中，对所有的ht（1或2个）进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">/* Continuous empty entries so far. */</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>涉及到rehashidx相关的逻辑，表示在每次进入<code>dictRehash</code>函数的时候，首先<code>ht[0].table[rehashidx]</code>这个桶。如果现在在rehash过程中，到<code>d-&gt;rehashidx</code>为止的所有index都已经被访问过了。实际上这些桶里面都空(not populated)了，因此我们可以跳过<code>ht[0]</code>里面$[0,idx-1]$这个区间的关卡，直接去看<code>ht[1]</code>里面的。这其实是一个优化，在<code>dictRehash</code>实现中，也有对空桶跳过的优化。<br>特别地，如果<code>i</code>在<code>ht[1]</code>里面也已经超了，这就表示截止到<code>rehashidx</code>两个表里面都没有了。【Q】为什么可以认为<code>ht[1]</code>中的<code>rehashidx</code>之前的也不需要判定了呢？或者说，为啥两个ht可以共享一个<code>i</code>呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">/* Out of range for this table. */</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们会统计遇到连续空桶的数量，如果超过了5个，就重新随机一个位置。</span></span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123;</span><br><span class="line">                    i = random() &amp; maxsizemask;</span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，我们使用桶里面所有的元素</span></span><br><span class="line">                emptylen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (he) &#123;</span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在主循环结束后，会自增<code>i</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主逻辑freeMemoryIfNeeded"><a href="#主逻辑freeMemoryIfNeeded" class="headerlink" title="主逻辑freeMemoryIfNeeded"></a>主逻辑freeMemoryIfNeeded</h2><p><code>freeMemoryIfNeeded</code>函数是evict的主要逻辑。<br>首先，如果是从服务器，并且配置了<code>server.repl_slave_ignore_maxmemory</code>就忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* By default replicas should ignore maxmemory</span></span><br><span class="line"><span class="comment">     * and just be masters exact copies. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就来计算占用了多少内存<code>mem_reported</code>，主要函数<code>getMaxmemoryState</code>我们放在后面单独讲解。<code>mem_reported</code>表示总共用了多少内存，<code>mem_tofree</code>表示应该释放多少内存(不算Slave和AOF的缓存)。<br><code>clientsArePaused</code>的检查，有点奇怪。根据注释，它的意思是，如果client都被pause了，那么数据就是静止的。不仅对于所有的client是这样，对于还没有做expire和evict的所有key也是这样。我觉得这应该是一个优化，防止在这种情况下再走下面的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency, lazyfree_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="keyword">int</span> result = C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>latencyStartMonitor</code>这个宏和stopwatch一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面开始根据淘汰政策<code>maxmemory_policy</code>进行讨论，如果是noeviction，那就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个内存释放过程是多次的，因此用一个循环来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理要排序的情况"><a href="#处理要排序的情况" class="headerlink" title="处理要排序的情况"></a>处理要排序的情况</h3><p>第一个if，用来处理所有需要排序的情况。查看代码，要用while循环去找<code>bestkey</code>，原因是可能从pool里面找到的key不存在了，【Q】可是究竟什么情况下会发生这个情况呢？<br>循环里面的过程就是我们去遍历整个数据库里面的所有db，如果它的<code>dict</code>或者<code>expires</code>不为空，则调用<code>evictionPoolPopulate</code>。这个函数会往pool里面加入一些key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，我们遍历整个pool，找到最合适的一个。解释几个问题：</p><ol><li>为什么要从尾往头遍历？<br> 在对evictionPool的介绍中提到，它是有序的，最左边的idle time最小，最右边的最大，因此优先淘汰右边的。</li><li>为什么要有bestdbid？将key之间的比较转化为数据库之间的比较么？</li><li><code>server.db[pool[k].dbid]</code>是什么鬼？<br> 实际上是要选择<code>pool[k].dbid</code>这个db。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                        <span class="comment">// 这个很奇怪，什么时候会出现这种情况呢？</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理随机情况"><a href="#处理随机情况" class="headerlink" title="处理随机情况"></a>处理随机情况</h3><p>第二个if，用来处理随机的情况。这个很简单，直接调用<code>dictGetRandomKey</code>就行，和eviction pool也没啥关系了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>如果我们找到了要删除的元素<code>bestkey</code>，就执行删除元素过程。<br>首先，调用老朋友<code>propagateExpire</code>，这个会发送一条删除指令给AOF/Slave。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，我们统计这次evict释放了多少内存，就是首尾两个<code>zmalloc_used_memory</code>相减。这个有点粗略了，就在刚才我们还将AOF/Slave缓存单独拿出来算的呢，现在直接总内存相减了。在注释中还提到，有可能用来<code>propagateExpire</code>的内存比我们释放的db内存还多呢，但我们是管不了的，否则<code>mem_freed &lt; mem_tofree</code>这个循环条件永远达不到了。并且，这些缓存终究会被释放的。<br>这里还统计了一下调用dictSyncDelete等的时间，并且通过<code>latencyAddSampleIfNeeded</code>放到统计里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            signalModifiedKey(<span class="literal">NULL</span>,db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些统计性的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在循环中就强制往Slave发送数据，确保即使在要传的数据都很大的情况下，我们仍然能够快速传递。<br>特别地，我们在<code>while (mem_freed &lt; mem_tofree)</code>这个循环的最后，还会有条件地检查一下内存是不是达标。这个主要是对异步删除来说的，在这种情况下，<code>dbAsyncDelete</code>流程中对内存的释放未必能和我们循环这边同步起来。所以我们每释放16个键，就检查一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                    <span class="comment">/* Let's satisfy our stop condition. */</span></span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (result != C_OK) &#123;</span><br><span class="line">        latencyStartMonitor(lazyfree_latency);</span><br><span class="line">        <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                result = C_OK;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(lazyfree_latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"eviction-lazyfree"</span>,lazyfree_latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMaxmemoryState"><a href="#getMaxmemoryState" class="headerlink" title="getMaxmemoryState"></a>getMaxmemoryState</h2><p>这个函数获得内存的使用情况，包括：</p><ol><li>total<br> 总共使用的内存。<br> 来自<code>zmalloc_used_memory</code>。</li><li>logical<br> 即<code>mem_used</code>，表示出了Slave/AOF buffer之外的内存。<br> 这个计算就是要减去<code>overhead</code>，也就是Slave/AOF buffer的内存，用<code>freeMemoryGetNotCountedMemory</code>计算得到的。</li><li>level<br> 表示内存使用率</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxmemoryState</span><span class="params">(<span class="keyword">size_t</span> *total, <span class="keyword">size_t</span> *logical, <span class="keyword">size_t</span> *tofree, <span class="keyword">float</span> *level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面获得了总内存量，如果没有设置最大内存，或者总内存量都没有操作，也不需要计算比例，那么就直接返回了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We may return ASAP if there is no need to compute the level. */</span></span><br><span class="line">    <span class="keyword">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>计算两个缓冲区占用的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the ratio of memory usage. */</span></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="keyword">float</span>)mem_used / (<span class="keyword">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><p>在前面的代码中可以看到下面的语句，实际上是对主数据库<code>c-&gt;db</code>进行修改后，需要进行事件通知，我们将在下面介绍这几个语句的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">    <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure><h3 id="signalModifiedKey"><a href="#signalModifiedKey" class="headerlink" title="signalModifiedKey"></a>signalModifiedKey</h3><p><code>signalModifiedKey</code>是key被修改的钩子函数，每当数据库<code>c-&gt;db</code>里面的key被改动时，会调用这个函数。这里的key发生改动也包括key对应的值发生改动，这是因为从<code>genericSetKey</code>的实现可以看到，SET指令也会导致<code>signalModifiedKey</code>被调用。<br>此外，根据注释，每一次DB被flush时，<code>signalFlushDb</code>会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(client *c, redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">    trackingInvalidateKey(c,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="touchWatchedKey"><a href="#touchWatchedKey" class="headerlink" title="touchWatchedKey"></a>touchWatchedKey</h4><p><code>touchWatchedKey</code>字如其名，它的作用是让WATCH这个键的事务失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里先特判一下，如果<code>db-&gt;watched_keys</code>为空就直接返回，这个用法在redis中非常常见，我猜想可能是<code>dictFind</code>的开销还是比较大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面从<code>db-&gt;watched_keys</code>上拿到WATCH这个key的所有的client，并且对这个链表上的每一个client设置<code>CLIENT_DIRTY_CAS</code>这个flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 这个函数是dictFind(只能得到dictEntry)和dictGetVal的简单封装</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trackingInvalidateKey"><a href="#trackingInvalidateKey" class="headerlink" title="trackingInvalidateKey"></a>trackingInvalidateKey</h4><p>下面看另一个函数<code>trackingInvalidateKey</code>。这个系列的函数是在Redis6.0左右被引入的，主要用途是维护客户端缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper (the one actually called across the core) to pass the key</span></span><br><span class="line"><span class="comment"> * as object. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKey</span><span class="params">(client *c, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    trackingInvalidateKeyRaw(c,keyobj-&gt;ptr,sdslen(keyobj-&gt;ptr),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key的值被改变后，在keys tracking的逻辑下，我们的任务是给每一个有可能缓存了当前keys的client发送通知。如果传入的<code>c</code>为空，表示这个不是一个client的场景，而是例如服务器内部做expire。<br><code>bcast</code>参数的作用是是否要将这个key通过BCAST模式广播给client们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * This is the case when the function is called from the Redis core once a key is modified, however</span></span><br><span class="line"><span class="comment"> * we also call the function in order to evict keys in the key table in case</span></span><br><span class="line"><span class="comment"> * of memory pressure: in that case the key didn't really change, so we want</span></span><br><span class="line"><span class="comment"> * just to notify the clients that are in the table for this key, that would</span></span><br><span class="line"><span class="comment"> * otherwise miss the fact we are no longer tracking the key for them. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKeyRaw</span><span class="params">(client *c, <span class="keyword">char</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> bcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TrackingTable == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcast &amp;&amp; raxSize(PrefixTable) &gt; <span class="number">0</span>)</span><br><span class="line">        trackingRememberKeyToBroadcast(c,key,keylen);</span><br><span class="line"></span><br><span class="line">    rax *ids = raxFind(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen);</span><br><span class="line">    <span class="keyword">if</span> (ids == raxNotFound) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    raxIterator ri;</span><br><span class="line">    raxStart(&amp;ri,ids);</span><br><span class="line">    raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> id;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;id,ri.key,<span class="keyword">sizeof</span>(id));</span><br><span class="line">        client *target = lookupClientByID(id);</span><br><span class="line">        <span class="comment">/* Note that if the client is in BCAST mode, we don't want to</span></span><br><span class="line"><span class="comment">         * send invalidation messages that were pending in the case</span></span><br><span class="line"><span class="comment">         * previously the client was not in BCAST mode. This can happen if</span></span><br><span class="line"><span class="comment">         * TRACKING is enabled normally, and then the client switches to</span></span><br><span class="line"><span class="comment">         * BCAST mode. */</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span> ||</span><br><span class="line">            !(target-&gt;flags &amp; CLIENT_TRACKING)||</span><br><span class="line">            target-&gt;flags &amp; CLIENT_TRACKING_BCAST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client enabled the NOLOOP mode, don't send notifications</span></span><br><span class="line"><span class="comment">         * about keys changed by the client itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;flags &amp; CLIENT_TRACKING_NOLOOP &amp;&amp;</span><br><span class="line">            target == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendTrackingMessage(target,key,keylen,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    raxStop(&amp;ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the tracking table: we'll create the radix tree and populate it</span></span><br><span class="line"><span class="comment">     * again if more keys will be modified in this caching slot. */</span></span><br><span class="line">    TrackingTableTotalItems -= raxSize(ids);</span><br><span class="line">    raxFree(ids);</span><br><span class="line">    raxRemove(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyKeyspaceEvent"><a href="#notifyKeyspaceEvent" class="headerlink" title="notifyKeyspaceEvent"></a>notifyKeyspaceEvent</h3><p>函数<code>notifyKeyspaceEvent</code>用来触发数据库事件，这个对应了Redis中的叫<a href="http://redisdoc.com/topic/notification.html" target="_blank" rel="noopener">“键空间通知”/“键事件通知”</a>的特性。这个特性是通过<strong>PUBLISH</strong>机制实现的。<br>简单来说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL key [key ...]</code>命令时，系统将分发两条消息，相当于执行以下两个<a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a>命令。其中<code>__keyspace</code>系列命令称为键空间通知(key-space notification)，<code>__keyevent</code>系列命令称为键事件通知(key-event notification)。订阅第一个PUBLISH命令，可以接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件。订阅第二个PUBLISH命令，可以接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>下面看看这个函数的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If any modules are interested in events, notify the module system now.</span></span><br><span class="line"><span class="comment">     * This bypasses the notifications configuration, but the module engine</span></span><br><span class="line"><span class="comment">     * will only call event subscribers if the event type matches the types</span></span><br><span class="line"><span class="comment">     * they are interested in. */</span></span><br><span class="line">    moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If notifications for this class of events are off, return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyspace@"</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyevent@"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="Redis内存管理zmalloc"><a href="#Redis内存管理zmalloc" class="headerlink" title="Redis内存管理zmalloc"></a>Redis内存管理zmalloc</h2><p>Redis基于zmalloc系列函数进行内存分配。<br>zmalloc是为了解决什么问题呢？主要是为了做到异常处理和内存统计的功能。<br>下面看<code>zmalloc</code>的实现。<br>可以看到，它会额外分配一个<code>PREFIX_SIZE</code>，用来存储额外信息。<code>zmalloc</code>最终返回的是<code>(char*)ptr+PREFIX_SIZE</code>，这个有点类似于SDS的骚操作。<code>PREFIX_SIZE</code>的大小是由宏来定义的，并且可以通过<code>HAVE_MALLOC_SIZE</code>禁用内存统计的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 如果不记录内存分配大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果记录内存分配大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面仔细查看一下<code>update_zmalloc_stat_alloc</code>函数的实现，不出所料的话，应该是通过一个原子操作来实现更新的。实际上也果不其然，<code>atomicIncr</code>的实现在后面会讲到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) atomicIncr(used_memory,(__n))</span></span><br></pre></td></tr></table></figure><p>还可以看到的是一个用来处理oom的函数<code>zmalloc_oom_handler</code>。对于C语言来说，<code>malloc</code>在内存分配失败后会返回一个0指针，然后我们在进行后续操作的时候要自行判断。基本上对于oom的处理就是打印一条日志然后abort了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisOutOfMemoryHandler</span><span class="params">(<span class="keyword">size_t</span> allocation_size)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Out Of Memory allocating %zu bytes!"</span>,</span><br><span class="line">        allocation_size);</span><br><span class="line">    serverPanic(<span class="string">"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"</span>, </span><br><span class="line">        allocation_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)</span></span><br><span class="line"><span class="comment">// debug.c</span></span><br><span class="line"><span class="keyword">void</span> _serverPanic(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *msg, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,msg);</span><br><span class="line">    <span class="keyword">char</span> fmtmsg[<span class="number">256</span>];</span><br><span class="line">    vsnprintf(fmtmsg,<span class="keyword">sizeof</span>(fmtmsg),msg,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    bugReportStart();</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"!!! Software Failure. Press left mouse button to continue"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Guru Meditation: %s #%s:%d"</span>,fmtmsg,file,line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.crashlog_enabled) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">        logStackTrace(<span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        printCrashReport();</span><br><span class="line">    &#125;</span><br><span class="line">    bugReportEnd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bugReportStart</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bug_report_start_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bug_report_start == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLogRaw(LL_WARNING|LL_RAW,</span><br><span class="line">        <span class="string">"\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n"</span>);</span><br><span class="line">        bug_report_start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bug_report_start_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下本章节中比较有意思的实现：</p><ol><li>LFU算法</li><li>evictPoolEntry中，key和cached的维护</li><li>诸如keyptrDictType和dbDictType这种C形式的OOP的实现</li><li>Redis对OOM的管理</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://my.oschina.net/lscherish/blog/4467394" target="_blank" rel="noopener">https://my.oschina.net/lscherish/blog/4467394</a><br> 对Redis中的LRU和LFU进行了讲解。本文吸纳了其中的部分内容并进行了修订。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为原&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;《Redis底层对象实现原理分析》&lt;/a&gt;太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redisDb，以及在这上面的增删改查&lt;/li&gt;
&lt;li&gt;Redis的expire和evict机制&lt;/li&gt;
&lt;li&gt;Redis的事件机制&lt;/li&gt;
&lt;li&gt;Redis的主从复制(一部分)&lt;br&gt; 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。&lt;br&gt; 本文介绍的部分比如propagate机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文中不介绍的是，它们在系列的其他文章中讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis的对象实现&lt;/li&gt;
&lt;li&gt;Redis Sentinel&lt;/li&gt;
&lt;li&gt;Redis Cluster&lt;/li&gt;
&lt;li&gt;Redis AOF/RDB&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>我们如何消除两个开源项目之间长达 4 年的分叉</title>
    <link href="http://www.calvinneo.com/2022/10/13/decouple-tikv/"/>
    <id>http://www.calvinneo.com/2022/10/13/decouple-tikv/</id>
    <published>2022-10-13T11:20:33.000Z</published>
    <updated>2022-10-24T11:55:08.661Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects" target="_blank" rel="noopener">https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>TiFlash 源码解读：TiFlash Proxy 模块</title>
    <link href="http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/"/>
    <id>http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/</id>
    <published>2022-08-25T11:20:33.000Z</published>
    <updated>2023-01-12T16:16:08.755Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/tiflash-source-code-reading-7" target="_blank" rel="noopener">https://cn.pingcap.com/blog/tiflash-source-code-reading-7</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的文件系统</title>
    <link href="http://www.calvinneo.com/2022/06/21/linux-fs/"/>
    <id>http://www.calvinneo.com/2022/06/21/linux-fs/</id>
    <published>2022-06-21T13:48:56.000Z</published>
    <updated>2022-06-21T13:34:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Linux 文件系统。</p><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cnblogs.com/zl1991/p/10288291.html" target="_blank" rel="noopener">https://www.cnblogs.com/zl1991/p/10288291.html</a><br> O_SYNC 和 O_DIRECT</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Linux 文件系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://www.calvinneo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Rust闭包实现递归</title>
    <link href="http://www.calvinneo.com/2022/06/18/rust-closure-self/"/>
    <id>http://www.calvinneo.com/2022/06/18/rust-closure-self/</id>
    <published>2022-06-18T12:28:29.000Z</published>
    <updated>2023-01-12T16:15:23.306Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2017/07/28/Y-Combinator/">不动点组合子Y-Combinator</a>中介绍了如何借助 Y-Combinator 和 Z-Combinator 实现在闭包中引用自己。</p><a id="more"></a><h1 id="基于-Y-Combinator-的方案"><a href="#基于-Y-Combinator-的方案" class="headerlink" title="基于 Y-Combinator 的方案"></a>基于 Y-Combinator 的方案</h1><p>回忆一下 Y-Combinator 的定义</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = λf.(λ<span class="keyword">x</span>.f (<span class="keyword">x</span> <span class="keyword">x</span>)) (λ<span class="keyword">x</span>.f (<span class="keyword">x</span> <span class="keyword">x</span>))</span><br></pre></td></tr></table></figure><h2 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h2><p>这里的<code>X</code>是为了实现 Y-Combinator 中的 <code>x x</code> 这样的结构。从<a href="/2017/07/28/Y-Combinator/">不动点组合子Y-Combinator</a>中可以知道 x 实际上是个递归类型。</p><p>容易看出，这里很多东西都是一样的，例如<code>Rc&lt;dyn Fn(A) -&gt; O&gt;</code>和<code>impl Fn(A) -&gt; O</code>都表示的是F：</p><ol><li>返回值可以用 impl 做静态分发，当然写成 <code>Box&lt;dyn Fn(A) -&gt; O&gt;</code> 返回也是没问题的</li><li>impl 本身也不能作为 closure 的参数<br> <code>impl Trait</code> only allowed in function and inherent method return types, not in closure param<br> 但是可以在普通函数中用 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> fi = |i:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = |f: <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; f(<span class="number">1</span>) &#125;;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fi</span></span>(i:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f1</span></span>(f: <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; f(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure></li></ol><p>整个实现如下所示，简单介绍下：</p><ol><li><code>(|x: X&lt;F&gt;| x.call(x.clone()))(x)</code><br> 实际上就是 <code>x x</code>，这里用 eta-conversion 来避免了立即求值。</li><li>那么 <code>inner1</code> 就应该是 <code>(λx.f (x x))</code>了<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">y</span></span>&lt;A, O, F&gt;(f: Rc&lt;dyn <span class="built_in">Fn</span>(Rc&lt;dyn <span class="built_in">Fn</span>(A) -&gt; O&gt;) -&gt; F&gt;) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(A) -&gt; O</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">Fn</span>(A) -&gt; O,</span><br><span class="line">        F: <span class="symbol">'static</span>,</span><br><span class="line">        A: <span class="symbol">'static</span>,</span><br><span class="line">        O: <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span></span>&lt;F&gt;(Rc&lt;dyn <span class="built_in">Fn</span>(X&lt;F&gt;) -&gt; F&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>(Rc::clone(&amp;<span class="keyword">self</span>.<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, x: <span class="keyword">Self</span>) -&gt; F &#123;</span><br><span class="line">            (<span class="keyword">self</span>.<span class="number">0</span>)(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> inner = Rc::new(<span class="keyword">move</span> |x: X&lt;F&gt;| f(</span><br><span class="line">            Rc::new(<span class="keyword">move</span> |a| (x.call(x.clone())) (a))</span><br><span class="line">        ));</span><br><span class="line">    <span class="keyword">let</span> x = X(inner);</span><br><span class="line">    (|x: X&lt;F&gt;| x.call(x.clone()))(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a>FnMut</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">y_mut</span></span>&lt;A, O, F&gt;(f: Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(A) -&gt; O&gt;&gt;) -&gt; F&gt;&gt;) -&gt; <span class="keyword">impl</span> <span class="built_in">FnMut</span>(A) -&gt; O</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnMut</span>(A) -&gt; O,</span><br><span class="line">        F: <span class="symbol">'static</span>,</span><br><span class="line">        A: <span class="symbol">'static</span>,</span><br><span class="line">        O: <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span></span>&lt;F&gt;(Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(X&lt;F&gt;) -&gt; F&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>(Rc::clone(&amp;<span class="keyword">self</span>.<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, x: <span class="keyword">Self</span>) -&gt; F &#123;</span><br><span class="line">            ((*<span class="keyword">self</span>.<span class="number">0</span>).borrow_mut())(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ff = Rc::new(RefCell::new(<span class="keyword">move</span> |x: X&lt;F&gt;| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ff_borrowd = (*f).borrow_mut();</span><br><span class="line">        ff_borrowd(Rc::new(RefCell::new(<span class="keyword">move</span> |a| (x.call(x.clone()))(a))))</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">let</span> x = X(ff);</span><br><span class="line">    (|x: X&lt;F&gt;| x.call(x.clone()))(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(RefCell::new(<span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">5</span>]));</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">usize</span> = (*a).borrow_mut().len();</span><br><span class="line"></span><br><span class="line">    y_mut(Rc::new(RefCell::new(&#123;</span><br><span class="line">        <span class="keyword">let</span> a = Rc::clone(&amp;a);</span><br><span class="line">        <span class="keyword">move</span> |f: Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(<span class="built_in">usize</span>)&gt;&gt;| &#123;</span><br><span class="line">            <span class="keyword">let</span> a = Rc::clone(&amp;a);</span><br><span class="line">            <span class="keyword">move</span> |i| &#123;</span><br><span class="line">                <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">                    (*a).borrow_mut()[i] = i;</span><br><span class="line">                    ((*f).borrow_mut())(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)))(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a is &#123;:?&#125;"</span>, a.borrow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h1><ol><li>struct 包 closure</li><li>在 fn 定义 fn<br> 但不能捕获任何变量了</li><li><a href="https://stackoverflow.com/questions/16946888/is-it-possible-to-make-a-recursive-closure-in-rust" target="_blank" rel="noopener">一个神奇的办法</a><br> 这个做法很有趣，它实际上是先顶一个 placeholder 的 fact 函数即 weak_holder，在真正的 fact 函数被定义时，调用 myself。在 fact 函数定义结束后，再把 fact 函数赋给 placeholder 的 weak_holder。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    cell::RefCell,</span><br><span class="line">    rc::&#123;Rc, Weak&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> weak_holder: Rc&lt;RefCell&lt;Weak&lt;dyn <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt;&gt;&gt; =</span><br><span class="line">        Rc::new(RefCell::new(Weak::&lt;<span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt;::new()));</span><br><span class="line">    <span class="keyword">let</span> weak_holder2 = weak_holder.clone();</span><br><span class="line">    <span class="keyword">let</span> fact: Rc&lt;dyn <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt; = Rc::new(<span class="keyword">move</span> |x| &#123;</span><br><span class="line">        <span class="keyword">let</span> myself = weak_holder2.borrow().upgrade().unwrap();</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x * myself(x - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    weak_holder.replace(Rc::downgrade(&amp;fact));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fact(<span class="number">5</span>)); <span class="comment">// prints "120"</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fact(<span class="number">6</span>)); <span class="comment">// prints "720"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2017/07/28/Y-Combinator/&quot;&gt;不动点组合子Y-Combinator&lt;/a&gt;中介绍了如何借助 Y-Combinator 和 Z-Combinator 实现在闭包中引用自己。&lt;/p&gt;</summary>
    
    
    
    
    <category term="函数式" scheme="http://www.calvinneo.com/tags/函数式/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中的异常</title>
    <link href="http://www.calvinneo.com/2022/03/19/exception_cpp/"/>
    <id>http://www.calvinneo.com/2022/03/19/exception_cpp/</id>
    <published>2022-03-19T11:20:33.000Z</published>
    <updated>2022-03-18T16:25:23.486Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。</p><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>F1的在线异步DDL</title>
    <link href="http://www.calvinneo.com/2022/01/28/f1-ddl/"/>
    <id>http://www.calvinneo.com/2022/01/28/f1-ddl/</id>
    <published>2022-01-28T15:33:22.000Z</published>
    <updated>2022-07-16T06:06:54.484Z</updated>
    
    <content type="html"><![CDATA[<p>介绍F1的在线异步DDL schema变更。</p><a id="more"></a><h1 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h1><h2 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h2><p>我们需要处理DDL执行进度不一致的问题，比如：</p><ol><li>Node A已经处理了a/b/c三个DDL</li><li>Node B刚处理完a这个DDL</li></ol><p>假定c是创建一个表，那么Node A能看见这个表，而Node B则看不见。那么分别从Node A和B查询，就会发现数据不一致的情况。</p><p>具体来说，有两类不一致问题需要考虑：</p><ol><li>orphan data anomaly<br> 违反1/3/5/7</li><li>integrity anomaly<br> 违反2/4/6</li></ol><p>其中：</p><ol><li>所有 ColumnKV 都能找到一个包含它的 Row 和 Table。</li><li>所有 Row 都包含所有非空列的 ColumnKV。</li><li>所有 IndexKV 都能找到一个包含它的 Index。</li><li>所有 Index 都是完整的(不存在某个 Row 缺少指向它的 IndexKV)。</li><li>所有 IndexKV 都指向有效的 Row。</li><li>没有违反 Constraint 的数据。</li><li>不存在未知的 KV(特指除上述 1，3 以外的未知 KV)。</li></ol><h2 id="分步解决问题"><a href="#分步解决问题" class="headerlink" title="分步解决问题"></a>分步解决问题</h2><p>目标1：在同一时刻改变所有Node的状态。很遗憾，因为各种延迟并不能做到。<br>妥协后的目标1：在某一时刻修改Schema，在确定的时间长度T之后，整个集群中不会有使用旧Schema的Node继续提供服务。这样在T之后这个修改就是确定生效的了。<br>方案：</p><ol><li>定时刷新<br> 每个节点会按照固定时间刷新自己的Schema。<br> 例如，可以选举出一个Owner，每个节点定时向Owner请求当前的Schema。</li><li>强制失败<br> 如果刷新失败，则停止服务，而不是继续按照旧Schema服务。</li></ol><p>目标1.1：在集群间同步最新的Schema<br>方案：借助于Spanner</p><ol><li>每次刷新时，从Spanner上的某个固定位置加载Schema。</li></ol><p>在实现目标1后，发现还是有问题。例如，虽然a/b在a+T/b+T时刻被完成，但在a+T之前的某个时刻，我们仍然不知道当前状态是a已生效，还是ab都已生效。如果在加上个c，那么情况更复杂。</p><p>目标2：在同一时刻，只会有最多两个Schema生效。例如在同一时刻内，最多只有DDL a之前的状态和DDL a之后的状态生效。<br>分析：直接Bruteforce搞就行，比如插一个barrier，等到DDL a确定生效(等到a+T)后，再执行DDL b。<br>方案：</p><ol><li>引入Lease，长度等于DDL确定生效的时间</li><li>每个Lease中只能执行一个DDL</li><li>我们在T+2个Lease时一定可以执行DDL b</li></ol><p>目标2.1：不会产生不合法的DML。<br>方案：write fencing</p><ol><li>事务允许跨越多个Lease。</li><li>但是，如果事务中有写操作，写操作只允许在当前Lease中进行：<ol><li>写操作在他们submit时，转换为Spanner上的KV操作</li><li>如果写操作跨Lease，可能会违反同一时刻集群中最多只有两个Schema版本生效的限制。</li></ol></li></ol><p>通过实现之前的目标进行了问题的分解，不需要处理多个DDL的进度不一致问题了。但仍然存在问题，考虑一个add index的DDL，Node A上已经执行完了，Node B则没有开始执行，然后考虑此刻开始执行的两个DML：</p><ol><li>通过Node A添加一个Row：会添加数据和索引</li><li>通过Node B删除一个Row：只会删除数据，因为尚未得到索引的schema</li></ol><p>现在如果从Node A索引读，那么会读到一开始被写入的索引，但对应的数据却被删除了。于是这里产生了<strong>孤儿索引</strong>的问题，这破坏了数据库的完整性。这是因为不同Node之间同一DDL的进度不同产生的不一致，如何解决呢？</p><p>目标3：将这一个DDL拆成多个Schema Change的步骤。由于Update可以看做是Delete+Insert，所以实际需要考虑Insert、Delete和Query三种操作。</p><p>从孤儿索引的问题可以看出，delete操作需要和insert操作分离，要拆出一个Delete Only状态，这个状态下该DDL的只对Delete操作可见，即该索引只对Delete操作可见：</p><ol><li>从None到Delete Only<br> 增和查都不会使用索引。<br> <strong>所有的删除操作会使用索引</strong>。</li><li>从Delete Only到Public<br> 不会出现孤儿索引问题了。假如Node A在Delete Only状态，它会在删除时一并删除索引；Node B在Public状态，在查询时发现索引被一并删除了。</li></ol><p>但有个新的问题，索引不会“多出来”，<strong>但却可能缺</strong>。这就得需要有个操作帮忙补索引，也就是reorg。<br>这个补索引的过程能发生在Delete Only到Public之间么？假设Node A在Delete Only阶段，它只能响应删除，然后开始为既有数据补索引，直到补完变成Public，同时可以处理增删改查。问题是这个过程中的insert，对应的索引并没有被补上啊。因此，需要引入新的状态Write Only。</p><p>于是引入Write Only状态，这个过程只不允许读：</p><ol><li>从Delete Only到Write Only</li><li>从Write Only到Public<br> 假如Node A在Write Only状态，它的<strong>所有写操作都会涉及索引</strong>。而Node B在Public状态，它也能读到Node A的修改。</li></ol><p>考虑所有节点都到达了Write Only状态，现在就可以做Reorg补上之前的索引数据了，方式很简单，就是取一个现在的Snapshot，然后照着补。此时可能有并发写的冲突问题，但Spanner的Percolator协议可以解决。</p><p>目标4：缩短Lease长度。Lease长度一般都会很长，F1中是分钟级，TiDB中也有45秒。如果完全走Lease的方案，那么一次DDL的时间就是分钟级的了，这显然很难被接受<br>方案1：直接将Lease长度缩短，例如改为1s。<br>这个方案是有问题的：</p><ol><li>在每个Lease结束后，Node需要去加载最新的Schema，这个伴随网络开销，需要时间。如果加载Schema的时间大于Lease的时间，那么就会导致刚加载的又失效了，从而重新加载，极大地降低了性能。</li></ol><p>既然方案1不行，那么就有了方案2<br>方案2：</p><ol><li>Owner在修改完DDL后，主动通知其他节点，并统计ack。如果其他节点都回复了，那么就主动确定了这个ddl在所有节点上都生效了。</li><li>如果有节点没有回复，那么再主动等2个Lease。</li></ol><h1 id="论文证明"><a href="#论文证明" class="headerlink" title="论文证明"></a>论文证明</h1><h2 id="Denotation"><a href="#Denotation" class="headerlink" title="Denotation"></a>Denotation</h2><p>一个 F1 schema 是一系列 table的定义。每个 table 包含一系列 column、index、constraint、optimistic lock。其中 constraint 包含外键以及 unique 约束。</p><h2 id="Schema-elements-and-states"><a href="#Schema-elements-and-states" class="headerlink" title="Schema elements and states"></a>Schema elements and states</h2><p>schema elements 包括 table、column、index、constraint、optimistic lock。每个 element 都可以对应 absent 和 public 两个 state。此外，还有 delete only 和 write only 两个中间态。</p><p>【定义1】一个 delete only 的 table、column 和 index 不能被读，且：</p><ol><li>如果 E 是 table 或 column，则只能被 delete</li><li>如果 E 是 index，则只能被 delete 和 update，<strong>这里的 update 不包含 create</strong><br> 注意这里的范围会更大一点了。</li></ol><p>【定义2】一个 write only 的 column 或 index 可以被 insert、delete、update，但继续不能被读。</p><p>【定义3】一个 write only 的 constraint 会在执行 insert、delete、update 操作应用。但它不能覆盖所有的已有数据。</p><h2 id="Database-consistency"><a href="#Database-consistency" class="headerlink" title="Database consistency"></a>Database consistency</h2><p>【定义4】一个 database representation(可以理解为某个快照) d consistent with respect to schema S，如果</p><ol><li>所有的 column 都属于 row 和 table</li><li>所有的 row 都具有所有 public required 的 column 值</li><li>所有的 index entry(索引数据)在 schema 中都能找到对应的 index<br> 也就是说我们写了条索引，但是 schema 里面却没有定义这一条索引</li><li>所有的 public 的 index 是完整的<br> 也就是说不会存在某一个 row 上没有对应的 index</li><li>所有的 index 都能指向 valid 的 row<br> 实际上就是不会有孤儿索引</li><li>所有的 public 的 constraint 一定是满足的</li><li>不存在未知数据</li></ol><p>这个定义在之前已经提到过了。</p><p>We denote the fact that database representation d is consistent with respect to schema S as d |= S. If d is not consistent with respect to schema S, we denote this as d |/= S.</p><p>【定义5】<strong>从 S1 到 S2 的 schema change，是 consistentcy preserving 的，当且仅当</strong>：</p><ol><li>d 在 schema S1 中任何操作下能够对 schema S2 也能保持 consistency</li><li>d 在 schema S2 中任何操作下能够对 schema S1 也能保持 consistency</li></ol><p>下图描述了不同元素的 schema 的变更。<br><img src="/img/f1/f1_schema_change.png"></p><h2 id="Adding-and-removing-schema-elements"><a href="#Adding-and-removing-schema-elements" class="headerlink" title="Adding and removing schema elements"></a>Adding and removing schema elements</h2><p>我们将 table、column和 index 称为 structural elements。它们可以被理解为决定了 Spanner 上能存储哪些 KV 数据的元素。注意 optimistic lock 因为在处理上和 column 是一致的，所以我们将它包含在 column 中讨论。</p><p>【Claim2】所有从 S1 到 S2 的 schema change，如果涉及到增加或者删除 public 的 structual element E，那么它就不是 consistency preserving 的。在下面的例子中，假设 S2 包含了 E，但 S1 没有。即从 S1 到 S2 的变换是新增。</p><ol><li>E 是 table<br> 如果对 S2 上的 E 做 insert，那么得到的 representation d2 和 S1 是不一致的。因为其中包含的新增的数据 S1 不能解析。违反了 Database consistency 中的第一条。</li><li>E 是 table R 上的 column<br> 同上</li><li>E 是 table R 上的 index<br> 如果在 S2 上的 E 做 insert，那么会同时违反3和4。对于 S1，违反了3，因为我们写入的索引在 schema 里面没找到定义。</li></ol><p>【Claim3】从 S1 到 S2 的 schema change 是 consistency preserving 的，当且仅当它在 S1 和 S2 上都能避免 orphan data 和 integrity anomaly 两种数据不一致的情况。</p><h2 id="Optional-structural-elements"><a href="#Optional-structural-elements" class="headerlink" title="Optional structural elements"></a>Optional structural elements</h2><p>这里的 Optional 指的是 element 是可选的，例如定义了 default，或者是 nullable 的。</p><p>【Claim4】【absent-&gt;delete only】考虑从 schema S1 到 schema S2 的 schema change，它添加了一个 delete only 的 structural element E。对于任意的 representation d，且 d |= S1, d |= S2。那么所有基于 S1 和 S2 在 E 上的操作都不会产生两种异常。</p><p>【Claim5】【delete only-&gt;public】类似 Claim4</p><h2 id="Required-structural-elements"><a href="#Required-structural-elements" class="headerlink" title="Required structural elements"></a>Required structural elements</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://zimulala.github.io/2016/02/02/schema-change-implement/" target="_blank" rel="noopener">http://zimulala.github.io/2016/02/02/schema-change-implement/</a></li><li><a href="https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md" target="_blank" rel="noopener">https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md</a></li><li><a href="https://disksing.com/understanding-f1-schema-change/" target="_blank" rel="noopener">https://disksing.com/understanding-f1-schema-change/</a></li><li><a href="https://tongtianta.site/paper/57876" target="_blank" rel="noopener">https://tongtianta.site/paper/57876</a><br> Online, Asynchronous Schema Change in F1</li><li><a href="https://www.zenlife.tk/schema-lease.md" target="_blank" rel="noopener">https://www.zenlife.tk/schema-lease.md</a></li><li><a href="https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/" target="_blank" rel="noopener">https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/</a></li><li><a href="https://zhuanlan.zhihu.com/p/309831009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/309831009</a><br> 一个翻译</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍F1的在线异步DDL schema变更。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>DPDK-Writing Efficient Code</title>
    <link href="http://www.calvinneo.com/2021/12/13/dpdk-coding/"/>
    <id>http://www.calvinneo.com/2021/12/13/dpdk-coding/</id>
    <published>2021-12-13T15:33:22.000Z</published>
    <updated>2023-01-12T15:56:19.859Z</updated>
    
    <content type="html"><![CDATA[<p>DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。</p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Memory-Copy"><a href="#Memory-Copy" class="headerlink" title="Memory Copy"></a>Memory Copy</h2><p>不要在数据面上使用libc函数，例如memcpy和strcpy等，推荐用<code>rte_memcpy</code>这样的优化实现，实际上就是SIMD的版本。<br>为了使用SIMD，需要保证地址不是虚拟地址，例如malloc等产生的是虚拟地址，那么在物理地址上可能是分散的，就做不了SIMD优化。</p><h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><p>避免使用malloc等在堆上分配内存，毕竟维护堆还是比较麻烦的(CSAPP的Data Lab令我记忆犹新)，并且也不容易做parallel allocation(【Q】这是啥)。<br>更为推荐的做法是对固定大小的对象构建内存池，例如<code>librte_mempool</code>/<code>rte_malloc</code>的实现。在这样的实现中需要考虑内存对齐，无锁访问，NUMA感知，批量读写，每个核心的Cache。</p><h2 id="对同一内存的并发访问"><a href="#对同一内存的并发访问" class="headerlink" title="对同一内存的并发访问"></a>对同一内存的并发访问</h2><h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><h2 id="Distribution-Across-Memory-Channels"><a href="#Distribution-Across-Memory-Channels" class="headerlink" title="Distribution Across Memory Channels"></a>Distribution Across Memory Channels</h2><h1 id="各个核心之间的通信"><a href="#各个核心之间的通信" class="headerlink" title="各个核心之间的通信"></a>各个核心之间的通信</h1><h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><h1 id="锁和原子操作"><a href="#锁和原子操作" class="headerlink" title="锁和原子操作"></a>锁和原子操作</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html" target="_blank" rel="noopener">https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html</a></li><li><a href="https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h" target="_blank" rel="noopener">https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h</a><br> rte_memcpy的源码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并行计算" scheme="http://www.calvinneo.com/tags/并行计算/"/>
    
    <category term="多线程" scheme="http://www.calvinneo.com/tags/多线程/"/>
    
    <category term="CPU" scheme="http://www.calvinneo.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>EPaxos介绍</title>
    <link href="http://www.calvinneo.com/2021/12/04/epaxos/"/>
    <id>http://www.calvinneo.com/2021/12/04/epaxos/</id>
    <published>2021-12-04T11:20:33.000Z</published>
    <updated>2023-01-12T16:22:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍EPaxos算法。</p><a id="more"></a><h1 id="Epaxos的简介"><a href="#Epaxos的简介" class="headerlink" title="Epaxos的简介"></a>Epaxos的简介</h1><p>EPaxos是一个Leaderless的算法，具有以下的优点：</p><ol><li>Client可以任意选择一个节点发送Command，这个Command的Commit的路径大部分都不会干扰到其他的Command。而在诸如Raft的算法中，必须有一个Master显式向其他节点复制日志。并且也避免了Client可能和一个跨地区的Master交互的情况。</li><li>因为没有Leader选举的过程，所以整个集群的可用性变高了。</li></ol><p>讨论Basic Paxos算法，当收到来自Client的Command后，某个replica会尝试成为一个尚未被使用过的instance的Leader，方式是发送Prepare消息。其他replica对Prepare的返回值，首先包含了它们认为的已经被chosen的Command(如果出现这种情况，Leader后面也需要使用这个Command)。在返回值中还会包含不会再ack早前的Leader发送的更旧的消息的承诺。在收到majority的对Prepare的ack之后，这个Leader会发送Accept消息。当Accept消息再被majority确认后，Leader会在本地记录Command已被Commit，并且异步通知Peer和Client。</p><p>容易发现，Paxos算法需要Prepare和Accept两个阶段，才能完成一个Command的提交。这是不经济的，因为即使从Raft的经验来看，只要Leader一直存在，那么一轮就可以决定一个instance，也就是Log Entry的值了。此外Basic Paxos中如果多个Leader打架，那2轮都不够。因此MultiPaxos中引入了stable leader(又称为distinguished proposer)的机制来处理。</p><p>EPaxos的设计目标是：</p><ol><li>减少Commit时延</li><li>优化Load Balance</li><li>对于较慢甚至故障的节点，提供一个优雅的降级方案</li></ol><p>为此，EPaxos需要做到：</p><ol><li>每个节点都可以同时作为Proposer(Command Leader)</li><li>每个Proposer在和最小数量的节点交流后就可以Commit，并且交流的次数也要最小化<br> 类似generic broadcast算法，以及Generalized Paxos算法，会广播消息。但如果两个Command不互相影响，实际上并没有必要强制他们有一个consistent的顺序。<br> 而在实际workload上，可以认为大部分的Command是这样的，也就是说它们修改的是不同的对象。</li><li>Quorum的组成应当是可变的</li></ol><p>EPaxos做到这些，得益于它给Command定序的方案。在这之前，诸如MultiPaxos和GenerizedPaxos选择通过一个Leader来选择顺序；而在 canonical Paxos和Mencius中选择将这些Command放入已经预先分配好的instance空间中。</p><p>EPaxos的方案是当对一个Command投票时，每个参与者需要附带上对这个Command的Order Constraints。EPaxos能够保证所有正常的节点能够以提交同样的Command和Order Constraints。</p><p>简介一下EPaxos的方案。当一个Command被发送给某个replica时，该replica就被称为Command Leader。这个称呼特意区别于MultiPaxos中的Leader，因为显而易见，同时可能存在多个Command Leader。</p><p>如果Command之间不冲突，如下图的左边所示，两个Command分别更新<code>obj_A</code>和<code>obj_B</code>。为了Commit这个Command，可以走论文中说的Fast Path。Command Leader需要和<code>F + floor((F + 1) / 2)</code>(称为fast-path quorum)个Peer交互。其中F是允许失败的节点的个数，对应到下图，F为2。特别地，对于常见的3节点集群，Fast-path Quorum为2；对于5节点集群，Fast-path Quorum为3，都等于传统的简单多数。</p><p>【Q】这里有个疑问，不同对象的先后顺序，有影响么？比如实际上一个Client先于<code>obj_B</code>写<code>obj_A</code>，但<code>obj_B</code>先于<code>obj_A</code>被Commit，当Client收到<code>obj_B</code>的时候读取<code>obj_A</code>，那么可能读到<code>obj_A</code>的stale的数据呢？可以看下面的Execution linearizability说明。</p><p>如果两个Command互相冲突，如下图的右边所示，C3和C4同时更新<code>obj_A</code>，就不能走Fast Path了。在提交的时候需要附带上Order Constraint。为了保证所有的Replica在存在部分节点故障的情况下，都能提交相同的Order Constraint，需要另一轮的通信。这一轮通信中，Command Leader需要和<code>F + 1</code>个Peer交互。这就是Slow Path，<code>F + 1</code>也就是传统意义上的简单多数Quorum。</p><p><img src="/img/epaxos/f1.png"></p><h2 id="EPaxos和其他算法的比较"><a href="#EPaxos和其他算法的比较" class="headerlink" title="EPaxos和其他算法的比较"></a>EPaxos和其他算法的比较</h2><p>在MultiPaxos中，Leader会负责Propose所有的Command。这样会导致Leader处理O(n)个请求，同时非Leader节点只会处理O(1)个请求，负载十分不均衡。</p><p>为了解决MultiPaxos的问题，Mencius选择逐Command将Paxos Leader在多个节点之间轮换。也就是说节点<br><code>R_id</code>拥有instance i，当i满足<code>(i mod N) = R_id</code>。这里的坏处是，每一次Commit Command A之前都需要询问所有节点。否则按照这个轮换顺序，另一个依赖于A的Command B可能在Command A之前被提交。这个询问过程会产生两个后果，首先是整个Commit的速度由最慢的那个Replica决定；其次是当一个节点Fail后，整个过程将block住，直到其他节点发现这个节点Fail掉了，并替他返回一个NoOp。</p><p>FastPaxos为了解决从Propose到Commit的延迟，选择让Client同时向所有的Replica发送Propose。MultiPaxos一样使用了Stable Leader，不仅用来开启voting round，也用来仲裁各个Acceptor的顺序(考虑到每个Acceptor可能以不同顺序收到)。</p><p>Generalized Paxos的方案是当Command之间不互相影响时，对它们乱序提交。Replicas learn commands after just two message<br>delays—which is optimal—as long as they do not interfere。TODO 后面看不懂了。</p><p>EPaxos相对于Generalized Paxos有三点优势：</p><ol><li>EPaxos的Fast Path Quorum Size比Generalized Paxos的正好小一个，能够减小延迟(应该是木桶效应吧)，以及总的消息量</li><li>EPaxos解决冲突，也就是Slow Path只需要额外一轮，但Generalized Paxos需要两轮</li><li>对于three-site replication而言，EPaxos即使在所有Command都冲突的情况下，只需要和距离Proposer最近的Replica通信一轮，即可Commit</li></ol><p>EPaxos和Fast/Generalized Paxos的<strong>Fast Path</strong>的一个重要区别是，EPaxos需3 message delays来Commit，但Fast等只需要2个。但一般EPaxos的第一个Delay可以忽略掉，因为Client和最接近的Replica通常都在一个数据中心中。</p><p>S-Paxos TODO</p><h1 id="EPaxos的实现"><a href="#EPaxos的实现" class="headerlink" title="EPaxos的实现"></a>EPaxos的实现</h1><p>结合了两篇论文的内容</p><h2 id="预备内容"><a href="#预备内容" class="headerlink" title="预备内容"></a>预备内容</h2><p>在允许F个失效节点的分布式系统中，至少存在N=2F+1个节点。对于每一个节点R，它拥有的instance写为序列R1, R2, …。在每个instance中，只有一个Command能被选出。需要注意的是，R1、R2等instance的order，并不是已经确定的，而是由协议来动态确定。</p><p>Commands γ和δ是interfere的，当存在一系列指令Σ使得顺序执行Σ,γ,δ不等价于顺序执行Σ,δ,γ。这里不等价包含它们会导致不同的状态机状态，或者导致在这些序列中读取到的值是不同的。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>Nontriviality<br> 所有被Commit的Command都由Client发出。</li><li>Stability<br> 对于任意Replica，不会丢失已经Commit的数据。<br> 进一步地，如果在t1时刻，Replica R在Q.i这个instance上提交了Command Y，那么在t1之后的任意时刻t2，R上的instanceQ.i的值也是Command Y。<br> 【Q】这里有个疑问，Q是哪里来的？不应该是R么？应该不矛盾，作为Acceptor，R也会有Q拥有的instance的信息的，不然怎么投票？</li><li>Consistency<br> 同一个instance在Commit之后，就在各个Replica上的值都是一样的。</li><li>Execution consistency<br> 如果两个interfere的Command Y和Z在任意Replica上被成功Commit了，那么所有Replica上的执行顺序是一样的。</li><li>Execution linearizability<br> 如果Client对Command Y和Command Z是serialized的，比如说在Command Y被Commit之后，才会Propose Command Z，那么所有的Replica都会先执行Y再执行Z。</li><li>Liveness<br> 活性</li></ol><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>基础版本的fast-path quorum是<code>2F</code>，后面优化版本的才是<code>F + floor((F + 1) / 2)</code></p><h3 id="Commit-Protocol"><a href="#Commit-Protocol" class="headerlink" title="Commit Protocol"></a>Commit Protocol</h3><p>Commit Protocol解决两个问题：</p><ol><li>Commit Command</li><li>Determine Order Between Commands</li></ol><p>在论文的Figure2中描述了Commit Protocol的整个过程，在Commit过程中，并不是每个过程都会走到。如果一个Command没有冲突，就可以走Fast Path，这也意味着走完Phase 1就能够直接提交了。Slow Path还需要额外的Phase 2(Paxos-Accept phase)。如果我们进行failure recovery，则需要运行Figure3描述的Explicit Prepare过程。</p><p>当一个Replica收到来自Client的Command γ后，会给这个Command γ分配一个全局唯一的instance number，例如R1、Q2等。全局唯一是通过组合Replica的名字，以及在Replica中递增的序列号保证的。这里Replica是可以将多个操作组合到一个instance中的。除了分配instance number之外，Replica还会给Command分配一个dependency set(deps)和一个sequence number(seq)，<strong>称为attribute</strong>。Dependency set包含了每个Replica中<strong>最高的</strong>和自己冲突的instance编号。Sequence number会选取一个大于dependency set中所有值的值作为<strong>初始值</strong>。The originating replica derives the dependency set and sequence number for a new instance from all other instances it has knowledge of。对于每个修改了新Command操作对象的Replica，需要持久化它们的最高的instance number和sequence number。</p><p>Command Leader通过<strong>PreAccept消息</strong>，即<code>(γ,seqγ,depsγ,pre-accepted)</code>，将Command以及deps和seq发送给至少fast-path quorum(在这里是2F)个Replica。每个Replica在收到后，会<strong>根据自己的cmds log</strong>来更新Command γ的deps和seq，并将γ和新的attribute记录在自己的log中，然后回复给Command Leader。</p><p>如果Command Leader满足了fast-path quorum，并且所有更新了的attribute(seq和deps)是一样的(根据Figure2的第10行代码，不包括Command Leader)，那么可以直接Commit。否则就需要走Slow Path。</p><p>在运行Slow Path前，我们得更新seq和deps。其中deps是从每个Replica之间的union，seq取每个Replica过来的最大的seq。然后在Slow Path中，Command Leader会给另外F个Replica发送Accept请求，让它们Accept三元组<code>(γ,seq,deps)</code>。其实这个过程类似于Basic Paxos的Accept阶段。</p><p>在Slow Path完成了取得了F + 1票后，就可以和Fast Path会师了。此时Command Leader会发送Commit消息给所有的Replica，并且返回给Client。</p><p>类似于经典的Paxos，EPaxos也会给每个消息(message)分配一个ballot number。每个Replica会忽略小于它们已经见过的最大的ballot number。这个ballot number格式为<code>epoch.b.R</code>，其中：</p><ol><li>epoch<br> 如果集群的配置有变动，那么epoch会变化</li><li>b<br> 如果某个replica R，在做Explicit Prepare时，需要创建一个新的ballot时，会自增b</li><li>R<br> 表示这个Replica</li></ol><p>每个Replica是自己拥有的instance的<strong>初始</strong>Leader，换言之，对于每个instance <code>R.i</code>，隐式存在一个<code>epoch.0.R</code>。</p><p><img src="/img/epaxos/f2.png"></p><h3 id="Explicit-Prepare过程"><a href="#Explicit-Prepare过程" class="headerlink" title="Explicit Prepare过程"></a>Explicit Prepare过程</h3><p>【这一块还包含了优化部分，比较难懂】<br>假如说Replica L可能宕机了，那么Replica Q会尝试接管它的instance L.i。</p><p>首先，将ballot number设置为epoch.(b + 1).Q，其中epoch.b.R是Q知道的L.i中最大的ballot number。然后，发送<code>Prepare(epoch.(b + 1).Q,L.i)</code>给包括自己在内的所有Replica，并且等待至少<code>floor(N/2) + 1</code>个回复。令R等于the set of replies w/ the highest ballot number：</p><ol><li>如果R中包含了<code>(γ,seqγ,depsγ,committed)</code>，则在L.i对(γ,seqγ,depsγ)运行Commit Phase。</li><li>再如果R中包含了<code>(γ,seqγ,depsγ,accepted)</code>，运行Paxos-Accept phase。</li><li>再如果R包含了至少<code>floor(N / 2)</code>个不同的对<code>L.i</code>上默认的ballot即<code>epoch.0.L</code>的回复<code>(γ,seqγ,depsγ,pre-accepted)</code>，并且没有一个回复是来自于L的，则运行Paxos-Accept phase。<br> 【优化算法】此时，只需要包含<code>floor((F + 1) / 2)</code>个PreAccept了<code>(γ,seqγ,depsγ)</code>这个三元组的Replica即可。在发现他们后，新的Command Leader Q会尝试向其他Replica发送TryPreAccept消息。在某个Replica收到TryPreAccept消息后，会判断这个三元组是否和自己已有的log冲突：一个Command的deps中不包括γ，并且depsγ中也不包括这个Command(简单来说两个Command的deps互相不包含)，那么这个Command就和γ冲突；或者这个Command虽然在depsγ中，但是它的seq大于等于seqγ，那么也是和γ冲突的。只有当自己的log中没有这些冲突Command时，这个Replica才会回复TryPreAccept。<br> 如果真的存在某个Command和三元组冲突，并且这个Command被Commit了，那么Q就知道γ不能再fast path中被提交。但如果这个Command没有被Commit，那么新的Comamnd Leader Q就会defer，知道这个Command被Commit。最后，如果Q能够得到F + 1个Replica(在计算F时，老Command Leader也被计算在内)的PreAccept票后，就可以运行Paxos-Accept phase了。<br> 这里有一个Corner case，也即是当deps中的某个Command修改它的seq，然后比需要Recover的Command γ的seq还要大了。为了阻止这个情况，对于depsγ中的所有Command，至少需要有一个Acceptor记录为Commit状态后，才允许Command Leader走Fast Path提交。对于N小于7的情况，更有效的方案是将更新后的deps放到Accept和AcceptReply消息中，并且保证这些消息的接收方都去缓存了它们。这些信息只会被用来辅助Recovery。<br> 【Q】为啥优化算法只改这一个分支？</li><li>再如果R包含了至少一个<code>(γ,seqγ,depsγ,pre-accepted)</code>，则在L.i上执行Phase1，Command为γ，并且避免fast path。</li><li>最终，则在L.i上执行Phase1，Command为noop，并且避免fast path。</li></ol><p>Replica R, 在收到来自Q的Prepare(epoch.b.Q,L.i)后：</p><ol><li>如果epoch.b.Q比最近接受到来自L.i的请求epoch.x.Y大，则返回PrepareOK(cmdsR[L][i], epoch.x.Y,L.i)</li><li>否则返回NAC</li></ol><p><img src="/img/epaxos/f3.png"></p><h3 id="Execution-Protocol"><a href="#Execution-Protocol" class="headerlink" title="Execution Protocol"></a>Execution Protocol</h3><p>为了执行在R.i这个instance上提交的Command γ，需要执行下面的步骤：</p><ol><li>等待R.i被提交，或者运行Explicit Prepare过程强制这个过程</li><li>构造γ的依赖图，其中需要加入γ的dependency set中的所有Command<br> 注意，这个过程是递归的，也就是我们需要考虑依赖的依赖</li><li>找到所有的SCC，并对这些SCC进行拓扑排序</li><li>根据逆拓扑序，执行：<ol><li>对于SCC中的所有命令，按照sequence number(seq)从低到高排序</li><li>按照这个顺序执行所有尚未被执行的Command，并标记他们为已被执行</li></ol></li></ol><h2 id="关于性质的-Informal-证明"><a href="#关于性质的-Informal-证明" class="headerlink" title="关于性质的(Informal)证明"></a>关于性质的(Informal)证明</h2><h3 id="Nontriviality"><a href="#Nontriviality" class="headerlink" title="Nontriviality"></a>Nontriviality</h3><h3 id="Stability和Consistency"><a href="#Stability和Consistency" class="headerlink" title="Stability和Consistency"></a>Stability和Consistency</h3><p>先证明命题1：如果Replica R通过instance Q.i提交了Commit γ(这里R和Q可能是同一个Replica)，那么对于任意的提交Q.i的Replica R’，它提交的Command γ’一定等于γ。</p><p>证明简要：如果说Command γ能被在Q.i这个instance中提交，一定是因为γ的Phase 1是在instance Q.i中被启动的。这是因为：</p><ol><li>对于每个新Command，Q会自增instance number，也就是这里的i</li><li>如果Q宕机并重启了，那么根据”4.7 Reconfiguring the Replica Set”，它会被分配得到一个新的identifier<br> 【TODO】这里需要详细解释下。</li></ol><p>可以看到，命题1实际上暗示了consistency。进一步地，在Replica崩溃时，Command可能被丢失，所以当Command Log被保存在持久化存储上时，也暗示了stability。</p><p>首先引入一个定义。如果Command γ具有seqγ和depsγ，如果元组(γ,seqγ,depsγ)是Q.i这个instance上唯一被或者可能被commit的元组，那么我们称元组(γ,seqγ,depsγ)在Q.i这个instance上是safe的。</p><p>下面证明命题2：Replica只会提交safe的tuple。首先知道(γ,seqγ,depsγ)如果在Q.i被提交，那么它要么在Paxos Accept phase提交，或者在Phase 1之后提交。</p><ol><li>对于第一种情况，即Slow Path。此时有多于半数的Replica写入了值(Figure2的L20)，这对应了经典Paxos的要求。</li><li>对于第二种情况，即Fast Path。此时Coomand Leader收到了不含自己的N-2个相同的回复(Figure2的L11)。如果此时另外的Replica需要接管这个instance，通常这是因为初始的Leader宕机了，那么新Leader必须执行Prepare过程，并且会发现至少<code>floor(N/2)</code>个Replica都返回(γ,seqγ,depsγ)这个元组。因此新的Leader会认为这个元组可能提交了，并在Paxos-Accept过程中使用这个元组。</li></ol><p>至此我们可以发现，元组们，包括他们的attributes，都会在各个Replica之间被consistently和stable地提交。</p><p>下面我们证明这些consistent和stable的attributes能够保证所有互相interfere的Command，在每个Replica上都按照同样的顺序被提交。</p><h3 id="Execution-consistency和Execution-linearizability"><a href="#Execution-consistency和Execution-linearizability" class="headerlink" title="Execution consistency和Execution linearizability"></a>Execution consistency和Execution linearizability</h3><p>引理1 (Execution consistency)：<br><strong>如果互相interfere的两个Command γ和δ都被成功Commit了(并不一定通过同一个Replica提交)，那么他们在任意Replica上都会以相同的顺序被执行</strong>。</p><p>如果两个Command互相interfere，至少有一个Command的deps中能找到另一个Command。Phase1在这个命令被至少简单多数(注意我们现在讲的还是基础版本的EPaxos，其中Phase1的Fast Path Quorum为2F)个Replica Pre-Accepted后结束，并且这个命令最终的deps集是由至少简单多数个Replica的deps的union。这也同样适用于recovery过程中使用的Explicit Prepare(L32)的情况，因为所有的依赖都是基于那些被可能宕机的Leader初始设置的集合计算得到。所以至少一个Replica同时PreAccept γ和δ，并且它的PreAcceptReplies被用来构造γ和δ的最终的deps集。</p><p>通过执行Execution Algorithm，一个命令只有在自己dependency graph中的所有命令都被Commit后才会执行。主要有三个场景：</p><ol><li>两个Command都在彼此的dependency graph中，这也意味着dependency graph是identical的，并且γ和δ在同一个SCC中。所以当执行一个Command时，另一个Command也会被执行，并且是根据sequence number来执行的。根据命题2，这些已Commit的Command的attribute在所有Replica上都是stable和consistent的。所以所有dependency graph相同的Replica都会在相同的顺序中执行γ和δ。</li><li>γ在δ的dependency graph中(δ依赖γ)，但δ不在γ的dependency graph中。也就是说dependency graph有一个从δ到γ的路径，反之不成立。因此γ和δ来自不同的SCC，在逆拓扑序即实际的执行顺序中，γ在δ前面。补充一点，在一些Replica中，γ在δ被Commit之前就被执行了，这样的场景是没毛病的，因为γ并不依赖于δ。</li><li>δ在γ前面，这个就是上面的对称形式。</li></ol><p>引理2 (Execution linearizability)：<br>如果两个Command γ和δ，被客户端指定了顺序，例如只有在γ被任意Replica Commit之后才会Propose δ，这样的话我们要求所有的Replica都要在δ之前执行γ。</p><p>证明。因为δ是在γ Commit之后被Propose的，所以在任何Replica收到Command δ的PreAccept时，γ的Sequence Number应该是Stable和Consist的。因为一个包含γ的元组，以及它最终的sequence number至少被majority个Replica记录，那么δ的sequence number会最终被更新到大于γ的值，并且delta的deps中会包含γ。所以在执行δ时，δ的dependency graph必须包含γ，并且：</p><ol><li>它们在同一个SCC中</li><li>按照逆拓扑序，γ在δ前面的一个SCC中。</li></ol><p>无论那种情况，γ都会在δ前面执行。</p><h3 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h3><p>只要不是大多数Replica有故障，那么Client会一直重试某个Command，直到被Accept。</p><h2 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h2><p>优化版本会修改Recovery过程，也就是Explicit Prepare Phase。我已经写到“Explicit Prepare过程”上面了。</p><p>当F个Replica宕机后，在Fast Quorum中就只有<code>floor((F + 1) / 2)</code>个存活的成员(可以翻翻前面Fast-Path Quorum的定义)，那么就不能在剩下的Replica中形成多数了。所以，当Command Leader向所有Replica(而不只是Fast Quorum中的Replica)发送PreAccept消息后，Recovery过程不一定能正确地发现，老的Command Leader，是通过哪些Replica的回复，从而Commit了这个instance的。 Still, such redundancy is sometimes desirable because the command leader may not know in advance which replicas are still live or which replicas will reply faster。<br>对于这种情况，需要修改Fast Path的条件：当Command Leader收到<code>F + floor((F + 1) / 2) - 1</code>个满足initial ordering attributes的PreAccept的回复，才会选择Fast Path。并且这些Replica需要被记录到Log中，以便在Recovery过程中只考虑这些Replica。<br>在不发送redundant PreAccept的时候(【Q】什么时候会发送？)，一个三副本的系统永远可以通过Fast Path提交，这是因为在做还有一个Acceptor的集合中肯定不存在disagreement。</p><h1 id="EPaxos的TLA-简介"><a href="#EPaxos的TLA-简介" class="headerlink" title="EPaxos的TLA+简介"></a>EPaxos的TLA+简介</h1><p>如果光读论文就能读懂，那我感觉你真的挺厉害的，反正我是半懂不懂的，特别是对Recovery部分。所以我转过来看TLA+了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>下面是对SlowQuorum和FastQuorum的定义。对于某个Replica r，SlowQuorum(r)表示它作为Command Leader时，所有可能的Slow Path Quorum组成的集合，也就是类似于<code>{ {r,a}, {r,b} }</code>这样的东西。那么，<code>SlowQuorum(r)</code>必须是<code>SUBSET Replica</code>的子集，换句话说，就是不能出现Replica之外的元素。然后对于SlowQuorum中的任意的Quorum SQ，它必须包含r，并且大小为<code>N/2+1</code>，其中N为集群大小。<br>同理，FastQuorum中的大小为<code>N/2 + (N/2+1)/2</code>，这个其实就是把<code>F = N/2</code>带入进去就得到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS FastQuorums(_), SlowQuorums(_)</span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ SlowQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A SQ \in SlowQuorums(r): </span><br><span class="line">    /\ r \in SQ</span><br><span class="line">    /\ Cardinality(SQ) = (Cardinality(Replicas) \div 2) + 1</span><br><span class="line"></span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ FastQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A FQ \in FastQuorums(r):</span><br><span class="line">    /\ r \in FQ</span><br><span class="line">    /\ Cardinality(FQ) = (Cardinality(Replicas) \div 2) + </span><br><span class="line">                         ((Cardinality(Replicas) \div 2) + 1) \div 2</span><br></pre></td></tr></table></figure><p>下面是对一些状态的定义。Commands是一个常量，表示所有可能的命令，在运行前由我们给出。none是一个none Command(也许是Noop？)，对它的定义还挺新颖的，如果是我，可能选择直接CONSTANT了一个Nil的值。<br>Instance是做了一个笛卡尔积，没啥讲的。<br>Status标记了Log中的某个Command可能处于的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS Commands</span><br><span class="line">none == CHOOSE c : c \notin Commands</span><br><span class="line">Instances == Replicas \X (1..Cardinality(Commands))</span><br><span class="line">Status == &#123;&quot;not-seen&quot;, &quot;pre-accepted&quot;, &quot;accepted&quot;, &quot;committed&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面是Replica之间可能发送的消息。这里的TLA+语法可以参考<a href="/2021/06/26/tla/">TwoPhase章节</a>。</p><ol><li>pre-accept、pre-accept-reply<br> Phase1由Command Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,pre-accepted)</code><br> 注意要区分这里的committed字段，和全局的committed变量</li><li>accept、accept-reply<br> Phase2由Commmand Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,accepted)</code></li><li>commit<br>Commit阶段由Command Leader发起的消息，即<code>(γ,seqγ,depsγ,committed)</code></li><li>prepare、prepare-reply<br> Explicit Prepare阶段由新的Command Leader Q发起的消息。</li><li>try-pre-accept、try-pre-accept-reply<br> 优化算法</li></ol><p>一些常见字段的说明：</p><ol><li>src和dst都属于Replicas。</li><li>inst属于Instances表示当前操作的实例。</li><li>ballot应该是指的ballot number，不是<code>epoch.b.R</code>么？看起来是吧epoch和b合并了？</li><li>cmd应该是指instance中包含的command。</li><li>deps和seq就是所谓的attribute，没啥讲的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Message ==</span><br><span class="line">        [type: &#123;&quot;pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;commit&quot;&#125;,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        deps: SUBSET Instances, seq: Nat, committed: SUBSET Instances]</span><br><span class="line">  \cup  [type: &#123;&quot;accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, prev_ballot: Nat \X Replicas,</span><br><span class="line">        status: Status,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, status: Status \cup &#123;&quot;OK&quot;&#125;]</span><br></pre></td></tr></table></figure><p>下面是定义变量，可以结合TypeOK和Init条件看出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VARIABLES cmdLog, proposed, executed, sentMsg, crtInst, leaderOfInst,</span><br><span class="line">          committed, ballots, preparing</span><br><span class="line"></span><br><span class="line">TypeOK ==</span><br><span class="line">    /\ cmdLog \in [Replicas -&gt; SUBSET [inst: Instances, </span><br><span class="line">                                       status: Status,</span><br><span class="line">                                       ballot: Nat \X Replicas,</span><br><span class="line">                                       cmd: Commands \cup &#123;none&#125;,</span><br><span class="line">                                       deps: SUBSET Instances,</span><br><span class="line">                                       seq: Nat]]</span><br><span class="line">    /\ proposed \in SUBSET Commands</span><br><span class="line">    /\ executed \in [Replicas -&gt; SUBSET (Nat \X Commands)]</span><br><span class="line">    /\ sentMsg \in SUBSET Message</span><br><span class="line">    /\ crtInst \in [Replicas -&gt; Nat]</span><br><span class="line">    /\ leaderOfInst \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line">    /\ committed \in [Instances -&gt; SUBSET ((Commands \cup &#123;none&#125;) \X</span><br><span class="line">                                           (SUBSET Instances) \X </span><br><span class="line">                                           Nat)]</span><br><span class="line">    /\ ballots \in Nat</span><br><span class="line">    /\ preparing \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line"></span><br><span class="line">Init ==</span><br><span class="line">  /\ sentMsg = &#123;&#125;</span><br><span class="line">  /\ cmdLog = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ proposed = &#123;&#125;</span><br><span class="line">  /\ executed = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ crtInst = [r \in Replicas |-&gt; 1]</span><br><span class="line">  /\ leaderOfInst = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ committed = [i \in Instances |-&gt; &#123;&#125;]</span><br><span class="line">  /\ ballots = 1</span><br><span class="line">  /\ preparing = [r \in Replicas |-&gt; &#123;&#125;]</span><br></pre></td></tr></table></figure><ol><li>cmdLog<br> 每个Replica上的日志。<br> 每条日志中包含对应的Instance、Status，ballot、Command、以及deps和seq</li><li>proposed<br> 已经被被Propose了的Command</li><li>executed<br> 每个Replica上已经被execute的Command</li><li>sentMsg<br> 所有被发送，但是还没有被接受的消息，理解成Message类型对象的集合</li><li>crtInst<br> 对于每个Replica，它下一个可以使用的instance number(一个数字)，初始值是1</li><li>leaderOfInst<br> 这是从Replicas到SUBSET Instances的一个映射，表示对于每个Replica，它发起但是还没有完成的Instance的集合</li><li>committed<br> 【Q】maps commands to set of commit attributs tuples<br> 从实现上来看，应该是个三元组，表示每个Command被提交时的deps和seq</li><li>ballots<br> 所有Replica中，最大的ballot number，这里指的应该是epoch.b</li><li>preparing<br> 对于每个Replica，它目前正在preparing(例如recovering)的所有Instance</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>Nontriviality的验证，对于任意的Instance，始终(因为有<code>[]</code>)有：在committed中的所有Command，它要么是在proposed集合中(也就是被某个Command Leader主动Propose的)，或者为none</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nontriviality ==</span><br><span class="line">    \A i \in Instances :</span><br><span class="line">        [](\A C \in committed[i] : C \in proposed \/ C = none)</span><br></pre></td></tr></table></figure><p>Stability的验证，是个三层大循环，遍历所有的Replica/Instances/Commands，此时我们检查(replica, i, C)，<strong>始终</strong>满足：<br>在replica的cmdLog[replica]中任选一条记录rec1，它的(inst,cmd)等于(replica, i)，并且status为committed或者executed，那么<strong>始终</strong>存在另一个满足条件的rec2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stability ==</span><br><span class="line">    \A replica \in Replicas :</span><br><span class="line">        \A i \in Instances :</span><br><span class="line">            \A C \in Commands :</span><br><span class="line">                []((\E rec1 \in cmdLog[replica] :</span><br><span class="line">                    /\ rec1.inst = i</span><br><span class="line">                    /\ rec1.cmd = C</span><br><span class="line">                    /\ rec1.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;) =&gt;</span><br><span class="line">                    [](\E rec2 \in cmdLog[replica] :</span><br><span class="line">                        /\ rec2.inst = i</span><br><span class="line">                        /\ rec2.cmd = C</span><br><span class="line">                        /\ rec2.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;))</span><br></pre></td></tr></table></figure><p>Consistency的验证，对于所有的Instance i，始终满足它最多只会被commit一次。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consistency ==</span><br><span class="line">    <span class="string">\A</span> i <span class="string">\in</span> Instances :</span><br><span class="line">        [](Cardinality(committed[i]) &lt;= <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">THEOREM Spec =&gt; ([]TypeOK) <span class="regexp">/\ Nontriviality /</span><span class="string">\</span> Stability /<span class="string">\</span> Consistency</span><br></pre></td></tr></table></figure><h2 id="总体的Action"><a href="#总体的Action" class="headerlink" title="总体的Action"></a>总体的Action</h2><p>可以选择执行Command Leader的某个动作，或者普通Replica的某个动作。Command Leader肯定属于Replica，但我们是按照行为来区分的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Next == </span><br><span class="line">    \/ CommandLeaderAction</span><br><span class="line">    \/ ReplicaAction</span><br></pre></td></tr></table></figure><p>首先是Command Leader的所有可能的动作：</p><ol><li>检查<code>Commands \ proposed</code>，也就是<code>Commands</code>中所有还没被propose的Command，如果存在，则<strong>选择一个C</strong>(<code>\E</code>可以表示选出一个的意思)：<br> 选出一个cleader，对C做状态转移<code>Propose(C, cleader)</code></li><li>在Replicas中选出一个cleader，在cleader为Command Leader的instance中选出一个instance，可以执行下面任意的状态转移：<ol><li>可能走Fast Path</li><li>可能走Slow Path</li><li>可能走Phase2Finalize<br> 【Q】Phase2的Accept啥时候发送的？</li><li>可能走优化路径FinalizeTryPreAccept</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLeaderAction ==</span><br><span class="line">    \/ (\E C \in (Commands \ proposed) :</span><br><span class="line">            \E cleader \in Replicas : Propose(C, cleader))</span><br><span class="line">    \/ (\E cleader \in Replicas : \E inst \in leaderOfInst[cleader] :</span><br><span class="line">            \/ (\E Q \in FastQuorums(cleader) : Phase1Fast(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase1Slow(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase2Finalize(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : FinalizeTryPreAccept(cleader, inst, Q)))</span><br></pre></td></tr></table></figure><p>下面是ReplicaAction，选择一个Replica：</p><ol><li>可能回复Phase1</li><li>可能回复Phase2</li><li>可能对于某个Instance i，<code>i[1]</code>表示Instance这个tuple的第一个元素，也就是Replica；<code>crtInst[i[1]]</code>表示它对应的Replica下一个可以使用的instance number，如果大于i本身的instance number。<br> 这个条件说明这个instance被自己原来的owner start。<br> 则通过SlowQuorum个节点进行SendPrepare。<br> 【Q】不太懂什么意思，但这里无疑就是Explicit Prepare里面的Prepare过程了。</li><li>可以ReplyPrepare</li><li>选择一个正在preparing的Replica<br> 通过SlowQuorum个节点进行PrepareFinalize</li><li>回复ReplyTryPreaccept</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReplicaAction ==</span><br><span class="line">    \E replica \in Replicas :</span><br><span class="line">        (\/ Phase1Reply(replica)</span><br><span class="line">         \/ Phase2Reply(replica)</span><br><span class="line">         \/ \E cmsg \in sentMsg : (cmsg.type = &quot;commit&quot; /\ Commit(replica, cmsg))</span><br><span class="line">         \/ \E i \in Instances : </span><br><span class="line">            /\ crtInst[i[1]] &gt; i[2] (* This condition states that the instance has *) </span><br><span class="line">                                    (* been started by its original owner          *)</span><br><span class="line">            /\ \E Q \in SlowQuorums(replica) : SendPrepare(replica, i, Q)</span><br><span class="line">         \/ ReplyPrepare(replica)</span><br><span class="line">         \/ \E i \in preparing[replica] :</span><br><span class="line">            \E Q \in SlowQuorums(replica) : PrepareFinalize(replica, i, Q)</span><br><span class="line">         \/ ReplyTryPreaccept(replica))</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><h3 id="Propose"><a href="#Propose" class="headerlink" title="Propose"></a>Propose</h3><p>从上文看到，CommandLeaderAction的一个可能的状态转移是Propose。<br>此时，生成newInst和newBallot。新生成的newInst的instance number为crtInst[cleader]，newBallot的<code>epoch.b</code>部分始终为0，看来是不考虑epoch了。<br>然后，将要Propose的Command C添加进proposed中，并且在FastQuorum里面选择一个Quorum，尝试走FastPath。<br>然后，我们自增crtInst，这里的<code>@</code>就是<code>crtInst[cleader]</code>，实际上是一个简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Propose(C, cleader) ==</span><br><span class="line">    LET newInst == &lt;&lt;cleader, crtInst[cleader]&gt;&gt; </span><br><span class="line">        newBallot == &lt;&lt;0, cleader&gt;&gt; </span><br><span class="line">    IN  /\ proposed&apos; = proposed \cup &#123;C&#125;</span><br><span class="line">        /\ (\E Q \in FastQuorums(cleader):</span><br><span class="line">                 StartPhase1(C, cleader, Q, newInst, newBallot, &#123;&#125;))</span><br><span class="line">        /\ crtInst&apos; = [crtInst EXCEPT ![cleader] = @ + 1]</span><br><span class="line">        /\ UNCHANGED &lt;&lt; executed, committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><p>对Phase1的处理起始于<code>StartPhase1</code>，这个状态转移触发的条件有很多，比如上面的Propose。<br>首先，构建依赖deps和seq：</p><ol><li>newDeps是Command Leader即cleader中所有Command的Instance，即<code>rec.inst</code>。<br> 【Q】这是不是太强了点？按照协议，首先要是冲突的，然后只要包含最高冲突Instance的编号就行啊。</li><li>newSeq是cleader中所有Command的seq的最大值，然后还要加1，这是符合协议的论述的。</li><li>oldRecs表示cleader中所有和当前Command的Instance相同的Command。</li></ol><p>然后进行状态转移：</p><ol><li>cmdLog<br> 需要修改cleader的Log。具体来说，需要把同Instance的所有的旧的日志全部干掉。【Q】为啥可能会有同Instance的日志呢？<br> 然后，我们把新的Command加上到日志中，并且设置status为”pre-accepted”。也就是说cleader我PreAccept了这个日志，并不代表其他Replica也PreAccept了这个日志。</li><li>leaderOfInst<br> 显然，对于这个Instance，cleader我是它的Leader。这是显然的，因为Instance二元组里面，Replica是cleader，然后instance number也是自增的。<br> 应该加入到leaderOfInst，表示是我发起的，但还没有完成的Instance。</li><li>sentMsg<br> 显然要往其他的Replica发消息。在此之前，我们先要把oldMsg干掉。如果我们是走Propose过来的，那么oldMsg是空的。但如果是走Explicit Prepare过来的，那么是会传入oldMsg的，这个到时候再说。<br> 这里需要注意，消息的定义是<code>src: Replicas, dst: Replicas</code>，但我们传进来的src和dst实际上是两个集合，这会导致产生一系列新Msg。可以参考<a href="/2021/06/26/tla/">TLA</a>的文档。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StartPhase1(C, cleader, Q, inst, ballot, oldMsg) ==</span><br><span class="line">    LET newDeps == &#123;rec.inst: rec \in cmdLog[cleader]&#125; </span><br><span class="line">        newSeq == 1 + Max(&#123;t.seq: t \in cmdLog[cleader]&#125;) </span><br><span class="line">        oldRecs == &#123;rec \in cmdLog[cleader] : rec.inst = inst&#125; IN</span><br><span class="line">        /\ cmdLog&apos; = [cmdLog EXCEPT ![cleader] = (@ \ oldRecs) \cup </span><br><span class="line">                                &#123;[inst   |-&gt; inst,</span><br><span class="line">                                  status |-&gt; &quot;pre-accepted&quot;,</span><br><span class="line">                                  ballot |-&gt; ballot,</span><br><span class="line">                                  cmd    |-&gt; C,</span><br><span class="line">                                  deps   |-&gt; newDeps,</span><br><span class="line">                                  seq    |-&gt; newSeq ]&#125;]</span><br><span class="line">        /\ leaderOfInst&apos; = [leaderOfInst EXCEPT ![cleader] = @ \cup &#123;inst&#125;]</span><br><span class="line">        /\ sentMsg&apos; = (sentMsg \ oldMsg) \cup </span><br><span class="line">                                [type  : &#123;&quot;pre-accept&quot;&#125;,</span><br><span class="line">                                  src   : &#123;cleader&#125;,</span><br><span class="line">                                  dst   : Q \ &#123;cleader&#125;,</span><br><span class="line">                                  inst  : &#123;inst&#125;,</span><br><span class="line">                                  ballot: &#123;ballot&#125;,</span><br><span class="line">                                  cmd   : &#123;C&#125;,</span><br><span class="line">                                  deps  : &#123;newDeps&#125;,</span><br><span class="line">                                  seq   : &#123;newSeq&#125;]</span><br></pre></td></tr></table></figure><h3 id="Phase1Reply"><a href="#Phase1Reply" class="headerlink" title="Phase1Reply"></a>Phase1Reply</h3><p>Propose是发送PreAccept请求，Phase1Reply是其他Replica处理该请求。<br>任选一个发给replica的type为”pre-accept”的消息msg。<br>oldRec为replica日志中，inst等于msg对应的Instance的日志组成的集合。<br>那么对于oldRec中所有的日志rec，要么它的ballot等于msg里的ballot，要么比msg传过来的ballot要小。否则这个消息就应该被忽略。</p><p>构造newDeps为msg传来的deps，加上当前replica所有的log中的Instance(除去msg.inst)。<br>构造newSeq为Max(msg.seq, replica的所有日志中最大的seq+1)。<br>构造instCom，为replica自己日志中所有status为”committed”或”executed”(其实就是已提交)的日志对应的Instance构成的集合。</p><p>下面是状态转移：</p><ol><li>修改当前replica的cmdLog<br> 主要是将status变成”pre-accepted”，然后deps和seq设置为刚算出来的newDeps和newSeq。</li><li>发送消息<br> 发送一条”pre-accept-reply”消息给msg.src，实际上就是刚才发命令过来的cleader。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Phase1Reply(replica) ==</span><br><span class="line">    <span class="string">\E</span> msg <span class="string">\in</span> sentMsg:</span><br><span class="line">        /<span class="string">\</span> msg.type = <span class="string">"pre-accept"</span></span><br><span class="line">        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">        /<span class="string">\</span> LET oldRec == &#123;rec <span class="string">\in</span> cmdLog[replica]: rec.inst = msg.inst&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rec <span class="string">\in</span> oldRec : </span><br><span class="line">                (rec.ballot = msg.ballot <span class="string">\/rec.ballot[1]</span> &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /<span class="string">\</span> LET newDeps == msg.deps <span class="string">\cup</span> </span><br><span class="line">                            (&#123;t.inst: t <span class="string">\in</span> cmdLog[replica]&#125; <span class="string">\</span> &#123;msg.inst&#125;)</span><br><span class="line">                   newSeq == Max(&#123;msg.seq, </span><br><span class="line">                                  <span class="number">1</span> + Max(&#123;t.seq: t <span class="string">\in</span> cmdLog[replica]&#125;)&#125;)</span><br><span class="line">                   instCom == &#123;t.inst: t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">                              tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125; IN</span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup</span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; msg.inst,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "pre-accepted",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; msg.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; msg.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; newDeps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; newSeq]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> &#123;msg&#125;) <span class="string">\cup</span></span><br><span class="line">                                    &#123;[type  |<span class="function">-&gt;</span> <span class="string">"pre-accept-reply"</span>,</span><br><span class="line">                                      src   |<span class="function">-&gt;</span> replica,</span><br><span class="line">                                      dst   |<span class="function">-&gt;</span> msg.src,</span><br><span class="line">                                      inst  |<span class="function">-&gt;</span> msg.inst,</span><br><span class="line">                                      ballot|<span class="function">-&gt;</span> msg.ballot,</span><br><span class="line">                                      deps  |<span class="function">-&gt;</span> newDeps,</span><br><span class="line">                                      seq   |<span class="function">-&gt;</span> newSeq,</span><br><span class="line">                                      committed|<span class="function">-&gt;</span> instCom]&#125;</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Fast"><a href="#Phase1Fast" class="headerlink" title="Phase1Fast"></a>Phase1Fast</h3><p>Phase1Fast是cleader在其他Replica处理该请求后，尝试通过FastPath提交这个请求。里面包含了是否能够进行FastPath提交的判断，以及提交的状态转移。<br>首先，是一部分简单的Enable条件，校验cleader是不是Instance i的Leader，并检查Q是不是cleader的FastQuorums。<br>然后，选择cleader的某条日志record，日志中的Instance为i、Status为”pre-accepted”、ballot的为0。这些日志肯定是从StartPhase1设置的。并且因为ballot为0，所以肯定是从Propose设置的。<br>Q通过刚才的Phase1Reply发回来的replies，它们是”pre-accept-reply”类型的消息，并且ballot等于record对应的ballot，我们进行下面的检查：</p><ol><li>对于Q中除了cleader之外的replica，在replies中都会有从它发给cleader的”pre-accept-reply”消息。<br> 也就是说Q中的Replica，都回复了cleader的pre-accept请求。<br> 这个检查是必要的，如果说之前cleader通过StartPhase1发过去的ballot比较小，那么有的replica就不会回复，因此这条Enable条件就过不了。</li><li>并且replies中任意两个消息r1和r2，它们的deps和seq是相等的。<br> 这是走FastPath的要求，只有满足该要求，才能进下一步。<br> 这个实际上也是Enable条件，如果不满足那么根本就不会有下面的状态转移。</li><li>CHOOSE replies中的某一个r，基于它构造新的r.deps：<br> 这里可以CHOOSE，是因为大家的deps和seq都一样。<br> 注意已提交的日志，指的是status为”committed”和”executed”的日志。<ol><li>localCom<br> cleader的所有的已提交日志的Instance构成集合。</li><li>extCom<br> Phase1Reply中，replica在回复时，会带上自己日志中所有已提交的日志对应的Instance构成的集合。<br> extCom是这些的并集。</li><li>然后构造新的r.deps集合，为localCom和extCom中所有的Instance</li></ol></li></ol><p>然后基于r构造状态转移：</p><ol><li>cmdLog<br> 更新这个日志状态为committed。<br> 更新当前的record的attribute为r.deps和r.seq。</li><li>sentMsg<br> 产生一条Commit信息，这个消息可能是直接给Client的，所以没有dst和src。</li><li>leaderOfInst<br> 在leaderOfInst[cleader]中移除掉当前的Instance i，表示这个Instance已经提交了。</li><li>committed<br> 将<code>&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;</code>加入已提交的数组中。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Phase1Fast(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> FastQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"pre-accepted"</span></span><br><span class="line">        /<span class="string">\</span> record.ballot[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i</span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"pre-accept-reply"</span></span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader</span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q</span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): </span><br><span class="line">                    <span class="string">\E</span> msg <span class="string">\in</span> replies: msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> r1, r2 <span class="string">\in</span> replies:</span><br><span class="line">                /<span class="string">\</span> r1.deps = r2.deps</span><br><span class="line">                /<span class="string">\</span> r1.seq = r2.seq)</span><br><span class="line">            /<span class="string">\</span> LET r == CHOOSE r <span class="string">\in</span> replies : TRUE IN</span><br><span class="line">                /<span class="string">\</span> LET localCom == &#123;t.inst: </span><br><span class="line">                            t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[cleader] : </span><br><span class="line">                                 tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125;</span><br><span class="line">                       extCom == UNION &#123;msg.committed: msg <span class="string">\in</span> replies&#125; IN</span><br><span class="line">                       (r.deps <span class="string">\subseteq</span> (localCom <span class="string">\cup</span> extCom))    </span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                        &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                          status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                          ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                          cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                          deps   |-&gt; r.deps,</span></span><br><span class="line"><span class="string">                                          seq    |-&gt; r.seq ]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                            &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                            inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                            ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                            cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                            deps    |<span class="function">-&gt;</span> r.deps,</span><br><span class="line">                            seq     |<span class="function">-&gt;</span> r.seq]&#125;</span><br><span class="line">                /<span class="string">\</span> leaderOfInst<span class="string">' = [leaderOfInst EXCEPT ![cleader] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                /\ committed'</span> = [committed EXCEPT ![i] = </span><br><span class="line">                                            @ <span class="string">\cup</span> &#123;&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;&#125;]</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Slow"><a href="#Phase1Slow" class="headerlink" title="Phase1Slow"></a>Phase1Slow</h3><p>Phase1Slow是cleader在其他Replica处理该请求后，尝试通过SlowPath提交这个请求。<br>前面的条件都一样，不再赘述。</p><p>主要不一样的地方是从finalDeps开始的。这里大家的deps和seq都不一定一样了，所以不能像FastPath一样CHOOSE了，而要老老实实取并集、取最大值。</p><ol><li>finalDeps<br> 就是所有来自Replica的回复中的deps的并集。</li><li>finalSeq<br> 就是所有回复中最大的seq。</li></ol><p>下面构造状态转移：</p><ol><li>cmdLog<br> 更新日志状态为”accepted”。<br> 注意，在FastPath中，能够直接进入commited状态，但这里得先是”accepted”，后面再走一轮Phase2才行。</li><li>sentMsg<br> 往除自己之外的SlowQuorum成员发送”accept”形式的消息。并且带上deps和seq为finalDeps和finalSeq。这个消息会在Phase2Reply被Replica处理。</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Phase1Slow(cleader, i, Q) ==</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>i <span class="tag">\<span class="name">in</span></span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>Q <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> record <span class="tag">\<span class="name">in</span></span> cmdLog[cleader]:</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.inst = i</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.status = "pre-accepted"</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>LET replies == &#123;msg <span class="tag">\<span class="name">in</span></span> sentMsg: </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.inst = i </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.type = "pre-accept-reply" </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.dst = cleader </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.src <span class="tag">\<span class="name">in</span></span> Q</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>(<span class="tag">\<span class="name">A</span></span> replica <span class="tag">\<span class="name">in</span></span> (Q <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>): <span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies: msg.src = replica)</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>LET finalDeps == UNION &#123;msg.deps : msg <span class="tag">\<span class="name">in</span></span> replies&#125;</span><br><span class="line">                   finalSeq == Max(&#123;msg.seq : msg <span class="tag">\<span class="name">in</span></span> replies&#125;) IN    </span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![cleader] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;record&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span> </span><br><span class="line">                                        &#123;[inst   |-&gt; i,</span><br><span class="line">                                          status |-&gt; "accepted",</span><br><span class="line">                                          ballot |-&gt; record.ballot,</span><br><span class="line">                                          cmd    |-&gt; record.cmd,</span><br><span class="line">                                          deps   |-&gt; finalDeps,</span><br><span class="line">                                          seq    |-&gt; finalSeq ]&#125;]</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> SQ <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader):</span><br><span class="line">                   (sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                            [type : &#123;"accept"&#125;,</span><br><span class="line">                            src : &#123;cleader&#125;,</span><br><span class="line">                            dst : SQ <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>,</span><br><span class="line">                            inst : &#123;i&#125;,</span><br><span class="line">                            ballot: &#123;record.ballot&#125;,</span><br><span class="line">                            cmd : &#123;record.cmd&#125;,</span><br><span class="line">                            deps : &#123;finalDeps&#125;,</span><br><span class="line">                            seq : &#123;finalSeq&#125;])</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><h3 id="Phase2Reply"><a href="#Phase2Reply" class="headerlink" title="Phase2Reply"></a>Phase2Reply</h3><p>Phase2Reply处理在SlowPath中，从Command Leader发过来的”accept”消息。</p><p>这里的Enable条件是，在自己的日志<code>cmdLog[replica]</code>中按照<code>msg.inst</code>找到对应的记录，要求消息的ballot要么等于，要么大于日志中的ballot。</p><p>如果满足Enable条件，则可以进行状态转移：</p><ol><li>cmdLog<br> 修改自己的日志，状态为”accepted”，并且更新deps和seq为msg中传入的值。这个值是由finalDeps和finalSeq一起计算得到的。</li><li>sentMsg<br> 发送”accept-reply”消息给cleader。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phase2Reply</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg: </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "accept"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica]: <span class="keyword">rec</span>.inst = msg.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec: (<span class="keyword">rec</span>.ballot = msg.ballot \/ </span><br><span class="line">                                    <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                &#123;[inst   |-&gt; msg.inst,</span><br><span class="line">                                  status |-&gt; <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot |-&gt; msg.ballot,</span><br><span class="line">                                  cmd    |-&gt; msg.cmd,</span><br><span class="line">                                  deps   |-&gt; msg.deps,</span><br><span class="line">                                  seq    |-&gt; msg.seq]&#125;]</span><br><span class="line">            /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                                &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "accept-reply",</span></span><br><span class="line">                                  src   |-&gt; replica,</span><br><span class="line">                                  dst   |-&gt; msg.src,</span><br><span class="line">                                  inst  |-&gt; msg.inst,</span><br><span class="line">                                  ballot|-&gt; msg.ballot]&#125;</span><br><span class="line">            /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                            committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase2Finalize"><a href="#Phase2Finalize" class="headerlink" title="Phase2Finalize"></a>Phase2Finalize</h3><p>Phase2Finalize是整个SlowQuorum过程的终点，cleader会收集各个Replica的消息，并提交Command。即对于cleader下的某个Instance i，和SlowQuorum Q，尝试完成Phase2的最终提交。</p><p>照例还是Enable条件，在自己的日志里面看看能不能找到i对应的状态为”accepted”的日志，如果找不到，那么也不用往下看了。<br>如果能找到，就需要在sentMsg中找出所有和这个Instance相关的，类型为”accept-reply”的消息(也就是各个Replica在Phase2Reply过程中发出的消息)。显然，对于Q中除cleader之外的replica，都需要发一条这样的消息才能继续提交。</p><p>下面就是状态转移，和Phase1Fast基本一致，就不另外说明了。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Phase2Finalize(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"accepted"</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i </span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"accept-reply"</span> </span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader </span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q </span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): <span class="string">\E</span> msg <span class="string">\in</span> replies: </span><br><span class="line">                                                        msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; record.deps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; record.seq ]&#125;]</span></span><br><span class="line"><span class="string">            /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                        &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                        inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                        ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                        cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                        deps    |<span class="function">-&gt;</span> record.deps,</span><br><span class="line">                        seq     |<span class="function">-&gt;</span> record.seq]&#125;</span><br><span class="line">            /<span class="string">\</span> committed<span class="string">' = [committed EXCEPT ![i] = @ \cup </span></span><br><span class="line"><span class="string">                               &#123;&lt;&lt;record.cmd, record.deps, record.seq&gt;&gt;&#125;]</span></span><br><span class="line"><span class="string">            /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">            /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>下面是Recovery相关操作。</p><h3 id="SendPrepare"><a href="#SendPrepare" class="headerlink" title="SendPrepare"></a>SendPrepare</h3><p>这里的replica就是论文里面的Replica L。其中，Enable条件：</p><ol><li>replica并不是i这个Instance的Leader<br> 这里注释掉一句，是replica并没有prepare这个instance。【Q】我不清楚为什么这个被注释掉。</li><li>目前使用过的ballots不超过MaxBallot<br> 这个应该是防止最后算法不会终止</li><li>replica当前的日志中，不存在任何Instance为i的日志是已提交的(即其status为”committed”和”executed”)。</li></ol><p>状态转移：</p><ol><li>sentMsg<br> 从这个replica向一个SlowQuorum，即Q发送”prepare”消息。<br> 这里注意，更新ballot为<code>&lt;&lt; ballots, replica &gt;&gt;</code>，这里的ballots是全局最大的ballot值。</li><li>ballots<br> 更新全局最大的ballots，自增1。</li><li>preparing<br> 将当前replica的preparing集合中增加Instance i。</li></ol><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SendPrepare(replica, i, Q) ==</span><br><span class="line">    /<span class="symbol">\ </span>i <span class="symbol">\n</span>otin leaderOfInst[replica]</span><br><span class="line">    <span class="symbol">\*</span>/<span class="symbol">\ </span>i <span class="symbol">\n</span>otin preparing[replica]</span><br><span class="line">    /<span class="symbol">\ </span>ballots &lt;= MaxBallot</span><br><span class="line">    /<span class="symbol">\ </span>~(<span class="symbol">\E</span> rec <span class="symbol">\i</span>n cmdLog[replica] :</span><br><span class="line">                        /<span class="symbol">\ </span>rec.inst = i</span><br><span class="line">                        /<span class="symbol">\ </span>rec.status <span class="symbol">\i</span>n &#123;"committed", "executed"&#125;)</span><br><span class="line">    /<span class="symbol">\ </span>sentMsg' = sentMsg <span class="symbol">\c</span>up</span><br><span class="line">                    [type   : &#123;"prepare"&#125;,</span><br><span class="line">                     src    : &#123;replica&#125;,</span><br><span class="line">                     dst    : Q,</span><br><span class="line">                     inst   : &#123;i&#125;,</span><br><span class="line">                     ballot : &#123;&lt;&lt; ballots, replica &gt;&gt;&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>ballots' = ballots + 1</span><br><span class="line">    /<span class="symbol">\ </span>preparing' = [preparing EXCEPT ![replica] = @ <span class="symbol">\c</span>up &#123;i&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst,</span><br><span class="line">                    leaderOfInst, committed &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyPrepare"><a href="#ReplyPrepare" class="headerlink" title="ReplyPrepare"></a>ReplyPrepare</h3><p>ReplyPrepare处理来自SendPrepare里面replica的”prepare”消息。下面进行讨论：</p><ol><li>如果自己的日志中，存在一条对应于msg里面instance的日志，并且消息中的ballot要大于日志中的ballot。<br> 状态转移：<ol><li>sentMsg<br> 将来自SendPrepare里面replica的”prepare”消息删除，并重新发送一条”prepare-reply”消息给msg.src。<br> 消息中的ballot为自己的msg.ballot，prev_ballot为rec.ballot。根据前文，msg.ballot肯定是大于rec.ballot的。<br> 消息中的deps和seq沿用自己本地日志中的。【Q】这里很奇怪，似乎我们不在ReplyPrepare阶段对deps和seq决议。</li><li>cmdLog<br> 删除自己日志中的rec，并且增加一条新条目。这个新条目和rec大致一样，只是将ballot更新为msg中的ballot。</li><li>leaderOfInst<br> 如果日志中的instance的Command Leader是replica，那么将它移出<code>leaderOfInst[replica]</code>。否则保持不变。<br> 【Q】这里是啥意思，重新选一个Command Leader，还是直接走Basic Paxos那一套提交呢？</li></ol></li><li>如果在自己日志中，不存在对应于msg里面instance的日志。<br> 状态转移：<ol><li>sentMsg<br> 发送”prepare-reply”消息。<br> ballot为消息中传来的ballot，并且prev_ballot为<code>&lt;&lt; 0, replica &gt;&gt;</code>，相当于是一开始的ballot。【Q】msg.ballot肯定是大于rec.ballot的么？<br> 其他的字段也是设置成默认值：status为”not-seen”。cmd为none。deps为<code>{}</code>，seq为0。</li><li>cmdLog<br> 参照sentMsg的变更</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyPrepare</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg : </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "prepare"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ \/ \<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : </span><br><span class="line">                /\ <span class="keyword">rec</span>.inst = msg.inst</span><br><span class="line">                /\ msg.ballot[<span class="number">1</span>] &gt; <span class="keyword">rec</span>.ballot[<span class="number">1</span>]</span><br><span class="line">                /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; <span class="keyword">rec</span>.ballot,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;</span><br><span class="line">                 /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ &#123;<span class="keyword">rec</span>&#125;) \cup</span><br><span class="line">                            &#123;[inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;]</span><br><span class="line">                 /\ <span class="type">IF</span> <span class="keyword">rec</span>.inst \<span class="keyword">in</span> leaderOfInst[replica] <span class="type">THEN</span></span><br><span class="line">                        /\ leaderOfInst' = [leaderOfInst <span class="type">EXCEPT</span> ![replica] = </span><br><span class="line">                                                                @ \ &#123;insrec.t&#125;]</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed,</span><br><span class="line">                                        crtInst, ballots, preparing &gt;&gt;</span><br><span class="line">                    <span class="type">ELSE</span> <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst,</span><br><span class="line">                                      ballots, preparing, leaderOfInst &gt;&gt;</span><br><span class="line">                        </span><br><span class="line">           \/ /\ ~(\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = msg.inst)</span><br><span class="line">              /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; msg.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; &lt;&lt; <span class="number">0</span>, replica &gt;&gt;,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;</span><br><span class="line">              /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = @ \cup</span><br><span class="line">                            &#123;[inst  |-&gt; msg.inst,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;]</span><br><span class="line">              /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                              leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="PrepareFinalize"><a href="#PrepareFinalize" class="headerlink" title="PrepareFinalize"></a>PrepareFinalize</h3><p>SendPrepare里面的replica，也就是所谓的Replica L，在收到对端的”prepare-reply”消息后，会走到PrepareFinalize中。这个函数也是最为复杂的。</p><p>Enable条件：</p><ol><li>i要在preparing[replica]中<br> 也就是确认当前replica是Replica L</li><li>replica的日志中有i这个Instance，并且还没被提交</li><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<br> 下面会讨论四种情况，总体是”越来越惨”的<ol><li>如果这些replies中的某个com的status是已提交(即”committed”, “executed”)<br> 【Q】为什么会有这种情况？感觉应该是因为在FastPath的Phase1Fast或者SlowPath的Phase2Finalize之后，cleader宕机导致的。<br> 那么就将这个Instance i移出preparing[replica]。并且在sentMsg中删除所有的replies。<br> 【Q】感觉这就相当于直接让它往后提交了？</li><li>如果这些replies中<strong>没有</strong>status是已提交(即”committed”, “executed”)，但是存在acc是**”accepted”**的。<br> 同时还需要检查acc的prev_ballot大于等于(如果其他消息不是”accept”状态，那么就默认acc的大)所有其他消息的prev_ballot<br> 状态转移：<ol><li>sentMsg<br> 删除所有的replies，并且对除当前replica之外的所有Q，都发送一条”accept”消息。<br> 这个消息的ballot为自己日志中的ballot。<br> 关键内容，即cmd、deps和seq，都设置为acc传过来的。<br> 【Q】为什么replies里面prev_ballot最大的那个消息是”accpeted”，就可以以它为准走”accept流程”？</li><li>cmdLog<br> 参照sentMsg创建一个新条目。</li></ol></li></ol></li></ol><p>因为太长了，所以后面两种情况拆到下面讨论</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PrepareFinalize(replica, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> preparing[replica]</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">       /<span class="string">\</span> rec.inst = i</span><br><span class="line">       /<span class="string">\</span> rec.status <span class="string">\notin</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">       /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg : </span><br><span class="line">                        /<span class="string">\</span> msg.inst = i</span><br><span class="line">                        /<span class="string">\</span> msg.type = <span class="string">"prepare-reply"</span></span><br><span class="line">                        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">                        /<span class="string">\</span> msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rep <span class="string">\in</span> Q : <span class="string">\E</span> msg <span class="string">\in</span> replies : msg.src = rep)</span><br><span class="line">            <span class="regexp">/\  \/</span> <span class="string">\E</span> com <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> (com.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                        /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                        /\ sentMsg'</span> = sentMsg <span class="string">\</span> replies</span><br><span class="line">                        /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                        committed, ballots &gt;&gt;</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> ~(<span class="string">\E</span> msg <span class="string">\in</span> replies : msg.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\E</span> acc <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> acc.status = <span class="string">"accepted"</span></span><br><span class="line">                        /<span class="string">\</span> (<span class="string">\A</span> msg <span class="string">\in</span> (replies <span class="string">\</span> &#123;acc&#125;) : </span><br><span class="line">                            (msg.prev_ballot[<span class="number">1</span>] &lt;= acc.prev_ballot[<span class="number">1</span>] <span class="string">\/</span> </span><br><span class="line">                             msg.status <span class="comment"># "accepted"))</span></span><br><span class="line">                        /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ replies) \cup</span></span><br><span class="line"><span class="string">                                 [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                                  src   : &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  dst   : Q \ &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                                  ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                                  cmd   : &#123;acc.cmd&#125;,</span></span><br><span class="line"><span class="string">                                  deps  : &#123;acc.deps&#125;,</span></span><br><span class="line"><span class="string">                                  seq   : &#123;acc.seq&#125;]</span></span><br><span class="line"><span class="string">                        /\ cmdLog'</span> = [cmdLog EXCEPT ![replica] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                                &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                                  status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                                  cmd   |<span class="function">-&gt;</span> acc.cmd,</span><br><span class="line">                                  deps  |<span class="function">-&gt;</span> acc.deps,</span><br><span class="line">                                  seq   |<span class="function">-&gt;</span> acc.seq]&#125;]</span><br><span class="line">                         /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                         /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![replica] = @ <span class="string">\cup</span> &#123;i&#125;]</span><br><span class="line">                         /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><p>下面是后两种情况：</p><ol><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<ol><li>第一种情况；已经讨论</li><li>第二种情况：已经讨论</li><li>如果这些replies中，同时没有”committed”、”executed”、”accept”状态，但是有”pre-accepted”<br> 将replies中所有的”pre-accepted”提出来为preaccepts，又分为三种情况：<ol><li>preaccepts里面任意两个的cmd、deps和seq都相等。并且preaccepts中没有一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的。并且Q中所有的replica都发了”pre-accepted”给当前的replica。<br> 执行状态转移：<ol><li>sentMsg<br> 从当前replica向Q中所有其他replica发送”accept”。<br> cmd、deps和seq取其中任意一个就行，因为都相等。</li><li>cmdLog<br> 参照sentMsg</li><li>preparing<br> 在preparing[replica]移除掉Instance i。</li><li>leaderOfInst<br> 在leaderOfInst[replica]移除掉Instance i。</li></ol></li><li>如果和之前一样，但Q中只有大于<code>Cardinality(Q) \div 2</code>个replica发送了”pre-accepted”<br> 执行状态转移：<ol><li>sentMsg<br> <strong>这也是全局唯一会走到ReplyTryPreaccept流程里面的情况，对应了优化算法</strong>。<br> 从当前replica向Q中所有其他replica发送”try-pre-accept”。<br> 注意，这个消息<strong>也要</strong>发送给自己，所以和上一个情况是不同的处理策略。<br> cmd、deps和seq的处理办法和上面是一样的。</li></ol></li><li>如果<code>preaccepts</code>不为空，并且满足下面三个条件之一：连cmd、deps和seq都不完全一样了，<strong>或者</strong><code>Cardinality(preaccepts)</code>也小于<code>Cardinality(Q) \div 2</code>，<strong>或者</strong><code>preaccepts</code>中存在一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的<br> 执行状态转移：<ol><li>在preaccepts中CHOOSE一个cmd不为none的pac，执行StartPhase1<br> 但是和Propose的处理不同，这里会带上rec.ballot, replies作为Ballot和oldMsg参数。<br> 而replies会在StartPhase1中被直接干掉(从sendMsg里面删除掉)。</li><li>preparing<br> 去掉i</li></ol></li></ol></li><li>如果这些replies中，状态都是”not-seen”的<br> 执行状态转移：<ol><li>同样执行StartPhase1，但cmd为none。</li><li>preparing<br> 去掉i</li></ol></li></ol></li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span> /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : </span><br><span class="line">                        msg.status <span class="tag">\<span class="name">in</span></span> &#123;"accepted", "committed", "executed"&#125;)</span><br><span class="line">                   /<span class="tag">\<span class="name"> </span></span>LET preaccepts == &#123;msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "pre-accepted"&#125; IN</span><br><span class="line">                       (<span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts :</span><br><span class="line">                                    p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span>p1.deps = p2.deps /<span class="tag">\<span class="name"> </span></span>p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q <span class="tag">\<span class="name"> </span><span class="string">&#123;replica&#125;</span></span>,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![replica] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;rec&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                        &#123;[inst  |-&gt; i,</span><br><span class="line">                                          status|-&gt; "accepted",</span><br><span class="line">                                          ballot|-&gt; rec.ballot,</span><br><span class="line">                                          cmd   |-&gt; pac.cmd,</span><br><span class="line">                                          deps  |-&gt; pac.deps,</span><br><span class="line">                                          seq   |-&gt; pac.seq]&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span></span><br><span class="line">                                                          p1.deps = p2.deps /<span class="tag">\</span></span><br><span class="line">                                                          p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &lt; Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"try-pre-accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; cmdLog, proposed, executed,</span><br><span class="line">                                                crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd # p2.cmd <span class="tag">\<span class="name">/</span></span> </span><br><span class="line">                                                             p1.deps # p2.deps <span class="tag">\<span class="name">/</span></span></span><br><span class="line">                                                             p1.seq # p2.seq</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1]</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> Cardinality(preaccepts) &lt; Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>preaccepts # &#123;&#125;</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : pac.cmd # none IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>StartPhase1(pac.cmd, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;)</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "not-seen"</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>StartPhase1(none, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyTryPreaccept"><a href="#ReplyTryPreaccept" class="headerlink" title="ReplyTryPreaccept"></a>ReplyTryPreaccept</h3><p>找到发给自己的”try-pre-accept”的请求tpa，首先找到自己日志中所有Instance等于tpa.inst的条目oldRec，进行校验：</p><ol><li>tpa的ballot number要大于等于所有oldRec中的ballot number</li><li>所有oldRec中的状态不能是{“accepted”, “committed”, “executed”}</li></ol><p>然后进行讨论：</p><ol><li>如果在oldRec之外，存在某个rec，和tpa是冲突的<br> 如果tpa.inst不属于rec.deps，并且要么rec.inst不属于tpa.deps，要么rec.seq大于tpa.seq。那么rec和tpa是冲突的。<br> 如果存在冲突的话，则执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply消息。<br> 此时，status为rec.status。</li><li>cmdLog<br> 不做改动，可以认为是拒绝了这个消息。</li></ol></li><li>如果对于oldRec之外的的所有rec，都和tpa不冲突<br> 执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply”消息。<br> 注意，status的值是”OK”，这个和冲突情况不一样。【Q】如果此时status的值为”pre-accepted”，那么在FinalizeTryPreAccept中，这条日志仍有被提交的希望？</li><li>cmdLog<br> 删除所有的oldRec，也就是自己日志中所有有关Instance的日志。<br> 新增一条”pre-accepted”日志，这就相当于走完了StartPhase1。</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyTryPreaccept</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> tpa \<span class="keyword">in</span> sentMsg :</span><br><span class="line">        /\ tpa.<span class="class"><span class="keyword">type</span> = "try-pre-accept" </span></span><br><span class="line">        /\ tpa.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = tpa.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ \<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec : <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt;= tpa.ballot[<span class="number">1</span>] /\ </span><br><span class="line">                                   <span class="keyword">rec</span>.status \notin &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">            /\ \/ (\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec:</span><br><span class="line">                        /\ tpa.inst \notin <span class="keyword">rec</span>.deps</span><br><span class="line">                        /\ \/ <span class="keyword">rec</span>.inst \notin tpa.deps</span><br><span class="line">                           \/ <span class="keyword">rec</span>.seq &gt;= tpa.seq</span><br><span class="line">                        /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="keyword">rec</span>.status]&#125;)</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                        ballots, leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               \/ /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec: </span><br><span class="line">                            tpa.inst \<span class="keyword">in</span> <span class="keyword">rec</span>.deps \/ (<span class="keyword">rec</span>.inst \<span class="keyword">in</span> tpa.deps /\</span><br><span class="line">                                                      <span class="keyword">rec</span>.seq &lt; tpa.seq))</span><br><span class="line">                  /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="string">"OK"</span>]&#125;</span><br><span class="line">                  /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                    &#123;[inst  |-&gt; tpa.inst,</span><br><span class="line">                                      status|-&gt; <span class="string">"pre-accepted"</span>,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      cmd   |-&gt; tpa.cmd,</span><br><span class="line">                                      deps  |-&gt; tpa.deps,</span><br><span class="line">                                      seq   |-&gt; tpa.seq]&#125;]</span><br><span class="line">                  /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="FinalizeTryPreAccept"><a href="#FinalizeTryPreAccept" class="headerlink" title="FinalizeTryPreAccept"></a>FinalizeTryPreAccept</h3><p>选出自己Instance为i的日志rec，在所有”try-pre-accept-reply”回复中，取出Instance为i且ballot为rec.ballot的回复，构成集合tprs。<br>那么对于Q中的任意一个r，tprs中肯定有一条消息是从r中发出的。也就是说必须得Q中每一个Replica都回复了”try-pre-accept-reply”，这个也是老生常谈的条件。</p><p>下面是三种情况的讨论：</p><ol><li><code>\A tpr \in tprs: tpr.status = &quot;OK&quot;</code><br> 这说明在ReplyTryPreaccept中，大家都没冲突。这个类似于PrepareFinalize中的accept流程，也就是论文中所谓的Paxos-Accept phase。执行状态转换：<ol><li>sentMsg<br> 直接发送”accept”消息给Q，后面就是走Phase2Reply的流程。</li><li>cmdLog<br> 设置status为”accepted”</li></ol></li><li>如果在tpr中存在某个status为{“accepted”, “committed”, “executed”}的消息<br> 走StartPhase1</li><li>如果tpr.status不全是”OK”，也有”pre-accepted”<br> 这里应该是冲突了，所以直接干掉。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FinalizeTryPreAccept(cleader, i, Q) ==</span><br><span class="line">    <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> rec.inst = i</span><br><span class="line">        <span class="regexp">/\ LET tprs == &#123;msg \in sentMsg : msg.type = "try-pre-accept-reply" /</span><span class="string">\</span></span><br><span class="line">                            msg.dst = cleader <span class="regexp">/\ msg.inst = i /</span><span class="string">\</span></span><br><span class="line">                            msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> <span class="string">\A</span> r <span class="string">\in</span> Q: <span class="string">\E</span> tpr <span class="string">\in</span> tprs : tpr.src = r</span><br><span class="line">            <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"OK"</span></span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ tprs) \cup</span></span><br><span class="line"><span class="string">                             [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                              src   : &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              dst   : Q \ &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                              ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                              cmd   : &#123;rec.cmd&#125;,</span></span><br><span class="line"><span class="string">                              deps  : &#123;rec.deps&#125;,</span></span><br><span class="line"><span class="string">                              seq   : &#123;rec.seq&#125;]</span></span><br><span class="line"><span class="string">                  /\ cmdLog'</span> = [cmdLog EXCEPT ![cleader] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                            &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                              status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                              ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                              cmd   |<span class="function">-&gt;</span> rec.cmd,</span><br><span class="line">                              deps  |<span class="function">-&gt;</span> rec.deps,</span><br><span class="line">                              seq   |<span class="function">-&gt;</span> rec.seq]&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> StartPhase1(rec.cmd, cleader, Q, i, rec.ballot, tprs)</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"pre-accepted"</span></span><br><span class="line">                  /<span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"OK"</span>, <span class="string">"pre-accepted"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = sentMsg \ tprs</span></span><br><span class="line"><span class="string">                  /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                  ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>There Is More Consensus in Egalitarian Parliaments</li><li>EPaxos Revisited</li><li><a href="https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla" target="_blank" rel="noopener">https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla</a><br> 一份TLA+的说明</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍EPaxos算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="一致性" scheme="http://www.calvinneo.com/tags/一致性/"/>
    
    <category term="paxos" scheme="http://www.calvinneo.com/tags/paxos/"/>
    
    <category term="epaxos" scheme="http://www.calvinneo.com/tags/epaxos/"/>
    
  </entry>
  
  <entry>
    <title>Mac电脑配置指南</title>
    <link href="http://www.calvinneo.com/2021/10/01/mac-config/"/>
    <id>http://www.calvinneo.com/2021/10/01/mac-config/</id>
    <published>2021-10-01T04:33:22.000Z</published>
    <updated>2021-10-01T14:16:43.182Z</updated>
    
    <content type="html"><![CDATA[<p>总结Mac系统下的配置相关方法。</p><a id="more"></a><h1 id="输入输出相关"><a href="#输入输出相关" class="headerlink" title="输入输出相关"></a>输入输出相关</h1><p>对于普通外接键盘，配置Alt为Command，Win为Option，Capslock为Control。使用Control+Space切换输入法。</p><h1 id="SSH相关"><a href="#SSH相关" class="headerlink" title="SSH相关"></a>SSH相关</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> -i ~/.ssh/id_rsa.pub root@localhost</span><br><span class="line">sudo systemsetup -setremotelogin <span class="keyword">on</span></span><br></pre></td></tr></table></figure><p>然后参照<a href="https://stackoverflow.com/questions/68827166/how-can-i-ssh-rootlocalhost-and-su-root-without-password-on-macos" target="_blank" rel="noopener">这篇文章</a>设置<code>/etc/ssh/sshd_config</code>。</p><h1 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h1><p>有的时候Brew会Update出问题，或者install不了，这时候可以重装Brew</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="regexp">/usr/</span>local<span class="regexp">/Homebrew/</span>Library<span class="regexp">/Taps/</span>homebrew/</span><br><span class="line">rm -rf homebrew-core</span><br><span class="line">git clone <span class="string">https:</span><span class="comment">//github.com/Homebrew/homebrew-core.git</span></span><br></pre></td></tr></table></figure><h1 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h1><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="为什么不能core？"><a href="#为什么不能core？" class="headerlink" title="为什么不能core？"></a>为什么不能core？</h2><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c unlimited</span><br><span class="line">sudo sysctl kern.coredump=<span class="number">1</span></span><br><span class="line">chmod <span class="number">777</span> /cores</span><br></pre></td></tr></table></figure><h2 id="Finder显示全部路径"><a href="#Finder显示全部路径" class="headerlink" title="Finder显示全部路径"></a>Finder显示全部路径</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com<span class="selector-class">.apple</span><span class="selector-class">.finder</span> _FXShowPosixPathInTitle -bool YES</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;总结Mac系统下的配置相关方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Mac" scheme="http://www.calvinneo.com/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>物化视图研究</title>
    <link href="http://www.calvinneo.com/2021/08/23/material_view_study/"/>
    <id>http://www.calvinneo.com/2021/08/23/material_view_study/</id>
    <published>2021-08-23T11:20:33.000Z</published>
    <updated>2022-03-01T08:37:22.659Z</updated>
    
    <content type="html"><![CDATA[<p>研究物化视图(materialized view)相关技术。</p><a id="more"></a><h1 id="Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications"><a href="#Maintenance-of-Materialized-Views-Problems-Techniques-and-Applications" class="headerlink" title="Maintenance of Materialized Views: Problems, Techniques, and Applications"></a>Maintenance of Materialized Views: Problems, Techniques, and Applications</h1><p>什么是view，是从base (stored) relation衍生出来的relation。可以理解为从base table到derived table的函数，因此在访问时会涉及重复计算。<br>什么是materialized view？materialized view类似于一个cache，避免重复计算。materialized view上允许构建索引。<br>什么是view maintainance？在更新base relation的同时，更新view。<br>什么是incremental view maintainance？在某些情况下，只更新一部分view，而不是全部view。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><ol><li>Information</li><li>Modification<br> 我们是直接处理update，还是将它作为先delete再insert来处理呢？</li><li>Language<br> 这个view是如何表示的？是传统的SPJ？是否有聚合函数？有没有UNION？是Set还是Duplicate(即没有DISTINCT语义)？有没有Recursion？</li><li>Instance</li></ol><h3 id="Information和Modification"><a href="#Information和Modification" class="headerlink" title="Information和Modification"></a>Information和Modification</h3><p>考虑如下relation</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(part_no,part_cost,contract)</span></span></span><br></pre></td></tr></table></figure><p>我们创建一个view，列出所有distinct的part_cost大于1000的part_no。注意，这里的Projection带Distinct语义。</p><p>$$<br>expensiveParts (partNo) = \Pi_{partNo} \sigma_{partCost&gt;1000} (part)<br>$$</p><p>考虑insert下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><ol><li>如果只有materialized view<br> 可以用老版本的判断part_no是否在view中。</li><li>如果只有base relation<br> 用relation <code>part</code>去查看是否存在同样的part_no，但是part_cost更大的，如果有，那么就不要更新了。</li><li>如果part_no is the key<br> 可以推断出part_no肯定不在view中。<br> 因为key保证了唯一性，因为我们insert成功了，所以肯定之前没有part_no。</li></ol><p>考虑delete下面条目情况</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">2000</span>,c12)</span></span></span><br></pre></td></tr></table></figure><p>显然p1在materialized view里面，但是不能断定是否还有类似于<code>part(p1,3000,c13)</code>这样的存在，因此不能直接从view中删除p1。事实上不能<strong>仅</strong>依赖materialized view来处理delete的情况。但如果有下面的，则可以：</p><ol><li>relation <code>part</code></li><li>key constraint<br> 【Q】How</li><li>counts of number of view tuple derivations</li></ol><p>考虑update情况，在某些算法中归结为先delete再insert，这种方式会丢失信息。Ref BCL89 UO92 GJM94。</p><h3 id="Language和Instance"><a href="#Language和Instance" class="headerlink" title="Language和Instance"></a>Language和Instance</h3><p>我们创建一个<code>supp_parts</code>，它是supp和part这两个relation的equijoin。列出了至少有一个supp的part的number，并且已经经过了distinct。</p><p>$$<br>suppParts(partNo) = \Pi_{partNo} (supp \bowtie_{partNo} part)<br>$$</p><p>现在考虑仅适用<code>supp_parts</code>，insert下面条目</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">part</span><span class="params">(p1,<span class="number">5000</span>,c15)</span></span></span><br></pre></td></tr></table></figure><p>如果<code>supp_parts</code>里面已经有了p1，那么无变化。但是如果view中没有p1，并不能仅通过这个view推断是否要insert。</p><h2 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h2><p>使用数学语言来描述。<br>考虑link(a,b)表示从a到b的一个link，定义hop(X,Y)表示从X经过两个link能到达Y，有</p><p>$$<br>hop(X,Y) = \Pi_{X,Y} (link(X,V) \bowtie_{V=W} link(W,Y))<br>$$</p><h2 id="Full-Information"><a href="#Full-Information" class="headerlink" title="Full Information"></a>Full Information</h2><h1 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.wikipedia.org/wiki/Relational_algebra" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Relational_algebra</a><br> 关系术语</li><li><a href="https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join" target="_blank" rel="noopener">https://www.dotnettricks.com/learn/sqlserver/difference-between-inner-join-and-equi-join-and-natural-join</a><br> 介绍Natual join，equijion和inner join。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;研究物化视图(materialized view)相关技术。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>Rust - A CPP Programmer&#39;s Perspective</title>
    <link href="http://www.calvinneo.com/2021/08/17/rust-acpppp/"/>
    <id>http://www.calvinneo.com/2021/08/17/rust-acpppp/</id>
    <published>2021-08-17T11:20:33.000Z</published>
    <updated>2023-02-10T11:57:37.772Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。</p><p>本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。</p><a id="more"></a><h1 id="rustup：Toolchain-管理工具"><a href="#rustup：Toolchain-管理工具" class="headerlink" title="rustup：Toolchain 管理工具"></a>rustup：Toolchain 管理工具</h1><p>安装 nightly toolchain</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain install nightly</span><br></pre></td></tr></table></figure><p>然后激活</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup default nightly</span><br></pre></td></tr></table></figure><h2 id="Override"><a href="#Override" class="headerlink" title="Override"></a>Override</h2><p>Toolchain 的选择使用下面：</p><ol><li>在命令行中<a href="https://rust-lang.github.io/rustup/overrides.html#toolchain-override-shorthand" target="_blank" rel="noopener">指定</a>，如<code>cargo +beta</code></li><li>RUSTUP_TOOLCHAIN环境变量</li><li>用 <code>rustup override set</code> 覆盖当前目录以及子目录的设置<br> <code>rustup show</code>和<code>rustup override unset</code>可以查看和取消 override</li><li>rust-toolchain.toml 或者 rust-toolchain</li><li>使用 default toolchain</li></ol><h1 id="Cargo：包管理工具"><a href="#Cargo：包管理工具" class="headerlink" title="Cargo：包管理工具"></a>Cargo：包管理工具</h1><h2 id="workspace、crate-和-mod"><a href="#workspace、crate-和-mod" class="headerlink" title="workspace、crate 和 mod"></a>workspace、crate 和 mod</h2><p>C++ 并没有什么包管理，如果我们想要引用什么东西，代码声明一下，然后确保链接器能够看到定义就行。并且因为模板的引入，很多都是头文件，直接include就行。</p><h3 id="访问-mod"><a href="#访问-mod" class="headerlink" title="访问 mod"></a>访问 mod</h3><h4 id="crate内"><a href="#crate内" class="headerlink" title="crate内"></a>crate内</h4><p>src/main.rs和src/lib.rs被称为crate<strong>根</strong>。</p><p>一个crate下有若干mod，每个mod的成员在对应mod文件夹的mod.rs中列出。<br>例如下面的声明，会查找当前目录下的hello.rs，或者hello目录下的mod.rs。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">mod</span>.rs</span><br><span class="line"><span class="keyword">mod</span> hello;</span><br></pre></td></tr></table></figure><p>可以通过<code>#[path = &quot;foo.rs&quot;]</code>来指定 mod 的位置。这种用法可以在函数中 inline。可以在<a href="https://github.com/CalvinNeo/Ruster/blob/3f228dbd15791f8bea85e56a46527c6c397d7acb/src/main.rs#L1" target="_blank" rel="noopener">这段代码</a>中查看具体用法。</p><h4 id="跨crate"><a href="#跨crate" class="headerlink" title="跨crate"></a>跨crate</h4><p>跨crate访问，需要使用Cargo.toml中定义的crate别名。</p><h3 id="rustc-和-crate"><a href="#rustc-和-crate" class="headerlink" title="rustc 和 crate"></a>rustc 和 crate</h3><p>rustc只接受一个文件，并只生成一个crate。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc hello.rs --crate-<span class="keyword">type</span>=<span class="class"><span class="keyword">lib</span></span></span><br></pre></td></tr></table></figure><h3 id="workspace"><a href="#workspace" class="headerlink" title="workspace"></a>workspace</h3><p>workspace不能嵌套。所以如果两个Cargo工程，并且工程A依赖于工程B，比较好的方案是<a href="https://stackoverflow.com/questions/49849878/how-to-deal-with-multiple-nested-workspace-roots" target="_blank" rel="noopener">平行摆放两个工程，并设置dependencies</a>。</p><h4 id="virtual-workspace"><a href="#virtual-workspace" class="headerlink" title="virtual workspace"></a>virtual workspace</h4><h2 id="crate-内部组织形式"><a href="#crate-内部组织形式" class="headerlink" title="crate 内部组织形式"></a>crate 内部组织形式</h2><ol><li>mod.rs</li><li>一个 common.rs 用作公共依赖，mod.rs 注明只对该 mod 服务</li><li>一个或多个 xxx_engine.rs 用来定义 mod 对外暴露的主要功能<br> 在 mod 中 pub mod 和 pub use。<br> 不 pub use。</li><li>一个或多个 yyy_impls.rs，用来辅助 xxx_engine.rs 的实现<br> 可能需要 use xxx_engine.rs 中的一些东西。<br> 反过来，xxx_engine.rs 中会 <code>use yyy_impls::*</code>。<br> 不 pub use。</li></ol><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><h3 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h3><p>可以通过 <code>-C debug_info</code> 来指定调试信息的等级，其中0(false)、1、2(true) 分别对应无/行信息以及全部信息。<strong>如果设置为0</strong>，那么很可能部分代码的行号是打印不出来的。<br>另外，Cargo.toml 中的 <code>[profile]</code> 也可以修改。 </p><h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h2 id="features"><a href="#features" class="headerlink" title="features"></a>features</h2><p>features用来支持<a href="https://doc.rust-lang.org/reference/conditional-compilation.html" target="_blank" rel="noopener">条件编译</a>和<a href="https://doc.rust-lang.org/cargo/reference/features.html#optional-dependencies" target="_blank" rel="noopener">可选依赖</a>。<br>在编译时，可以通过<code>--features</code>去enable某个feature。<br>例如在Cargo.toml中，webp是一个feature，并且它没有enable其他feature。而ico这个feature会enable两个feature即bmp和png。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[features]</span><br><span class="line"># Defines a feature named `webp` that does not enable any other features.</span><br><span class="line">webp = []</span><br><span class="line">ico = [&quot;bmp&quot;, &quot;png&quot;]</span><br></pre></td></tr></table></figure><p>在代码中，可以用下面两种方式，让代码只对webp被enable的情况下生效，</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"webp"</span>)]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">cfg!</span>(feature = <span class="string">"webp"</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下，所有的 feature 都是 disable 的，但可以把 feature 加入 default 中来默认 enable 它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default = [&quot;webp&quot;]</span><br></pre></td></tr></table></figure><p>在编译时，可以指定<code>--no-default-features</code>来disable default feature。</p><h3 id="dependency-features"><a href="#dependency-features" class="headerlink" title="dependency features"></a>dependency features</h3><p>在指定dependency时，也可以指定features。<br>例如下面的配置中，将flate2的default features disable掉，但额外enable了zlib这个feature。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[dependencies]</span><br><span class="line">flate2 = &#123; version = &quot;1.0.3&quot;, default-features = false, features = [&quot;zlib&quot;] &#125;</span><br></pre></td></tr></table></figure><h3 id="optional-dependency"><a href="#optional-dependency" class="headerlink" title="optional dependency"></a>optional dependency</h3><p>下面的语句表示gif默认不会作为依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">gif</span> = &#123; version = <span class="string">"0.11.1"</span>, optional = <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure><p>它会隐式定义了如下的feature</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">gif</span> = [<span class="string">"dep:gif"</span>]</span><br></pre></td></tr></table></figure><p>可以通过 <code>cfg(feature = &quot;gif&quot;)</code> 来判断dependency是否被启用，通过 <code>--features gif</code> 来显式启用 dependency。</p><p>如下的代码表示 avif 会 enable ravif 和 rgb 这两个 feature，但因为显式使用了 <code>dep:ravif</code> 和 <code>dep:rgb</code>，所以系统不会隐式生成 <code>ravif</code> 和 <code>rgb</code> 这两个feature。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">ravif</span> = &#123; version = <span class="string">"0.6.3"</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"><span class="attr">rgb</span> = &#123; version = <span class="string">"0.8.25"</span>, optional = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="section">[features]</span></span><br><span class="line"><span class="attr">avif</span> = [<span class="string">"dep:ravif"</span>, <span class="string">"dep:rgb"</span>]</span><br></pre></td></tr></table></figure><h2 id="Cargo-toml-解读"><a href="#Cargo-toml-解读" class="headerlink" title="Cargo.toml 解读"></a>Cargo.toml 解读</h2><ol><li><p>[dependencies]<br> 依赖的第三方package</p></li><li><p>[dev-dependencies]<br> 只有tests/examples/benchmarks依赖的第三方package</p></li><li><p>[features]<br> 用来支持条件编译和可选依赖</p></li><li><p>[lib]</p></li><li><p>[[test]]<br> 两个中括号说明是表数组，我们可以这样写</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br><span class="line"><span class="string">[[test]]</span></span><br><span class="line"><span class="built_in">path</span> = <span class="string">""</span></span><br><span class="line">name = <span class="string">""</span></span><br></pre></td></tr></table></figure></li><li><p>[package]</p></li><li><p>[workspace]<br> 相对于package而言，workspace是一系列共享同样的Cargo.lock和输出目录的包。<br> 包含members数组</p></li><li><p>[profile]</p></li><li><p>[patch.crates-io]</p></li></ol><h2 id="Cargo-lock-解读"><a href="#Cargo-lock-解读" class="headerlink" title="Cargo.lock 解读"></a>Cargo.lock 解读</h2><p>Cargo.lock 是记录每个 crate 对应版本的工具。例如下面的配置表示依赖一个0.1.0版本的 <code>azure_core</code> 库，可是这个版本具体对应哪个 rev 呢？github 打开发现 master 上已经是0.2.1的版本了，我们显然不可能是用的 master 啊。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">azure_core</span> = &#123; version = <span class="string">"0.1.0"</span>, git = <span class="string">"https://github.com/Azure/azure-sdk-for-rust"</span>&#125;</span><br></pre></td></tr></table></figure><p>此时查看 Cargo.lock 就能发现类似下面的配置，其中具体指出了0.1.0对应的 git commit</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[package]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"azure_core"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">source</span> = <span class="string">"git+https://github.com/Azure/azure-sdk-for-rust#b3c53f4cec4a6b541e49388b51e696dc892f18a3"</span></span><br><span class="line"><span class="attr">dependencies</span> = [</span><br><span class="line"> "async-trait",</span><br><span class="line"> ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>一个 workspace 只在根目录有一个 Cargo.lock。这确保了所有的 crate 都使用完全相同版本的依赖。<br>如果在 Cargo.toml 和 add-one/Cargo.toml 中都增加 rand crate，则 Cargo 会将其都解析为同一版本并记录到唯一的 Cargo.lock 中。</p><h2 id="Cargo-的常见问题"><a href="#Cargo-的常见问题" class="headerlink" title="Cargo 的常见问题"></a>Cargo 的常见问题</h2><p><a href="https://github.com/rust-lang/cargo/issues/3381" target="_blank" rel="noopener">failed to authenticate when downloading repository</a>这样的错误一般出现在和github交互的场景中。使用下面的办法可解决</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br><span class="line">ssh-add</span><br><span class="line">cargo build</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/47565203/cargo-build-hangs-with-blocking-waiting-for-file-lock-on-the-registry-index-a" target="_blank" rel="noopener">Blocking waiting for file lock on the registry index</a> 这样的错误一般删除<code>rm $CARGO_HOME/.package-cache</code>.</p><h1 id="所有权、生命周期"><a href="#所有权、生命周期" class="headerlink" title="所有权、生命周期"></a>所有权、生命周期</h1><p>为了检验是否初步理解Rust所有权，可以尝试自己实现一个双向链表。</p><h2 id="绑定和可变性"><a href="#绑定和可变性" class="headerlink" title="绑定和可变性"></a>绑定和可变性</h2><h3 id="let和let-mut"><a href="#let和let-mut" class="headerlink" title="let和let mut"></a>let和let mut</h3><p><code>let x = y</code>表示把y这个值bound/assign到变量x上，因为let是immutable的，所以就不能修改变量x，也就是再次给它赋值(assign)了。如果需要能re-bound或者re-assign，就需要<code>let mut x = y</code>这种形式。</p><p>对结构体而言，如果它是immutable的，那么它的所有成员也都是immutable的。在C++中，可以声明类中的某个成员是mutable的，这样即使在const类中也可以修改它，但Rust不允许这样。</p><p>由此还派生出了<code>&amp;mut</code>和<code>&amp;</code>两种引用。可以可变或者不可变地借用let mut绑定的值，但只能不可变地借用let绑定的值。</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>下面的语句都在尝试定义一个<code>&amp;mut {interger}</code>类型的a，但第三条语句是编译不过的。原因是它触发了Rust里面的pattern matching。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">ref</span> <span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> a = &amp;<span class="keyword">mut</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> &amp;<span class="keyword">mut</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 下面这个语句肯定编译不过，但可以从错误中得到a的实际类型，所以是个常见的白嫖编译器类型推导的办法</span></span><br><span class="line"><span class="keyword">let</span> _: () = a;</span><br></pre></td></tr></table></figure><p>我们很熟悉对 enum 类型(诸如<code>Option</code>和<code>Result</code>)进行 Pattern Matching 的做法。下面介绍一些不一样的，例如可以 Pattern Match 一个 struct，有点类似 C++ 的 structual binding。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>@</code>，可以在 Pattern Matching 的时候同时指定期待的值，并将该值保存到局部变量中，有点类似于 Haskell 的用法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x: xv @ <span class="number">1</span>, y: yv @ <span class="number">2</span>&#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched x &#123;:?&#125; y &#123;:?&#125;"</span>, xv, yv),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        pt @ Point &#123; .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched pt &#123;:?&#125;"</span>, pt),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pattern bindings after an `@` are unstable</span></span><br><span class="line">    <span class="comment">// https://github.com/rust-lang/rust/issues/65490</span></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        pt @ Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"matched pt &#123;:?&#125; x &#123;:?&#125; y &#123;:?&#125;"</span>, pt, x, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"no match"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何在pattern matching的时候不move，<a href="https://stackoverflow.com/questions/29662807/how-do-you-borrow-a-mutable-reference-during-a-match" target="_blank" rel="noopener">而是borrow呢</a>？如下所示，<code>g</code>是一个owned值，而不是一个mutable borrow的值。解决方案就是直接<code>match v.intention_mut()</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> intention = v.intention_mut();</span><br><span class="line"><span class="keyword">match</span> intention &#123;</span><br><span class="line">    vehicle::Intention::Die =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    vehicle::Intention::Goto(g) =&gt; &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Variable-shadow"><a href="#Variable-shadow" class="headerlink" title="Variable shadow"></a>Variable shadow</h3><p>在Rust中有如下称为Variable shadow的做法。一个问题油然而生，既然可以直接<code>let mut</code>，为什么还需要如下的做法呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> x = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>其实shadow的含义是这个变量的生命周期没变，只是我们无法通过从前的名字访问它了，而let mut在重新assign之后，原来的value就会被析构掉。进一步举个例子，给出下面这个程序，它的输出是啥？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop &#123;&#125;"</span>, <span class="keyword">self</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="keyword">let</span> a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> a = S &#123; x: <span class="number">1</span> &#125;;</span><br><span class="line">        a = S &#123; x: <span class="number">2</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结论如下</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">1</span></span><br><span class="line"><span class="built_in">drop</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>为什么呢？对于第一种情况，a被rebound了，但是<code>S {x: 1}</code>只是被shadow了，并没有立即析构。但对于第二种情况，在rebound的时候，<code>S { x: 1 }</code>就被析构了。</p><h2 id="移动和借用"><a href="#移动和借用" class="headerlink" title="移动和借用"></a>移动和借用</h2><p>可以把所有对值的使用方式归纳为三种：复制、移动和引用(或者称为指针)：</p><ol><li>复制的缺点是浪费空间和时间。</li><li>移动的缺点是很多变量的地址会变，这个FFI带来很多麻烦，需要用Box/Pin将一些东西分配到堆上的固定地址，并且传出裸指针。</li><li>引用的缺点是存在NULL，为了避免NULL，又要引入生命周期注解等机制。此外，即使在有了移动语义后，多线程之间依然可以通过引用来访问同一个值，产生并发问题。</li></ol><p>Rust中的<strong>移动可能伴随着内存地址的变化</strong>。很显然，一个对象从A方法通过调用被移动到B方法中，那么肯定出于不同的栈帧中，它的地址肯定会变化，所以要提防这个。而C++中移动更类似金蝉脱壳，将老对象中的东西拆出来用来构建新对象。</p><h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Can compile</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can not compile</span></span><br><span class="line"><span class="keyword">let</span> vx = <span class="built_in">vec!</span>[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">let</span> vy = vx;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, vx[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用和借用是什么关系呢？<strong>创建一个引用的行为称为借用</strong>，在借用过程中，是不可以访问owned值的，否则出现<code>use of borrowed xxx</code>错误。</p><p>在C++中，引用必须在定义时就绑定，并且，无论它是可变引用<code>T&amp;</code>还是不可变引用<code>const T&amp;</code>，都不能重新绑定。这很难受，并且<code>std::reference_wrapper</code>也不是什么时候都可以用的。Rust中这些都不是问题，例如下面的代码就可以正常运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a: &amp;<span class="built_in">i32</span>;</span><br><span class="line">a = &amp;<span class="number">1</span>;</span><br><span class="line">a = &amp;<span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="只能有一个可变借用，或多个不可变借用"><a href="#只能有一个可变借用，或多个不可变借用" class="headerlink" title="只能有一个可变借用，或多个不可变借用"></a>只能有一个可变借用，或多个不可变借用</h3><p>考虑下面的Race Condition:</p><ol><li>多个指针访问同一块数据</li><li>至少一个指针被用来修改数据</li><li>没有同步机制</li></ol><p>Rust解决方案是只能同时有一个可变借用，或者多个不可变借用。问题来了，如果Owner在写，有一个可变引用在写，或者有一个不可变引用在读呢？<br>对于对象的成员函数的调用，这种情况是不存在的。<a href="https://stackoverflow.com/questions/55688018/how-does-rust-prevent-data-races-when-the-owner-of-a-value-can-read-it-while-ano" target="_blank" rel="noopener">如下所示</a>，成员函数需要<code>&amp;self</code>或者<code>&amp;mut self</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="string">"123"</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line"></span><br><span class="line">x.push_str(<span class="string">"456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"y = &#123;&#125;"</span>, y);</span><br></pre></td></tr></table></figure><p>那么对于primitive types呢？运行下面的代码，发现出现错误提示”use of borrowed <code>aaa</code>“，这也就是说在借用期间，是无法访问owned value的，毕竟被<strong>借走</strong>了嘛。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> bbb = &amp;<span class="keyword">mut</span> aaa;</span><br><span class="line">aaa += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"bbb &#123;:?&#125;"</span>, *bbb);</span><br></pre></td></tr></table></figure><p>注意，下面的代码给人一种”可以同时使用借用和owned的值的错觉“，但并不是这样。因为<code>change_aaa</code>对<code>aaa</code>的借用在调用完成之后就结束了，后面<code>aaa = 2</code>的时候就没有其他借用情况了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change_aaa</span></span>(bbb: &amp;<span class="keyword">mut</span> <span class="built_in">i32</span>)&#123;</span><br><span class="line">    *bbb = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> aaa: <span class="built_in">i32</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// TODO 是否可以想个办法异步执行</span></span><br><span class="line">    change_aaa(&amp;<span class="keyword">mut</span> aaa)</span><br><span class="line">    aaa = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="通过移动来实现析构"><a href="#通过移动来实现析构" class="headerlink" title="通过移动来实现析构"></a>通过移动来实现析构</h4><p><code>std::mem::drop</code>函数用来析构T的对象，这是对移动的应用。在调用drop函数时，<code>_x</code>的所有权会被移入。当然，如果实现了<code>Copy</code>，那么<code>drop</code><a href="https://doc.rust-lang.org/std/mem/fn.drop.html" target="_blank" rel="noopener">就无效了</a>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>&lt;T&gt;(_x: T) &#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="借用的demo"><a href="#借用的demo" class="headerlink" title="借用的demo"></a>借用的demo</h4><p>当一个函数接受引用作为参数时，需要显式借用，这一点和C++不一样。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fn_takes_ref</span></span>(i: &amp;int) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line">fn_takes_ref(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// Ok</span></span><br><span class="line">fn_takes_ref(&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="Clone和Copy"><a href="#Clone和Copy" class="headerlink" title="Clone和Copy"></a>Clone和Copy</h2><h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>Rust有一个叫做<code>std::marker::Copy</code>的特殊trait，其中不带有任何方法，所以基本可以视作是给编译器提供的一个marker。如果一个类型实现了Copy trait，在赋值的时候使用复制语义而不是移动语义。</p><p>Rust不允许自身或其任何部分实现了Drop trait的类型使用Copy trait。这听起来很奇怪，但如果我说Copy trait的实现就是bitwise的Copy，就合理了。所以可以近似理解为Copy只适用于C++中的trivial的对象。</p><h3 id="Clone"><a href="#Clone" class="headerlink" title="Clone"></a>Clone</h3><p>对于非trivial对象，又想复制怎么办呢？一个方法是实现Clone trait。可以理解为是C++中的拷贝构造函数。</p><p>容易想到，如果仅仅实现深复制，那么实际上就是递归调用所有field的<code>.clone()</code>而已，这其实等价于下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但注意，编译器在要求实现Copy后，Clone的含义也必须代表bitwise memcpy。因此我们通常会通过<code>#[derive(Copy,Clone)]</code>来支持自动生成Copy特性。</p><h2 id="所有权相关设施"><a href="#所有权相关设施" class="headerlink" title="所有权相关设施"></a>所有权相关设施</h2><p>介绍Borrow(.borrow())/BorrowMut(.borrow_mut())/AsRef(.as_ref())/AsMut(.as_mut())/ToOwned(.to_owned())等基础的实现。</p><h3 id="as-ref-as-mut-和借用"><a href="#as-ref-as-mut-和借用" class="headerlink" title="as_ref/as_mut 和借用"></a>as_ref/as_mut 和借用</h3><p>什么时候用 as_ref/as_mut 呢？如下代码所示，如果需要获得容器 Option 持有的对象的借用，那么我们不能先 unwrap 再 &amp;mut 借用，而应该先 as_mut 再 unwrap。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">i32</span>,</span><br><span class="line">    b: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a: <span class="built_in">Option</span>&lt;S&gt; = <span class="literal">Some</span>(S &#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125;);</span><br><span class="line">    <span class="keyword">let</span> b = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">    <span class="comment">// Error</span></span><br><span class="line">    <span class="keyword">let</span> c = &amp;<span class="keyword">mut</span> b.unwrap();</span><br><span class="line">    <span class="comment">// Ok</span></span><br><span class="line">    <span class="keyword">let</span> c = b.as_mut().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Borrow和AsRef的区别是什么？"><a href="#Borrow和AsRef的区别是什么？" class="headerlink" title="Borrow和AsRef的区别是什么？"></a>Borrow和AsRef的区别是什么？</h3><p>可以看到AsRef和Borrow两个trait的定义不能说非常相似，也可以说是一模一样了，那为什么会分成两个呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">AsRef</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">as_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Borrow</span></span>&lt;Borrowed: ?<span class="built_in">Sized</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">borrow</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;Borrowed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/rust-lang/rust/issues/24140" target="_blank" rel="noopener">显然这个疑问是普遍的</a>，通常的说法是Borrow更严格，目的是借用；AsRef支持的类型更广，目的是类型转换。但说实话，还是一头雾水。<a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">这篇文章讲解了个例子</a>，概括如下：</p><ol><li>HashMap存储<code>(K, V)</code>对，并且可以通过提供的<code>&amp;K</code>查找对应的<code>&amp;mut V</code>。因为按<code>K</code>写，按<code>&amp;K</code>取，所以需要保证这两个的行为是一致的。<br> 【Q】为什么HashMap要按照<code>&amp;K</code>取呢？</li><li>于此同时，我们可以实现一个<code>CaseInsensitiveString</code>结构，它可以看做是忽略大小写比较的一个String。</li><li>问题来了，我们有<code>impl Borrow&lt;str&gt; for String</code>，那么是否可以实现<code>impl Borrow&lt;str&gt; for CaseInsensitiveString</code>呢？<br> 答案是不可以的，这样会破坏HashMap的一致性。例如我两个只是大小写不同的字符串，按照<code>s: CaseInsensitiveString</code>比较是相等的，按照<code>s.borrow()</code>比较就不相等了。<br> 但这就够了么？难道<code>CaseInsensitiveString</code>不可以转换成<code>&amp;str</code>么？当然可以，所以有AsRef。</li></ol><h3 id="cannot-infer-type-for-type-parameter-Borrowed-declared-on-the-trait-BorrowMut"><a href="#cannot-infer-type-for-type-parameter-Borrowed-declared-on-the-trait-BorrowMut" class="headerlink" title="cannot infer type for type parameter Borrowed declared on the trait BorrowMut"></a>cannot infer type for type parameter <code>Borrowed</code> declared on the trait <code>BorrowMut</code></h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Box</span>::new(RefCell::new(<span class="number">1</span>));</span><br><span class="line">(*a.borrow_mut().get_mut()) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="为什么不能从-amp-mut调用Clone？"><a href="#为什么不能从-amp-mut调用Clone？" class="headerlink" title="为什么不能从&amp;mut调用Clone？"></a>为什么不能从<code>&amp;mut</code>调用Clone？</h3><p>从下面的实现可以看到，标准库没有为<code>&amp;mut</code>提供Clone，原因是会产生指向同一个位置的两个<code>&amp;mut</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Clone</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="https://stackoverflow.com/questions/69875015/why-cant-we-implement-clone-for-mut" target="_blank" rel="noopener">下面的代码</a>中，如果clone了<code>&amp;mut MyStruct2</code>，会出现多个指向同一个地址的<code>&amp;&#39;a mut MyStruct</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    val: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct2</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    struct_reference: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> MyStruct</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要注意，clone的目标不是<code>&amp;T</code>而是<code>T</code>。上面例子为什么会失败，原因是在Clone <code>MyStruct</code>的时候递归地需要Clone <code>&amp;&#39;a mut MyStruct</code>导致的。但如果直接对一个<code>&amp;mut T</code>调用Clone就不会出现编译问题，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoClone</span></span>&#123;</span><br><span class="line">    x: <span class="built_in">i32</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> dc = DoClone&#123;x:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> mdc = &amp;<span class="keyword">mut</span> dc;</span><br><span class="line">mdc.clone();</span><br></pre></td></tr></table></figure><h3 id="ToOwned和Clone的区别是什么？"><a href="#ToOwned和Clone的区别是什么？" class="headerlink" title="ToOwned和Clone的区别是什么？"></a>ToOwned和Clone的区别是什么？</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">ToOwned</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Owned</span></span>: Borrow&lt;<span class="keyword">Self</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_owned</span></span>(&amp;<span class="keyword">self</span>) -&gt; Self::Owned;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">clone_into</span></span>(&amp;<span class="keyword">self</span>, target: &amp;<span class="keyword">mut</span> Self::Owned) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个例子很经典，<code>&quot;123&quot;</code>是一个<code>&amp;str</code>类型，对它调用clone，还会得到一个<code>&amp;str</code>类型。但调用<code>to_owned</code>则会得到一个String类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> become_str = <span class="string">"123"</span>.clone();</span><br><span class="line"><span class="keyword">let</span> become_String = <span class="string">"123"</span>.to_owned();</span><br></pre></td></tr></table></figure><h1 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h1><h2 id="Option"><a href="#Option" class="headerlink" title="Option"></a>Option</h2><p>如何处理Option呢？</p><ol><li>unwrap+if</li><li>match，并处理<code>Some(e)</code>和<code>None</code></li><li><code>unwrap_or</code></li><li><code>map</code>组合子，<code>and_then</code>组合子</li><li><code>?</code><br> 得到<code>Result&lt;T, NoneError&gt;</code></li></ol><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p>如何处理Result呢？</p><ol><li><code>try!</code></li><li><code>?</code></li></ol><h2 id="常见组合子"><a href="#常见组合子" class="headerlink" title="常见组合子"></a>常见组合子</h2><ol><li>filter_map<br> F 如果返回 None，则跳过处理这个元素</li></ol><h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> panic &#123;</span><br><span class="line">    ($($arg:tt)*) =&gt; &#123; ... &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 panic 操作会使得当前线程 panic。<br>诸如 Option 和 Result 的 unwrap 方法，如果结果是 None 或者 Err，则会导致 panic。</p><h3 id="Panic-和-thread"><a href="#Panic-和-thread" class="headerlink" title="Panic 和 thread"></a>Panic 和 thread</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> thread_join_handle = std::thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">"Pan"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> res = thread_join_handle.join();</span><br><span class="line"><span class="built_in">assert!</span>(res.is_err());</span><br></pre></td></tr></table></figure><p>可以看到，如果线程 panic 了，那么 join 会得到一个 Err。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">thread &apos;&lt;unnamed&gt;&apos; panicked at &apos;Pan&apos;, src\mod_thread\mod.rs:4:9</span><br><span class="line">stack backtrace:</span><br><span class="line">   0: std::panicking::begin_panic</span><br><span class="line">             at /rustc/f83e0266cf7aaa4b41505c49a5fd9c2363166522\library\std\src/panicking.rs:588:12</span><br><span class="line">   1: learn::mod_thread::test_join_panic::&#123;&#123;closure&#125;&#125;</span><br><span class="line">             at .\src\mod_thread\mod.rs:4:9</span><br><span class="line">note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><h3 id="捕获-panic"><a href="#捕获-panic" class="headerlink" title="捕获 panic"></a>捕获 panic</h3><p>对 panic 的处理，可以是直接 abort，也可以是 unwind。通过<a href="https://doc.rust-lang.org/std/panic/fn.catch_unwind.html" target="_blank" rel="noopener">std::panic::catch_unwind</a>可以捕获 unwind 形式的 panic。<a href="https://doc.rust-lang.org/nomicon/unwinding.html" target="_blank" rel="noopener">在 Rust 1.0 中，panic 只能被父线程捕获</a>，所以如果我们需要捕获 panic，就必须为可能 panic 的代码启动一个新的线程，而 catch_unwind 可以缓解这问题。</p><p><code>catch_unwind</code> 的用法通常是在 FFI 的边界中用来捕获所有的 panic，但我们无法获取和 panic 有关的信息，例如 backtrace。此时可以使用<code>panic::set_hook</code>。</p><p>另外一种捕获 panic 的方法，是 <code>panic::set_hook</code>。</p><h3 id="Exception-Safety"><a href="#Exception-Safety" class="headerlink" title="Exception Safety"></a>Exception Safety</h3><p>考虑下面的代码，在 unsafe 中，clone 可能 panic。一旦它 panic，因为已经 set_len 了，所以我们可能读到一些未初始化的数据。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: <span class="built_in">Clone</span>&gt; <span class="built_in">Vec</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">push_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, to_push: &amp;[T]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.reserve(to_push.len());</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            <span class="comment">// can't overflow because we just reserved this</span></span><br><span class="line">            <span class="keyword">self</span>.set_len(<span class="keyword">self</span>.len() + to_push.len());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i, x) <span class="keyword">in</span> to_push.iter().enumerate() &#123;</span><br><span class="line">                <span class="keyword">self</span>.ptr().add(i).write(x.clone());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="double-panic"><a href="#double-panic" class="headerlink" title="double panic"></a>double panic</h3><p>避免 double panic，可以使用 safe_panic。double panic 的情况可能出现在：</p><ol><li>如果在某个线程中已经 panic 了，并且后续在某个对象的 Drop 中也会有 panic 逻辑，那么可能 panic while panicking<br> 例如<a href="https://github.com/tikv/tikv/blob/5a1f11048714054232fd12bde01f11a1729e498d/components/raftstore/src/store/fsm/peer.rs#L190" target="_blank" rel="noopener">这里</a>的<code>Drop-&gt;stop-&gt;cancel_applying_snap-&gt;check_applying_snap</code> 和 <code>check_snap_status-&gt;check_applying_snap</code>。</li></ol><h1 id="指针和智能指针"><a href="#指针和智能指针" class="headerlink" title="指针和智能指针"></a>指针和智能指针</h1><p>C++中，为了突破栈上分配的限制会在堆上分配对象，Rust中为了避免移动，有更进一步的往堆上创建对象的需求。C++不会对指针进行资源管理，后面标准库也只是断断续续支持了一些智能指针，但Rust希望做得更周到一点。</p><p>在Rust中有下面的指针：</p><ol><li><code>*mut T</code>/<code>*const T</code><br> 这是C的裸指针</li><li><code>Box</code></li><li><code>Pin</code></li><li><code>Rc</code></li><li><code>Arc</code><br> 原子引用计数</li><li><code>Ref</code></li><li><code>RefCell</code></li><li><code>Cow</code></li><li><code>Cell</code></li><li><code>NotNull</code></li></ol><h2 id="Box"><a href="#Box" class="headerlink" title="Box"></a>Box</h2><h2 id="trait-Deref-DerefMut"><a href="#trait-Deref-DerefMut" class="headerlink" title="trait Deref/DerefMut"></a>trait Deref/DerefMut</h2><p>Deref是deref操作符<code>*</code>的 trait，比如<code>*v</code>。它的作用是：</p><ol><li>对于实现了Copy对象，获得其拷贝</li><li>对于没有实现Copy的对象，获得其所有权</li></ol><p>如下所示，一个智能指针对象U比如Box，如果它实现了<code>U: Deref&lt;Target=T&gt;</code>，那么Deref能够从它获得一个<code>&amp;T</code>。实现上，我们从一个<code>&amp;Box&lt;T&gt;</code>解两次引用，获得<code>T</code>，再返回<code>&amp;T</code>。抽象一点来说，在实现了Deref后，能将<code>&amp;U</code>变成<code>&amp;T</code>，换种说法<code>*x</code>的效果就是<code>*Deref::deref(&amp;x)</code>。这么做的好处是将所有奇怪的对智能指针的引用都转成<code>&amp;T</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; Deref <span class="keyword">for</span> &amp;T &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        *<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>, A: Allocator&gt; Deref <span class="keyword">for</span> <span class="built_in">Box</span>&lt;T, A&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;**<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而DerefMut如下所示，它允许我们从智能指针获取一个 <code>&amp;mut T</code>。容易发现，如果一个智能指针没实现DerefMut，那么它实际上是 Immutable 的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">DerefMut</span></span>: Deref &#123;</span><br><span class="line">    <span class="comment">/// Mutably dereferences the value.</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; &amp;<span class="keyword">mut</span> Self::Target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rc-Arc"><a href="#Rc-Arc" class="headerlink" title="Rc/Arc"></a>Rc/Arc</h2><p>如下图所示，三个list中，<code>b</code> 和 <code>c</code>共享 <code>a</code> 的所有权。我们可以用 Rc 来描述。<br><img src="/img/rust-lang/trpl15-03.svg"></p><p>注意虽然<code>Rc::clone(a)</code>等价于<code>a.clone()</code>，但推荐使用<code>Rc::clone</code>，因为这显式表示它只增加引用计数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="只读和-amp-mut"><a href="#只读和-amp-mut" class="headerlink" title="只读和 &amp;mut"></a>只读和 &amp;mut</h3><p>需要注意的是，Rc 只允许各个所有者之间<strong>只读地</strong>进行共享。否则，如果各个所有者能修改，那么就有可能data race。也就是说，Rc/Arc 不实现 AsMut 和 DerefMut，从而做到禁止可变借用。事实上，Rc 会在<strong>编译期</strong>进行不可变借用的检查。</p><p>例如，如果 Rc 中持有 FnMut，则会导致 “cannot borrow data in an <code>Rc</code> as mutable” 报错</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> r = Rc::new(|| a += <span class="number">1</span>);</span><br><span class="line">r();</span><br></pre></td></tr></table></figure><p>尽管如此，Rc 还是通过 <code>Rc::get_mut</code> 提供一种获得 <code>&amp;mut T</code> 的方法。它会在运行期用 <code>Rc::is_unique</code> 来判断是否为唯一引用，并返回 <code>Some(&amp;mut T)</code> 或者 <code>None</code>。</p><h2 id="内部可变性-interior-mutability-引用"><a href="#内部可变性-interior-mutability-引用" class="headerlink" title="内部可变性(interior mutability)引用"></a>内部可变性(interior mutability)引用</h2><p>总所周知，Rust 要求一个对象可以：</p><ol><li>有多个不可变引用(aliasing)</li><li>有一个可变引用(mutability)</li></ol><p>通过 Cell 和 RefCell 可以允许“多个可变引用”。其主要做法是可以通过<code>&amp;</code>来 mutate 对象。</p><h3 id="RefCell"><a href="#RefCell" class="headerlink" title="RefCell"></a>RefCell</h3><p><code>RefCell</code>是类似于<code>Box</code>的指针，但不同于引用和Box类型，RefCell<strong>在运行期检查借用</strong>。具体来说，RefCell在运行期检查：</p><ol><li>在任意时刻只能获得一个<code>&amp;mut</code>或任意个<code>&amp;</code></li><li>引用指向的对象是存在的</li></ol><p>容易想到，RefCell的内部实现肯定会有unsafe块，才能绕过编译期的可变/不可变借用检查，而delay到运行期检查。但检查仍然是要求在任何时候只允许有多个不可变借用或一个可变借用。如果运行时检查出现问题，则会panic，如下所示。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// panic: already borrowed: BorrowMutError</span></span><br><span class="line"><span class="keyword">let</span> y1 = b.borrow_mut();</span><br><span class="line"><span class="keyword">let</span> y2 = b.borrow_mut();</span><br></pre></td></tr></table></figure><p><code>RefCell</code>在自己不可变的情况下，修改内部的值，这也就是<a href="https://kaisery.github.io/trpl-zh-cn/ch15-05-interior-mutability.html" target="_blank" rel="noopener">内部可变性</a>。可以类比为C++中一个const对象里面的mutable成员。那么<code>RefCell</code>也可以用在类似的场景下，例如一些需要存中间状态的状态机、Mocker等。</p><p>对<code>RefCell</code>的<code>&amp;</code>和<code>&amp;mut</code>借用，分别对应了<code>.borrow()</code>和<code>.borrow_mut()</code>方法。</p><p>RefCell是Send/Sync的么？将在Sync/Send章节中介绍。</p><h4 id="RefCell-的-borrow-mut-和-get-mut"><a href="#RefCell-的-borrow-mut-和-get-mut" class="headerlink" title="RefCell 的 borrow_mut 和 get_mut"></a>RefCell 的 borrow_mut 和 get_mut</h4><p>上文介绍了，RefCell 访问对象需要通过 <code>borrow</code> 系列方法，但还有一个 <code>get_mut</code> 方法，它是做啥的呢？<br>根据<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank" rel="noopener">文档</a>可以发现，这个方法直接在编译器从 RefCell 中获取 <code>&amp;mut T</code>。如下所示，这遵循编译期的检查，比如两次 <code>&amp;mut T</code> 会在编译器挡掉而不是在运行期 panic，有点不把它当 RefCell 用的感觉。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="keyword">let</span> x1 = b.get_mut();</span><br><span class="line"><span class="keyword">let</span> x2 = b.get_mut();</span><br><span class="line"><span class="comment">// Compile Error</span></span><br><span class="line">x1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br><span class="line">x2.store(<span class="literal">true</span>, std::sync::atomic::Ordering::SeqCst);</span><br></pre></td></tr></table></figure><p>如果我们联用，会在编译期报错，不过报错内容比较有趣。它说<code>b.get_mut()</code>是个可变借用，而<code>b.borrow_mut()</code>是个不可变借用。为什么不是两次可变借用的冲突？原因很简单，RefCell 本来就是支持的内部可变性嘛，所以对于 Rust 来讲，这是个不可变借用没问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x1 = b.get_mut();</span><br><span class="line"><span class="keyword">let</span> y1 = b.borrow_mut();</span><br><span class="line">x1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br><span class="line">y1.store(<span class="literal">false</span>, std::sync::atomic::Ordering::SeqCst);</span><br></pre></td></tr></table></figure><h4 id="Rc-RefCell"><a href="#Rc-RefCell" class="headerlink" title="Rc+RefCell"></a>Rc+RefCell</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">make_value</span></span>(i: <span class="built_in">i32</span>) -&gt; Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt; &#123;</span><br><span class="line">    Rc::new(RefCell::new(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = make_value(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(make_value(<span class="number">1</span>), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(make_value(<span class="number">2</span>), Rc::clone(&amp;a));</span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> z = value.borrow_mut();</span><br><span class="line">    <span class="comment">// *z = 11; // error</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Cell"><a href="#Cell" class="headerlink" title="Cell"></a>Cell</h3><p>不同于 RefCell，Cell 实现可变性的办法是将持有的对象移出或者移进。所以它不是操作对象引用，而是操作对象本身。</p><ol><li>对于实现了 Copy 的类型，get 方法可以获取当前值。</li><li>对于实现了 Default 的类型，take 可以取出当前值，并用 Default::default() 代替。</li><li>对于所有的类型<ol><li>replace 可以替换并返回旧值。</li><li>into_inner 可以消费 Cell，并返回内部值。</li><li>set 类似于 replace，但直接 drop 旧值。</li></ol></li></ol><h3 id="Mutex-可以和-RefCell-Cell-联用么？"><a href="#Mutex-可以和-RefCell-Cell-联用么？" class="headerlink" title="Mutex 可以和 RefCell/Cell 联用么？"></a>Mutex 可以和 RefCell/Cell 联用么？</h3><p>Mutex 自带了内部可变性。完全可以理解，如果一个函数不可变，那么为何需要用 Mutex 保护呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = Mutex::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> lock = a.lock().unwrap();</span><br><span class="line">*(lock.deref_mut()) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Box</span>::new(RefCell::new(<span class="number">1</span>));</span><br><span class="line">(*a.deref().borrow_mut().deref_mut()) = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>同时，RefCell 和 Cell 都没有实现 Sync，也就是说它们不是线性安全的。</p><h2 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h2><p>【建议在学习Pin之前，了解 Deref 和 DerefMut】<br>一个async fn会产生一个自引用结构<code>AsyncFuture</code>，因此它不能被移动。让一个对象不能被移动的<strong>第一步</strong>是将它分配到堆上，<code>Box</code>可以做到这一点。但这并不够，因为如下所示，<code>std::mem::swap</code>能够移动Box中的对象：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note we don't use &amp;TestNUnpin</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rb2 = <span class="built_in">Box</span>::new(TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;);</span><br><span class="line">std::mem::swap(rb.as_mut(), rb2.as_mut());</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, rb.b, rb2.b); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p>另一方面，很多FFI会跨语言边界传递指针，这<strong>也需要保证地址是不变的</strong>。综上于是就有了Pin。Pin 中包裹了一个指针，如 <code>Pin&lt;&amp;mut T&gt;</code> , <code>Pin&lt;&amp;T&gt;</code> ,<code> Pin&lt;Box&lt;T&gt;&gt;</code>，Pin 保证对应的 T 不会被移动。<br>其实在 C++ 中也会有自引用结构，并且也会造成相同的问题。</p><p>Pin分析了下，诸如<code>std::mem::swap</code>之流为什么能移动，原因是它们都能获得<code>&amp;mut T</code>。所以只要<strong>限制可变借用</strong>，就可以在把对象Pin在堆上。限制获得可变引用简单啊，不实现<code>AsMut</code>就行。</p><h3 id="Unpin-和-Unpin-和-PhantomPinned"><a href="#Unpin-和-Unpin-和-PhantomPinned" class="headerlink" title="Unpin 和 !Unpin 和 PhantomPinned"></a>Unpin 和 !Unpin 和 PhantomPinned</h3><p>大部分的类型都被实现了 Unpin trait，表示能够随意被移动。</p><p>而一个可以被 Pin 住的值需要实现 <code>!Unpin</code>。因为 Rust 中带 <code>!</code> 这样的称为 negative bounds，Rust 对它的支持还没有稳定下来。所以更一般的做法是让结构中持有一个 PhantomPinned 的 marker。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StructCanBePinned</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    _marker: PhantomPinned,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::marker::PhantomPinned</code>中被实现了<code>!Unpin</code>，它会是持有它的结构体变成 <code>!Unpin</code>，从而无法被移动。</p><p>以上的容易理解，但为什么会有<code>Unpin</code>和<code>!Unpin</code>呢？原因是需要给类型分类，讨论在Pin之前和之后类型的行为。这肯定难以理解，所以不妨先看看Pin是如何创建的，再回过来看。</p><h3 id="Pin-对象的创建方式"><a href="#Pin-对象的创建方式" class="headerlink" title="Pin 对象的创建方式"></a>Pin 对象的创建方式</h3><p>在下面的代码中，对一个实现了 <code>trait Unpin</code> 的类型 Target，可以直接通过 <code>Pin::new</code> 产生一个 <code>Pin&lt;P&gt;</code> 对象。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;P: Deref&lt;Target: Unpin&gt;&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">const</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(pointer) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_unchecked</span></span>(pointer: P) -&gt; Pin&lt;P&gt; &#123;</span><br><span class="line">    Pin &#123; pointer &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果说是一个<code>!Unpin</code>的对象，<code>Pin::new</code> 会返回错误 “error[E0277]: <code>PhantomPinned</code> cannot be unpinned”；或者错误 “the trait <code>Unpin</code> is not implemented for <code>TestNUnpin</code>“，和”note: consider using <code>Box::pin</code>“。可以通过打开下面代码的注释来检查。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestUnpin</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#[derive(Default, Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TestNUnpin</span></span> &#123;</span><br><span class="line">    b: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> TestNUnpin &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rp = Pin::new(&amp;<span class="keyword">mut</span> TestUnpin::<span class="keyword">default</span>());</span><br><span class="line">    <span class="comment">// let rnp = Pin::new(&amp;mut TestNUnpin::default());</span></span><br><span class="line">    <span class="comment">// let rnp2 = Pin::new(&amp;TestUnpin::default()); // error[E0277]: `PhantomPinned` cannot be unpinned</span></span><br><span class="line">    <span class="keyword">let</span> rnb = <span class="built_in">Box</span>::pin(TestNUnpin::<span class="keyword">default</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用不安全的-new-unchecked"><a href="#使用不安全的-new-unchecked" class="headerlink" title="使用不安全的 new_unchecked"></a>使用不安全的 new_unchecked</h4><p>我们可以通过 <code>Pin::new_unchecked</code> 来创建 <code>!Unpin</code> 的对象。但这是<a href="https://doc.rust-lang.org/stable/std/pin/struct.Pin.html#safety" target="_blank" rel="noopener">不安全的</a>，因为我们不能保证传入的 <code>pointer: P</code> 指向的数据是被 pin 的。使用这个方法，需要保证 <code>P::Deref/DerefMut</code> 的实现中不能将 self 中的东西进行移动。这是因为 Pin 的 <code>as_mut</code> 和 <code>as_def</code> 会调用 P 的 <code>deref(_mut)</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Pin&lt;&amp;<span class="keyword">mut</span> P::Target&gt; &#123;</span><br><span class="line">    <span class="comment">// SAFETY: see documentation on this function</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> *<span class="keyword">self</span>.pointer) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以构造出一个 evil 有问题的 case。在 DerefMut 中，我们将 b 的原值 move 了出来。然后我们将 <code>EvilNUnpin</code> 作为一个 String 的指针传进去。结果打印出来已经有问题了。解决方案也很简单，如果想要 T 不被移动，那么始终 pin 住 <code>&amp;mut T</code> 就行。</p><p>此外，还需要保证这个 pointer 指向的对象不会再被移动，特别要注意不能以 <code>&amp;mut P::Target</code> 这样的方式被移动，例如通过之前提的 mem::swap。<br>特别地，Pin 需要保证自己维护的指针不会再被移动了，**即使在自己销毁之后，<a href="https://stackoverflow.com/questions/69854787/why-we-use-boxpin-for-unpin-and-pinnew-for-unpin" target="_blank" rel="noopener">也是不能被移动的</a>**，但这个很难在编译期判定。如下代码所示，在两个 Pin 对象析构后，我们又可以移动对象 x1 和 x2 了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_new_unchecked</span></span>() &#123;</span><br><span class="line">    <span class="comment">// We can even swap !Unpin objects, with Pin::new_unchecked</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x1 = TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin&#123; b: <span class="string">"2"</span>.to_owned() &#125;;</span><br><span class="line">    <span class="keyword">let</span> ptr1 = &amp;x1 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">    <span class="keyword">let</span> ptr2 = &amp;x2 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> _pin1 = Pin::new_unchecked(&amp;x1);</span><br><span class="line">        <span class="keyword">let</span> _pin2 = Pin::new_unchecked(&amp;x1);</span><br><span class="line">    &#125;</span><br><span class="line">    std::mem::swap(&amp;<span class="keyword">mut</span> x1, &amp;<span class="keyword">mut</span> x2);</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> n1 = &amp;*(ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">        <span class="keyword">let</span> n2 = &amp;*(ptr2 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(n1.b, <span class="string">"2"</span>);</span><br><span class="line">        <span class="built_in">assert_eq!</span>(n2.b, <span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对-Rc-使用-new-unchecked-也不安全"><a href="#对-Rc-使用-new-unchecked-也不安全" class="headerlink" title="对 Rc 使用 new_unchecked 也不安全"></a>对 Rc<t> 使用 new_unchecked 也不安全</t></h4><p>如下所示，我们可以获得 &amp;mut T，从而又可以乱搞了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x = Rc::new(TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;);</span><br><span class="line"><span class="keyword">let</span> pinned = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(Rc::clone(&amp;x)) &#125;;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> p = pinned.as_ref();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">drop</span>(pinned);</span><br><span class="line"><span class="comment">// We can get &amp;mut T now.</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(Rc::get_mut(&amp;<span class="keyword">mut</span> x).is_some());</span><br></pre></td></tr></table></figure><h4 id="使用安全的-Box-pin"><a href="#使用安全的-Box-pin" class="headerlink" title="使用安全的 Box::pin"></a>使用安全的 Box::pin</h4><p>使用 <code>Box::pin</code> 会产生一个 <code>Pin&lt;Box&lt;T&gt;&gt;</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x1 = TestNUnpin&#123; b: <span class="string">"1"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin&#123; b: <span class="string">"2"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> ptr1 = &amp;x1 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"><span class="keyword">let</span> ptr2 = &amp;x2 <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="built_in">isize</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bx1 = <span class="built_in">Box</span>::pin(x1);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> bx2 = <span class="built_in">Box</span>::pin(x2);</span><br><span class="line">std::mem::swap(&amp;<span class="keyword">mut</span> bx1, &amp;<span class="keyword">mut</span> bx2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n1 = &amp;*(ptr1 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="keyword">let</span> n2 = &amp;*(ptr2 <span class="keyword">as</span> *<span class="keyword">const</span> TestNUnpin);</span><br><span class="line">    <span class="comment">// Should still be 1 and 2.</span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(n1.b, <span class="string">"1"</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(n2.b, <span class="string">"2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么 <code>Box::pin</code> 可以 Pin 住 <code>!Unpin</code>？<br>查看 <code>Box::pin</code> 的实现。它传入一个 <code>T</code>，然后创建一个<code>Box&lt;T&gt;</code>并立马 Pin 住它。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">pin</span></span>(x: T) -&gt; Pin&lt;<span class="built_in">Box</span>&lt;T&gt;&gt; &#123;</span><br><span class="line">    (<span class="keyword">box</span> x).into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Pin 之前，无法移动 T，这是因为只能同时有一个可变借用<code>&amp;mut T</code>。<br>在 Pin 之后，无法移动 T，这是因为 Box 被实现为 owned 且 unique 的。可以参考下面的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t = TestNUnpin&#123;b: <span class="string">"b"</span>.to_owned()&#125;;</span><br><span class="line"><span class="keyword">let</span> mt = &amp;<span class="keyword">mut</span> t;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Box</span>::pin(&amp;<span class="keyword">mut</span> t);</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> t2 = TestNUnpin&#123;b: <span class="string">"a"</span>.to_owned()&#125;;</span><br><span class="line">std::mem::swap(mt, &amp;<span class="keyword">mut</span> t2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, t.b, t2.b);</span><br></pre></td></tr></table></figure><h4 id="使用安全的-pin-utils"><a href="#使用安全的-pin-utils" class="headerlink" title="使用安全的 pin_utils"></a>使用安全的 pin_utils</h4><p>还可以使用 <code>pin_utils::pin_mut!</code>。对于下面的代码，我们考量上述 <code>new_unchecked</code> 安全性的几点保证：</p><ol><li>控制 <code>Deref(Mut)</code><br> pin 的是 <code>&amp;mut T</code> 而不是 <code>T</code>。</li><li>不能取出 <code>&amp;mut T</code><br> 这很简单，因为开始的 <code>$x</code> 已经被 shadow 了。</li><li>不能再次移动 <code>T</code><br> 同上。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> pin_mut &#123;</span><br><span class="line">    ($($x:ident),* $(,)?) =&gt; &#123; $(</span><br><span class="line">        <span class="comment">// Move the value to ensure that it is owned</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> $x = $x;</span><br><span class="line">        <span class="comment">// Shadow the original binding so that it can't be directly accessed</span></span><br><span class="line">        <span class="comment">// ever again.</span></span><br><span class="line">        <span class="meta">#[allow(unused_mut)]</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> $x = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            $crate::core_reexport::pin::Pin::new_unchecked(&amp;<span class="keyword">mut</span> $x)</span><br><span class="line">        &#125;;</span><br><span class="line">    )* &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 shadow 非常重要，我们用下面的例子来说明。可以看到 <code>xp</code> 并没有 shadow 住 <code>x</code>，因此在它被 drop 后，<code>x</code> 又可以被 mutable borrow 了。所以 <code>pin_mut</code> 的实现中保证了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_shadow</span></span>() &#123;</span><br><span class="line">    <span class="comment">// How pin_mut! takes effect.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = TestNUnpin &#123; b: <span class="string">"b"</span>.to_owned() &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> xp = <span class="keyword">unsafe</span> &#123; Pin::new_unchecked(&amp;<span class="keyword">mut</span> x) &#125;;</span><br><span class="line">    <span class="built_in">drop</span>(xp);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.b, <span class="string">"b"</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x2 = TestNUnpin &#123; b: <span class="string">"b2"</span>.to_owned() &#125;;</span><br><span class="line">    std::mem::swap(&amp;<span class="keyword">mut</span> x, &amp;<span class="keyword">mut</span> x2);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(x.b, <span class="string">"b2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，这里的 <code>let mut $x = $x</code> 也很重要，它使得下面的代码可以编译</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> x_mut = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    pin_mut!(x_mut);</span><br><span class="line">    **x_mut = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时它<a href="https://stackoverflow.com/questions/73945397/why-a-ownership-test-is-necessary-in-pin-mut#73950193" target="_blank" rel="noopener">可以拒绝</a></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> foo = Foo &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    pin_mut!(foo);</span><br><span class="line">    <span class="keyword">let</span> _: Pin&lt;&amp;<span class="keyword">mut</span> Foo&gt; = foo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Woops we now have an unprotected Foo when its supposed to be pinned and</span></span><br><span class="line"><span class="comment">// thus can break the guarantees of Pin::new_unchecked</span></span><br><span class="line"><span class="keyword">let</span> foo_ref: &amp;<span class="keyword">mut</span> Foo = &amp;<span class="keyword">mut</span> foo;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总结几个疑问：</p><ol><li><p>为什么可以直接 <code>Pin::new</code> 一个 <code>Unpin</code> 对象？<br> 因为对于实现Unpin类型的对象，Pin不做任何保证。</p></li><li><p>为什么不能直接 <code>Pin::new</code> 一个 <code>!Unpin</code> 的对象？<br> 因为这是不安全的，所以要么 unsafe 地 <code>Pin::new_unchecked</code> 来创建，要么借助于诸如 Box::pin 等安全的方法。</p></li><li><p>如果 T 是 Unpin，能获得 Pin 里面的 <code>&amp;mut</code> 么？<br> 可以通过<code>Pin::get_mut</code>获得</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p = TestUnpin&#123; <span class="string">"a"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> p2 = TestUnpin&#123; <span class="string">"b"</span>.to_owned() &#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    Pin::new(&amp;<span class="keyword">mut</span> p)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> rp2 = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    Pin::ne(&amp;<span class="keyword">mut</span> p2)</span><br><span class="line">&#125;;</span><br><span class="line">std::mem::swap(Pin::get_mut(rp), Pin::get_mut(rp2));</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; &#123;&#125;"</span>, p.a, p2.a); <span class="comment">// Should be `a b`</span></span><br></pre></td></tr></table></figure><p> 但如果类型是!Unpin，我们就不能调用 <code>Pin::get_mut</code>。</p></li></ol><p>现在回答为什么要有Unpin和!Unpin的问题。对于Unpin类型，它实际上是给Pin做了一个担保，告诉Pin即使我这个类型被移动了也没事，所以Pin对它的作用就是屏蔽了<code>&amp;mut</code>的获取渠道。对于!Unpin和PhantomPinned类型，它们是真的不能被移动的，这不仅要借助Pin，这些类型自己也要提供一个合适的接口，从它们来创建Pin。</p><h3 id="Pin-和内部可变性"><a href="#Pin-和内部可变性" class="headerlink" title="Pin 和内部可变性"></a>Pin 和内部可变性</h3><p>是不是被 Pin 的对象就不可以有内部可变性呢？不妨考虑下面一个更简单的对象，我们修改 a 的值，并不会导致任何地址上的变化，所以这个对象是可以有内部可变性的。<br>Pin 使得下面的代码不可编译，并报错”trait <code>DerefMut</code> is required to modify through a dereference, but it is not implemented for <code>Pin&lt;&amp;mut SimpleNUnPin&gt;</code>“。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SimpleNUnPin</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> !Unpin <span class="keyword">for</span> SimpleNUnPin &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x = SimpleNUnPin &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">    pin_utils::pin_mut!(x);</span><br><span class="line">    x.as_mut().a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们能够通过 RefCell 获得内部可变性么？这其实不安全。</p><h2 id="NonNull"><a href="#NonNull" class="headerlink" title="NonNull"></a>NonNull</h2><h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>生命周期(lifetime)是编译期中的 borrow checker 用来检查所有的借用都 valid 的结构。<br>当在结构体中持有一个引用时，需要指定生命周期，从而防止悬垂引用。</p><h2 id="计算生命周期"><a href="#计算生命周期" class="headerlink" title="计算生命周期"></a>计算生命周期</h2><p>下面的代码展示了 Lifetime 和 Scope 的区别。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">3</span>; <span class="comment">// Lifetime for `i` starts. ────────────────┐</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow1 = &amp;i; <span class="comment">// `borrow1` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow1: &#123;&#125;"</span>, borrow1); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow1 ends. ──────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow2 = &amp;i; <span class="comment">// `borrow2` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow2: &#123;&#125;"</span>, borrow2); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow2` ends. ─────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">&#125;   <span class="comment">// Lifetime ends. ─────────────────────────────────────┘</span></span><br></pre></td></tr></table></figure><p>如下所示，发生了移动，只有一次析构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> S &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"drop!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;</span><br><span class="line">        <span class="keyword">let</span> s = S &#123;</span><br><span class="line">            a: <span class="number">1</span></span><br><span class="line">        &#125;;</span><br><span class="line">        s</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但对于下面的代码，则会返回错误”error[E0597]: <code>s.a</code> does not live long enough”。这应该是 Rust 对自引用结构支持不够的问题。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    a: <span class="built_in">u64</span>,</span><br><span class="line">    ra: RefCell&lt;<span class="built_in">Option</span>&lt;&amp;<span class="symbol">'a</span> <span class="built_in">u64</span>&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl&lt;'a&gt; Drop for S&lt;'a&gt; &#123;</span></span><br><span class="line"><span class="comment">//     fn drop(&amp;mut self) &#123;</span></span><br><span class="line"><span class="comment">//         println!("drop!");</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = &#123;</span><br><span class="line">        <span class="keyword">let</span> s = S &#123;</span><br><span class="line">            a: <span class="number">1</span>,</span><br><span class="line">            ra: RefCell::new(<span class="literal">None</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">        *s.ra.borrow_mut() = <span class="literal">Some</span>(&amp;s.a);</span><br><span class="line">        s</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(s));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, (*b).a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="声明周期注解"><a href="#声明周期注解" class="headerlink" title="声明周期注解"></a>声明周期注解</h2><p>下面表示 foo 具有生命周期参数 ‘a 和 ‘b，并且 foo 的 lifetime 不会超过 ‘a 和 ‘b 的 lifetime。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;</span><br><span class="line"><span class="comment">// `foo` has lifetime parameters `'a` and `'b`</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>不考虑省略：</p><ol><li>所有引用参数都需要带一个生命周期参数</li><li>返回的引用要么是’static，要么是和输入一样的生命周期</li></ol><p>下面编译出错。这里，<code>&#39;a</code> must live longer than the function，也就是说函数运行完之后，’a 应该还在 lifetime 中。而这里的 &amp;String 在函数返回前就析构了，所以它肯定不满足 ‘a 的约束。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">invalid_output</span></span>&lt;<span class="symbol">'a</span>&gt;() -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">String</span> &#123; &amp;<span class="built_in">String</span>::from(<span class="string">"foo"</span>) &#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>下面两个代码实际是等价的，所以如果希望 self 的生命周期就是 impl 的，那么应该加上 ‘a。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; Foo&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; Boo&lt;<span class="symbol">'a</span>&gt; &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; Foo&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>&lt;<span class="symbol">'b</span>&gt;(&amp;<span class="symbol">'b</span> <span class="keyword">self</span>, path: &amp;<span class="built_in">str</span>) -&gt; Boo&lt;<span class="symbol">'b</span>&gt; &#123; <span class="comment">/* */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，未必要给 impl 加 lifetime 参数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Owner</span></span>(<span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Owner &#123;</span><br><span class="line">    <span class="comment">// Annotate lifetimes as in a standalone function.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) &#123; <span class="keyword">self</span>.<span class="number">0</span> += <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">print</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"`print`: &#123;&#125;"</span>, <span class="keyword">self</span>.<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> owner = Owner(<span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    owner.add_one();</span><br><span class="line">    owner.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Elision"><a href="#Elision" class="headerlink" title="Elision"></a>Elision</h3><h2 id="生命周期的协变和逆变"><a href="#生命周期的协变和逆变" class="headerlink" title="生命周期的协变和逆变"></a>生命周期的协变和逆变</h2><p><code>&#39;a</code>是<code>&#39;b</code>的子类，这个在生命周期注解中的含义是<code>&#39;a</code>比<code>&#39;b</code>长，也就是说子类的生命周期大于等于父类。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">'a</span> : <span class="symbol">'b</span></span><br></pre></td></tr></table></figure><p>根据里氏替换原则，可以得到定义：</p><ol><li>协变<br> 子类可以替换父类，也就是生命周期短的参数可以接受生命周期长的参数。大部分指针都是协变或者不变的。</li><li>逆变</li></ol><p>讨论变性：</p><ol><li><code>&amp;&#39;a T</code><br> 对<code>&#39;a</code>协变，对 T <strong>协变</strong>。</li><li><code>&amp;&#39;a mut T</code><br> 对<code>&#39;a</code>协变，对 T <strong>不变</strong>。</li><li><code>fn(T) -&gt; U</code><br> 对 T 逆变，也就是它可以接受生命周期更短的参数。<br> 对 U 协变。</li></ol><p>讨论上面几个问题。<br>为什么 <code>&amp;&#39;a mut T</code> 对 T 不变？不妨考虑 T 分别是 <code>&amp;&#39;static str</code> 和 <code>&amp;&#39;a str</code> 的情况，显然前者是后者的子类。那么如果 T 协变，则前者就能代替后者。现在我们考虑下面的 overwrite 函数。如果协变成立，就可以事实上将 string 这个生命周期更短的赋值给 forever_str 这个生命周期更长的了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">overwrite</span></span>&lt;T: <span class="built_in">Copy</span>&gt;(input: &amp;<span class="keyword">mut</span> T, new: &amp;<span class="keyword">mut</span> T) &#123;</span><br><span class="line">    *input = *new;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_varaint_mut</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> forever_str: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"hello"</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> string = <span class="built_in">String</span>::from(<span class="string">"world"</span>);</span><br><span class="line">        <span class="comment">// *string is str</span></span><br><span class="line">        <span class="comment">// &amp;*string is &amp;'a str</span></span><br><span class="line">        overwrite(&amp;<span class="keyword">mut</span> forever_str, &amp;<span class="keyword">mut</span> &amp;*string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="闭包和函数"><a href="#闭包和函数" class="headerlink" title="闭包和函数"></a>闭包和函数</h1><h2 id="Fn-FnMut-FnOnce"><a href="#Fn-FnMut-FnOnce" class="headerlink" title="Fn/FnMut/FnOnce"></a>Fn/FnMut/FnOnce</h2><p>Rust对<code>a(b,c,d)</code>这样的调用搞了个有点像Haskell中的<code>$</code>的东西，目的是为了<strong>重载“对函数的调用”</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fn</span>::call(&amp;a, (b, c, d))</span><br><span class="line"><span class="built_in">FnMut</span>::call_mut(&amp;<span class="keyword">mut</span> a, (b, c, d))</span><br><span class="line"><span class="built_in">FnOnce</span>::call_once(a, (b, c, d))</span><br></pre></td></tr></table></figure><p><code>FnOnce</code>会获取自由变量的所有权，并且只能调用一次，调用完会把自己释放掉。<br><code>FnMut</code>会可变借用自由变量。<br><code>Fn</code>会不可变借用自由变量。<br><code>FnMut</code>和<code>Fn</code>都可以调用多次。</p><p>可以用下面的代码确定某个函数具体实现了哪个trait，实现了的trait能够通过编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_fn</span> </span>&lt;A, R&gt;(_x: <span class="function"><span class="keyword">fn</span></span>(A) -&gt; R) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_Fn</span> </span>&lt;A, R, F: <span class="built_in">Fn</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnMut</span> </span>&lt;A, R, F: <span class="built_in">FnMut</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_FnOnce</span> </span>&lt;A, R, F: <span class="built_in">FnOnce</span>(A) -&gt; R&gt; (_x: &amp;F) &#123;&#125;</span><br></pre></td></tr></table></figure><p><a href="/asset/rust/easy_demo.md"></a></p><p>查看代码，发现三者具有继承关系<code>Fn : FnMut : FnOnce</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnOnce</span></span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// The returned type after the call operator is used.</span></span><br><span class="line">    <span class="meta">#[lang = <span class="meta-string">"fn_once_output"</span>]</span></span><br><span class="line">    <span class="meta">#[stable(feature = <span class="meta-string">"fn_once_output"</span>, since = <span class="meta-string">"1.12.0"</span>)]</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_once</span></span>(<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">FnMut</span></span>&lt;Args&gt;: <span class="built_in">FnOnce</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call_mut</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Fn</span></span>&lt;Args&gt;: <span class="built_in">FnMut</span>&lt;Args&gt; &#123;</span><br><span class="line">    <span class="comment">/// Performs the call operation.</span></span><br><span class="line">    <span class="meta">#[unstable(feature = <span class="meta-string">"fn_traits"</span>, issue = <span class="meta-string">"29625"</span>)]</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">"rust-call"</span> <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, args: Args) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么是这样的继承关系呢</strong>？<a href="https://stackoverflow.com/questions/31190851/why-is-fn-derived-from-fnmut-which-is-derived-from-fnonce" target="_blank" rel="noopener">这篇回答</a>给出了解释。</p><p>确实可以让FnOnce、FnMut和FnOnce做7种自由组合，但其中只有三种traits是有意义的：</p><ol><li>Fn/FnMut/FnOnce</li><li>FnMut/FnOnce</li><li>FnOnce</li></ol><p>这是因为，如果传入<code>&amp;self</code>可以解决的问题，传入<code>&amp;mut self</code>也可以解决。传入<code>&amp;mut self</code>可以解决的问题，传入<code>self</code>也可以解决。但反之就不一定成立。</p><p>所以 self 是大哥级的人物，动用了伤害很大，它能够解决一切的问题，所以他是最 base 的 trait，而不是最 derive 的 trait。</p><h3 id="闭包对三个trait的实现"><a href="#闭包对三个trait的实现" class="headerlink" title="闭包对三个trait的实现"></a>闭包对三个trait的实现</h3><ol><li>所有的闭包都实现了FnOnce</li><li>如果闭包只移出了所有权，则只实现FnOnce</li><li>如果闭包没移出所捕获变量的所有权，并修改了变量，则实现FnMut</li><li>如果闭包没移出所捕获变量的所有权，且没有修改变量，则实现Fn</li></ol><p><a href="https://doc.rust-lang.org/1.48.0/std/keyword.move.html" target="_blank" rel="noopener">move关键字不会改变闭包具体实现的trait</a>，而只影响变量的捕获方式，我们将在下节讨论。</p><h2 id="捕获"><a href="#捕获" class="headerlink" title="捕获"></a>捕获</h2><p>上面的章节中介绍了闭包可能实现的三个trait，这个章节说明闭包如何捕获环境中的变量。</p><h3 id="C-中捕获的问题"><a href="#C-中捕获的问题" class="headerlink" title="C++中捕获的问题"></a>C++中捕获的问题</h3><p>在C++中，返回一个捕获了Local变量的闭包，是有安全问题的，见<code>get_f()</code>。<br>对于类中的方法，如果<strong>捕获了this指针</strong>(即使是<code>[=]</code>)并传出，在对象析构之后也是有问题的，见<code>print_this_proxy()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x_ = <span class="number">0</span>;</span><br><span class="line">    S(<span class="keyword">int</span> x) : x_(x) &#123;&#125;</span><br><span class="line">    ~S() &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Bye\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; print_this_proxy() &#123;</span><br><span class="line">        <span class="keyword">return</span> [=]()&#123;</span><br><span class="line">            <span class="comment">// Capture this-&gt;x_</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"x_ %d"</span>, x_);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; get_f() &#123;</span><br><span class="line">    <span class="function">S <span class="title">s</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]()&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"S %d\n"</span>, s.x_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="keyword">auto</span> f = get_f();</span><br><span class="line">    f(); <span class="comment">// Not safe</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; proxy;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">S <span class="title">s</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">        proxy = s.print_this_proxy();</span><br><span class="line">    &#125;</span><br><span class="line">    proxy(); <span class="comment">// Not safe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust的捕获"><a href="#Rust的捕获" class="headerlink" title="Rust的捕获"></a>Rust的捕获</h3><p>Rust的捕获相比C++使人比较困惑。首先它没有地方指定捕获哪些变量；另外，还有个move关键字；最后还会加上复制和移动语义。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|| <span class="number">42</span>;</span><br><span class="line">|x| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| x + <span class="number">1</span>;</span><br><span class="line">|x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">move</span> |x:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; x + <span class="number">1</span> &#125;;</span><br></pre></td></tr></table></figure><p>闭包按照什么方式捕获，取决于我们打算如何使用捕获后的变量。</p><p>我们不妨看一个例子，首先定义下面的结构。<code>get_number</code>、<code>inc_number</code>和<code>destructor</code>分别需要传入不可变引用，可变引用以及值。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span> &#123;</span><br><span class="line">    text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    number: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> MyStruct &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span> </span>(text: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>, number: <span class="built_in">u32</span>) -&gt; MyStruct &#123;</span><br><span class="line">        MyStruct &#123;</span><br><span class="line">            text: text,</span><br><span class="line">            number: number,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_number</span> </span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.number</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">inc_number</span> </span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.number += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">destructor</span> </span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Destructing &#123;&#125;"</span>, <span class="keyword">self</span>.text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面代码展示了类似fn的情况，这里fn并没有捕获任何自由变量，因此下面的代码可以正常编译和运行。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> closure1 = |x: &amp;MyStruct| x.get_number() + <span class="number">3</span>;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj1), <span class="number">18</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure1(&amp;obj2), <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">is_fn(closure1); </span><br><span class="line">is_Fn(&amp;closure1);</span><br><span class="line">is_FnMut(&amp;closure1);</span><br><span class="line">is_FnOnce(&amp;closure1);</span><br></pre></td></tr></table></figure><p>下面的代码展示了Fn的情况，这里closure2捕获了obj1的引用。后面的代码进行验证，仍然可以<code>obj1.get_number()</code>来不可变借用，但需要可变引用的<code>obj1.inc_number()</code>就不能通过编译了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure immutably.</span></span><br><span class="line"><span class="keyword">let</span> closure2 = |x: &amp;MyStruct| x.get_number() + obj1.get_number();</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure2(&amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number();               // ERROR</span></span><br></pre></td></tr></table></figure><p>事实上，闭包类似语法糖，相当于把需要捕获的上下文封装到一个Context里面传给真正的执行单元。例如我们可以改写closure2，得到一个自由函数func2。它接受一个Context对象，里面封装了一个不可变引用，并且其生命周期等于Context的生命周期。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span></span>&lt;<span class="symbol">'a</span>&gt;(&amp;<span class="symbol">'a</span> MyStruct);</span><br><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">let</span> ctx = Context(&amp;obj1);</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">func2</span> </span>(context: &amp;Context, x: &amp;MyStruct) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    x.get_number() + context.<span class="number">0</span>.get_number()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="comment">// We can borrow obj1 again immutably...</span></span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="comment">// But we can't borrow it mutably.</span></span><br><span class="line"><span class="comment">// obj1.inc_number(); // ERROR</span></span><br></pre></td></tr></table></figure><p>其实细心观察，就可以提出反对意见。上面的case中不能<code>obj1.inc_number()</code>原因是我们没有<code>let mut obj1 = ...</code>，如果加上去就能正常编译了。这不就是同时Immutable和Mutable Borrow了么？其实我们在最后加一行，再调用一次<code>func2</code>就能报错了。看起来Rust还蛮智能的，func2虽然可变借用，但后续没有用到了，所以就不影响<code>obj1.get_number()</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">25</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(obj1.get_number(), <span class="number">15</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(func2(&amp;ctx, &amp;obj2), <span class="number">26</span>);</span><br></pre></td></tr></table></figure><p>下面的代码展示了FnMut的情况。现在闭包里就直接是可变借用了。在闭包之外，我们既不能可变借用，也不能不变借用，否则都无法编译。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is borrowed by the closure mutably.</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> closure3 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.inc_number();</span><br><span class="line">    x.get_number() + obj1.get_number()</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">26</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">27</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(closure3(&amp;obj2), <span class="number">28</span>);</span><br><span class="line"><span class="comment">// We can't borrow obj1 mutably or immutably</span></span><br><span class="line"><span class="comment">// assert_eq!(obj1.get_number(), 18);   // ERROR</span></span><br><span class="line"><span class="comment">// obj1.inc_number();                   // ERROR</span></span><br></pre></td></tr></table></figure><p>下面的代码展示了FnOnce的情况</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = MyStruct::new(<span class="string">"Hello"</span>, <span class="number">15</span>);</span><br><span class="line"><span class="keyword">let</span> obj2 = MyStruct::new(<span class="string">"More Text"</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// obj1 is owned by the closure</span></span><br><span class="line"><span class="keyword">let</span> closure4 = |x: &amp;MyStruct| &#123;</span><br><span class="line">    obj1.destructor();</span><br><span class="line">    x.get_number()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尝试用四个函数检查下，发现上面三个trait的检查都无法通过编译，也就说明closure4没有实现上面三个trait。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Does not compile:</span></span><br><span class="line"><span class="comment">// is_fn(closure4);</span></span><br><span class="line"><span class="comment">// is_Fn(&amp;closure4);</span></span><br><span class="line"><span class="comment">// is_FnMut(&amp;closure4);</span></span><br><span class="line"><span class="comment">// Compiles successfully:</span></span><br><span class="line">is_FnOnce(&amp;closure4);</span><br></pre></td></tr></table></figure><p>可以发现，闭包捕获变量按照<code>&amp;T -&gt; &amp;mut T -&gt; T</code>的顺序，和<code>Fn -&gt; FnMut -&gt; FnOnce</code>的继承关系如出一辙。也就是先派小弟尝试捕获，小弟解决不了，再请老大出山的思路。</p><p>当然，可以通过<code>move</code>关键字，强行请老大出山。</p><p>对于move/move async捕获，如果闭包中需要使用某个变量例如p，并且在闭包调用完之后，还需要继续访问，则需要在调用闭包前进行clone，例如得到pp。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug,Clone)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> pp = p.clone();</span><br><span class="line">    <span class="keyword">let</span> total_price = <span class="keyword">move</span> | price: <span class="built_in">i32</span>| &#123;</span><br><span class="line">        p.x * p.y * price</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> price = total_price(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p &#123;:?&#125; price &#123;&#125;"</span>, pp, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包能否被多个线程使用？"><a href="#闭包能否被多个线程使用？" class="headerlink" title="闭包能否被多个线程使用？"></a>闭包能否被多个线程使用？</h3><p><a href="https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads" target="_blank" rel="noopener">https://stackoverflow.com/questions/36211389/can-a-rust-closure-be-used-by-multiple-threads</a></p><h1 id="并发与异步"><a href="#并发与异步" class="headerlink" title="并发与异步"></a>并发与异步</h1><h2 id="Send和Sync"><a href="#Send和Sync" class="headerlink" title="Send和Sync"></a>Send和Sync</h2><p><code>trait Send</code>表示该类型的实例可以在线程之间移动。大多数的Rust类型都是Send的，另一些则不可以。比如引用计数智能指针<code>Rc&lt;T&gt;</code>只能在线程内部使用，它就不能被实现为<code>Send</code>的；此外裸指针也不是Send的。由Send类型组成的新类型也是Send的。</p><p><code>trait Sync</code>表示多个线程中拥有该类型实例的引用。换句话说，对于任意类型T，如果<code>&amp;T</code>是Send的，那么<code>T</code>就是Sync的。</p><h3 id="一些常见类型对Send和Sync的支持"><a href="#一些常见类型对Send和Sync的支持" class="headerlink" title="一些常见类型对Send和Sync的支持"></a>一些常见类型对Send和Sync的支持</h3><h4 id="Rc"><a href="#Rc" class="headerlink" title="Rc"></a>Rc</h4><p>Rc并不是Send的。原因是Rc共享同一个引用计数块，并且更新引用计数并不是原子的。如果两个线程同时尝试clone，那么它们可能同时更新引用计数，从而可能会UB。</p><h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h4><p>如果T是Send和Sync的，那么<code>Arc&lt;T&gt;</code>是Send和Sync的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Sync</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Arc&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>初看这很奇怪，难道不是为了并发安全才用的Arc么？为什么反过来Arc还需要一个并发安全的类型呢？其实和C++一样，智能指针的线程安全包含两个层面，即智能指针本身实现，特别是引用计数的线程安全；以及智能指针保护的数据的线程安全：</p><ol><li>Arc相对Rc只是保证了引用计数这一块功能是并发安全的</li><li>如果类型不是并发安全的，通常需要配合RwLock和Mutex等使用。</li></ol><h4 id="RefCell-1"><a href="#RefCell-1" class="headerlink" title="RefCell"></a>RefCell</h4><p>从<a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html" target="_blank" rel="noopener">定义</a>看，RefCell是Send的，但不是Sync的。很容易理解，一个具有内部可变性的对象的引用被各个线程持有，那岂不是可以瞎改了？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> RefCell&lt;T&gt; <span class="keyword">where</span> T: <span class="built_in">Send</span> &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Sync</span> <span class="keyword">for</span> RefCell&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="引用-1"><a href="#引用-1" class="headerlink" title="引用"></a>引用</h4><p><code>&amp;T</code>需要T是Sync的，这个对应了上面的定义。<br><code>&amp;mut T</code>需要T是Send的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Sync</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;T &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: <span class="built_in">Send</span> + ?<span class="built_in">Sized</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> &amp;<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="裸指针"><a href="#裸指针" class="headerlink" title="裸指针"></a>裸指针</h4><p>各类指针都不是Send的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">const</span> T &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span>&gt; !<span class="built_in">Send</span> <span class="keyword">for</span> *<span class="keyword">mut</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然可以简单包一层，从而间接得到可以Send或Sync的裸指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>(*<span class="keyword">mut</span> <span class="built_in">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="built_in">Send</span> <span class="keyword">for</span> MyBox &#123;&#125;</span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> <span class="built_in">Sync</span> <span class="keyword">for</span> MyBox &#123;&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以用同样的办法，通过negative_impls，取消某些已经被Send/Sync的类型的特性。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(negative_impls)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// I have some magic semantics for some synchronization primitive!</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SpecialThreadToken</span></span>(<span class="built_in">u8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Send</span> <span class="keyword">for</span> SpecialThreadToken &#123;&#125;</span><br><span class="line"><span class="keyword">impl</span> !<span class="built_in">Sync</span> <span class="keyword">for</span> SpecialThreadToken &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Mutex和RwLock"><a href="#Mutex和RwLock" class="headerlink" title="Mutex和RwLock"></a>Mutex和RwLock</h4><p>Mutex需要Send，但不需要Sync。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> Mutex&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> Mutex&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>RwLock不仅需要Send，还需要Sync，从而保证能被Reader们共享读取。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span>&gt; <span class="built_in">Send</span> <span class="keyword">for</span> RwLock&lt;T&gt; &#123;&#125;</span><br><span class="line"><span class="meta">#[stable(feature = <span class="meta-string">"rust1"</span>, since = <span class="meta-string">"1.0.0"</span>)]</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span>&lt;T: ?<span class="built_in">Sized</span> + <span class="built_in">Send</span> + <span class="built_in">Sync</span>&gt; <span class="built_in">Sync</span> <span class="keyword">for</span> RwLock&lt;T&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future的所有权可能在各个线程之间移动，<a href="https://users.rust-lang.org/t/why-future-is-not-send-as-this-value-is-used-across-an-await-and-how-to-fix/40620" target="_blank" rel="noopener">那为什么Future不是Send的呢</a>？</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>因为Rust目前不支持可变参数包，所以<a href="https://stackoverflow.com/questions/70082393/why-cant-stdthreadspawn-accept-arguments-in-rust/70082474#70082474" target="_blank" rel="noopener">只能通过spawn闭包的形式创建线程</a>。</p><p>如果子线程panic了，其他线程是没影响的，除非：</p><ol><li>某个线程join了panic的线程，此时会得到一个包含Err的Result，如果直接unwrap则会panic</li><li>如果线程在获得锁后panic，这种现象称为poison<br> 此时，再次尝试<code>mutex.lock()</code>会得到PoisonError，并且<code>mutex.is_poisoned()</code>会返回true。</li></ol><h3 id="线程间同步"><a href="#线程间同步" class="headerlink" title="线程间同步"></a>线程间同步</h3><h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>可以使用类似Go的Channel的方式来通信，也就是所谓的Do not communicate by sharing memory; instead, share memory by communicating。<br>这里mpsc是multiple producer, single consumer的意思。<br>send方法返回一个<code>Result&lt;T, E&gt;</code>类型，所以如果接收端已经被丢弃了，将没有发送值的目标，所以发送操作会返回错误。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为生产者是可以有多个的，所以<code>tx.clone()</code>可以产生另一个生产之。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><p>下面展示了两种async的写法，一种是async函数<code>plus_one</code>，另一种是async块<code>plus_two</code>。对async函数，编译器在实现时也会最终转成async块的形式，并且会改写函数签名。<br>所以，可以理解为async函数最终是返回了一个<code>impl Future&lt;Output = ...&gt;</code>类型，<code>impl Future</code>表示这个类型实现了<code>trait Future</code>，这应该就是<strong>impl Trait</strong>这个特性。Output是我们期望这个Future在Ready后实际返回的类型，比如在这里就是i32。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">initial</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>() -&gt; <span class="keyword">impl</span> Future&lt;Output = <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        initial().await + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">async <span class="function"><span class="keyword">fn</span> <span class="title">plus_two</span></span>() -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    initial().await + <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>plus_one_res</code>和<code>plus_two_res</code>都是Future，可以通过<code>block_on</code>获取结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> plus_one_res = plus_one();</span><br><span class="line">    <span class="keyword">let</span> plus_two_res = plus_two();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_one_res));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, futures::executor::block_on(plus_two_res));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以通过join同时await多个Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">futures::executor::block_on(async &#123;</span><br><span class="line">    <span class="keyword">let</span> j = futures::future::join(plus_one_res, plus_two_res).await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, j.<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="trait-Future"><a href="#trait-Future" class="headerlink" title="trait Future"></a>trait Future</h3><p>这里指的是<code>std::future::Future</code>，因为在早前还有<code>futures::future::Future</code>，它是一个“社区版”的时候，后来<code>trait Future</code>被整合到了标准库中，剩余部分整合到了<code>pub trait FutureExt: Future</code>，其中包含了<code>map</code>/<code>then</code>等操作。当然对于<code>trait Future</code>还有其他的扩展，例如async-std。但回过头，先来看看最基础的<code>trait Future</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Future</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;Self::Output&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>poll函数返回的Poll是个enum，包含<code>Ready(T)</code>和<code>Pending</code>两个状态。但它<strong>并不只有忙等</strong>，如果在一次poll后返回的是<code>Pending</code>，那就会注册<code>cx.waker</code>这个回调，在Future后调用进行通知。</p><p><code>Pin&lt;&amp;mut Self&gt;</code>实际是个指针，它是为了解决自引用结构的问题。</p><h4 id="impl-Future"><a href="#impl-Future" class="headerlink" title="impl Future"></a>impl Future</h4><p>impl了<code>trait Future</code>的类型有很多，例如<code>f.map</code>生成的Map，<code>f.then</code>生成的<code>Then</code>这些组合子都是Future。</p><p>例如，下面代码为Map类型impl Future。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Map</span></span>&lt;I, F&gt; &#123;</span><br><span class="line">    <span class="comment">// Used for `SplitWhitespace` and `SplitAsciiWhitespace` `as_str` methods</span></span><br><span class="line">    <span class="keyword">pub</span>(<span class="keyword">crate</span>) iter: I,</span><br><span class="line">    f: F,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in futures-0.1.31, src/future/map.rs</span></span><br><span class="line"><span class="comment">// 注意，这是一个较老的版本，所以future.poll的签名也不一样。在futures-0.3.15中该实现被挪到了futures-util中</span></span><br><span class="line"><span class="keyword">impl</span>&lt;U, A, F&gt; Future <span class="keyword">for</span> Map&lt;A, F&gt;</span><br><span class="line">    <span class="keyword">where</span> A: Future,</span><br><span class="line">          F: <span class="built_in">FnOnce</span>(A::Item) -&gt; U,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = U;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Error</span></span> = A::Error;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; Poll&lt;U, A::Error&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> e = <span class="keyword">match</span> <span class="keyword">self</span>.future.poll() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(Async::NotReady) =&gt; <span class="keyword">return</span> <span class="literal">Ok</span>(Async::NotReady),</span><br><span class="line">            <span class="literal">Ok</span>(Async::Ready(e)) =&gt; <span class="literal">Ok</span>(e),</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; <span class="literal">Err</span>(e),</span><br><span class="line">        &#125;;</span><br><span class="line">        e.map(<span class="keyword">self</span>.f.take().expect(<span class="string">"cannot poll Map twice"</span>))</span><br><span class="line">         .map(Async::Ready)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里<code>e.map().map()</code>比较独特，前一个map是把<code>self.f</code>应用到e里面的东西，并且清空<code>self.f</code>，让它成为一次性的调用。后一个是把将map的结果包在<code>Async::Ready</code>里面。</p><h3 id="async的生命周期"><a href="#async的生命周期" class="headerlink" title="async的生命周期"></a>async的生命周期</h3><h3 id="async实现"><a href="#async实现" class="headerlink" title="async实现"></a>async实现</h3><p>我们知道，因为在async实现中会产生自引用结构，所以需要用Pin，那什么是自引用结构？为什么async中会存在这种结构呢？<br>首先得从async的实现讲起</p><h4 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h4><p>看下面代码，f1和f2两个await之间是串行的，那么编译器如何生成<code>f.await</code>的代码呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = async <span class="keyword">move</span> &#123;</span><br><span class="line">    f1.await;</span><br><span class="line">    f2.await;</span><br><span class="line">&#125;</span><br><span class="line">f.await;</span><br></pre></td></tr></table></figure><p>如果是用Then的方式，那么就通过回调实现，但这里Rust使用了状态机的方式，即编译器会生成类似<a href="https://huangjj27.github.io/async-book/04_pinning/01_chapter.html" target="_blank" rel="noopener">下面的代码</a>。<code>AsyncFuture</code>实际上</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    fut_one: FutOne,</span><br><span class="line">    fut_two: FutTwo,</span><br><span class="line">    state: State,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">State</span></span> &#123;</span><br><span class="line">    AwaitingFutOne,</span><br><span class="line">    AwaitingFutTwo,</span><br><span class="line">    Done,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Future <span class="keyword">for</span> AsyncFuture &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">poll</span></span>(<span class="keyword">self</span>: Pin&lt;&amp;<span class="keyword">mut</span> <span class="keyword">Self</span>&gt;, cx: &amp;<span class="keyword">mut</span> Context&lt;<span class="symbol">'_</span>&gt;) -&gt; Poll&lt;()&gt; &#123;</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">                State::AwaitingFutOne =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_one.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::AwaitingFutTwo,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::AwaitingFutTwo =&gt; <span class="keyword">match</span> <span class="keyword">self</span>.fut_two.poll(..) &#123;</span><br><span class="line">                    Poll::Ready(()) =&gt; <span class="keyword">self</span>.state = State::Done,</span><br><span class="line">                    Poll::Pending =&gt; <span class="keyword">return</span> Poll::Pending,</span><br><span class="line">                &#125;</span><br><span class="line">                State::Done =&gt; <span class="keyword">return</span> Poll::Ready(()),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么async实现会涉及自引用结构？"><a href="#为什么async实现会涉及自引用结构？" class="headerlink" title="为什么async实现会涉及自引用结构？"></a>为什么async实现会涉及自引用结构？</h4><p>在之前，已经讨论过编译async的普通情况。考虑下面的代码，应该如何编译呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">async &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = [<span class="number">0</span>; <span class="number">128</span>];</span><br><span class="line">    <span class="keyword">let</span> read_into_buf_fut = read_into_buf(&amp;<span class="keyword">mut</span> x);</span><br><span class="line">    read_into_buf_fut.await;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<a href="https://huangjj27.github.io/async-book/03_async_await/01_chapter.html" target="_blank" rel="noopener">在await时可能发生线程切换</a>，所以我们需要将<code>x</code>也转移到生成的<code>AsyncFuture</code>中，那么<code>read_into_buf</code>就会产生一个指向<code>x</code>的引用。如果在一个结构中，某个字段是指向另一个字段的引用，这就是一个自引用结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ReadIntoBuf</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    buf: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> [<span class="built_in">u8</span>], <span class="comment">// points to `x` below</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AsyncFuture</span></span> &#123;</span><br><span class="line">    x: [<span class="built_in">u8</span>; <span class="number">128</span>],</span><br><span class="line">    read_into_buf_fut: ReadIntoBuf&lt;<span class="symbol">'what_lifetime</span>?&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自引用结构"><a href="#自引用结构" class="headerlink" title="自引用结构"></a>自引用结构</h4><p>自引用结构如下，b是一个指向a的引用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span>&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: &amp;<span class="symbol">'a</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但很遗憾，Rust现在不支持自引用结构，导致下面的代码会报错(之前在 lifetime 部分也提过)</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">"Hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> _test = Test &#123; a, b: &amp;a &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为workaround，又得用裸指针。但这玩意有个问题，它的地址是绝对的。当Test被移动了，<code>b</code>指向的地址并不会变化。这就好比反过来的刻舟求剑，我们希望b是一个刻在船(Test)上的地址，但实际上它是个GPS坐标。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span></span> &#123;</span><br><span class="line">    a: <span class="built_in">String</span>,</span><br><span class="line">    b: *<span class="keyword">const</span> <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="then用法"><a href="#then用法" class="headerlink" title="then用法"></a>then用法</h3><p>在没有async和await时，可以使用then系列的用法。</p><h1 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h1><h2 id="数组和切片"><a href="#数组和切片" class="headerlink" title="数组和切片"></a>数组和切片</h2><p>数组的签名是<code>[T;N]</code>，和C++一样，数组类型中包含了它的大小，是编译期常量。数组是否是Copy/Clone<a href="https://doc.rust-lang.org/std/primitive.array.html" target="_blank" rel="noopener">取决于其内部的类型</a>，但如果使用<code>[x, N]</code>创建数组，则<code>x</code>对应的类型必须是Copy的。数组引用<code>&amp;[T;N]</code>可以转换为切片引用<code>&amp;[T]</code></p><p>与之对应的是切片<code>&amp;[T]</code>和<code>&amp;mut [T]</code>。</p><h3 id="切片-Slice-的方法"><a href="#切片-Slice-的方法" class="headerlink" title="切片(Slice)的方法"></a>切片(Slice)的方法</h3><h2 id="Sized、-Sized、-Sized和DST"><a href="#Sized、-Sized、-Sized和DST" class="headerlink" title="Sized、!Sized、?Sized和DST"></a>Sized、!Sized、?Sized和DST</h2><p>Dynamically sized type(DST)，即动态大小类型，表示在编译阶段无法确定大小的类型</p><p>如果一个类型在编译期是已知Size，并且Size固定不变的，那么它会自动实现trait Sized。<br>但有些类型是无法在编译期确定大小的，例如<code>str</code>的大小是未知的(<a href="https://stackoverflow.com/questions/24158114/what-are-the-differences-between-rusts-string-and-str" target="_blank" rel="noopener">所以我们一般通过<code>&amp;str</code>来访问它</a>)，一个trait的大小也是未知的。</p><p>如果一个类型的大小是未知的，那么它的使用会有限制，例如不能写<code>Vec&lt;T&gt;</code>，而只能将T放到Box里面，做成<code>Vec&lt;Box&lt;T&gt;&gt;</code>。</p><h2 id="胖指针"><a href="#胖指针" class="headerlink" title="胖指针"></a>胖指针</h2><p>胖指针指的是指向 DST 的<a href="https://stackoverflow.com/questions/57754901/what-is-a-fat-pointer" target="_blank" rel="noopener">引用<strong>或者指针</strong></a>。<br>一个 Slice 是 DST，那么指向 Slice 的指针就是胖指针</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;<span class="built_in">u32</span>&gt;(), <span class="number">4</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;<span class="built_in">usize</span>&gt;(), <span class="number">8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;[<span class="built_in">u32</span>; <span class="number">2</span>]&gt;(), <span class="number">8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;&amp;<span class="built_in">u32</span>&gt;(), <span class="number">8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;&amp;[<span class="built_in">u32</span>; <span class="number">2</span>]&gt;(), <span class="number">8</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;&amp;[<span class="built_in">u32</span>]&gt;(), <span class="number">16</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;&amp;<span class="keyword">mut</span>[<span class="built_in">u32</span>]&gt;(), <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>可以看到，<code>&amp;[u32]</code>具有两倍大小，原因是其中还储存了一份长度，如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SliceRef</span></span> &#123; </span><br><span class="line">    ptr: *<span class="keyword">const</span> <span class="built_in">u32</span>, </span><br><span class="line">    len: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能直接把变量绑定到一个DST上，因为编译器无法计算出如何分配内存。例如我们经常见到<code>&amp;str</code>，但基本见不到<code>str</code>。</p><p>特别强调，指针也是胖的。考虑到 C++ 允许直接使用 delete 析构 POD 数组，这也是和 C++ 部分一致的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;*<span class="keyword">mut</span>[<span class="built_in">u32</span>]&gt;(), <span class="number">16</span>);</span><br><span class="line"><span class="built_in">assert_eq!</span>(size_of::&lt;*<span class="keyword">const</span>[<span class="built_in">u32</span>]&gt;(), <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>除了 Slice，trait object 也是 DST，它还包含了一个 vptr，将在后面讨论。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TraitObjectRef</span></span> &#123;</span><br><span class="line">    data_ptr: *<span class="keyword">const</span> (),</span><br><span class="line">    vptr: *<span class="keyword">const</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rust中的字符串"><a href="#Rust中的字符串" class="headerlink" title="Rust中的字符串"></a>Rust中的字符串</h2><p>Rust中的字符串是很好的比较数组和切片的工具。和C++一样，Rust有两种字符串：</p><ol><li>str<br> str是Rust的原生字符串类型。因为是DST，所以通常以<code>&amp;str</code>出现。</li><li>String<br> String类型可以随时修改其长度和内容。</li></ol><h3 id="str"><a href="#str" class="headerlink" title="str"></a>str</h3><p><code>&amp;str</code>相关方法实现在str.rs的<code>impl str</code>中。通过<code>.as_ptr()</code>将其转换为一个<code>*const u8</code>指针，通过<code>.len()</code>获得其长度。</p><p>字符串字面量的类型是<code>&amp;&#39;static str</code></p><p><code>&amp;str</code>和<code>&amp;[u8]</code>可以互相转换。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>略</p><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><h3 id="tuple-struct"><a href="#tuple-struct" class="headerlink" title="tuple struct"></a>tuple struct</h3><p>Int 是一个别名，Interger 是一个新的类型。这种形式称为 tuple struct。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Int</span></span> = <span class="built_in">i32</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Interger</span></span>(<span class="built_in">u32</span>)</span><br></pre></td></tr></table></figure><h2 id="ZST"><a href="#ZST" class="headerlink" title="ZST"></a>ZST</h2><p>在C++中，会接触到这样的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ZST</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">sizeof</span>(ZST)</span><br><span class="line"></span><br><span class="line">&amp;ZST() != &amp;ZST()</span><br></pre></td></tr></table></figure><p>在Rust中ZST实例的地址是什么呢？</p><h2 id="never类型和"><a href="#never类型和" class="headerlink" title="never类型和!"></a>never类型和!</h2><p>诸如<code>return</code>、<code>break</code>、<code>continue</code>、<code>panic!()</code>、<code>loop</code> 没有返回值的，或者说返回值类型是<code>never</code>即<code>!</code>，对应到类型理论中就是Bottom类型<br>never类型可以转换为其他任何类型，所以在诸如match中才能下入如下代码而不会产生类型错误</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">None</span> =&gt; <span class="built_in">panic!</span></span><br></pre></td></tr></table></figure><p>如下的发散函数也没有返回值，因此也具有never类型</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>() -&gt; <span class="built_in">u32</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> x: ! = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h2><p>通过turbofish可以辅助推导，下面列出一些例子</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x.parse::&lt;<span class="built_in">i32</span>&gt;()</span><br><span class="line">[</span><br><span class="line">    AdminCmdType::CompactLog,</span><br><span class="line">    AdminCmdType::ComputeHash,</span><br><span class="line">    AdminCmdType::VerifyHash,</span><br><span class="line">]</span><br><span class="line">.iter()</span><br><span class="line">.cloned()</span><br><span class="line">.collect::&lt;std::collections::HashSet&lt;AdminCmdType&gt;&gt;()</span><br><span class="line"><span class="comment">// can also use std::collections::HashSet&lt;_&gt;</span></span><br></pre></td></tr></table></figure><h2 id="trait"><a href="#trait" class="headerlink" title="trait"></a>trait</h2><p>trait类似于Haskell中的typeclass。</p><h3 id="trait和adhoc多态"><a href="#trait和adhoc多态" class="headerlink" title="trait和adhoc多态"></a>trait和adhoc多态</h3><p>见笔记</p><h3 id="关联类型"><a href="#关联类型" class="headerlink" title="关联类型"></a>关联类型</h3><p>关联类型(associated types)是一个将类型占位符(也就是下面的<code>type Output</code>)与trait相关联的方式。</p><p>考虑如果某个类型impl了trait Add，那么它可以接受一个RHS类型的右操作数，并返回Output类型的结果。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS, Output&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Output</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> Add&lt;<span class="built_in">u32</span>, <span class="built_in">u32</span>&gt; <span class="keyword">for</span> <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">my_add</span></span>(<span class="keyword">self</span>, ths: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span> + rhs</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但考虑到trait Add可以接受的RHS可能是多种(例如对String而言可以接受<code>String</code>和<code>&amp;str</code>)，但返回的Output类型是确定的，所以可以将Output类型从由用户指定<strong>改为由实现方指定</strong>。此时就可以定义一个关联类型<code>type Output</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS = <span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="trait的继承"><a href="#trait的继承" class="headerlink" title="trait的继承"></a>trait的继承</h3><p>struct不能继承，但是trait可以继承。</p><p>这里涉及到泛型约束的问题，例如我们impl的是两个Father的交集还是并集呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Son</span></span>: Father1 + Father2 &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> &lt;T: Father1 + Father2&gt; Son <span class="keyword">for</span> T &#123;&#125;</span><br></pre></td></tr></table></figure><p>在这里Father1和Father2是取的交集，也就是说对所有实现了Father1和Father2的T实现Son。</p><h3 id="孤儿规则-Orphan-Rule"><a href="#孤儿规则-Orphan-Rule" class="headerlink" title="孤儿规则(Orphan Rule)"></a>孤儿规则(Orphan Rule)</h3><p>注意，孤儿规则是对 trait 而言的。而 impl 和 struct 就不能出现在不同的 crate 中，否则会报错 “cannot define inherent <code>impl</code> for a type outside of the crate where the type is defined”。</p><h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>例如我们实现sum函数，它只能接受泛型参数T是实现了trait Add的。可以这样写</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;T, Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>因为使用了关联参数，所以还可以简写成这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sum</span></span>&lt;T: Add&lt;Output=T&gt;&gt;</span><br></pre></td></tr></table></figure><p>如果要写的比较多，可以把里面的东西拿出来，用where来写</p><h3 id="静态分发和动态分发"><a href="#静态分发和动态分发" class="headerlink" title="静态分发和动态分发"></a>静态分发和动态分发</h3><p>静态分发和动态分发是对trait而言的。<br>下面是静态分发，为<code>fly_static::&lt;Pig&gt;</code>和<code>fly_static::&lt;Duck&gt;</code>生成独立的代码。这类似于C++里面的模板实例化。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_static</span></span>&lt;T: Fly&gt;(S: T) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是动态分发，在运行期查找<code>fly_dyn(&amp;Fly)</code>对应类型的方法，例如实际传入的是<code>&amp;Duck</code>还是<code>&amp;Pig</code>，是不一样的。这类似C++里面的动态绑定，是有运行时开销的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题来了，这里的<code>&amp;Fly</code>是啥呢？实际上这是后面讨论的trait对象。</p><h2 id="trait作为存在类型-Existential-Type"><a href="#trait作为存在类型-Existential-Type" class="headerlink" title="trait作为存在类型(Existential Type)"></a>trait作为存在类型(Existential Type)</h2><p>存在类型，又被称为无法直接实例化，它的每个实例是具体类型的实例。<br>对于存在类型，编译期无法知道其功能和 Size，目前 Rust 使用 trait object 和 impl Trait 处理存在类型。</p><h3 id="trait-object"><a href="#trait-object" class="headerlink" title="trait object"></a>trait object</h3><p>如下所示，<code>fly_dyn</code>中的<code>&amp;Fly</code>参数就是一个trait object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fly_dyn</span></span>(S: &amp;Fly) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://web.mit.edu/rust-lang_v1.25/arch/amd64_ubuntu1404/share/doc/rust/html/std/raw/struct.TraitObject.html" target="_blank" rel="noopener">TraitObject</a> 可以看成具有下面的组织结构</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Copy, Clone)]</span></span><br><span class="line"><span class="meta">#[allow(missing_debug_implementations)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">TraitObject</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> data: *<span class="keyword">mut</span> (),</span><br><span class="line">    <span class="keyword">pub</span> vtable: *<span class="keyword">mut</span> (),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vtable中包含了对象的析构函数、大小、对齐、方法(也就是虚函数指针)等信息。</p><p>Rust 中有个常见的 E0035错误，和 trait 的对象安全有关。具体来说，只有<strong>对象安全</strong>的trait才可以作为 trait object 来使用，否则只能作为一般的 trait 来使用。<br>具体指下面几点：</p><ol><li>该 trait 的 Self 不能被限定为 Sized</li><li>该 trait 的所有方法必须是对象安全的<ol><li>方法受 Self: Sized 约束</li><li>不包含任何泛型参数</li><li>第一个参数必须为 Self 类型，或者可以解引用为 Self 的类型</li><li>Self 不能出现在出第一个参数之外的地方，包括返回值中</li></ol></li></ol><p>在 <a href="https://learnku.com/docs/rust-rcei-2020/e0038/10604" target="_blank" rel="noopener">E0038</a> 错误中，列出了一些破坏上述原则的情况。<br>比如 <code>T</code> 中定义了带有 type parameter 的接口函数，那么 <code>T</code> 就不能以 trait object 的形式使用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">T</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_value_cf</span></span>&lt;F&gt;(&amp;<span class="keyword">self</span>, cf: &amp;<span class="built_in">str</span>, key: &amp;[<span class="built_in">u8</span>], cb: F)</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnOnce</span>(<span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;, <span class="built_in">String</span>&gt;),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Error like the following</span></span><br><span class="line"><span class="comment">// for a trait to be "object safe" it needs to allow building a vtable to allow the call to be resolvable dynamically</span></span><br></pre></td></tr></table></figure><p>我们可以尝试将它改为下面的形式</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_value_cf</span></span>(&amp;<span class="keyword">self</span>, cf: &amp;<span class="built_in">str</span>, key: &amp;[<span class="built_in">u8</span>], cb: <span class="built_in">Box</span>&lt;dyn <span class="built_in">FnOnce</span>(<span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;, <span class="built_in">String</span>&gt;)&gt;)</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_value_cf</span></span>(&amp;<span class="keyword">self</span>, cf: &amp;<span class="built_in">str</span>, key: &amp;[<span class="built_in">u8</span>], cb: &amp;<span class="keyword">mut</span> dyn <span class="built_in">FnOnce</span>(<span class="built_in">Result</span>&lt;<span class="built_in">Option</span>&lt;&amp;[<span class="built_in">u8</span>]&gt;, <span class="built_in">String</span>&gt;));</span><br></pre></td></tr></table></figure><p>但在实践中，我还观察到出现有 “Cast requires that variable is borrowed for ‘static” 这样的报错。在 <a href="https://github.com/calvinneo/tidb-engine-ext/tree/lifetime-demo" target="_blank" rel="noopener">demo</a> 中如果删掉<code>impl RaftStoreProxy</code>和<code>impl RaftStoreProxyEngineTrait for RaftStoreProxyEngine</code>里面的<code>+ &#39;_</code>，就能复现报错。<a href="https://stackoverflow.com/questions/72672953/cast-requires-that-variable-is-borrowed-for-static" target="_blank" rel="noopener">解决方案</a>就是加上 <code>+ &#39;_</code>。原因是 <code>dyn Trait</code> 会被默认为是 <code>dyn Trait + &#39;static</code>。我们需要显式指定另一个生命周期。 </p><h3 id="impl-Trait"><a href="#impl-Trait" class="headerlink" title="impl Trait"></a>impl Trait</h3><p>在目前的版本中，<a href="https://stackoverflow.com/questions/39482131/is-it-possible-to-use-impl-trait-as-a-functions-return-type-in-a-trait-defini" target="_blank" rel="noopener">不能在trait中返回impl Trait</a>，也就是下面的代码无法编译。只能使用Trait Object。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Vehicle</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> Vehicle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `impl Trait` not allowed outside of function and inherent method return types</span></span><br></pre></td></tr></table></figure><h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>默认情况下Rust编译时会link标准库，通过添加<code>no_std</code>属性可以关闭这个行为。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串相关的结构之间的转换"><a href="#字符串相关的结构之间的转换" class="headerlink" title="字符串相关的结构之间的转换"></a>字符串相关的结构之间的转换</h3><p>包括<code>str</code>、<code>String</code>、<code>&amp;[u8]</code>、<code>Vec&lt;u8&gt;</code>。</p><h1 id="macro-宏"><a href="#macro-宏" class="headerlink" title="macro 宏"></a>macro 宏</h1><h2 id="macro-的-import-和-export"><a href="#macro-的-import-和-export" class="headerlink" title="macro 的 import 和 export"></a>macro 的 import 和 export</h2><p>macro 有两种 scope，textual scope 和 path-based scope。这里的 <a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types" target="_blank" rel="noopener">path</a> 有专门的定义，可以理解为类似<code>crate::a::b</code>或者<code>super::a::b</code>这样的东西。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> lazy_static::lazy_static; <span class="comment">// Path-based import.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> lazy_static &#123; <span class="comment">// Textual definition.</span></span><br><span class="line">    (lazy) =&gt; &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lazy_static!&#123;lazy&#125; <span class="comment">// Textual lookup finds our macro first.</span></span><br><span class="line">self::lazy_static!&#123;&#125; <span class="comment">// Path-based lookup ignores our macro, finds imported one.</span></span><br></pre></td></tr></table></figure><p>在通过 macro_rules! 定义了 macro <strong>之后</strong>，进入 textual scope，直到退出外层的 scope。这就类似于通过 let 定义变量一样。如果定义多次，那么老的 macro 会被 shadow 掉。</p><p><a href="https://github.com/CalvinNeo/Ruster/blob/2e6ddee60798413f658e0448a684dd69a6f997cc/src/main.rs#L13" target="_blank" rel="noopener">如代码所示</a>，在 mod.rs 中声明了 m 后，<code>pub mod a</code>，于是在 a 中也能使用 m 了。这是因为这里是 textual scope，a 也在 mod_macro 这个 scope 下面。也就是说 textual scope 可以进入子 mod，甚至穿越多个文件</p><p>使用<code>#[macro_use]</code>可以将 <code>mod inner</code> 中的 macro 暴露给外部。<code>#[macro_use]</code>甚至可以从另一个 crate import 指定的或者所有的 macro，如下所示：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use(lazy_static)]</span> <span class="comment">// Or #[macro_use] to import all macros.</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> lazy_static;</span><br><span class="line"></span><br><span class="line">lazy_static!&#123;&#125;</span><br><span class="line"><span class="comment">// self::lazy_static!&#123;&#125; // Error: lazy_static is not defined in `self`</span></span><br></pre></td></tr></table></figure><p><code>#[macro_use]</code>需要和<code>#[macro_export]</code>配合使用。<code>#[macro_export]</code>的作用是将 macro 的声明放到 crate root 中，这样就可以通过 <code>crate::macro_name</code> 来访问。<br><a href="https://github.com/CalvinNeo/Ruster/blob/4db2a0ed9de1d70fff4d826ff6f79dcbd9648257/src/main.rs#L14" target="_blank" rel="noopener">下面的代码</a>中，helped 是定义在 mod mod_macro 中的，但它被 export 到了 crate root。所以我们可以通过 crate::helped 来访问。</p><h2 id="macro-语法"><a href="#macro-语法" class="headerlink" title="macro 语法"></a>macro 语法</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>查看定义，MacroRule 就是一个被 match 的 pattern，它支持三种括号。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MacroRules :</span><br><span class="line">   MacroRule ( ; MacroRule )* ;?</span><br><span class="line"></span><br><span class="line">MacroRule :</span><br><span class="line">   MacroMatcher =&gt; MacroTranscriber</span><br><span class="line"></span><br><span class="line">MacroMatcher :</span><br><span class="line">      ( MacroMatch* )</span><br><span class="line">   | [ MacroMatch* ]</span><br><span class="line">   | &#123; MacroMatch* &#125;</span><br></pre></td></tr></table></figure><p>所以可以写如下所示的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add &#123;</span><br><span class="line">    &#123;$a:expr,$b:expr,$c:expr&#125; =&gt; &#123;</span><br><span class="line">        $a+$b</span><br><span class="line">    &#125;;</span><br><span class="line">    [$a:expr,$b:expr] =&gt; &#123;</span><br><span class="line">        $a+$b</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add!&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add![<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add!(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>如下的代码是两种对列表求和的方案。<br>在 MacroTranscriber 中有个结构<code>$(+$a)*</code>，表示给列表的每个元素前面都加上一个<code>+</code>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add_list &#123;</span><br><span class="line">    ($($a:expr),*) =&gt; &#123;</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">        $(+$a)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">macro_rules!</span> add_list2 &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr,$($b:expr),+) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">        $(+$b)*</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, add_list2!(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TT-munchers"><a href="#TT-munchers" class="headerlink" title="TT munchers"></a>TT munchers</h3><p><a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html" target="_blank" rel="noopener">TT munchers</a>指的是<code>$($tail:tt)*</code>这样的结构，它永远可以捕获到还没有被 macro 处理的部分。通过该结构可以“递归”调用 macro。<br>所以可以得到第三种求和方案。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> add_list3 &#123;</span><br><span class="line">    ($a:expr) =&gt; &#123;</span><br><span class="line">        $a</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:expr,$($tail:tt)*) =&gt; &#123;</span><br><span class="line">        $a+add_list3!($($tail)*)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对-MacroMatch-的详细说明"><a href="#对-MacroMatch-的详细说明" class="headerlink" title="对 MacroMatch 的详细说明"></a>对 MacroMatch 的详细说明</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MacroMatch :</span><br><span class="line">      Tokenexcept $ and delimiters</span><br><span class="line">   | <span class="type">MacroMatcher</span></span><br><span class="line">   | <span class="type">$ ( IDENTIFIER_OR_KEYWORD</span> except crate | <span class="type">RAW_IDENTIFIER</span> | <span class="type">_</span> ) : MacroFragSpec</span><br><span class="line">   | <span class="type">$ ( MacroMatch</span>+ ) MacroRepSep? MacroRepOp</span><br></pre></td></tr></table></figure><p>MacroRepSep 能取什么呢？定义如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacroRepSep :</span><br><span class="line">   Token except delimiters and MacroRepOp</span><br></pre></td></tr></table></figure><p>delimiter 是三个括号，Token 基本上啥都可以是了。但我们可以写出<code>($($a:expr)&gt;&gt;*)</code>或者<code>($($a:expr)%*)</code>么？并不能，原因在”Follow-set Ambiguity Restrictions”中有讲到。</p><h3 id="metavariable"><a href="#metavariable" class="headerlink" title="metavariable"></a>metavariable</h3><ol><li>item<br> 诸如 mod、extern crate、fn、struct、enum、union、trait、macro 这些结构都是 item</li><li>expr</li><li>block</li><li>pat(Pattern)</li><li><a href="https://doc.rust-lang.org/reference/paths.html#paths-in-types" target="_blank" rel="noopener">path</a><br> 类似<code>crate::a::b</code>这样的东西</li><li><a href="https://doc.rust-lang.org/reference/macros.html#macro-invocation" target="_blank" rel="noopener">tt(TokenTree)</a></li></ol><h1 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h1><h2 id="unsafe-操作"><a href="#unsafe-操作" class="headerlink" title="unsafe 操作"></a>unsafe 操作</h2><p>Rust哪些操作是需要unsafe包裹的呢？</p><ol><li>对<code>*mut T</code>解引用<br> 注意，取引用是safe的</li><li>访问全局的<code>static</code>对象</li><li>访问union</li></ol><p>这也对应了Rust的两个机制，所有权(禁止裸指针)和并发安全。</p><h1 id="FFI"><a href="#FFI" class="headerlink" title="FFI"></a>FFI</h1><h2 id="常见报错"><a href="#常见报错" class="headerlink" title="常见报错"></a>常见报错</h2><p>Pure virtual function called。通常是因为对象提前被析构了，导致虚表也被释放了。常常和 invalid memory reference 交替出现。</p><h2 id="Fat-pointer-和-FFI"><a href="#Fat-pointer-和-FFI" class="headerlink" title="Fat pointer 和 FFI"></a>Fat pointer 和 FFI</h2><h2 id="trait-object-和-FFI"><a href="#trait-object-和-FFI" class="headerlink" title="trait object 和 FFI"></a>trait object 和 FFI</h2><p>在处理 Fat pointer 和 FFI 的过程中，trait object 非常头疼。<br>考虑下面的场景，<code>RaftStoreProxyPtr</code> 位于 FFI 边界，负责向 C++ 端传递上下文 <code>RaftStoreProxy</code>。C++ 端持有 <code>RaftStoreProxyFFIHelper</code> 对象，并通过里面的 <code>fn_handle_get_proxy_status</code> 接口来调用 Rust。在调用时会传入 <code>RaftStoreProxyPtr</code> 作为上下文。Rust 端在收到调用时，将传入的 <code>RaftStoreProxyPtr</code> 从指针转回为 <code>RaftStoreProxy</code>，并调用 <code>RaftStoreProxy</code> 中的方法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">RaftStoreProxyFFI</span></span>: <span class="built_in">Sync</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RaftStoreProxy</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RaftStoreProxyFFI <span class="keyword">for</span> RaftStoreProxy &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RaftStoreProxyPtr</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> inner: *<span class="keyword">const</span> ::std::os::raw::c_void,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RaftStoreProxyPtr &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">as_ref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;RaftStoreProxy &#123;</span><br><span class="line">        &amp;*(<span class="keyword">self</span>.inner <span class="keyword">as</span> *<span class="keyword">const</span> RaftStoreProxy)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[repr(C)]</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">RaftStoreProxyFFIHelper</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> proxy_ptr: RaftStoreProxyPtr,</span><br><span class="line">    <span class="keyword">pub</span> fn_handle_get_proxy_status: ::std::option::<span class="built_in">Option</span>&lt;</span><br><span class="line">        <span class="keyword">unsafe</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span></span>(</span><br><span class="line">            arg1: RaftStoreProxyPtr,</span><br><span class="line">        ) -&gt; RaftProxyStatus,</span><br><span class="line">    &gt;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> RaftStoreProxyFFIHelper &#123;</span><br><span class="line">    <span class="comment">// forward fn_handle_get_proxy_status to ffi_handle_get_proxy_status</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">ffi_handle_get_proxy_status</span></span>(proxy_ptr: RaftStoreProxyPtr) -&gt; RaftProxyStatus &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> r = proxy_ptr.as_ref().status().load(Ordering::SeqCst);</span><br><span class="line">        std::mem::transmute(r)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们想通过 RaftStoreProxyPtr 调用 RaftStoreProxyFFI 的方法，然后由 RaftStoreProxyFFI 动态 dispatch 到 RaftStoreProxy 上。这样的目的是因为 RaftStoreProxy 里面涉及了很多细节实现，我们想解耦掉，提出一个较为干净的 FFI 层。但很快遇到了问题：</p><ol><li><p>没法为 RaftStoreProxyPtr 实现到 RaftStoreProxyFFI 的解引用<br> 显然，这是因为没办法从 <code>*const c_void</code> 转成 trait object。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error[E0277]: the trait bound `c_void: RaftStoreProxyFFI` is not satisfied</span><br><span class="line">the trait `RaftStoreProxyFFI` is implemented for `RaftStoreProxy`</span><br><span class="line">required for the cast from `c_void` to the object type `dyn RaftStoreProxyFFI`</span><br></pre></td></tr></table></figure></li><li><p>没法为 RaftStoreProxyPtr 直接实现 RaftStoreProxyFFI<br> 这相当于是为 <code>*const c_void</code> 实现一些 trait。不论编译器的报错，单从这个指针我们都无法获得任何的可供后续转发的上下文。</p></li><li><p>也许可以尝试将 RaftStoreProxyPtr 直接定义为 TraitObject，可是它并不是 FFI 安全的。<a href="https://stackoverflow.com/questions/33929079/rust-ffi-passing-trait-object-as-context-to-call-callbacks-on" target="_blank" rel="noopener">有一些比较 hack 的做法</a>，比如可以再定义一个 FFI 安全的平行于 trait object 的对象。</p></li></ol><p>最后我们的<a href="https://github.com/pingcap/tidb-engine-ext/pull/275" target="_blank" rel="noopener">做法</a>是避免在 FFI 边界使用 trait object，而是用一个简单的对象，如 RaftStoreProxy。然后让 RaftStoreProxy 持有一个 trait object 即 RaftStoreProxyEngineTrait。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="cargo-test"><a href="#cargo-test" class="headerlink" title="cargo test"></a>cargo test</h2><p>相比C++的各种测试库，Cargo直接整合了cargo test。测试一般分为两种：</p><ol><li>单测<br> 一般是某个 mod 下面的 #[cfg(test)] 的 mod。</li><li>集成测试<br> 一般是单独的 crate，名字叫做 tests。</li></ol><p>说到 test feature，有一个坑点。考虑集成测试的情况，我们创建<a href="https://github.com/CalvinNeo/tidb-engine-ext/tree/error_test_trait" target="_blank" rel="noopener">两个 crate：tests 和 raftstore</a>。在集成测试的 tests crate 中开启的 <code>#[cfg(test)]</code>，或者 cargo test 自己带上的 test feature，都不会传递到 raftstore 中。如果有需要，得通过自定义一个 testexport 来传递：</p><ol><li>如果 raftstore 需要感知 test 环境，就定义一个 testexport 在自己的 Cargo.toml</li><li>tests 的 Cargo.toml 去 enable <code>raftstore/testexport</code></li></ol><p>当然，如果是 raftstore 自己内部的单测，就不需要 testexport 了，所以我们常常看到代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(any(test, feature = <span class="meta-string">"testexport"</span>))]</span></span><br></pre></td></tr></table></figure><p>具体进行什么测试，会经过：</p><h3 id="package-selection"><a href="#package-selection" class="headerlink" title="package selection"></a>package selection</h3><p><code>--package</code>表示只测试某个package下面的测试，<code>--workspace</code>测试workspace中的所有测试。<br>如果不给定任何选项，则会根据<code>--manifest-path</code>。如果在没有给定，则使用当前的工作目录。<br>如果工作目录是某个workspace的根，则运行所有的default成员的测试。即<code>[default-members]</code>中列出的项目。如果没有列出，对于virtual workspace会运行所有workspace成员的测试；对于非virtual，则只运行root crate的测试。这里其实有点反直觉，按理说virtual workspace一个都不运行比较好。因为比如我哪天将workspace改成了virtual，那么原来的cargo test脚本可能就会运行很多的测试。</p><h3 id="target-selection"><a href="#target-selection" class="headerlink" title="target selection"></a>target selection</h3><p>如果没有指定 target selection，则TODO</p><h3 id="cargo-test-打印"><a href="#cargo-test-打印" class="headerlink" title="cargo test 打印"></a>cargo test 打印</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_snap_append_restart-0 2022/11/15 16:02:38.526 thread.rs:396: [DEBG] tid 42023 thread name is region-worker::test_snap_append_restart-0</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="线程安全的双向链表"><a href="#线程安全的双向链表" class="headerlink" title="线程安全的双向链表"></a>线程安全的双向链表</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>Rust编程之道 by 张汉东</li><li><a href="https://course.rs/" target="_blank" rel="noopener">https://course.rs/</a><br> Rust 语言圣经</li><li><a href="https://learnku.com/docs/rust-async-std/translation-notes/7132" target="_blank" rel="noopener">https://learnku.com/docs/rust-async-std/translation-notes/7132</a><br> 异步rust学习</li><li><a href="https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/01_getting_started/03_state_of_async_rust.html</a><br> 同样是异步教程</li><li><a href="https://huangjj27.github.io/async-book/02_execution/02_future.html" target="_blank" rel="noopener">https://huangjj27.github.io/async-book/02_execution/02_future.html</a><br> 对Future实现的讲解</li><li><a href="https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/" target="_blank" rel="noopener">https://kangxiaoning.github.io/post/2021/04/writing-an-os-in-rust-01/</a><br> 这个是用Rust写操作系统的教程，这一节讲的是如何移除标准库</li><li><a href="https://www.cnblogs.com/praying/p/14179397.html" target="_blank" rel="noopener">https://www.cnblogs.com/praying/p/14179397.html</a><br> future的实现，不关注async相关，包含各种组合子</li><li><a href="https://cloud.tencent.com/developer/article/1628311" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1628311</a><br> 对pin的讲解</li><li><a href="https://folyd.com/blog/rust-pin-unpin/" target="_blank" rel="noopener">https://folyd.com/blog/rust-pin-unpin/</a><br> 对pin的讲解</li><li><a href="https://doc.rust-lang.org/std/pin/" target="_blank" rel="noopener">https://doc.rust-lang.org/std/pin/</a><br> pin的官方文档</li><li><a href="https://www.zhihu.com/question/470049587" target="_blank" rel="noopener">https://www.zhihu.com/question/470049587</a><br> AsRef/Borrow/Deref的讲解</li><li><a href="https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html" target="_blank" rel="noopener">https://dengjianping.github.io/2019/03/05/%E8%B0%88%E4%B8%80%E8%B0%88Fn,-FnMut,-FnOnce%E7%9A%84%E5%8C%BA%E5%88%AB.html</a><br> Fn FnOnce FnMut的区别</li><li><a href="https://zhuanlan.zhihu.com/p/341815515" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/341815515</a><br> 对闭包的论述</li><li><a href="https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759" target="_blank" rel="noopener">https://medium.com/swlh/understanding-closures-in-rust-21f286ed1759</a><br> 对闭包的说明</li><li><a href="https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch" target="_blank" rel="noopener">https://stackoverflow.com/questions/59593989/what-will-happen-in-rust-if-create-mutable-variable-and-mutable-reference-and-ch</a><br> Owner和&amp;mut是否可以同时修改？</li><li><a href="https://doc.rust-lang.org/cargo/reference/features.html" target="_blank" rel="noopener">https://doc.rust-lang.org/cargo/reference/features.html</a><br> 对features的论述</li><li><a href="https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html" target="_blank" rel="noopener">https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html</a><br> TT munchers</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;鉴于贵司大作tikv、tidb、tiflash在Rust、Go和C++之间横跳，因此学习Rust被提上了日程。&lt;/p&gt;
&lt;p&gt;本文简称叫Rust: ACPPPP，它主要是用来讨论Rust在一些方面和C++的异同，而不是介绍这一门语言。所以文章是话题形式的，会有很多穿插，例如在讨论所有权时，会直接讲结构体。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Percolator论文阅读</title>
    <link href="http://www.calvinneo.com/2021/08/14/percolator-reading/"/>
    <id>http://www.calvinneo.com/2021/08/14/percolator-reading/</id>
    <published>2021-08-14T11:20:33.000Z</published>
    <updated>2022-10-24T11:29:22.002Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Percolator论文。</p><a id="more"></a><p>类Percolator系统的环境：</p><ol><li><p>一个KV存储<br> 在Percolator中是BigTable，在TiDB中是TiKV。<br> BigTable可以理解为下面的一个KV映射</p> <figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">row</span><span class="symbol">:string</span>, column<span class="symbol">:string</span>, timestamp<span class="symbol">:int64</span>)-&gt;string</span><br></pre></td></tr></table></figure><p> 在Bigtable中已经提供了针对单行的跨column的事务能力。当然，对于Percolator的跨行跨表的事务，这还是不够的。</p></li><li><p>一个全局授时服务器(TSO)<br> 在Percolator中叫Timestamp Oracle。在TiDB中由PD提供。<br> 这个授时服务可以给每个事务一个全局的时间戳，从而解决时序的问题。</p></li><li><p>Client<br> 作为分布式事务的协调者。在TSO的支持下，这个协调者实现了SI的隔离级别。<br> 所以这个协调者并不是在BigTable里面的，而其他数据库的控制节点和数据节点是放到一起的。<br> Percolator里面的每个节点都会向BigTable进行读写。</p></li></ol><h1 id="Snapshot-Isolation"><a href="#Snapshot-Isolation" class="headerlink" title="Snapshot Isolation"></a>Snapshot Isolation</h1><p>在<a href="/2017/09/20/transaction/">数据库系统中的事务</a>这篇文章中介绍了快照隔离(Snapshot Isolation, SI)。<br>在实现SI时，需要记录两个时间戳，事务开始ST和事务提交CT。SI保护了WW冲突，其他事务在[ST,CT]中的写会和本事务产生冲突。</p><p>如下图所示，SI要求在ST1开始的事务，能看到所有CT2先于(因此ST2肯定也先于)自己的ST1事务的修改。<br><img src="/img/dbtrans/percolator3.png"></p><h1 id="2-2-Transactions"><a href="#2-2-Transactions" class="headerlink" title="2.2 Transactions"></a>2.2 Transactions</h1><p>因为Percolator的协调者是BigTable外部的Client，所以需要自己维护锁。锁具有replicated、distributed、balanced、persistent的要求，BigTable作为存储是支持的，所以这个锁作为meta列一同存放在BigTable的中。</p><p>其实有4个Meta列，如下图所示：</p><p><img src="/img/percolator/f5.png"></p><ol><li>lock<br> 表示一个没提交的事务正在写这个cell。包含了primary lock的位置。</li><li>write<br> 表示是已提交的数据。存放了BigTable的时间戳。</li></ol><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>先来看一个Demo。Bob给Joe转账7块钱。一开始Joe有2块钱，Bob有10块钱。</p><ol><li>写<code>bal:lock</code>加锁Bob的账户，并且这个锁是primary的。此外，写了<code>bal:data</code>为3，也就是扣了7块钱的Bob。</li><li>下面加锁Joe的账户，在<code>bal:lock</code>里面写一个对Bob账户的primary锁的引用。这样在事务挂掉之后，能够知道primary lock在哪里，并且把它清理掉。</li><li>下面进入提交阶段，首先操作primary lock所在的Bob的账户。需要将<code>bal:lock</code>清理掉，<code>bal:write</code>写上对应的ST。通过这个ST就能找到实际的数据<code>bal:data</code>。<br> 在这之后，Reader们就能看到Bob账户上只有3块钱了。</li><li>下面对Secondary也进行写记录和删除锁的处理。</li></ol><p>【Q】看完Demo，有几个问题：</p><ol><li>为什么要引入primary lock？<br> 这个是为了方便进行失败回滚。当事务提交时，会清空primary lock。因此可以认为如果primary lock还在，则事务尚未提交。<br> 例如老事务挂了，留下了一片狼藉的现场。此时，一个新事务可能会访问到老事务残留的secondary lock，对应有两种情况：<ol><li>指向的primary lock还在，认为这个事务还没有提交成功。</li><li>指向的primary lock不在了，认为这个事务提交成功。那么必须先继续提交老事务。</li></ol></li><li>如果说secondary lock被清了一半，怎么办呢？<br> 没问题，后面会讲</li><li>写write列和清空lock是要原子的么？</li><li>在还没有修改Secondary时就可以访问新版本数据了，这个不破坏一致性么？<br> 同问题2</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Percolator事务的模型也是2PC，下面就分两步来看实现，其实就是对Demo的形式化。<br>整个实现是一个Transaction类，包含几个成员：</p><ol><li><p>writes_<br> 这个事务的所有写入。<code>writes_[0]</code>是primary。<br> 一个Percolator事务类似于</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">DML/DQL</span><br><span class="line">...</span><br><span class="line">DML/DQL</span><br><span class="line">Prewrite</span><br><span class="line"><span class="keyword">Commit</span></span><br></pre></td></tr></table></figure></li><li><p>start_ts_<br> 整个事务的ST时间戳，在事务创建时初始化。</p></li><li><p>Set<br> 往<code>writes_</code>里面加数据。</p></li><li><p>Get<br> 读</p></li><li><p>Commit<br> 提交，首先调用一阶段的Prewrite，如果全部成功，执行二阶段提交。</p></li><li><p>Prewrite<br> 一阶段，会被Commit调用。</p></li></ol><h3 id="Commit-1"><a href="#Commit-1" class="headerlink" title="Commit 1"></a>Commit 1</h3><p>Commit的前几行是封装了一阶段的Prewrite，省得用户自己去调用了：</p><ol><li>选择<code>writes_[0]</code>作为<code>primary</code>，剩余的作为<code>secondaries</code></li><li>对primary做Prewrite</li><li>对所有secondaries做Prewrite</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> <span class="function"><span class="keyword">bool</span> <span class="title">Commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">42</span>   Write primary = writes_[<span class="number">0</span>];</span><br><span class="line"><span class="number">43</span>   <span class="built_in">vector</span>&lt;Write&gt; secondaries(writes_.begin()+<span class="number">1</span>, writes_.end());</span><br><span class="line"><span class="number">44</span>   <span class="keyword">if</span> (!Prewrite(primary, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="number">45</span>   <span class="keyword">for</span> (Write w : secondaries)</span><br><span class="line"><span class="number">46</span>     <span class="keyword">if</span> (!Prewrite(w, primary)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>【Q】先对primary进行Prewrite这个行为是必要的么？此外，在Commit 2阶段也能看到类似的现象。我们放到Commit 2这部分讲。</p><h3 id="Prewrite"><a href="#Prewrite" class="headerlink" title="Prewrite"></a>Prewrite</h3><p>传入的两个参数，primary是<code>writes_[0]</code>，primary lock会在它上面。</p><p>我们需要lock所有被写的cell，在这之前，先对于所有的cell检查下面两类冲突：</p><ol><li>【Line 32】如果发现cell的<strong>write列</strong>在自己的ST之后已经存在一条记录，执行abort<br> 这实际上是有其他事务已经提交了修改，事务write-write冲突了。根据SI，需要abort。<br> 【Q】这里有个疑问，SI不是要到提交的时候再检查冲突么？</li><li>【Line 34】如果发现cell的<strong>lock列</strong>上有另外的记录，无论timestamp是什么，执行abort<br> 有可能是一个已经提交的事务，并且它的CT比我们ST还要小，但没来得及清理锁，所以并不是冲突。<br> Percolator认为这个不常见，所以还是abort。<br> 在<a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">文章</a>中还提到可能有失败事务的情况。</li></ol><p>可以发现，检查冲突实际上就是处理write列和lock列。<br>如果没有以上两类冲突，才继续进行：</p><ol><li>【Line36】更新data列，写入ST，以及真正的值<code>w.value</code>。</li><li>【Line37】更新lock列，写入primary锁的row和col。</li></ol><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">27 </span>bool Prewrite(<span class="keyword">Write</span> w, <span class="keyword">Write</span> primary) &#123;</span><br><span class="line"><span class="symbol">28 </span>  Column c = w.col;</span><br><span class="line"><span class="symbol">29 </span>  bigtable::Txn T = bigtable::StartRowTransaction(w.row);</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="symbol">31 </span>  // Abort <span class="keyword">on</span> writes after our start timestamp . . .</span><br><span class="line"><span class="symbol">32 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"write"</span>, [start_ts_ , ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="symbol">33 </span>  // . . . <span class="keyword">or</span> locks at any timestamp.</span><br><span class="line"><span class="symbol">34 </span>  <span class="keyword">if</span> (T.<span class="keyword">Read</span>(w.row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, ∞])) <span class="keyword">return</span> false;</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="symbol">36 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"data"</span>, start_ts , w.value);</span><br><span class="line"><span class="symbol">37 </span>  T.<span class="keyword">Write</span>(w.row, c+<span class="string">"lock"</span>, start_ts ,</span><br><span class="line"><span class="symbol">38 </span>     &#123;primary.row, primary.col&#125;); // The primary’s location.</span><br><span class="line"><span class="symbol">39 </span>  <span class="keyword">return</span> T.Commit();</span><br><span class="line"><span class="symbol">40 </span>&#125;</span><br></pre></td></tr></table></figure><p>接下来，进入Commit 2阶段。</p><h3 id="Commit-2"><a href="#Commit-2" class="headerlink" title="Commit 2"></a>Commit 2</h3><p>后面就是提交的第二阶段：</p><ol><li>【Line48】向TSO请求时间戳，作为CT</li><li>检查lock是否还存在<br> 【Line53】注意，根据“Failure”章节的论述，这里锁可能已经被其他事务清理了。</li><li>对于primary lock<br> 一旦primary对reader可见，说明事务提交了。<ol><li>【Line55】更新write列<br> write列中存放了ST和CT。<br> 存放ST的原因是可以通过ST找到数据，即data列。</li><li>【Line57】移除锁</li><li>【Line58】提交BigTable的行事务，这里就是所谓的commit point。</li></ol></li><li>对于所有secondary lock<ol><li>【Line62】更新write列</li><li>【Line63】移除锁</li></ol></li></ol><p>【Q】为什么在处理primary的时候就提交行事务<code>T.Commit()</code>了？先对primary进行Prewrite这个行为是必要的么？<br>原因是primary的lock列和write列是判断整个事务状态的金标准。在primary写完write、清完lock之后，就认为事务已经提交，所以就<code>T.Commit()</code>了。后面往secondary写，只是起到通知作用。<br>假如往secondary写失败了，也不会影响到整个事务的提交。因为secondary还是会将请求redirect到primary上，然后就能发现primary的已提交状态。</p><p>【Q】写write删lock是原子操作么？如果不是原子操作，它们的顺序是必然的么？是的，因为这是一个 bigtable 事务。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span> bool Commit() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="number">47</span></span><br><span class="line"><span class="number">48</span>   int commit ts = oracle.GetTimestamp();</span><br><span class="line"><span class="number">49</span></span><br><span class="line"><span class="number">50</span>   // Commit primary <span class="built_in">first</span>.</span><br><span class="line"><span class="number">51</span>   Write p = primary;</span><br><span class="line"><span class="number">52</span>   bigtable::Txn T = bigtable::StartRowTransaction(p.<span class="built_in">row</span>);</span><br><span class="line"><span class="number">53</span>   <span class="keyword">if</span> (!T.Read(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, [start_ts , start_ts ]))</span><br><span class="line"><span class="number">54</span>     <span class="built_in">return</span> <span class="literal">false</span>; // aborted <span class="keyword">while</span> working</span><br><span class="line"><span class="number">55</span>   T.Write(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts,</span><br><span class="line"><span class="number">56</span>     start_ts ); // Pointer to data written <span class="built_in">at</span> start_ts .</span><br><span class="line"><span class="number">57</span>   T.Erase(p.<span class="built_in">row</span>, p.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">58</span>   <span class="keyword">if</span> (!T.Commit()) <span class="built_in">return</span> <span class="literal">false</span>; // commit point</span><br><span class="line"><span class="number">59</span></span><br><span class="line"><span class="number">60</span>   // Second phase: write out write records <span class="keyword">for</span> secondary cells.</span><br><span class="line"><span class="number">61</span>   <span class="keyword">for</span> (Write w : secondaries) &#123;</span><br><span class="line"><span class="number">62</span>     bigtable::Write(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"write"</span>, commit ts, start_ts );</span><br><span class="line"><span class="number">63</span>     bigtable::Erase(w.<span class="built_in">row</span>, w.<span class="built_in">col</span>+<span class="string">"lock"</span>, commit ts);</span><br><span class="line"><span class="number">64</span>   &#125;</span><br><span class="line"><span class="number">65</span>   <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="number">66</span> &#125;</span><br></pre></td></tr></table></figure><p>【Q】ST和CT的关系是什么，会出现<code>ST1&lt;ST2</code>但是<code>CT1&gt;CT2</code>的情况吗？也就是说 st2 对应的更晚被启动，但是更早被提交，并且在这之前的 st1 反而在它提交之后还能成功提交？其实不会，我们考虑：<br>如果 st2 被提交，说明 st2 设置的lock，没有被清掉。从而 st2 需要能成功设置 lock。从而 st2 事务在 prewrite 时，没有 ts 大于 st2 的 write，在 [0, ∞] 没有 lock。因为 <code>st1&lt;st2</code>，所以实际要求就是在 [0, ∞] 没有 lock。那么就分为两种情况：</p><ol><li>st1 此时已经提交了，那么 ct1 肯定小于 ct2，假设不成立</li><li>st1 此时还没提交<ol><li>如果此时 st1 已经持有 lock，则 st2 不能上锁成功，假设不成立</li><li>所以此时 st1 会卡在【line 35】，一直到 st2 提交完</li></ol></li></ol><p>但这个情况成立么？其实不会，因为我们注意到 Line 39 的 <code>T.Commit()</code>，可以看出从31到38行的代码都是作为 bigtable 事务被整体提交的。</p><h3 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h3><p>首先检查[0, ST]区间内有没有锁。<br>如果有，说明另一个事务在写，这个读取事务就要等锁被释放(也就是事务完成)后才能继续执行。注意，不能在这里返回旧数据，<a href="https://pingcap.com/zh/blog/percolator-and-txn" target="_blank" rel="noopener">否则可能导致幻读</a>。<br>【Line19】 如果没有锁，就读取最后一次写的数据<code>latest_write</code>，并且返回对应的data【Line22】。如果没有读到数据，就返回no data。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">8 </span> bool <span class="keyword">Get</span>(Row row, Column c, string* value) &#123;</span><br><span class="line"><span class="symbol">9 </span>   <span class="keyword">while</span> (true) &#123;</span><br><span class="line"><span class="symbol">10 </span>    bigtable::Txn T = bigtable::StartRowTransaction(row);</span><br><span class="line"><span class="symbol">11 </span>    // Check <span class="keyword">for</span> locks that signal concurrent writes.</span><br><span class="line"><span class="symbol">12 </span>    <span class="keyword">if</span> (T.<span class="keyword">Read</span>(row, c+<span class="string">"lock"</span>, [<span class="number">0</span>, start_ts_])) &#123;</span><br><span class="line"><span class="symbol">13 </span>    // There is a pending lock; try <span class="keyword">to</span> clean it <span class="keyword">and</span> <span class="keyword">wait</span></span><br><span class="line"><span class="symbol">14 </span>    BackoffAndMaybeCleanupLock(row, c);</span><br><span class="line"><span class="symbol">15 </span>    continue;</span><br><span class="line"><span class="symbol">16 </span>  &#125;</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="symbol">18 </span>  // Find the latest <span class="keyword">write</span> below our start timestamp.</span><br><span class="line"><span class="symbol">19 </span>  latest_write = T.<span class="keyword">Read</span>(row, c+<span class="string">"write"</span>, [<span class="number">0</span>, start_ts_]);</span><br><span class="line"><span class="symbol">20 </span>  <span class="keyword">if</span> (!latest_write.found()) <span class="keyword">return</span> false; // no <span class="keyword">data</span></span><br><span class="line"><span class="symbol">21 </span>  <span class="keyword">int</span> <span class="keyword">data</span> ts = latest_write.start_timestamp();</span><br><span class="line"><span class="symbol">22 </span>  *value = T.<span class="keyword">Read</span>(row, c+<span class="string">"data"</span>, [data_ts, data_ts]);</span><br><span class="line"><span class="symbol">23 </span>  <span class="keyword">return</span> true;</span><br><span class="line"><span class="symbol">24 </span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Failure"><a href="#Failure" class="headerlink" title="Failure"></a>Failure</h2><p>BigTable能处理自身的问题，但还需要处理Client的Failure。<br>如果在提交事务时Client挂了，Percolator需要能够清除遗留的锁，否则可能导致后续的事务被hang住。这个清除的过程是Lazy的，如果事务A在执行时遇到了事务B的冲突锁，那么A会判定事务B是否宕掉，并清除锁。</p><p>A在清除锁时，如果事务B实际并没有宕掉，而且正准备利用这个锁提交事务，会产生race。primary lock就是来解决这个问题的。因为清理或者提交事务都需要通过这个primary lock，所以事务A的清除锁和事务B的利用锁提交事务只有一个可能成功。</p><p>特别注意，在事务B提交前，需要检查lock是否还在【Line53】，然后才能写write。同理，在事务A清理前，也需要检查primary lock是否存在，如果存在，则可以安全清理掉这个primary lock(看起来挺奇怪的，如果一个锁存在，就清理掉这个锁)。</p><p>还有一种情况，当事务已经写完至少一个write列后发生崩溃，此时可能lock还没有全清理完，write可能没有全写完。此时需要roll forward这个事务。</p><p>总之，整个判断的原则就是lock有没有被write取代。</p><h3 id="Lazy-clean和Liveness"><a href="#Lazy-clean和Liveness" class="headerlink" title="Lazy clean和Liveness"></a>Lazy clean和Liveness</h3><p>因为eager clean会导致事务回滚，带来性能开销。所以只有在该事务的锁被认为是属于某个dead worker时，才会被清理。</p><h2 id="Timestamps"><a href="#Timestamps" class="headerlink" title="Timestamps"></a>Timestamps</h2><p>TSO(Timestamp Oracle)服务会阶段性地分配一段区间，并将这段区间的最大值持久化，剩下的时候就可以直接从内存提供服务。当TSO服务重启时，timestamp就会来到持久化了的最大值上。</p><p>为了减少TSO的压力，每个Percolator worker会batch自己的请求为一个RPC发送给TSO服务。当TSO的负载变大时，Percolator的batch大小也会变大。</p><p>Percolator的事务性要求Get()操作会返回它的ST前所有已经被提交的写。考虑一个事务R在TR读，另一个事务W在TW提交了写，且TW &lt; TR，则R能看到W的写。因为TW &lt; TR，那么TW一定在TR的batch，或者TR之前的batch中。因此可以得到下面的顺序</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W <span class="function"><span class="title">lock</span> -&gt;</span> W <span class="function"><span class="title">request</span> TW -&gt;</span> R <span class="function"><span class="title">get</span> TR -&gt;</span> R read</span><br></pre></td></tr></table></figure><p>实际上，在R读取前，W至少已经写完所有的lock了。所以R要么读到锁，要么读到已经被写完的数据。</p><p>从这里，也可以看出加锁的意义之一。考虑下面的执行顺序，如果不加锁，R就不能知道W在写。因为Commit(row1)的CT是小于Get(row)的ST的，根据SI，TR需要能读到Commit(row1)的结果。如果R不管不顾直接读了，而Commit(row1)又是在读取之后发生的，那么R实际上就读到了Commit(row1)之前的结果。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction W       Transaction TR</span><br><span class="line">Prewrite(<span class="name">row1</span>)</span><br><span class="line">W request TW</span><br><span class="line">                    R get TR</span><br><span class="line">                    Get(<span class="name">row</span>) with TR</span><br><span class="line">Commit(<span class="name">row1</span>)</span><br></pre></td></tr></table></figure><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li>Large-scale Incremental Processing Using Distributed Transactions and Notiﬁcations<br> Percolator论文</li><li><a href="http://mysql.taobao.org/monthly/2018/11/02/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2018/11/02/</a><br> 阿里数据库月报，对Percolator有较为详细的介绍</li><li><a href="https://www.jianshu.com/p/05194f4b29dd" target="_blank" rel="noopener">https://www.jianshu.com/p/05194f4b29dd</a><br> 一个简单翻译和个人理解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍Percolator论文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="事务" scheme="http://www.calvinneo.com/tags/事务/"/>
    
  </entry>
  
</feed>
