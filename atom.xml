<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2023-04-23T15:23:42.879Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Excerpt from Harry Potter</title>
    <link href="http://www.calvinneo.com/2023/04/09/excerpt_harry_potter/"/>
    <id>http://www.calvinneo.com/2023/04/09/excerpt_harry_potter/</id>
    <published>2023-04-09T15:20:37.000Z</published>
    <updated>2023-04-23T15:23:42.879Z</updated>
    
    <content type="html"><![CDATA[<p>While rereading Harry Potter, I found these fragments are powerful or interesting.</p><a id="more"></a><h1 id="HP1"><a href="#HP1" class="headerlink" title="HP1"></a>HP1</h1><h1 id="HP2"><a href="#HP2" class="headerlink" title="HP2"></a>HP2</h1><h1 id="HP3"><a href="#HP3" class="headerlink" title="HP3"></a>HP3</h1><blockquote><p>We all know in HP7, Pettigrew gave his life to save Harry.</p></blockquote><p>This is magic at its deepest, its most impenetrable, Harry. But trust me … the time may come when you will be very glad you saved Pettigrew’s life.</p><h1 id="HP4"><a href="#HP4" class="headerlink" title="HP4"></a>HP4</h1><blockquote><p>Another subtle foreshadowing. One must finish reading the entire book before being impressed by Dumbledore’s foresight.</p></blockquote><p>For a fleeting instant, Harry thought he saw a gleam of something like triumph in Dumbledore’s eyes.</p><p>“You are blinded,” said Dumbledore, his voice rising now, the aura of power around him palpable, his eyes blazing once more, “by the love of the office you hold, Cornelius! You place too much importance, and you always have done, on the so-called purity of blood! You fail to recognize that it matters not what someone is born, but what they grow to be! Your dementor has just destroyed the last remaining member of a pure-blood family as old as any — and see what that man chose to make of his life! </p><blockquote><p>“make a choice between what is right and what is easy”.</p></blockquote><p>Remember Cedric. Remember, if the time should come when you have to make a choice between what is right and what is easy, remember what happened to a boy who was good, and kind, and brave, because he strayed across the path of Lord Voldemort. Remember Cedric Diggory.</p><h1 id="HP5"><a href="#HP5" class="headerlink" title="HP5"></a>HP5</h1><blockquote><p>I think it’s funny, since it remind me of Sir Humphrey Appleby.</p></blockquote><p>… because some changes will be for the better, while others will come, in the fullness of time, to be recognized as errors of judgment. Meanwhile, some old habits will be retained, and rightly so, whereas others, outmoded and outworn, must be abandoned. Let us move forward, then, into a new era of openness, effectiveness, and accountability, intent on preserving what ought to be preserved, perfecting what needs to be perfected, and pruning wherever we find practices that ought to be prohibited.</p><p>“You told her He-Who-Must-Not-Be-Named is back?<br>“Yes.”<br>Professor McGonagall sat down behind her desk, frowning at Harry.<br>Then she said, “Have a biscuit, Potter.”</p><blockquote><p>That tells the difference between Hermione and Percy.</p></blockquote><p>“You disagree?”<br>“Yes, I do,” said Hermione, who, unlike Umbridge, was not whispering, but speaking in a clear, carrying voice that had by now attracted the rest of the class’s attention. “Mr. Slinkhard doesn’t like jinxes, does he? But I think they can be very useful when they’re used defensively.” </p><blockquote><p>Ron’s awkward compliment shows the subtle change in his relationship with Hermione.</p></blockquote><p>“We do try,” said Ron. “We just haven’t got your brains or your memory or your concentration — you’re just cleverer than we are — is it nice to rub it in?”<br>“Oh, don’t give me that rubbish,” said Hermione, but she looked slightly mollified as she led the way out into the damp courtyard. </p><blockquote><p>Excellent sarcasm.</p></blockquote><p>“For disrupting my class with pointless interruptions,” said Professor Umbridge smoothly. “I am here to teach you using a Ministry approved method that does not include inviting students to give their opinions on matters about which they understand very little. Your previous teachers in this subject may have allowed you more license, but as none of them — with the possible exception of Professor Quirrell, who did at least appear to have restricted himself to age-appropriate subjects — would have passed a Ministry inspection —“<br>“Yeah, Quirrell was a great teacher,” said Harry loudly, “there was just that minor drawback of him having Lord Voldemort sticking out of the back of his head.” </p><blockquote><p>Hermione is not a nerd.</p></blockquote><p>Nobody raised objections after Ernie, though Harry saw Cho’s friend give her a rather reproachful look before adding her name. When the last person — Zacharias — had signed, Hermione took the parchment back and slipped it carefully into her bag. There was an odd feeling in the group now. It was as though they had just signed some kind of contract.</p><p>He was on the sixth stair when it happened. There was a loud, wailing, klaxonlike sound and the steps melted together to make a long, smooth stone slide. There was a brief moment when Ron tried to keep running, arms working madly like windmills, then he toppled over backward and shot down the newly created slide, coming to rest on his back at Harry’s feet. </p><blockquote><p>Umbridge’s confrontation with Snape. Snape refused to say one more word to deal with Umbridge’s nonsense.</p></blockquote><p>“Well, the class seems fairly advanced for their level,” she said briskly to Snape’s back. “Though I would question whether it is advisable to teach them a potion like the Strengthening Solution. I think the Ministry would prefer it if that was removed from the syllabus.”<br>Snape straightened up slowly and turned to look at her.<br>“Now … how long have you been teaching at Hogwarts?” she asked, her quill poised over her clipboard.<br>“Fourteen years,” Snape replied. His expression was unfathomable.<br>His eyes on Snape, Harry added a few drops to his potion; it hissed menacingly and turned from turquoise to orange.<br>“You applied first for the Defense Against the Dark Arts post, I believe?” Professor Umbridge asked Snape.<br>“Yes,” said Snape quietly.<br>“But you were unsuccessful?”<br>Snape’s lip curled.<br>“Obviously.”<br>Professor Umbridge scribbled on her clipboard.<br>“And you have applied regularly for the Defense Against the Dark Arts post since you first joined the school, I believe?”<br>“Yes,” said Snape quietly, barely moving his lips. He looked very angry.<br>“Do you have any idea why Dumbledore has consistently refused to appoint you?” asked Umbridge.<br>“I suggest you ask him,” said Snape jerkily.<br>“Oh I shall,” said Professor Umbridge with a sweet smile.<br>“I suppose this is relevant?” Snape asked, his black eyes narrowed.</p><blockquote><p>It is always wise to take fate firmly in one’s own hands.</p></blockquote><p>“Well, better expelled and able to defend yourselves than sitting safely in school without a clue,” said Sirius. </p><p>“You don’t think he has become … sort of … reckless … since he’s been cooped up in Grimmauld Place? You don’t think he’s … kind of … living through us?” </p><p>“Your father knew what he was getting into, and he won’t thank you for messing things up for the Order!” said Sirius angrily in his turn. “This is how it is — this is why you’re not in the Order — you don’t understand — there are things worth dying for!”<br>“Easy for you to say, stuck here!” bellowed Fred. “I don’t see you risking your neck!” </p><blockquote><p>Being a victim is not a shame. However, being a fighter is more honorable.</p></blockquote><p>“What’s this?” said Mrs. Longbottom sharply. “Haven’t you told your friends about your parents, Neville?”<br>Neville took a deep breath, looked up at the ceiling, and shook his head. Harry could not remember ever feeling sorrier for anyone, but he could not think of any way of helping Neville out of the situation.<br>“Well, it’s nothing to be ashamed of!” said Mrs. Longbottom angrily. “You should be proud, Neville, proud! They didn’t give their health and their sanity so their only son would be ashamed of them, you know!”<br>“I’m not ashamed,” said Neville very faintly, still looking anywhere but at Harry and the others. Ron was now standing on tiptoe to look over at the inhabitants of the two beds.<br>“Well, you’ve got a funny way of showing it!” said Mrs. Longbottom. “My son and his wife,” she said, turning haughtily to Harry, Ron, Hermione, and Ginny, “were tortured into insanity by You-Know-Who’s followers.”<br>Hermione and Ginny both clapped their hands over their mouths.<br>Ron stopped craning his neck to catch a glimpse of Neville’s parents and looked mortified.<br>“They were Aurors, you know, and very well respected within the Wizarding community,” Mrs. Longbottom went on. “Highly gifted, the pair of them. I — yes, Alice dear, what is it?” </p><blockquote><p>An incisive comment on speech censorship. </p></blockquote><p>“Oh Harry, don’t you see?” Hermione breathed. “If she could have done one thing to make absolutely sure that every single person in this school will read your interview, it was banning it!”</p><blockquote><p>Brilliant irony.</p></blockquote><p>“Oh, so that’s why he wasn’t prosecuted for setting up all those regurgitating toilets!” said Professor McGonagall, raising her eyebrows. “What an interesting insight into our justice system!” </p><p>“Well, usually when a person shakes their head,” said McGonagall coldly, “they mean ‘no.’ So unless Miss Edgecombe is using a form of sign language as yet unknown to humans —“<br>Professor Umbridge seized Marietta, pulled her around to face her, and began shaking her very hard. A split second later Dumbledore was on his feet, his wand raised. Kingsley started forward and Umbridge leapt back from Marietta, waving her hands in the air as though they had been burned.<br>“I cannot allow you to manhandle my students, Dolores,” said Dumbledore, and for the first time, he looked angry.<br>“You want to calm yourself, Madam Umbridge,” said Kingsley in  his deep, slow voice. “You don’t want to get yourself into trouble now.”</p><blockquote><p>Dumbledore’s contempt of Fudge jumps off the page.</p></blockquote><p>“Well, the game is up,” he said simply. “Would you like a written confession from me, Cornelius — or will a statement before these witnesses suffice?”<br>Harry saw McGonagall and Kingsley look at each other. There was fear in both faces. He did not understand what was going on, and neither, apparently, did Fudge.<br>“Statement?” said Fudge slowly. “What — I don’t — ?”<br>“Dumbledore’s Army, Cornelius,” said Dumbledore, still smiling as he waved the list of names before Fudge’s face. “Not Potter’s Army. Dumbledore’s Army.”<br>“But — but —“<br>Understanding blazed suddenly in Fudge’s face. He took a horrified step backward, yelped, and jumped out of the fire again.<br>“You?” he whispered, stamping again on his smoldering cloak.<br>“That’s right,” said Dumbledore pleasantly.<br>“You organized this?”<br>“I did,” said Dumbledore.<br>“You recruited these students for — for your army?”<br>“Tonight was supposed to be the first meeting,” said Dumbledore, nodding. “Merely to see whether they would be interested in joining me. I see now that it was a mistake to invite Miss Edgecombe, of course.”<br>Marietta nodded. Fudge looked from her to Dumbledore, his chest swelling.<br>“Then you have been plotting against me!” he yelled.<br>“That’s right,” said Dumbledore cheerfully.<br>“NO!” shouted Harry.<br>Kingsley flashed a look of warning at him, McGonagall widened her eyes threateningly, but it had suddenly dawned upon Harry what Dumbledore was about to do, and he could not let it happen.<br>“No — Professor Dumbledore!”<br>“Be quiet, Harry, or I am afraid you will have to leave my office,” said Dumbledore calmly.<br>“Yes, shut up, Potter!” barked Fudge, who was still ogling Dumbledore with a kind of horrified delight. “Well, well, well — I came here tonight expecting to expel Potter and instead —“<br>“Instead you get to arrest me,” said Dumbledore, smiling. “It’s like losing a Knut and finding a Galleon, isn’t it?”<br>“Weasley!” cried Fudge, now positively quivering with delight, “Weasley, have you written it all down, everything he’s said, his confession, have you got it?”<br>“Yes, sir, I think so, sir!” said Percy eagerly, whose nose was splattered with ink from the speed of his note-taking.<br>“The bit about how he’s been trying to build up an army against the Ministry, how he’s been working to destabilize me?”<br>“Yes, sir, I’ve got it, yes!” said Percy, scanning his notes joyfully.<br>“Very well, then,” said Fudge, now radiant with glee. “Duplicate your notes, Weasley, and send a copy to the Daily Prophet at once. If we send a fast owl we should make the morning edition!” Percy dashed from the room, slamming the door behind him, and Fudge turned back to Dumbledore. “You will now be escorted back to the Ministry, where you will be formally charged and then sent to Azkaban to await trial!”<br>“Ah,” said Dumbledore gently, “yes. Yes, I thought we might hit that little snag.”<br>“Snag?” said Fudge, his voice still vibrating with joy. “I see no snag, Dumbledore!”<br>“Well,” said Dumbledore apologetically, “I’m afraid I do.”<br>“Oh really?”<br>“Well — it’s just that you seem to be laboring under the delusion that I am going to — what is the phrase? ‘Come quietly’ I am afraid I am not going to come quietly at all, Cornelius. I have absolutely no intention of being sent to Azkaban. I could break out, of course — but what a waste of time, and frankly, I can think of a whole host of things I would rather be doing.”<br>Umbridge’s face was growing steadily redder, she looked as though she was being filled with boiling water. Fudge stared at Dumbledore with a very silly expression on his face, as though he had just been stunned by a sudden blow and could not quite believe it had happened. He made a small choking noise and then looked around at Kingsley and the man with short gray hair, who alone of everyone in the room had remained entirely silent so far. The latter gave Fudge a reassuring nod and moved forward a little, away from the wall. Harry saw his hand drift, almost casually, toward his pocket.<br>“Don’t be silly, Dawlish,” said Dumbledore kindly. “I’m sure you are an excellent Auror, I seem to remember that you achieved ‘Outstanding’ in all your N.E.W.T.s, but if you attempt to — er — ‘bring me in’ by force, I will have to hurt you.”<br>The man called Dawlish blinked, looking rather foolish. He looked toward Fudge again, but this time seemed to be hoping for a clue as to what to do next.<br>“So,” sneered Fudge, recovering himself, “you intend to take on Dawlish, Shacklebolt, Dolores, and myself single-handed, do you, Dumbledore?”<br>“Merlin’s beard, no,” said Dumbledore, smiling. “Not unless you are foolish enough to force me to.” </p><p>“ ‘Course we have,” said George. “Never been expelled, have we?”<br>“We’ve always known where to draw the line,” said Fred.<br>“We might have put a toe across it occasionally,” said George.<br>“But we’ve always stopped short of causing real mayhem,” said Fred.<br>“But now?” said Ron tentatively.<br>“Well, now —“ said George.<br>“— what with Dumbledore gone —“ said Fred.<br>“— we reckon a bit of mayhem —“ said George.<br>“— is exactly what our dear new Head deserves,” said Fred.<br>“You mustn’t!” whispered Hermione. “You really mustn’t! She’d love a reason to expel you!”<br>“You don’t get it, Hermione, do you?” said Fred, smiling at her.<br>“We don’t care about staying anymore. We’d walk out right now if we weren’t determined to do our bit for Dumbledore first. So anyway,” he checked his watch, “phase one is about to begin. I’d get in the Great Hall for lunch if I were you, that way the teachers will see you can’t have had anything to do with it.”</p><p>“Thank you so much, Professor!” said Professor Flitwick in his squeaky little voice. “I could have got rid of the sparklers myself, of course, but I wasn’t sure whether I had the authority… .” </p><blockquote><p>Hermione and rebellious…</p></blockquote><p>“Oh, why don’t we have a night off?” said Hermione brightly, as a silver-tailed Weasley rocket zoomed past the window. “After all, the Easter holidays start on Friday, we’ll have plenty of time then… .”<br>“Are you feeling all right?” Ron asked, staring at her in disbelief.<br>“Now you mention it,” said Hermione happily, “d’you know … I think I’m feeling a bit … rebellious.” </p><blockquote><p>When it comes to satire, McGonagall will never let you down.</p></blockquote><p>“I should have made my meaning plainer,” said Professor McGonagall, turning at last to look Umbridge directly in the eyes. “He has achieved high marks in all Defense Against the Dark Arts tests set by a competent teacher.” </p><blockquote><p>“She towered over”</p></blockquote><p>Professor McGonagall got to her feet too, and in her case this was a much more impressive move. She towered over Professor Umbridge.<br>“Potter,” she said in ringing tones, “I will assist you to become an Auror if it is the last thing I do! If I have to coach you nightly I will make sure you achieve the required results!”<br>“The Minister of Magic will never employ Harry Potter!” said Umbridge, her voice rising furiously.<br>“There may well be a new Minister of Magic by the time Potter is ready to join!” shouted Professor McGonagall. </p><blockquote><p>Glorious finale of Fred and George’s schooling.</p></blockquote><p>“You know what?” said Fred. “I don’t think we are.”<br>He turned to his twin.<br>“George,” said Fred, “I think we’ve outgrown full-time education.”<br>“Yeah, I’ve been feeling that way myself,” said George lightly.<br>“Time to test our talents in the real world, d’you reckon?” asked Fred.<br>“Definitely,” said George.<br>And before Umbridge could say a word, they raised their wands and said together, “Accio Brooms!”<br>Harry heard a loud crash somewhere in the distance. Looking to his left he ducked just in time — Fred and George’s broomsticks, one still trailing the heavy chain and iron peg with which Umbridge had fastened them to the wall, were hurtling along the corridor toward their owners. They turned left, streaked down the stairs, and stopped sharply in front of the twins, the chain clattering loudly on the flagged stone floor.<br>“We won’t be seeing you,” Fred told Professor Umbridge, swinging his leg over his broomstick.<br>“Yeah, don’t bother to keep in touch,” said George, mounting his own.<br>Fred looked around at the assembled students, and at the silent, watchful crowd.<br>“If anyone fancies buying a Portable Swamp, as demonstrated upstairs, come to number ninety-three, Diagon Alley — Weasleys’ Wizarding Wheezes,” he said in a loud voice. “Our new premises!”<br>“Special discounts to Hogwarts students who swear they’re going to use our products to get rid of this old bat,” added George, pointing at Professor Umbridge.<br>“STOP THEM!” shrieked Umbridge, but it was too late. As the Inquisitorial Squad closed in, Fred and George kicked off from the floor, shooting fifteen feet into the air, the iron peg swinging dangerously below. Fred looked across the hall at the poltergeist bobbing on his level above the crowd.<br>“Give her hell from us, Peeves.”<br>And Peeves, whom Harry had never seen take an order from a student before, swept his belled hat from his head and sprang to a salute as Fred and George wheeled about to tumultuous applause from the students below and sped out of the open front doors into the glorious sunset. </p><p>Indeed, a week after Fred and George’s departure Harry witnessed Professor McGonagall walking right past Peeves, who was determinedly loosening a crystal chandelier, and could have sworn he heard her tell the poltergeist out of the corner of her mouth, “It unscrews the other way.”</p><p>“Now see here, Dumbledore!” said Fudge, as Dumbledore picked up the head and walked back to Harry carrying it. “You haven’t got authorization for that Portkey! You can’t do things like that right in front of the Minister of Magic, you — you —“<br>His voice faltered as Dumbledore surveyed him magisterially over his half-moon spectacles.<br>“You will give the order to remove Dolores Umbridge from Hogwarts,” said Dumbledore. “You will tell your Aurors to stop searching for my Care of Magical Creatures teacher so that he can return to work. I will give you …” Dumbledore pulled a watch with twelve hands from his pocket and glanced at it, “half an hour of my time tonight, in which I think we shall be more than able to cover the important points of what has happened here. After that, I shall need to return to my school. If you need more help from me you are, of course, more than welcome to contact me at Hogwarts. Letters addressed to the headmaster will find me.”</p><p>“Kreacher is what he has been made by wizards, Harry,” said Dumbledore. “Yes, he is to be pitied. His existence has been as miserable as your friend Dobby’s. He was forced to do Sirius’s bidding, because Sirius was the last of the family to which he was enslaved, but he felt no true loyalty to him. And whatever Kreacher’s faults, it must be admitted that Sirius did nothing to make Kreacher’s lot easier —“ </p><p>“Sirius did not hate Kreacher,” said Dumbledore. “He regarded him as a servant unworthy of much interest or notice. Indifference and neglect often do much more damage than outright dislike… .<br>The fountain we destroyed tonight told a lie. We wizards have mistreated and abused our fellows for too long, and we are now reaping our reward.”</p><p>“And do I look like the kind of man who can be intimidated?” barked Uncle Vernon.<br>“Well …” said Moody, pushing back his bowler hat to reveal his sinisterly revolving magical eye. Uncle Vernon leapt backward in horror and collided painfully with a luggage trolley. “Yes, I’d have to say you do, Dursley.” </p><h1 id="HP6"><a href="#HP6" class="headerlink" title="HP6"></a>HP6</h1><p>“You are determined to hate him, Harry,” said Lupin with a faint smile. </p><p>Harry got to his feet. As he walked across the room, his eyes fell upon the little table on which Marvolo Gaunt”s ring had rested last time, but the ring was no longer there.<br>“Yes, Harry?” said Dumbledore, for Harry had come to a halt.<br>“The ring”s gone,” said Harry, looking around. “But I thought you might have the mouth organ or something.”<br>Dumbledore beamed at him, peering over the top of his halfmoon spectacles.<br>“Very astute, Harry, but the mouth organ was only ever a mouth organ.”<br>And on that enigmatic note he waved to Harry, who understood himself to be dismissed. </p><p>“But if I keep running in and out of the Ministry,” said Harry, still endeavoring to keep his voice friendly, “won’t that seem as though I approve of what the Ministry’s up to?”<br>“Well,” said Scrimgeour, frowning slightly, “well, yes, that’s partly why we’d like —“<br>“No, I don’t think that’ll work,” said Harry pleasantly. “You see, I don’t like some of the things the Ministry’s doing. Locking up Stan Shunpike, for instance.”<br>Scrimgeour did not speak for a moment but his expression hardened instantly. “I would not expect you to understand,” he said, and he was not as successful at keeping anger out of his voice as Harry had been. “These are dangerous times, and certain measures need to be taken. You are sixteen years old —“<br>“Dumbledore’s a lot older than sixteen, and he doesn’t think Stan should be in Azkaban either,” said Harry. “You’re making Stan a scapegoat, just like you want to make me a mascot.”<br>They looked at each other, long and hard. Finally Scrimgeour said, with no pretense at warmth, “I see. You prefer — like your hero, Dumbledore — to disassociate yourself from the Ministry?”<br>“I don’t want to be used,” said Harry.<br>“Some would say it’s your duty to be used by the Ministry!”<br>“Yeah, and others might say it’s your duty to check that people really are Death Eaters before you chuck them in prison,” said Harry, his temper rising now. “You’re doing what Barty Crouch  did. You never get it right, you people, do you? Either we’ve got Fudge, pretending everything’s lovely while people get murdered right under his nose, or we’ve got you, chucking the wrong people into jail and trying to pretend you’ve got ‘the Chosen One’ working for you!”<br>“So you’re not ‘the Chosen One’?” said Scrimgeour.<br>“I thought you said it didn’t matter either way?” said Harry, with a bitter laugh. “Not to you anyway.”<br>“I shouldn’t have said that,” said Scrimgeour quickly. “It was tactless —“<br>“No, it was honest,” said Harry. “One of the only honest things you’ve said to me. You don’t care whether I live or die, but you do care that I help you convince everyone you’re winning the war against Voldemort. I haven’t forgotten, Minister… .”<br>He raised his right fist. There, shining white on the back of his cold hand, were the scars which Dolores Umbridge had forced him to carve into his own flesh: I must not tell lies.<br>“I don’t remember you rushing to my defense when I was trying to tell everyone Voldemort was back. The Ministry wasn’t so keen to be pals last year.”<br>They stood in silence as icy as the ground beneath their feet. The gnome had finally managed to extricate his worm and was now sucking on it happily, leaning against the bottommost branches of the rhododendron bush.<br>“What is Dumbledore up to?” said Scrimgeour brusquely.<br>“Where does he go when he is absent from Hogwarts?”<br>“No idea,” said Harry.<br>“And you wouldn’t tell me if you knew,” said Scrimgeour, “would you?”<br>“No, I wouldn’t,” said Harry. </p><p>“Harry’s already Apparated,” Ron told a slightly abashed Seamus, after Professor Flitwick had dried himself off with a wave of his wand and set Seamus lines: “I am a wizard, not a baboon brandishing a stick.” “Dum — er — someone took him. Side-Along Apparition, you know.”</p><p>“He accused me of being ‘Dumbledore’s man through and through.’ “<br>“How very rude of him.”<br>“I told him I was.” </p><p>He raised his glass as though toasting Voldemort, whose face remained expressionless. Nevertheless, Harry felt the atmosphere in the room change subtly: Dumbledore’s refusal to use Voldemort’s chosen name was a refusal to allow Voldemort to dictate the terms of the meeting, and Harry could tell that Voldemort took it as such. </p><blockquote><p>“For the greater good”.</p></blockquote><p>“You call it ‘greatness,’ what you have been doing, do you?” asked Dumbledore delicately.<br>“Certainly,” said Voldemort, and his eyes seemed to burn red. “I have experimented; I have pushed the boundaries of magic further, perhaps, than they have ever been pushed —“<br>“Of some kinds of magic,” Dumbledore corrected him quietly. “Of some. Of others, you remain … forgive me … woefully ignorant.” </p><p>“I am glad to hear that you consider them friends,” said Dumbledore. “I was under the impression that they are more in the order of servants.”</p><p>“Let us speak openly. Why have you come here tonight, surrounded by henchmen, to request a job we both know you do not want?”<br>Voldemort looked coldly surprised. “A job I do not want? On the contrary, Dumbledore, I want it very much.”<br>“Oh, you want to come back to Hogwarts, but you do not want to teach any more than you wanted to when you were eighteen. What is it you’re after, Tom? Why not try an open request for once?”<br>Voldemort sneered. “If you do not want to give me a job —“<br>“Of course I don’t,” said Dumbledore. “And I don’t think for a moment you expected me to. Nevertheless, you came here, you asked, you must have had a purpose.” </p><blockquote><p>The most valuable thing of a man is braveness.</p></blockquote><p>“Of course, it doesn’t matter how he looks… . It’s not r-really important … but he was a very handsome little b-boy … always very handsome … and he was g-going to be married!”<br>“And what do you mean by zat?” said Fleur suddenly and loudly.<br>“What do you mean, ‘ ‘e was going to be married?’ “<br>Mrs. Weasley raised her tear-stained face, looking startled.<br>“Well — only that —“<br>“You theenk Bill will not wish to marry me anymore?” demanded Fleur. “You theenk, because of these bites, he will not love me?”<br>“No, that’s not what I —“<br>“Because ‘e will!” said Fleur, drawing herself up to her full height and throwing back her long mane of silver hair. “It would take more zan a werewolf to stop Bill loving me!”<br>“Well, yes, I’m sure,” said Mrs. Weasley, “but I thought perhaps — given how — how he —“<br>“You thought I would not weesh to marry him? Or per’aps, you hoped?” said Fleur, her nostrils flaring. “What do I care how he looks? I am good-looking enough for both of us, I theenk! All these scars show is zat my husband is brave! And I shall do zat!” she added fiercely, pushing Mrs. Weasley aside and snatching the ointment from her.<br>Mrs. Weasley fell back against her husband and watched Fleur mopping up Bill’s wounds with a most curious expression upon her face. Nobody said anything; Harry did not dare move. Like everybody else, he was waiting for the explosion.<br>“Our Great-Auntie Muriel,” said Mrs. Weasley after a long pause, “has a very beautiful tiara — goblin-made — which I am sure I could persuade her to lend you for the wedding. She is very fond of Bill, you know, and it would look lovely with your hair.”<br>“Thank you,” said Fleur stiffly. “I am sure zat will be lovely.”<br>And then, Harry did not quite see how it happened, both women were crying and hugging each other. Completely bewildered, wondering whether the world had gone mad, he turned around: Ron looked as stunned as he felt and Ginny and Hermione were exchanging startled looks. </p><p>Harry looked at Ginny, Ron, and Hermione: Ron’s face was screwed up as though the sunlight were blinding him. Hermione’s face was glazed with tears, but Ginny was no longer crying. She met Harry’s gaze with the same hard, blazing look that he had seen when she had hugged him after winning the Quidditch Cup in his absence, and he knew that at that moment they understood each other perfectly, and that when he told her what he was going to do now, she would not say, “Be careful,” or “Don’t do it,” but accept his decision, because she would not have expected anything less of him. And so he steeled himself to say what he had known he must say ever since Dumbledore had died.</p><h1 id="HP7"><a href="#HP7" class="headerlink" title="HP7"></a>HP7</h1><blockquote><p>“He must’ve known you’d always want to come back.”</p></blockquote><p>But I don’t think so, not anymore. He knew what he was doing when he gave me the Deluminator, didn’t he? He — well,” Ron’s ears turned bright red and he became engrossed in a tuft of grass at his feet, which he prodded with his toe, “he must’ve known I’d run out on you.”<br>“No,” Harry corrected him. “He must’ve known you’d always want to come back.” </p><p>“Yeah, well, I couldn’t ask people to go through what Michael did, so we dropped those kinds of stunts. But we were still fighting, doing underground stuff, right up until a couple of weeks ago. That’s when they decided there was only one way to stop me, I suppose, and they went for Gran.”<br>“They what?” said Harry, Ron, and Hermione together.<br>“Yeah,” said Neville, panting a little now, because the passage was climbing so steeply, “well, you can see their thinking. It had worked really well, kidnapping kids to force their relatives to behave, I s’pose it was only a matter of time before they did it the other way around. Thing was,” he faced them, and Harry was astonished to see that he was grinning, “they bit off a bit more than they could chew with Gran. Little old witch living alone, they probably thought they didn’t need to send anyone particularly powerful. Anyway,” Neville laughed, “Dawlish is still in St. Mungo’s and Gran’s on the run. She sent me a letter,” he clapped a hand to the breast pocket of his robes, “telling me she was proud of me, that I’m my parents’ son, and to keep it up.” </p><blockquote><p>This little episode shows Ron’s character traits vividly.<br>“Your mother can’t produce food out of thin air,” said Hermione. “No one can. Food is the first of the five Principal Exceptions to Gamp’s Law of Elemental Transfigur —“<br>“Oh, speak English, can”t you?” Ron said, prising a fish bone outfrom between his teeth. </p></blockquote><p>“Yeah, well, food’s one of the five exceptions to Gamp’s Law of Elemental Transfiguration,” said Ron to general astonishment. </p><p>“Why would Harry Potter try to get inside Ravenclaw Tower? Potter belongs in my House!”<br>Beneath the disbelief and anger, Harry heard a little strain of pride in her voice, and affection for Minerva McGonagall gushed up inside him. </p><p>“It’s not a case of what you’ll permit, Minerva McGonagall. Your time’s over. It’s us what’s in charge here now, and you’ll back me up or you’ll pay the price.” And he spat in her face.<br>Harry pulled the Cloak off himself, raised his wand, and said, “You shouldn’t have done that.”<br>As Amycus spun around, Harry shouted, “Crucio!” </p><p>“Potter, I — that was very — very gallant of you — but don’t you realize — ?”</p><p>There was a sound of movement, of clinking glass: Amycus was coming round. Before Harry or Luna could act, Professor McGonagall rose to her feet, pointed her wand at the groggy Death Eater, and said, “Imperio.” </p><p>The aged caretaker had just come hobbling into view, shouting, “Students out of bed! Students in the corridors!”<br>“They’re supposed to be, you blithering idiot!” shouted McGonagall. “Now go and do something constructive! Find Peeves!”</p><p>“I was a fool!” Percy roared, so loudly that Lupin nearly dropped his photograph. “I was an idiot, I was a pompous prat, I was a — a —“<br>“Ministry-loving, family-disowning, power-hungry moron,” said Fred.<br>Percy swallowed.<br>“Yes, I was!”<br>“Well, you can’t say fairer than that,” said Fred, holding out his hand to Percy.<br>Mrs. Weasley burst into tears. She ran forward, pushed Fred aside, and pulled Percy into a strangling hug, while he patted her on the back, his eyes on his father. </p><p>“Well, we do look to our prefects to take a lead at times such as these,” said George in a good imitation of Percy’s most pompous manner. “Now let’s get upstairs and fight, or all the good Death Eaters’ll be taken.”</p><p>“Karkaroff’s Mark is becoming darker too. He is panicking, he fears retribution; you know how much help he gave the Ministry after the Dark Lord fell.” Snape looked sideways at Dumbledore’s crooked-nosed profile. “Karkaroff intends to flee if the Mark burns.”<br>“Does he?” said Dumbledore softly, as Fleur Delacour and Roger Davies came giggling in from the grounds. “And are you tempted to join him?”<br>“No,” said Snape, his black eyes on Fleur’s and Roger’s retreating figures. “I am not such a coward.”<br>“No,” agreed Dumbledore. “You are a braver man by far than Igor Karkaroff. You know, I sometimes think we Sort too soon… .”</p><p>“I am sorry too,” said Lupin. “Sorry I will never know him … but he will know why I died and I hope he will understand. I was trying to make a world in which he could live a happier life.” </p><p>“Would I?” asked Dumbledore heavily. “I am not so sure. I had proven, as a very young man, that power was my weakness and my temptation. It is a curious thing, Harry, but perhaps those who are best suited to power are those who have never sought it. Those who, like you, have leadership thrust upon them, and take up the mantle because they must, and find to their own surprise that they wear it well. </p><p>At last he said, “Grindelwald tried to stop Voldemort going after the wand. He lied, you know, pretended he had never had it.”</p><p>“I’ve got to go back, haven’t I?”<br>“That is up to you.”<br>“I’ve got a choice?”<br>“Oh yes.” Dumbledore smiled at him. “We are in King’s Cross, you say? I think that if you decided not to go back, you would be able to … let’s say … board a train.”<br>“And where would it take me?”<br>“On,” said Dumbledore simply.<br>Silence again.<br>“Voldemort’s got the Elder Wand.”<br>“True. Voldemort has the Elder Wand.”<br>“But you want me to go back?”<br>“I think,” said Dumbledore, “that if you choose to return, there is a chance that he may be finished for good. I cannot promise it. But I know this, Harry, that you have less to fear from returning here than he does.”<br>Harry glanced again at the raw-looking thing that trembled and choked in the shadow beneath the distant chair.<br>“Do not pity the dead, Harry. Pity the living, and, above all, those who live without love. By returning, you may ensure that fewer souls are maimed, fewer families are torn apart. If that seems to you a worthy goal, then we say good-bye for the present.” </p><p>“Of course it is happening inside your head, Harry, but why on earth should that mean that it is not real?” </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;While rereading Harry Potter, I found these fragments are powerful or interesting.&lt;/p&gt;</summary>
    
    
    
    
    <category term="文学" scheme="http://www.calvinneo.com/tags/文学/"/>
    
    <category term="读书笔记" scheme="http://www.calvinneo.com/tags/读书笔记/"/>
    
  </entry>
  
  <entry>
    <title>Church 编码</title>
    <link href="http://www.calvinneo.com/2023/04/04/church-encoding/"/>
    <id>http://www.calvinneo.com/2023/04/04/church-encoding/</id>
    <published>2023-04-04T15:20:37.000Z</published>
    <updated>2023-04-10T13:53:40.059Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Church 编码和 Scott 编码。</p><a id="more"></a><p>邱奇数使用 lambda 构成的高阶函数来描述自然数。事实上邱奇编码可以用来描述一些很基本的结构，例如布尔值、元组、列表和 tagged unions。<br>可以将 0 表示为函数 zero 即 <code>\f x. x</code>。x 是什么并不重要，但我们可以将 f 令为 add1，将 x 令为 0。那么 0 就是 <code>zero(add1, 0) = 0</code>。<br>然后，可以将 1 表示为函数 one 即 <code>\f x. f x</code>。进行代换可以得到 <code>one(add1, 0) = add1(0)</code>。同理，将 2 表示为 <code>\f x. f (f x)</code>。<br>任意一个数 <code>n</code> 可以表示为<code>($) f^n x</code>，我们要想出一个结构实现把 <code>f</code> 执行 <code>n</code> 次，那实际上需要套一个递归的概念。下面来定义这个 Successor 函数 <code>s</code>。<br>递推函数 <code>s</code> 可以求出 <code>n</code> 的 Successor 为 <code>\n f x -&gt; f (($) n f x)</code>。检查类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :t s</span><br><span class="line">s :: ((t1 -&gt; t2) -&gt; t3 -&gt; t1) -&gt; (t1 -&gt; t2) -&gt; t3 -&gt; t2</span><br></pre></td></tr></table></figure><p>可以理解为 <code>s</code> 是接受一个函数 <code>n</code>，返回另一个和 <code>f</code>/<code>x</code> 有关的函数。不妨简单带入</p><ol><li><code>add1 (($) zero add1 0)</code> 为 1</li><li><code>add1 (($) one add1 0)</code> 为 2</li></ol><p>实现加法函数<code>plus(m, n) = m + n</code>，<code>plus = \m n f x. m f(n f x)</code>。这里用到了性质<code>f^(m+n) x = f^m f^n x</code>。<br>实现乘法函数<code>multi(m, n) = m * n</code>，<code>multi = \m n f x. m (n f) x</code>。相当于将 <code>n f</code> 应用 <code>m</code> 次在 <code>x</code> 上。而 <code>n f</code> 表示 <code>n</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add1</span> x = x + <span class="number">1</span></span><br><span class="line"><span class="title">shownat</span> n = ($) n add1 <span class="number">0</span></span><br><span class="line"><span class="title">zero</span> = \f x -&gt; x</span><br><span class="line"><span class="title">s</span> = \n f x -&gt; f (($) n f x)</span><br><span class="line"><span class="title">one</span> = s zero</span><br><span class="line"><span class="title">two</span> = s one</span><br><span class="line"><span class="title">three</span> = s two</span><br><span class="line"><span class="title">shownat</span> one</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> n m f x = ($) n f (($) m f x)</span><br><span class="line"><span class="title">multi</span> n m f = n (m f)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :t zero</span><br><span class="line">zero :: p1 -&gt; p2 -&gt; p2</span><br><span class="line">ghci&gt; :t one</span><br><span class="line">one :: (t1 -&gt; t2) -&gt; t1 -&gt; t2</span><br><span class="line">ghci&gt; :t two</span><br><span class="line">two :: (t3 -&gt; t3) -&gt; t3 -&gt; t3</span><br><span class="line">ghci&gt; :t three</span><br><span class="line">three :: (t3 -&gt; t3) -&gt; t3 -&gt; t3</span><br></pre></td></tr></table></figure><p>下面定义和 bool 量有关的函数。可以看到，true 就是传两个元素选择第一个，false 就是选择第二个。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">true</span> x y = x</span><br><span class="line"><span class="title">false</span> x y = y</span><br><span class="line"><span class="title">showbool</span> b = ($) b <span class="type">True</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><p>容易看出，通过 true 和 false，可以自然而然定义出 if-then-else 语义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ifte</span> pred x y = ($) pred x y</span><br></pre></td></tr></table></figure><p>下面定义 pair 结构。不同于一般编程中指定如何构造结构，这里的思路是定义如何去消费这个结构。这里可以传入一个 sel。sel 可以是 fst 和 snd，表示选出 a 或者 b。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pair</span> a b sel = ($) sel a b</span><br><span class="line"><span class="title">fst</span> p = p true</span><br><span class="line"><span class="title">snd</span> p = p false</span><br><span class="line"><span class="title">shownat</span> (fst (($) pair one two))</span><br></pre></td></tr></table></figure><p>这里有个小问题，写成 <code>pair a b sel = sel $ a b</code> 会有错误</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;interactive&gt;:<span class="number">28</span>:<span class="number">1</span>: error:</span><br><span class="line">    ? <span class="type">Non</span> <span class="class"><span class="keyword">type</span>-variable argument in the constraint: <span class="type">Num</span> (<span class="title">t3</span> -&gt; <span class="title">t3</span>)</span></span><br><span class="line">      (<span class="type">Use</span> <span class="type">FlexibleContexts</span> to permit this)</span><br><span class="line">    ? <span class="type">When</span> checking the inferred <span class="class"><span class="keyword">type</span></span></span><br><span class="line">        it :: <span class="keyword">forall</span> &#123;t3&#125;. <span class="type">Num</span> (t3 -&gt; t3) =&gt; t3 -&gt; t3</span><br></pre></td></tr></table></figure><p>下面定义 pair 上的函数 next。<code>(next (: pair a b))</code> 返回 <code>(: pair (s a) a)</code>，可以理解为 pair 上的 Successor。<br>思路很简单，新构造一个 pair，它的第二个元素是 <code>(fst p)</code>，第一个元素是 <code>s (fst p)</code>&gt;</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">next</span> p = ($) pair (s (fst p)) (fst p)</span><br><span class="line"><span class="title">nn_of_a</span> a = ($) fst (next (($) pair a a))</span><br><span class="line"><span class="title">shownat</span> $ nn_of_a one</span><br></pre></td></tr></table></figure><p>实现减法函数，首先先实现一个 pred 函数。它可以求出 n - 1 是什么。例如 <code>pred two</code> 是 <code>one</code>，但 <code>pred zero</code> 是 <code>zero</code>。这里的方案是从 <code>pair zero zero</code> 开始，调用 n 次 next，就可以得到 <code>(n, n - 1)</code>。使用 snd 返回就行。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pred</span> n = snd (($) n next (($) pair zero zero))</span><br></pre></td></tr></table></figure><p>减法函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sub</span> m n = ($) m (pred n)</span><br></pre></td></tr></table></figure><p>下面这个函数用来判断 n 是不是 0。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isZero</span> n = ($) n (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p>不妨进行代入来看看原理</p><ol><li><p>zero</p> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($) (\f x -&gt; x) (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p> 这里的 <code>f</code> 实际上就是 <code>(\x -&gt; false)</code>，而 x 就是 true。所以肯定是 true。</p></li><li><p>one</p> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($) (\f x -&gt; f x) (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p> 这里代入就是 <code>(\x -&gt; false) true</code>，即 false。</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">http://learnyouahaskell.com</a></li><li><a href="https://www.zhihu.com/question/19804597" target="_blank" rel="noopener">https://www.zhihu.com/question/19804597</a><br> Church 编码</li><li><a href="https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/lambda-calculus-2/index.html" target="_blank" rel="noopener">https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/lambda-calculus-2/index.html</a><br> Church 编码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Church 编码和 Scott 编码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="函数式" scheme="http://www.calvinneo.com/tags/函数式/"/>
    
    <category term="lambda" scheme="http://www.calvinneo.com/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>线性代数复习——以MIT18.06为指导(3)</title>
    <link href="http://www.calvinneo.com/2023/03/01/linear-alg-3/"/>
    <id>http://www.calvinneo.com/2023/03/01/linear-alg-3/</id>
    <published>2023-03-01T14:40:32.000Z</published>
    <updated>2023-04-11T15:02:44.814Z</updated>
    
    <content type="html"><![CDATA[<p>本文从<a href="https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&p=16" target="_blank" rel="noopener">MIT的线代教程</a>的角度重新学习线性代数。</p><p>这是第三部分，从 L26 开始。</p><a id="more"></a><h1 id="L26-对称矩阵和正定矩阵"><a href="#L26-对称矩阵和正定矩阵" class="headerlink" title="L26 对称矩阵和正定矩阵"></a>L26 对称矩阵和正定矩阵</h1><p>本章讲对称矩阵。<br>这里注意，因为对称矩阵不一定满秩，比如<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;1 \\<br>    1&amp;1<br>\end{bmatrix}<br>\end{equation}<br>$$<br>就不满秩。</p><p>首先介绍实对称矩阵，有两个特性：</p><ol><li>特征值都是实数</li><li>特征向量正交<br> 这里注意，如果出现重特征值，则可能一个平面中都是特征向量。所以这里说的是总能选出一套完全正交的特征向量。<br> 其实这里我不是很懂，投影矩阵是个什么样的例子呢？</li></ol><p>在 L22 已经讲过如何判断是否存在 n 个线性无关的特征向量了。现在假设存在，那么矩阵可以对角化为 $A = S \Lambda S^{-1}$。<br>对对称矩阵进行对角化，因为特征向量正交，所以 S 实际是正交矩阵，这里改写为 Q。因为 Q 是正交矩阵，根据正交矩阵的性质，有 $Q Q^T = I$，即 $Q^{-1} = Q^T$。所以有<br>所以可以得到下面的式子。<br>$$<br>A = Q \Lambda Q^{-1} = Q \Lambda Q^T<br>$$</p><p>上面的定理又被称为谱定理或者主轴定理。</p><p>在笔记上还写了一段<br><img src="/img/linalg/symmat_note.png"></p><hr><p>下面来证明为什么实对称矩阵的特征值都是实数。特别地，第二个性质教授说直接看课本就行。</p><p>首先他介绍了一个特性，其中 $\overline{c}$ 表示复数 c 的共轭。<br>$$<br>\overline{A} \overline{x} = \overline{\lambda} \overline{x}<br>$$</p><p>考虑上面的式子，可以得到<br>$$<br>\overline{x}^T \overline{A}^T = \overline{x}^T \overline{\lambda}<br>$$</p><p>考虑到 $\overline{A} = A$ 和 $A = A^T$ 可以得到<br>$$<br>\overline{x}^T A = \overline{x}^T \overline{\lambda}<br>$$</p><p>两边同时右乘 x 有<br>$$<br>\overline{x}^T A x = \overline{x}^T x \overline{\lambda}<br>$$</p><p>接下来考虑 $ A x = \lambda x$，两边同时左乘 $\overline{x}^T$ 有</p><p>$$<br>\overline{x}^T A x = \lambda \overline{x}^T x<br>$$</p><p>比较可得，$\overline{\lambda} = \lambda$ 或者 $\overline{x}^T A$ 为0。下面要证明后者不为0。<br>不妨展开看一下<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    \overline{x_1}&amp;…&amp;\overline{x_n}<br>\end{bmatrix}<br>\begin{bmatrix}<br>    \overline{x_1} \\<br>    … \\<br>    \overline{x_n}<br>\end{bmatrix}<br>\end{equation}<br>$$<br>其中每一个 $\overline{x_i} x_i$ 都可以看做是 $(a + bi)(a - bi)$，结果为复向量的模。只有当向量是0的时候，模才是0。</p><hr><p>特别地，如果 A 是复矩阵，那么要满足上面两个条件则需要 $ A = \overline{A}^T$。</p><hr><p>TODO</p><hr><p>下面介绍一个性质，也就是主元的符号和特征值的符号数量是匹配的。例如有 x 个主元为正，n - x 个主元为负，那么就有 x 个特征值为正，n - x 个特征值为负。</p><hr><p>正定矩阵是对称矩阵。它的所有特征值为正。所以它对应的微分方程是收敛的。</p><p>【Q】这里为什么要在对称矩阵上定义正定矩阵呢？</p><p>正定矩阵的主元都为正。</p><p>可以通过行列式判断是否是正定。如果 A 正定，则 $det(A) \gt 0$。但反之就未必，例如矩阵<br>$$<br>\begin{bmatrix}<br>    -1&amp;0 \\<br>    0&amp;-3 \\<br>\end{bmatrix}<br>$$</p><p>其实要所有的子行列式都为正才行。</p><h1 id="L27-复矩阵和快速傅里叶变换"><a href="#L27-复矩阵和快速傅里叶变换" class="headerlink" title="L27 复矩阵和快速傅里叶变换"></a>L27 复矩阵和快速傅里叶变换</h1><p>我们如何定义两个复向量正交呢？$z^T z = 0$ 可以么？不行。因为 $z^T z$ 是向量模长的平方，它应该是一个正数。但如果考虑<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;i<br>\end{bmatrix}<br>\begin{bmatrix}<br>    1 \\<br>    i \\<br>\end{bmatrix}<br>= 0<br>\end{equation}<br>$$<br>难道向量的长度为0？</p><p>实际上我们定义复向量 z 的模是 $\overline{z}^T z$，也可以写作 $z^H z$。这里的 H 表示埃尔米特(Hermitian)矩阵的意思。</p><hr><p>进行延伸，我们定义复矩阵中的“对称矩阵”。它被称作埃尔米特矩阵，定义为 $\overline{A}^T$ 即 $A^H$。它的特性是 $\overline{A}^T = A$。</p><p>下面的例子是一个埃尔米特矩阵，可以发现主对角线上一定都是实数，主对角线两边的元素“共轭对称”。<br>$$<br>\begin{bmatrix}<br>    2&amp;3+i \\<br>    3-i&amp;5 \\<br>\end{bmatrix}<br>$$</p><p>埃尔米特矩阵具有实数特征值和正交的特性向量，这个应该是从对称矩阵上类比得到的，教授在上节课证明的时候已经带过了。</p><hr><p>类似地，我们定义对应于“正交矩阵”的概念即酉矩阵。</p><p>假如 $q_1$、$q_2$、……、$q_n$ 彼此标准正交，即<br>$$<br>\begin{equation}<br>\overline{q_i}^T q_i =<br>\left\{<br>    \begin{array}{lr}<br>    0, \quad i\ne j \\<br>    1, \quad i=j<br>    \end{array}<br>\right.<br>\end{equation}<br>$$</p><p>可以得到 $Q^H Q = I$，这里 $Q^H$ 就是酉矩阵。</p><hr><p>求逆方便的原因是 $F_4^H F = I$，所以逆就是共轭转置。</p><p>容易想到 $F_{64}$ 和 $F_{32}$ 之间可能有联系。在 $F_{64}$ 中，w 是 1 的 64 次方根，不妨记作 $w_{64}$。可以发现 $w_{64}^2 = w_{32}$。</p><p>如何建立 $F_{64}$ 和 $F_{32}$ 之间的联系呢？不妨考虑下面的式子，$F_{64}$ 被拆成两个 $F_{32}$ 组合起来很稀疏的矩阵。<br>$$<br>\begin{equation}<br>F_{64} =<br>X<br>\begin{bmatrix}<br>    F_{32}&amp;0 \\<br>    0&amp;F_{32}<br>\end{bmatrix}<br>P<br>\end{equation}<br>$$</p><p>当然，整个式子要乘上 X 和 Y 才能成立。</p><p>这里的 Y 是一个奇偶置换矩阵，如下所示。从矩阵乘法的第四种方法可以看出。</p><p>而 X 是一个<br>$$<br>\begin{bmatrix}<br>    I&amp;D \\<br>    I&amp;-D<br>\end{bmatrix}<br>$$</p><p>其中 D 是对角矩阵，对角线上的值为从 $w^0$ 到 $w^{32}$。</p><p>建立上面联系的目的是什么呢？比如如果要做傅里叶变换，那么就要用 $F_{64}$ 乘以某个向量，这是 $64^2$ 的复杂度。但经过上面的分解，我们只需要 $2*32^2 + 32$ 即可。</p><p>还可以从 32 继续分解为 16/8/4/2/1。最终中间的矩阵越来越简单，但两侧会补上很多的修正矩阵。</p><h1 id="L28-正定矩阵和最小值"><a href="#L28-正定矩阵和最小值" class="headerlink" title="L28 正定矩阵和最小值"></a>L28 正定矩阵和最小值</h1><p>首先是复习上上节课介绍的正定性的判断方法。主要分为：</p><ol><li>特征值法</li><li>行列式法</li><li>主元法<br> 这里需要注意之前讲的一个性质，也就是主元的积等于行列式的值。</li><li>$x^T A x \gt 0$，实际上一般这才是定义<br> 注意，这里是不是要把原点扣掉？因为令 x 为零向量，那么肯定是等于0的啊？</li></ol><hr><p>下面教授举了几个例子。</p><p>[2 6; 6 18] 是一个半正定矩阵。因为它是奇异矩阵，所以有一个特征值为0，只有一个主元。半正定矩阵的特征值大于等于0。</p><p>而 [2 6; 6 7]就是不定矩阵，它实际上是一个马鞍面。</p><p>[2 6; 6 20]是正定矩阵。</p><hr><p>从微积分的角度来看，极小值点满足一阶导数为零，且二阶导数为正。这里教授说的是 minimum，不知道翻译成啥。</p><p>从线性代数中，f(x1, x2, … xn) 存在极小值的条件是二阶导数矩阵是正定的。</p><hr><p>事实上对 [2 6; 6 20] 进行配方，得到的是 $2(x + 3y)^2 + 2y^2$，它的图像是一个碗形。它的某个截面是椭圆，其实可以从椭圆的方程就能看出来了。</p><hr><p>其实配方法就是矩阵消元，可以从矩阵消元得到。<br>例如我们将矩阵 [2 6; 6 20] 进行 LU 分解。显然 U 是 [2 6; 0 2]。因为我们是用第二行减去了第一行的三倍，所以 L 是 [1 0; 3 1]，也就是加回来。</p><hr><p>什么是二阶导数矩阵呢？</p><p>其中 $f_{xx}$ 和 $f_{yy}$ 必须为正，才有最小值。并且还需要足够大以抵消混合导数的影响。<br>$$<br>\begin{bmatrix}<br>    f_{xx}&amp;f_{xy} \\<br>    f_{yx}&amp;f_{yy}<br>\end{bmatrix}<br>$$</p><p>这里 $f_{xy} = f_{yx}$，所以也能看出为什么二阶导数矩阵是对称的了。</p><p>TODO</p><h1 id="L29-相似矩阵和若尔当标准型"><a href="#L29-相似矩阵和若尔当标准型" class="headerlink" title="L29 相似矩阵和若尔当标准型"></a>L29 相似矩阵和若尔当标准型</h1><p>正定矩阵从何而来？它实际上来自于最小二乘法。不放先复习下，这里的 A 是一个长方形矩阵。<br>$$<br>\hat{x} = (A^T A)^{-1} A^T b<br>$$</p><p>我们要研究在什么情况下 $A^T A$ 是正定的。</p><p>先来想一想，正定矩阵肯定是对称的。正定矩阵的逆矩阵一定也是正定的，判断正定性有四种做法，$x^T A x \gt 0$、主元、特征值、子行列式。我们知道逆矩阵的特征值是倒数，那么不影响正负号。这里补充下，对称矩阵的逆矩阵也是对称的，可以由很早之前证明的 $(A^{-1})^T = (A^T)^{-1}$ 得到。</p><p>如果 A 和 B 都是正定矩阵，那么 A + B 是正定矩阵。这个可以从第一种判定办法得到。</p><p>回到一开始的问题，也就是什么情况下 m 行 n 列的长方形矩阵 $A$，有 $A^T A$ 是正定的。直觉上来看，它像是一个数的平方，肯定大于等于0，但矩阵中是否这样呢？</p><p>我们选用第一种判定办法来研究。也就是证明 $x^T A^T A x$ 大于0。即要证明 $(A x)^T A x \gt 0$，而 $A x$ 是个向量，向量的模是大于等于0的，并且等号只在零向量取得。那么什么时候 $A x$ 为 0 呢，或者更有用的是反过来，如何保证 $A x$ 不为0呢？这样我们就取不到等号了。这个也就是在问什么时候 A 的零空间里面只有零向量，这个很简单，满秩的情况下。也就是说如果 A 满秩，那么 $A^T A$ 正定。</p><p>现在已经很接近最后的核心内容，正定性将之前的东西联系起来。</p><hr><p>现在我们不再讨论对称阵了，而是普通的方阵。</p><p>A 和 B 是相似的，则存在某个可逆矩阵 M，有 $B = M^{-1} A M$。这个式子有什么意义？其实先前在对角化的时候就已经见到过。$S^{-1} A S = \Lambda$ 可以描述为 A 和 $\Lambda$ 相似。</p><p>【Q】其实我觉得这里只要 M 可逆就行了。</p><p>但如果我们不取特征向量矩阵 S，而是取另一个 M，同样可以得到另一个相似矩阵 B。所以所有的相似矩阵可以划为一类，并可以由其中最好的矩阵 $\Lambda$ 来代表。</p><p>例如考虑 [2 1; 1 2]，它的特征值矩阵 $\Lambda$ 是 [3 0; 0 1]。但我们也可以取另一个可逆矩阵 M = [1 4; 0 1]，它是上三角矩阵，可以轻松算到逆矩阵是 [1 -4; 0 1]，通过 M 可以得到另一个相似矩阵。总而言之，下面的几个矩阵都是相似矩阵，可以从特征值来验证。</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    1&amp;2<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    3&amp;0 \\<br>    0&amp;1<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    3&amp;7 \\<br>    0&amp;1<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    1&amp;7 \\<br>    0&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>所有的相似矩阵的特征值是相同的。可以给出如下的证明：<br>$$<br>A x = \lambda x \\<br>A M M^{-1} x = \lambda x \\<br>M^{-1} A M M^{-1} x = M^{-1} \lambda x \\<br>B M^{-1} x = M^{-1} \lambda x<br>$$</p><p>因此这些矩阵都具有特征值 $\lambda$。但对应的特征向量则未必一样，为 $M^{-1} x$。</p><p>【Q】不妨考虑这个问题，如果两个矩阵的特征向量都相同，那么这两个矩阵一定相同么？答案不是，可以考虑</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    1&amp;2<br>\end{bmatrix}<br>\begin{bmatrix}<br>    3&amp;2 \\<br>    2&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(np.array([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]]))</span><br><span class="line">(array([<span class="number">3.</span>, <span class="number">1.</span>]), array([[ <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>],</span><br><span class="line">       [ <span class="number">0.70710678</span>,  <span class="number">0.70710678</span>]]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(np.array([[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]]))</span><br><span class="line">(array([<span class="number">5.</span>, <span class="number">1.</span>]), array([[ <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>],</span><br><span class="line">       [ <span class="number">0.70710678</span>,  <span class="number">0.70710678</span>]]))</span><br></pre></td></tr></table></figure><p>如果两个矩阵的特征值和特征向量都相同呢？这两个矩阵也不一定相同，可以考虑<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    0&amp;2<br>\end{bmatrix}<br>\begin{bmatrix}<br>    2&amp;0 \\<br>    1&amp;2<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>下面介绍一些比较难的情况。首先是有重特征值的情况，这意味着特征向量未必是线性无关的了，当然还是有可能线性无关的。但如果不存在 n 个线性无关的特征向量，那么就不能对角化。<br>假设有重特征值4，可以分为下面的情况：<br>第一种如下，和单位矩阵相关<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    4&amp;0 \\<br>    0&amp;4<br>\end{bmatrix}<br>\end{equation}<br>$$<br>对于这种矩阵 $M^{-1} A M = A = 4I$。</p><p>所有其他的矩阵类似于<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    4&amp;1 \\<br>    0&amp;4<br>\end{bmatrix}<br>\end{equation}<br>$$<br>不同于上面的单位矩阵，这是一个不可对角化的矩阵。这里可以看出，矩阵经过初等变换之后，可能从原来的可对角化变成不可对角化了。<br>这样的矩阵称为若尔当标准型。</p><p>不是所有的矩阵都可以很容易被变成若尔当标准型，因为这需要特征值严格相等。而在数值计算中，一个值些微的变化就能导致特征值变化甚至秩的变化。所以计算若尔当标准型很不友好。</p><p>下面的矩阵也拥有特征值4和4，所以<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    5&amp;1 \\<br>    -1&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>下面的矩阵的四个特征向量都是0，秩为2，有两个线性无关的特征向量。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    0&amp;1&amp;0&amp;0 \\<br>    0&amp;0&amp;1&amp;0 \\<br>    0&amp;0&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;0<br>\end{bmatrix}<br>\end{equation}<br>$$<br>下面的矩阵也一样<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    0&amp;1&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;1 \\<br>    0&amp;0&amp;0&amp;0<br>\end{bmatrix}<br>\end{equation}<br>$$<br>但这两个矩阵不是相似矩阵，从它们有不同的若尔当块可以看出。</p><p>若尔当块如下，主对角线上是重特征值 $\lambda_i$，上方对角线都是1，其他位置的元素都是0。每个若尔当块只有一个特征向量，多个若尔当块可以拼成一个若尔当矩阵。<br><img src="/img/linalg/jordanblock.png"></p><p>教授说，第一个矩阵上面 3x3 是一个若尔当块，下面 1x1 是一个若尔当块。我不是很明白，因为上面 3x3 不是有两个特征向量么？其实我搞错了，特征向量对应的是 $ A - \lambda I$ 的零空间而不是列空间。</p><hr><p>若尔当的理论是，每个方阵 A 和某个若尔当矩阵 J 相似。而这个若尔当矩阵中的块的数量是特征向量的数量。</p><p>而对于比较好的情况，也就是有不同的特征值，那么若尔当矩阵就是对角阵 $\Lambda$。也就是说若尔当块只是比对角矩阵多了对角线上方的一些1，这已经是最优的了。</p><hr><p>这里补充下几何重数和代数重数。<br>代数重数：也就是矩阵特征多项式中，某个解也就是特征值的重数。<br><img src="/img/linalg/tzdxs.webp"></p><p>几何重数：矩阵某个特征值对应的特征空间的维度。也就是 $A-\lambda I$ 的零空间的维度。</p><h1 id="L30-奇异值分解-SVD"><a href="#L30-奇异值分解-SVD" class="headerlink" title="L30 奇异值分解(SVD)"></a>L30 奇异值分解(SVD)</h1><p>这是线性代数的核心部分。是矩阵最终和最好的分解。</p><p>一个矩阵会被分解为一个正交矩阵 $U$，一个对角矩阵 $\Sigma$ 和一个正交矩阵 $V$ 的乘积。即 $A = U \Sigma V^T$。<br>首先介绍两个特殊情况：</p><ol><li>A 是正定矩阵，那么 A 可以被分解为 $Q A Q^T$<br> 在第 L26 课中讲过，实对称矩阵的特征向量是正交的。</li><li>A 可对角化，那么 A 可以被分解为 $ S A S^{-1}$<br> 但需要注意，这里的正交向量矩阵 S 未必是正交的。</li></ol><p>如何做到呢？我们可以在行空间找某个 $v_1$，它变换到列空间里是 $ u_1 = A v_1$。在奇异值分解中，找的是行空间里面的一组正交基，变换到列空间里面的一组正交基上。<br>此外，零空间上的向量对应了对角矩阵对角线上为0的元素。<br><img src="/img/linalg/svd.png"></p><p>首先，通过施密特正交化，可以将行空间的一组基转化为一组正交基。但并不是所有的正交基在变换后都还是正交的，所以要找特殊的一组正交基。</p><p>这里的 r 表示矩阵的秩。如果加上零空间的部分，则有 $A V = U \Sigma$。其中零空间对应的正交基是 $v_{r+1} , …, v_n$。<br><img src="/img/linalg/svd_core.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/470026382" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/470026382</a><br> 几何重数和代数重数</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文从&lt;a href=&quot;https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&amp;p=16&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MIT的线代教程&lt;/a&gt;的角度重新学习线性代数。&lt;/p&gt;
&lt;p&gt;这是第三部分，从 L26 开始。&lt;/p&gt;</summary>
    
    
    
    
    <category term="公开课" scheme="http://www.calvinneo.com/tags/公开课/"/>
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
    <category term="代数" scheme="http://www.calvinneo.com/tags/代数/"/>
    
    <category term="线性代数" scheme="http://www.calvinneo.com/tags/线性代数/"/>
    
  </entry>
  
  <entry>
    <title>线性代数复习——以MIT18.06为指导(2)</title>
    <link href="http://www.calvinneo.com/2023/02/16/linear-alg-2/"/>
    <id>http://www.calvinneo.com/2023/02/16/linear-alg-2/</id>
    <published>2023-02-16T14:40:32.000Z</published>
    <updated>2023-04-02T13:06:24.336Z</updated>
    
    <content type="html"><![CDATA[<p>本文从<a href="https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&p=16" target="_blank" rel="noopener">MIT的线代教程</a>的角度重新学习线性代数。</p><p>这是第二部分，从 L14 开始。</p><p><img src="/img/linalg/mitbad.png"></p><a id="more"></a><h1 id="L14-正交向量和子空间"><a href="#L14-正交向量和子空间" class="headerlink" title="L14 正交向量和子空间"></a>L14 正交向量和子空间</h1><p>这张图其实在四个子空间那一节课已经展示了，但当时我没有搞明白，为什么这四个空间的位置这么诡异。因为这4个空间两两正交。<br><img src="/img/linalg/4space.png"></p><hr><p>正交(orthogonal)向量 $x$、$y$ 满足 $x^T y = 0$。可以用它证明勾股定理即 $ |x|^2 + |y|^2 = |x+y|^2 $。注意这里向量点乘，所以 $x^T y = y^T x$。</p><p>根据定义，零向量和所有向量正交。</p><hr><p>两个子空间正交是什么意思呢？即 A 中的所有向量，和 B 中的所有向量正交。考虑教室作为一个三维空间，墙上的向量和地板上的向量未必正交。或者其实考虑 $ [1,1,0]$ 和 $[1,0,1]$ 即可。或者考虑踢脚线的那个向量，它同时处于两个空间中，肯定不会自己和自己正交。</p><p>所以如果两个空间正交，它们的交集一定不会是某个非零向量。当然这不是充分的。</p><hr><p>证明行空间和零空间正交。</p><p>不如把 A 写完整。可以看到每一行 $r_i$ 乘上 $x$ 都为 0。<br>$$<br>Ax = 0 \\<br>\Leftrightarrow \\<br>\begin{equation}<br>\begin{bmatrix}<br>    r_1 \\<br>    r_2 \\<br>    … \\<br>    r_m \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    x_1 \\<br>    x_2 \\<br>    … \\<br>    x_m \\<br>\end{bmatrix}<br>= 0<br>\end{equation}<br>$$</p><p>然后我们证明这些行的线性组合，和 $x$ 正交。这是肯定的。</p><hr><p>那么它们可能是什么呢？考虑 $R^3$，行空间和零空间不可能是两条直线，因为维度加起来不对。其实我们可以考虑是一条线和一个面的正交。</p><p>可以看出，行空间和零空间“划分”整个 $R^m$。这称为 $m$ 维空间里的正交补。也就是说行空间包含了所有和零空间垂直的向量。</p><hr><p>如何求一个无解方程组的解？这里指的是 $m$ 很大的时候。比如进行很多次测量，里面存在各种噪声，方程组大概率无解。所以我们要采取比如最小二乘法的技巧来“拟合”。</p><p>如果 $A$ 是 $m$ 行 $n$ 列 的矩阵，则 $A^T A$ 有一些很好的特性：</p><ol><li>它是方阵</li><li>它是对称矩阵<br> 这是因为 $ (A^T A)^T = A^T A $</li></ol><p>所以当我们发现 $ A x = b$ 无解时，两边乘以 $A^T$ 就会得到一个“好”的方程 $ A^T A \hat {x} = A^T x$。</p><hr><p>现在考虑 $A^T A$什么时候是可逆的呢？<br>首先这个矩阵未必可逆，比如零矩阵，比如下面这个 $A$<br>$$<br>\begin{bmatrix}<br>    1&amp;3 \\<br>    1&amp;3 \\<br>    1&amp;3 \\<br>\end{bmatrix}<br>$$</p><p>事实上 $N(A^T A)=N(A)$，且 $r(A^T A) = r(A)$。为什么呢？关于这个性质，在 L16 最后会进行证明，这里不妨假设它是对的。</p><p><img src="/img/linalg/bthz.png"></p><p>所以 $N(A^T A)$ 可逆，当且仅当 $A$ 的各列线性无关，这样零空间就是0维的了。</p><h1 id="L15-子空间投影"><a href="#L15-子空间投影" class="headerlink" title="L15 子空间投影"></a>L15 子空间投影</h1><p>向量 $b$ 和它在向量 $a$ 上的投影 $p$ 正交。如果我们将 $p$ 视为 $b$ 的近似，那么 $e = b - p$ 就是这近似的误差。这里 $p$ 是 $a$ 的某个倍数，即 $p = x a$。<br><img src="/img/linalg/projection_error.png"></p><p>$e$ 等于 $b - x a$。整理一下上面的关系，有<br>$$<br>a^T (b - x a) = 0<br>$$</p><p>化简一下，可以求得 $x$</p><p>$$<br>x a^T a = a^T b \\<br>x = \frac{a^T b}{a^T a}<br>$$</p><p>投影 p 就是<br>$$<br>p = a \frac{a^T b}{a^T a}<br>$$</p><hr><p>投影矩阵 P，上面一行是一个矩阵(列乘以行)，下面一行是一个数。投影矩阵 P 作用于 b，得到 b 向量在 a 上的投影。<br>$$<br>P = \frac{a a^T}{a^T a} \\<br>p = P b<br>$$</p><p>看看这个矩阵的列空间，先想想几何意义。因为 $P$ 是投影矩阵，它就是要投到 $a$ 这根向量上。所以 $P$ 的列空间就是通过 $a$ 的一条直线。所以 $P$ 的秩是1。</p><p>其实根据上节课末尾介绍的 $r(A^T A) = r(A)$，可以知道分式上面的 $ a a^T $ 的秩就是 $a$ 的秩是1，下面是一个常数。</p><p>这个矩阵是对称的么？是的，因为 $ a a^T $ 是对称的。</p><p>还能发现，投影两次是自己，即 $ P^2 = P$。</p><hr><p>下面来看在更高维，比如 $R^3$ 上投影。现在 $b$ 不是在 $a$ 上投影，而是在 $A$ 上投影了。</p><p>为什么要投影呢？因为 $Ax = b$ 无解，也就是说 $b$ 不一定在 $A$ 的列空间中。所以我们就退而求其次，求 $A \hat{x} = p$。也就是求 $b$ 在 $A$ 列空间上的投影。</p><p>这里的 $e$ 向量是垂直于平面的了。</p><p><img src="/img/linalg/proj_3d.png"></p><p>此时我们的投影是</p><p>$$<br>p = \hat{x}_1 a_1 + \hat{x}_2 a_2 = A \hat{x}<br>$$</p><p>因为 e 垂直于由 $a_1$ 和 $a_2$ 构成的平面，可以表示为 $b - A \hat{x}$，所以可以得到两个方程<br>$$<br>a_1^T (b - A \hat{x}) = 0 \\<br>a_2^T (b - A \hat{x}) = 0 \\<br>\Leftrightarrow \\<br>A^T (b - A \hat{x}) = 0<br>\Leftrightarrow \\<br>A^T A \hat{x} = A^T b<br>$$</p><p>这个方程看上去和二维的有点出入，但其实你把二维里面的 $a$ 看做是 $A$ 就对的上了。这个式子铭记在心，它很重要。</p><p>$e$ 在 $A^T$ 的零空间中，也就是说 $e$ 垂直于 $A$ 的列空间。其实我觉得从图上就能看出来吧……</p><hr><p>现在不妨讨论下方程的解<br>$$<br>\hat{x} = (A^T A)^{-1} A^T b<br>$$</p><p>投影 $p$ 就是<br>$$<br>p = A \hat{x} = A (A^T A)^{-1} A^T b<br>$$</p><p>形式上很像 </p><p>$$<br>\frac{a a^T}{a^T a}<br>$$</p><p>我们能简化为 $ P = A A^{-1} (A^T)^{-1} A^T $，结果居然是 $I$。这肯定有问题，可是哪里有问题呢？教授说因为 $A$ 不是方阵。所以我们不能直接写成分式，即下面未必成立</p><p>$$<br>p = \frac{A A^T}{A^T A} b<br>$$</p><p>而如果 $A$ 是一个可逆的方阵，那么列空间是整个 $R^m$，而投影矩阵确实就是单位阵。</p><p>同理，$ P $ 也是对称阵。<br>$ P^2 = P$，写出来可以发现中间可以消掉。</p><hr><p><img src="/img/linalg/ls.png"></p><p>最小二乘求得是 $ A^T A \hat{x} = A^T b$。这个方程之前介绍过，说的是 $e$ 和 $A$ 的列空间正交。</p><h1 id="L16-投影矩阵和最小二乘"><a href="#L16-投影矩阵和最小二乘" class="headerlink" title="L16 投影矩阵和最小二乘"></a>L16 投影矩阵和最小二乘</h1><p>如果 $b$ 垂直于列空间，则 $P b = 0$。因为 $A^T b = 0$。<br>如果 $b$ 属于列空间，则 $P b = b$。将 $Ax$ 带入，发现等于 $b$。</p><p>所以这里有点向量分解的意思。已经知道投到列空间的向量是 $P b$，那么投到左零空间的向量是 $(I - P) b$。<br><img src="/img/linalg/xlfj.png"></p><hr><p>回到最小二乘，我们要最小化的是 $ | Ax - b |^2 $，因为 $Ax - b = e$，所以也就是最小化 $e^2$。对这个有疑问的，可以多去看一下二维的情况。</p><p>最小二乘很容易受到离群点的影响，因为这个离群点会导致误差的平方非常大。</p><p>如下图所示，如果我们不是把 b1、b2、b3 放入方程，而是将 p1、p2、p3 放入方程，则好处是方程是有解的。并且我们也能发现它们确实是“最近”的。而我们要最小化的是 $e1^2 + e2^2 + e3^2$。<br><img src="/img/linalg/peb.png"></p><p>现在我们求<br>$$<br>\begin{equation}<br>\hat{x} =<br>\begin{bmatrix}<br>    \hat{C} \\<br>    \hat{D} \\<br>\end{bmatrix}<br>\end{equation}<br>$$<br>以及 $p$。</p><p>$\hat{x}$ 是什么呢？之前说过是<br>$$<br>A^T A \hat{x} = A^T b<br>$$</p><p>下面这种图中对这个方程进行了化简，最后得到右边的矩阵<br><img src="/img/linalg/solve-linear.png"></p><p>那么解就是下面的方程组<br>$$<br>3C + 6D = 5 \\<br>6C + 14D = 11 \\<br>$$</p><p>可以用分析的办法来解决，即考虑最小化 $e1^2 + e2^2 + e3^2$。分别对 $C$ 和 $D$ 求偏导数，可以同样得到上面两个方程。</p><p>最后我们求出 $b = p + e$，可以发现 $e$ 和 $p$ 互相垂直。<br><img src="/img/linalg/bpe.png"></p><hr><p>填坑，证明如果 $A$ 各列线性无关，则 $A^T A$ 可逆。</p><p>只需要证明如果 $A^T A x = 0$，则 $x = 0$。因为在 L09 讲过，如果矩阵可逆，那么它的零空间只有0。</p><p>第一种办法，是两边都左乘 $x^T$，得到 $ x^T A^T A x = 0$。其实就是 $(Ax)^T (Ax) = 0$，很有趣。而如果 $y^T y = 0$，说明 $y$ 是零向量，因为这个表示向量长度的平方。</p><p>【Q】如果这里 $A$ 是矩阵，$A^T A = 0$，是什么性质呢？A 也是0，可以看下<a href="https://math.stackexchange.com/questions/1044527/prove-that-aat-0-implies-a-0" target="_blank" rel="noopener">这个证明</a>。这个证明引入的符号也很实用。</p><p>上面得到 $Ax = $，因为 $A$ 各列线性无关，所以 $x$ 一定是零向量。</p><hr><p>下节课的预告：相互垂直的向量一定线性无关。</p><h1 id="L17-正交矩阵和施密特正交化"><a href="#L17-正交矩阵和施密特正交化" class="headerlink" title="L17 正交矩阵和施密特正交化"></a>L17 正交矩阵和施密特正交化</h1><p>首先定义正交向量 $q_i$ 和 $q_j$，如果 $ i \ne j$ 则 $q^T_i q_j = 0$，如果 $ i = j$ 则 $ q^T_i q_j = 1 $。我觉得这个 0 表明了正交，1 表明了标准。</p><p>下面教授证明性质如果 Q 的列向量为标准正交向量，则 $ Q^T Q = I$ 为单位阵。</p><p>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    q_1&amp;q_2&amp;x&amp;q_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>$$<br>Q^T Q =<br>\begin{equation}<br>\begin{bmatrix}<br>    q_1 \\<br>    q_2 \\<br>    x \\<br>    q_n \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    q_1&amp;q_2&amp;x&amp;q_n \\<br>\end{bmatrix}<br>= I<br>\end{equation}<br>$$</p><p>教授说，尽管这个性质对非方阵也有效，但仅<strong>方阵并且标准正交</strong>的情况下，我们才会将它称为正交矩阵。</p><hr><p>下面举例说明正交矩阵的定义。</p><p>例如下面的置换矩阵是正交矩阵。其实我想，根据上面的性质，可以知道如果 Q 还是方阵，则 $ Q^T = Q^{-1}$。而正交矩阵 P 也满足这个关系，所以很容易想到它是正交矩阵。<br>$$<br>\begin{equation}<br>P =<br>\begin{bmatrix}<br>    0&amp;0&amp;1 \\<br>    1&amp;0&amp;0 \\<br>    0&amp;1&amp;0 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>同理，下面这个矩阵也是正交矩阵，因为它的的两个列向量都是单位向量。<br>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    cos\theta&amp;-sin\theta \\<br>    sin\theta&amp;cos\theta \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>下面这个矩阵的列向量正交，但因为列向量不是单位向量，所以不是正交矩阵<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;1 \\<br>    1&amp;-1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>后面还介绍了 Hadamard 矩阵，略了。</p><hr><p>下面的矩阵的列向量是标准正交的，但它不是方阵，所以不是正交矩阵，但我们可以拓展它成为正交矩阵。<br>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    1&amp;-2 \\<br>    2&amp;-1 \\<br>    2&amp;2 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>我们之前已经介绍过了，如果 Q 的列向量是标准正交向量，但 Q 未必是方阵，则投影到 Q 的列空间的投影矩阵为</p><p>$$<br>P = Q (Q^T Q)^{-1} Q^T<br>$$</p><p>因为标准正交，所以有 $Q^T Q = I$。即 $ P = Q Q^T$。</p><p>其实当时学到这我就有疑问，为啥 $ Q Q^T$ 不能也是 I，后来才发现不一定是方阵……不过如果 $Q$ 确实是方阵，那么 $ Q^ Q = I$，即 $P$ 就是单位阵了。因为 $Q$ 的列向量张成了整个空间，所以投影过程不会对向量有任何改变。</p><hr><p>正规方阵 $Q$ 可以之前讲过的所谓“线性代数基本方程”即 $A^T A \hat{x} = A^T b$ 进行简化。也就是说，如果 $A$ 是 $Q$，那么 $ \hat{x} = Q^T b$。即 $\hat{x_i}=q_i^T b$。</p><hr><p>下面介绍施密特正交化，教授吐槽了下这个东西居然还能两个人冠名。</p><p>首先施密特说，一个正交基除以自己的长度得到标准正交基，即<br>$$<br>q_1 = \frac{A}{|A|}<br>$$</p><p>然后就是如何求得正交，其实从下面的图中就可以看出，前面讲的 b 和 A 的误差 e 就是正交基。</p><p><img src="/img/linalg/gcmethod.png"></p><p>即 $ B = b - \frac{A^T b}{A^T A} A$。其实这里我很困惑，不应该是 $ B = b - A(A^T A)^{-1} A^T b$ 么？搞了半天，原来这里的 A 和 B 啥的都是向量而不是矩阵……所以这里能直接用分式除也是这个原因。哈哈，想到 Artin 书里面直接写不要写成分式，就挺好笑，MIT 老师的风格都好不一样。</p><p>我们可以验证正交性。<br>$$<br>A^T B = A^T (b - \frac{A^T b}{A^T A} A)<br>$$<br>教授的意思是可以像这样提出来 $A^T b$。不知道这里为啥可以分配，可能是我瞎猜的<br>$$<br>A^T b = A^T (I - \frac{A^T A}{A^T A}) = 0<br>$$</p><hr><p>最后，教授又将 Q 和 LU 分解联系起来。他说 $A = Q R$，R 就是行最简阶梯矩阵，randomwalk 的笔记说可以放宽到上三角矩阵。</p><p>他说下面的式子中，$a_1^T q_2$是0。因为 $q_2$ 和 $a_1$ 垂直。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a_1&amp;a_2 \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    q_1&amp;q_2 \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    a_1^T q_1&amp;a_2^T q_1 \\<br>    a_1^T q_2&amp;a_2^T q_2 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><h1 id="L18-行列式和它的性质"><a href="#L18-行列式和它的性质" class="headerlink" title="L18 行列式和它的性质"></a>L18 行列式和它的性质</h1><p>开始着重介绍方阵。首先介绍行列式，它的作用是引出后面的特征值。</p><p>行列式中包含了很多有关这个矩阵的信息，例如可逆矩阵的行列式不是0，奇异矩阵的行列式是0。</p><hr><p>首先介绍三个行列式的性质，通过下面这三个性质，我们可以定义出所有矩阵的行列式<br>第一个性质说，$det(I) = 1$。<br>第二个性质说，行交换导致行列式符号相反。通过行交换，我们可以得到所有的置换矩阵。容易知道 $det(P)= \pm 1$。<br>第3a个性质说，行列式的一行中的每个元素都乘上一个 t，则行列式的值就会乘上一个 t。<br>第3b个性质说，行列式可以对某一行进行线性组合，听起来很怪，不如直接看下面的性质。同时注意，教授不是在说 $det(A+B)=det(A)+det(B)$。<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a + a’&amp;b + b’ \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    a’&amp;b’ \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>听到这里，我不禁点了暂停进行了验证，确实通过三个性质推出所有矩阵的行列式了。关于为什么最右边的行列式为0可以看看后面的推导。<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    1&amp;2 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    1&amp;0 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;2 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>= 4<br>\left | \begin{matrix}<br>    1&amp;0 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>+<br>2 \times 4<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$<br>不得不说，上面三个性质非常容易理解，比用代数余子式的定义好多了，比什么鬼逆序数更是高到不知高哪里去。</p><hr><p>下面介绍行列式的其他性质，它们都可以从上面三个性质得到。<br>第四个性质说，如果行列式的两个行相等，那么行列式的值为0。这里推理的方法很巧妙，根据性质2，如果我们交换两行，行列式会反号。但我们交换的行又是相等的，照理说行列式符号不变。又要反号，又要不变，那行列式的值只能为0了。</p><p>第五个性质说，行 k 减去行 i 的若干倍，行列式的值不变。其实应该能猜到不变，消元如果能让行列式的值变化，那岂不是消元就有可能让不可逆矩阵可逆了？<br>所以<br>$$<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;0 \\<br>\end{matrix} \right |<br>$$</p><p>第六个性质说，如果矩阵的某一行都是0，则行列式是0。</p><p>第七个性质，上三角矩阵的行列式 U 等于对角线元素的乘积。这个很容易理解，因为可以通过之前的性质消掉上三角，得到一个对角矩阵，其行列式不变。然后可以用性质 3a “提取公因式”。</p><p>第八个性质，$det(A) = 0$ 当且仅当 A 是奇异矩阵。因为矩阵如果可逆，那么每一行都有主元，那么始终可以 <code>A -&gt; U -&gt; D -&gt; d1 d2 ... dn</code>这样计算。<br>比如<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    0&amp;d-\frac{c}{a}b \\<br>\end{matrix} \right |<br>= ad - bc<br>\end{equation}<br>$$</p><p>第九个性质，$det(AB) = det(A) det(B)$。所以虽然行列式不具备所谓的 adding property，但对乘法是有性质的。关于这个的证明教授没给出，randomwalk 说书上有，但其实书上也没找到。</p><p>从第九个性质可以推出 $det(A^{-1}) det(A) = det(I) = 1$，所以 $det(A^{-1}) = \frac{1}{det(A)}$。</p><p>另一个更有趣的性质是 $det(2A) = 2^n det(A)$，相当于每行都需要乘以一个 2。这就将行列式和体积联系起来了，如果正方体的边长扩大到原来的两倍，那么体积扩大到原来的 $2^3$ 倍。关于体积，后面还会详细介绍。</p><p>第十个性质，$det(A^T) = det(A)$，这就将行的性质可以推广到列上。<br>更有意思的是教授给了一个直觉的证明。我们可以将方阵进行 LU 分解，所以实际是要证明</p><p>$$<br>|U^T L^T| = |L U|<br>$$<br>根据性质九，实际是要证明<br>$$<br>|U^T| |L^T| = |L| |U|<br>$$</p><p>而这个是显然的，因为上下三角阵都等于主对角线的乘积，而转置不会改变主对角线。</p><hr><p>后面是一个非常有趣的观察，也就是置换具有奇偶性。这个往深了讲还能扯到交错群上。</p><p>教授说，进行一次行交换，行列式符号取反，所以得到的矩阵“是不一样”的。这听起来有点循环论证，因为交换行符号取反是教授的行列式定义啊。</p><h1 id="L19-行列式和代数余子式"><a href="#L19-行列式和代数余子式" class="headerlink" title="L19 行列式和代数余子式"></a>L19 行列式和代数余子式</h1><p>首先介绍从行列式的性质推导出行列式的计算公式。</p><p>对于二阶行列式，教授上节课已经从消元的角度推导过一次了，这次他用类似我上节课尝试的做法做的。其中第一和第四个行列式等于0。</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;0 \\<br>    c&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    a&amp;0 \\<br>    0&amp;d \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;b \\<br>    c&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;b \\<br>    0&amp;d \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>容易想到，对于3阶方阵，我们这样能拆出来 27 个行列式，这也太多了。但其中有很多行列式必然是0，因为它们的某一行或者列是0。有哪些行列式有可能不是0呢？</p><p>考虑三阶方阵，这里我省略下标，即 $a_{ij}$ 写成 $ij$ 了。如果我们选定第一行是 11，那么如果第二行选 22，那么最终可以被 11 消掉，所以只能选 22 或者 23。在第二行选完之后，第三行能选的也就唯一确定了。</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;23 \\<br>    0&amp;32&amp;33 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>所以可以得到</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;23 \\<br>    0&amp;32&amp;33 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;0&amp;23 \\<br>    0&amp;32&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;0 \\<br>    0&amp;0&amp;33 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>这里行列式是加，但如果再往下算，会发现符号会取反</p><p>$$<br>… = 11 * 22 * 33 - 11 * 23 * 32<br>$$</p><p>所以这里正负号有什么规律么？3阶方阵是有个规律，但没必要去记，因为4阶方阵不一样了。比如4阶方阵的副对角线上那四个数乘起来的 $14 * 23 * 32 * 41$ 其实符号应该为正。这是因为 $(4 , 3 , 2 , 1)$ 这样的排列，只需要进行两次即偶数次交换，即 1 和 4，2 和 3 交换即可。行列式的符号不变。</p><hr><p>下面推导一个行列式的通用公式，称为 The Big Formula。</p><p>$$<br>det(A) = \sum_{n! items} \pm a_{1\alpha} a_{2\beta} … a_{n\omega}<br>$$<br>其中，$\alpha, \beta, …, \omega$ 是从 1 到 n 的一个排列。</p><p>这个公式的 intuition 很简单，因为第一行可以在 n 列中选一个元素，第二行只能在剩下没选的 n-1 列中选一个元素，否则必然是0，由此往下推，总共就是 n! 中方案。</p><hr><p>下面介绍代数余子式。</p><p>以三阶矩阵为例</p><p>$$<br>det(A) = a_{11} + (a_{22} a_{33} - a_{23} a_{32}) \\<br>    + a12 (…) \\<br>    + … \\<br>$$</p><p>如果我们同时对 $a_{11}$ 展开行列式，可以看出，右下角的那个2阶方阵就是上面括号中的数字。即代数余子式 $C_{ij}$。</p><p>$$<br>\left | \begin{matrix}<br>    a_{11}&amp;0&amp;0 \\<br>    0&amp;a_{22}&amp;a_{23} \\<br>    0&amp;a_{32}&amp;a_{33} \\<br>\end{matrix} \right |<br>$$</p><p>不难猜出规律，正负号和 $i+j$ 有关。偶数正，奇数负。</p><p>可以得到行列式的代数余子式的计算方法<br>$$<br>det(A) = a_{11} C_{11} .. a_{1n} C_{1n}<br>$$</p><hr><p>下面，同样是用代数余子式来算二阶矩阵的行列式</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>= a d + b (-c)<br>\end{equation}<br>$$</p><p>可以看到，代数余子式求行列式也不简单。其实根据之前的性质7，也就是所谓的 pivot formula，可以发现，消元之后将主元都乘起来是最简单的。</p><hr><p>下面，介绍了一个叫三对角线阵的方阵。</p><p>$$<br>\begin{equation}<br>A_4 =<br>\left | \begin{matrix}<br>    1&amp;1&amp;0&amp;0 \\<br>    1&amp;1&amp;1&amp;0 \\<br>    0&amp;1&amp;1&amp;1 \\<br>    0&amp;0&amp;1&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>这里算 A3，我的方法更取巧，因为只需要消元成下面的形式，就可以发现交换 1 和 2 行得到 I。这样就可以知道行列式的值为 -1。</p><p>$$<br>\left | \begin{matrix}<br>    0&amp;1&amp;0 \\<br>    1&amp;0&amp;0 \\<br>    0&amp;0&amp;1 \\<br>\end{matrix} \right |<br>$$</p><p>这里算 A4 很有意思，选取 $a_{11}$，其代数余子式为 $A_3$。选取 $a_{12}$，代数余子式如下，我们不认识。但如果将它先转置，那么算起来会方便很多。这是一个很有趣的技巧。</p><p>$$<br>\left | \begin{matrix}<br>    1&amp;1&amp;0 \\<br>    0&amp;1&amp;1 \\<br>    0&amp;1&amp;1 \\<br>\end{matrix} \right |<br>$$</p><p>后面教授推到<br>$$<br>A_n = |A_{n-1}| - |A_{n-2}|<br>$$</p><p>得到 $A_n$ 的行列式的值随着 n 增大有个长度为 6 的循环节。这个略过了。</p><h1 id="L20-克莱默法则和体积"><a href="#L20-克莱默法则和体积" class="headerlink" title="L20 克莱默法则和体积"></a>L20 克莱默法则和体积</h1><p>基于行列式求逆矩阵如下，其中 $C^T$ 为各个 $a_{ij}$ 对应的 $C_{ij}$ 构成的矩阵的转置，称为伴随矩阵。</p><p>$$<br>A^{-1} = \frac{1}{det(A)} C^T<br>$$</p><p>教授说，det(A) 是 n 个 entry 的 product，而 $C^T$ 是 n-1 个 entry 的 product，不知道这有什么深层含义。</p><hr><p>下面教授证明上面的式子是对的，也就是要证明 $A C^T = (det(A)) T$。</p><p>首先确认主对角线上的每一个元素都是 det(A)。<br>不妨直接写出来。可以看出第一行乘以第一列就是 $a_{11} C_{11} + … + a_{1n} C_{1n}$，也就是行列式的值。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a_{11}&amp;…&amp;a_{1n} \\<br>    \ &amp;\ddots&amp; \ \\<br>    a_{n1}&amp;…&amp;a_{nn} \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    c_{11}&amp;…&amp;c_{1n} \\<br>    \ &amp;\ddots&amp; \ \\<br>    c_{n1}&amp;…&amp;c_{nn} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>然后确认非主对角线上的元素都是0。我们不妨考虑二阶矩阵这个简单的情况。<br>下面这个矩阵，它的行列式的值是0，两行相同。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a&amp;b \\<br>    a&amp;b \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>如果求 A 的第一行，和 C^T 的最后一列的内积，即 C 的最后一行的内积，也就相当于是求一个第一行和最后一行相等的矩阵的行列式。而如果两行相等，则行列式的值为0。</p><hr><p>考虑 $Ax = b$，有 $x = \frac{1}{det(A)} C^T b$，这就是克莱默法则。</p><p>这个神奇的 $C^T b$ 是怎么来的呢？教授说，一个余子式乘以一个数字，总让人想起行列式的值。不妨考虑 b 是个 n 维向量，那么其中一个分量的解就可以写成如下的形式，其中 $det(B_1)$ 就是那个不知道是什么的行列式的值。</p><p>$$<br>x_1 = \frac{det(B_1)}{det(A)}<br>$$</p><p>克莱默发现，这个行列式对应的矩阵 $B_1$ 实际上就是用 b 替换掉 A 的第一列，从而得到的矩阵。</p><p>$$<br>\begin{equation}<br>\left [ \begin{matrix}<br>    b_1&amp;a_{12}&amp;…&amp;a_{1n} \\<br>    b_2&amp;\ n &amp; - &amp;1 \\<br>    …&amp;\ cols&amp; \ &amp; of \\<br>    b_n&amp;\  &amp;\ A \\<br>\end{matrix} \right ]<br>\end{equation}<br>$$</p><p>容易看出，上面矩阵的右下角的部分就是 $C_11$。那么 $B_1$ 的行列式可以写成</p><p>$$<br>C_{11} b_1 + C_{21} b_2 + … + C_{n1} b_n<br>$$</p><p>而如下所示，上面这个式子等于 $C^T b$</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    c_{11} &amp; c_{21} &amp; \ldots &amp; c_{n1} \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    b_{1} \\<br>    b_{2} \\<br>    \vdots \\<br>    b_{n} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>行列式的值和体积有对应的关系。例如三阶行列式的值，就是对应三个向量组成的平行六面体的体积。</p><p>如何证明呢？这里有个神来一笔，我们只需要证明体积满足行列式的那三个定义就行了。</p><p>对于第一个定义，可以发现单位立方体的体积是1，这对应了 I 的行列式。</p><p>特别地，如果 A 是正交矩阵 Q，它对应的也是单位立方体，只是可能会发生旋转。它的体积也是 1，这是因为 $Q^T Q = I$。所以行列式相等，即 $ |Q^T Q| = |I|$，然后观察到 $ |Q^T Q| = |I|<br>\Rightarrow |Q| |Q| = |I| = 1 $，所以 $|Q| = \pm 1$。</p><p>对于第二个定义，显然交换行相当于坐标轴对调，不会改变体积。</p><p>对于第 3a 个定义，是显然的。</p><p>对于第 3b 个定义，下面的图一目了然。</p><p><img src="/img/linalg/volume3b.png"></p><hr><p>特别地，教授还讲了三顶点都不过原点的三角形的面积，是</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    x_1&amp;y_1&amp;1 \\<br>    x_2&amp;y_2&amp;1 \\<br>    x_3&amp;y_3&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><h1 id="L21-特征向量和特征值"><a href="#L21-特征向量和特征值" class="headerlink" title="L21 特征向量和特征值"></a>L21 特征向量和特征值</h1><p>对于特定的向量 x，我们要 $ Ax = \lambda x$，也就是说 $ Ax$ 和 $x$ 平行。</p><hr><p>不妨考虑一下一些特殊矩阵的特征值和特征向量。</p><p>如果 $A$ 是个奇异矩阵，它可以将某个非零向量变为0，所以它的一个特征值是0。这是肯定的，因为如果 $A$ 是奇异矩阵，则 $A$ 不可逆，且 $Ax = 0$ 存在非零解，即 $Ax$ 的零空间中不只有 0 向量。</p><p>考虑投影矩阵 $P$，它所投影到的平面上的所有向量是特征向量。这是因为对于任意平面内的向量 x 有 $P x = x$，此时 $\lambda=1$。<br>还有没有其他的特征向量么？所有垂直于平面的向量也是特征向量，这是因为总有 $P x = 0$，此时 $\lambda=0$。</p><p>考虑置换矩阵 A = [0 1; 1 0]。容易发现向量 $[1 , 1]^T$ 是它的一个特征向量，对应特征值为 1。教授说，肯定还有个特征值是 -1，对应特征向量是 $[-1 , 1]$。<br>这么厉害的么？原来根据代数基本定理，在 n 阶方阵中肯定有 n 个特征值，并且它们的和等于矩阵的迹，也就是主对角线的和。<br>因为 A 是对称矩阵，所以这两个向量互相垂直。</p><hr><p>下面来解 $ Ax = \lambda x$ 这个方程了，简单移项可以得到 $(A - \lambda I) x = 0$。</p><p>教授说，$A - \lambda I$ 一定是奇异的，否则 x 只能为零向量了。</p><p>所以 $det(A - \lambda I)=0$。对于这个行列式，可以用消元法求出主列。</p><p>例如考虑矩阵 [3 1; 1 3]，$det(A - \lambda I) = \lambda^2 - 6 \lambda + 8$。有趣的是这里的 6 刚好是 trace(A)，8 则是 det(A)。这有点像韦达定理，不知道对于更高阶的矩阵，是不是也是对应的韦达定理呢。</p><p>现在求出特征值了，下面需要求特征向量。可以用消元法解 $ A - \lambda I $，这一矩阵零空间中的向量为矩阵<br>A 的特征向量。不妨先考虑 $\lambda_1 = 4$，对应的 $A - \lambda I$ 是<br>$$<br>\begin{bmatrix}<br>    -1&amp;1 \\<br>    1&amp;-1 \\<br>\end{bmatrix}<br>$$<br>显然这个矩阵一定是奇异矩阵。我们要找的就是它的零空间。同样可以消元得到<br>$$<br>\begin{bmatrix}<br>    1&amp;-1 \\<br>    0&amp;0 \\<br>\end{bmatrix}<br>$$<br>然后可以得到<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    -F \\<br>    I \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    1 \\<br>    1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>进一步考虑上面的问题 [3 1; 1 3] 相比 [0 1; 1 0]，它的特征向量没变，但是特征值都增加了3。所以如果 $Ax = \lambda x$，则 $(A + 3 I)x = \lambda x + 3 x = (\lambda + 3)x$。</p><p>但是两个矩阵的和的特征值不等于两个矩阵特征值的和。教授说因为特征向量可能不一样。反正这一块他讲得很奇怪，我就不记录了。</p><hr><p>下面讨论一些特殊的矩阵。</p><p>首先是旋转矩阵，它是正交的，所以教授用 Q 表示</p><p>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    0&amp;-1 \\<br>    -1&amp;0 \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    cos90^{\circ}&amp;-sin90^{\circ} \\<br>    sin90^{\circ}&amp;cos90^{\circ} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>这里教授补充了下，特征值的积等于行列式的值。【Q】看起来特征值还和体积有关系？</p><p>教授发出灵魂拷问，什么样的向量在旋转之后还是它自己呢？除了0向量之外，我似乎想不到别的，那 $A x = \lambda x$ 如何成立呢？然后教授就推到 $\lambda^2 + 1 = 0$。原来如此，特征值可能是虚数！</p><p>教授说，对称矩阵都是实特征值，而我们的这个矩阵是反对称矩阵，也就是说 $Q^T Q = -1$。所以它的特征值是纯虚数。所以看起来，实数特征值是让特征向量伸缩的部分，而虚数是让特征向量的旋转部分？</p><p>另外从这也可以看出，如果 $a+bi$ 是特征值，那么共轭复数 $a-bi$ 也是特征值。</p><hr><p>然后是上三角矩阵，它的特征值全部在对角线上。我们发现，它的两个特征值相等，都为3。<br>$$<br>\begin{bmatrix}<br>    3&amp;1 \\<br>    0&amp;3 \\<br>\end{bmatrix}<br>$$</p><p>可以找到一个特征向量 $[1, 0]$。这是显然的，因为我们有一个主元，一个自由列。但因为另一个特征值是重复的，所以找不到第二个线性无关的特征向量了。这说明矩阵是个退化矩阵。</p><p>下一节会继续讨论这个问题。</p><h1 id="L22-对角化和矩阵的幂"><a href="#L22-对角化和矩阵的幂" class="headerlink" title="L22 对角化和矩阵的幂"></a>L22 对角化和矩阵的幂</h1><p>这里，定义 S 是<strong>特征向量组成的矩阵</strong>。我们同时要求 S 是可逆的，这说明 A 要有 n 个线性无关的特征向量。</p><p>S 有很神奇的性质，不妨算算<br>$$<br>AS = A [x1 , x2 , … , xn] \\<br>= [\lambda_1 x1 , \lambda_2 x2, …, \lambda_n xn] \\<br>=<br>\begin{equation}<br>\begin{bmatrix}<br>    x1&amp;x2&amp;…&amp;xn \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    \lambda_1 &amp; … &amp; 0 \\<br>    0 &amp; … &amp; 0 \\<br>    0 &amp; … &amp; \lambda_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>这里最后一步，可以正好用来复习列操作。也就是矩阵乘法的第四种看待方式。所以接下来可以得到</p><p>$$<br>\begin{equation}<br>AS = S<br>\begin{bmatrix}<br>    \lambda_1&amp;…&amp;0 \\<br>    \vdots &amp; \ddots &amp; \vdots \\<br>    0&amp;…&amp;\lambda_n \\<br>\end{bmatrix}<br>= S \Lambda<br>\end{equation}<br>$$</p><p>从上面可以总结得到</p><p>$$<br>S^{-1} A S = \Lambda \\<br>A = S \Lambda S^{-1}<br>$$</p><p>所以我们有了在 LU、QR 分解之外的另一种分解矩阵的思路。</p><hr><p>这种新的矩阵分解方式常常被用来计算矩阵的幂。即</p><p>$$<br>A^k x = S \Lambda^k S^{-1}<br>$$</p><p>当所有的特征值的绝对值都小于 1 时，$|A^k|$ 趋向于零矩阵。</p><hr><p>A 必存在 n 个线性无关的特征向量才能对角化。<br>可是<strong>如何判断是否有 n 个线性无关的特征向量</strong>呢？</p><ol><li>当所有的特征值不同，那么一定有 n 个线性无关的特征向量。</li><li>当有重复的特征值，则需要进一步检查<br> 例如对 I 来说，有 n 个线性无关的特征向量。<br> 对之前说的矩阵来说则没有。</li></ol><p>代数重度 几何重度 都是啥？</p><hr><p>下面介绍差分方程，以及斐波拉契数列作为一个例子。<br>差分方程类似 $u_{k+1} = A u_k$。它的解是 $u_k = A^k u_0$。这个形式虽然很对，但是对我们计算没有意义。</p><p>如何解呢，我们可以将 $u_k$ 表示成 A 的特征向量的线性组合。如下式所示，其中 S 和之前一样是特征向量组成的矩阵。<br>$$<br>u_1 = c_1 u_0 + … + c_n x_n = S c<br>$$</p><p>这里是因为 A 可以对角化，所以一定能得到 n 个线性无关的向量，它们是张成 n 维空间的一组基。【Q】如果不可以对角化呢？</p><p>然后，乘上 A，得到<br>$$<br>A u_0 = c_1 \lambda_1 x_1 + … + c_n \lambda_n x_n<br>$$</p><p>那么根据特征值和特征向量的性质 $ Ax = \lambda x$，有<br>$$<br>u_k = A^k u_0 = c_1 \lambda_1^k x_1 + … + c_n \lambda_n^k x_n =<br>$$</p><p>结果等于 $\Lambda^k S c$。</p><hr><p>下面举了斐波拉契数列的例子。</p><p>【Q】这里教授插了句嘴，说对称矩阵特征值都是实数，不知道是怎么得到的。</p><p>在斐波拉契数列的计算中，求出两个特征值后，可以根据大的那个进行估计。这是因为较小的那个绝对值小于1，所以影响会越来越收敛。</p><h1 id="L23-微分方程"><a href="#L23-微分方程" class="headerlink" title="L23 微分方程"></a>L23 微分方程</h1><p>考虑微分方程<br>$$<br>\frac{du_1}{dt} = -u_1 + 2u_2 \\<br>\frac{du_2}{dt} = u_1 - 2u_2 \\<br>$$</p><p>可以写出 A 为 [-1 2; 1 -2]。显然这是一个奇异矩阵，奇异矩阵的行列式为0。而特征值的积等于行列式，所以一定有一个特征值为0。而根据迹可以求出另一个特征值为-3。</p><p>如果特征值是0，则会得到一个稳态，因为解是 $e^{0t} = 1$。</p><p>下面求特征向量。不要觉得 A 是奇异矩阵，那么0特征值对应的特征向量就可以随意取了。我们还是要按部就班来算，最后得到是 [2; 1]。同理，-3对应的特征向量是 [1; -1]。</p><p>通解是 $u(t) = c_1 e^{\lambda_1 t} x_1 + c_2 e^{\lambda_2 t} x_2$。</p><p>为什么可以这样将通解和矩阵的特征值联系起来呢？可以参考 randomwalk 的注解。这里 $x_1$ 和 $x_2$ 是对初值 $u_0$ 的分解。$\lambda$ 部分可以凑 e。</p><p>接着带入 $u_0$ 求出 $c_1$ 和 $c_2$，即 $S c = u_0$，这个上一讲我们也见过了。得到通解为</p><p>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    2 \\<br>    1 \\<br>\end{bmatrix}<br>+<br>\frac{1}{3} e^{-3t}<br>\begin{bmatrix}<br>    1 \\<br>    -1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>其中，前者为稳态状态，后者随时间衰减。最终，趋于<br>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    2 \\<br>    1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>什么时候微分方程得到稳态呢？</p><ol><li>负的特征值一定会得到稳态</li><li>如果是复数，那么还是看实部的正负号。虚部只是让它在单位圆上转圈。</li></ol><p>容易看出，如果 A 是收敛的，那么 -A 是发散的。因为 -A 的特征值都变号了。</p><p>而需要注意，如果特征值都为负数，那么迹是负数；反之则不成立。</p><hr><p>这里，教授讲到原微分方程组中有两个相互耦合的未知数 $u_1$、$u_2$。我们通过对角化来解耦。即 $u = S v$。即<br>$$<br>\frac{du}{dt} = A u \\<br>S \frac{dv}{dt} = A S v<br>$$<br>所以<br>$$<br>\frac{du}{dt} = S^{-1} A S v = \Lambda v<br>$$<br>则解为<br>$$<br>v(t) = e^{\Lambda t} v(0) \\<br>u(t) = S e^{\Lambda t} S^{-1} u(0)<br>$$</p><p>然后有一个奇怪的式子。可以发现 $e^{At}$ 就是原方程的解。<br>$$<br>S e^{\Lambda t} S^{-1} = e^{At}<br>$$</p><p>这里用矩阵作为 e 的指数很奇怪，需要往下介绍矩阵指数函数。</p><hr><p>定义指数函数的办法是将它分解为幂级数的形式，这样就可以当矩阵称为底数了。这边需要一些泰勒分解的基础，就不详细讲了。</p><p>同理 $(I - At)^{-1}$ 可以写成几何级数的形式，但是需要 $At$ 特征值的绝对值小于1，否则不收敛。这里 randomwalk 写错了吧。</p><p>然后教授通过幂级数定义了以矩阵为指数的指数函数。</p><p>需要注意的是，有一些矩阵，它的特征向量并不全部线性无关，<strong>所以它们无法对角化</strong>。<strong>但它们仍然可以三角化</strong>。</p><hr><p>下图是一个复平面。<br>图中阴影部分表示矩阵的的指数函数收敛于0的特征值范围。<br>图中圆圈中的部分表示矩阵的幂函数收敛于0的特征值范围。</p><p><img src="/img/linalg/converge.png"></p><hr><p>二阶微分方程。</p><h1 id="L24-马尔科夫矩阵和傅里叶级数"><a href="#L24-马尔科夫矩阵和傅里叶级数" class="headerlink" title="L24 马尔科夫矩阵和傅里叶级数"></a>L24 马尔科夫矩阵和傅里叶级数</h1><p>马尔科夫矩阵的两个性质：</p><ol><li>每个元素都大于等于0</li><li>所有列的加和都为1</li></ol><p>马尔科夫矩阵的幂还是马尔科夫矩阵。【Q】这个很奇怪，性质2是怎么保持的？</p><p>教授说，每列加和为1这个性质保证了马尔科夫矩阵有一个特征值为1。并且其他的所有特征值小于等于1。<br>下面证明这个性质。需要证明 $A-I$ 是奇异的。结合之前的课程知道，如果 $A-I$ 不是奇异的，那么 $(A-I)x=0$ 只有0这一个解，这样的话就不存在特征值1对应的特征向量了。证明奇异很简单，只需要观察到每一列的和都是0，这说明行向量线性相关。实际上我们把每一行相加，就会得到零。从线性组合来理解，即 [1, 1, 1] 位于 $A-I$ 的左零空间中。而特征向量 $x_1$ 位于 $A-I$ 的零空间中。</p><hr><p>$A$ 和 $A^T$ 的特征值相同。这是因为 $det(A^T -\lambda I) = det(A - \lambda I)$。</p><hr><p>用加州和麻省的人口迁徙作为例子。求出马尔科夫矩阵的特征值1对应的特征向量为 [2, 1]，这说明在稳态时，加州人口占 2/3，麻省占 1/3。</p><hr><p>上面是将向量分解为各个特征向量的线性组合。现在将向量 v 分解为若干个标准正交向量的线性组合。</p><p>如下所示，如果我们有一组正交基，那么每个基向量的系数 $x_i$ 很容易求得，只需要乘上 $q_i$ 即可。即 $x_i = q_i^T v$。<br>$$<br>v = x_1 q_1 + … + x_n q_n<br>$$</p><p>写成矩阵形式，即<br>$$<br>\begin{equation}<br>v =<br>\begin{bmatrix}<br>    q_1&amp;…&amp;q_n<br>\end{bmatrix}<br>\begin{bmatrix}<br>    x_1 \\<br>    \vdots \\<br>    x_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$<br>也就是说 $v = Qx$。所以 $x = Q^{-1}v = Q^T v$。</p><hr><p>下面模仿正交向量，定义了两个正交的函数。</p><p>$$<br>f^T g = \int f(x) g(x) dx<br>$$</p><p>容易看出 $sin x$ 和 $cos x$ 是正交的。</p><p>$$<br>\int_0^{2 \pi} sinx cosx dx = 0<br>$$</p><h1 id="L25-复习"><a href="#L25-复习" class="headerlink" title="L25 复习"></a>L25 复习</h1><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>从公式可以推出。或者可以看出 A 是向量，用二维的简化形式算，这样可以直接做除法。</p><p>至于 P 的秩可以从向量是一维来看，所以秩是一维。</p><p>P 的列空间是一条直线。</p><p>P 的特征值很好算。因为 P 的行列式是0，所以有特征值是0。【Q】这里有一点不明白的是为什么0一定是重特征值呢？</p><p>不过后面既然知道0是重特征值就可以从迹算出最后一个特征值是1。</p><p>求P对应特征值为1的特征向量。这里考虑到 P 为投影矩阵的性质，在投影空间中的向量比如 a 就是对应特征值 1 的特征向<br>量。</p><p>如果有 $u_{k+1} = P u_k$，且有初值 $u_0$，求 $u_k$。这个就是考虑投影第二次之后，结果就不会变化了。</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>小问2是如何从投影的角度理解最小二乘？这个其实教授也讲过了，因为 b 不在 Ax 的列空间中，所以原方程是无解的。但是如果将 b 投影到 A 的列空间，就能得到 Ax=b 的近似解。</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p>使用施密特正交化来求正交基。</p><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p>小问1：一个四阶方阵 A 的特征值要满足什么条件，A 才是可逆的？我觉得这四个特征值都不为零，哪怕有重特征值都行。因为特征值的乘积是行列式，行列式不为零矩阵可逆。而重特征值只和特征向量的线性相关性有关系。</p><p>小问2：求 $A^{-1}$ 的特征值。【Q】我似乎没印象教授讲过逆矩阵的特征值是倒数。</p><p>小问3：求 A + I 的迹。</p><h2 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h2><p>已知三对角矩阵 $A_4$，令 $D_n = det(A_n)$。</p><h2 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h2><p>小问1：求投影到 $A_3$ 列空间的投影矩阵 P。什么叫投影到列空间？我想如果一个矩阵的列空间是一个平面，那么投影到它的列空间就是投影到一个平面上。</p><p>那么 $A_3$ 的列空间是什么呢？可以发现它的秩是2，所以列空间是一个平面，零空间是一条线，不要搞混。</p><p>小问2：求 $A_3$ 的特征值和特征向量</p><p>小问3：找到投影到 $A_4$ 列空间的投影矩阵 P<br>这里解法很巧妙，因为 $A_4$ 可逆，所以列空间是整个 $R^4$，所以 P 是 I。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%88%97%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%88%97%E7%A9%BA%E9%97%B4</a></li><li><a href="https://zh.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3</a></li><li><a href="/asset/linalg-vector-eig.ggb">特征向量</a><br> 一个 Geogebra 的关于特征向量的演示。</li><li><a href="https://randomwalk.top/archives/569" target="_blank" rel="noopener">https://randomwalk.top/archives/569</a></li><li><a href="https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/" target="_blank" rel="noopener">https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文从&lt;a href=&quot;https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&amp;p=16&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MIT的线代教程&lt;/a&gt;的角度重新学习线性代数。&lt;/p&gt;
&lt;p&gt;这是第二部分，从 L14 开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/linalg/mitbad.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="公开课" scheme="http://www.calvinneo.com/tags/公开课/"/>
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
    <category term="代数" scheme="http://www.calvinneo.com/tags/代数/"/>
    
    <category term="线性代数" scheme="http://www.calvinneo.com/tags/线性代数/"/>
    
  </entry>
  
  <entry>
    <title>停机问题</title>
    <link href="http://www.calvinneo.com/2023/02/01/the-halt-problem/"/>
    <id>http://www.calvinneo.com/2023/02/01/the-halt-problem/</id>
    <published>2023-02-01T15:20:37.000Z</published>
    <updated>2023-02-12T13:25:42.511Z</updated>
    
    <content type="html"><![CDATA[<p>介绍停机问题相关证明。</p><a id="more"></a><h1 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h1><p>令<code>H(P, I)</code>，返回对于程序<code>P</code>在输入<code>I</code>的情况下是否可停机，假如<code>P(I)</code>能停机，则<code>H</code>停机，否则<code>H</code>死循环。</p><p>不妨假设<code>U(X) = H(X, X)</code>。现在考虑<code>U(X)</code>的定义：</p><ol><li>如果<code>H(X, X)</code>停机，则<code>U(X)</code>死循环。</li><li>如果<code>H(X, X)</code>死循环，则<code>U(X)</code>停机。</li></ol><p>也就是<code>U(X)</code>是对<code>H(X, X)</code>取反。</p><p>下面考虑<code>U(U)</code>的结果：</p><ol><li>如果<code>H(U,U)</code>停机，那么<code>U(U)</code>应该输出死循环。</li><li>但是考虑<code>H(U,U)</code>的定义是<code>U</code>在输入为<code>U</code>的情况下是否停机，如果<code>H(U,U)</code>停机了，说明<code>U(U)</code>是可以停机的。</li></ol><p>于是上面两者矛盾。</p><p>其实这个证明的 intuition 很简单，比如女朋友说“我觉得你对我有意见”时：</p><ol><li>如果你说“你说的对”，那说明你对女朋友有意见，你就完蛋了。</li><li>如果你说“你说的不对”，那你居然反对女朋友，你完蛋了。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍停机问题相关证明。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
  </entry>
  
  <entry>
    <title>valgrind 用法</title>
    <link href="http://www.calvinneo.com/2023/01/26/valgrind-usage/"/>
    <id>http://www.calvinneo.com/2023/01/26/valgrind-usage/</id>
    <published>2023-01-26T02:04:26.000Z</published>
    <updated>2023-01-30T16:09:25.326Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。</p><a id="more"></a><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>功能是：</p><ol><li>未允许的内存访问，例如 overrun 或者 underrun 堆内存，或者 oveerrun 栈顶，或者访问已经被释放的内存。</li><li>使用未定义的值，例如没有被初始化的值，或者从其他未初始化的值派生出来的值。</li><li>错误释放堆内存，类似于 double free，或者错误搭配 new/new[]/malloc。</li><li>在内存分配时，传入负数作为大小。</li><li>内存泄露。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --track-origins=yes</span><br></pre></td></tr></table></figure><h2 id="Illegal-read-Illegal-write-errors"><a href="#Illegal-read-Illegal-write-errors" class="headerlink" title="Illegal read / Illegal write errors"></a>Illegal read / Illegal write errors</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, *(<span class="keyword">int</span>*)(&amp;y + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==25724== Invalid read of size 4</span><br><span class="line">==25724==    at 0x400674: main</span><br><span class="line">==25724==  Address 0x0 is not stack&apos;d, malloc&apos;d or (recently) free&apos;d</span><br></pre></td></tr></table></figure><h2 id="Use-of-uninitialised-values"><a href="#Use-of-uninitialised-values" class="headerlink" title="Use of uninitialised values"></a>Use of uninitialised values</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">==38591== Use of uninitialised value of size 8</span><br><span class="line">==38591==    at 0x571A32B: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line"></span><br><span class="line">==38591== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==38591==    at 0x571A335: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line">==38591==  Uninitialised value was created by a stack allocation</span><br><span class="line">==38591==    at 0x400667: main</span><br></pre></td></tr></table></figure><p>在程序操作未初始化的数据时，memcheck 会记录这些数据，但不会输出错误。只有当这个程序尝试使用这些未初始化的数据，并且会影响这个程序的外部可见性时，才会报错。在这个例子中，x 没有被初始化。memcheck 观察到这个值被传给 printf 和 vfprintf，但并没有输出错误。当 vfprintf 检查 x 的值，并且试图将其转换为 ASCII 字符串时，memcheck 才会输出错误。</p><p>可以通过设置 <code>--track-origins=yes</code> 来检查这些未初始化的数据。它会使得 memcheck 跑得更慢，但更容易发现问题。</p><h2 id="Use-of-uninitialised-or-unaddressable-values-in-system-calls"><a href="#Use-of-uninitialised-or-unaddressable-values-in-system-calls" class="headerlink" title="Use of uninitialised or unaddressable values in system calls"></a>Use of uninitialised or unaddressable values in system calls</h2><p>Memcheck 检查 system call 中所有的未初始化变量，包括：</p><ol><li>所有的直接变量。</li><li>或者，如果一个 system call 需要读取程序中的某一段缓存，memcheck 会检查整个缓存是否 addressable，并且其内容是否被初始化。</li><li>或者，如果这个 system call 需要写到用户提供的某一段缓存中，memcheck 需要检查这段缓存是否 addressable。</li></ol><h2 id="Illegal-frees"><a href="#Illegal-frees" class="headerlink" title="Illegal frees"></a>Illegal frees</h2><p>Memcheck 记录通过 malloc 和 new 分配的所有块，所以他可以知道某个 free 或者 delete 是否合法。在这里，出现了 double free。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在出现非法读写的错误时，memcheck 会尝试解析被释放的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==27728== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006E4: main</span><br><span class="line">==27728==  Address 0x5ab1c80 is 0 bytes inside a block of size 10 free&apos;d</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006D8: main</span><br><span class="line">==27728==  Block was alloc&apos;d at</span><br><span class="line">==27728==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27728==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><p>注意，如果我们释放的是指向某个堆空间内部的指针，则也会出现类似的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，报错为 <code>is 1 bytes inside ... alloc&#39;d</code>。这样的报错说明不是 double free 的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==31870== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==31870==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==31870==    by 0x4006DC: main</span><br><span class="line">==31870==  Address 0x5ab1c81 is 1 bytes inside a block of size 10 alloc&apos;d</span><br><span class="line">==31870==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==31870==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==12625== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x400705: main</span><br><span class="line">==12625==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 free&apos;d</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x4006F2: main</span><br><span class="line">==12625==  Block was alloc&apos;d at</span><br><span class="line">==12625==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==12625==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] (x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==18227== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==18227==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==18227==    by 0x4006FC: main</span><br><span class="line">==18227==  Address 0x5ab1c84 is 4 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==18227==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==18227==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h2 id="When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function"><a href="#When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function" class="headerlink" title="When a heap block is freed with an inappropriate deallocation function"></a>When a heap block is freed with an inappropriate deallocation function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==29865== Mismatched free() / delete / delete []</span><br><span class="line">==29865==    at 0x4C2B6DF: operator delete(void*, unsigned long) (vg_replace_malloc.c:595)</span><br><span class="line">==29865==    by 0x400710: main</span><br><span class="line">==29865==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==29865==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==29865==    by 0x4006E8: main</span><br></pre></td></tr></table></figure><p>C++ 中的 allocate 和 deallocate 操作包含：</p><ol><li>If allocated with malloc, calloc, realloc, valloc or memalign, you must deallocate with free.</li><li>If allocated with new, you must deallocate with delete.</li><li>If allocated with new[], you must deallocate with delete[].</li></ol><p>最要命的是在 Linux 中其实无所谓搞混这些 allocate 和 deallocate 操作。但是这样错误的搭配在其他平台比如 Solaris 上则会导致 crash。</p><h2 id="Overlapping-source-and-destination-blocks"><a href="#Overlapping-source-and-destination-blocks" class="headerlink" title="Overlapping source and destination blocks"></a>Overlapping source and destination blocks</h2><p>在 <code>memcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code> 中，指向 src 和 dst 的指针不能 overlap。</p><p>比较奇怪的是下面的代码并不会出现这样的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(x + <span class="number">1</span>, x, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">void</span> * y = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(y + <span class="number">1</span>, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 gcc 会把 memcpy 优化掉，通过 <code>-fno-builtin-memcpy</code> 可以禁用这个性质。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==15974== Source and destination overlap in memcpy(0x5ab1c81, 0x5ab1c80, 2)</span><br><span class="line">==15974==    at 0x4C2E81D: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1035)</span><br><span class="line">==15974==    by 0x40075E: main</span><br><span class="line">==15974==</span><br></pre></td></tr></table></figure><h2 id="Fishy-argument-values"><a href="#Fishy-argument-values" class="headerlink" title="Fishy argument values"></a>Fishy argument values</h2><p>所有的内存分配函数都需要指定需要分配的大小，而这个大小肯定是一个非负数，并且不会特别大。例如我们不太可能在64位机器上分配 <code>2**23</code> 个字节。这样的大小通常来自于一个人为的错误，而这样的值就被称为 fishy value。在 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>memalign</code>、<code>new</code>、<code>new []</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==27571== Argument &apos;size&apos; of function malloc has a fishy (possibly negative) value: -2</span><br><span class="line">==27571==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27571==    by 0x40067A: main</span><br></pre></td></tr></table></figure><p>但同时注意到编译器也会触发警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: argument 1 value ‘18446744073709551614’ exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]</span><br><span class="line">void * x = malloc(-2);</span><br></pre></td></tr></table></figure><h2 id="Memory-leak-detection"><a href="#Memory-leak-detection" class="headerlink" title="Memory leak detection"></a>Memory leak detection</h2><p>Memcheck 会记录所有分配的堆对象。<br>通过设置 <code>--leak-check</code>，对于在结束时尚未被释放的 block，Memcheck 会检查这个 block 是否可以从 root set 被访问。这里的 root set 包括：</p><ol><li>通用寄存器</li><li>在所有可访问内存，包括栈中的 initialised, aligned, pointer-sized data words</li></ol><p>有两种方法可以访问一个 block：</p><ol><li>start-pointer，也就是指向 block 开始位置的指针</li><li>interior-pointer，也就是指向 block 中间位置的指针</li></ol><p>一个 interior-pointer 是如何产生的呢？</p><ol><li>它可能开始是一个 start-pointer，但后来被程序故意或者非故意地向前移动<br> 比如如果程序使用 tagged pointer。因为对齐的缘故，指针最右边的几位通常是0，所以会被用来存储额外的信息。这些信息可能导致指针被前进。</li><li>可能是内存中的某个垃圾</li><li>【stdstring】可能是指向 std::string 内部持有的 char[] 的指针<br> 例如某些编译期会在 std::string 的头部存3个字段，分别表示数组的 length、capacity 和 refcount，在这3个字段之后再放置真正的 char[]。但是它返回的指针是指向 char[] 的。这个有点类似 Redis 的 SDS 的实现。</li><li>【length64】Some code might allocate a block of memory, and use the first 8 bytes to store (block size - 8) as a 64bit number. sqlite3MemMalloc does this.</li><li>【newarray】可能是执行某个 T[] 中的指针。这里的 T 是一个 C++ 对象，它具有自定义的析构函数，并使用 new[] 分配，delete[] 删除<br> 在这种情况下，一些编译器会在指针的前面放一个 magic cookie，用来存放长度。</li><li>【multipleinheritance】It might be a pointer to an inner part of a C++ object using multiple inheritance.</li></ol><p>You can optionally activate heuristics to use during the leak search to detect the interior pointers corresponding to the stdstring, length64, newarray and multipleinheritance cases. If the heuristic detects that an interior pointer corresponds to such a case, the block will be considered as reachable by the interior pointer. In other words, the interior pointer will be treated as if it were a start pointer.</p><p>下面一张图阐释了几种内存泄露的情况：</p><ol><li><code>DR</code>: Directly reachable</li><li><code>IR</code>: Indirectly reachable</li><li><code>DL</code>: Directly lost</li><li><code>IL</code>: Indirectly lost</li><li><code>(y)XY</code>: it’s XY if the interior-pointer is a real pointer</li><li><code>(n)XY</code>: it’s XY if the interior-pointer is not a real pointer</li><li><code>(_)XY</code>: it’s XY in either case</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(1)  RRR ------------&gt; BBB                    DR</span><br><span class="line">(2)  RRR ---&gt; AAA ---&gt; BBB    DR              IR</span><br><span class="line">(3)  RRR               BBB                    DL</span><br><span class="line">(4)  RRR      AAA ---&gt; BBB    DL              IL</span><br><span class="line">(5)  RRR ------?-----&gt; BBB                    (y)DR, (n)DL</span><br><span class="line">(6)  RRR ---&gt; AAA -?-&gt; BBB    DR              (y)IR, (n)DL</span><br><span class="line">(7)  RRR -?-&gt; AAA ---&gt; BBB    (y)DR, (n)DL    (y)IR, (n)IL</span><br><span class="line">(8)  RRR -?-&gt; AAA -?-&gt; BBB    (y)DR, (n)DL    (y,y)IR, (n,y)IL, (_,n)DL</span><br><span class="line">(9)  RRR      AAA -?-&gt; BBB    DL              (y)IL, (n)DL</span><br><span class="line"></span><br><span class="line">Pointer chain legend:</span><br><span class="line">- RRR: a root set node or DR block</span><br><span class="line">- AAA, BBB: heap blocks</span><br><span class="line">- ---&gt;: a start-pointer</span><br><span class="line">- -?-&gt;: an interior-pointer</span><br></pre></td></tr></table></figure><p>前四行比较简单。<br>第5行，如果这个 interior pointer 是一个 real pointer，则是 directly reachable。如果不是 real pointer 则是 directly lost。<br>第6行，相当于是2+5，没啥特殊的。<br>第7行，相当于是5+1，没啥特殊的。<br>第8行，可以分成三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(8)  RRR -?-&gt; AAA -?n-&gt; BBB   (y)DR, (n)DL    DL</span><br><span class="line">(8)  RRR -?y-&gt; AAA -?y-&gt; BBB  DR              IR</span><br><span class="line">(8)  RRR -?n-&gt; AAA -?y-&gt; BBB  DL              IL</span><br></pre></td></tr></table></figure><p>但实际输出的时候，不会按照上面9个情况来输出，而是设计为如下的形式：</p><ol><li>Still reachable 1-2行</li><li>Definitely lost 3行</li><li>Indirectly lost 4/9行</li><li>Possibly lost 5-8行<br> 这种情况下可能存在1或者多个指针构成的链，但其中至少有一个指针是 interior pointer。这个可能只是内存中的随机值，并恰巧指向了某个块。</li></ol><h2 id="Details-of-Memcheck’s-checking-machinery"><a href="#Details-of-Memcheck’s-checking-machinery" class="headerlink" title="Details of Memcheck’s checking machinery"></a>Details of Memcheck’s checking machinery</h2><p>这一节介绍 Memcheck 的原理。</p><h3 id="Valid-value-V-bits"><a href="#Valid-value-V-bits" class="headerlink" title="Valid-value (V) bits"></a>Valid-value (V) bits</h3><p>It is simplest to think of Memcheck implementing a synthetic CPU which is identical to a real CPU, except for one crucial detail. Every bit (literally) of data processed, stored and handled by the real CPU has, in the synthetic CPU, an associated “valid-value” bit, which says whether or not the accompanying bit has a legitimate value. In the discussions which follow, this bit is referred to as the V (valid-value) bit.</p><p>Each byte in the system therefore has a 8 V bits which follow it wherever it goes. For example, when the CPU loads a word-size item (4 bytes) from memory, it also loads the corresponding 32 V bits from a bitmap which stores the V bits for the process’ entire address space. If the CPU should later write the whole or some part of that value to memory at a different address, the relevant V bits will be stored back in the V-bit bitmap.</p><p>In short, each bit in the system has (conceptually) an associated V bit, which follows it around everywhere, even inside the CPU. Yes, all the CPU’s registers (integer, floating point, vector and condition registers) have their own V bit vectors. For this to work, Memcheck uses a great deal of compression to represent the V bits compactly.</p><p>Copying values around does not cause Memcheck to check for, or report on, errors. However, when a value is used in a way which might conceivably affect your program’s externally-visible behaviour, the associated V bits are immediately checked. If any of these indicate that the value is undefined (even partially), an error is reported.</p><h3 id="Valid-address-A-bits"><a href="#Valid-address-A-bits" class="headerlink" title="Valid-address (A) bits"></a>Valid-address (A) bits</h3><h3 id="结合-VV-和-VA"><a href="#结合-VV-和-VA" class="headerlink" title="结合 VV 和 VA"></a>结合 VV 和 VA</h3><h2 id="Debugging-MPI-Parallel-Programs-with-Valgrind"><a href="#Debugging-MPI-Parallel-Programs-with-Valgrind" class="headerlink" title="Debugging MPI Parallel Programs with Valgrind"></a>Debugging MPI Parallel Programs with Valgrind</h2><h1 id="Callgrind"><a href="#Callgrind" class="headerlink" title="Callgrind"></a>Callgrind</h1><p>检查程序中函数调用过程中出现的问题。</p><h1 id="Cachegrind"><a href="#Cachegrind" class="headerlink" title="Cachegrind"></a>Cachegrind</h1><p>检查程序中缓存使用出现的问题。</p><h1 id="Helgrind"><a href="#Helgrind" class="headerlink" title="Helgrind"></a>Helgrind</h1><p>检查多线程程序中出现的竞争问题。</p><h1 id="Massif"><a href="#Massif" class="headerlink" title="Massif"></a>Massif</h1><p>检查程序中堆栈使用中出现的问题。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs" target="_blank" rel="noopener">https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="valgrind" scheme="http://www.calvinneo.com/tags/valgrind/"/>
    
    <category term="工具" scheme="http://www.calvinneo.com/tags/工具/"/>
    
  </entry>
  
  <entry>
    <title>高并发场景</title>
    <link href="http://www.calvinneo.com/2023/01/12/high-concurrency/"/>
    <id>http://www.calvinneo.com/2023/01/12/high-concurrency/</id>
    <published>2023-01-12T15:20:37.000Z</published>
    <updated>2023-04-02T11:20:04.982Z</updated>
    
    <content type="html"><![CDATA[<p>WIP 介绍高并发场景下的 design 和 troubleshotting。</p><p>如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。</p><a id="more"></a><h1 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h1><p>这些工具主要是：</p><ol><li>O11y</li></ol><h2 id="Trace-任意函数的执行时间"><a href="#Trace-任意函数的执行时间" class="headerlink" title="Trace 任意函数的执行时间"></a>Trace 任意函数的执行时间</h2><p>该方案整理自某同事的 idea。</p><p>考虑下面的场景，我们需要查看某动态链接库 <code>/path/to/libtiflash_proxy.so</code> 中 <code>handle_pending_applies</code> 函数每次调用的耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perf probe --del <span class="string">'probe_libtiflash_proxy:*'</span></span><br><span class="line">BIN=/path/to/libtiflash_proxy.so</span><br><span class="line">TOKEN=handle_pending_applies</span><br><span class="line">ITER=0</span><br><span class="line">objdump <span class="variable">$BIN</span> --syms | grep <span class="variable">$TOKEN</span> | awk <span class="string">'&#123;print $6&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> -r tok ; <span class="keyword">do</span></span><br><span class="line">    ITER=$(expr <span class="variable">$ITER</span> + 1)</span><br><span class="line">    NAME=<span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$NAME</span>, <span class="variable">$TOKEN</span>, <span class="variable">$ITER</span>, <span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span>%<span class="built_in">return</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">perf record -e probe_libtiflash_proxy:\* -aR sleep 10</span><br><span class="line">perf script -s perf-script.py</span><br></pre></td></tr></table></figure><p><a href="/asset/highconcurrency/perf-script.py">附上 perf-script.py</a></p><h2 id="分析某段时刻的调用栈"><a href="#分析某段时刻的调用栈" class="headerlink" title="分析某段时刻的调用栈"></a>分析某段时刻的调用栈</h2><h2 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h2><h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>有一些典型的特征：</p><ol><li>时间偏移<br> 比如某些周期性的时间，如日志等，突然失去周期性，而在一瞬间打印了很多。</li></ol><p>注意，阻塞的原因有很多：</p><ol><li>不能正确解耦逻辑和 IO</li><li>队列积压，工作线程数偏少，导致对于每个任务而言，自己的等待时间会越来越大，似乎自己正在被阻塞</li></ol><h3 id="解耦-IO"><a href="#解耦-IO" class="headerlink" title="解耦 IO"></a>解耦 IO</h3><p>如下所示，一瞬间打印了很多发送消息的日志，实际上这是由于没有正确解耦消息发送逻辑和 IO 逻辑。导致 IO 阻塞了同一个线程，从而积攒了大量的消息。特别地，如果因此产生了消息延迟，可能会雪崩。<br>在这个场景下，虽然我们使用了 ClickHouse 的线程池来处理异步的 IO，但由于线程池的队列大小过小，并且也没有指定等待超时时间，所以我们以为的异步实际上变成了同步。<br><img src="/img/high-concurrency/many-simu-logs.png"></p><p>在解耦 IO 时，常常会将一些消息或者写入缓存到 Queue 或者 WriteBatch 以攒批 IO。对于这样的情况，在判断时首先需要检查对象是否已经被真的发送或者写入，因为这会导致后续完全不同的调查方向。</p><h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><p>可能发生在基于消息传输进行同步的系统中。不妨以 Raft 为例，如果因为一些阻塞的原因，一些发给 Follower 的 Append 消息没有被及时处理，很可能该 Follower 就会认为 Leader 挂了，从而发起选举。而选举会产生更多的消息，从而导致消息进一步积压，甚至会扩散到其他正常的 Region 中。</p><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p>在某个接口被高频调用时，</p><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>当一个程序异常退出，但看不到异常日志时，考虑：</p><ol><li>日志服务是否未初始化，或者该段异常日志被直接打印到标准错误</li><li>该程序是否由于异常信号/OOM退出<br> 可以从 return code 或者 dmesg 或者 coredump 或者 stderr 等信息来看。</li><li>该程序是否主动退出<br> 在一些程序中，会针对一些异常情况直接调用 exit 退出程序。此时可以用 gdb 去 hook <code>_exit</code> 函数来查看退出时的堆栈。</li></ol><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一些程序会基于时间片的算法来进行调度。一些实现会从任务队列中取出所有等待的任务，执行这些任务，再检查是否超出时间片。如果执行这些任务本身的时间就比较长，甚至可能占用多个时间片，这就会导致调度算法接近于失效。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h2 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h2><p>一般写入的阶段可以分为：</p><ol><li>write batch</li><li>WAL<br> 有的系统能容许一定的数据丢失，或者有其他手段起到 WAL 的作用，则可以去掉。</li><li>memtable</li><li>disk</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;WIP 介绍高并发场景下的 design 和 troubleshotting。&lt;/p&gt;
&lt;p&gt;如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="高并发" scheme="http://www.calvinneo.com/tags/高并发/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 const 的用法</title>
    <link href="http://www.calvinneo.com/2022/11/20/C++-const/"/>
    <id>http://www.calvinneo.com/2022/11/20/C++-const/</id>
    <published>2022-11-19T16:29:16.000Z</published>
    <updated>2022-11-20T08:08:47.176Z</updated>
    
    <content type="html"><![CDATA[<p>把<a href="/2016/12/22/C++-meta-programming/">文章</a>中的相关部分独立出来。</p><a id="more"></a><h1 id="const不是编译期常量"><a href="#const不是编译期常量" class="headerlink" title="const不是编译期常量"></a>const不是编译期常量</h1><p>在<a href="/2016/12/30/C++%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/">C++初始化方式</a>中已经提到常量<code>const</code>是不能在构造函数体中初始化的，但可以在初始化列表中可以进行初始化，对于常量数组或者标准库的<code>std::vector</code>等容器，现在可以使用花括号<code>{}</code>进行初始化。<br>需要额外说明的是<code>const</code>甚至不能作为模板参数等编译期常量使用。例如在MSVC2015中，下面的代码是无法通过编译的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    C(<span class="keyword">int</span> _x) :x(_x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a[c.x];</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是在<code>C.x</code>虽然是常量，但是要到运行期才能知道，这里应该使用的是<code>static const</code>或者<code>constexpr</code>，<code>const</code>修饰符实际上的意义更接近于<code>readonly</code>。如果说<code>const</code>能够“节省空间”，那是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="noopener">const对象实际上并不发生复制</a>，但只<code>const</code>修饰的类成员仍然是占空间的。</p><h1 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h1><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="noopener">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;文章&lt;/a&gt;中的相关部分独立出来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决 bindgen 的一个奇怪问题</title>
    <link href="http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/"/>
    <id>http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/</id>
    <published>2022-10-31T12:20:33.000Z</published>
    <updated>2023-04-01T12:24:43.992Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。</p><a id="more"></a><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><ol><li>没有问题的版本(旧版本)<br> <a href="https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a" target="_blank" rel="noopener">https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a</a></li><li>有问题的版本(新版本)<br> <a href="https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen" target="_blank" rel="noopener">https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen</a></li></ol><p>具体报错如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Finished dev [unoptimized] target(s) <span class="keyword">in</span> <span class="number">2.51</span>s</span><br><span class="line">     Running `target<span class="regexp">/debug/</span>gen_proxy_ffi`</span><br><span class="line"><span class="string">dyld:</span> Library not <span class="string">loaded:</span> <span class="meta">@rpath</span>/libclang.dylib</span><br><span class="line">  Referenced <span class="string">from:</span> <span class="regexp">/Users/</span>calvin<span class="regexp">/tidb-engine-ext/</span>target<span class="regexp">/debug/</span>gen_proxy_ffi</span><br><span class="line"><span class="symbol">  Reason:</span> image not found</span><br><span class="line"><span class="string">zsh:</span> abort      cargo run --<span class="keyword">package</span> gen-proxy-ffi --bin gen_proxy_ffi</span><br></pre></td></tr></table></figure><p>首先，这两个版本之间的区别是啥呢？主要两点：</p><ol><li>将 workspace 改成 virtual<br> 也就是有 workspace 段，但是没有 package 段。</li><li>将 cargo dependency 从 path 改成 git</li></ol><p>它们都不涉及 gen-proxy-ffi 这个 crate。</p><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><h2 id="深入了解情况"><a href="#深入了解情况" class="headerlink" title="深入了解情况"></a>深入了解情况</h2><p>“dyld: Library not loaded” 这个错误表示 gen-proxy-ffi 依赖 libclang 这个库，也就是所谓的 clang-sys，并且要在运行期加载，但我们并没有在运行期找到这个库。我们可以通过类似 ldd 的指令来确认这一点。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">otool -L target/debug/gen_proxy_ffi</span><br><span class="line">target/debug/<span class="symbol">gen_proxy_ffi:</span></span><br><span class="line"> @rpath/libclang.dylib (compatibility version <span class="number">1.0</span>.<span class="number">0</span>, current version <span class="number">1205.0</span>.<span class="number">22</span>)</span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libSystem</span>.<span class="title">B</span>.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 1.0.0, <span class="title">current</span> <span class="title">version</span> 1292.100.5)</span></span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libiconv</span>.2.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 7.0.0, <span class="title">current</span> <span class="title">version</span> 7.0.0)</span></span><br><span class="line"> /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libresolv</span>.9.<span class="title">dylib</span> (<span class="title">compatibility</span> <span class="title">version</span> 1.0.0, <span class="title">current</span> <span class="title">version</span> 1.0.0)</span></span><br></pre></td></tr></table></figure><p>从 <a href="https://github.com/rust-lang/rust-bindgen/tree/v0.57.0" target="_blank" rel="noopener">https://github.com/rust-lang/rust-bindgen/tree/v0.57.0</a> 可以看到，这个项目确实依赖 clang-sys</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clang-sys</span> = &#123; version = <span class="string">"1"</span>, features = [<span class="string">"clang_6_0"</span>] &#125;</span><br></pre></td></tr></table></figure><p>所以我们的问题是，为啥旧版本能跑呢？</p><h2 id="通过-unit-graph-分析"><a href="#通过-unit-graph-分析" class="headerlink" title="通过 unit-graph 分析"></a>通过 unit-graph 分析</h2><p>可以通过<code>--unit-graph</code>命令来检查编译时实际的依赖</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">cargo</span> <span class="comment">build</span> <span class="literal">-</span><span class="comment">Z</span> <span class="comment">unstable</span><span class="literal">-</span><span class="comment">options</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">unit</span><span class="literal">-</span><span class="comment">graph</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">package</span> <span class="comment">gen</span><span class="literal">-</span><span class="comment">proxy</span><span class="literal">-</span><span class="comment">ffi</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">bin</span> <span class="comment">gen_proxy_ffi</span></span><br></pre></td></tr></table></figure><p>通过下面的代码可以找到所有的 bindgen。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bindgens = [v <span class="keyword">for</span> v <span class="keyword">in</span> j[<span class="string">'units'</span>] <span class="keyword">if</span> v[<span class="string">'pkg_id'</span>].startswith(<span class="string">"bindgen"</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> bindgens:</span><br><span class="line">    print(x)</span><br><span class="line">    print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>对于旧版本，我们发现有两个 bindgen 的项目。其中一个 bindgen 依赖 index 为 4 和 11 的两个项目，而另一个则不依赖任何项目。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">False</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">4</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">11</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'run-custom-build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里很多 extern_crate_name 都是 build_script_build，具体看不出究竟是什么。但可以通过 index 直接对应到 “units” 这个数组的下标。检查发现，其中包含了 clang-sys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="keyword">None</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">False</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [<span class="string">u'clang_3_5'</span>, <span class="string">u'clang_3_6'</span>, <span class="string">u'clang_3_7'</span>, <span class="string">u'clang_3_8'</span>, <span class="string">u'clang_3_9'</span>, <span class="string">u'clang_4_0'</span>, <span class="string">u'clang_5_0'</span>, <span class="string">u'clang_6_0'</span>], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">12</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'run-custom-build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'clang-sys 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'custom-build'</span>], <span class="string">u'name'</span>: <span class="string">u'build-script-build'</span>, <span class="string">u'doc'</span>: <span class="keyword">False</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/clang-sys-1.1.1/build.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2015'</span>, <span class="string">u'doctest'</span>: <span class="keyword">False</span>, <span class="string">u'test'</span>: <span class="keyword">False</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'bin'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>对于新版本，发现只有一个 bindgen 项目，可以看到它会依赖 clang_sys。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">u'profile'</span>: &#123;<span class="string">u'name'</span>: <span class="string">u'dev'</span>, <span class="string">u'codegen_units'</span>: <span class="number">4</span>, <span class="string">u'debug_assertions'</span>: <span class="keyword">True</span>, <span class="string">u'debuginfo'</span>: <span class="number">0</span>, <span class="string">u'codegen_backend'</span>: <span class="keyword">None</span>, <span class="string">u'rpath'</span>: <span class="keyword">False</span>, <span class="string">u'overflow_checks'</span>: <span class="keyword">False</span>, <span class="string">u'incremental'</span>: <span class="keyword">False</span>, <span class="string">u'strip'</span>: <span class="string">u'none'</span>, <span class="string">u'opt_level'</span>: <span class="string">u'0'</span>, <span class="string">u'split_debuginfo'</span>: <span class="keyword">None</span>, <span class="string">u'lto'</span>: <span class="string">u'false'</span>, <span class="string">u'panic'</span>: <span class="string">u'unwind'</span>&#125;, <span class="string">u'features'</span>: [], <span class="string">u'platform'</span>: <span class="keyword">None</span>, <span class="string">u'dependencies'</span>: [&#123;<span class="string">u'index'</span>: <span class="number">3</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'build_script_build'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">5</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'bitflags'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">9</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'cexpr'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">10</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'clang_sys'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">18</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'lazy_static'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">19</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'lazycell'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">29</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'peeking_take_while'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">30</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'proc_macro2'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">33</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'quote'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">34</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'regex'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">36</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'rustc_hash'</span>&#125;, &#123;<span class="string">u'index'</span>: <span class="number">38</span>, <span class="string">u'noprelude'</span>: <span class="keyword">False</span>, <span class="string">u'public'</span>: <span class="keyword">False</span>, <span class="string">u'extern_crate_name'</span>: <span class="string">u'shlex'</span>&#125;], <span class="string">u'mode'</span>: <span class="string">u'build'</span>, <span class="string">u'pkg_id'</span>: <span class="string">u'bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)'</span>, <span class="string">u'target'</span>: &#123;<span class="string">u'kind'</span>: [<span class="string">u'lib'</span>], <span class="string">u'name'</span>: <span class="string">u'bindgen'</span>, <span class="string">u'doc'</span>: <span class="keyword">True</span>, <span class="string">u'src_path'</span>: <span class="string">u'/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/src/lib.rs'</span>, <span class="string">u'edition'</span>: <span class="string">u'2018'</span>, <span class="string">u'doctest'</span>: <span class="keyword">True</span>, <span class="string">u'test'</span>: <span class="keyword">True</span>, <span class="string">u'crate_types'</span>: [<span class="string">u'lib'</span>]&#125;&#125;</span><br></pre></td></tr></table></figure><p>至此可以得出猜测，老版本之所以能运行原因是 gen-proxy-ffi 链接到了不依赖 clang-sys 的 bindgen 上了。</p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>可为什么依赖 clang-sys 的 bindgen 可以实际上不依赖 clang-sys 呢？为此，我们首先怀疑 build.rs，可并没有发现什么异常。</p><p>然后尝试从源码中搜索 clang 关键词，发现了下面的代码。似乎我们可以在代码运行过程中，用类似 dlopen 的方式懒加载 libclang。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"runtime"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ensure_libclang_is_loaded</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> clang_sys::is_loaded() &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX (issue #350): Ensure that our dynamically loaded `libclang`</span></span><br><span class="line">    <span class="comment">// doesn't get dropped prematurely, nor is loaded multiple times</span></span><br><span class="line">    <span class="comment">// across different threads.</span></span><br><span class="line"></span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> LIBCLANG: std::sync::Arc&lt;clang_sys::SharedLibrary&gt; = &#123;</span><br><span class="line">            clang_sys::load().expect(<span class="string">"Unable to find libclang"</span>);</span><br><span class="line">            clang_sys::get_library().expect(</span><br><span class="line">                <span class="string">"We just loaded libclang and it had better still be \</span></span><br><span class="line"><span class="string">                 here!"</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clang_sys::set_library(<span class="literal">Some</span>(LIBCLANG.clone()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是恍然大悟，如果指定让程序懒加载 libclang，但实际上我们又不会真的去用到它，那样老版本代码确实可以这么很苟地运行。因此我们去掉了<code>default-features = false</code>，结果运行正常了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中类型和类型转换</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-type-cast/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-type-cast/</id>
    <published>2022-10-25T12:06:10.000Z</published>
    <updated>2023-01-24T14:20:36.013Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++ 中的类型转换。<br>部分内容来自<a href="/2016/12/22/C++-meta-programming/">C++元编程</a>。隐式转换部分和重载决议有关，需要结合起来看。</p><a id="more"></a><h1 id="涉及-type-的一些概念"><a href="#涉及-type-的一些概念" class="headerlink" title="涉及 type 的一些概念"></a>涉及 type 的一些概念</h1><h2 id="Incomplete-type"><a href="#Incomplete-type" class="headerlink" title="Incomplete type"></a>Incomplete type</h2><ol><li>void 以及其 cv-qualified 形式</li><li>incompletely-defined object type<br> 一个 class 被声明(比如一个前向声明)，却没有定义。<br> bound 未知的数组。<br> imcomplete type 构成的数组。<br> enum，从它的声明，到它的 underlying type 被确定期间。</li></ol><p>这里说明一下，bound 未知的数组未必是 flex 数组。它可能是如下面这种 extern 形式定义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x[];      <span class="comment">// the type of x is "array of unknown bound of int"</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is "array of 3 int"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure><p>Incomplete type 经常让人头大，需要各种头文件魔法或者 pimpl 来解决。</p><p>在下列情况下，需要类型是 Complete 的：</p><ol><li>TODO</li></ol><h2 id="typd-id"><a href="#typd-id" class="headerlink" title="typd-id"></a>typd-id</h2><p>我们可以通过 class/union/enum/typedef/using(type alias) 这些方式定义一个具名的类型。但是在 C++ 中，我们经常使用那些不具名的类型，例如下面的情况。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is "int (*(*[2])())[3]"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id "void(int)"</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">auto</span>(<span class="keyword">int</span>) -&gt; <span class="keyword">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;); <span class="comment">// type-id is "std::vector&lt;int&gt;"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="keyword">sizeof</span>(struct &#123; <span class="keyword">int</span> x; &#125;);   <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = struct &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">static</span> <span class="keyword">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</span><br></pre></td></tr></table></figure><p>此外，RTTI 机制还提供了一个 typeid 运算符(不是函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>&amp;) != <span class="keyword">typeid</span>(<span class="keyword">int</span>*));</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><p>显式转换有几种类型：</p><p><code>(new-type) expr</code>型。这是 C-style 的，C++ 会按顺序尝试：</p><ol><li>const_cast</li><li>static_cast(增强的)<br> 注意，子类的指针或者引用，可以被转成无歧义的基类，即使基类不可访问。对于成员函数的指针也同样适用</li><li>static_cast(增强的) + const_cast</li><li>reinterpret_cast</li><li>reinterpret_cast + const_cast</li></ol><p><code>new-type (expr)</code>型。</p><p>需要注意，这种 function-style cast expression 容易和声明产生歧义。此时，这些歧义都会被视作声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">M</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">L</span> &#123;</span> L(M&amp;); &#125;;</span><br><span class="line"> </span><br><span class="line">M n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    M(m);    <span class="comment">// declaration, equivalent to M m;</span></span><br><span class="line">    L(n);    <span class="comment">// ill-formed declaration</span></span><br><span class="line">    L(l)(m); <span class="comment">// still a declaration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【C++11起】<code>new-type {expr}</code>型。</p><p>一个显式类型转换的类型是什么呢？</p><ol><li>对于 lvalue reference，结果是一个 lvalue</li><li>对于函数的 rvalue reference，结果是一个 lvalue</li><li>对于 rvalue reference，结果是一个 xvalue</li><li>对于其他情况，结果是一个 prvalue</li></ol><h1 id="Value-categories"><a href="#Value-categories" class="headerlink" title="Value categories"></a>Value categories</h1><p>为了介绍隐式类型转换，介绍<a href="/2017/02/11/C++-rvalue/">Value categories</a>。</p><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>一个隐式类型转换序列包含：</p><ol><li>一系列 standard conversion sequence</li><li>可选的 user-defined conversion</li><li>一系列 standard conversion sequence</li></ol><p><img src="/img/cpp_meta_programming/implicit_conversion_cat11.jpg"></p><p>When considering the argument to a constructor or to a user-defined conversion function, only a standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one non-class type to another non-class type, only a standard conversion sequence is allowed.</p><p>Standard conversion 的顺序：</p><ol><li>zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion;</li><li>zero or one numeric promotion or numeric conversion;</li><li>【C++17】zero or one function pointer conversion;</li><li>zero or one qualification conversion.</li></ol><p>一个 user-defined conversion 由0或1个单参数的类型转换构造函数，或者一个 non-explicit conversion function call 构成。</p><p>An expression e is said to be implicitly convertible to T2 if and only if T2 can be copy-initialized from e, that is the declaration T2 t = e; is well-formed (can be compiled), for some invented temporary t. Note that this is different from direct initialization (T2 t(e)), where explicit constructors and conversion functions would additionally be considered.</p><h2 id="decay"><a href="#decay" class="headerlink" title="decay"></a>decay</h2><p>首先来看一下什么是decay。例如，对于数组<code>T a[n]</code>，除了<code>sizeof</code>、<code>alignof</code>、引用限定符<code>&amp;</code>以及字符串常量等<a href="https://stackoverflow.com/questions/16570716/c-warning-format-s-expects-type-char-but-argument-2-has-type-char" target="_blank" rel="noopener">少数情形</a>外，<code>a</code>出现时会被decay成指向T的指针。例如下面代码往<code>char s[N]</code>数组中读入了数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br></pre></td></tr></table></figure><p>而很多人会误写为以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;s);</span><br></pre></td></tr></table></figure><p>此时，<code>s</code>的类型实际上是<code>char (*) [N]</code>（pointer to an array of char），而<code>scanf</code>希望接受到的是<code>char *</code>（pointer to char）类型。</p><h2 id="各种-convertion-类型"><a href="#各种-convertion-类型" class="headerlink" title="各种 convertion 类型"></a>各种 convertion 类型</h2><h3 id="Contextual-conversions"><a href="#Contextual-conversions" class="headerlink" title="Contextual conversions"></a>Contextual conversions</h3><p>Case1: 【C++11】从 T 到 bool 的转换。如果 <code>bool t(e)</code> 是 well-formed，也就是说存在 <code>explicit T::operator bool() const;</code>。在下列场景中，这样的表达式 e 会被转换为 bool：</p><ol><li>if、while、for 的条件</li><li>逻辑运算符</li><li>三目运算符的条件</li><li>static_assert</li><li>noexcept</li><li>【C++20】explicit 表达式</li></ol><p>Case2: In the following contexts, a context-specific type T is expected, and the expression e of class type E is only allowed if：</p><ol><li>【until C++14】E has a single non-explicit (since C++11) user-defined conversion function to an allowable type.</li><li>【since C++14】对于 E 的所有的 non-explicit conversion functions，如果它们的返回类型是都是 T，或者带 CV 和引用修饰的 T，这样的 e 可以 implicitly convertible to T。</li></ol><p>Such expression e is said to be contextually implicitly converted to the specified type T. 【C++11】Note that explicit conversion functions are not considered, even though they are considered in contextual conversions to bool.</p><ol><li>the argument of the delete-expression (T is any object pointer type);</li><li>integral constant expression, where a literal class is used (T is any integral or unscoped (since C++11) enumeration type, the selected user-defined conversion function must be constexpr);</li><li>the controlling expression of the switch statement (T is any integral or enumeration type).</li></ol><h3 id="Value-transformations"><a href="#Value-transformations" class="headerlink" title="Value transformations"></a>Value transformations</h3><h4 id="Lvalue-to-rvalue-conversion"><a href="#Lvalue-to-rvalue-conversion" class="headerlink" title="Lvalue-to-rvalue conversion"></a>Lvalue-to-rvalue conversion</h4><p>不考虑旧版本，从 C++11 开始说。<br>一个非 function 且非 array 类型的 glvalue T 可以被隐式转换为一个 prvalue。此时：</p><ol><li>如果 T 不是 class type, 那么这个 prvalue 的类型是 T，但会去掉 cv 限定符。</li><li>如果 T 是 class type，那么这个 prvalue 的类型是 T。</li></ol><p>If an lvalue-to-rvalue conversion from an incomplete type is required by a program, that program is ill-formed.</p><p>When an lvalue-to-rvalue conversion is applied to an expression E, the value contained in the referenced object is not accessed if:</p><ol><li>E is not <a href="https://en.cppreference.com/w/cpp/language/expressions#Potentially-evaluated_expressions" target="_blank" rel="noopener">potentially evaluated</a>，也就是它是 unevaluated operand，或者 unevaluated operand 中的子表达式。</li><li>the evaluation of E results in the evaluation of a member Ex of the set of potential results of E, and Ex names a variable x that is not <a href="https://en.cppreference.com/w/cpp/language/definition#ODR-use" target="_blank" rel="noopener">odr-used</a> by Ex.</li></ol><h4 id="Array-to-pointer-conversion"><a href="#Array-to-pointer-conversion" class="headerlink" title="Array-to-pointer conversion"></a>Array-to-pointer conversion</h4><p>An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be implicitly converted to a prvalue of type “pointer to T”.<br>【C++17】If the array is a prvalue, temporary materialization occurs.<br>The resulting pointer refers to the first element of the array (see array to pointer decay for details)</p><h5 id="temporary-materialization"><a href="#temporary-materialization" class="headerlink" title="temporary materialization"></a>temporary materialization</h5><p>A prvalue of any complete type T can be converted to an xvalue of the same type T.<br>This conversion initializes a temporary object of type T from the prvalue by evaluating the prvalue with the temporary object as its result object, and produces an xvalue denoting the temporary object. </p><p>If T is a class or array of class type, it must have an accessible and non-deleted destructor.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> m; &#125;;</span><br><span class="line"><span class="keyword">int</span> i = S().m; <span class="comment">// member access expects glvalue as of C++17;</span></span><br><span class="line">               <span class="comment">// S() prvalue is converted to xvalue</span></span><br></pre></td></tr></table></figure><h4 id="Function-to-pointer-conversion"><a href="#Function-to-pointer-conversion" class="headerlink" title="Function-to-pointer conversion"></a>Function-to-pointer conversion</h4><h3 id="Numeric-promotions"><a href="#Numeric-promotions" class="headerlink" title="Numeric promotions"></a>Numeric promotions</h3><h4 id="Integral-promotion"><a href="#Integral-promotion" class="headerlink" title="Integral promotion"></a>Integral promotion</h4><h4 id="Floating-point-promotion"><a href="#Floating-point-promotion" class="headerlink" title="Floating-point promotion"></a>Floating-point promotion</h4><h3 id="Numeric-conversions"><a href="#Numeric-conversions" class="headerlink" title="Numeric conversions"></a>Numeric conversions</h3><h4 id="Integral-conversions"><a href="#Integral-conversions" class="headerlink" title="Integral conversions"></a>Integral conversions</h4><h4 id="Floating-point-conversions"><a href="#Floating-point-conversions" class="headerlink" title="Floating-point conversions"></a>Floating-point conversions</h4><h4 id="Floating–integral-conversions"><a href="#Floating–integral-conversions" class="headerlink" title="Floating–integral conversions"></a>Floating–integral conversions</h4><h4 id="Pointer-conversions"><a href="#Pointer-conversions" class="headerlink" title="Pointer conversions"></a>Pointer conversions</h4><h4 id="Pointer-to-member-conversions"><a href="#Pointer-to-member-conversions" class="headerlink" title="Pointer-to-member conversions"></a>Pointer-to-member conversions</h4><h4 id="Boolean-conversions"><a href="#Boolean-conversions" class="headerlink" title="Boolean conversions"></a>Boolean conversions</h4><h3 id="Qualification-conversions"><a href="#Qualification-conversions" class="headerlink" title="Qualification conversions"></a>Qualification conversions</h3><h3 id="【C-17】Function-pointer-conversions"><a href="#【C-17】Function-pointer-conversions" class="headerlink" title="【C++17】Function pointer conversions"></a>【C++17】Function pointer conversions</h3><h2 id="重载决议的顺序-rank"><a href="#重载决议的顺序-rank" class="headerlink" title="重载决议的顺序(rank)"></a>重载决议的顺序(rank)</h2><p>在<a href="https://en.cppreference.com/w/cpp/language/overload_resolution" target="_blank" rel="noopener">重载决议</a>时，采取下列顺序，可参考 Ranking of implicit conversion sequences 章节。<br>任何一个 standard conversion sequence 被划分为下面三个 rank：</p><ol><li><p>精确匹配<br> 此时，不需要进行任何的转换。<br> 下面列举出了几种情况：</p><ol><li>无转换</li><li>Lvalue-to-rvalue conversion</li><li>【C++17】function pointer conversion</li><li>user-defined conversion of class type to the same class</li><li>Qualification conversions，即限定符转换<br> 我们可以为任意类型加上CV限定符。对于多重指针来说，前面的重数的限制要高于后面重数的限制，如 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>** p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** p1 = p; <span class="comment">// error: level 2 more cv-qualified but level 1 is not const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> * p2 = p; <span class="comment">// OK: level 2 more cv-qualified and const added at level 1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Promotion<br> 即Numeric promotions，包含Integral promotion和Floating-point promotion<br> 这里注意，<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">非promotion的整数之间转换都作为conversion</a>，如<code>char -&gt; int</code></p></li><li><p>Conversion</p><ol><li>integral conversion</li><li>floating-point conversion</li><li>floating-integral conversion</li><li>pointer conversion</li><li>pointer-to-member conversion</li><li>boolean conversion</li><li>user-defined conversion of a derived class to its base</li></ol></li></ol><p>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to three conversions)</p><p>注意能进行隐式类型转换<strong>并不意味着类型相同</strong>，所以使用<code>std::is_same</code>进行的判断都是false，例如下面的代码输出都是false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/explicit_cast" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/explicit_cast</a></li><li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li><li><a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/type</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++ 中的类型转换。&lt;br&gt;部分内容来自&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;C++元编程&lt;/a&gt;。隐式转换部分和重载决议有关，需要结合起来看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto关键字的用法</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-auto/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-auto/</id>
    <published>2022-10-25T11:06:10.000Z</published>
    <updated>2022-10-25T16:04:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>auto 的作用：</p><ol><li>对于变量，自动推导其类型</li><li>【C++14起】对于函数，自动推导返回值</li><li>【C++17起】对于非类型模板参数，自动推导其类型</li></ol><p>有两种用法<br>【C++11起】auto<br>基于<a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts" target="_blank" rel="noopener">template type deduction</a>进行推导。</p><p>在推导变量类型时，这种推导方式会将每个 auto 出现的地方代换做一个模板参数 U。U 的类型可以从等号左边的 P(<code>下面的const auto&amp;</code>) 和等号右边的 A(下面的<code>1+2</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// P = const U&amp;, A = 1 + 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">const</span> <span class="title">U</span>&amp; <span class="title">u</span>) &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = f(<span class="number">1</span> + <span class="number">2</span>); <span class="comment">// U = int, so the type of x is const int&amp;</span></span><br></pre></td></tr></table></figure><p>特别地，对于 copy-list-initialization 的情况，auto 要被代换为 <code>initializer_list&lt;U&gt;</code>。U 的类型同样可以从 P 和 A 推导出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = &#123;<span class="number">13</span>&#125;; <span class="comment">// P = std::initializer_list&lt;U&gt;, A = &#123;13&#125;:</span></span><br><span class="line">               <span class="comment">// deduced U = int, the type of l is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x1 = &#123;<span class="number">3</span>&#125;; <span class="comment">// x1 is std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对于 direct-list-initialization 的情况，大括号内只允许有一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// error: not a single element</span></span><br><span class="line"><span class="keyword">auto</span> x3&#123;<span class="number">3</span>&#125;;    <span class="comment">// x3 is int</span></span><br><span class="line">               <span class="comment">// (before N3922 x2 and x3 were both std::initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure><p>在推导返回值类型时，同样用模板参数 U 去替换。这个时候 A 就是 return 后面跟的表达式。如果有多个 return，那么它们推导出来必须是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// P = auto, A = 42:</span></span><br><span class="line">                        <span class="comment">// deduced U = int, the return type of f is int</span></span><br></pre></td></tr></table></figure><p>【C++14起】decltype(auto)<br>类型是<code>decltype(expr)</code>，expr 就是用来初始化的表达式。它不走上面的 template type deduction 逻辑。<br>那么这个到底有啥用呢？<a href="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto" target="_blank" rel="noopener">举几个例子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">auto</span> x3a = i;                  <span class="comment">// decltype(x3a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x3d = i;        <span class="comment">// decltype(x3d) is int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x4a = (i);                <span class="comment">// decltype(x4a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x4d = (i);      <span class="comment">// decltype(x4d) is int&amp;</span></span><br></pre></td></tr></table></figure><p>如果一个函数返回右值引用，则其<code>decltype(auto)</code>是右值引用，但<code>auto</code>推导为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x5a = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5a), <span class="keyword">int</span>&gt;::value, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x5b = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5b), <span class="keyword">int</span>&amp;&amp;&gt;::value, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>对于大括号的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x6a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;           <span class="comment">// decltype(x6a) is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x6d = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// error, &#123; 1, 2 &#125; is not an expression</span></span><br></pre></td></tr></table></figure><p>此外，<code>decltype(auto)</code>不能有其他的修饰了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *x7a = &amp;i;                <span class="comment">// decltype(x7a) is int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)*x7d = &amp;i;       <span class="comment">// error, declared type is not plain decltype(auto)</span></span><br></pre></td></tr></table></figure><p>【C++23】auto 可以被用作显式类型转换。如<code>auto (expr)</code>和<code>auto {expr}</code></p><p>注意，在 trailing return type 中，auto 会在开头来开始这个声明。但它同样可以作为 placeholder 出现在尾部，虽然我也不知道意义在哪里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> (*p)() -&gt; <span class="keyword">int</span>; <span class="comment">// declares p as pointer to function returning int</span></span><br><span class="line"><span class="keyword">auto</span> (*q)() -&gt; <span class="keyword">auto</span> = p; <span class="comment">// declares q as pointer to function returning T</span></span><br><span class="line">                         <span class="comment">// where T is deduced from the type of p</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/auto" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/auto</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础机制分析</title>
    <link href="http://www.calvinneo.com/2022/10/15/redis-common/"/>
    <id>http://www.calvinneo.com/2022/10/15/redis-common/</id>
    <published>2022-10-15T15:52:20.000Z</published>
    <updated>2022-10-29T07:34:18.735Z</updated>
    
    <content type="html"><![CDATA[<p>因为原<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：</p><ol><li>redisDb，以及在这上面的增删改查</li><li>Redis的expire和evict机制</li><li>Redis的事件机制</li><li>Redis的主从复制(一部分)<br> 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。<br> 本文介绍的部分比如propagate机制。</li></ol><p>本文中不介绍的是，它们在系列的其他文章中讲解：</p><ol><li>Redis的对象实现</li><li>Redis Sentinel</li><li>Redis Cluster</li><li>Redis AOF/RDB</li></ol><a id="more"></a><h1 id="Redis源码结构"><a href="#Redis源码结构" class="headerlink" title="Redis源码结构"></a>Redis源码结构</h1><p>在3.0版本中，redis的主要结构都定义在redis.h中，在新版本中，它们被放到了server.h中。</p><p>我们主要介绍</p><ol><li>一些常用的类<ol><li>redisServer</li><li>redisDb</li><li>redisObject<br> 包含添加对象的逻辑</li></ol></li><li>删除逻辑<br> 包含对同步删除和异步删除的讨论。</li><li>查找逻辑</li><li>expire</li><li>evict</li><li>propagate</li><li>事件机制</li><li>内存管理</li></ol><h1 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h1><p>这个章节中介绍Redis数据库顶层键的架构和增删改查的实现，主要包括：</p><h2 id="redisDb类"><a href="#redisDb类" class="headerlink" title="redisDb类"></a>redisDb类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间，字典的键为键，字典的值为过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 用来服务诸如BLPOP的命令，记录目前被阻塞的键 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均TTL，统计信息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>可以发现，<code>redisDb</code>本身就依赖<code>dict</code>和<code>list</code>等Redis底层结构的实现，说明Redis的复用性还是很好的。</p><h2 id="client类"><a href="#client类" class="headerlink" title="client类"></a>client类</h2><p>client类对应了3.0版本中的<code>redisClient</code>类。因为Redis对IO是多路复用的，所以需要为每个客户端连接维护一个状态，所以<code>client</code>实际上类似于session一样，是在服务器端维护的一个状态。而真正的Redis客户端定义在redis-cli.c这个文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="keyword">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br></pre></td></tr></table></figure><h2 id="redisServer类"><a href="#redisServer类" class="headerlink" title="redisServer类"></a>redisServer类</h2><p><code>server</code>是一个全局对象，它的类型是<code>redisServer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span> <span class="comment">/* Server global state */</span></span><br></pre></td></tr></table></figure><h1 id="Redis基础类"><a href="#Redis基础类" class="headerlink" title="Redis基础类"></a>Redis基础类</h1><h2 id="增删改查涉及的系统梳理"><a href="#增删改查涉及的系统梳理" class="headerlink" title="增删改查涉及的系统梳理"></a>增删改查涉及的系统梳理</h2><ol><li>DB部分<br> 更新dirty</li><li>Cluster部分</li><li>事件部分<br> signalModifiedKey：包含通知WATCH列表、通知客户端更新缓存<br> notifyKeyspaceEvent：通过PUBLUSH发送消息</li><li>主从复制/持久化部分<br> propagate对应命令（在call中处理）</li><li>Module部分</li></ol><h2 id="Redis-Object"><a href="#Redis-Object" class="headerlink" title="Redis Object"></a>Redis Object</h2><p>诸如<code>dict</code>、<code>sds</code>之类的对象，在db层面实际上是用<code>redisObject</code>封装的，需要的时候通过<code>robj-&gt;ptr</code>获取实际需要的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 由OBJ_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 由OBJ_ENCODING_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure><p>Redis对象的类型是用<code>OBJ_</code>宏来列出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The "module" object type is a special one that signals that the object</span></span><br><span class="line"><span class="comment"> * is one directly managed by a Redis module. In this case the value points</span></span><br><span class="line"><span class="comment"> * to a moduleValue struct, which contains the object value (which is only</span></span><br><span class="line"><span class="comment"> * handled by the module itself) and the RedisModuleType struct which lists</span></span><br><span class="line"><span class="comment"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span></span><br><span class="line"><span class="comment"> * free the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span></span><br><span class="line"><span class="comment"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span></span><br><span class="line"><span class="comment"> * in order to dispatch the loading to the right module, plus a 10 bits</span></span><br><span class="line"><span class="comment"> * encoding version. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br></pre></td></tr></table></figure><p>Redis对象实际使用的内部结构是用<code>OBJ_ENCODING_</code>宏来表示的，如前文所列举的，同一个对象可能有不同的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">// OBJ_ENCODING_RAW是普通的SDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="comment">// embstr是对短字符串的一种优化编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>有两种特殊的引用计数值：</p><ol><li><code>OBJ_SHARED_REFCOUNT</code><br> 由<code>makeObjectShared</code>函数生成，在这种情况下这个对象是immutable的，因此可以不加锁地进行访问。这种对象也不受<code>incrRefCount</code>/<code>decrRefCount</code>控制。<br> 注意，这种对象设为immutable是合理的，它的一个通常作用是共享小整数对象，例如Redis会共享0到9999。</li><li><code>OBJ_STATIC_REFCOUNT</code><br> 一般由<code>initStaticStringObject</code>宏生成。看上去这个一般用在在栈上面分配的临时对象的refcount，我对此也不是很确定。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX     <span class="comment">/* Global object never destroyed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STATIC_REFCOUNT (INT_MAX-1) <span class="comment">/* Object allocated in the stack. */</span></span></span><br><span class="line"><span class="comment">// 第一个有特殊含义的refcount值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT</span></span><br></pre></td></tr></table></figure></li></ol><p>一般来说，使用引用计数可能存在循环引用的问题。Redis巧妙地避免了这个问题，首先在Redis的所有<code>redisObject</code>里面，只有String会被嵌入到其他类型中，也就是说ZSET等其他的数据类型不会互相引用（在Geo等新数据结构里面也是这样的么？）。而Redis对String类型引入对象共享机制，保证了不会产生互相引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt; OBJ_FIRST_SPECIAL_REFCOUNT) &#123;</span><br><span class="line">        o-&gt;refcount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount == OBJ_SHARED_REFCOUNT) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do: this refcount is immutable. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;refcount == OBJ_STATIC_REFCOUNT) &#123;</span><br><span class="line">            serverPanic(<span class="string">"You tried to retain an object allocated in the stack"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decrRefCount</code>还负责销毁对象，步骤是<code>freeXXXObject</code>，然后在<code>zfree</code>。前者用来释放<code>o-&gt;ptr</code>指向的对象的内存，后者用来释放<code>o</code>的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解<code>incr/decrRefCount</code>，如果我们创建或者复制一个对象，就要incr，如果我们要删除一个对象就要decr。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过<code>createObject</code>创建对象，<code>refcount</code>设为1。<code>encoding</code>设为<code>OBJ_ENCODING_RAW</code>，也就是普通SDS字符串。传入的<code>type</code>是<code>OBJ_</code>宏的某个特定值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在创建完对象后，还需要通过<code>dbAdd</code>将它插入到数据库里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the key to the DB. It's up to the caller to increment the reference</span></span><br><span class="line"><span class="comment"> * counter of the value if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The program is aborted if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,retval == DICT_OK);</span><br><span class="line">    signalKeyAsReady(db, key, val-&gt;type);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key-&gt;ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象装箱拆箱"><a href="#对象装箱拆箱" class="headerlink" title="对象装箱拆箱"></a>对象装箱拆箱</h3><p>这个都是返回一个“新”对象，这里“新”的意思是在使用完这个对象都应该<code>decrRefCount</code>。<br>如果是原生encoding储存的，就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果使用SDS保存的整数，实际上里面是个long long，那么就需要先<code>ll2string</code>把这个转换成字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h2><h3 id="redisCommand对象"><a href="#redisCommand对象" class="headerlink" title="redisCommand对象"></a>redisCommand对象</h3><p>redisCommand对象有新旧很多种版本，新旧版本中存在一些区别，例如<code>sflag</code>的内容，我们以新版本为主。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags; <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * 通常用在Redis Cluster转发过程中 */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br></pre></td></tr></table></figure><p>command id，是从0开始递增的，作用是检查ACL。一个connection在执行命令前，服务器先要检查第<code>id</code>位有没有设置，如果设置了，说明这个connection有对应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释如下：</p><ol><li><code>sflags</code>是字符串格式的，表示这个命令的一些特性<br> <a href="https://segmentfault.com/a/1190000017104165" target="_blank" rel="noopener">例如</a>：<br> write对应CMD_WRITE<br> read-only对应CMD_READONLY</li><li><code>flags</code>是通过<code>populateCommandTableParseFlags</code><strong>从<code>sflags</code>生成的二进制表示</strong>。详见server.h中的<code>CMD_</code>定义，我们在下面会讲解。</li><li>下面是key三元组：<code>firstkey</code>表示第一个key参数的位置，<code>lastkey</code>表示最后一个key参数的位置，<code>keystep</code>表示key参数步长。通过上面三个参数，可以拿到所有的key。通常发生在<code>getKeysFromCommand</code>到<code>getKeysUsingCommandTable</code>函数调用链中。引入这个三元组的目的是有一些指令（如<code>mset</code>和<code>msetnx</code>的<code>keystep</code>取2）是支持在一个命令中对多个key/value对进行赋值的。我们需要注意的是诸如<code>ZADD</code>的指令虽然可以同时添加很多个<code>(score, member)</code>对，但是实际上他们是对一个key添加的，所以它们的三元组都是1。</li><li><code>getkeys_proc</code>表示<a href="https://developer.aliyun.com/article/754089" target="_blank" rel="noopener">从命令中判断命令的key</a>，实际上就是当<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>不能描述的时候，就会用到这个，返回一个<code>int*</code>表示所有key。例如后面举的eval的例子。</li><li><code>microseconds</code>表示该命令的调用总时间</li><li><code>calls</code>表示该命令的调用总次数</li><li><code>id</code>是在运行时给每个指令分配的id</li></ol><h4 id="flags枚举"><a href="#flags枚举" class="headerlink" title="flags枚举"></a>flags枚举</h4><p>从sflags可以解析得到flags，枚举如下：</p><ol><li><code>CMD_WRITE (1ULL&lt;&lt;0)</code></li><li><code>CMD_READONLY (1ULL&lt;&lt;1)</code><br> 对应read-only，一般包括所有的非特殊的命令，例如返回keys的值，或者返回一些其他信息，例如TIME等。诸如admin、transaction相关的信息，也不会被标记为readonly，因为他们会影响服务器状态。<br> 只读命令和非只读命令在主从复制时，<a href="https://luoming1224.github.io/2019/04/08/[redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0]redis%E4%B8%ADGeo%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">是不一样的</a>。</li><li><code>CMD_DENYOOM (1ULL&lt;&lt;2)</code><br> 对应use-memory，表示这个命令可能导致内存增加。需要在发生OOM的时候拒绝掉。</li><li><code>CMD_MODULE (1ULL&lt;&lt;3)</code></li><li><code>CMD_ADMIN (1ULL&lt;&lt;4)</code><br> 对应admin，诸如SAVE或者SHUTDOWN的命令。</li><li><code>CMD_PUBSUB (1ULL&lt;&lt;5)</code><br> SUBSCRIBE、UNSUBSCRIBE</li><li><code>CMD_NOSCRIPT (1ULL&lt;&lt;6)</code><br> 这样的命令不能在lua脚本中使用，例如AUTH、SAVE等。</li><li><code>CMD_RANDOM (1ULL&lt;&lt;7)</code><br> 对应random，有的命令即使在相同的情况下的运行结果也是不确定的，诸如SPOP、RANDOMKEY。</li><li><code>CMD_SORT_FOR_SCRIPT (1ULL&lt;&lt;8)</code><br> 对应to-sort，需要对输出序列进行排序。</li><li><code>CMD_LOADING (1ULL&lt;&lt;9)</code><br> 在服务器启动载入过程中可以执行的命令。如果没标记该项目的命令，启动过程中不能执行。</li><li><code>CMD_STALE (1ULL&lt;&lt;10)</code></li><li><code>CMD_SKIP_MONITOR (1ULL&lt;&lt;11)</code><br> no-monitor，不自动将这个命令propagate到MONITOR。</li><li><code>CMD_SKIP_SLOWLOG (1ULL&lt;&lt;12)</code><br> no-slowlog，不自动将这个命令propagate到slowlog。比如EXEC、AUTH之类的命。</li><li><code>CMD_ASKING (1ULL&lt;&lt;13)</code></li><li><code>CMD_FAST (1ULL&lt;&lt;14)</code><br> 这个命令是O(1)或者O(log(N))复杂度的，他们不会延误执行。注意所有可能导致DEL操作的并不是FAST命令，例如SET。</li><li><code>CMD_NO_AUTH (1ULL&lt;&lt;15)</code></li></ol><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>我们结合一个具体的定义来了解这个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"module"</span>,moduleCommand,<span class="number">-2</span>, <span class="comment">// -2表示大于等于2个参数</span></span><br><span class="line">     <span class="string">"admin no-script"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>, <span class="comment">// 这个叫get的指令对应到void getCommand(client *c)，有2个参数</span></span><br><span class="line">     <span class="string">"read-only fast @string"</span>, <span class="comment">// sflags 中是只读的，fast表示命令执行时间超过阈值时，会记录延迟事件。</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// flags</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">// getkeys_proc</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// firstkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// lastkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// keystep</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// microseconds</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// calls</span></span><br><span class="line">     <span class="number">0</span> <span class="comment">// id</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment">     * implicit DEL of a large key. */</span></span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"write use-memory @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"eval"</span>,evalCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"no-script @scripting"</span>,</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     evalGetKeys, <span class="comment">// eval无法通过key三元组描述，所以这里指定一个特殊的getkeys_proc</span></span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">"zadd"</span>,zaddCommand,<span class="number">-4</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @sortedset"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="命令的处理顺序"><a href="#命令的处理顺序" class="headerlink" title="命令的处理顺序"></a>命令的处理顺序</h3><ol><li>call<ol><li>processCommand<ol><li>processCommandAndResetClient<ol><li>processInputBuffer<ol><li>readQueryFromClient</li><li>handleClientsWithPendingReadsUsingThreads</li></ol></li><li>handleClientsWithPendingReadsUsingThreads<ol><li>stopThreadedIO</li><li>beforeSleep</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="processCommand"><a href="#processCommand" class="headerlink" title="processCommand"></a>processCommand</h3><p>这个函数很复杂：</p><ol><li>通过call执行命令</li><li>准备从客户端进行一次读取</li></ol><p>返回<code>C_OK</code>表示这个客户端还存在，否则表示这个客户端没了。</p><p>首先需要特别处理quit命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The QUIT command is handled separately. Normal command procs will</span></span><br><span class="line"><span class="comment">     * go through checking for replication and QUIT will cause trouble</span></span><br><span class="line"><span class="comment">     * when FORCE_REPLICATION is enabled and would be implemented in</span></span><br><span class="line"><span class="comment">     * a regular command proc. */</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面通过<code>lookupCommand</code>查找对应的命令结构，并处理找不到或者命令格式错误的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment"> * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line">c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">    sds args = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; <span class="number">128</span>; i++)</span><br><span class="line">        args = sdscatprintf(args, <span class="string">"`%.*s`, "</span>, <span class="number">128</span>-(<span class="keyword">int</span>)sdslen(args), (<span class="keyword">char</span>*)c-&gt;argv[i]-&gt;ptr);</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"unknown command `%s`, with args beginning with: %s"</span>,</span><br><span class="line">        (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr, args);</span><br><span class="line">    sdsfree(args);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">           (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">        c-&gt;cmd-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断命令的性质，是只读的，还是可写的等性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_write_command = (c-&gt;cmd-&gt;flags &amp; CMD_WRITE) ||</span><br><span class="line">                       (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_WRITE));</span><br><span class="line"><span class="keyword">int</span> is_denyoom_command = (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) ||</span><br><span class="line">                         (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_DENYOOM));</span><br><span class="line"><span class="keyword">int</span> is_denystale_command = !(c-&gt;cmd-&gt;flags &amp; CMD_STALE) ||</span><br><span class="line">                           (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_STALE));</span><br><span class="line"><span class="keyword">int</span> is_denyloading_command = !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING) ||</span><br><span class="line">                             (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_LOADING));</span><br></pre></td></tr></table></figure><p>进行auth和ACL检查。<br>auth也就是登录状态检查。<br>ACL，即Access Control List，有一系列条件规则组成，用来具体控制某些用户是否可以运行某些命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Check if the user is authenticated. This check is skipped in case</span></span><br><span class="line"><span class="comment">     * the default user is flagged as "nopass" and is active. */</span></span><br><span class="line">    <span class="keyword">int</span> auth_required = (!(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) ||</span><br><span class="line">                          (DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED)) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    <span class="keyword">if</span> (auth_required) &#123;</span><br><span class="line">        <span class="comment">/* AUTH and HELLO and no auth modules are valid even in</span></span><br><span class="line"><span class="comment">         * non-authenticated state. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;cmd-&gt;flags &amp; CMD_NO_AUTH)) &#123;</span><br><span class="line">            rejectCommand(c,shared.noautherr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the user can run this command according to the current</span></span><br><span class="line"><span class="comment">     * ACLs. */</span></span><br><span class="line">    <span class="keyword">int</span> acl_keypos;</span><br><span class="line">    <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">    <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">        addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval == ACL_DENIED_CMD)</span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to run "</span></span><br><span class="line">                <span class="string">"the '%s' command or its subcommand"</span>, c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to access "</span></span><br><span class="line">                <span class="string">"one of the keys used as arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果启用了Redis Cluster，就要进行转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* If cluster is enabled perform the cluster redirection here.</span></span><br><span class="line"><span class="comment">     * However we don't perform the redirection if:</span></span><br><span class="line"><span class="comment">     * 1) The sender of this command is our master.</span></span><br><span class="line"><span class="comment">     * 2) The command has no key arguments. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hashslot;</span><br><span class="line">        <span class="keyword">int</span> error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>处理oom相关行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Handle the maxmemory directive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we do not want to reclaim memory if we are here re-entering</span></span><br><span class="line"><span class="comment">     * the event loop since there is a busy Lua script running in timeout</span></span><br><span class="line"><span class="comment">     * condition, to avoid mixing the propagation of scripts with the</span></span><br><span class="line"><span class="comment">     * propagation of DELs due to eviction. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="keyword">int</span> out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;</span><br><span class="line">        <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span></span><br><span class="line"><span class="comment">         * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> reject_cmd_on_oom = is_denyoom_command;</span><br><span class="line">        <span class="comment">/* If client is in MULTI/EXEC context, queuing may consume an unlimited</span></span><br><span class="line"><span class="comment">         * amount of memory, so we want to stop that.</span></span><br><span class="line"><span class="comment">         * However, we never want to reject DISCARD, or even EXEC (unless it</span></span><br><span class="line"><span class="comment">         * contains denied commands, in which case is_denyoom_command is already</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != execCommand &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != discardCommand) &#123;</span><br><span class="line">            reject_cmd_on_oom = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save out_of_memory result at script start, otherwise if we check OOM</span></span><br><span class="line"><span class="comment">         * untill first write within script, memory used by lua stack and</span></span><br><span class="line"><span class="comment">         * arguments might interfere. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == evalCommand || c-&gt;cmd-&gt;proc == evalShaCommand) &#123;</span><br><span class="line">            server.lua_oom = out_of_memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use a reasonable amount of memory for client side</span></span><br><span class="line"><span class="comment">     * caching metadata. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.tracking_clients) trackingLimitUsedSlots();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are problems persisting on disk</span></span><br><span class="line"><span class="comment">     * and if this is a master instance. */</span></span><br><span class="line">    <span class="keyword">int</span> deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">    <span class="keyword">if</span> (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span><br><span class="line">        server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (is_write_command ||c-&gt;cmd-&gt;proc == pingCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deny_write_type == DISK_ERROR_TYPE_RDB)</span><br><span class="line">            rejectCommand(c, shared.bgsaveerr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-MISCONF Errors writing to the AOF file: %s"</span>,</span><br><span class="line">                strerror(server.aof_last_write_errno));</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are not enough good slaves and</span></span><br><span class="line"><span class="comment">     * user configured the min-slaves-to-write option. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_to_write &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_max_lag &amp;&amp;</span><br><span class="line">        is_write_command &amp;&amp;</span><br><span class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.noreplicaserr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if this is a read only slave. But</span></span><br><span class="line"><span class="comment">     * accept write commands if this is our master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        is_write_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.roslaveerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow a subset of commands in the context of Pub/Sub if the</span></span><br><span class="line"><span class="comment">     * connection is in RESP2 mode. With RESP3 there are no limits. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp; c-&gt;resp == <span class="number">2</span>) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</span><br><span class="line">        rejectCommandFormat(c,</span><br><span class="line">            <span class="string">"Can't execute '%s': only (P)SUBSCRIBE / "</span></span><br><span class="line">            <span class="string">"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow commands with flag "t", such as INFO, SLAVEOF and so on,</span></span><br><span class="line"><span class="comment">     * when slave-serve-stale-data is no and we are a slave with a broken</span></span><br><span class="line"><span class="comment">     * link with master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        server.repl_serve_stale_data == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_denystale_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.masterdownerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loading DB? Return an error if the command has not the</span></span><br><span class="line"><span class="comment">     * CMD_LOADING flag. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; is_denyloading_command) &#123;</span><br><span class="line">        rejectCommand(c, shared.loadingerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lua script too slow? Only allow a limited number of commands.</span></span><br><span class="line"><span class="comment">     * Note that we need to allow the transactions commands, otherwise clients</span></span><br><span class="line"><span class="comment">     * sending a transaction with pipelining without error checking, may have</span></span><br><span class="line"><span class="comment">     * the MULTI plus a few initial commands refused, then the timeout</span></span><br><span class="line"><span class="comment">     * condition resolves, and the bottom-half of the transaction gets</span></span><br><span class="line"><span class="comment">     * executed, see Github PR #7022. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != multiCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != unwatchCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'n'</span>) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'k'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.slowscripterr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面才是真正的执行，对于非multi，会调用call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code>就是调用指令的函数，有一系列的flag：</p><ol><li><code>CMD_CALL_NONE</code></li><li><code>CMD_CALL_SLOWLOG</code><br> 检查指令执行的速度，是否记录到slow log中呢？</li><li><code>CMD_CALL_STATS</code><br> Populate command stats.</li><li><code>CMD_CALL_PROPAGATE_AOF</code><br> 如果对数据有改动（可以通过<code>server.dirty</code>字段看出），或者client有一个强迫propagate的<code>CLIENT_FORCE_AOF</code>，就加到AOF上。<br> 相应的，如果client设置了<code>CLIENT_PREVENT_AOF_PROP</code>，那么即使数据集变动了，也不会写AOF。<br> 注意，无论client设置了什么，如果没有<code>CMD_CALL_PROPAGATE_AOF</code>，那么永远不会写AOF。</li><li><code>CMD_CALL_PROPAGATE_REPL</code><br> 同理，但是对Slave。同样有<code>CLIENT_FORCE_REPL</code>/<code>CLIENT_PREVENT_REPL_PROP</code>。</li><li><code>CMD_CALL_PROPAGATE</code><br> 相当于<code>PROPAGATE_AOF|PROPAGATE_REPL</code></li><li><code>CMD_CALL_FULL</code><br> 相当于<code>SLOWLOG|STATS|PROPAGATE</code></li></ol><p><code>call</code>主要就是用<code>c-&gt;cmd-&gt;proc(c)</code>执行命令，后者实际上就是<code>xxxCommand()</code>这样的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="keyword">ustime_t</span> start, duration;</span><br><span class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">real_cmd</span> = <span class="title">c</span>-&gt;<span class="title">cmd</span>;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>fixed_time_expire</code>在expire机制中见到过的，如果有命令在执行过程中，这个值就不是0。<br>还会把除了ADMIN之外的命令发送给MONITOR，ADMIN命令展示出来太危险了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.fixed_time_expire++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the command to clients in MONITOR mode if applicable.</span></span><br><span class="line"><span class="comment">     * Administrative commands are considered too dangerous to be shown. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些初始化和执行工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Initialization: clear the flags that must be set by the command on</span></span><br><span class="line"><span class="comment">     * demand, and initialize the array for additional commands propagation. */</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    redisOpArray prev_also_propagate = server.also_propagate;</span><br><span class="line">    redisOpArrayInit(&amp;server.also_propagate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the command. */</span></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    updateCachedTime(<span class="number">0</span>);</span><br><span class="line">    start = server.ustime;</span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在执行后，统计数据库被修改的次数<code>dirty</code>。在<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>中看到，比如我新加一个元素，或者修改一个元素，都会导致<code>dirty</code>增加。也就对应了数据的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    duration = ustime()-start;</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When EVAL is called loading the AOF we don't want commands called</span></span><br><span class="line"><span class="comment">     * from Lua to go into the slowlog or to populate statistics. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span><br><span class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the caller is Lua, we want to force the EVAL caller to propagate</span></span><br><span class="line"><span class="comment">     * the script if the command flag or client flag are forcing the</span></span><br><span class="line"><span class="comment">     * propagation. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>记录延迟信息，并记录slowlog。其中<code>latencyAddSampleIfNeeded</code>在适当的时候调用<code>latencyAddSample</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Log the command into the Slow log if needed, and populate the</span></span><br><span class="line"><span class="comment">     * per-command statistics that we show in INFO commandstats. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_SKIP_SLOWLOG)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_STATS) &#123;</span><br><span class="line">        <span class="comment">/* use the real command that was executed (cmd and lastamc) may be</span></span><br><span class="line"><span class="comment">         * different, in case of MULTI-EXEC or re-written commands such as</span></span><br><span class="line"><span class="comment">         * EXPIRE, GEOADD, etc. */</span></span><br><span class="line">        real_cmd-&gt;microseconds += duration;</span><br><span class="line">        real_cmd-&gt;calls++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理propagate的情况，这个对应了<code>CALL_</code>开头的一些规则，就不详解了。最终会计算得到一个<code>propagate_flags</code>传给<code>propagate</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">         * set for replication / AOF propagation. */</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">         * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* However prevent AOF / replication propagation if the command</span></span><br><span class="line"><span class="comment">         * implementations called preventCommandPropagation() or similar,</span></span><br><span class="line"><span class="comment">         * or if we don't have the call() flags to do so. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">         * propagation is needed. Note that modules commands handle replication</span></span><br><span class="line"><span class="comment">         * in an explicit way, so we never replicate them automatically. */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在结束之后，我们需要还原一下有关propagate的相关flag，因为<code>call</code>可能被递归调用。<br>【Q】我觉得这里一个典型的例子就是这里的multi、exec。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Restore the old replication flags, since call() can be executed</span></span><br><span class="line"><span class="comment"> * recursively. */</span></span><br><span class="line">c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">    (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br></pre></td></tr></table></figure><p><code>alsoPropagate</code>函数可以往<code>server.also_propagate</code>里面加一些其他的op。下面就处理<code>alsoPropagate</code>的逻辑，也就是当propagate完当前的命令之后，还可以再去propagate一些命令。并且这些命令不被<code>CLIENT_PREVENT_PROP</code>影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.also_propagate.numops) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    redisOp *rop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">        <span class="keyword">int</span> multi_emitted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果说已经被包在了MULTI里面，就不在继续包在<code>also_propagate</code>里面propagate了。<br><code>execCommandPropagateMulti</code>实际上就是下面的propagate调用。这里的<code>shared.multi</code>或者<code>shared.exec</code>实际上是缓存的字符串对象<code>EXEC</code>和<code>MULTI</code>，减少频繁的内存分配的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateMulti</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.multiCommand,c-&gt;db-&gt;id,&amp;shared.multi,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateExec</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.execCommand,c-&gt;db-&gt;id,&amp;shared.exec,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是做propagate。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="comment">/* Wrap the commands in server.also_propagate array,</span></span><br><span class="line"><span class="comment">             * but don't wrap it if we are already in MULTI context,</span></span><br><span class="line"><span class="comment">             * in case the nested MULTI/EXEC.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * And if the array contains only one command, no need to</span></span><br><span class="line"><span class="comment">             * wrap it, since the single command is atomic. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.also_propagate.numops &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE) &amp;&amp;</span><br><span class="line">                !(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span><br><span class="line">                !(flags &amp; CMD_CALL_NOWRAP))</span><br><span class="line">            &#123;</span><br><span class="line">                execCommandPropagateMulti(c);</span><br><span class="line">                multi_emitted = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">                rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">                <span class="keyword">int</span> target = rop-&gt;target;</span><br><span class="line">                <span class="comment">/* Whatever the command wish is, we honor the call() flags. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">                <span class="keyword">if</span> (target)</span><br><span class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (multi_emitted) &#123;</span><br><span class="line">                execCommandPropagateExec(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line">    &#125;</span><br><span class="line">    server.also_propagate = prev_also_propagate;</span><br></pre></td></tr></table></figure><p>这个应该是和客户端缓存有关的，如果client提供了keys tracking功能，要通知。这个函数里面维护了一个tracking invalidation表，这样客户端会收到一个invalidation信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* If the client has keys tracking enabled for client side caching,</span></span><br><span class="line"><span class="comment">     * make sure to remember the keys it fetched via this command. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">        client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                            server.lua_caller : c;</span><br><span class="line">        <span class="keyword">if</span> (caller-&gt;flags &amp; CLIENT_TRACKING &amp;&amp;</span><br><span class="line">            !(caller-&gt;flags &amp; CLIENT_TRACKING_BCAST))</span><br><span class="line">        &#123;</span><br><span class="line">            trackingRememberKeys(caller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.fixed_time_expire--;</span><br><span class="line">    server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除逻辑实现"><a href="#删除逻辑实现" class="headerlink" title="删除逻辑实现"></a>删除逻辑实现</h1><p>为了理解下面论述中涉及到的expire相关实现，我们需要先介绍一些<code>UNLINK</code>和<code>DEL</code>的实现。<br>delGenericCommand的实现是比较Legacy的，从<code>c-&gt;argv</code>中读取所有需要被删除的key，然后调用dbAsyncDelete或者dbSyncDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>容易发现，删除有两种模式：异步(lazy)删除和同步删除。异步删除的情况包括：</p><ol><li>delete逻辑<ol><li><code>delGenericCommand</code>中传入lazy<br> 如果是unlink命令，那么一定是异步删除。<br> 如果是del命令，则取决于<code>server.lazyfree_lazy_user_del</code>。</li><li><code>dbDelete</code>中设置了<code>server.lazyfree_lazy_server_del</code></li></ol></li><li>expire逻辑<ol><li><code>expireIfNeeded</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应了Redis的lazy过期策略。</li><li><code>activeExpireCycleTryExpire</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应着Redis的定期循环，主动过期策略。</li><li><code>expireGenericCommand</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 直接运行expire命令，主动检查一下有没有过期。</li></ol></li><li>evict逻辑<ol><li><code>freeMemoryIfNeeded</code>中如果设置<code>server.lazyfree_lazy_eviction</code>，则使用异步删除</li></ol></li><li>其他<ol><li><code>RM_UnlinkKey</code></li></ol></li></ol><p>这些<code>lazyfree_lazy_</code>开头的配置，默认都是0。也就是说这些情况下默认都是同步删除。</p><p>同步删除的情况类似，除了“其他”中发生了变化：</p><ol><li>其他<ol><li><code>rdbLoadRio</code></li></ol></li></ol><p>下面的代码会进行事件通知，我们将专门进行介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【续】delGenericCommand函数</span></span><br><span class="line">...</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>del和unlink的唯一区别是，unlink一定是lazy删除的，但是del取决于配置<code>lazyfree_lazy_user_del</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlinkCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步删除"><a href="#同步删除" class="headerlink" title="同步删除"></a>同步删除</h2><p>看简单的同步实现。<br>首先，如果<code>db-&gt;expires</code>非空，从<code>db-&gt;expires</code>里面删除<code>key</code>，实际上是删除的过期时间。<br>这里有个注释，说从<code>db-&gt;expires</code>中删除一个entry不会释放<code>key-&gt;ptr</code>这个sds，因为它和<code>db-&gt;dict</code>是共享的。这里应该说的是在<code>setExpire</code>里面往<code>db-&gt;expires</code>添加key的时候，加的实际上是指向<code>db-&gt;dict</code>中的指针。<br>但果真是这样的么？继续看<code>dictDelete</code>最终调用<code>dictGenericDelete</code>。查看<code>dictDelete</code>实际上是<code>dictGenericDelete</code>的实现(在“dict的其他相关方法”这个章节中介绍)，发现新版本的代码肯定会调用<code>dictFreeKey</code>(Redis3.0里面有个<code>dictFreeEntryKey</code>，不要混淆了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>检查dictFreeKey的实现发现，这个函数调用<code>keyDestructor</code>，它似乎一定会导致对应sds的析构。看上去和上面的注释是矛盾的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br></pre></td></tr></table></figure><p>究竟是怎么回事呢？我们看下keyptrDictType和dbDictType这两个dict类型就有了答案。原来对于<code>db-&gt;expires</code>，它实际的类型就没有设置keyDestructor，所以不会析构key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line">server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;expires */</span></span><br><span class="line">dictType keyptrDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></span><br><span class="line">dictType dbDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></span><br><span class="line">    dictObjectDestructor   <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以说一下<code>#define DICT_NOTUSED(V) ((void) V)</code>是经典的关闭编译器unused variable warning的办法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSdsDestructor</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接着看<code>dbSyncDelete</code>的逻辑，刚才是删除的<code>db-&gt;expires</code>，还需要删除<code>db-&gt;dict</code>。<br>此外<code>server.cluster_enabled</code>的情况进行了额外的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再从db-&gt;dict里面删除key</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// Redis Cluster相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h2><p>异步删除的核心是调用<code>dictUnlink</code>而不是<code>dictDelete</code>。<br>前面的是大差不差的，删除<code>db-&gt;expires</code>里面的字段，因为他们的dictType不一样，他们的析构行为(<code>keyDestructor</code>)也不一样。这就导致expire可以直接dictDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazyfree.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB.</span></span><br><span class="line"><span class="comment"> * If there are enough allocations to free the value object may be put into</span></span><br><span class="line"><span class="comment"> * a lazy free list instead of being freed synchronously. The lazy free list</span></span><br><span class="line"><span class="comment"> * will be reclaimed in a different bio.c thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面调用<code>dictUnlink</code>而不是<code>dictDelete</code>了。这里注意区别一下<code>dictUnlink</code>和前面提到的UNLINK命令。<code>dictUnlink</code>的作用是将对应的key从dict中删除，但不会释放对应的结构，而是直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>拿到这个<code>de</code>，我们手动来析构。会首先使用<code>lazyfreeGetFreeEffort</code>来计算析构的代价，如果代价过高，就将这个对象放到lazy free list里面让它后台去析构。不然的话就在后面的代码中同步析构，这是因为如果对象很小，那么再搞这一套异步反而更耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先来看lazy的实现，如果算出来值得，那么就lazy。但这里还有个特殊情况我们不能异步删除，根据注释，如果这个对象是被共享的(<code>val-&gt;refcount</code>就是一个大于1的值)，我们不能就直接把它现在就回收掉。这个倒不经常发生，但确实Redis的一些实现代码会用<code>incrRefCount</code>来保护对象，然后调用<code>dbDelete</code>。在这种情况下我们会fall through到下面<code>dictFreeUnlinkedEntry</code>的调用，它的最终效果相当于直接调用<code>decrRefCount</code>。<br>经过了上述的判断，我们就可以使用bioCreateBackgroundJob来异步删除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就是同步删除的实现。<code>dictFreeUnlinkedEntry</code>这一块就是给之前<code>nofree</code>没做的事情擦一下屁股，包含调用<code>dictFreeKey</code>啥的来释放key和value所占用的内存。<br><code>slotToKeyDel</code>这个是Redis Cluster的实现逻辑，用来算出来这个key在哪个slot上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    zfree(he);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及的几个函数来讲解一下</p><h3 id="lazyfreeGetFreeEffort"><a href="#lazyfreeGetFreeEffort" class="headerlink" title="lazyfreeGetFreeEffort"></a>lazyfreeGetFreeEffort</h3><p>这个函数计算并返回释放一个对象的代价。返回值不一定是这个对象对应的内存分配次数，但是和这个量成比例的。具体来说：</p><ol><li>对于字符串，函数永远返回1。</li><li>对于用诸如哈希表等数据结构表示的聚合对象，返回组成该对象元素的数量。</li><li>对于只需要一次内存分配就产生的对象，认为是独立的一个对象，即使实际上是由多个造成的。</li><li>对于列表对象，返回quicklist里面的元素数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> lazyfreeGetFreeEffort(robj *obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">        quicklist *ql = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> ql-&gt;len;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_SET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br></pre></td></tr></table></figure><p>对于ZSET，如果是跳表实现，就返回跳表的长度。如果是ziplist实现就返回1？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_ZSET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_SKIPLIST)&#123;</span><br><span class="line">        zset *zs = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> zs-&gt;zsl-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_HASH &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_STREAM) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> effort = <span class="number">0</span>;</span><br><span class="line">        stream *s = obj-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make a best effort estimate to maintain constant runtime. Every macro</span></span><br><span class="line"><span class="comment">         * node in the Stream is one allocation. */</span></span><br><span class="line">        effort += s-&gt;rax-&gt;numnodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Every consumer group is an allocation and so are the entries in its</span></span><br><span class="line"><span class="comment">         * PEL. We use size of the first group's PEL as an estimate for all</span></span><br><span class="line"><span class="comment">         * others. */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;cgroups) &#123;</span><br><span class="line">            raxIterator ri;</span><br><span class="line">            streamCG *cg;</span><br><span class="line">            raxStart(&amp;ri,s-&gt;cgroups);</span><br><span class="line">            raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* There must be at least one group so the following should always</span></span><br><span class="line"><span class="comment">             * work. */</span></span><br><span class="line">            serverAssert(raxNext(&amp;ri));</span><br><span class="line">            cg = ri.data;</span><br><span class="line">            effort += raxSize(s-&gt;cgroups)*(<span class="number">1</span>+raxSize(cg-&gt;pel));</span><br><span class="line">            raxStop(&amp;ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> effort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Everything else is a single allocation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="atomicIncr"><a href="#atomicIncr" class="headerlink" title="atomicIncr"></a>atomicIncr</h3><p>是一个原子操作，更新lazyfree里面的一个static变量<code>lazyfree_objects</code>。根据不同的操作系统的支持，有三种实现：<br>如果支持atomic语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><p>如果有sync语义，一般是gcc的一个内置宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __sync_add_and_fetch(&amp;var,(count))</span></span><br></pre></td></tr></table></figure><p>如果什么都没有，用mutex，mutex的名字是变量名加上<code>_mutex</code>，这些mutex随着变量名一起被定义，只是可能不会被用到，如lazyfree_objects_mutex。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</span><br><span class="line">    var += (count); \</span><br><span class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="bioCreateBackgroundJob"><a href="#bioCreateBackgroundJob" class="headerlink" title="bioCreateBackgroundJob"></a>bioCreateBackgroundJob</h3><p>所有的bio开头的函数表示Redis的Background IO服务。根据注释，将来也许会迁移到libeio。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictSetVal"><a href="#dictSetVal" class="headerlink" title="dictSetVal"></a>dictSetVal</h3><p>见dict相关</p><h3 id="slotToKeyDel"><a href="#slotToKeyDel" class="headerlink" title="slotToKeyDel"></a>slotToKeyDel</h3><p>见 Redis Cluster 相关</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>lookUpKey相关方法根据查找目的是读或者写区分了<code>lookupKeyRead</code>、<code>lookupKeyWrite</code>两个方向的函数，此外还根据是否<code>WithFlags</code>或者<code>OrReply</code>派生出其他几种函数。</p><p>对于<code>lookupKeyWrite</code>来讲，有一个副作用，就是会先检查一下要不要expire，如果需要就直接expire掉。<br>对于<code>lookupKeyRead</code>来讲，也要处理expire的问题，但是因为涉及到主从复制的问题，所以要进行额外处理。【Q】为什么不需要对写处理呢？我想应该是因为只有Master处理写，处理完再发指令给Slave。</p><p>直接介绍带Flags的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WithFlags</code>目前只包含了<code>LOOKUP_NONE</code>和<code>LOOKUP_NOTOUCH</code>两个选项。：</p><ol><li><code>LOOKUP_NONE</code></li><li><code>LOOKUP_NOTOUCH</code><br> 表示这次访问不要更新LRU啥的，例如type这样的命令就带上这个参数。</li></ol><h2 id="lookupKeyReadWithFlags"><a href="#lookupKeyReadWithFlags" class="headerlink" title="lookupKeyReadWithFlags"></a>lookupKeyReadWithFlags</h2><p>下面查看<code>lookupKeyReadWithFlags</code>的实现，相比于写要复杂点，因为要处理键过期的时候读的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Master的<code>masterhost</code>肯定是NULL，这是一个经典判定。首先考虑Master的情况，如果key过期了，那么就直接安全地返回NULL，并且触发一个keymiss事件。这里注释上说在Master情况下，<code>expireIfNeeded</code>返回0当且只当这个key不存在。<br>为什么强调Master呢，实际上可以结合<code>expireIfNeeded</code>的实现来看。提前说一下，<strong>对Slave而言</strong>，<code>expireIfNeeded</code>并<strong>不会真的让key过期并删除</strong>，而只是返回key在逻辑上是过期的，而真正的过期是由Master来同步的，其目的是保持Slave和Master的一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Key expired. If we are in the context of a master, expireIfNeeded()</span></span><br><span class="line"><span class="comment">         * returns 0 only when the key does not exist at all, so it's safe</span></span><br><span class="line"><span class="comment">         * to return NULL ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更新统计信息，<code>server.stat_keyspace_misses</code>可以通过<code>INFO keyspace_misses</code>命令来查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是对Master情况的处理，下面是对Slave的情况。我们已经知道，Slave并不会真的删除过期key，而是等待Master的Del指令。所以即使<code>expireIfNeeded</code>返回1表示过期，<br>但根据注释，对Slave而言，作为一个额外的安全措施，如果相关指令是只读的，还是可以在这里安全地返回NULL。Redis的说法是：对于只读命令，这样可以向client提供一个更加一致性的行为。这个会包含GETS，当使用Slave来扩容读的时候。我的理解就是尽管slave上还没有删除，但是过期就是过期，我们要和Master一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookupKeyWriteWithFlags"><a href="#lookupKeyWriteWithFlags" class="headerlink" title="lookupKeyWriteWithFlags"></a>lookupKeyWriteWithFlags</h2><p>首先查看<code>lookupKeyWriteWithFlags</code>的实现，直接先检查下expire，然后调用<code>lookupKey</code>。这里的<code>expireIfNeeded</code>也是Redis的lazy过期策略的实现，在每次查找的时候都会调用，检查这个键是不是已经过期了。<br>不同于<code>lookupKeyReadWithFlags</code>，这里就不会统计keymiss啥的了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookUpKey"><a href="#lookUpKey" class="headerlink" title="lookUpKey"></a>lookUpKey</h2><p><code>lookUpKey</code>的主要内容包括从db里面找到对应的key，并且维护LRU或LFU。它是一个较为底层的 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从db中获得key对应的entry</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了，就取出val</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有设置</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是LRU和LFU的实现，更新每个key的访问情况，从而方便后续evict。详细见有关updateLFU的实现见”Redis的LRU和LFU实现”这一章节。<br>但先要做一些判断：</p><ol><li>如果设置了<code>LOOKUP_NOTOUCH</code>。</li><li>如果有子进程正在进行保存，就不进行LFU操作，以免破坏COW。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h1><h2 id="如何判断键已过期？"><a href="#如何判断键已过期？" class="headerlink" title="如何判断键已过期？"></a>如何判断键已过期？</h2><p>诸如<code>EXPIRE</code>/<code>RENAME</code>等的实现中会调用<code>setExpire</code>函数设置过期时间。<code>setExpire</code>会把每个键的过期时间都被存在<code>db-&gt;expires</code>这个字典里面。<br>通过<code>getExpire</code>可以从字典中读取到过期时间。</p><h3 id="getExpire"><a href="#getExpire" class="headerlink" title="getExpire"></a>getExpire</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the expire time of the specified key, or -1 if no expire</span></span><br><span class="line"><span class="comment"> * is associated with this key (i.e. the key is non volatile) */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keyIsExpired"><a href="#keyIsExpired" class="headerlink" title="keyIsExpired"></a>keyIsExpired</h3><p>keyIsExpired作用是判断某个键有没有过期。主要功能就是比较现在的时间，和获得的key的过期时间。被expireIfNeeded调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面一段代码的目的是：如果在执行lua脚本，将时间设置成脚本执行开始的时间，这样在脚本执行过程中就不会expire。这么做的原因是源自Github上面的<a href="https://github.com/redis/redis/issues/1525" target="_blank" rel="noopener">Issue1525</a>。作者发现这个脚本在Master和Slave上的执行是不一样的。原因是在Master上第一次执行可能key存在，第二次就不存在了。这导致<code>incr</code>实际只被执行了一次。但是因为此时Master会合成一个DEL指令，让Slave也删除并过期这个Key。此时，如果相同的脚本运行在Slave上面，那么<code>incr</code>一次也不会被执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保障向Slave和AOF的propagate是一致的，首先在执行lua脚本的时候，要禁止expire(就是这里的行为)；但是在执行脚本之前，先要对涉及的key做下<code>expireIfNeeded</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are in the middle of a command execution, we still want to use</span></span><br><span class="line"><span class="comment">     * a reference time that does not change: in that case we just use the</span></span><br><span class="line"><span class="comment">     * cached time, that we update before each call in the call() function.</span></span><br><span class="line"><span class="comment">     * This way we avoid that commands such as RPOPLPUSH or similar, that</span></span><br><span class="line"><span class="comment">     * may re-open the same key multiple times, can invalidate an already</span></span><br><span class="line"><span class="comment">     * open object in a next call, if the next call will see the key expired,</span></span><br><span class="line"><span class="comment">     * while the first did not. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For the other cases, we want to use the most fresh time we have. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key expired if the current (virtual or real) time is greater</span></span><br><span class="line"><span class="comment">     * than the expire time of the key. */</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="expireIfNeeded"><a href="#expireIfNeeded" class="headerlink" title="expireIfNeeded"></a>expireIfNeeded</h2><p><code>expireIfNeeded</code>用来删除过期的键，它是<strong>被动expire</strong>的关键步骤。返回0表示键有效(键未过期，或永不过期)，否则返回1表示已经过期并被删除。<br>对于Master，如果找到的键是expire的，会被从数据库中evict掉。并且会导致想AOF和Slave流propagate一条DEL或者UNLINK指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>如果没有过期，就返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先，通过<code>keyIsExpired</code>检测是不是已经过期了，如果还没有过期，上面就直接返回0了，再往下就是处理过期的情况。<br>根据注释，如果Redis运行在主从模式下，并且是在Slave上，<code>expireIfNeeded</code>直接返回，而不是继续删除键。这是因为Slave上的key过期是由Master控制的，Slave并不直接处理key的过期。Master会发送一个同步的<code>DEL</code>命令给Slave来删除某个键，Slave等到那时候再删除，<strong>这样做的目的是出于一致性的考量</strong>。<br>但尽管如此，对Slave调用<code>expireIfNeeded</code>也应该返回一个正确的值，也就是这个时候键应不应该过期。因此，Slave上是先过期，然后再删除键的，这其中存在一个窗口时间，因为Slave还没有来得及收到并处理Master的<code>DEL</code>。<br>下面肯定对应了已经过期的情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面负责通知删除事件，这里还出现了<code>propagateExpire</code>函数，我们也统一在后面讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 向AOF文件和Slave节点传播过期信息，实际会调用propagate函数</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是真正的过期删除的过程。这里根据<code>server.lazyfree_lazy_expire</code>的配置，可以选择异步删除或者同步删除，这类似于上面讨论过的<code>UNLINK</code>和<code>DEL</code>的实现。事实上在<code>expireGenericCommand</code>上就可以看到对应的映射关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);     </span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主动expire实现"><a href="#主动expire实现" class="headerlink" title="主动expire实现"></a>主动expire实现</h2><p>在<code>databasesCron</code>可以看到，如果开启了主动expire，并且自己是master，则会定时运行activeExpireCycle。<br>介绍<a href="https://stackoverflow.com/questions/33370047/configuring-redis-expire-algorithm" target="_blank" rel="noopener">参数</a>：<br><code>active_expire_effort</code>默认值为1，表示<a href="https://docs.aws.amazon.com/memorydb/latest/devguide/parametergroups.redis.html" target="_blank" rel="noopener">避免有超过<code>10%</code>的过期key，同时CPU占用不超过25%</a>。<br><code>config_keys_per_loop</code>表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    effort = server.active_expire_effort<span class="number">-1</span>, <span class="comment">/* Rescale from 0 to 9. */</span></span><br><span class="line">    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +</span><br><span class="line">                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +</span><br><span class="line">                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +</span><br><span class="line">                                  <span class="number">2</span>*effort,</span><br><span class="line">    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-</span><br><span class="line">                                    effort;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是几个全局变量：</p><ol><li>timelimit_exit表示是否已经超时了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></span><br><span class="line"><span class="comment">     * incrementally across calls. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>如果所有的clients停止了，那么我们的主动expire循环也要停止，从而保持数据库是静态的。没搞懂为啥这么设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里，Redis的主动过期策略分为了fast和slow两个模式。第一种在key比较少的情况下尝试是用较少的cpu，一旦这些过期的键的数量小于某个给定值，就退出。第二种更激进一点，以减少内存占用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exit</span></span><br><span class="line"><span class="comment">         * for time limit, unless the percentage of estimated stale keys is</span></span><br><span class="line"><span class="comment">         * too high. Also never repeat a fast cycle for the same period</span></span><br><span class="line"><span class="comment">         * as the fast cycle total duration itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit &amp;&amp;</span><br><span class="line">            server.stat_expired_stale_perc &lt; config_cycle_acceptable_stale)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + (<span class="keyword">long</span> <span class="keyword">long</span>)config_cycle_fast_duration*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每次扫多少db呢？默认<code>dbs_per_call</code>为CRON_DBS_PER_CALL，即16：</p><ol><li><code>dbs_per_call</code>不能超过总的db数。</li><li>如果<code>timelimit_exit</code>，需要扫描全部db<br> 我的理解是如果上次active expire都超时了，说明肯定有很多expire key等待清理，我们全部做一遍，以免占用太多内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We usually should test CRON_DBS_PER_CALL per iteration, with</span></span><br><span class="line"><span class="comment">     * two exceptions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Don't test more DBs than we have.</span></span><br><span class="line"><span class="comment">     * 2) If last time we hit the time limit, we want to scan all DBs</span></span><br><span class="line"><span class="comment">     * in this iteration, as there is work to do in some DB and we don't want</span></span><br><span class="line"><span class="comment">     * expired keys to use memory for too much time. */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里通过计算耗时，来限制active expire循环对CPU的占用。默认CPU限制是ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC。我们最多在这个函数中只能用timelimit这么多<strong>微秒</strong>。<code>server.hz</code>指的是表示一秒钟被触发多少次，<code>config_cycle_slow_time_perc</code>是个CPU的百分比，也就是每次迭代中只能用<code>config_cycle_slow_time_perc/100</code>这么久。因为每次迭代的耗时是<code>1/server.hz</code>秒，即<code>1000000/server.hz</code>微秒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We can use at max 'config_cycle_slow_time_perc' percentage of CPU</span></span><br><span class="line"><span class="comment">     * time per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span></span><br><span class="line">    timelimit = config_cycle_slow_time_perc*<span class="number">1000000</span>/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = config_cycle_fast_duration; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accumulate some global stats as we expire keys, to have some idea</span></span><br><span class="line"><span class="comment">     * about the number of keys that are already logically expired, but still</span></span><br><span class="line"><span class="comment">     * existing inside the database. */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>外层的循环，遍历所有的数据库。如果<code>timelimit_exit</code>为1，说明内层循环中已经发现执行超时了，外层循坏也退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="comment">/* Expired and checked in a single loop. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> expired, sampled;</span><br><span class="line"></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></span><br><span class="line"><span class="comment">         * in the current DB we'll restart from the next. This allows to</span></span><br><span class="line"><span class="comment">         * distribute the time evenly across DBs. */</span></span><br><span class="line">        current_db++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内层的循环，如果每次循环结束，还是有很高的没有处理的过期的key，就需要继续做。但我们也不能一直这么做下去，所以每过16次，就会检查是否超过timelimit。如果是的话，就设置timelimit_exit为1，然后退出当前循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">            <span class="keyword">int</span> ttl_samples;</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When there are less than 1% filled slots, sampling the key</span></span><br><span class="line"><span class="comment">             * space is expensive, so stop here waiting for better times...</span></span><br><span class="line"><span class="comment">             * The dictionary will be resized asap. */</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. */</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            sampled = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个db最多抽样这么多个</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; config_keys_per_loop)</span><br><span class="line">                num = config_keys_per_loop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Here we access the low level representation of the hash table</span></span><br><span class="line"><span class="comment">             * for speed concerns: this makes this code coupled with dict.c,</span></span><br><span class="line"><span class="comment">             * but it hardly changed in ten years.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Note that certain places of the hash table may be empty,</span></span><br><span class="line"><span class="comment">             * so we want also a stop condition about the number of</span></span><br><span class="line"><span class="comment">             * buckets that we scanned. However scanning for free buckets</span></span><br><span class="line"><span class="comment">             * is very fast: we are in the cache line scanning a sequential</span></span><br><span class="line"><span class="comment">             * array of NULL pointers, so we can scan a lot more buckets</span></span><br><span class="line"><span class="comment">             * than keys in the same time. */</span></span><br><span class="line">            <span class="keyword">long</span> max_buckets = num*<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">long</span> checked_buckets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> table = <span class="number">0</span>; table &lt; <span class="number">2</span>; table++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == <span class="number">1</span> &amp;&amp; !dictIsRehashing(db-&gt;expires)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx = db-&gt;expires_cursor;</span><br><span class="line">                    idx &amp;= db-&gt;expires-&gt;ht[table].sizemask;</span><br><span class="line">                    dictEntry *de = db-&gt;expires-&gt;ht[table].table[idx];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Scan the current bucket of the current table. */</span></span><br><span class="line">                    checked_buckets++;</span><br><span class="line">                    <span class="keyword">while</span>(de) &#123;</span><br><span class="line">                        <span class="comment">/* Get the next entry now since this entry may get</span></span><br><span class="line"><span class="comment">                         * deleted. */</span></span><br><span class="line">                        dictEntry *e = de;</span><br><span class="line">                        de = de-&gt;next;</span><br><span class="line"></span><br><span class="line">                        ttl = dictGetSignedIntegerVal(e)-now;</span><br><span class="line">                        <span class="keyword">if</span> (activeExpireCycleTryExpire(db,e,now)) expired++;</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">/* We want the average TTL of keys yet</span></span><br><span class="line"><span class="comment">                             * not expired. */</span></span><br><span class="line">                            ttl_sum += ttl;</span><br><span class="line">                            ttl_samples++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sampled++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                db-&gt;expires_cursor++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            total_sampled += sampled;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Do a simple running average with a few samples.</span></span><br><span class="line"><span class="comment">                 * We just use the current estimate with a weight of 2%</span></span><br><span class="line"><span class="comment">                 * and the previous estimate with a weight of 98%. */</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就是检查并设置timelimit_exit</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (sampled == <span class="number">0</span> ||</span><br><span class="line">                 (expired*<span class="number">100</span>/sampled) &gt; config_cycle_acceptable_stale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed = ustime()-start;</span><br><span class="line">    server.stat_expire_cycle_time_used += elapsed;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update our estimate of keys existing but yet to be expired.</span></span><br><span class="line"><span class="comment">     * Running average with this sample accounting for 5%. */</span></span><br><span class="line">    <span class="keyword">double</span> current_perc;</span><br><span class="line">    <span class="keyword">if</span> (total_sampled) &#123;</span><br><span class="line">        current_perc = (<span class="keyword">double</span>)total_expired/total_sampled;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        current_perc = <span class="number">0</span>;</span><br><span class="line">    server.stat_expired_stale_perc = (current_perc*<span class="number">0.05</span>)+</span><br><span class="line">                                     (server.stat_expired_stale_perc*<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="propagateExpire"><a href="#propagateExpire" class="headerlink" title="propagateExpire"></a>propagateExpire</h2><p>在前面的代码中，还看到<code>propagateExpire</code>的使用。我们知道，在主从结构下，键实际的expire操作是在Master完成的。在expire之后，Master会发送DEL指令给Slave和AOF，也就是这个函数。<br>在注释中还指出，因为AOF，以及Master到Slave的连接都是保证有序的，所以即使有操作去写已经失效的key，都能保证结果是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    robj *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    argv[<span class="number">0</span>] = lazy ? shared.unlink : shared.del;</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    incrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    propagate(server.delCommand,db-&gt;id,argv,<span class="number">2</span>,PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="propagate机制"><a href="#propagate机制" class="headerlink" title="propagate机制"></a>propagate机制</h1><p>在expire中，提到了<code>propagate</code>函数，因此这里也顺便介绍一些propagate机制。<br>propagate机制是Redis主从复制逻辑的一部分，通常来说，Redis主从复制<a href="http://redisbook.com/preview/replication/replicate-before-2-8.html" target="_blank" rel="noopener">包含两个机制</a>：</p><ol><li>sync/psync机制<br> 用来处理sync和psync指令，也就是刚开始同步的情况，将从服务器的数据库状态更新至主服务器当前所处的数据库状态。</li><li>propagate机制<br> 将指令从Master同步到Slave或者AOF文件。</li></ol><p>propagate机制将特定的指令传播给AOF或者Slave，这些指令有下面几种：</p><ol><li><code>PROPAGATE_NONE</code><br> 压根就不传播。</li><li><code>PROPAGATE_AOF</code><br> 如果开启了AOF，就传播给AOF。此时就会调用AOF的主入口函数<code>feedAppendOnlyFile</code>。关于RDB和AOF机制，我们在专门的文章介绍。</li><li><code>PROPAGATE_REPL</code><br> 传播给Slave。同样调用<code>replicationFeedSlaves</code>函数。</li></ol><p>根据注释，不能够在各个command的实现代码中使用这个函数，因为它不会wrap the resulting commands in MULTI/EXEC，如果需要，应该用<code>alsoPropagate</code>、<code>preventCommandPropagation</code>、<code>forceCommandPropagation</code>等。<br>However for functions that need to (also) propagate out of the context of a command execution, for example when serving a blocked client, you want to use propagate().</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="evict实现"><a href="#evict实现" class="headerlink" title="evict实现"></a>evict实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis对当前执行环节的判断</p><ol><li><code>server.masterhost == NULL</code><br> 常常被用来判断是不是Master服务器</li><li><code>server.current_client != server.master</code><br> 根据注释，这是指的服务器的当前客户端，仅用于崩溃报告。</li><li><code>sentinelRedisInstance-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)</code></li><li><code>sentinelRedisInstance-&gt;slave_master_host</code></li></ol><p>大家都知道，Redis里面有下面<a href="https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/" target="_blank" rel="noopener">几种evict policy</a>：</p><ol><li>noeviction<br> 这是默认情况。<br> 内存爆了，就直接报错。</li><li>allkeys-lru<br> 对所有的键做LRU。</li><li>allkeys-lfu<br> 对所有的键做LFU。</li><li>allkeys-random<br> 对所有的key做随机删除。</li><li>volatile-lru/volatile-lfu/volatile-random<br> 这是对有expire的键做对应的操作。</li><li>volatile-ttl<br> 删除剩余生命最短的键。</li></ol><p>而对应的实现，就在<code>freeMemoryIfNeeded</code>中。根据注释，这个函数被定时调用，当发现超出最大使用内存后，就会释放相关内存。如果释放内存成功，或者我们不需要释放内存，那么返回<code>C_OK</code>；如果我们没有能够释放足够的内存，那么返回<code>C_ERR</code>。总之一堆废话。。。其实我们想了解的是这几个问题：</p><ol><li>如何计算现在已经使用了多少内存？</li><li>如何实现LFU和LRU？</li><li>释放内存会对其他模块产生什么影响？</li></ol><h2 id="LRU和LFU的一般实现及优缺点讨论"><a href="#LRU和LFU的一般实现及优缺点讨论" class="headerlink" title="LRU和LFU的一般实现及优缺点讨论"></a>LRU和LFU的一般实现及优缺点讨论</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>对于LRU，一个队列就行了，我们把最近用到的元素放到队列尾部，需要evict的时候就弹出头部，一般用双向队列就行。但这样查找一个Key就变成<code>O(n)</code>的了，但这也不难，我们只需要用一个map记录一下对应元素在队列中的位置就行。也就是说，用hash+双向链表来维护。hash用来实现O(1)查询，双向链表用来维护顺序。</p><p>Redis并没有采用这个办法来维护一个LRU，显然内存开销很大，这是值得的么？<a href="https://juejin.cn/post/6844903454654087182" target="_blank" rel="noopener">文章</a>中提到，当<code>maxmemory-samples</code>数为<a href="https://segmentfault.com/a/1190000017555834" target="_blank" rel="noopener">10</a>的时候，近似LRU算法的性能已经很好了。此外，Redis实际上是记录了最后一次访问某个key的时间戳的(倒不是因为复用LFU的空间了，毕竟LRU是先有的)。到了我们这个版本的代码，近似LRU又被优化了，出现了一个<code>evictionPoolEntry</code>。这个pool的容量是16，里面的key是按照lru有序排列的。</p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>对于LFU，我们需要记录对应的访问次数，在淘汰时，选择最少访问次数的键值对。此时，队列的性质就不够用了，但可以考虑下面的方案</p><ol><li>用优先队列，把访问次数作为key，大不了手动实现一个二叉堆嘛。</li><li>用一个双层链表，第一层是从0开始的访问次数，第二层是具有这个访问次数的所有键值对的开链表。为了节约空间，第一层可以是哈希表的形式。</li></ol><h2 id="Redis的LRU和LFU实现"><a href="#Redis的LRU和LFU实现" class="headerlink" title="Redis的LRU和LFU实现"></a>Redis的LRU和LFU实现</h2><p>本章介绍了Redis对LRU和LFU数据结构的维护，这是必要的前置知识。<br>这一部分的实现是在先前介绍过的<code>lookupKey</code>函数中。根据<code>server.maxmemory_policy</code>分别用LRU和LFU进行维护。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lookUpKey</span></span><br><span class="line"><span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        updateLFU(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的evict的时刻是<code>freeMemoryIfNeeded</code>函数。<br>Redis对每个<code>robj</code>对象去维护了一个<code>lru:LRU_BITS</code>字段。在3.0版本，这个字段被用来存储当前秒级别的时间戳。在往后的版本中还支持LFU模式，会复用这个字段。</p><p>维护了的LRU或者是LFU在<code>evictionPoolPopulate</code>中起作用，会分别根据<code>estimateObjectIdleTime</code>和<code>255-LFUDecrAndReturn(e)</code>进行排序</p><h3 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h3><p><code>LRU_CLOCK</code>这里会选择是直接用<code>server.lruclock</code>(也是在<code>serverCron</code>里面调用<code>getLRUClock</code>设置的)，或者直接自己调用一次<code>getLRUClock</code>。这个比较是怎么来的呢？有必要介绍一下，毕竟诸如<code>run_with_period</code>里面也有这样的比较。<br>首先，在<a href="/2020/10/18/redis-sentinel/">文章</a>中已经介绍过，<code>server.hz</code>指的是表示一秒钟被触发多少次。那么<code>1000/server.hz</code>就表示触发1次要多少毫秒。<code>LRU_CLOCK_RESOLUTION</code>的默认值是1000，表示时钟精度是1000毫秒调用一次。所以只要LRU的精度小于server调用的精度，就可以复用server.lruclock，从而少调用一次getLRUClock。<br>【Q】岂不是大多数情况下都可以复用server的时钟？毕竟hz不会为0.5啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        lruclock = server.lruclock;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-1"><a href="#LFU-1" class="headerlink" title="LFU"></a>LFU</h3><p>在访问一个对象的时候，用<code>updateLFU</code>更新<code>lru</code>字段。这个函数会在高16位存一个分钟级别的时间戳ldt，在低8位存访问计数counter。这两个值被存放在一个字段中完全是为了节省空间和复用字段，其组合后的值整体上没有实际意义。<br>更新<code>lru</code>需要注意两点，<strong>即要根据时间衰减，但也要根据访问次数增长</strong>。首先，通过<code>LFUDecrAndReturn</code>，计算通过当前时间和ldt的差值去减少<code>counter</code>。然后通过<code>LFULogIncr</code>以一定概率增加counter。最后，将最新的counter和ldt重新组装起来存入<code>-&gt;lru</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 组装lru字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加counter"><a href="#增加counter" class="headerlink" title="增加counter"></a>增加counter</h4><p>介绍<code>counter</code>随访问次数的增长。<br>每次访问，都需要增加访问计数，但<code>counter</code>的增长并不是访问一次就+1。而是每次访问以<code>[0,1]</code>之间的概率<code>p</code>来增长，当它大于随机<code>r</code>的阈值后才会自增<code>counter</code>。<br>其中<code>p</code>的值是<code>1.0/(baseval*lfu_log_factor+1)</code>，其中<code>baseval</code>为<code>max(0,counter-LFU_INIT_VAL)</code>。</p><p>不妨讨论下baseval：</p><ol><li>baseval=0，p=1</li><li>baseval=1，p=0.09</li><li>baseval=10，p=0.009</li></ol><p>可以看到：</p><ol><li><code>counter</code>越大，<code>counter</code>的自增概率就越小。</li><li><code>lfu_log_factor</code>越大，<code>counter</code>的自增概率就越小<br> 所以为了支持存储更高的访问频次，我们就需要设置更大的<code>lfu_log_factor</code>。</li></ol><p>事实上<code>counter</code>的增长和访问次数是<strong>成对数关系</strong>的。所以这8 bits足够存储很大的命中次数。<br>在更新版本的<a href="https://github.com/redis/redis/blob/9ab873d9d35e789a228c5281d57c9c4fdc1e4ce1/redis.conf#L2156" target="_blank" rel="noopener">redis.conf</a>中，列出了不同<code>lfu_log_factor</code>取值下，若干次hit之后，counter增加的数量。</p><p>因为r是随机取的，所以可能用数学计算挺困难的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | <span class="number">100</span> hits   | <span class="number">1000</span> hits  | <span class="number">100</span>K hits  | <span class="number">1</span>M hits    | <span class="number">10</span>M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">0</span>      | <span class="number">104</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">1</span>      | <span class="number">18</span>         | <span class="number">49</span>         | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">10</span>     | <span class="number">10</span>         | <span class="number">18</span>         | <span class="number">142</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">100</span>    | <span class="number">8</span>          | <span class="number">11</span>         | <span class="number">49</span>         | <span class="number">143</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><p>还需要特别介绍下<code>LFU_INIT_VAL</code>，每个对象在初始化时，对应的counter是<code>LFU_INIT_VAL</code>即5。没有这个，那么在<code>LFUDecrAndReturn</code>的时候，counter就会因为很小而被淘汰掉。但因为偏移了这个5，所以在<code>LFULogIncr</code>我们需要将它还原回实际的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="comment">// 确保不会回绕</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 随机数r</span></span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p小于该随机数r才增长</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-log-factor"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_log_factor, <span class="number">10</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h4 id="衰减counter"><a href="#衰减counter" class="headerlink" title="衰减counter"></a>衰减counter</h4><p><code>LFUDecrAndReturn</code>返回<code>counter</code>，表示当前对象的frequency。<br>此外，如果到了需要减少<code>counter</code>的时候，会尝试减少<code>num_periods</code>。它也不完全是两个时间相减，而是要除以<code>lfu_decay_time</code>。<br><code>server.lfu_decay_time</code>是个衰变因子，默认是1，也就是不衰减。这时候对<code>counter</code>的减少就是经过的分钟数。它还有个特殊值0，表示每次都不衰减(文档上可能错了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出老的分钟时间戳</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 取出老的计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? </span><br><span class="line">        LFUTimeElapsed(ldt) / server.lfu_decay_time : </span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-decay-time"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_decay_time, <span class="number">1</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>简单介绍<code>LFUTimeElapsed</code>，用来计算从<code>ldt</code>开始经过了多少分钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得从ldt开始经过了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="comment">// 如果now小了，就当成已经wrap了刚好一次，这个和estimateObjectIdleTime的实现是类似的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="evictionPoolEntry和evictionPoolPopulate"><a href="#evictionPoolEntry和evictionPoolPopulate" class="headerlink" title="evictionPoolEntry和evictionPoolPopulate"></a>evictionPoolEntry和evictionPoolPopulate</h2><p>来看<code>evictionPoolPopulate</code>这个函数，它作用是往<code>evictionPool</code>里面加一些<code>evictionPoolEntry</code>条目。<code>evictionPool</code>由一系列<code>evictionPoolEntry</code>组成，后者表示某个数据库中的某个键。在<code>evictionPool</code>中的entry都是按照<code>idle</code>排序的，左边的idle time最小，从小到大升序排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><ol><li><code>idle</code><br> 表示每个对象的空闲时间。pool里面只能加入具有更大idle time的键。如果还有空余空间，就始终加入。</li><li><code>cached</code><br> <strong>这是一个有趣的优化</strong><br> 如果key的长度比较小，它就会被存在预分配好空间的cached结构中，从而避免在key中分配空间的开销。</li><li><code>dbid</code><br> 表示这个键所属的数据库。</li></ol><p>如何根据LRU或者LFU计算idle呢？</p><ol><li><p>如果采用LRU<br> 调用<code>estimateObjectIdleTime</code>函数计算，实际上就是乘以一个<code>LRU_CLOCK_RESOLUTION</code>。这里实现上还处理了一下回绕wrap的情况。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果采用LFU<br> 这里要反向一下，就是用255减一下<code>LFUDecrAndReturn(o)</code>。因为idle和访问频率是相反的。</p></li></ol><p>输入参数：</p><ol><li><code>sampledict</code>表示从哪个dict里面进行采样，根据策略不同，可能是dict(allkeys策略)或者expire(volatile策略)。</li><li><code>keydict</code>只能是对应的dict。因为expire里面只是存一个”引用”。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code>这个函数从dict里面任意取出若干个entry。<code>server.maxmemory_samples</code>默认被设置成5个。在取出这些entry到<code>samples</code>后，我们挨个尝试将它们插入pool中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的一段代码计算这个对象的<code>idle</code>时间。首先需要讨论是否需要回dict表再查一次，得到<code>keydict</code>中的entry <code>de</code>，以及key对应的val <code>o</code>：</p><ol><li>回表的情况<br> 显然，只要<code>sampledict</code>不等于<code>keydict</code>就需要回表。因为<code>sampledict</code>肯定是expire。</li><li>不回表的情况</li><li>特殊情况：volatile-ttl策略<br> 前面两种情况都是用的<code>keydict</code>中对应的entry、key和val，但这里我们直接用<code>sampledict</code>的。</li></ol><p>然后需要讨论具体的策略，这个在前面讲过了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment">         * idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment">         * just a score where an higher score means better candidate. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面的代码计算出了当前key对应的<code>idle</code>时间，接下来将元素插入到池中。这是一个类似<strong>插入排序</strong>的过程。<br>首先，找到第一个空bucket，或者找到第一个<code>idle &lt;= pool[k].idle</code>，可以插到它前面。下面的循环能够跳过所有不满足以上条件的情况。【Q】这里能直接二分么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理两种特殊情况，第一种是我们的<code>idle</code>比pool里面所有的idle都要小，并且也没有空余的格子给我们了。第二种是bucket完全空的情况，我们可以直接用最左边的格子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，因为<code>key</code>和<code>cache</code>有点类似于<strong>自引用结构</strong>的关系，但其实不是。因为key和cached实际上都是sds，也就是个<code>char*</code>。移动或者复制sds，并没有改变sds指向的内容。所以，我们只需要保证<strong>只要它不释放就行</strong>。<br>当然，发散一下，如果<code>key</code>是一个指向<code>cached</code>的<code>sds*</code>，那就真的是自引用结构了。但也并不需要绑定<code>key</code>和它可能指向的<code>cached</code>在一个结构中，因为这两个是一一对应的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| key <span class="number">1</span> | key <span class="number">2</span> | key <span class="number">3</span> | nul k |</span><br><span class="line">| nul c | cac <span class="number">3</span> | cac <span class="number">2</span> | cac <span class="number">1</span> |</span><br></pre></td></tr></table></figure><p>此时<code>k</code>是第一个满足<code>idle &lt;= pool[k].idle</code>，我们的新entry应该插入在<code>k</code>之前。下面就插入排序，把待插入的<code>de</code>插入，然后把原来<code>k</code>以及之后的数字往右边移动。这里使用了memmove，它能自动检测src内存和dest内存重叠的情况并处理，所以是更安全的memcpy。<br>分为两种情况：</p><ol><li>最右边还有空位，将[k,)整体右移一格，新entry预计插入<code>k</code>处<br> 尽管这时候最右边的cached是空，但我们还是需要备份。否则就会泄露掉那一块内存。</li><li>最右边没有空位，将整个数组右移一格，新entry预计插入在<code>k-1</code>处<br> 此时最左边是idle最小的，将它从pool里面去掉，换成idle更大的。<br> 但同时，也要保证最左边的cached不被意外释放。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，将新entry插入pool中。这里说明下cached的使用：</p><ol><li>如果<code>key</code>的长度大于<code>EVPOOL_CACHED_SDS_SIZE</code><br> 则复制<code>key</code>到<code>pool[k].key</code></li><li>如果<code>key</code>的长度较小，就可以尝试做优化，将它放在<code>cached</code>中，然后让把<code>cache</code>赋值给<code>key</code>，从而避免复制底层的字符串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">// 尝试复用pool entry中的cached SDS。因为内存分配和回收还是开销比较大的。</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictGetSomeKeys"><a href="#dictGetSomeKeys" class="headerlink" title="dictGetSomeKeys"></a>dictGetSomeKeys</h3><p><code>dictGetSomeKeys</code>这个函数，是对一个dict来说的，而不是对db来说的。<br>它不保证一定返回正好count个，也不保证返回的元素都不重复。返回值被存到<code>des</code>里面，需要保证这个数组至少能容纳<code>count</code>个。<br>取出来的指针存在<code>des</code>中返回。<code>des</code>必须预分配至少<code>count</code>个空间，尽管函数可能未必能取到<code>count</code>个。其原因可能是本来就没那么多个，或者我们经过多轮迭代没添加完。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is not suitable when you need a good distribution</span></span><br><span class="line"><span class="comment"> * of the returned items, but only when you need to "sample" a given number</span></span><br><span class="line"><span class="comment"> * of continuous elements to run some kind of algorithm or to produce</span></span><br><span class="line"><span class="comment"> * statistics. However the function is much faster than dictGetRandomKey()</span></span><br><span class="line"><span class="comment"> * at producing N elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; <span class="comment">/* internal hash table id, 0 or 1. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; <span class="comment">/* 1 or 2 tables? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>首先，执行一点渐进式rehash。然后将<code>maxsizemask</code>设置为所有ht(没有rehash是1个，有是2个)的最大容量。<br>将<code>i</code>设置为随机一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Try to do a rehashing work proportional to 'count'. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">    <span class="comment">/* Pick a random point inside the larger table. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面进入主循环，循环条件有两个，一个是取满count个，一个是执行最多<code>maxsteps=count*10</code>次。<br>在每一次迭代中，对所有的ht（1或2个）进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">/* Continuous empty entries so far. */</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>涉及到rehashidx相关的逻辑，表示在每次进入<code>dictRehash</code>函数的时候，首先<code>ht[0].table[rehashidx]</code>这个桶。如果现在在rehash过程中，到<code>d-&gt;rehashidx</code>为止的所有index都已经被访问过了。实际上这些桶里面都空(not populated)了，因此我们可以跳过<code>ht[0]</code>里面$[0,idx-1]$这个区间的关卡，直接去看<code>ht[1]</code>里面的。这其实是一个优化，在<code>dictRehash</code>实现中，也有对空桶跳过的优化。<br>特别地，如果<code>i</code>在<code>ht[1]</code>里面也已经超了，这就表示截止到<code>rehashidx</code>两个表里面都没有了。【Q】为什么可以认为<code>ht[1]</code>中的<code>rehashidx</code>之前的也不需要判定了呢？或者说，为啥两个ht可以共享一个<code>i</code>呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">/* Out of range for this table. */</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们会统计遇到连续空桶的数量，如果超过了5个，就重新随机一个位置。</span></span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123;</span><br><span class="line">                    i = random() &amp; maxsizemask;</span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，我们使用桶里面所有的元素</span></span><br><span class="line">                emptylen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (he) &#123;</span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在主循环结束后，会自增<code>i</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主逻辑freeMemoryIfNeeded"><a href="#主逻辑freeMemoryIfNeeded" class="headerlink" title="主逻辑freeMemoryIfNeeded"></a>主逻辑freeMemoryIfNeeded</h2><p><code>freeMemoryIfNeeded</code>函数是evict的主要逻辑。<br>首先，如果是从服务器，并且配置了<code>server.repl_slave_ignore_maxmemory</code>就忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* By default replicas should ignore maxmemory</span></span><br><span class="line"><span class="comment">     * and just be masters exact copies. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就来计算占用了多少内存<code>mem_reported</code>，主要函数<code>getMaxmemoryState</code>我们放在后面单独讲解。<code>mem_reported</code>表示总共用了多少内存，<code>mem_tofree</code>表示应该释放多少内存(不算Slave和AOF的缓存)。<br><code>clientsArePaused</code>的检查，有点奇怪。根据注释，它的意思是，如果client都被pause了，那么数据就是静止的。不仅对于所有的client是这样，对于还没有做expire和evict的所有key也是这样。我觉得这应该是一个优化，防止在这种情况下再走下面的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency, lazyfree_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="keyword">int</span> result = C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>latencyStartMonitor</code>这个宏和stopwatch一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面开始根据淘汰政策<code>maxmemory_policy</code>进行讨论，如果是noeviction，那就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个内存释放过程是多次的，因此用一个循环来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理要排序的情况"><a href="#处理要排序的情况" class="headerlink" title="处理要排序的情况"></a>处理要排序的情况</h3><p>第一个if，用来处理所有需要排序的情况。查看代码，要用while循环去找<code>bestkey</code>，原因是可能从pool里面找到的key不存在了，【Q】可是究竟什么情况下会发生这个情况呢？<br>循环里面的过程就是我们去遍历整个数据库里面的所有db，如果它的<code>dict</code>或者<code>expires</code>不为空，则调用<code>evictionPoolPopulate</code>。这个函数会往pool里面加入一些key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，我们遍历整个pool，找到最合适的一个。解释几个问题：</p><ol><li>为什么要从尾往头遍历？<br> 在对evictionPool的介绍中提到，它是有序的，最左边的idle time最小，最右边的最大，因此优先淘汰右边的。</li><li>为什么要有bestdbid？将key之间的比较转化为数据库之间的比较么？</li><li><code>server.db[pool[k].dbid]</code>是什么鬼？<br> 实际上是要选择<code>pool[k].dbid</code>这个db。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                        <span class="comment">// 这个很奇怪，什么时候会出现这种情况呢？</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理随机情况"><a href="#处理随机情况" class="headerlink" title="处理随机情况"></a>处理随机情况</h3><p>第二个if，用来处理随机的情况。这个很简单，直接调用<code>dictGetRandomKey</code>就行，和eviction pool也没啥关系了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>如果我们找到了要删除的元素<code>bestkey</code>，就执行删除元素过程。<br>首先，调用老朋友<code>propagateExpire</code>，这个会发送一条删除指令给AOF/Slave。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，我们统计这次evict释放了多少内存，就是首尾两个<code>zmalloc_used_memory</code>相减。这个有点粗略了，就在刚才我们还将AOF/Slave缓存单独拿出来算的呢，现在直接总内存相减了。在注释中还提到，有可能用来<code>propagateExpire</code>的内存比我们释放的db内存还多呢，但我们是管不了的，否则<code>mem_freed &lt; mem_tofree</code>这个循环条件永远达不到了。并且，这些缓存终究会被释放的。<br>这里还统计了一下调用dictSyncDelete等的时间，并且通过<code>latencyAddSampleIfNeeded</code>放到统计里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            signalModifiedKey(<span class="literal">NULL</span>,db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些统计性的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在循环中就强制往Slave发送数据，确保即使在要传的数据都很大的情况下，我们仍然能够快速传递。<br>特别地，我们在<code>while (mem_freed &lt; mem_tofree)</code>这个循环的最后，还会有条件地检查一下内存是不是达标。这个主要是对异步删除来说的，在这种情况下，<code>dbAsyncDelete</code>流程中对内存的释放未必能和我们循环这边同步起来。所以我们每释放16个键，就检查一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                    <span class="comment">/* Let's satisfy our stop condition. */</span></span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (result != C_OK) &#123;</span><br><span class="line">        latencyStartMonitor(lazyfree_latency);</span><br><span class="line">        <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                result = C_OK;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(lazyfree_latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"eviction-lazyfree"</span>,lazyfree_latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMaxmemoryState"><a href="#getMaxmemoryState" class="headerlink" title="getMaxmemoryState"></a>getMaxmemoryState</h2><p>这个函数获得内存的使用情况，包括：</p><ol><li>total<br> 总共使用的内存。<br> 来自<code>zmalloc_used_memory</code>。</li><li>logical<br> 即<code>mem_used</code>，表示出了Slave/AOF buffer之外的内存。<br> 这个计算就是要减去<code>overhead</code>，也就是Slave/AOF buffer的内存，用<code>freeMemoryGetNotCountedMemory</code>计算得到的。</li><li>level<br> 表示内存使用率</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxmemoryState</span><span class="params">(<span class="keyword">size_t</span> *total, <span class="keyword">size_t</span> *logical, <span class="keyword">size_t</span> *tofree, <span class="keyword">float</span> *level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面获得了总内存量，如果没有设置最大内存，或者总内存量都没有操作，也不需要计算比例，那么就直接返回了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We may return ASAP if there is no need to compute the level. */</span></span><br><span class="line">    <span class="keyword">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>计算两个缓冲区占用的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the ratio of memory usage. */</span></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="keyword">float</span>)mem_used / (<span class="keyword">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><p>在前面的代码中可以看到下面的语句，实际上是对主数据库<code>c-&gt;db</code>进行修改后，需要进行事件通知，我们将在下面介绍这几个语句的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">    <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure><h3 id="signalModifiedKey"><a href="#signalModifiedKey" class="headerlink" title="signalModifiedKey"></a>signalModifiedKey</h3><p><code>signalModifiedKey</code>是key被修改的钩子函数，每当数据库<code>c-&gt;db</code>里面的key被改动时，会调用这个函数。这里的key发生改动也包括key对应的值发生改动，这是因为从<code>genericSetKey</code>的实现可以看到，SET指令也会导致<code>signalModifiedKey</code>被调用。<br>此外，根据注释，每一次DB被flush时，<code>signalFlushDb</code>会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(client *c, redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">    trackingInvalidateKey(c,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="touchWatchedKey"><a href="#touchWatchedKey" class="headerlink" title="touchWatchedKey"></a>touchWatchedKey</h4><p><code>touchWatchedKey</code>字如其名，它的作用是让WATCH这个键的事务失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里先特判一下，如果<code>db-&gt;watched_keys</code>为空就直接返回，这个用法在redis中非常常见，我猜想可能是<code>dictFind</code>的开销还是比较大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面从<code>db-&gt;watched_keys</code>上拿到WATCH这个key的所有的client，并且对这个链表上的每一个client设置<code>CLIENT_DIRTY_CAS</code>这个flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 这个函数是dictFind(只能得到dictEntry)和dictGetVal的简单封装</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trackingInvalidateKey"><a href="#trackingInvalidateKey" class="headerlink" title="trackingInvalidateKey"></a>trackingInvalidateKey</h4><p>下面看另一个函数<code>trackingInvalidateKey</code>。这个系列的函数是在Redis6.0左右被引入的，主要用途是维护客户端缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper (the one actually called across the core) to pass the key</span></span><br><span class="line"><span class="comment"> * as object. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKey</span><span class="params">(client *c, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    trackingInvalidateKeyRaw(c,keyobj-&gt;ptr,sdslen(keyobj-&gt;ptr),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key的值被改变后，在keys tracking的逻辑下，我们的任务是给每一个有可能缓存了当前keys的client发送通知。如果传入的<code>c</code>为空，表示这个不是一个client的场景，而是例如服务器内部做expire。<br><code>bcast</code>参数的作用是是否要将这个key通过BCAST模式广播给client们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * This is the case when the function is called from the Redis core once a key is modified, however</span></span><br><span class="line"><span class="comment"> * we also call the function in order to evict keys in the key table in case</span></span><br><span class="line"><span class="comment"> * of memory pressure: in that case the key didn't really change, so we want</span></span><br><span class="line"><span class="comment"> * just to notify the clients that are in the table for this key, that would</span></span><br><span class="line"><span class="comment"> * otherwise miss the fact we are no longer tracking the key for them. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKeyRaw</span><span class="params">(client *c, <span class="keyword">char</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> bcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TrackingTable == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcast &amp;&amp; raxSize(PrefixTable) &gt; <span class="number">0</span>)</span><br><span class="line">        trackingRememberKeyToBroadcast(c,key,keylen);</span><br><span class="line"></span><br><span class="line">    rax *ids = raxFind(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen);</span><br><span class="line">    <span class="keyword">if</span> (ids == raxNotFound) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    raxIterator ri;</span><br><span class="line">    raxStart(&amp;ri,ids);</span><br><span class="line">    raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> id;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;id,ri.key,<span class="keyword">sizeof</span>(id));</span><br><span class="line">        client *target = lookupClientByID(id);</span><br><span class="line">        <span class="comment">/* Note that if the client is in BCAST mode, we don't want to</span></span><br><span class="line"><span class="comment">         * send invalidation messages that were pending in the case</span></span><br><span class="line"><span class="comment">         * previously the client was not in BCAST mode. This can happen if</span></span><br><span class="line"><span class="comment">         * TRACKING is enabled normally, and then the client switches to</span></span><br><span class="line"><span class="comment">         * BCAST mode. */</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span> ||</span><br><span class="line">            !(target-&gt;flags &amp; CLIENT_TRACKING)||</span><br><span class="line">            target-&gt;flags &amp; CLIENT_TRACKING_BCAST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client enabled the NOLOOP mode, don't send notifications</span></span><br><span class="line"><span class="comment">         * about keys changed by the client itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;flags &amp; CLIENT_TRACKING_NOLOOP &amp;&amp;</span><br><span class="line">            target == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendTrackingMessage(target,key,keylen,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    raxStop(&amp;ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the tracking table: we'll create the radix tree and populate it</span></span><br><span class="line"><span class="comment">     * again if more keys will be modified in this caching slot. */</span></span><br><span class="line">    TrackingTableTotalItems -= raxSize(ids);</span><br><span class="line">    raxFree(ids);</span><br><span class="line">    raxRemove(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyKeyspaceEvent"><a href="#notifyKeyspaceEvent" class="headerlink" title="notifyKeyspaceEvent"></a>notifyKeyspaceEvent</h3><p>函数<code>notifyKeyspaceEvent</code>用来触发数据库事件，这个对应了Redis中的叫<a href="http://redisdoc.com/topic/notification.html" target="_blank" rel="noopener">“键空间通知”/“键事件通知”</a>的特性。这个特性是通过<strong>PUBLISH</strong>机制实现的。<br>简单来说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL key [key ...]</code>命令时，系统将分发两条消息，相当于执行以下两个<a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a>命令。其中<code>__keyspace</code>系列命令称为键空间通知(key-space notification)，<code>__keyevent</code>系列命令称为键事件通知(key-event notification)。订阅第一个PUBLISH命令，可以接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件。订阅第二个PUBLISH命令，可以接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>下面看看这个函数的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If any modules are interested in events, notify the module system now.</span></span><br><span class="line"><span class="comment">     * This bypasses the notifications configuration, but the module engine</span></span><br><span class="line"><span class="comment">     * will only call event subscribers if the event type matches the types</span></span><br><span class="line"><span class="comment">     * they are interested in. */</span></span><br><span class="line">    moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If notifications for this class of events are off, return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyspace@"</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyevent@"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="Redis内存管理zmalloc"><a href="#Redis内存管理zmalloc" class="headerlink" title="Redis内存管理zmalloc"></a>Redis内存管理zmalloc</h2><p>Redis基于zmalloc系列函数进行内存分配。<br>zmalloc是为了解决什么问题呢？主要是为了做到异常处理和内存统计的功能。<br>下面看<code>zmalloc</code>的实现。<br>可以看到，它会额外分配一个<code>PREFIX_SIZE</code>，用来存储额外信息。<code>zmalloc</code>最终返回的是<code>(char*)ptr+PREFIX_SIZE</code>，这个有点类似于SDS的骚操作。<code>PREFIX_SIZE</code>的大小是由宏来定义的，并且可以通过<code>HAVE_MALLOC_SIZE</code>禁用内存统计的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 如果不记录内存分配大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果记录内存分配大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面仔细查看一下<code>update_zmalloc_stat_alloc</code>函数的实现，不出所料的话，应该是通过一个原子操作来实现更新的。实际上也果不其然，<code>atomicIncr</code>的实现在后面会讲到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) atomicIncr(used_memory,(__n))</span></span><br></pre></td></tr></table></figure><p>还可以看到的是一个用来处理oom的函数<code>zmalloc_oom_handler</code>。对于C语言来说，<code>malloc</code>在内存分配失败后会返回一个0指针，然后我们在进行后续操作的时候要自行判断。基本上对于oom的处理就是打印一条日志然后abort了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisOutOfMemoryHandler</span><span class="params">(<span class="keyword">size_t</span> allocation_size)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Out Of Memory allocating %zu bytes!"</span>,</span><br><span class="line">        allocation_size);</span><br><span class="line">    serverPanic(<span class="string">"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"</span>, </span><br><span class="line">        allocation_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)</span></span><br><span class="line"><span class="comment">// debug.c</span></span><br><span class="line"><span class="keyword">void</span> _serverPanic(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *msg, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,msg);</span><br><span class="line">    <span class="keyword">char</span> fmtmsg[<span class="number">256</span>];</span><br><span class="line">    vsnprintf(fmtmsg,<span class="keyword">sizeof</span>(fmtmsg),msg,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    bugReportStart();</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"!!! Software Failure. Press left mouse button to continue"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Guru Meditation: %s #%s:%d"</span>,fmtmsg,file,line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.crashlog_enabled) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">        logStackTrace(<span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        printCrashReport();</span><br><span class="line">    &#125;</span><br><span class="line">    bugReportEnd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bugReportStart</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bug_report_start_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bug_report_start == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLogRaw(LL_WARNING|LL_RAW,</span><br><span class="line">        <span class="string">"\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n"</span>);</span><br><span class="line">        bug_report_start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bug_report_start_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下本章节中比较有意思的实现：</p><ol><li>LFU算法</li><li>evictPoolEntry中，key和cached的维护</li><li>诸如keyptrDictType和dbDictType这种C形式的OOP的实现</li><li>Redis对OOM的管理</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://my.oschina.net/lscherish/blog/4467394" target="_blank" rel="noopener">https://my.oschina.net/lscherish/blog/4467394</a><br> 对Redis中的LRU和LFU进行了讲解。本文吸纳了其中的部分内容并进行了修订。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为原&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;《Redis底层对象实现原理分析》&lt;/a&gt;太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redisDb，以及在这上面的增删改查&lt;/li&gt;
&lt;li&gt;Redis的expire和evict机制&lt;/li&gt;
&lt;li&gt;Redis的事件机制&lt;/li&gt;
&lt;li&gt;Redis的主从复制(一部分)&lt;br&gt; 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。&lt;br&gt; 本文介绍的部分比如propagate机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文中不介绍的是，它们在系列的其他文章中讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis的对象实现&lt;/li&gt;
&lt;li&gt;Redis Sentinel&lt;/li&gt;
&lt;li&gt;Redis Cluster&lt;/li&gt;
&lt;li&gt;Redis AOF/RDB&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>我们如何消除两个开源项目之间长达 4 年的分叉</title>
    <link href="http://www.calvinneo.com/2022/10/13/decouple-tikv/"/>
    <id>http://www.calvinneo.com/2022/10/13/decouple-tikv/</id>
    <published>2022-10-13T11:20:33.000Z</published>
    <updated>2022-10-24T11:55:08.661Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects" target="_blank" rel="noopener">https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>TiFlash 源码解读：TiFlash Proxy 模块</title>
    <link href="http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/"/>
    <id>http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/</id>
    <published>2022-08-25T11:20:33.000Z</published>
    <updated>2023-01-12T16:16:08.755Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/tiflash-source-code-reading-7" target="_blank" rel="noopener">https://cn.pingcap.com/blog/tiflash-source-code-reading-7</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>Linux 的文件系统</title>
    <link href="http://www.calvinneo.com/2022/06/21/linux-fs/"/>
    <id>http://www.calvinneo.com/2022/06/21/linux-fs/</id>
    <published>2022-06-21T13:48:56.000Z</published>
    <updated>2022-06-21T13:34:19.939Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Linux 文件系统。</p><a id="more"></a><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.cnblogs.com/zl1991/p/10288291.html" target="_blank" rel="noopener">https://www.cnblogs.com/zl1991/p/10288291.html</a><br> O_SYNC 和 O_DIRECT</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Linux 文件系统。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://www.calvinneo.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Rust闭包实现递归</title>
    <link href="http://www.calvinneo.com/2022/06/18/rust-closure-self/"/>
    <id>http://www.calvinneo.com/2022/06/18/rust-closure-self/</id>
    <published>2022-06-18T12:28:29.000Z</published>
    <updated>2023-01-12T16:15:23.306Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2017/07/28/Y-Combinator/">不动点组合子Y-Combinator</a>中介绍了如何借助 Y-Combinator 和 Z-Combinator 实现在闭包中引用自己。</p><a id="more"></a><h1 id="基于-Y-Combinator-的方案"><a href="#基于-Y-Combinator-的方案" class="headerlink" title="基于 Y-Combinator 的方案"></a>基于 Y-Combinator 的方案</h1><p>回忆一下 Y-Combinator 的定义</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Y = λf.(λ<span class="keyword">x</span>.f (<span class="keyword">x</span> <span class="keyword">x</span>)) (λ<span class="keyword">x</span>.f (<span class="keyword">x</span> <span class="keyword">x</span>))</span><br></pre></td></tr></table></figure><h2 id="Fn"><a href="#Fn" class="headerlink" title="Fn"></a>Fn</h2><p>这里的<code>X</code>是为了实现 Y-Combinator 中的 <code>x x</code> 这样的结构。从<a href="/2017/07/28/Y-Combinator/">不动点组合子Y-Combinator</a>中可以知道 x 实际上是个递归类型。</p><p>容易看出，这里很多东西都是一样的，例如<code>Rc&lt;dyn Fn(A) -&gt; O&gt;</code>和<code>impl Fn(A) -&gt; O</code>都表示的是F：</p><ol><li>返回值可以用 impl 做静态分发，当然写成 <code>Box&lt;dyn Fn(A) -&gt; O&gt;</code> 返回也是没问题的</li><li>impl 本身也不能作为 closure 的参数<br> <code>impl Trait</code> only allowed in function and inherent method return types, not in closure param<br> 但是可以在普通函数中用 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> fi = |i:<span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> f1 = |f: <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; f(<span class="number">1</span>) &#125;;</span><br><span class="line"><span class="comment">// OK</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">fi</span></span>(i:<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">f1</span></span>(f: <span class="keyword">impl</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; f(<span class="number">1</span>) &#125;</span><br></pre></td></tr></table></figure></li></ol><p>整个实现如下所示，简单介绍下：</p><ol><li><code>(|x: X&lt;F&gt;| x.call(x.clone()))(x)</code><br> 实际上就是 <code>x x</code>，这里用 eta-conversion 来避免了立即求值。</li><li>那么 <code>inner1</code> 就应该是 <code>(λx.f (x x))</code>了<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">y</span></span>&lt;A, O, F&gt;(f: Rc&lt;dyn <span class="built_in">Fn</span>(Rc&lt;dyn <span class="built_in">Fn</span>(A) -&gt; O&gt;) -&gt; F&gt;) -&gt; <span class="keyword">impl</span> <span class="built_in">Fn</span>(A) -&gt; O</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">Fn</span>(A) -&gt; O,</span><br><span class="line">        F: <span class="symbol">'static</span>,</span><br><span class="line">        A: <span class="symbol">'static</span>,</span><br><span class="line">        O: <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span></span>&lt;F&gt;(Rc&lt;dyn <span class="built_in">Fn</span>(X&lt;F&gt;) -&gt; F&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>(Rc::clone(&amp;<span class="keyword">self</span>.<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, x: <span class="keyword">Self</span>) -&gt; F &#123;</span><br><span class="line">            (<span class="keyword">self</span>.<span class="number">0</span>)(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> inner = Rc::new(<span class="keyword">move</span> |x: X&lt;F&gt;| f(</span><br><span class="line">            Rc::new(<span class="keyword">move</span> |a| (x.call(x.clone())) (a))</span><br><span class="line">        ));</span><br><span class="line">    <span class="keyword">let</span> x = X(inner);</span><br><span class="line">    (|x: X&lt;F&gt;| x.call(x.clone()))(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="FnMut"><a href="#FnMut" class="headerlink" title="FnMut"></a>FnMut</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">y_mut</span></span>&lt;A, O, F&gt;(f: Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(A) -&gt; O&gt;&gt;) -&gt; F&gt;&gt;) -&gt; <span class="keyword">impl</span> <span class="built_in">FnMut</span>(A) -&gt; O</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">        F: <span class="built_in">FnMut</span>(A) -&gt; O,</span><br><span class="line">        F: <span class="symbol">'static</span>,</span><br><span class="line">        A: <span class="symbol">'static</span>,</span><br><span class="line">        O: <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">X</span></span>&lt;F&gt;(Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(X&lt;F&gt;) -&gt; F&gt;&gt;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; <span class="built_in">Clone</span> <span class="keyword">for</span> X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">clone</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">            <span class="keyword">Self</span>(Rc::clone(&amp;<span class="keyword">self</span>.<span class="number">0</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span>&lt;F&gt; X&lt;F&gt; &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>, x: <span class="keyword">Self</span>) -&gt; F &#123;</span><br><span class="line">            ((*<span class="keyword">self</span>.<span class="number">0</span>).borrow_mut())(x)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ff = Rc::new(RefCell::new(<span class="keyword">move</span> |x: X&lt;F&gt;| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> ff_borrowd = (*f).borrow_mut();</span><br><span class="line">        ff_borrowd(Rc::new(RefCell::new(<span class="keyword">move</span> |a| (x.call(x.clone()))(a))))</span><br><span class="line">    &#125;));</span><br><span class="line">    <span class="keyword">let</span> x = X(ff);</span><br><span class="line">    (|x: X&lt;F&gt;| x.call(x.clone()))(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(RefCell::new(<span class="built_in">vec!</span>[<span class="number">0</span>; <span class="number">5</span>]));</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">usize</span> = (*a).borrow_mut().len();</span><br><span class="line"></span><br><span class="line">    y_mut(Rc::new(RefCell::new(&#123;</span><br><span class="line">        <span class="keyword">let</span> a = Rc::clone(&amp;a);</span><br><span class="line">        <span class="keyword">move</span> |f: Rc&lt;RefCell&lt;dyn <span class="built_in">FnMut</span>(<span class="built_in">usize</span>)&gt;&gt;| &#123;</span><br><span class="line">            <span class="keyword">let</span> a = Rc::clone(&amp;a);</span><br><span class="line">            <span class="keyword">move</span> |i| &#123;</span><br><span class="line">                <span class="keyword">if</span> i &lt; n &#123;</span><br><span class="line">                    (*a).borrow_mut()[i] = i;</span><br><span class="line">                    ((*f).borrow_mut())(i + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)))(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a is &#123;:?&#125;"</span>, a.borrow());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h1><ol><li>struct 包 closure</li><li>在 fn 定义 fn<br> 但不能捕获任何变量了</li><li><a href="https://stackoverflow.com/questions/16946888/is-it-possible-to-make-a-recursive-closure-in-rust" target="_blank" rel="noopener">一个神奇的办法</a><br> 这个做法很有趣，它实际上是先顶一个 placeholder 的 fact 函数即 weak_holder，在真正的 fact 函数被定义时，调用 myself。在 fact 函数定义结束后，再把 fact 函数赋给 placeholder 的 weak_holder。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::&#123;</span><br><span class="line">    cell::RefCell,</span><br><span class="line">    rc::&#123;Rc, Weak&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> weak_holder: Rc&lt;RefCell&lt;Weak&lt;dyn <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt;&gt;&gt; =</span><br><span class="line">        Rc::new(RefCell::new(Weak::&lt;<span class="function"><span class="keyword">fn</span></span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt;::new()));</span><br><span class="line">    <span class="keyword">let</span> weak_holder2 = weak_holder.clone();</span><br><span class="line">    <span class="keyword">let</span> fact: Rc&lt;dyn <span class="built_in">Fn</span>(<span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span>&gt; = Rc::new(<span class="keyword">move</span> |x| &#123;</span><br><span class="line">        <span class="keyword">let</span> myself = weak_holder2.borrow().upgrade().unwrap();</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x * myself(x - <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    weak_holder.replace(Rc::downgrade(&amp;fact));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fact(<span class="number">5</span>)); <span class="comment">// prints "120"</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, fact(<span class="number">6</span>)); <span class="comment">// prints "720"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2017/07/28/Y-Combinator/&quot;&gt;不动点组合子Y-Combinator&lt;/a&gt;中介绍了如何借助 Y-Combinator 和 Z-Combinator 实现在闭包中引用自己。&lt;/p&gt;</summary>
    
    
    
    
    <category term="函数式" scheme="http://www.calvinneo.com/tags/函数式/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中的异常</title>
    <link href="http://www.calvinneo.com/2022/03/19/exception_cpp/"/>
    <id>http://www.calvinneo.com/2022/03/19/exception_cpp/</id>
    <published>2022-03-19T11:20:33.000Z</published>
    <updated>2023-03-07T07:41:43.869Z</updated>
    
    <content type="html"><![CDATA[<p>C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。</p><a id="more"></a><h1 id="C-异常的开销"><a href="#C-异常的开销" class="headerlink" title="C++ 异常的开销"></a>C++ 异常的开销</h1><p>C++ 将异常视为特殊路径。编译器优化时倾向于对 try-catch 包裹中的代码按照不抛异常进行优化。反之，如果执行到异常代码，则会伴随着很高的惩罚。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::high_resolution_clock;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::duration_cast;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::duration;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::chrono::milliseconds;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; global_vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exception_call_all_throw_inner</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"prevent optimization"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exception_all_throw_call</span><span class="params">(<span class="keyword">int</span> &amp; a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        exception_call_all_throw_inner(a);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        a = (a + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            global_vec.push_back(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">9999</span>) &#123;</span><br><span class="line">            global_vec.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">55</span>) &#123;</span><br><span class="line">            a += global_vec.size();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exception_call_no_throw_inner</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">10010</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">"prevent optimization"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">exception_no_throw_call</span><span class="params">(<span class="keyword">int</span> &amp; a)</span> </span>&#123;</span><br><span class="line">    a = (a + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        global_vec.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">9999</span>) &#123;</span><br><span class="line">        global_vec.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        exception_call_no_throw_inner(a);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">55</span>) &#123;</span><br><span class="line">        a += global_vec.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">no_exception_call</span><span class="params">(<span class="keyword">int</span> &amp; a)</span> </span>&#123;</span><br><span class="line">    a = (a + <span class="number">1</span>) % <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        global_vec.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">9999</span>) &#123;</span><br><span class="line">        global_vec.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a % <span class="number">100</span> == <span class="number">55</span>) &#123;</span><br><span class="line">        a += global_vec.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loop_main</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    global_vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">19999933</span>; i++) &#123;</span><br><span class="line">        f(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ms_inte_no;</span><br><span class="line">    <span class="keyword">int</span> ms_inte_all;</span><br><span class="line">    <span class="keyword">int</span> ms_intnoe;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t1 = high_resolution_clock::now();</span><br><span class="line">        loop_main(exception_no_throw_call);</span><br><span class="line">        <span class="keyword">auto</span> t2 = high_resolution_clock::now();</span><br><span class="line">        ms_inte_no = duration_cast&lt;milliseconds&gt;(t2 - t1).count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exception no throw cost %d vec %lu\n"</span>, ms_inte_no, global_vec.size());</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t1 = high_resolution_clock::now();</span><br><span class="line">        loop_main(exception_all_throw_call);</span><br><span class="line">        <span class="keyword">auto</span> t2 = high_resolution_clock::now();</span><br><span class="line">        ms_inte_all = duration_cast&lt;milliseconds&gt;(t2 - t1).count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exception all throw cost %d vec %lu\n"</span>, ms_inte_all, global_vec.size());</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t1 = high_resolution_clock::now();</span><br><span class="line">        loop_main(no_exception_call);</span><br><span class="line">        <span class="keyword">auto</span> t2 = high_resolution_clock::now();</span><br><span class="line">        ms_intnoe = duration_cast&lt;milliseconds&gt;(t2 - t1).count();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no exception cost %d vec %lu\n"</span>, ms_intnoe, global_vec.size());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"loss exception no throw %f\n"</span>, (ms_inte_no - ms_intnoe) * <span class="number">1.0</span> / ms_intnoe);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"loss exception all throw %f\n"</span>, (ms_inte_all - ms_intnoe) * <span class="number">1.0</span> / ms_intnoe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上面的代码为例，执行结果如下，可以发现，如果全抛异常的执行时间达到一百多倍之多。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1619</span><br><span class="line">exception no throw cost 118 vec 45</span><br><span class="line">1619</span><br><span class="line">exception all throw cost 21453 vec 45</span><br><span class="line">1619</span><br><span class="line">no exception cost 114 vec 45</span><br><span class="line">loss exception no throw 0.035088</span><br><span class="line">loss exception all throw 187.184211</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;C++中的异常是很多人不推荐使用的机制，但其中有很多玄学，不妨来讲一讲。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>F1的在线异步DDL</title>
    <link href="http://www.calvinneo.com/2022/01/28/f1-ddl/"/>
    <id>http://www.calvinneo.com/2022/01/28/f1-ddl/</id>
    <published>2022-01-28T15:33:22.000Z</published>
    <updated>2022-07-16T06:06:54.484Z</updated>
    
    <content type="html"><![CDATA[<p>介绍F1的在线异步DDL schema变更。</p><a id="more"></a><h1 id="简要问题"><a href="#简要问题" class="headerlink" title="简要问题"></a>简要问题</h1><h2 id="定义问题"><a href="#定义问题" class="headerlink" title="定义问题"></a>定义问题</h2><p>我们需要处理DDL执行进度不一致的问题，比如：</p><ol><li>Node A已经处理了a/b/c三个DDL</li><li>Node B刚处理完a这个DDL</li></ol><p>假定c是创建一个表，那么Node A能看见这个表，而Node B则看不见。那么分别从Node A和B查询，就会发现数据不一致的情况。</p><p>具体来说，有两类不一致问题需要考虑：</p><ol><li>orphan data anomaly<br> 违反1/3/5/7</li><li>integrity anomaly<br> 违反2/4/6</li></ol><p>其中：</p><ol><li>所有 ColumnKV 都能找到一个包含它的 Row 和 Table。</li><li>所有 Row 都包含所有非空列的 ColumnKV。</li><li>所有 IndexKV 都能找到一个包含它的 Index。</li><li>所有 Index 都是完整的(不存在某个 Row 缺少指向它的 IndexKV)。</li><li>所有 IndexKV 都指向有效的 Row。</li><li>没有违反 Constraint 的数据。</li><li>不存在未知的 KV(特指除上述 1，3 以外的未知 KV)。</li></ol><h2 id="分步解决问题"><a href="#分步解决问题" class="headerlink" title="分步解决问题"></a>分步解决问题</h2><p>目标1：在同一时刻改变所有Node的状态。很遗憾，因为各种延迟并不能做到。<br>妥协后的目标1：在某一时刻修改Schema，在确定的时间长度T之后，整个集群中不会有使用旧Schema的Node继续提供服务。这样在T之后这个修改就是确定生效的了。<br>方案：</p><ol><li>定时刷新<br> 每个节点会按照固定时间刷新自己的Schema。<br> 例如，可以选举出一个Owner，每个节点定时向Owner请求当前的Schema。</li><li>强制失败<br> 如果刷新失败，则停止服务，而不是继续按照旧Schema服务。</li></ol><p>目标1.1：在集群间同步最新的Schema<br>方案：借助于Spanner</p><ol><li>每次刷新时，从Spanner上的某个固定位置加载Schema。</li></ol><p>在实现目标1后，发现还是有问题。例如，虽然a/b在a+T/b+T时刻被完成，但在a+T之前的某个时刻，我们仍然不知道当前状态是a已生效，还是ab都已生效。如果在加上个c，那么情况更复杂。</p><p>目标2：在同一时刻，只会有最多两个Schema生效。例如在同一时刻内，最多只有DDL a之前的状态和DDL a之后的状态生效。<br>分析：直接Bruteforce搞就行，比如插一个barrier，等到DDL a确定生效(等到a+T)后，再执行DDL b。<br>方案：</p><ol><li>引入Lease，长度等于DDL确定生效的时间</li><li>每个Lease中只能执行一个DDL</li><li>我们在T+2个Lease时一定可以执行DDL b</li></ol><p>目标2.1：不会产生不合法的DML。<br>方案：write fencing</p><ol><li>事务允许跨越多个Lease。</li><li>但是，如果事务中有写操作，写操作只允许在当前Lease中进行：<ol><li>写操作在他们submit时，转换为Spanner上的KV操作</li><li>如果写操作跨Lease，可能会违反同一时刻集群中最多只有两个Schema版本生效的限制。</li></ol></li></ol><p>通过实现之前的目标进行了问题的分解，不需要处理多个DDL的进度不一致问题了。但仍然存在问题，考虑一个add index的DDL，Node A上已经执行完了，Node B则没有开始执行，然后考虑此刻开始执行的两个DML：</p><ol><li>通过Node A添加一个Row：会添加数据和索引</li><li>通过Node B删除一个Row：只会删除数据，因为尚未得到索引的schema</li></ol><p>现在如果从Node A索引读，那么会读到一开始被写入的索引，但对应的数据却被删除了。于是这里产生了<strong>孤儿索引</strong>的问题，这破坏了数据库的完整性。这是因为不同Node之间同一DDL的进度不同产生的不一致，如何解决呢？</p><p>目标3：将这一个DDL拆成多个Schema Change的步骤。由于Update可以看做是Delete+Insert，所以实际需要考虑Insert、Delete和Query三种操作。</p><p>从孤儿索引的问题可以看出，delete操作需要和insert操作分离，要拆出一个Delete Only状态，这个状态下该DDL的只对Delete操作可见，即该索引只对Delete操作可见：</p><ol><li>从None到Delete Only<br> 增和查都不会使用索引。<br> <strong>所有的删除操作会使用索引</strong>。</li><li>从Delete Only到Public<br> 不会出现孤儿索引问题了。假如Node A在Delete Only状态，它会在删除时一并删除索引；Node B在Public状态，在查询时发现索引被一并删除了。</li></ol><p>但有个新的问题，索引不会“多出来”，<strong>但却可能缺</strong>。这就得需要有个操作帮忙补索引，也就是reorg。<br>这个补索引的过程能发生在Delete Only到Public之间么？假设Node A在Delete Only阶段，它只能响应删除，然后开始为既有数据补索引，直到补完变成Public，同时可以处理增删改查。问题是这个过程中的insert，对应的索引并没有被补上啊。因此，需要引入新的状态Write Only。</p><p>于是引入Write Only状态，这个过程只不允许读：</p><ol><li>从Delete Only到Write Only</li><li>从Write Only到Public<br> 假如Node A在Write Only状态，它的<strong>所有写操作都会涉及索引</strong>。而Node B在Public状态，它也能读到Node A的修改。</li></ol><p>考虑所有节点都到达了Write Only状态，现在就可以做Reorg补上之前的索引数据了，方式很简单，就是取一个现在的Snapshot，然后照着补。此时可能有并发写的冲突问题，但Spanner的Percolator协议可以解决。</p><p>目标4：缩短Lease长度。Lease长度一般都会很长，F1中是分钟级，TiDB中也有45秒。如果完全走Lease的方案，那么一次DDL的时间就是分钟级的了，这显然很难被接受<br>方案1：直接将Lease长度缩短，例如改为1s。<br>这个方案是有问题的：</p><ol><li>在每个Lease结束后，Node需要去加载最新的Schema，这个伴随网络开销，需要时间。如果加载Schema的时间大于Lease的时间，那么就会导致刚加载的又失效了，从而重新加载，极大地降低了性能。</li></ol><p>既然方案1不行，那么就有了方案2<br>方案2：</p><ol><li>Owner在修改完DDL后，主动通知其他节点，并统计ack。如果其他节点都回复了，那么就主动确定了这个ddl在所有节点上都生效了。</li><li>如果有节点没有回复，那么再主动等2个Lease。</li></ol><h1 id="论文证明"><a href="#论文证明" class="headerlink" title="论文证明"></a>论文证明</h1><h2 id="Denotation"><a href="#Denotation" class="headerlink" title="Denotation"></a>Denotation</h2><p>一个 F1 schema 是一系列 table的定义。每个 table 包含一系列 column、index、constraint、optimistic lock。其中 constraint 包含外键以及 unique 约束。</p><h2 id="Schema-elements-and-states"><a href="#Schema-elements-and-states" class="headerlink" title="Schema elements and states"></a>Schema elements and states</h2><p>schema elements 包括 table、column、index、constraint、optimistic lock。每个 element 都可以对应 absent 和 public 两个 state。此外，还有 delete only 和 write only 两个中间态。</p><p>【定义1】一个 delete only 的 table、column 和 index 不能被读，且：</p><ol><li>如果 E 是 table 或 column，则只能被 delete</li><li>如果 E 是 index，则只能被 delete 和 update，<strong>这里的 update 不包含 create</strong><br> 注意这里的范围会更大一点了。</li></ol><p>【定义2】一个 write only 的 column 或 index 可以被 insert、delete、update，但继续不能被读。</p><p>【定义3】一个 write only 的 constraint 会在执行 insert、delete、update 操作应用。但它不能覆盖所有的已有数据。</p><h2 id="Database-consistency"><a href="#Database-consistency" class="headerlink" title="Database consistency"></a>Database consistency</h2><p>【定义4】一个 database representation(可以理解为某个快照) d consistent with respect to schema S，如果</p><ol><li>所有的 column 都属于 row 和 table</li><li>所有的 row 都具有所有 public required 的 column 值</li><li>所有的 index entry(索引数据)在 schema 中都能找到对应的 index<br> 也就是说我们写了条索引，但是 schema 里面却没有定义这一条索引</li><li>所有的 public 的 index 是完整的<br> 也就是说不会存在某一个 row 上没有对应的 index</li><li>所有的 index 都能指向 valid 的 row<br> 实际上就是不会有孤儿索引</li><li>所有的 public 的 constraint 一定是满足的</li><li>不存在未知数据</li></ol><p>这个定义在之前已经提到过了。</p><p>We denote the fact that database representation d is consistent with respect to schema S as d |= S. If d is not consistent with respect to schema S, we denote this as d |/= S.</p><p>【定义5】<strong>从 S1 到 S2 的 schema change，是 consistentcy preserving 的，当且仅当</strong>：</p><ol><li>d 在 schema S1 中任何操作下能够对 schema S2 也能保持 consistency</li><li>d 在 schema S2 中任何操作下能够对 schema S1 也能保持 consistency</li></ol><p>下图描述了不同元素的 schema 的变更。<br><img src="/img/f1/f1_schema_change.png"></p><h2 id="Adding-and-removing-schema-elements"><a href="#Adding-and-removing-schema-elements" class="headerlink" title="Adding and removing schema elements"></a>Adding and removing schema elements</h2><p>我们将 table、column和 index 称为 structural elements。它们可以被理解为决定了 Spanner 上能存储哪些 KV 数据的元素。注意 optimistic lock 因为在处理上和 column 是一致的，所以我们将它包含在 column 中讨论。</p><p>【Claim2】所有从 S1 到 S2 的 schema change，如果涉及到增加或者删除 public 的 structual element E，那么它就不是 consistency preserving 的。在下面的例子中，假设 S2 包含了 E，但 S1 没有。即从 S1 到 S2 的变换是新增。</p><ol><li>E 是 table<br> 如果对 S2 上的 E 做 insert，那么得到的 representation d2 和 S1 是不一致的。因为其中包含的新增的数据 S1 不能解析。违反了 Database consistency 中的第一条。</li><li>E 是 table R 上的 column<br> 同上</li><li>E 是 table R 上的 index<br> 如果在 S2 上的 E 做 insert，那么会同时违反3和4。对于 S1，违反了3，因为我们写入的索引在 schema 里面没找到定义。</li></ol><p>【Claim3】从 S1 到 S2 的 schema change 是 consistency preserving 的，当且仅当它在 S1 和 S2 上都能避免 orphan data 和 integrity anomaly 两种数据不一致的情况。</p><h2 id="Optional-structural-elements"><a href="#Optional-structural-elements" class="headerlink" title="Optional structural elements"></a>Optional structural elements</h2><p>这里的 Optional 指的是 element 是可选的，例如定义了 default，或者是 nullable 的。</p><p>【Claim4】【absent-&gt;delete only】考虑从 schema S1 到 schema S2 的 schema change，它添加了一个 delete only 的 structural element E。对于任意的 representation d，且 d |= S1, d |= S2。那么所有基于 S1 和 S2 在 E 上的操作都不会产生两种异常。</p><p>【Claim5】【delete only-&gt;public】类似 Claim4</p><h2 id="Required-structural-elements"><a href="#Required-structural-elements" class="headerlink" title="Required structural elements"></a>Required structural elements</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://zimulala.github.io/2016/02/02/schema-change-implement/" target="_blank" rel="noopener">http://zimulala.github.io/2016/02/02/schema-change-implement/</a></li><li><a href="https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md" target="_blank" rel="noopener">https://github.com/zimulala/builddatabase/blob/master/f1/schema-change.md</a></li><li><a href="https://disksing.com/understanding-f1-schema-change/" target="_blank" rel="noopener">https://disksing.com/understanding-f1-schema-change/</a></li><li><a href="https://tongtianta.site/paper/57876" target="_blank" rel="noopener">https://tongtianta.site/paper/57876</a><br> Online, Asynchronous Schema Change in F1</li><li><a href="https://www.zenlife.tk/schema-lease.md" target="_blank" rel="noopener">https://www.zenlife.tk/schema-lease.md</a></li><li><a href="https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/" target="_blank" rel="noopener">https://hhwyt.xyz/2021-03-27-online-async-schema-change-in-f1/</a></li><li><a href="https://zhuanlan.zhihu.com/p/309831009" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/309831009</a><br> 一个翻译</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍F1的在线异步DDL schema变更。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>DPDK-Writing Efficient Code</title>
    <link href="http://www.calvinneo.com/2021/12/13/dpdk-coding/"/>
    <id>http://www.calvinneo.com/2021/12/13/dpdk-coding/</id>
    <published>2021-12-13T15:33:22.000Z</published>
    <updated>2023-04-02T15:47:54.292Z</updated>
    
    <content type="html"><![CDATA[<p>DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。</p><a id="more"></a><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="Memory-Copy"><a href="#Memory-Copy" class="headerlink" title="Memory Copy"></a>Memory Copy</h2><p>不要在数据面上使用 libc 函数，例如 memcpy 和 strcpy 等，推荐用 <a href="https://git.dpdk.org/dpdk/tree/lib/eal/x86/include/rte_memcpy.h" target="_blank" rel="noopener"><code>rte_memcpy</code></a> 这样的优化实现，实际上就是SIMD的版本。<br>为了使用 SIMD，需要保证地址不是虚拟地址，例如 malloc 等产生的是虚拟地址，那么在物理地址上可能是分散的，就做不了 SIMD 优化。</p><p>下面介绍 <code>rte_memcpy</code>，它要求地址不连续。</p><h3 id="rte-mov15-or-less-处理小内存"><a href="#rte-mov15-or-less-处理小内存" class="headerlink" title="rte_mov15_or_less 处理小内存"></a>rte_mov15_or_less 处理小内存</h3><p>下面这段代码处理小内存的复制。这里压根不考虑内存对齐了，直接复制。</p><ol><li>如果 <code>n &amp; 8</code>，就一次性复制头 64 bit。</li><li>如果剩下来的还满足 <code>n &amp; 4</code>，就一次性复制下面 32 bit。</li><li>由此类推。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span> *</span><br><span class="line">rte_mov15_or_less(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Use the following structs to avoid violating C standard</span></span><br><span class="line"><span class="comment">     * alignment requirements and to avoid strict aliasing bugs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_uint64_alias</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> val;</span><br><span class="line">    &#125; __rte_packed __rte_may_alias;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_uint32_alias</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> val;</span><br><span class="line">    &#125; __rte_packed __rte_may_alias;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rte_uint16_alias</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint16_t</span> val;</span><br><span class="line">    &#125; __rte_packed __rte_may_alias;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *ret = dst;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">8</span>) &#123; <span class="comment">// 1000b</span></span><br><span class="line">        ((struct rte_uint64_alias *)dst)-&gt;val =</span><br><span class="line">            ((<span class="keyword">const</span> struct rte_uint64_alias *)src)-&gt;val;</span><br><span class="line">        src = (<span class="keyword">const</span> <span class="keyword">uint64_t</span> *)src + <span class="number">1</span>;</span><br><span class="line">        dst = (<span class="keyword">uint64_t</span> *)dst + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">4</span>) &#123; <span class="comment">// 0100b</span></span><br><span class="line">        ((struct rte_uint32_alias *)dst)-&gt;val =</span><br><span class="line">            ((<span class="keyword">const</span> struct rte_uint32_alias *)src)-&gt;val;</span><br><span class="line">        src = (<span class="keyword">const</span> <span class="keyword">uint32_t</span> *)src + <span class="number">1</span>;</span><br><span class="line">        dst = (<span class="keyword">uint32_t</span> *)dst + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">2</span>) &#123; <span class="comment">// 0010b</span></span><br><span class="line">        ((struct rte_uint16_alias *)dst)-&gt;val =</span><br><span class="line">            ((<span class="keyword">const</span> struct rte_uint16_alias *)src)-&gt;val;</span><br><span class="line">        src = (<span class="keyword">const</span> <span class="keyword">uint16_t</span> *)src + <span class="number">1</span>;</span><br><span class="line">        dst = (<span class="keyword">uint16_t</span> *)dst + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) <span class="comment">// 0001b</span></span><br><span class="line">        *(<span class="keyword">uint8_t</span> *)dst = *(<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AVX512-实现"><a href="#AVX512-实现" class="headerlink" title="AVX512 实现"></a>AVX512 实现</h3><p>首先这里使用的都是带 u，也就是非对齐的版本。其中：</p><ol><li>16 byte 数据对应 128 bit，对应一个 xmm 寄存器。</li><li>32 byte 数据对应 256 bit，对应一个 ymm 寄存器。</li><li>64 byte 数据对应 512 bit，对应一个 zmm 寄存器。<br> 注意，这里是 64 byte 而不是 64 bit，64 bit 等于普通寄存器了。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AVX512 implementation below</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 16 bytes from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov16(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    __m128i xmm0;</span><br><span class="line"></span><br><span class="line">    xmm0 = _mm_loadu_si128((<span class="keyword">const</span> __m128i *)src);</span><br><span class="line">    _mm_storeu_si128((__m128i *)dst, xmm0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 32 bytes from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov32(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    __m256i ymm0;</span><br><span class="line"></span><br><span class="line">    ymm0 = _mm256_loadu_si256((<span class="keyword">const</span> __m256i *)src);</span><br><span class="line">    _mm256_storeu_si256((__m256i *)dst, ymm0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 64 bytes from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov64(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    __m512i zmm0;</span><br><span class="line"></span><br><span class="line">    zmm0 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)src);</span><br><span class="line">    _mm512_storeu_si512((<span class="keyword">void</span> *)dst, zmm0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 128 bytes from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov128(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    rte_mov64(dst + <span class="number">0</span> * <span class="number">64</span>, src + <span class="number">0</span> * <span class="number">64</span>);</span><br><span class="line">    rte_mov64(dst + <span class="number">1</span> * <span class="number">64</span>, src + <span class="number">1</span> * <span class="number">64</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 256 bytes from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov256(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src)</span><br><span class="line">&#123;</span><br><span class="line">    rte_mov64(dst + <span class="number">0</span> * <span class="number">64</span>, src + <span class="number">0</span> * <span class="number">64</span>);</span><br><span class="line">    rte_mov64(dst + <span class="number">1</span> * <span class="number">64</span>, src + <span class="number">1</span> * <span class="number">64</span>);</span><br><span class="line">    rte_mov64(dst + <span class="number">2</span> * <span class="number">64</span>, src + <span class="number">2</span> * <span class="number">64</span>);</span><br><span class="line">    rte_mov64(dst + <span class="number">3</span> * <span class="number">64</span>, src + <span class="number">3</span> * <span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是逐 128 byte 搬数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 128-byte blocks from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span></span><br><span class="line">rte_mov128blocks(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    __m512i zmm0, zmm1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">        zmm0 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">0</span> * <span class="number">64</span>));</span><br><span class="line">        n -= <span class="number">128</span>;</span><br><span class="line">        zmm1 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">1</span> * <span class="number">64</span>));</span><br><span class="line">        src = src + <span class="number">128</span>;</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">0</span> * <span class="number">64</span>), zmm0);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">1</span> * <span class="number">64</span>), zmm1);</span><br><span class="line">        dst = dst + <span class="number">128</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是逐 512 byte 搬数据。这个是用在对齐逻辑上的，不知道为什么还带 u。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Copy 512-byte blocks from one location to another,</span></span><br><span class="line"><span class="comment"> * locations should not overlap.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rte_mov512blocks(<span class="keyword">uint8_t</span> *dst, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *src, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    __m512i zmm0, zmm1, zmm2, zmm3, zmm4, zmm5, zmm6, zmm7;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n &gt;= <span class="number">512</span>) &#123;</span><br><span class="line">        zmm0 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">0</span> * <span class="number">64</span>));</span><br><span class="line">        n -= <span class="number">512</span>;</span><br><span class="line">        zmm1 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">1</span> * <span class="number">64</span>));</span><br><span class="line">        zmm2 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">2</span> * <span class="number">64</span>));</span><br><span class="line">        zmm3 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">3</span> * <span class="number">64</span>));</span><br><span class="line">        zmm4 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">4</span> * <span class="number">64</span>));</span><br><span class="line">        zmm5 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">5</span> * <span class="number">64</span>));</span><br><span class="line">        zmm6 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">6</span> * <span class="number">64</span>));</span><br><span class="line">        zmm7 = _mm512_loadu_si512((<span class="keyword">const</span> <span class="keyword">void</span> *)(src + <span class="number">7</span> * <span class="number">64</span>));</span><br><span class="line">        src = src + <span class="number">512</span>;</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">0</span> * <span class="number">64</span>), zmm0);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">1</span> * <span class="number">64</span>), zmm1);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">2</span> * <span class="number">64</span>), zmm2);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">3</span> * <span class="number">64</span>), zmm3);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">4</span> * <span class="number">64</span>), zmm4);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">5</span> * <span class="number">64</span>), zmm5);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">6</span> * <span class="number">64</span>), zmm6);</span><br><span class="line">        _mm512_storeu_si512((<span class="keyword">void</span> *)(dst + <span class="number">7</span> * <span class="number">64</span>), zmm7);</span><br><span class="line">        dst = dst + <span class="number">512</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来看 <code>rte_memcpy_generic</code>。<br>首先是处理非对齐的部分：</p><ol><li>如果长度小于 16 bytes，走 rte_mov15_or_less</li><li>如果长度小于等于 32 bytes，走两次 rte_mov16<br> 令 n=17，则<br> 第一次从 src[0..16] 复制到 dst[0..16]。<br> 第二次从 src[1..17] 复制到 dst[1..17]。</li><li>如果长度小于等于 64 bytes，类似上面。</li><li>如果长度小于等于 512 bytes，则是一个类似于 rte_mov15_or_less 的实现<br> 但是在剩余长度小于 128 bytes 后，如果大于 64 bytes，就走两次 rte_mov64 解决战斗。<br> 如果小于 64 bytes，就走一次 rte_mov64 解决战斗。</li></ol><p>如果需要复制的长度大于 512 bytes，就需要处理对齐的部分。这里检查 dst 是否按照 64 bytes 对齐，即 <code>0x3F</code> 对齐。如果不对齐，则先把前面的部分给复制完毕。</p><p>【Q】为什么是考虑 dst 对齐还是 src 对齐？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> __rte_always_inline <span class="keyword">void</span> *</span><br><span class="line">rte_memcpy_generic(<span class="keyword">void</span> *dst, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> *ret = dst;</span><br><span class="line">    <span class="keyword">size_t</span> dstofss;</span><br><span class="line">    <span class="keyword">size_t</span> bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy less than 16 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">16</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> rte_mov15_or_less(dst, src, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Fast way when copy size doesn't exceed 512 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">32</span>) &#123;</span><br><span class="line">        rte_mov16((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">        rte_mov16((<span class="keyword">uint8_t</span> *)dst - <span class="number">16</span> + n,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src - <span class="number">16</span> + n);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">64</span>) &#123;</span><br><span class="line">        rte_mov32((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">        rte_mov32((<span class="keyword">uint8_t</span> *)dst - <span class="number">32</span> + n,</span><br><span class="line">                  (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src - <span class="number">32</span> + n);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">256</span>) &#123;</span><br><span class="line">            n -= <span class="number">256</span>;</span><br><span class="line">            rte_mov256((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">            src = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src + <span class="number">256</span>;</span><br><span class="line">            dst = (<span class="keyword">uint8_t</span> *)dst + <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">            n -= <span class="number">128</span>;</span><br><span class="line">            rte_mov128((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">            src = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src + <span class="number">128</span>;</span><br><span class="line">            dst = (<span class="keyword">uint8_t</span> *)dst + <span class="number">128</span>;</span><br><span class="line">        &#125;</span><br><span class="line">COPY_BLOCK_128_BACK63:</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">64</span>) &#123;</span><br><span class="line">            rte_mov64((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">            rte_mov64((<span class="keyword">uint8_t</span> *)dst - <span class="number">64</span> + n,</span><br><span class="line">                      (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src - <span class="number">64</span> + n);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            rte_mov64((<span class="keyword">uint8_t</span> *)dst - <span class="number">64</span> + n,</span><br><span class="line">                      (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src - <span class="number">64</span> + n);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Make store aligned when copy size exceeds 512 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    dstofss = ((<span class="keyword">uintptr_t</span>)dst &amp; <span class="number">0x3F</span>); <span class="comment">// 111111b = 64</span></span><br><span class="line">    <span class="keyword">if</span> (dstofss &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dstofss = <span class="number">64</span> - dstofss;</span><br><span class="line">        n -= dstofss;</span><br><span class="line">        rte_mov64((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src);</span><br><span class="line">        src = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src + dstofss;</span><br><span class="line">        dst = (<span class="keyword">uint8_t</span> *)dst + dstofss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy 512-byte blocks.</span></span><br><span class="line"><span class="comment">     * Use copy block function for better instruction order control,</span></span><br><span class="line"><span class="comment">     * which is important when load is unaligned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    rte_mov512blocks((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src, n);</span><br><span class="line">    bits = n;</span><br><span class="line">    n = n &amp; <span class="number">511</span>;</span><br><span class="line">    bits -= n;</span><br><span class="line">    src = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src + bits;</span><br><span class="line">    dst = (<span class="keyword">uint8_t</span> *)dst + bits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy 128-byte blocks.</span></span><br><span class="line"><span class="comment">     * Use copy block function for better instruction order control,</span></span><br><span class="line"><span class="comment">     * which is important when load is unaligned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">        rte_mov128blocks((<span class="keyword">uint8_t</span> *)dst, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src, n);</span><br><span class="line">        bits = n;</span><br><span class="line">        n = n &amp; <span class="number">127</span>;</span><br><span class="line">        bits -= n;</span><br><span class="line">        src = (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)src + bits;</span><br><span class="line">        dst = (<span class="keyword">uint8_t</span> *)dst + bits;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy whatever left</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">goto</span> COPY_BLOCK_128_BACK63;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Memory-Allocation"><a href="#Memory-Allocation" class="headerlink" title="Memory Allocation"></a>Memory Allocation</h2><p>避免使用 malloc 等在堆上分配内存，毕竟维护堆还是比较麻烦的，CSAPP 的 Data Lab 令我记忆犹新，并且也不容易做 parallel allocation。【Q】这是啥？<br>更为推荐的做法是对固定大小的对象构建内存池，例如<code>librte_mempool</code>/<code>rte_malloc</code>的实现。在这样的实现中需要考虑内存对齐，无锁访问，NUMA感知，批量读写，每个核心的Cache。</p><h2 id="对同一内存的并发访问"><a href="#对同一内存的并发访问" class="headerlink" title="对同一内存的并发访问"></a>对同一内存的并发访问</h2><h2 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h2><h2 id="Distribution-Across-Memory-Channels"><a href="#Distribution-Across-Memory-Channels" class="headerlink" title="Distribution Across Memory Channels"></a>Distribution Across Memory Channels</h2><h1 id="各个核心之间的通信"><a href="#各个核心之间的通信" class="headerlink" title="各个核心之间的通信"></a>各个核心之间的通信</h1><h1 id="PMD"><a href="#PMD" class="headerlink" title="PMD"></a>PMD</h1><h1 id="锁和原子操作"><a href="#锁和原子操作" class="headerlink" title="锁和原子操作"></a>锁和原子操作</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html" target="_blank" rel="noopener">https://doc.dpdk.org/guides/prog_guide/env_abstraction_layer.html</a></li><li><a href="https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h" target="_blank" rel="noopener">https://github.com/DPDK/dpdk/blob/main/lib/eal/x86/include/rte_memcpy.h</a><br> rte_memcpy 的源码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;DPDK的编程规范，用来指导如何写高性能程序，觉得挺有意思的，所以翻译过来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="并行计算" scheme="http://www.calvinneo.com/tags/并行计算/"/>
    
    <category term="多线程" scheme="http://www.calvinneo.com/tags/多线程/"/>
    
    <category term="CPU" scheme="http://www.calvinneo.com/tags/CPU/"/>
    
  </entry>
  
  <entry>
    <title>EPaxos介绍</title>
    <link href="http://www.calvinneo.com/2021/12/04/epaxos/"/>
    <id>http://www.calvinneo.com/2021/12/04/epaxos/</id>
    <published>2021-12-04T11:20:33.000Z</published>
    <updated>2023-01-12T16:22:51.403Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍EPaxos算法。</p><a id="more"></a><h1 id="Epaxos的简介"><a href="#Epaxos的简介" class="headerlink" title="Epaxos的简介"></a>Epaxos的简介</h1><p>EPaxos是一个Leaderless的算法，具有以下的优点：</p><ol><li>Client可以任意选择一个节点发送Command，这个Command的Commit的路径大部分都不会干扰到其他的Command。而在诸如Raft的算法中，必须有一个Master显式向其他节点复制日志。并且也避免了Client可能和一个跨地区的Master交互的情况。</li><li>因为没有Leader选举的过程，所以整个集群的可用性变高了。</li></ol><p>讨论Basic Paxos算法，当收到来自Client的Command后，某个replica会尝试成为一个尚未被使用过的instance的Leader，方式是发送Prepare消息。其他replica对Prepare的返回值，首先包含了它们认为的已经被chosen的Command(如果出现这种情况，Leader后面也需要使用这个Command)。在返回值中还会包含不会再ack早前的Leader发送的更旧的消息的承诺。在收到majority的对Prepare的ack之后，这个Leader会发送Accept消息。当Accept消息再被majority确认后，Leader会在本地记录Command已被Commit，并且异步通知Peer和Client。</p><p>容易发现，Paxos算法需要Prepare和Accept两个阶段，才能完成一个Command的提交。这是不经济的，因为即使从Raft的经验来看，只要Leader一直存在，那么一轮就可以决定一个instance，也就是Log Entry的值了。此外Basic Paxos中如果多个Leader打架，那2轮都不够。因此MultiPaxos中引入了stable leader(又称为distinguished proposer)的机制来处理。</p><p>EPaxos的设计目标是：</p><ol><li>减少Commit时延</li><li>优化Load Balance</li><li>对于较慢甚至故障的节点，提供一个优雅的降级方案</li></ol><p>为此，EPaxos需要做到：</p><ol><li>每个节点都可以同时作为Proposer(Command Leader)</li><li>每个Proposer在和最小数量的节点交流后就可以Commit，并且交流的次数也要最小化<br> 类似generic broadcast算法，以及Generalized Paxos算法，会广播消息。但如果两个Command不互相影响，实际上并没有必要强制他们有一个consistent的顺序。<br> 而在实际workload上，可以认为大部分的Command是这样的，也就是说它们修改的是不同的对象。</li><li>Quorum的组成应当是可变的</li></ol><p>EPaxos做到这些，得益于它给Command定序的方案。在这之前，诸如MultiPaxos和GenerizedPaxos选择通过一个Leader来选择顺序；而在 canonical Paxos和Mencius中选择将这些Command放入已经预先分配好的instance空间中。</p><p>EPaxos的方案是当对一个Command投票时，每个参与者需要附带上对这个Command的Order Constraints。EPaxos能够保证所有正常的节点能够以提交同样的Command和Order Constraints。</p><p>简介一下EPaxos的方案。当一个Command被发送给某个replica时，该replica就被称为Command Leader。这个称呼特意区别于MultiPaxos中的Leader，因为显而易见，同时可能存在多个Command Leader。</p><p>如果Command之间不冲突，如下图的左边所示，两个Command分别更新<code>obj_A</code>和<code>obj_B</code>。为了Commit这个Command，可以走论文中说的Fast Path。Command Leader需要和<code>F + floor((F + 1) / 2)</code>(称为fast-path quorum)个Peer交互。其中F是允许失败的节点的个数，对应到下图，F为2。特别地，对于常见的3节点集群，Fast-path Quorum为2；对于5节点集群，Fast-path Quorum为3，都等于传统的简单多数。</p><p>【Q】这里有个疑问，不同对象的先后顺序，有影响么？比如实际上一个Client先于<code>obj_B</code>写<code>obj_A</code>，但<code>obj_B</code>先于<code>obj_A</code>被Commit，当Client收到<code>obj_B</code>的时候读取<code>obj_A</code>，那么可能读到<code>obj_A</code>的stale的数据呢？可以看下面的Execution linearizability说明。</p><p>如果两个Command互相冲突，如下图的右边所示，C3和C4同时更新<code>obj_A</code>，就不能走Fast Path了。在提交的时候需要附带上Order Constraint。为了保证所有的Replica在存在部分节点故障的情况下，都能提交相同的Order Constraint，需要另一轮的通信。这一轮通信中，Command Leader需要和<code>F + 1</code>个Peer交互。这就是Slow Path，<code>F + 1</code>也就是传统意义上的简单多数Quorum。</p><p><img src="/img/epaxos/f1.png"></p><h2 id="EPaxos和其他算法的比较"><a href="#EPaxos和其他算法的比较" class="headerlink" title="EPaxos和其他算法的比较"></a>EPaxos和其他算法的比较</h2><p>在MultiPaxos中，Leader会负责Propose所有的Command。这样会导致Leader处理O(n)个请求，同时非Leader节点只会处理O(1)个请求，负载十分不均衡。</p><p>为了解决MultiPaxos的问题，Mencius选择逐Command将Paxos Leader在多个节点之间轮换。也就是说节点<br><code>R_id</code>拥有instance i，当i满足<code>(i mod N) = R_id</code>。这里的坏处是，每一次Commit Command A之前都需要询问所有节点。否则按照这个轮换顺序，另一个依赖于A的Command B可能在Command A之前被提交。这个询问过程会产生两个后果，首先是整个Commit的速度由最慢的那个Replica决定；其次是当一个节点Fail后，整个过程将block住，直到其他节点发现这个节点Fail掉了，并替他返回一个NoOp。</p><p>FastPaxos为了解决从Propose到Commit的延迟，选择让Client同时向所有的Replica发送Propose。MultiPaxos一样使用了Stable Leader，不仅用来开启voting round，也用来仲裁各个Acceptor的顺序(考虑到每个Acceptor可能以不同顺序收到)。</p><p>Generalized Paxos的方案是当Command之间不互相影响时，对它们乱序提交。Replicas learn commands after just two message<br>delays—which is optimal—as long as they do not interfere。TODO 后面看不懂了。</p><p>EPaxos相对于Generalized Paxos有三点优势：</p><ol><li>EPaxos的Fast Path Quorum Size比Generalized Paxos的正好小一个，能够减小延迟(应该是木桶效应吧)，以及总的消息量</li><li>EPaxos解决冲突，也就是Slow Path只需要额外一轮，但Generalized Paxos需要两轮</li><li>对于three-site replication而言，EPaxos即使在所有Command都冲突的情况下，只需要和距离Proposer最近的Replica通信一轮，即可Commit</li></ol><p>EPaxos和Fast/Generalized Paxos的<strong>Fast Path</strong>的一个重要区别是，EPaxos需3 message delays来Commit，但Fast等只需要2个。但一般EPaxos的第一个Delay可以忽略掉，因为Client和最接近的Replica通常都在一个数据中心中。</p><p>S-Paxos TODO</p><h1 id="EPaxos的实现"><a href="#EPaxos的实现" class="headerlink" title="EPaxos的实现"></a>EPaxos的实现</h1><p>结合了两篇论文的内容</p><h2 id="预备内容"><a href="#预备内容" class="headerlink" title="预备内容"></a>预备内容</h2><p>在允许F个失效节点的分布式系统中，至少存在N=2F+1个节点。对于每一个节点R，它拥有的instance写为序列R1, R2, …。在每个instance中，只有一个Command能被选出。需要注意的是，R1、R2等instance的order，并不是已经确定的，而是由协议来动态确定。</p><p>Commands γ和δ是interfere的，当存在一系列指令Σ使得顺序执行Σ,γ,δ不等价于顺序执行Σ,δ,γ。这里不等价包含它们会导致不同的状态机状态，或者导致在这些序列中读取到的值是不同的。</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ol><li>Nontriviality<br> 所有被Commit的Command都由Client发出。</li><li>Stability<br> 对于任意Replica，不会丢失已经Commit的数据。<br> 进一步地，如果在t1时刻，Replica R在Q.i这个instance上提交了Command Y，那么在t1之后的任意时刻t2，R上的instanceQ.i的值也是Command Y。<br> 【Q】这里有个疑问，Q是哪里来的？不应该是R么？应该不矛盾，作为Acceptor，R也会有Q拥有的instance的信息的，不然怎么投票？</li><li>Consistency<br> 同一个instance在Commit之后，就在各个Replica上的值都是一样的。</li><li>Execution consistency<br> 如果两个interfere的Command Y和Z在任意Replica上被成功Commit了，那么所有Replica上的执行顺序是一样的。</li><li>Execution linearizability<br> 如果Client对Command Y和Command Z是serialized的，比如说在Command Y被Commit之后，才会Propose Command Z，那么所有的Replica都会先执行Y再执行Z。</li><li>Liveness<br> 活性</li></ol><h2 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h2><p>基础版本的fast-path quorum是<code>2F</code>，后面优化版本的才是<code>F + floor((F + 1) / 2)</code></p><h3 id="Commit-Protocol"><a href="#Commit-Protocol" class="headerlink" title="Commit Protocol"></a>Commit Protocol</h3><p>Commit Protocol解决两个问题：</p><ol><li>Commit Command</li><li>Determine Order Between Commands</li></ol><p>在论文的Figure2中描述了Commit Protocol的整个过程，在Commit过程中，并不是每个过程都会走到。如果一个Command没有冲突，就可以走Fast Path，这也意味着走完Phase 1就能够直接提交了。Slow Path还需要额外的Phase 2(Paxos-Accept phase)。如果我们进行failure recovery，则需要运行Figure3描述的Explicit Prepare过程。</p><p>当一个Replica收到来自Client的Command γ后，会给这个Command γ分配一个全局唯一的instance number，例如R1、Q2等。全局唯一是通过组合Replica的名字，以及在Replica中递增的序列号保证的。这里Replica是可以将多个操作组合到一个instance中的。除了分配instance number之外，Replica还会给Command分配一个dependency set(deps)和一个sequence number(seq)，<strong>称为attribute</strong>。Dependency set包含了每个Replica中<strong>最高的</strong>和自己冲突的instance编号。Sequence number会选取一个大于dependency set中所有值的值作为<strong>初始值</strong>。The originating replica derives the dependency set and sequence number for a new instance from all other instances it has knowledge of。对于每个修改了新Command操作对象的Replica，需要持久化它们的最高的instance number和sequence number。</p><p>Command Leader通过<strong>PreAccept消息</strong>，即<code>(γ,seqγ,depsγ,pre-accepted)</code>，将Command以及deps和seq发送给至少fast-path quorum(在这里是2F)个Replica。每个Replica在收到后，会<strong>根据自己的cmds log</strong>来更新Command γ的deps和seq，并将γ和新的attribute记录在自己的log中，然后回复给Command Leader。</p><p>如果Command Leader满足了fast-path quorum，并且所有更新了的attribute(seq和deps)是一样的(根据Figure2的第10行代码，不包括Command Leader)，那么可以直接Commit。否则就需要走Slow Path。</p><p>在运行Slow Path前，我们得更新seq和deps。其中deps是从每个Replica之间的union，seq取每个Replica过来的最大的seq。然后在Slow Path中，Command Leader会给另外F个Replica发送Accept请求，让它们Accept三元组<code>(γ,seq,deps)</code>。其实这个过程类似于Basic Paxos的Accept阶段。</p><p>在Slow Path完成了取得了F + 1票后，就可以和Fast Path会师了。此时Command Leader会发送Commit消息给所有的Replica，并且返回给Client。</p><p>类似于经典的Paxos，EPaxos也会给每个消息(message)分配一个ballot number。每个Replica会忽略小于它们已经见过的最大的ballot number。这个ballot number格式为<code>epoch.b.R</code>，其中：</p><ol><li>epoch<br> 如果集群的配置有变动，那么epoch会变化</li><li>b<br> 如果某个replica R，在做Explicit Prepare时，需要创建一个新的ballot时，会自增b</li><li>R<br> 表示这个Replica</li></ol><p>每个Replica是自己拥有的instance的<strong>初始</strong>Leader，换言之，对于每个instance <code>R.i</code>，隐式存在一个<code>epoch.0.R</code>。</p><p><img src="/img/epaxos/f2.png"></p><h3 id="Explicit-Prepare过程"><a href="#Explicit-Prepare过程" class="headerlink" title="Explicit Prepare过程"></a>Explicit Prepare过程</h3><p>【这一块还包含了优化部分，比较难懂】<br>假如说Replica L可能宕机了，那么Replica Q会尝试接管它的instance L.i。</p><p>首先，将ballot number设置为epoch.(b + 1).Q，其中epoch.b.R是Q知道的L.i中最大的ballot number。然后，发送<code>Prepare(epoch.(b + 1).Q,L.i)</code>给包括自己在内的所有Replica，并且等待至少<code>floor(N/2) + 1</code>个回复。令R等于the set of replies w/ the highest ballot number：</p><ol><li>如果R中包含了<code>(γ,seqγ,depsγ,committed)</code>，则在L.i对(γ,seqγ,depsγ)运行Commit Phase。</li><li>再如果R中包含了<code>(γ,seqγ,depsγ,accepted)</code>，运行Paxos-Accept phase。</li><li>再如果R包含了至少<code>floor(N / 2)</code>个不同的对<code>L.i</code>上默认的ballot即<code>epoch.0.L</code>的回复<code>(γ,seqγ,depsγ,pre-accepted)</code>，并且没有一个回复是来自于L的，则运行Paxos-Accept phase。<br> 【优化算法】此时，只需要包含<code>floor((F + 1) / 2)</code>个PreAccept了<code>(γ,seqγ,depsγ)</code>这个三元组的Replica即可。在发现他们后，新的Command Leader Q会尝试向其他Replica发送TryPreAccept消息。在某个Replica收到TryPreAccept消息后，会判断这个三元组是否和自己已有的log冲突：一个Command的deps中不包括γ，并且depsγ中也不包括这个Command(简单来说两个Command的deps互相不包含)，那么这个Command就和γ冲突；或者这个Command虽然在depsγ中，但是它的seq大于等于seqγ，那么也是和γ冲突的。只有当自己的log中没有这些冲突Command时，这个Replica才会回复TryPreAccept。<br> 如果真的存在某个Command和三元组冲突，并且这个Command被Commit了，那么Q就知道γ不能再fast path中被提交。但如果这个Command没有被Commit，那么新的Comamnd Leader Q就会defer，知道这个Command被Commit。最后，如果Q能够得到F + 1个Replica(在计算F时，老Command Leader也被计算在内)的PreAccept票后，就可以运行Paxos-Accept phase了。<br> 这里有一个Corner case，也即是当deps中的某个Command修改它的seq，然后比需要Recover的Command γ的seq还要大了。为了阻止这个情况，对于depsγ中的所有Command，至少需要有一个Acceptor记录为Commit状态后，才允许Command Leader走Fast Path提交。对于N小于7的情况，更有效的方案是将更新后的deps放到Accept和AcceptReply消息中，并且保证这些消息的接收方都去缓存了它们。这些信息只会被用来辅助Recovery。<br> 【Q】为啥优化算法只改这一个分支？</li><li>再如果R包含了至少一个<code>(γ,seqγ,depsγ,pre-accepted)</code>，则在L.i上执行Phase1，Command为γ，并且避免fast path。</li><li>最终，则在L.i上执行Phase1，Command为noop，并且避免fast path。</li></ol><p>Replica R, 在收到来自Q的Prepare(epoch.b.Q,L.i)后：</p><ol><li>如果epoch.b.Q比最近接受到来自L.i的请求epoch.x.Y大，则返回PrepareOK(cmdsR[L][i], epoch.x.Y,L.i)</li><li>否则返回NAC</li></ol><p><img src="/img/epaxos/f3.png"></p><h3 id="Execution-Protocol"><a href="#Execution-Protocol" class="headerlink" title="Execution Protocol"></a>Execution Protocol</h3><p>为了执行在R.i这个instance上提交的Command γ，需要执行下面的步骤：</p><ol><li>等待R.i被提交，或者运行Explicit Prepare过程强制这个过程</li><li>构造γ的依赖图，其中需要加入γ的dependency set中的所有Command<br> 注意，这个过程是递归的，也就是我们需要考虑依赖的依赖</li><li>找到所有的SCC，并对这些SCC进行拓扑排序</li><li>根据逆拓扑序，执行：<ol><li>对于SCC中的所有命令，按照sequence number(seq)从低到高排序</li><li>按照这个顺序执行所有尚未被执行的Command，并标记他们为已被执行</li></ol></li></ol><h2 id="关于性质的-Informal-证明"><a href="#关于性质的-Informal-证明" class="headerlink" title="关于性质的(Informal)证明"></a>关于性质的(Informal)证明</h2><h3 id="Nontriviality"><a href="#Nontriviality" class="headerlink" title="Nontriviality"></a>Nontriviality</h3><h3 id="Stability和Consistency"><a href="#Stability和Consistency" class="headerlink" title="Stability和Consistency"></a>Stability和Consistency</h3><p>先证明命题1：如果Replica R通过instance Q.i提交了Commit γ(这里R和Q可能是同一个Replica)，那么对于任意的提交Q.i的Replica R’，它提交的Command γ’一定等于γ。</p><p>证明简要：如果说Command γ能被在Q.i这个instance中提交，一定是因为γ的Phase 1是在instance Q.i中被启动的。这是因为：</p><ol><li>对于每个新Command，Q会自增instance number，也就是这里的i</li><li>如果Q宕机并重启了，那么根据”4.7 Reconfiguring the Replica Set”，它会被分配得到一个新的identifier<br> 【TODO】这里需要详细解释下。</li></ol><p>可以看到，命题1实际上暗示了consistency。进一步地，在Replica崩溃时，Command可能被丢失，所以当Command Log被保存在持久化存储上时，也暗示了stability。</p><p>首先引入一个定义。如果Command γ具有seqγ和depsγ，如果元组(γ,seqγ,depsγ)是Q.i这个instance上唯一被或者可能被commit的元组，那么我们称元组(γ,seqγ,depsγ)在Q.i这个instance上是safe的。</p><p>下面证明命题2：Replica只会提交safe的tuple。首先知道(γ,seqγ,depsγ)如果在Q.i被提交，那么它要么在Paxos Accept phase提交，或者在Phase 1之后提交。</p><ol><li>对于第一种情况，即Slow Path。此时有多于半数的Replica写入了值(Figure2的L20)，这对应了经典Paxos的要求。</li><li>对于第二种情况，即Fast Path。此时Coomand Leader收到了不含自己的N-2个相同的回复(Figure2的L11)。如果此时另外的Replica需要接管这个instance，通常这是因为初始的Leader宕机了，那么新Leader必须执行Prepare过程，并且会发现至少<code>floor(N/2)</code>个Replica都返回(γ,seqγ,depsγ)这个元组。因此新的Leader会认为这个元组可能提交了，并在Paxos-Accept过程中使用这个元组。</li></ol><p>至此我们可以发现，元组们，包括他们的attributes，都会在各个Replica之间被consistently和stable地提交。</p><p>下面我们证明这些consistent和stable的attributes能够保证所有互相interfere的Command，在每个Replica上都按照同样的顺序被提交。</p><h3 id="Execution-consistency和Execution-linearizability"><a href="#Execution-consistency和Execution-linearizability" class="headerlink" title="Execution consistency和Execution linearizability"></a>Execution consistency和Execution linearizability</h3><p>引理1 (Execution consistency)：<br><strong>如果互相interfere的两个Command γ和δ都被成功Commit了(并不一定通过同一个Replica提交)，那么他们在任意Replica上都会以相同的顺序被执行</strong>。</p><p>如果两个Command互相interfere，至少有一个Command的deps中能找到另一个Command。Phase1在这个命令被至少简单多数(注意我们现在讲的还是基础版本的EPaxos，其中Phase1的Fast Path Quorum为2F)个Replica Pre-Accepted后结束，并且这个命令最终的deps集是由至少简单多数个Replica的deps的union。这也同样适用于recovery过程中使用的Explicit Prepare(L32)的情况，因为所有的依赖都是基于那些被可能宕机的Leader初始设置的集合计算得到。所以至少一个Replica同时PreAccept γ和δ，并且它的PreAcceptReplies被用来构造γ和δ的最终的deps集。</p><p>通过执行Execution Algorithm，一个命令只有在自己dependency graph中的所有命令都被Commit后才会执行。主要有三个场景：</p><ol><li>两个Command都在彼此的dependency graph中，这也意味着dependency graph是identical的，并且γ和δ在同一个SCC中。所以当执行一个Command时，另一个Command也会被执行，并且是根据sequence number来执行的。根据命题2，这些已Commit的Command的attribute在所有Replica上都是stable和consistent的。所以所有dependency graph相同的Replica都会在相同的顺序中执行γ和δ。</li><li>γ在δ的dependency graph中(δ依赖γ)，但δ不在γ的dependency graph中。也就是说dependency graph有一个从δ到γ的路径，反之不成立。因此γ和δ来自不同的SCC，在逆拓扑序即实际的执行顺序中，γ在δ前面。补充一点，在一些Replica中，γ在δ被Commit之前就被执行了，这样的场景是没毛病的，因为γ并不依赖于δ。</li><li>δ在γ前面，这个就是上面的对称形式。</li></ol><p>引理2 (Execution linearizability)：<br>如果两个Command γ和δ，被客户端指定了顺序，例如只有在γ被任意Replica Commit之后才会Propose δ，这样的话我们要求所有的Replica都要在δ之前执行γ。</p><p>证明。因为δ是在γ Commit之后被Propose的，所以在任何Replica收到Command δ的PreAccept时，γ的Sequence Number应该是Stable和Consist的。因为一个包含γ的元组，以及它最终的sequence number至少被majority个Replica记录，那么δ的sequence number会最终被更新到大于γ的值，并且delta的deps中会包含γ。所以在执行δ时，δ的dependency graph必须包含γ，并且：</p><ol><li>它们在同一个SCC中</li><li>按照逆拓扑序，γ在δ前面的一个SCC中。</li></ol><p>无论那种情况，γ都会在δ前面执行。</p><h3 id="Liveness"><a href="#Liveness" class="headerlink" title="Liveness"></a>Liveness</h3><p>只要不是大多数Replica有故障，那么Client会一直重试某个Command，直到被Accept。</p><h2 id="优化版本"><a href="#优化版本" class="headerlink" title="优化版本"></a>优化版本</h2><p>优化版本会修改Recovery过程，也就是Explicit Prepare Phase。我已经写到“Explicit Prepare过程”上面了。</p><p>当F个Replica宕机后，在Fast Quorum中就只有<code>floor((F + 1) / 2)</code>个存活的成员(可以翻翻前面Fast-Path Quorum的定义)，那么就不能在剩下的Replica中形成多数了。所以，当Command Leader向所有Replica(而不只是Fast Quorum中的Replica)发送PreAccept消息后，Recovery过程不一定能正确地发现，老的Command Leader，是通过哪些Replica的回复，从而Commit了这个instance的。 Still, such redundancy is sometimes desirable because the command leader may not know in advance which replicas are still live or which replicas will reply faster。<br>对于这种情况，需要修改Fast Path的条件：当Command Leader收到<code>F + floor((F + 1) / 2) - 1</code>个满足initial ordering attributes的PreAccept的回复，才会选择Fast Path。并且这些Replica需要被记录到Log中，以便在Recovery过程中只考虑这些Replica。<br>在不发送redundant PreAccept的时候(【Q】什么时候会发送？)，一个三副本的系统永远可以通过Fast Path提交，这是因为在做还有一个Acceptor的集合中肯定不存在disagreement。</p><h1 id="EPaxos的TLA-简介"><a href="#EPaxos的TLA-简介" class="headerlink" title="EPaxos的TLA+简介"></a>EPaxos的TLA+简介</h1><p>如果光读论文就能读懂，那我感觉你真的挺厉害的，反正我是半懂不懂的，特别是对Recovery部分。所以我转过来看TLA+了。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>下面是对SlowQuorum和FastQuorum的定义。对于某个Replica r，SlowQuorum(r)表示它作为Command Leader时，所有可能的Slow Path Quorum组成的集合，也就是类似于<code>{ {r,a}, {r,b} }</code>这样的东西。那么，<code>SlowQuorum(r)</code>必须是<code>SUBSET Replica</code>的子集，换句话说，就是不能出现Replica之外的元素。然后对于SlowQuorum中的任意的Quorum SQ，它必须包含r，并且大小为<code>N/2+1</code>，其中N为集群大小。<br>同理，FastQuorum中的大小为<code>N/2 + (N/2+1)/2</code>，这个其实就是把<code>F = N/2</code>带入进去就得到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS FastQuorums(_), SlowQuorums(_)</span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ SlowQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A SQ \in SlowQuorums(r): </span><br><span class="line">    /\ r \in SQ</span><br><span class="line">    /\ Cardinality(SQ) = (Cardinality(Replicas) \div 2) + 1</span><br><span class="line"></span><br><span class="line">ASSUME \A r \in Replicas:</span><br><span class="line">  /\ FastQuorums(r) \subseteq SUBSET Replicas</span><br><span class="line">  /\ \A FQ \in FastQuorums(r):</span><br><span class="line">    /\ r \in FQ</span><br><span class="line">    /\ Cardinality(FQ) = (Cardinality(Replicas) \div 2) + </span><br><span class="line">                         ((Cardinality(Replicas) \div 2) + 1) \div 2</span><br></pre></td></tr></table></figure><p>下面是对一些状态的定义。Commands是一个常量，表示所有可能的命令，在运行前由我们给出。none是一个none Command(也许是Noop？)，对它的定义还挺新颖的，如果是我，可能选择直接CONSTANT了一个Nil的值。<br>Instance是做了一个笛卡尔积，没啥讲的。<br>Status标记了Log中的某个Command可能处于的状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS Commands</span><br><span class="line">none == CHOOSE c : c \notin Commands</span><br><span class="line">Instances == Replicas \X (1..Cardinality(Commands))</span><br><span class="line">Status == &#123;&quot;not-seen&quot;, &quot;pre-accepted&quot;, &quot;accepted&quot;, &quot;committed&quot;&#125;</span><br></pre></td></tr></table></figure><p>下面是Replica之间可能发送的消息。这里的TLA+语法可以参考<a href="/2021/06/26/tla/">TwoPhase章节</a>。</p><ol><li>pre-accept、pre-accept-reply<br> Phase1由Command Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,pre-accepted)</code><br> 注意要区分这里的committed字段，和全局的committed变量</li><li>accept、accept-reply<br> Phase2由Commmand Leader发起的消息和回复，即<code>(γ,seqγ,depsγ,accepted)</code></li><li>commit<br>Commit阶段由Command Leader发起的消息，即<code>(γ,seqγ,depsγ,committed)</code></li><li>prepare、prepare-reply<br> Explicit Prepare阶段由新的Command Leader Q发起的消息。</li><li>try-pre-accept、try-pre-accept-reply<br> 优化算法</li></ol><p>一些常见字段的说明：</p><ol><li>src和dst都属于Replicas。</li><li>inst属于Instances表示当前操作的实例。</li><li>ballot应该是指的ballot number，不是<code>epoch.b.R</code>么？看起来是吧epoch和b合并了？</li><li>cmd应该是指instance中包含的command。</li><li>deps和seq就是所谓的attribute，没啥讲的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Message ==</span><br><span class="line">        [type: &#123;&quot;pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;commit&quot;&#125;,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        deps: SUBSET Instances, seq: Nat, committed: SUBSET Instances]</span><br><span class="line">  \cup  [type: &#123;&quot;accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas]</span><br><span class="line">  \cup  [type: &#123;&quot;prepare-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, prev_ballot: Nat \X Replicas,</span><br><span class="line">        status: Status,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas,</span><br><span class="line">        cmd: Commands \cup &#123;none&#125;, deps: SUBSET Instances, seq: Nat]</span><br><span class="line">  \cup  [type: &#123;&quot;try-pre-accept-reply&quot;&#125;, src: Replicas, dst: Replicas,</span><br><span class="line">        inst: Instances, ballot: Nat \X Replicas, status: Status \cup &#123;&quot;OK&quot;&#125;]</span><br></pre></td></tr></table></figure><p>下面是定义变量，可以结合TypeOK和Init条件看出类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">VARIABLES cmdLog, proposed, executed, sentMsg, crtInst, leaderOfInst,</span><br><span class="line">          committed, ballots, preparing</span><br><span class="line"></span><br><span class="line">TypeOK ==</span><br><span class="line">    /\ cmdLog \in [Replicas -&gt; SUBSET [inst: Instances, </span><br><span class="line">                                       status: Status,</span><br><span class="line">                                       ballot: Nat \X Replicas,</span><br><span class="line">                                       cmd: Commands \cup &#123;none&#125;,</span><br><span class="line">                                       deps: SUBSET Instances,</span><br><span class="line">                                       seq: Nat]]</span><br><span class="line">    /\ proposed \in SUBSET Commands</span><br><span class="line">    /\ executed \in [Replicas -&gt; SUBSET (Nat \X Commands)]</span><br><span class="line">    /\ sentMsg \in SUBSET Message</span><br><span class="line">    /\ crtInst \in [Replicas -&gt; Nat]</span><br><span class="line">    /\ leaderOfInst \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line">    /\ committed \in [Instances -&gt; SUBSET ((Commands \cup &#123;none&#125;) \X</span><br><span class="line">                                           (SUBSET Instances) \X </span><br><span class="line">                                           Nat)]</span><br><span class="line">    /\ ballots \in Nat</span><br><span class="line">    /\ preparing \in [Replicas -&gt; SUBSET Instances]</span><br><span class="line"></span><br><span class="line">Init ==</span><br><span class="line">  /\ sentMsg = &#123;&#125;</span><br><span class="line">  /\ cmdLog = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ proposed = &#123;&#125;</span><br><span class="line">  /\ executed = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ crtInst = [r \in Replicas |-&gt; 1]</span><br><span class="line">  /\ leaderOfInst = [r \in Replicas |-&gt; &#123;&#125;]</span><br><span class="line">  /\ committed = [i \in Instances |-&gt; &#123;&#125;]</span><br><span class="line">  /\ ballots = 1</span><br><span class="line">  /\ preparing = [r \in Replicas |-&gt; &#123;&#125;]</span><br></pre></td></tr></table></figure><ol><li>cmdLog<br> 每个Replica上的日志。<br> 每条日志中包含对应的Instance、Status，ballot、Command、以及deps和seq</li><li>proposed<br> 已经被被Propose了的Command</li><li>executed<br> 每个Replica上已经被execute的Command</li><li>sentMsg<br> 所有被发送，但是还没有被接受的消息，理解成Message类型对象的集合</li><li>crtInst<br> 对于每个Replica，它下一个可以使用的instance number(一个数字)，初始值是1</li><li>leaderOfInst<br> 这是从Replicas到SUBSET Instances的一个映射，表示对于每个Replica，它发起但是还没有完成的Instance的集合</li><li>committed<br> 【Q】maps commands to set of commit attributs tuples<br> 从实现上来看，应该是个三元组，表示每个Command被提交时的deps和seq</li><li>ballots<br> 所有Replica中，最大的ballot number，这里指的应该是epoch.b</li><li>preparing<br> 对于每个Replica，它目前正在preparing(例如recovering)的所有Instance</li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>Nontriviality的验证，对于任意的Instance，始终(因为有<code>[]</code>)有：在committed中的所有Command，它要么是在proposed集合中(也就是被某个Command Leader主动Propose的)，或者为none</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nontriviality ==</span><br><span class="line">    \A i \in Instances :</span><br><span class="line">        [](\A C \in committed[i] : C \in proposed \/ C = none)</span><br></pre></td></tr></table></figure><p>Stability的验证，是个三层大循环，遍历所有的Replica/Instances/Commands，此时我们检查(replica, i, C)，<strong>始终</strong>满足：<br>在replica的cmdLog[replica]中任选一条记录rec1，它的(inst,cmd)等于(replica, i)，并且status为committed或者executed，那么<strong>始终</strong>存在另一个满足条件的rec2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Stability ==</span><br><span class="line">    \A replica \in Replicas :</span><br><span class="line">        \A i \in Instances :</span><br><span class="line">            \A C \in Commands :</span><br><span class="line">                []((\E rec1 \in cmdLog[replica] :</span><br><span class="line">                    /\ rec1.inst = i</span><br><span class="line">                    /\ rec1.cmd = C</span><br><span class="line">                    /\ rec1.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;) =&gt;</span><br><span class="line">                    [](\E rec2 \in cmdLog[replica] :</span><br><span class="line">                        /\ rec2.inst = i</span><br><span class="line">                        /\ rec2.cmd = C</span><br><span class="line">                        /\ rec2.status \in &#123;&quot;committed&quot;, &quot;executed&quot;&#125;))</span><br></pre></td></tr></table></figure><p>Consistency的验证，对于所有的Instance i，始终满足它最多只会被commit一次。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Consistency ==</span><br><span class="line">    <span class="string">\A</span> i <span class="string">\in</span> Instances :</span><br><span class="line">        [](Cardinality(committed[i]) &lt;= <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">THEOREM Spec =&gt; ([]TypeOK) <span class="regexp">/\ Nontriviality /</span><span class="string">\</span> Stability /<span class="string">\</span> Consistency</span><br></pre></td></tr></table></figure><h2 id="总体的Action"><a href="#总体的Action" class="headerlink" title="总体的Action"></a>总体的Action</h2><p>可以选择执行Command Leader的某个动作，或者普通Replica的某个动作。Command Leader肯定属于Replica，但我们是按照行为来区分的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Next == </span><br><span class="line">    \/ CommandLeaderAction</span><br><span class="line">    \/ ReplicaAction</span><br></pre></td></tr></table></figure><p>首先是Command Leader的所有可能的动作：</p><ol><li>检查<code>Commands \ proposed</code>，也就是<code>Commands</code>中所有还没被propose的Command，如果存在，则<strong>选择一个C</strong>(<code>\E</code>可以表示选出一个的意思)：<br> 选出一个cleader，对C做状态转移<code>Propose(C, cleader)</code></li><li>在Replicas中选出一个cleader，在cleader为Command Leader的instance中选出一个instance，可以执行下面任意的状态转移：<ol><li>可能走Fast Path</li><li>可能走Slow Path</li><li>可能走Phase2Finalize<br> 【Q】Phase2的Accept啥时候发送的？</li><li>可能走优化路径FinalizeTryPreAccept</li></ol></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CommandLeaderAction ==</span><br><span class="line">    \/ (\E C \in (Commands \ proposed) :</span><br><span class="line">            \E cleader \in Replicas : Propose(C, cleader))</span><br><span class="line">    \/ (\E cleader \in Replicas : \E inst \in leaderOfInst[cleader] :</span><br><span class="line">            \/ (\E Q \in FastQuorums(cleader) : Phase1Fast(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase1Slow(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : Phase2Finalize(cleader, inst, Q))</span><br><span class="line">            \/ (\E Q \in SlowQuorums(cleader) : FinalizeTryPreAccept(cleader, inst, Q)))</span><br></pre></td></tr></table></figure><p>下面是ReplicaAction，选择一个Replica：</p><ol><li>可能回复Phase1</li><li>可能回复Phase2</li><li>可能对于某个Instance i，<code>i[1]</code>表示Instance这个tuple的第一个元素，也就是Replica；<code>crtInst[i[1]]</code>表示它对应的Replica下一个可以使用的instance number，如果大于i本身的instance number。<br> 这个条件说明这个instance被自己原来的owner start。<br> 则通过SlowQuorum个节点进行SendPrepare。<br> 【Q】不太懂什么意思，但这里无疑就是Explicit Prepare里面的Prepare过程了。</li><li>可以ReplyPrepare</li><li>选择一个正在preparing的Replica<br> 通过SlowQuorum个节点进行PrepareFinalize</li><li>回复ReplyTryPreaccept</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ReplicaAction ==</span><br><span class="line">    \E replica \in Replicas :</span><br><span class="line">        (\/ Phase1Reply(replica)</span><br><span class="line">         \/ Phase2Reply(replica)</span><br><span class="line">         \/ \E cmsg \in sentMsg : (cmsg.type = &quot;commit&quot; /\ Commit(replica, cmsg))</span><br><span class="line">         \/ \E i \in Instances : </span><br><span class="line">            /\ crtInst[i[1]] &gt; i[2] (* This condition states that the instance has *) </span><br><span class="line">                                    (* been started by its original owner          *)</span><br><span class="line">            /\ \E Q \in SlowQuorums(replica) : SendPrepare(replica, i, Q)</span><br><span class="line">         \/ ReplyPrepare(replica)</span><br><span class="line">         \/ \E i \in preparing[replica] :</span><br><span class="line">            \E Q \in SlowQuorums(replica) : PrepareFinalize(replica, i, Q)</span><br><span class="line">         \/ ReplyTryPreaccept(replica))</span><br></pre></td></tr></table></figure><h2 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h2><h3 id="Propose"><a href="#Propose" class="headerlink" title="Propose"></a>Propose</h3><p>从上文看到，CommandLeaderAction的一个可能的状态转移是Propose。<br>此时，生成newInst和newBallot。新生成的newInst的instance number为crtInst[cleader]，newBallot的<code>epoch.b</code>部分始终为0，看来是不考虑epoch了。<br>然后，将要Propose的Command C添加进proposed中，并且在FastQuorum里面选择一个Quorum，尝试走FastPath。<br>然后，我们自增crtInst，这里的<code>@</code>就是<code>crtInst[cleader]</code>，实际上是一个简写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Propose(C, cleader) ==</span><br><span class="line">    LET newInst == &lt;&lt;cleader, crtInst[cleader]&gt;&gt; </span><br><span class="line">        newBallot == &lt;&lt;0, cleader&gt;&gt; </span><br><span class="line">    IN  /\ proposed&apos; = proposed \cup &#123;C&#125;</span><br><span class="line">        /\ (\E Q \in FastQuorums(cleader):</span><br><span class="line">                 StartPhase1(C, cleader, Q, newInst, newBallot, &#123;&#125;))</span><br><span class="line">        /\ crtInst&apos; = [crtInst EXCEPT ![cleader] = @ + 1]</span><br><span class="line">        /\ UNCHANGED &lt;&lt; executed, committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><p>对Phase1的处理起始于<code>StartPhase1</code>，这个状态转移触发的条件有很多，比如上面的Propose。<br>首先，构建依赖deps和seq：</p><ol><li>newDeps是Command Leader即cleader中所有Command的Instance，即<code>rec.inst</code>。<br> 【Q】这是不是太强了点？按照协议，首先要是冲突的，然后只要包含最高冲突Instance的编号就行啊。</li><li>newSeq是cleader中所有Command的seq的最大值，然后还要加1，这是符合协议的论述的。</li><li>oldRecs表示cleader中所有和当前Command的Instance相同的Command。</li></ol><p>然后进行状态转移：</p><ol><li>cmdLog<br> 需要修改cleader的Log。具体来说，需要把同Instance的所有的旧的日志全部干掉。【Q】为啥可能会有同Instance的日志呢？<br> 然后，我们把新的Command加上到日志中，并且设置status为”pre-accepted”。也就是说cleader我PreAccept了这个日志，并不代表其他Replica也PreAccept了这个日志。</li><li>leaderOfInst<br> 显然，对于这个Instance，cleader我是它的Leader。这是显然的，因为Instance二元组里面，Replica是cleader，然后instance number也是自增的。<br> 应该加入到leaderOfInst，表示是我发起的，但还没有完成的Instance。</li><li>sentMsg<br> 显然要往其他的Replica发消息。在此之前，我们先要把oldMsg干掉。如果我们是走Propose过来的，那么oldMsg是空的。但如果是走Explicit Prepare过来的，那么是会传入oldMsg的，这个到时候再说。<br> 这里需要注意，消息的定义是<code>src: Replicas, dst: Replicas</code>，但我们传进来的src和dst实际上是两个集合，这会导致产生一系列新Msg。可以参考<a href="/2021/06/26/tla/">TLA</a>的文档。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StartPhase1(C, cleader, Q, inst, ballot, oldMsg) ==</span><br><span class="line">    LET newDeps == &#123;rec.inst: rec \in cmdLog[cleader]&#125; </span><br><span class="line">        newSeq == 1 + Max(&#123;t.seq: t \in cmdLog[cleader]&#125;) </span><br><span class="line">        oldRecs == &#123;rec \in cmdLog[cleader] : rec.inst = inst&#125; IN</span><br><span class="line">        /\ cmdLog&apos; = [cmdLog EXCEPT ![cleader] = (@ \ oldRecs) \cup </span><br><span class="line">                                &#123;[inst   |-&gt; inst,</span><br><span class="line">                                  status |-&gt; &quot;pre-accepted&quot;,</span><br><span class="line">                                  ballot |-&gt; ballot,</span><br><span class="line">                                  cmd    |-&gt; C,</span><br><span class="line">                                  deps   |-&gt; newDeps,</span><br><span class="line">                                  seq    |-&gt; newSeq ]&#125;]</span><br><span class="line">        /\ leaderOfInst&apos; = [leaderOfInst EXCEPT ![cleader] = @ \cup &#123;inst&#125;]</span><br><span class="line">        /\ sentMsg&apos; = (sentMsg \ oldMsg) \cup </span><br><span class="line">                                [type  : &#123;&quot;pre-accept&quot;&#125;,</span><br><span class="line">                                  src   : &#123;cleader&#125;,</span><br><span class="line">                                  dst   : Q \ &#123;cleader&#125;,</span><br><span class="line">                                  inst  : &#123;inst&#125;,</span><br><span class="line">                                  ballot: &#123;ballot&#125;,</span><br><span class="line">                                  cmd   : &#123;C&#125;,</span><br><span class="line">                                  deps  : &#123;newDeps&#125;,</span><br><span class="line">                                  seq   : &#123;newSeq&#125;]</span><br></pre></td></tr></table></figure><h3 id="Phase1Reply"><a href="#Phase1Reply" class="headerlink" title="Phase1Reply"></a>Phase1Reply</h3><p>Propose是发送PreAccept请求，Phase1Reply是其他Replica处理该请求。<br>任选一个发给replica的type为”pre-accept”的消息msg。<br>oldRec为replica日志中，inst等于msg对应的Instance的日志组成的集合。<br>那么对于oldRec中所有的日志rec，要么它的ballot等于msg里的ballot，要么比msg传过来的ballot要小。否则这个消息就应该被忽略。</p><p>构造newDeps为msg传来的deps，加上当前replica所有的log中的Instance(除去msg.inst)。<br>构造newSeq为Max(msg.seq, replica的所有日志中最大的seq+1)。<br>构造instCom，为replica自己日志中所有status为”committed”或”executed”(其实就是已提交)的日志对应的Instance构成的集合。</p><p>下面是状态转移：</p><ol><li>修改当前replica的cmdLog<br> 主要是将status变成”pre-accepted”，然后deps和seq设置为刚算出来的newDeps和newSeq。</li><li>发送消息<br> 发送一条”pre-accept-reply”消息给msg.src，实际上就是刚才发命令过来的cleader。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Phase1Reply(replica) ==</span><br><span class="line">    <span class="string">\E</span> msg <span class="string">\in</span> sentMsg:</span><br><span class="line">        /<span class="string">\</span> msg.type = <span class="string">"pre-accept"</span></span><br><span class="line">        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">        /<span class="string">\</span> LET oldRec == &#123;rec <span class="string">\in</span> cmdLog[replica]: rec.inst = msg.inst&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rec <span class="string">\in</span> oldRec : </span><br><span class="line">                (rec.ballot = msg.ballot <span class="string">\/rec.ballot[1]</span> &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /<span class="string">\</span> LET newDeps == msg.deps <span class="string">\cup</span> </span><br><span class="line">                            (&#123;t.inst: t <span class="string">\in</span> cmdLog[replica]&#125; <span class="string">\</span> &#123;msg.inst&#125;)</span><br><span class="line">                   newSeq == Max(&#123;msg.seq, </span><br><span class="line">                                  <span class="number">1</span> + Max(&#123;t.seq: t <span class="string">\in</span> cmdLog[replica]&#125;)&#125;)</span><br><span class="line">                   instCom == &#123;t.inst: t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">                              tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125; IN</span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup</span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; msg.inst,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "pre-accepted",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; msg.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; msg.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; newDeps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; newSeq]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> &#123;msg&#125;) <span class="string">\cup</span></span><br><span class="line">                                    &#123;[type  |<span class="function">-&gt;</span> <span class="string">"pre-accept-reply"</span>,</span><br><span class="line">                                      src   |<span class="function">-&gt;</span> replica,</span><br><span class="line">                                      dst   |<span class="function">-&gt;</span> msg.src,</span><br><span class="line">                                      inst  |<span class="function">-&gt;</span> msg.inst,</span><br><span class="line">                                      ballot|<span class="function">-&gt;</span> msg.ballot,</span><br><span class="line">                                      deps  |<span class="function">-&gt;</span> newDeps,</span><br><span class="line">                                      seq   |<span class="function">-&gt;</span> newSeq,</span><br><span class="line">                                      committed|<span class="function">-&gt;</span> instCom]&#125;</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Fast"><a href="#Phase1Fast" class="headerlink" title="Phase1Fast"></a>Phase1Fast</h3><p>Phase1Fast是cleader在其他Replica处理该请求后，尝试通过FastPath提交这个请求。里面包含了是否能够进行FastPath提交的判断，以及提交的状态转移。<br>首先，是一部分简单的Enable条件，校验cleader是不是Instance i的Leader，并检查Q是不是cleader的FastQuorums。<br>然后，选择cleader的某条日志record，日志中的Instance为i、Status为”pre-accepted”、ballot的为0。这些日志肯定是从StartPhase1设置的。并且因为ballot为0，所以肯定是从Propose设置的。<br>Q通过刚才的Phase1Reply发回来的replies，它们是”pre-accept-reply”类型的消息，并且ballot等于record对应的ballot，我们进行下面的检查：</p><ol><li>对于Q中除了cleader之外的replica，在replies中都会有从它发给cleader的”pre-accept-reply”消息。<br> 也就是说Q中的Replica，都回复了cleader的pre-accept请求。<br> 这个检查是必要的，如果说之前cleader通过StartPhase1发过去的ballot比较小，那么有的replica就不会回复，因此这条Enable条件就过不了。</li><li>并且replies中任意两个消息r1和r2，它们的deps和seq是相等的。<br> 这是走FastPath的要求，只有满足该要求，才能进下一步。<br> 这个实际上也是Enable条件，如果不满足那么根本就不会有下面的状态转移。</li><li>CHOOSE replies中的某一个r，基于它构造新的r.deps：<br> 这里可以CHOOSE，是因为大家的deps和seq都一样。<br> 注意已提交的日志，指的是status为”committed”和”executed”的日志。<ol><li>localCom<br> cleader的所有的已提交日志的Instance构成集合。</li><li>extCom<br> Phase1Reply中，replica在回复时，会带上自己日志中所有已提交的日志对应的Instance构成的集合。<br> extCom是这些的并集。</li><li>然后构造新的r.deps集合，为localCom和extCom中所有的Instance</li></ol></li></ol><p>然后基于r构造状态转移：</p><ol><li>cmdLog<br> 更新这个日志状态为committed。<br> 更新当前的record的attribute为r.deps和r.seq。</li><li>sentMsg<br> 产生一条Commit信息，这个消息可能是直接给Client的，所以没有dst和src。</li><li>leaderOfInst<br> 在leaderOfInst[cleader]中移除掉当前的Instance i，表示这个Instance已经提交了。</li><li>committed<br> 将<code>&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;</code>加入已提交的数组中。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">Phase1Fast(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> FastQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"pre-accepted"</span></span><br><span class="line">        /<span class="string">\</span> record.ballot[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i</span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"pre-accept-reply"</span></span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader</span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q</span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): </span><br><span class="line">                    <span class="string">\E</span> msg <span class="string">\in</span> replies: msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> r1, r2 <span class="string">\in</span> replies:</span><br><span class="line">                /<span class="string">\</span> r1.deps = r2.deps</span><br><span class="line">                /<span class="string">\</span> r1.seq = r2.seq)</span><br><span class="line">            /<span class="string">\</span> LET r == CHOOSE r <span class="string">\in</span> replies : TRUE IN</span><br><span class="line">                /<span class="string">\</span> LET localCom == &#123;t.inst: </span><br><span class="line">                            t <span class="string">\in</span> &#123;tt <span class="string">\in</span> cmdLog[cleader] : </span><br><span class="line">                                 tt.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;&#125;&#125;</span><br><span class="line">                       extCom == UNION &#123;msg.committed: msg <span class="string">\in</span> replies&#125; IN</span><br><span class="line">                       (r.deps <span class="string">\subseteq</span> (localCom <span class="string">\cup</span> extCom))    </span><br><span class="line">                /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                        &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                          status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                          ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                          cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                          deps   |-&gt; r.deps,</span></span><br><span class="line"><span class="string">                                          seq    |-&gt; r.seq ]&#125;]</span></span><br><span class="line"><span class="string">                /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                            &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                            inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                            ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                            cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                            deps    |<span class="function">-&gt;</span> r.deps,</span><br><span class="line">                            seq     |<span class="function">-&gt;</span> r.seq]&#125;</span><br><span class="line">                /<span class="string">\</span> leaderOfInst<span class="string">' = [leaderOfInst EXCEPT ![cleader] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                /\ committed'</span> = [committed EXCEPT ![i] = </span><br><span class="line">                                            @ <span class="string">\cup</span> &#123;&lt;&lt;record.cmd, r.deps, r.seq&gt;&gt;&#125;]</span><br><span class="line">                /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase1Slow"><a href="#Phase1Slow" class="headerlink" title="Phase1Slow"></a>Phase1Slow</h3><p>Phase1Slow是cleader在其他Replica处理该请求后，尝试通过SlowPath提交这个请求。<br>前面的条件都一样，不再赘述。</p><p>主要不一样的地方是从finalDeps开始的。这里大家的deps和seq都不一定一样了，所以不能像FastPath一样CHOOSE了，而要老老实实取并集、取最大值。</p><ol><li>finalDeps<br> 就是所有来自Replica的回复中的deps的并集。</li><li>finalSeq<br> 就是所有回复中最大的seq。</li></ol><p>下面构造状态转移：</p><ol><li>cmdLog<br> 更新日志状态为”accepted”。<br> 注意，在FastPath中，能够直接进入commited状态，但这里得先是”accepted”，后面再走一轮Phase2才行。</li><li>sentMsg<br> 往除自己之外的SlowQuorum成员发送”accept”形式的消息。并且带上deps和seq为finalDeps和finalSeq。这个消息会在Phase2Reply被Replica处理。</li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Phase1Slow(cleader, i, Q) ==</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>i <span class="tag">\<span class="name">in</span></span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span>Q <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> record <span class="tag">\<span class="name">in</span></span> cmdLog[cleader]:</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.inst = i</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>record.status = "pre-accepted"</span><br><span class="line">        /<span class="tag">\<span class="name"> </span></span>LET replies == &#123;msg <span class="tag">\<span class="name">in</span></span> sentMsg: </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.inst = i </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.type = "pre-accept-reply" </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.dst = cleader </span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.src <span class="tag">\<span class="name">in</span></span> Q</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>(<span class="tag">\<span class="name">A</span></span> replica <span class="tag">\<span class="name">in</span></span> (Q <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>): <span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies: msg.src = replica)</span><br><span class="line">            /<span class="tag">\<span class="name"> </span></span>LET finalDeps == UNION &#123;msg.deps : msg <span class="tag">\<span class="name">in</span></span> replies&#125;</span><br><span class="line">                   finalSeq == Max(&#123;msg.seq : msg <span class="tag">\<span class="name">in</span></span> replies&#125;) IN    </span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![cleader] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;record&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span> </span><br><span class="line">                                        &#123;[inst   |-&gt; i,</span><br><span class="line">                                          status |-&gt; "accepted",</span><br><span class="line">                                          ballot |-&gt; record.ballot,</span><br><span class="line">                                          cmd    |-&gt; record.cmd,</span><br><span class="line">                                          deps   |-&gt; finalDeps,</span><br><span class="line">                                          seq    |-&gt; finalSeq ]&#125;]</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">E</span></span> SQ <span class="tag">\<span class="name">in</span></span> SlowQuorums(cleader):</span><br><span class="line">                   (sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                            [type : &#123;"accept"&#125;,</span><br><span class="line">                            src : &#123;cleader&#125;,</span><br><span class="line">                            dst : SQ <span class="tag">\<span class="name"> </span><span class="string">&#123;cleader&#125;</span></span>,</span><br><span class="line">                            inst : &#123;i&#125;,</span><br><span class="line">                            ballot: &#123;record.ballot&#125;,</span><br><span class="line">                            cmd : &#123;record.cmd&#125;,</span><br><span class="line">                            deps : &#123;finalDeps&#125;,</span><br><span class="line">                            seq : &#123;finalSeq&#125;])</span><br><span class="line">                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Phase2"><a href="#Phase2" class="headerlink" title="Phase2"></a>Phase2</h2><h3 id="Phase2Reply"><a href="#Phase2Reply" class="headerlink" title="Phase2Reply"></a>Phase2Reply</h3><p>Phase2Reply处理在SlowPath中，从Command Leader发过来的”accept”消息。</p><p>这里的Enable条件是，在自己的日志<code>cmdLog[replica]</code>中按照<code>msg.inst</code>找到对应的记录，要求消息的ballot要么等于，要么大于日志中的ballot。</p><p>如果满足Enable条件，则可以进行状态转移：</p><ol><li>cmdLog<br> 修改自己的日志，状态为”accepted”，并且更新deps和seq为msg中传入的值。这个值是由finalDeps和finalSeq一起计算得到的。</li><li>sentMsg<br> 发送”accept-reply”消息给cleader。</li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Phase2Reply</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg: </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "accept"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica]: <span class="keyword">rec</span>.inst = msg.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec: (<span class="keyword">rec</span>.ballot = msg.ballot \/ </span><br><span class="line">                                    <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt; msg.ballot[<span class="number">1</span>]))</span><br><span class="line">            /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                &#123;[inst   |-&gt; msg.inst,</span><br><span class="line">                                  status |-&gt; <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot |-&gt; msg.ballot,</span><br><span class="line">                                  cmd    |-&gt; msg.cmd,</span><br><span class="line">                                  deps   |-&gt; msg.deps,</span><br><span class="line">                                  seq    |-&gt; msg.seq]&#125;]</span><br><span class="line">            /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                                &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "accept-reply",</span></span><br><span class="line">                                  src   |-&gt; replica,</span><br><span class="line">                                  dst   |-&gt; msg.src,</span><br><span class="line">                                  inst  |-&gt; msg.inst,</span><br><span class="line">                                  ballot|-&gt; msg.ballot]&#125;</span><br><span class="line">            /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, crtInst, executed, leaderOfInst,</span><br><span class="line">                            committed, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="Phase2Finalize"><a href="#Phase2Finalize" class="headerlink" title="Phase2Finalize"></a>Phase2Finalize</h3><p>Phase2Finalize是整个SlowQuorum过程的终点，cleader会收集各个Replica的消息，并提交Command。即对于cleader下的某个Instance i，和SlowQuorum Q，尝试完成Phase2的最终提交。</p><p>照例还是Enable条件，在自己的日志里面看看能不能找到i对应的状态为”accepted”的日志，如果找不到，那么也不用往下看了。<br>如果能找到，就需要在sentMsg中找出所有和这个Instance相关的，类型为”accept-reply”的消息(也就是各个Replica在Phase2Reply过程中发出的消息)。显然，对于Q中除cleader之外的replica，都需要发一条这样的消息才能继续提交。</p><p>下面就是状态转移，和Phase1Fast基本一致，就不另外说明了。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Phase2Finalize(cleader, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> leaderOfInst[cleader]</span><br><span class="line">    /<span class="string">\</span> Q <span class="string">\in</span> SlowQuorums(cleader)</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> record <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> record.inst = i</span><br><span class="line">        /<span class="string">\</span> record.status = <span class="string">"accepted"</span></span><br><span class="line">        /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg: </span><br><span class="line">                                /<span class="string">\</span> msg.inst = i </span><br><span class="line">                                /<span class="string">\</span> msg.type = <span class="string">"accept-reply"</span> </span><br><span class="line">                                /<span class="string">\</span> msg.dst = cleader </span><br><span class="line">                                /<span class="string">\</span> msg.src <span class="string">\in</span> Q </span><br><span class="line">                                /<span class="string">\</span> msg.ballot = record.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> replica <span class="string">\in</span> (Q <span class="string">\</span> &#123;cleader&#125;): <span class="string">\E</span> msg <span class="string">\in</span> replies: </span><br><span class="line">                                                        msg.src = replica)</span><br><span class="line">            /<span class="string">\</span> cmdLog<span class="string">' = [cmdLog EXCEPT ![cleader] = (@ \ &#123;record&#125;) \cup </span></span><br><span class="line"><span class="string">                                    &#123;[inst   |-&gt; i,</span></span><br><span class="line"><span class="string">                                      status |-&gt; "committed",</span></span><br><span class="line"><span class="string">                                      ballot |-&gt; record.ballot,</span></span><br><span class="line"><span class="string">                                      cmd    |-&gt; record.cmd,</span></span><br><span class="line"><span class="string">                                      deps   |-&gt; record.deps,</span></span><br><span class="line"><span class="string">                                      seq    |-&gt; record.seq ]&#125;]</span></span><br><span class="line"><span class="string">            /\ sentMsg'</span> = (sentMsg <span class="string">\</span> replies) <span class="string">\cup</span></span><br><span class="line">                        &#123;[type  |<span class="function">-&gt;</span> <span class="string">"commit"</span>,</span><br><span class="line">                        inst    |<span class="function">-&gt;</span> i,</span><br><span class="line">                        ballot  |<span class="function">-&gt;</span> record.ballot,</span><br><span class="line">                        cmd     |<span class="function">-&gt;</span> record.cmd,</span><br><span class="line">                        deps    |<span class="function">-&gt;</span> record.deps,</span><br><span class="line">                        seq     |<span class="function">-&gt;</span> record.seq]&#125;</span><br><span class="line">            /<span class="string">\</span> committed<span class="string">' = [committed EXCEPT ![i] = @ \cup </span></span><br><span class="line"><span class="string">                               &#123;&lt;&lt;record.cmd, record.deps, record.seq&gt;&gt;&#125;]</span></span><br><span class="line"><span class="string">            /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">            /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><p>下面是Recovery相关操作。</p><h3 id="SendPrepare"><a href="#SendPrepare" class="headerlink" title="SendPrepare"></a>SendPrepare</h3><p>这里的replica就是论文里面的Replica L。其中，Enable条件：</p><ol><li>replica并不是i这个Instance的Leader<br> 这里注释掉一句，是replica并没有prepare这个instance。【Q】我不清楚为什么这个被注释掉。</li><li>目前使用过的ballots不超过MaxBallot<br> 这个应该是防止最后算法不会终止</li><li>replica当前的日志中，不存在任何Instance为i的日志是已提交的(即其status为”committed”和”executed”)。</li></ol><p>状态转移：</p><ol><li>sentMsg<br> 从这个replica向一个SlowQuorum，即Q发送”prepare”消息。<br> 这里注意，更新ballot为<code>&lt;&lt; ballots, replica &gt;&gt;</code>，这里的ballots是全局最大的ballot值。</li><li>ballots<br> 更新全局最大的ballots，自增1。</li><li>preparing<br> 将当前replica的preparing集合中增加Instance i。</li></ol><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SendPrepare(replica, i, Q) ==</span><br><span class="line">    /<span class="symbol">\ </span>i <span class="symbol">\n</span>otin leaderOfInst[replica]</span><br><span class="line">    <span class="symbol">\*</span>/<span class="symbol">\ </span>i <span class="symbol">\n</span>otin preparing[replica]</span><br><span class="line">    /<span class="symbol">\ </span>ballots &lt;= MaxBallot</span><br><span class="line">    /<span class="symbol">\ </span>~(<span class="symbol">\E</span> rec <span class="symbol">\i</span>n cmdLog[replica] :</span><br><span class="line">                        /<span class="symbol">\ </span>rec.inst = i</span><br><span class="line">                        /<span class="symbol">\ </span>rec.status <span class="symbol">\i</span>n &#123;"committed", "executed"&#125;)</span><br><span class="line">    /<span class="symbol">\ </span>sentMsg' = sentMsg <span class="symbol">\c</span>up</span><br><span class="line">                    [type   : &#123;"prepare"&#125;,</span><br><span class="line">                     src    : &#123;replica&#125;,</span><br><span class="line">                     dst    : Q,</span><br><span class="line">                     inst   : &#123;i&#125;,</span><br><span class="line">                     ballot : &#123;&lt;&lt; ballots, replica &gt;&gt;&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>ballots' = ballots + 1</span><br><span class="line">    /<span class="symbol">\ </span>preparing' = [preparing EXCEPT ![replica] = @ <span class="symbol">\c</span>up &#123;i&#125;]</span><br><span class="line">    /<span class="symbol">\ </span>UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst,</span><br><span class="line">                    leaderOfInst, committed &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyPrepare"><a href="#ReplyPrepare" class="headerlink" title="ReplyPrepare"></a>ReplyPrepare</h3><p>ReplyPrepare处理来自SendPrepare里面replica的”prepare”消息。下面进行讨论：</p><ol><li>如果自己的日志中，存在一条对应于msg里面instance的日志，并且消息中的ballot要大于日志中的ballot。<br> 状态转移：<ol><li>sentMsg<br> 将来自SendPrepare里面replica的”prepare”消息删除，并重新发送一条”prepare-reply”消息给msg.src。<br> 消息中的ballot为自己的msg.ballot，prev_ballot为rec.ballot。根据前文，msg.ballot肯定是大于rec.ballot的。<br> 消息中的deps和seq沿用自己本地日志中的。【Q】这里很奇怪，似乎我们不在ReplyPrepare阶段对deps和seq决议。</li><li>cmdLog<br> 删除自己日志中的rec，并且增加一条新条目。这个新条目和rec大致一样，只是将ballot更新为msg中的ballot。</li><li>leaderOfInst<br> 如果日志中的instance的Command Leader是replica，那么将它移出<code>leaderOfInst[replica]</code>。否则保持不变。<br> 【Q】这里是啥意思，重新选一个Command Leader，还是直接走Basic Paxos那一套提交呢？</li></ol></li><li>如果在自己日志中，不存在对应于msg里面instance的日志。<br> 状态转移：<ol><li>sentMsg<br> 发送”prepare-reply”消息。<br> ballot为消息中传来的ballot，并且prev_ballot为<code>&lt;&lt; 0, replica &gt;&gt;</code>，相当于是一开始的ballot。【Q】msg.ballot肯定是大于rec.ballot的么？<br> 其他的字段也是设置成默认值：status为”not-seen”。cmd为none。deps为<code>{}</code>，seq为0。</li><li>cmdLog<br> 参照sentMsg的变更</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyPrepare</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> msg \<span class="keyword">in</span> sentMsg : </span><br><span class="line">        /\ msg.<span class="class"><span class="keyword">type</span> = "prepare"</span></span><br><span class="line">        /\ msg.dst = replica</span><br><span class="line">        /\ \/ \<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : </span><br><span class="line">                /\ <span class="keyword">rec</span>.inst = msg.inst</span><br><span class="line">                /\ msg.ballot[<span class="number">1</span>] &gt; <span class="keyword">rec</span>.ballot[<span class="number">1</span>]</span><br><span class="line">                /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; <span class="keyword">rec</span>.ballot,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;</span><br><span class="line">                 /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ &#123;<span class="keyword">rec</span>&#125;) \cup</span><br><span class="line">                            &#123;[inst  |-&gt; <span class="keyword">rec</span>.inst,</span><br><span class="line">                              status|-&gt; <span class="keyword">rec</span>.status,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; <span class="keyword">rec</span>.cmd,</span><br><span class="line">                              deps  |-&gt; <span class="keyword">rec</span>.deps,</span><br><span class="line">                              seq   |-&gt; <span class="keyword">rec</span>.seq]&#125;]</span><br><span class="line">                 /\ <span class="type">IF</span> <span class="keyword">rec</span>.inst \<span class="keyword">in</span> leaderOfInst[replica] <span class="type">THEN</span></span><br><span class="line">                        /\ leaderOfInst' = [leaderOfInst <span class="type">EXCEPT</span> ![replica] = </span><br><span class="line">                                                                @ \ &#123;insrec.t&#125;]</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed,</span><br><span class="line">                                        crtInst, ballots, preparing &gt;&gt;</span><br><span class="line">                    <span class="type">ELSE</span> <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst,</span><br><span class="line">                                      ballots, preparing, leaderOfInst &gt;&gt;</span><br><span class="line">                        </span><br><span class="line">           \/ /\ ~(\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = msg.inst)</span><br><span class="line">              /\ sentMsg' = (sentMsg \ &#123;msg&#125;) \cup</span><br><span class="line">                            &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "prepare-reply",</span></span><br><span class="line">                              src   |-&gt; replica,</span><br><span class="line">                              dst   |-&gt; msg.src,</span><br><span class="line">                              inst  |-&gt; msg.inst,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              prev_ballot|-&gt; &lt;&lt; <span class="number">0</span>, replica &gt;&gt;,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;</span><br><span class="line">              /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = @ \cup</span><br><span class="line">                            &#123;[inst  |-&gt; msg.inst,</span><br><span class="line">                              status|-&gt; <span class="string">"not-seen"</span>,</span><br><span class="line">                              ballot|-&gt; msg.ballot,</span><br><span class="line">                              cmd   |-&gt; none,</span><br><span class="line">                              deps  |-&gt; &#123;&#125;,</span><br><span class="line">                              seq   |-&gt; <span class="number">0</span>]&#125;]</span><br><span class="line">              /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                              leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="PrepareFinalize"><a href="#PrepareFinalize" class="headerlink" title="PrepareFinalize"></a>PrepareFinalize</h3><p>SendPrepare里面的replica，也就是所谓的Replica L，在收到对端的”prepare-reply”消息后，会走到PrepareFinalize中。这个函数也是最为复杂的。</p><p>Enable条件：</p><ol><li>i要在preparing[replica]中<br> 也就是确认当前replica是Replica L</li><li>replica的日志中有i这个Instance，并且还没被提交</li><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<br> 下面会讨论四种情况，总体是”越来越惨”的<ol><li>如果这些replies中的某个com的status是已提交(即”committed”, “executed”)<br> 【Q】为什么会有这种情况？感觉应该是因为在FastPath的Phase1Fast或者SlowPath的Phase2Finalize之后，cleader宕机导致的。<br> 那么就将这个Instance i移出preparing[replica]。并且在sentMsg中删除所有的replies。<br> 【Q】感觉这就相当于直接让它往后提交了？</li><li>如果这些replies中<strong>没有</strong>status是已提交(即”committed”, “executed”)，但是存在acc是**”accepted”**的。<br> 同时还需要检查acc的prev_ballot大于等于(如果其他消息不是”accept”状态，那么就默认acc的大)所有其他消息的prev_ballot<br> 状态转移：<ol><li>sentMsg<br> 删除所有的replies，并且对除当前replica之外的所有Q，都发送一条”accept”消息。<br> 这个消息的ballot为自己日志中的ballot。<br> 关键内容，即cmd、deps和seq，都设置为acc传过来的。<br> 【Q】为什么replies里面prev_ballot最大的那个消息是”accpeted”，就可以以它为准走”accept流程”？</li><li>cmdLog<br> 参照sentMsg创建一个新条目。</li></ol></li></ol></li></ol><p>因为太长了，所以后面两种情况拆到下面讨论</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PrepareFinalize(replica, i, Q) ==</span><br><span class="line">    /<span class="string">\</span> i <span class="string">\in</span> preparing[replica]</span><br><span class="line">    /<span class="string">\</span> <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[replica] :</span><br><span class="line">       /<span class="string">\</span> rec.inst = i</span><br><span class="line">       /<span class="string">\</span> rec.status <span class="string">\notin</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">       /<span class="string">\</span> LET replies == &#123;msg <span class="string">\in</span> sentMsg : </span><br><span class="line">                        /<span class="string">\</span> msg.inst = i</span><br><span class="line">                        /<span class="string">\</span> msg.type = <span class="string">"prepare-reply"</span></span><br><span class="line">                        /<span class="string">\</span> msg.dst = replica</span><br><span class="line">                        /<span class="string">\</span> msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> (<span class="string">\A</span> rep <span class="string">\in</span> Q : <span class="string">\E</span> msg <span class="string">\in</span> replies : msg.src = rep)</span><br><span class="line">            <span class="regexp">/\  \/</span> <span class="string">\E</span> com <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> (com.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                        /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                        /\ sentMsg'</span> = sentMsg <span class="string">\</span> replies</span><br><span class="line">                        /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, crtInst, leaderOfInst,</span><br><span class="line">                                        committed, ballots &gt;&gt;</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> ~(<span class="string">\E</span> msg <span class="string">\in</span> replies : msg.status <span class="string">\in</span> &#123;<span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;)</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\E</span> acc <span class="string">\in</span> replies :</span><br><span class="line">                        /<span class="string">\</span> acc.status = <span class="string">"accepted"</span></span><br><span class="line">                        /<span class="string">\</span> (<span class="string">\A</span> msg <span class="string">\in</span> (replies <span class="string">\</span> &#123;acc&#125;) : </span><br><span class="line">                            (msg.prev_ballot[<span class="number">1</span>] &lt;= acc.prev_ballot[<span class="number">1</span>] <span class="string">\/</span> </span><br><span class="line">                             msg.status <span class="comment"># "accepted"))</span></span><br><span class="line">                        /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ replies) \cup</span></span><br><span class="line"><span class="string">                                 [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                                  src   : &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  dst   : Q \ &#123;replica&#125;,</span></span><br><span class="line"><span class="string">                                  inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                                  ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                                  cmd   : &#123;acc.cmd&#125;,</span></span><br><span class="line"><span class="string">                                  deps  : &#123;acc.deps&#125;,</span></span><br><span class="line"><span class="string">                                  seq   : &#123;acc.seq&#125;]</span></span><br><span class="line"><span class="string">                        /\ cmdLog'</span> = [cmdLog EXCEPT ![replica] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                                &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                                  status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                                  ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                                  cmd   |<span class="function">-&gt;</span> acc.cmd,</span><br><span class="line">                                  deps  |<span class="function">-&gt;</span> acc.deps,</span><br><span class="line">                                  seq   |<span class="function">-&gt;</span> acc.seq]&#125;]</span><br><span class="line">                         /<span class="string">\</span> preparing<span class="string">' = [preparing EXCEPT ![replica] = @ \ &#123;i&#125;]</span></span><br><span class="line"><span class="string">                         /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![replica] = @ <span class="string">\cup</span> &#123;i&#125;]</span><br><span class="line">                         /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><p>下面是后两种情况：</p><ol><li>Q中所有的replica都给当前replica的发送”prepare-reply”回复(replies)，并且：<ol><li>第一种情况；已经讨论</li><li>第二种情况：已经讨论</li><li>如果这些replies中，同时没有”committed”、”executed”、”accept”状态，但是有”pre-accepted”<br> 将replies中所有的”pre-accepted”提出来为preaccepts，又分为三种情况：<ol><li>preaccepts里面任意两个的cmd、deps和seq都相等。并且preaccepts中没有一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的。并且Q中所有的replica都发了”pre-accepted”给当前的replica。<br> 执行状态转移：<ol><li>sentMsg<br> 从当前replica向Q中所有其他replica发送”accept”。<br> cmd、deps和seq取其中任意一个就行，因为都相等。</li><li>cmdLog<br> 参照sentMsg</li><li>preparing<br> 在preparing[replica]移除掉Instance i。</li><li>leaderOfInst<br> 在leaderOfInst[replica]移除掉Instance i。</li></ol></li><li>如果和之前一样，但Q中只有大于<code>Cardinality(Q) \div 2</code>个replica发送了”pre-accepted”<br> 执行状态转移：<ol><li>sentMsg<br> <strong>这也是全局唯一会走到ReplyTryPreaccept流程里面的情况，对应了优化算法</strong>。<br> 从当前replica向Q中所有其他replica发送”try-pre-accept”。<br> 注意，这个消息<strong>也要</strong>发送给自己，所以和上一个情况是不同的处理策略。<br> cmd、deps和seq的处理办法和上面是一样的。</li></ol></li><li>如果<code>preaccepts</code>不为空，并且满足下面三个条件之一：连cmd、deps和seq都不完全一样了，<strong>或者</strong><code>Cardinality(preaccepts)</code>也小于<code>Cardinality(Q) \div 2</code>，<strong>或者</strong><code>preaccepts</code>中存在一个消息是从Instance i最初的Command Leader即<code>i[1]</code>发出的<br> 执行状态转移：<ol><li>在preaccepts中CHOOSE一个cmd不为none的pac，执行StartPhase1<br> 但是和Propose的处理不同，这里会带上rec.ballot, replies作为Ballot和oldMsg参数。<br> 而replies会在StartPhase1中被直接干掉(从sendMsg里面删除掉)。</li><li>preparing<br> 去掉i</li></ol></li></ol></li><li>如果这些replies中，状态都是”not-seen”的<br> 执行状态转移：<ol><li>同样执行StartPhase1，但cmd为none。</li><li>preparing<br> 去掉i</li></ol></li></ol></li></ol><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span> /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : </span><br><span class="line">                        msg.status <span class="tag">\<span class="name">in</span></span> &#123;"accepted", "committed", "executed"&#125;)</span><br><span class="line">                   /<span class="tag">\<span class="name"> </span></span>LET preaccepts == &#123;msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "pre-accepted"&#125; IN</span><br><span class="line">                       (<span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts :</span><br><span class="line">                                    p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span>p1.deps = p2.deps /<span class="tag">\<span class="name"> </span></span>p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q <span class="tag">\<span class="name"> </span><span class="string">&#123;replica&#125;</span></span>,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>cmdLog' = [cmdLog EXCEPT ![replica] = (@ <span class="tag">\<span class="name"> </span><span class="string">&#123;rec&#125;</span></span>) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                        &#123;[inst  |-&gt; i,</span><br><span class="line">                                          status|-&gt; "accepted",</span><br><span class="line">                                          ballot|-&gt; rec.ballot,</span><br><span class="line">                                          cmd   |-&gt; pac.cmd,</span><br><span class="line">                                          deps  |-&gt; pac.deps,</span><br><span class="line">                                          seq   |-&gt; pac.seq]&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                 /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd = p2.cmd /<span class="tag">\<span class="name"> </span></span></span><br><span class="line">                                                          p1.deps = p2.deps /<span class="tag">\</span></span><br><span class="line">                                                          p1.seq = p2.seq</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>~(<span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1])</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &lt; Cardinality(Q) - 1</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>Cardinality(preaccepts) &gt;= Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : TRUE IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>sentMsg' = (sentMsg <span class="tag">\<span class="name"> </span></span>replies) <span class="tag">\<span class="name">cup</span></span></span><br><span class="line">                                         [type  : &#123;"try-pre-accept"&#125;,</span><br><span class="line">                                          src   : &#123;replica&#125;,</span><br><span class="line">                                          dst   : Q,</span><br><span class="line">                                          inst  : &#123;i&#125;,</span><br><span class="line">                                          ballot: &#123;rec.ballot&#125;,</span><br><span class="line">                                          cmd   : &#123;pac.cmd&#125;,</span><br><span class="line">                                          deps  : &#123;pac.deps&#125;,</span><br><span class="line">                                          seq   : &#123;pac.seq&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>leaderOfInst' = [leaderOfInst EXCEPT ![replica] = @ <span class="tag">\<span class="name">cup</span></span> &#123;i&#125;]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; cmdLog, proposed, executed,</span><br><span class="line">                                                crtInst, committed, ballots &gt;&gt;</span><br><span class="line">                        <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> p1, p2 <span class="tag">\<span class="name">in</span></span> preaccepts : p1.cmd # p2.cmd <span class="tag">\<span class="name">/</span></span> </span><br><span class="line">                                                             p1.deps # p2.deps <span class="tag">\<span class="name">/</span></span></span><br><span class="line">                                                             p1.seq # p2.seq</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> <span class="tag">\<span class="name">E</span></span> pl <span class="tag">\<span class="name">in</span></span> preaccepts : pl.src = i[1]</span><br><span class="line">                               <span class="tag">\<span class="name">/</span></span> Cardinality(preaccepts) &lt; Cardinality(Q) <span class="tag">\<span class="name">div</span></span> 2</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>preaccepts # &#123;&#125;</span><br><span class="line">                            /<span class="tag">\<span class="name"> </span></span>LET pac == CHOOSE pac <span class="tag">\<span class="name">in</span></span> preaccepts : pac.cmd # none IN</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>StartPhase1(pac.cmd, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                                /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;)</span><br><span class="line">                <span class="tag">\<span class="name">/</span></span>  /<span class="tag">\<span class="name"> </span></span><span class="tag">\<span class="name">A</span></span> msg <span class="tag">\<span class="name">in</span></span> replies : msg.status = "not-seen"</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>StartPhase1(none, replica, Q, i, rec.ballot, replies)</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>preparing' = [preparing EXCEPT ![replica] = @ <span class="tag">\<span class="name"> </span><span class="string">&#123;i&#125;</span></span>]</span><br><span class="line">                    /<span class="tag">\<span class="name"> </span></span>UNCHANGED &lt;&lt; proposed, executed, crtInst, committed, ballots &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="ReplyTryPreaccept"><a href="#ReplyTryPreaccept" class="headerlink" title="ReplyTryPreaccept"></a>ReplyTryPreaccept</h3><p>找到发给自己的”try-pre-accept”的请求tpa，首先找到自己日志中所有Instance等于tpa.inst的条目oldRec，进行校验：</p><ol><li>tpa的ballot number要大于等于所有oldRec中的ballot number</li><li>所有oldRec中的状态不能是{“accepted”, “committed”, “executed”}</li></ol><p>然后进行讨论：</p><ol><li>如果在oldRec之外，存在某个rec，和tpa是冲突的<br> 如果tpa.inst不属于rec.deps，并且要么rec.inst不属于tpa.deps，要么rec.seq大于tpa.seq。那么rec和tpa是冲突的。<br> 如果存在冲突的话，则执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply消息。<br> 此时，status为rec.status。</li><li>cmdLog<br> 不做改动，可以认为是拒绝了这个消息。</li></ol></li><li>如果对于oldRec之外的的所有rec，都和tpa不冲突<br> 执行状态转换：<ol><li>sentMsg<br> 消费掉tpa消息，并且回复”try-pre-accept-reply”消息。<br> 注意，status的值是”OK”，这个和冲突情况不一样。【Q】如果此时status的值为”pre-accepted”，那么在FinalizeTryPreAccept中，这条日志仍有被提交的希望？</li><li>cmdLog<br> 删除所有的oldRec，也就是自己日志中所有有关Instance的日志。<br> 新增一条”pre-accepted”日志，这就相当于走完了StartPhase1。</li></ol></li></ol><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReplyTryPreaccept</span>(replica) ==</span><br><span class="line">    \<span class="type">E</span> tpa \<span class="keyword">in</span> sentMsg :</span><br><span class="line">        /\ tpa.<span class="class"><span class="keyword">type</span> = "try-pre-accept" </span></span><br><span class="line">        /\ tpa.dst = replica</span><br><span class="line">        /\ <span class="type">LET</span> oldRec == &#123;<span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] : <span class="keyword">rec</span>.inst = tpa.inst&#125; <span class="type">IN</span></span><br><span class="line">            /\ \<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> oldRec : <span class="keyword">rec</span>.ballot[<span class="number">1</span>] &lt;= tpa.ballot[<span class="number">1</span>] /\ </span><br><span class="line">                                   <span class="keyword">rec</span>.status \notin &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">            /\ \/ (\<span class="type">E</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec:</span><br><span class="line">                        /\ tpa.inst \notin <span class="keyword">rec</span>.deps</span><br><span class="line">                        /\ \/ <span class="keyword">rec</span>.inst \notin tpa.deps</span><br><span class="line">                           \/ <span class="keyword">rec</span>.seq &gt;= tpa.seq</span><br><span class="line">                        /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="keyword">rec</span>.status]&#125;)</span><br><span class="line">                        /\ <span class="type">UNCHANGED</span> &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                        ballots, leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               \/ /\ (\<span class="type">A</span> <span class="keyword">rec</span> \<span class="keyword">in</span> cmdLog[replica] \ oldRec: </span><br><span class="line">                            tpa.inst \<span class="keyword">in</span> <span class="keyword">rec</span>.deps \/ (<span class="keyword">rec</span>.inst \<span class="keyword">in</span> tpa.deps /\</span><br><span class="line">                                                      <span class="keyword">rec</span>.seq &lt; tpa.seq))</span><br><span class="line">                  /\ sentMsg' = (sentMsg \ &#123;tpa&#125;) \cup</span><br><span class="line">                                    &#123;[<span class="class"><span class="keyword">type</span>  |-&gt; "try-pre-accept-reply",</span></span><br><span class="line">                                      src   |-&gt; replica,</span><br><span class="line">                                      dst   |-&gt; tpa.src,</span><br><span class="line">                                      inst  |-&gt; tpa.inst,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      status|-&gt; <span class="string">"OK"</span>]&#125;</span><br><span class="line">                  /\ cmdLog' = [cmdLog <span class="type">EXCEPT</span> ![replica] = (@ \ oldRec) \cup</span><br><span class="line">                                    &#123;[inst  |-&gt; tpa.inst,</span><br><span class="line">                                      status|-&gt; <span class="string">"pre-accepted"</span>,</span><br><span class="line">                                      ballot|-&gt; tpa.ballot,</span><br><span class="line">                                      cmd   |-&gt; tpa.cmd,</span><br><span class="line">                                      deps  |-&gt; tpa.deps,</span><br><span class="line">                                      seq   |-&gt; tpa.seq]&#125;]</span><br><span class="line">                  /\ <span class="type">UNCHANGED</span> &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h3 id="FinalizeTryPreAccept"><a href="#FinalizeTryPreAccept" class="headerlink" title="FinalizeTryPreAccept"></a>FinalizeTryPreAccept</h3><p>选出自己Instance为i的日志rec，在所有”try-pre-accept-reply”回复中，取出Instance为i且ballot为rec.ballot的回复，构成集合tprs。<br>那么对于Q中的任意一个r，tprs中肯定有一条消息是从r中发出的。也就是说必须得Q中每一个Replica都回复了”try-pre-accept-reply”，这个也是老生常谈的条件。</p><p>下面是三种情况的讨论：</p><ol><li><code>\A tpr \in tprs: tpr.status = &quot;OK&quot;</code><br> 这说明在ReplyTryPreaccept中，大家都没冲突。这个类似于PrepareFinalize中的accept流程，也就是论文中所谓的Paxos-Accept phase。执行状态转换：<ol><li>sentMsg<br> 直接发送”accept”消息给Q，后面就是走Phase2Reply的流程。</li><li>cmdLog<br> 设置status为”accepted”</li></ol></li><li>如果在tpr中存在某个status为{“accepted”, “committed”, “executed”}的消息<br> 走StartPhase1</li><li>如果tpr.status不全是”OK”，也有”pre-accepted”<br> 这里应该是冲突了，所以直接干掉。</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">FinalizeTryPreAccept(cleader, i, Q) ==</span><br><span class="line">    <span class="string">\E</span> rec <span class="string">\in</span> cmdLog[cleader]:</span><br><span class="line">        /<span class="string">\</span> rec.inst = i</span><br><span class="line">        <span class="regexp">/\ LET tprs == &#123;msg \in sentMsg : msg.type = "try-pre-accept-reply" /</span><span class="string">\</span></span><br><span class="line">                            msg.dst = cleader <span class="regexp">/\ msg.inst = i /</span><span class="string">\</span></span><br><span class="line">                            msg.ballot = rec.ballot&#125; IN</span><br><span class="line">            /<span class="string">\</span> <span class="string">\A</span> r <span class="string">\in</span> Q: <span class="string">\E</span> tpr <span class="string">\in</span> tprs : tpr.src = r</span><br><span class="line">            <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"OK"</span></span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = (sentMsg \ tprs) \cup</span></span><br><span class="line"><span class="string">                             [type  : &#123;"accept"&#125;,</span></span><br><span class="line"><span class="string">                              src   : &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              dst   : Q \ &#123;cleader&#125;,</span></span><br><span class="line"><span class="string">                              inst  : &#123;i&#125;,</span></span><br><span class="line"><span class="string">                              ballot: &#123;rec.ballot&#125;,</span></span><br><span class="line"><span class="string">                              cmd   : &#123;rec.cmd&#125;,</span></span><br><span class="line"><span class="string">                              deps  : &#123;rec.deps&#125;,</span></span><br><span class="line"><span class="string">                              seq   : &#123;rec.seq&#125;]</span></span><br><span class="line"><span class="string">                  /\ cmdLog'</span> = [cmdLog EXCEPT ![cleader] = (@ <span class="string">\</span> &#123;rec&#125;) <span class="string">\cup</span></span><br><span class="line">                            &#123;[inst  |<span class="function">-&gt;</span> i,</span><br><span class="line">                              status|<span class="function">-&gt;</span> <span class="string">"accepted"</span>,</span><br><span class="line">                              ballot|<span class="function">-&gt;</span> rec.ballot,</span><br><span class="line">                              cmd   |<span class="function">-&gt;</span> rec.cmd,</span><br><span class="line">                              deps  |<span class="function">-&gt;</span> rec.deps,</span><br><span class="line">                              seq   |<span class="function">-&gt;</span> rec.seq]&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"accepted"</span>, <span class="string">"committed"</span>, <span class="string">"executed"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> StartPhase1(rec.cmd, cleader, Q, i, rec.ballot, tprs)</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; proposed, executed, committed, crtInst, ballots,</span><br><span class="line">                                  leaderOfInst, preparing &gt;&gt;</span><br><span class="line">               <span class="string">\/</span> /<span class="string">\</span> <span class="string">\E</span> tpr <span class="string">\in</span> tprs: tpr.status = <span class="string">"pre-accepted"</span></span><br><span class="line">                  /<span class="string">\</span> <span class="string">\A</span> tpr <span class="string">\in</span> tprs: tpr.status <span class="string">\in</span> &#123;<span class="string">"OK"</span>, <span class="string">"pre-accepted"</span>&#125;</span><br><span class="line">                  /<span class="string">\</span> sentMsg<span class="string">' = sentMsg \ tprs</span></span><br><span class="line"><span class="string">                  /\ leaderOfInst'</span> = [leaderOfInst EXCEPT ![cleader] = @ <span class="string">\</span> &#123;i&#125;]</span><br><span class="line">                  /<span class="string">\</span> UNCHANGED &lt;&lt; cmdLog, proposed, executed, committed, crtInst,</span><br><span class="line">                                  ballots, preparing &gt;&gt;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li>There Is More Consensus in Egalitarian Parliaments</li><li>EPaxos Revisited</li><li><a href="https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla" target="_blank" rel="noopener">https://github.com/efficient/epaxos/blob/master/tla%2B/EgalitarianPaxos.tla</a><br> 一份TLA+的说明</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单介绍EPaxos算法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="一致性" scheme="http://www.calvinneo.com/tags/一致性/"/>
    
    <category term="paxos" scheme="http://www.calvinneo.com/tags/paxos/"/>
    
    <category term="epaxos" scheme="http://www.calvinneo.com/tags/epaxos/"/>
    
  </entry>
  
</feed>
