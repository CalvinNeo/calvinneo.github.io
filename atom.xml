<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2024-01-14T16:23:13.856Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Performance analysis and tuning on modern CPUs 学习笔记</title>
    <link href="http://www.calvinneo.com/2023/12/17/patmc/"/>
    <id>http://www.calvinneo.com/2023/12/17/patmc/</id>
    <published>2023-12-17T02:57:32.000Z</published>
    <updated>2024-01-14T16:23:13.856Z</updated>
    
    <content type="html"><![CDATA[<p>According to 老板，according to yifan，这本书很好，所以我就来学习一下了。</p><a id="more"></a><h1 id="Part-1-的说明"><a href="#Part-1-的说明" class="headerlink" title="Part 1 的说明"></a>Part 1 的说明</h1><h1 id="Measuring-Performance"><a href="#Measuring-Performance" class="headerlink" title="Measuring Performance"></a>Measuring Performance</h1><p>Changing a seemingly unrelated part of the source code can surprise us with a significant impact on program performance. This phenomenon is called measurement bias. … Instead, we will just focus on high-level ideas and directions to follow.</p><p>This chapter will give a brief introduction to why modern systems yield noisy performance measurements and what you can do about it.</p><h2 id="Noise-In-Modern-Systems"><a href="#Noise-In-Modern-Systems" class="headerlink" title="Noise In Modern Systems"></a>Noise In Modern Systems</h2><p>一种叫 Dynamic Frequency Scaling 的技术可以短时间内提升 CPU 的频率，但它是基于核心温度的，所以不确定。在散热不太好的笔记本上经常发生第一个 run 会 turbo，但第二个 run 回归到 base frequency 的情况。</p><p>软件层面的因素，包括 file cache 是否 warm。有论文说，env var 的大小，以及 link 的顺序都能影响性能。影响内存布局也可以影响性能，有研究说 efficiently and repeatedly randomizing the placement of code, stack, and heap objects at runtime 可以解决处理内存布局带来的问题。</p><p>如果 benchmark 一个云处理器环境，上述的 noise 和 variation 基本难以被消除。</p><p>temci 这个工具能够设置环境，从而确保一个 low variance。</p><h2 id="Measuring-Performance-In-Production"><a href="#Measuring-Performance-In-Production" class="headerlink" title="Measuring Performance In Production"></a>Measuring Performance In Production</h2><h1 id="CPU-Microarchitecture"><a href="#CPU-Microarchitecture" class="headerlink" title="CPU Microarchitecture"></a>CPU Microarchitecture</h1><h2 id="Instruction-Set-Architecture"><a href="#Instruction-Set-Architecture" class="headerlink" title="Instruction Set Architecture"></a>Instruction Set Architecture</h2><p>the critical CPU architecture and microarchitecture features that impact performance</p><p>In addition to providing the basic functions in the ISA such as<br>load, store, control, scalar arithmetic operations using integers and floating-point, the widely deployed architectures continue to enhance their ISA to support new computing paradigms. These include enhanced vector processing instructions (e.g., Intel AVX2, AVX512, ARM SVE) and matrix/tensor instructions (Intel AMX). Software mapped to use these advanced instructions typically provide orders of magnitude improvement in performance.</p><p>深度学习中，即使使用较少的 bits 效果也挺好，所以一些处理器倾向于引入 8bit integer 等来节约计算和内存带宽。</p><h2 id="Pipelining"><a href="#Pipelining" class="headerlink" title="Pipelining"></a>Pipelining</h2><p>The processing of instructions is divided into stages. The stages operate in parallel, working on different parts of different instructions.</p><p>在 CSAPP 里面已经学习了取指、解码、执行、访存、写回的流水线。</p><p>The throughput of a pipelined CPU is defined as the number of instructions that complete and exit the pipeline per unit of time.</p><p>The latency for any given instruction is the total time through all the stages of the pipeline.</p><p>The time required to move an instruction from one stage to the other defines the basic machine cycle or clock for the CPU. The value chosen for the clock for a given pipeline is defined by the <strong>slowest stage</strong> of the pipeline. 因此这里的优化点是均衡或者重新设计 pipeline，消除最慢的 stage 的 bottleneck。</p><p>假定所有的 stage 都是完美 balanced，没有任何 stall，那么通过 pipeline，可以让一个指令的处理时间减少到原来的 n_stage 分之一。</p><p>下面提到三种冒险，其中 Structural hazard 指的是对硬件资源的争抢，通常通过复制硬件解决。剩下两种在 CSAPP 中详细介绍过了，本教程做了归纳。<br>数据冒险是程序中的数据依赖，分三类：</p><ol><li><p>Read after write<br> x 的写结束前，x + 1 就需要读到 x 的写的内容，不然 x + 1 会读到更旧的数据。通常使用 bypassing 的办法，将数据从流水线的后面(指令 x + 1 的阶段) forward 到前面(指令 x 的阶段)。</p></li><li><p>Write after read<br> x 在读完之后，x + 1 才能写，不然 x 会读到更新的数据。译码阶段总是在写回阶段前面，为什么会有 WAR 场景？原因是需要考虑处理器乱序执行。如下所示，R0 上存在 WAR 场景。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R1 = R0 ADD 1</span><br><span class="line">R0 = R2 ADD 2</span><br></pre></td></tr></table></figure><p> WAR 可以被 register renaming 解决。 Logical (architectural) registers, the ones that are defined by the ISA, are just aliases over a wider register file。因此，只需要将第二个 R0，以及之后的所有的 R0 重命名到另一个寄存器文件上即可解决问题。因此这两个指令之间就可以被乱序执行了。<br> 【Q】这些 physical register file 如何被 gc 呢？旧的 R0 alias 不知道新的 R0 alias 的存在啊。看 CPU backend 的介绍时发现，这个是 ROB 做的。</p></li><li><p>Write after write<br> 同样可以通过 register renaming 解决。</p></li></ol><p>控制冒险主要指分支预测之类的东西，影响取指阶段。诸如动态分支预测、 speculative execution 能优化。</p><h2 id="Exploiting-Instruction-Level-Parallelism-ILP"><a href="#Exploiting-Instruction-Level-Parallelism-ILP" class="headerlink" title="Exploiting Instruction Level Parallelism (ILP)"></a>Exploiting Instruction Level Parallelism (ILP)</h2><p>大多数的指令可以被并行执行，因为它们是不相关的。</p><h3 id="OOO-Execution"><a href="#OOO-Execution" class="headerlink" title="OOO Execution"></a>OOO Execution</h3><p>An instruction is called retired when it is finally executed, and its results are correct and visible in the <a href="https://en.wikipedia.org/wiki/Architectural_state" target="_blank" rel="noopener">architectural state</a>. To ensure correctness, CPUs must retire all instructions in the program order. 这里 architectural state 主要区分于 microarchitectural state，后者是隐藏的 state，例如 pipeline registers、cache tag、branch predictor 等。</p><p>OOO is primarily used to avoid underutilization of CPU resources due to stalls caused by dependencies, especially in superscalar engines described in the next section.</p><p>scoreboard 被用来 schedule the in-order retirement and all machine state updates。它需要记录每一条指令的数据依赖 and where in the pipe the data is available。scoreboard 的大小决定了 CPU 能够超前多少调度彼此无关的指令。</p><p>下图中，x + 1 因为一些冲突，插入了一些气泡。而 OOO 的执行可以使 x + 2 这个 independent 的指令先进入执行(EXE)阶段。但是所有的指令还是要 按照 program order 来 retire，也就是最后的写回阶段是要按顺序的。<br><img src="/img/patmc/3.8.png"></p><h3 id="Superscalar-Engines-and-VLIW"><a href="#Superscalar-Engines-and-VLIW" class="headerlink" title="Superscalar Engines and VLIW"></a>Superscalar Engines and VLIW</h3><p>Most modern CPUs are superscalar i.e., they can issue more than one instruction in a given cycle. Issue-width is the maximum number of instructions that can be issued during the same cycle.</p><p>目前处理器的 issue width 在 2 到 6 之间。为了处理这些 instruction，目前 CPU 也会支持 more than one execution unit and/or pipelined execution units。Superscalar 也可以和之前提到的 pipeline 和 OOO 结合起来用。</p><p>下图展示了 issue width = 2 的情况。 Superscalar CPU 中支持多个 independent execution units 能够执行指令，而避免冲突。<br><img src="/img/patmc/3.9.png"></p><p>Intel 使用 VLIW，即 Very Long Instruction Word 技术将调度 Superscalar 和 multi execution unit 的负担转移给编译器。这是因为 software pipelining, loop unrolling 这些编译器优化相比硬件能看到的更多。</p><h3 id="Speculative-Execution"><a href="#Speculative-Execution" class="headerlink" title="Speculative Execution"></a>Speculative Execution</h3><p>下面介绍了 Speculative Execution 是什么，不翻译了。</p><blockquote><p>As noted in the previous section, control hazards can cause significant performance loss in a pipeline if instructions are stalled until the branch condition is resolved. One technique to avoid this performance loss is hardware branch prediction logic to predict the likely direction of branches and allow executing instructions from the predicted path (speculative execution).</p></blockquote><p>如下所示，Speculative Execution 不会等 branch 预测结果，而是直接执行 foo，如打星号所示，但是实际的状态变化直到 condition 被 resolve 之后才会被 commit，这样才能保证 architecture state 不会被 speculative executing 影响。</p><p><img src="/img/patmc/3.10.png"></p><p>在现实中，branch 命令可能依赖从内存中加载上来的某个值，这可能需要花费上百个 cycle。如果分支预测的是不正确的，也就是实际应该调用 bar 了，那么 speculative 执行的结果需要被扔掉，称为 branch misprediction penalty。</p><p>为了记录 speculation 的进度，CPU 支持一个叫 ReOrder Buffer 即 ROB 的结构。ROB 中依照顺序了所有指令，包括已经 retire 的指令的状态。如果 speculation 是正确的华，speculative execution 的结果按照 program order 会写到 ROB 里面，然后被 commit 到 architecture register 中。</p><p>CPUs can also combine speculative execution with out-of-order execution and use the ROB to track both speculation and out-of-order execution.</p><h2 id="Exploiting-Thread-Level-Parallelism"><a href="#Exploiting-Thread-Level-Parallelism" class="headerlink" title="Exploiting Thread Level Parallelism"></a>Exploiting Thread Level Parallelism</h2><p>A hardware multi-threaded CPU supports dedicated hardware resources to track the state (aka context) of each thread independently.<br>The main motivation for such a multi-threaded CPU is to switch from one context to another with the smallest latency (without incurring the cost of saving and restoring thread context) when a thread is blocked due to a long latency activity such as memory references</p><h3 id="Simultaneous-Multithreading"><a href="#Simultaneous-Multithreading" class="headerlink" title="Simultaneous Multithreading"></a>Simultaneous Multithreading</h3><p>ILP techniques and multi-threading 被结合使用。不同线程中的指令在同一个 cycle 中被并发地执行。同时从多个线程中 dispatch 指令可以充分利用 superscalar 资源，提高 CPU 总体性能。为了支持 SMT，CPU 需要复制硬件去存储 thread state，例如 PC 和寄存器等。追踪 OOO 和 speculative execution 的资源可以复制，也可以共享。一些 Cache 被 hardware 线程共享。</p><h2 id="Memory-Hierarchy"><a href="#Memory-Hierarchy" class="headerlink" title="Memory Hierarchy"></a>Memory Hierarchy</h2><p>Memory Hierarchy 从下面两种性质构造：</p><ol><li>Temporal locality</li><li>Spatial locality</li></ol><p>CSAPP 中进行了更为详细的讨论。</p><h3 id="Cache-Hierarchy"><a href="#Cache-Hierarchy" class="headerlink" title="Cache Hierarchy"></a>Cache Hierarchy</h3><p>A particular level of the cache hierarchy can be used exclusively for code (instruction cache, i-cache) or for data (data cache, d-cache), or shared between code and data (unified cache).</p><h4 id="Placement-of-data-within-the-cache"><a href="#Placement-of-data-within-the-cache" class="headerlink" title="Placement of data within the cache"></a>Placement of data within the cache</h4><h4 id="Finding-data-in-the-cache"><a href="#Finding-data-in-the-cache" class="headerlink" title="Finding data in the cache"></a>Finding data in the cache</h4><h4 id="Managing-misses"><a href="#Managing-misses" class="headerlink" title="Managing misses"></a>Managing misses</h4><p>对 direct-mapped 来讲，它会 evict 掉之前的 block。<br>对 set-associative 来讲，需要一个例如 LRU cache 的算法。</p><h4 id="Managing-writes"><a href="#Managing-writes" class="headerlink" title="Managing writes"></a>Managing writes</h4><p>CPU designs use two basic mechanisms to handle writes that hit in the cache:</p><ol><li>In a write-through cache<br> hit data is written to both the block in the cache and to the next lower level of the hierarchy</li><li>In a write-back cache<br> hit data is only written to the cache.<br> Subsequently, lower levels of the hierarchy contain stale data.<br> The state of the modified line is tracked through a dirty bit in the tag. When a modified cache line is eventually evicted from the cache, a write-back operation forces the data to be written back to the next lower level.</li></ol><p>Cache misses on write operations can be handled using two different options:</p><ol><li>write-allocate or fetch on write miss cache<br> 数据会被从下一级缓存中被加载上来，并且当前 write operation 会被视作一次 write hit。</li><li>no-write-allocate policy<br> cache miss 会直接被发送到下一级缓存，并且该缓存不会被加载到当前缓存。</li></ol><p>Out of these options, most designs typically choose to implement a write-back cache with a write-allocate policy as both of these techniques try to convert subsequent write transactions into cache-hits, without additional traffic to the lower levels of the hierarchy.</p><p>Write through caches typically use the no-write-allocate policy.</p><h4 id="Other-cache-optimization-techniques"><a href="#Other-cache-optimization-techniques" class="headerlink" title="Other cache optimization techniques"></a>Other cache optimization techniques</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Average Access Latency = Hit Time + Miss Rate × Miss Penalty</span><br></pre></td></tr></table></figure><p>硬件工程师们努力减少 Hit Time，以及 Miss Penalty。而 Miss Rate 取决于 block size 和 associativity，以及软件。</p><h4 id="HW-and-SW-Prefetching"><a href="#HW-and-SW-Prefetching" class="headerlink" title="HW and SW Prefetching"></a>HW and SW Prefetching</h4><p>Prefetch 指令和数据可以减少 cache miss 和后续的 stall 的发生。</p><p>Hardware prefetchers observe the behavior of a running application and initiate prefetching on repetitive patterns of cache misses. Hardware prefetching can automatically adapt to the dynamic behavior of the application, such as varying data sets, and does not require support from an optimizing compiler or profiling support. Also, the hardware prefetching works without the overhead of additional address-generation and prefetch instructions. 当然，hardware prefetching 只限于某几种 cache miss pattern。</p><p>Software memory prefetching 中，开发者可制定一些内存位置，或者让编译器自行添加一些 prefetch 指令。</p><h3 id="Main-memory"><a href="#Main-memory" class="headerlink" title="Main memory"></a>Main memory</h3><p>Main memory uses DRAM (dynamic RAM) technology that supports large capacities at reasonable cost points.</p><p>主存被三个属性描述，latency、bandwidth 和 capacity。</p><p>Latency 主要是两个指标，Memory access time 是从请求，到数据 available 的时间。Memory cycle time 是两个连续的访存操作之间最小的时间间隔。</p><p>DDR (double data rate) DRAM 是主要的 DRAM 技术。历史上，DRAM bandwidth 每一代都会被提高，但是 DRAM 的 latency 原地踏步，甚至会更高。下面的表中展示了最近三代的 DDR 技术的相关数据。MT/s 指的是 a million transfers per sec。</p><p><img src="/img/patmc/t2.png"></p><h2 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h2><p>Virtual Memory 实现多个程序共享一个内存。具有特性：</p><ol><li>protection<br> 也就是不能访问其他进程的内存</li><li>relocation<br> 也就是不改变逻辑地址，但是将程序加载到任意的物理地址</li></ol><p>vitual 地址和物理地址通过 page table 进行转换。vitual 地址分为两部分。virtual page number 用来索引具体的 page table，这个 page table 可能是一层，也有可能嵌套了很多层。page offset 用来 access the physical memory location at the same offset in the mapped physical page。<br>如果需要的 page 不在主存里面，就会发生 page fault。操作系统负责告诉硬件去处理 page fault，这样一个 LRU 的 page 会被 evict 掉，腾出空间给新 page。</p><p>CPUs typically use a hierarchical page table format to map virtual address bits efficiently to<br>the available physical memory. CPU 会使用一个有层级的 page table 去维护 virtual address 和 physical memory 的关系。但 page fault 的惩罚是很大的，需要从 hierarchy 中 traverse 查找。所以 CPU 支持一个硬件结构 translation lookaside buffer (TLB) 来保存最近的地址翻译结果。</p><p><img src="/img/patmc/3.12.png"></p><h2 id="SIMD-Multiprocessors"><a href="#SIMD-Multiprocessors" class="headerlink" title="SIMD Multiprocessors"></a>SIMD Multiprocessors</h2><p>SIMD (Single Instruction, Multiple Data) multiprocessors 是相对于之前的 MIMD 来说的。SIMD 会在一个 cycle 中将一条指令运用于多个数据上，从而利用多个 functional units。</p><p>下图是 SISD 和 SIMD 的对比。<br><img src="/img/patmc/3.13.png"></p><h2 id="Modern-CPU-design"><a href="#Modern-CPU-design" class="headerlink" title="Modern CPU design"></a>Modern CPU design</h2><p>下图是 Skylake(2015) 的架构。 The Skylake core is split into an in-order front-end that fetches and decodes x86 instructions into u-ops and an 8-way superscalar, out-of-order backend.</p><p>The core supports 2-way SMT. It has a 32KB, 8-way first-level instruction cache (L1 I-cache), and a 32KB, 8-way first-level data cache (L1 D-cache). The L1 caches are backed up by a unified 1MB second-level cache, the L2 cache. The L1 and L2 caches are private to each core.</p><p><img src="/img/patmc/3.14.png"></p><h3 id="CPU-Front-End"><a href="#CPU-Front-End" class="headerlink" title="CPU Front-End"></a>CPU Front-End</h3><p>前端负责 fetch and decode instructions from memory，将准备好的指令喂给后端执行。</p><p>每一个 cycle，前端从 L1 I-cache 中取 16 bytes 的指令。它们被两个线程分享，所以实际上是第一个周期线程 A 取，第二个周期线程 B 取，然后又是线程 A 这样。这些指令是复杂的可变长度的指令，pipeline 的 pre-decode 和 decode 阶段将它们分成 micro Ops(UOPs)，并且把它们排在 Allocation Queue (IDQ) 队列中。</p><p>pre-decode 主要标记指令的边界。指令的长度从 1 到 15 bytes 不等。这个阶段还 identifies branch instructions。这个阶段移动最多 6 条指令，或者称为 Macro Instructions 到 instruction queue 中。instruction queue is split between the two threads. instruction queue 中有个 macro-op fusion unit，可以检测两个 macroinstructions 是否可以 fuse 为一个指令、</p><p>一个周期中，最多5个被 pre-decode 完毕的指令会被发送到 instruction queue，同样是两个线程轮流分享这个接口。Decoder 将复杂的 macro-Op 转化为固定长度的 UOP，也就是上文提到的 micro Op。Decoder 是 5-way 的。</p><p>前端主要的性能提升组件是 Decoded Stream Buffer (DSB)，或者称为 UOP Cache。它的目的是将 macro Op 到 UOP 的转换保存在单独的 DSB 结构中。在取指阶段，会先在 DSB 查询。频繁执行的 macro op 会命中 DSB，pipeline 就能够避免昂贵的 pre-decode 和 decode 环节。</p><p>DSB 提供 6 个 UOP，这个和前端到后端的接口匹配。DSB 和 BPU 也就是 branch prediction unit 协同工作。</p><p>一些非常复杂的指令需要超过 decoder 能够处理的 UOP，它们就会被送给 Microcode Sequencer (MSROM) 处理。这些命令包含字符串处理、加密、同步等指令。另外，MSROM 也会保存 microcode operation，以便处理分支预测出错（需要刷新 pipeline），或者 floating-point 等异常情况。 </p><p>Instruction Decode Queue (IDQ) 是在 inorder 的前端和 OOO 的后端之间的桥梁。每个 hardware thread 上 IDQ 大小 64 个 UOP，总计大小 128 UOP。</p><h3 id="CPU-Back-End"><a href="#CPU-Back-End" class="headerlink" title="CPU Back-End"></a>CPU Back-End</h3><p>后端是一些 OOO engine，执行指令并且存储结果。<br>后端的心脏是一个 ReOrder Buffer，即 ROB，它有 224 条 entry。它的功能：</p><ol><li>维护 architecture-visible registers 到 physical registers 的映射。这个映射被 Reservation Station/Scheduler (RS) 使用。</li><li>支持 register renaming。</li><li>记录 speculative execution。</li></ol><p>ROB entry 按照 program order retire。</p><p>Reservation Station/Scheduler (RS) 结构记录一个 UOP 所使用的所有资源的 availablility。一旦这些资源满足了，就会将这个 UOP dispatch 到某一个 port。因为 the core（不知道指的是什么）是 8-way superscalar，所以 RS 在一个 cycle 中可以 dispatch 最多 8 个 UOP。如上面图 14 所示，这些 Port 分别支持不同的操作：</p><ul><li>Ports 0, 1, 5, and 6 provide all the integer, FP, and vector ALU. UOPs dispatched to those ports do not require memory operations.</li><li>Ports 2 and 3 are used for address generation and for load operations.</li><li>Port 4 is used for store operations.</li><li>Port 7 is used for address generation.</li></ul><h3 id="Performance-Monitoring-Unit"><a href="#Performance-Monitoring-Unit" class="headerlink" title="Performance Monitoring Unit"></a>Performance Monitoring Unit</h3><h4 id="Performance-Monitoring-Counters"><a href="#Performance-Monitoring-Counters" class="headerlink" title="Performance Monitoring Counters"></a>Performance Monitoring Counters</h4><p>这也就是后面在 Sampling 中提到的 PMC。PMC 会收集 CPU 中各个组件的统计信息。<br><img src="/img/patmc/3.16.png"></p><p>一般来说，PMC 有 48bit 宽，这样可以允许分析工具能够跑更长时间，而不至于被中断触发。这是因为当 PMC overflow 的时候，程序执行会被中断，SW 需要存储 overflow 的情况。在 Sampling 章节也会进一步看到分析工具是如何利用这个特性的。</p><p>PMC 是 HW register，被实现为 Model Specific Register(MSR)。也就是具体有哪些，每种 CPU 是不一样的，并且 width 也不一定是 48bit。</p><h1 id="Terminology-and-metrics-in-performance-analysis"><a href="#Terminology-and-metrics-in-performance-analysis" class="headerlink" title="Terminology and metrics in performance analysis"></a>Terminology and metrics in performance analysis</h1><p>perf 命令或者 Intel VTune Profiler 里面的术语很难懂，本章进行介绍。</p><h2 id="Retired-vs-Executed-Instruction"><a href="#Retired-vs-Executed-Instruction" class="headerlink" title="Retired vs. Executed Instruction"></a>Retired vs. Executed Instruction</h2><ol><li>正常情况，the CPU commits results once they are available, and all precedinginstructions are already retired.</li><li>Speculative 执行，the CPU keeps their results without immediately committing their results. When the speculation turns out to be correct, the CPU unblocks such instructions and proceeds as normal. 如果预测失败，则会丢弃所有的结果，并且不 retire 它们。</li></ol><h2 id="CPU-Utilization"><a href="#CPU-Utilization" class="headerlink" title="CPU Utilization"></a>CPU Utilization</h2><p>CPU 不在跑 idle 线程的时候，即被认为是 utilize 的。</p><h2 id="CPI-amp-IPC"><a href="#CPI-amp-IPC" class="headerlink" title="CPI &amp; IPC"></a>CPI &amp; IPC</h2><p><img src="/img/patmc/cpiipc.png"></p><h2 id="UOPs-micro-ops"><a href="#UOPs-micro-ops" class="headerlink" title="UOPs (micro-ops)"></a>UOPs (micro-ops)</h2><p>Microprocessors with the x86 architecture translate complex CISC-like instructions into simple RISC-like59 microoperations - abbreviated µops or uops. 这里 CISC 指的是 Complex Instruction Set Computer。RISC 指的是 Reduced Instruction Set Computer。</p><p>这个转换的好处在于，UOP 可以被 OOO 地执行。一个简单的加法指令，例如 ADD EXA,EBX 只会产生一个 UOP。而一个复杂的指令，例如 ADD EAX,[MEM1] 可能生成两个 UOP，一个用来读内存到一个临时的，没有名字的寄存器中，另一个指令将这个临时寄存器中的数字加到 EAX 中。同理，ADD [MEM1],EAX 会产生三个 UOP，一个读内存，一个加，一个写内存。不同的 CPU 处理这些指令，比如如何将它们划分为不同的 UOP 的方式，是不一样的。</p><p>除了将复杂的 CISC-like 的指令分解为 RISC-lick 的 UOP 或者说 microoperations 之外，还有一种策略是融合一些指令。有两种融合的类型：</p><ol><li><p>Microfusion<br> 对同一个指令中的多个 UOP 进行 fuse。如下所示，访存操作和加法在 decode 阶段被 fuse 了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Read the memory location [ESI] and add it to EAX</span><br><span class="line"># Two uops are fused into one at the decoding step.</span><br><span class="line">add eax, [esi]</span><br></pre></td></tr></table></figure></li><li><p>Macrofusion<br> 如下所示，一个代数计算和一个条件跳转指令被 fuse 为一个 compute-and-branch UOP 了。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Two uops from DEC and JNZ instructions are fused into one</span><br><span class="line">.loop:</span><br><span class="line">dec rdi</span><br><span class="line">jnz .loop</span><br></pre></td></tr></table></figure></li></ol><p>Both Micro- and Macrofusion save bandwidth in all stages of the pipeline from decoding to retirement. The fused operations share a single entry in the reorder buffer (ROB). The capacity of the ROB is increased when a fused uop uses only one entry。我想这就是为什么要 fuse 指令的原因，因为它们节约了 ROB 的空间。在执行的时候，这个表示两个操作的 ROB entry 会被两个 execution units 处理，被发送到两个不同的 execution ports，但最后作为一个 unit 被 retire。</p><p>Linux perf users can collect the number of issued, executed, and retired uops for their workload by running the following command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ perf stat -e uops_issued.any,uops_executed.thread,uops_retired.all -- a.exe</span><br><span class="line">2856278 uops_issued.any</span><br><span class="line">2720241 uops_executed.thread</span><br><span class="line">2557884 uops_retired.all</span><br></pre></td></tr></table></figure><h2 id="Pipeline-Slot"><a href="#Pipeline-Slot" class="headerlink" title="Pipeline Slot"></a>Pipeline Slot</h2><p>A pipeline slot represents hardware resources needed to process one uop.</p><h2 id="Core-vs-Reference-Cycles"><a href="#Core-vs-Reference-Cycles" class="headerlink" title="Core vs. Reference Cycles"></a>Core vs. Reference Cycles</h2><p>Reference Cycles 是 CPU 计算 cycle 数量，仿佛没有 frequency scaling 一般。相当于不 tuebo，base frequency 下运行的 cycles。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ perf stat -e cycles,ref-cycles ./a.exe</span><br><span class="line">    43340884632 cycles # 3.97 GHz</span><br><span class="line">    37028245322 ref-cycles # 3.39 GHz</span><br><span class="line">    10,899462364 seconds time elapsed</span><br></pre></td></tr></table></figure><p>The core clock cycle counter is very useful when testing which version of a piece of code is fastest because you can avoid the problem that the clock frequency goes up and down.</p><h2 id="Cache-miss"><a href="#Cache-miss" class="headerlink" title="Cache miss"></a>Cache miss</h2><h2 id="Mispredicted-branch"><a href="#Mispredicted-branch" class="headerlink" title="Mispredicted branch"></a>Mispredicted branch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ perf stat -e branches,branch-misses -- a.exe</span><br><span class="line">358209 branches</span><br><span class="line">14026 branch-misses</span><br></pre></td></tr></table></figure><h1 id="Performance-Analysis-Approaches"><a href="#Performance-Analysis-Approaches" class="headerlink" title="Performance Analysis Approaches"></a>Performance Analysis Approaches</h1><h2 id="Code-Instrumentation"><a href="#Code-Instrumentation" class="headerlink" title="Code Instrumentation"></a>Code Instrumentation</h2><p>比如用 printf 调试，打印一个函数执行了多少次这样。这是 macro level 的，而不是 mirco level 的。<br>这个技术的主要用处是，能够快速定位到具体问题的模块。因为性能问题不仅和代码有关，也和数据有关。例如一个场景渲染比较慢，有可能是数据压缩问题，也有可能是场景元素过多。<br>当然，缺点就是只在 app 层级，到不了内核以及更下层。另外，调试代码需要重新编译，会降低性能，甚至改变现场。</p><p>Binary instrumentation 技术的特点：</p><ol><li>对二进制分析</li><li>提供 static 和 dynamic 两种模式<br> dynamic 模式可以动态开启，可以限制只对某些函数调试</li></ol><p>诸如 Intel Pin 的工具可以拦截某个事件，并且在之后插入代码。</p><ol><li>instruction count and function call counts.</li><li>intercepting function calls and execution of any instruction in an application.</li><li>allows “record and replay” the program region by capturing the memory and HW registers state at the beginning of the region.</li></ol><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><p>strace 工具跟踪系统调用，可以被视作对内核的测量。Intel Processor Traces 工具跟踪 CPU 指令，可以被视作对 CPU 的测量。<br>Tracing is often used as the black-box approach, where a user cannot modify the code of the application, yet they want insight on what the program is doing behind the scenes。</p><p>Tracing 用来检查异常。例如一个系统十秒都不响应了，这个时候，Code Instrumentation 可能就不管用，但 tracing 可以去了解到底发生了什么。</p><h2 id="Workload-Characterization"><a href="#Workload-Characterization" class="headerlink" title="Workload Characterization"></a>Workload Characterization</h2><p>Workload characterization is a process of describing a workload by means of quantitative parameters and functions。</p><h3 id="Counting-Performance-Events"><a href="#Counting-Performance-Events" class="headerlink" title="Counting Performance Events"></a>Counting Performance Events</h3><p>用一个 Counter 记录在跑一个 workload 时，某个事件在一段时间内发生的次数。</p><h3 id="Manual-performance-counters-collection"><a href="#Manual-performance-counters-collection" class="headerlink" title="Manual performance counters collection"></a>Manual performance counters collection</h3><p>一般来说，不建议直接观察 PMC，而是使用 Intel Vtune Profiler 去看一个处理后的结果。</p><p>可以通过 perf list 查看可以访问的 PMC。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ perf list</span><br><span class="line">branches [Hardware event]</span><br><span class="line">branch-misses [Hardware event]</span><br><span class="line">bus-cycles [Hardware event]</span><br><span class="line">cache-misses [Hardware event]</span><br><span class="line">cycles [Hardware event]</span><br><span class="line">instructions [Hardware event]</span><br><span class="line">ref-cycles [Hardware event]</span><br></pre></td></tr></table></figure><p>对于没列出的，可以使用下面的来检查</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">perf stat -e cpu/event=0xc4,umask=0x0,name=BR_INST_RETIRED.ALL_BRANCHES/</span><br><span class="line">-- ./a.exe</span><br></pre></td></tr></table></figure><h3 id="Multiplexing-and-scaling-events"><a href="#Multiplexing-and-scaling-events" class="headerlink" title="Multiplexing and scaling events"></a>Multiplexing and scaling events</h3><p>考虑到有时候需要同时记录多个事件，但只有一个 counter。所以 PMU 会为每个 HW 线程提供四个 counter。但可能还是不够。<br>Top-Down Analysis Methodology (TMA) 需要一次执行过程中收集最多 100 个不同的 performance event。<br>这个时候，就引入了 multiplexing 技术，如下图所示。<br><img src="/img/patmc/5.19.png"></p><h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><p>人们常常用 profiling 这个词去指代 sampling，但其实 profiling 这个词包含的范围更广。</p><h3 id="User-Mode-And-Hardware-Event-based-Sampling"><a href="#User-Mode-And-Hardware-Event-based-Sampling" class="headerlink" title="User-Mode And Hardware Event-based Sampling"></a>User-Mode And Hardware Event-based Sampling</h3><p>User-mode sampling 是个 SW 方案，也就是在用户程序中 embed 一个库。这个库会为每个线程设置 OS timer，在 timer 超时的时候，程序会收到 SIGPROF 信号。<br>EBS 是一个 HW 方案，它使用 PMC 去触发中断。</p><p>SW 方案只能被用来发现热点。而 HW 方案还可以被用来采样 cache miss，TMA(section 6.1) 等。</p><p>SW 方案的 overhead 更大。HW 方案更准确，因为允许采样更多的数据。</p><h3 id="Finding-Hotspots"><a href="#Finding-Hotspots" class="headerlink" title="Finding Hotspots"></a>Finding Hotspots</h3><p>下面的一个技术使用了 counter overflow 技术。也就是当 counter 溢出的时候，触发 performance monitoring interrupt(PMI)。<br><img src="/img/patmc/5.25.png"></p><p>我们不一定要 sample CPU cycle，例如如果要检查程序中哪里出现了最多的 L3 cache miss，就可以 sample <code>MEM_LOAD_RETIRED.L3_MISS</code> 这个事件。</p><p>流程如下：</p><ol><li>配置 PMC 去计算某项指标，例如 cycle 数</li><li>在执行过程中，PMC 会递增</li><li>PMC 最终会 overflow，HW 会触发 PMI</li><li>Profile 工具会抓住中断，并使用配置了的 Interrupt Service Routine(ISR) 去处理这个事件<ul><li>禁止掉 counting</li><li>reset counter 到 N</li><li>继续 benchmark 过程</li></ul></li></ol><p>通过 N 的不同取值，可以决定采样的频率。</p><h3 id="Collecting-Call-Stacks"><a href="#Collecting-Call-Stacks" class="headerlink" title="Collecting Call Stacks"></a>Collecting Call Stacks</h3><p>常见情况是，最热点的函数是被多个 caller 调用的。这个时候就需要知道是 Control Flow Graph (CFG) 里面的哪一条路径导致的。想要去追踪 foo 的所有 caller 是很耗时的，但我们只是想最终那些导致 foo 变成 hotspot 的，或者说是想找到 CFG 中经过 foo 的最热的路径。</p><p>下面三种方法：</p><ol><li>Frame pointer<br> perf record –call-graph fp<br> 这需要二进制被以 -fnoomit-frame-pointer 形式编译。历史上，Frame pointer 也就是 BP 寄存器被用来 debug，是因为它允许 get the call stack without popping all the arguments from the stack(stack unwinding)。Frame pointer 可以直接告诉我们 return address。</li><li>DWARF debug info<br> perf record –call-graph dwarf<br> 这需要程序被按照 -g (-gline-tables-only) 形式编译。</li><li>Intel Last Branch Record (LBR)<br> perf record –call-graph lbr<br> 这种方式得到的 call graph 的深度不如前面两者。</li></ol><h3 id="Flame-graph"><a href="#Flame-graph" class="headerlink" title="Flame graph"></a>Flame graph</h3><p>相比上面提到的，一个更流行的办法是火焰图。</p><h2 id="Roofline-Performance-Model"><a href="#Roofline-Performance-Model" class="headerlink" title="Roofline Performance Model"></a>Roofline Performance Model</h2><p>这里的 roofline 指的是应用程序的性能不会超过机器本身的容量。每个函数或者每个循环都会被机器本身的计算或者内存容量所限制。</p><p>HW 有两方面限制：</p><ol><li>它可以算多快<br> FLOPS</li><li>它可以多快传输数据<br> GB/s</li></ol><p>一个程序的不同部分，会有不同的 performance characteristics。<br><img src="/img/patmc/5.24.png"></p><p>Arithmetic Intensity (AI) is a ratio between FLOPS and bytes and can be extracted for every loop in a program。不妨对下面的代码来算一下。在最内层循环有一个加法和一个乘法，所以是 2FLOPS。另外，还有三个读操作和一个写操作，所以传输了 <code>4 * 4 = 16</code> 字节。所以 AI 是 <code>2 / 16 = 0.125</code>。这作为图表的横轴。</p><p><img src="/img/patmc/l8.png"></p><p>一般来说，提高程序性能可以分为 vectorization、memory、threading 三个方面。Roofline methodology 可以帮助评估应用的特征。如下所示，在 roofline 图表上，我们可以画出单核、SIMD 单核和 SIMD 多核的性能。因此可以借助于图表来判断优化方向。AI 越高，说明越是 CPU bound 的，就越要考虑 CPU 方面的优化。Vectorization 和 threading 的操作一般能够让图表中的点上移，而 optimize memory access 的操作一般能够将点右移，也可能能将点上移。</p><p><img src="/img/patmc/5.25.png"></p><p>Roffline 分析可以进行前后的对比，如下所示，在执行完交换内外循环，以及 vectorize 后，性能发生了提高。<br><img src="/img/patmc/5.25.png"></p><h2 id="Static-Performance-Analysis"><a href="#Static-Performance-Analysis" class="headerlink" title="Static Performance Analysis"></a>Static Performance Analysis</h2><h2 id="Compiler-Optimization-Reports"><a href="#Compiler-Optimization-Reports" class="headerlink" title="Compiler Optimization Reports"></a>Compiler Optimization Reports</h2><h1 id="CPU-Features-For-Performance-Analysis"><a href="#CPU-Features-For-Performance-Analysis" class="headerlink" title="CPU Features For Performance Analysis"></a>CPU Features For Performance Analysis</h1><p>通常来说，profiling 能够快速发现应用程序的 hotspots。例如考虑 profile 一个函数，你觉得它应该是 cold 的，但你发现它实际花了很长时间并且被调用了很多次。所以你可以使用 cache 等技术来减少调用的次数，从而提高性能。</p><p>当主要的性能优化点都被处理后，就需要 CPU的支持来发现新的性能瓶颈了。所以在了解本章之前，需要先确保程序没有主要的性能问题。</p><p>现代 CPU 提供新的特性来辅助性能分析，这些特性可以用来发现 cache miss 或者 branch misprediction。这些措施包括：</p><ol><li>Top-Down Microarchitecture Analysis Methodology (TMA)<br> 特征化出 workload 的瓶颈，并且能够在源码中进行定位。</li><li>Last Branch Record (LBR)<br> 持续地记录最近的 branch outcomes。被用来记录 call stacks，识别 hot branch，计算 misprediction rates of individual branches。</li><li>Processor Event-Based Sampling (PEBS)</li><li>Intel Processor Traces (PT)<br> 能够回放程序的执行。</li></ol><h2 id="Top-Down-Microarchitecture-Analysis"><a href="#Top-Down-Microarchitecture-Analysis" class="headerlink" title="Top-Down Microarchitecture Analysis"></a>Top-Down Microarchitecture Analysis</h2><p><img src="/img/patmc/6.28.png"></p><h1 id="Part-2-的说明"><a href="#Part-2-的说明" class="headerlink" title="Part 2 的说明"></a>Part 2 的说明</h1><p>In part 2, we will take a look at how to use CPU monitoring features (see section 6) to find the places in the code which can be tuned for execution on a CPU. For performance-critical applications like large distributed cloud services, scientific HPC software, ‘AAA’ games, etc. it is very important to know how underlying HW works.</p><p>面对 performance-critical 负载时，一些经典算法未必有效。例如链表并不适合用来处理 flat 的数据。原因是需要逐节点动态分配，并且每个元素是零散分布在内存中的。</p><p>Some data structures, like binary trees, have natural linked-list-like representation, so it might be tempting to implement them in a pointer chasing manner. However, more efficient “flat” versions of those data structures exist, see boost::flat_map, boost::flat_set.</p><p>另一方面，即使算法是最好的，但它未必对某些特定的 case 是最好的。例如对有序数组使用二分查找是最优的，但他的 branch miss 很高，因为是 50-50 的失败率。因此对于短数组，常常是线性查找。</p><p>在讲解 CPU 微架构的优化前，先列出一些更高层级的优化方案：</p><ol><li>If a program is written using interpreted languages (python, javascript, etc.), rewrite its performance-critical portion in a language with less overhead.</li><li>Analyze the algorithms and data structures used in the program, see if you can find better ones.</li><li>Tune compiler options. Check that you use at least these three compiler flags: -O3 (enables machine-independent optimizations), -march (enables optimizations for particular CPU generation), -flto (enables inter-procedural optimizations).</li><li>If a problem is a highly parallelizable computation, make it threaded, or consider running<br>it on a GPU.</li><li>Use async IO to avoid blocking while waiting for IO operations.</li><li>Leverage using more RAM to reduce the amount of CPU and IO you have to use (memoization, look-up tables, caching of data, compression, etc.)</li></ol><p>此外，并不是所有的优化方式都对每个平台有效。例如 <a href="https://en.wikipedia.org/wiki/Loop_nest_optimization" target="_blank" rel="noopener">loop blocking</a> 对 memory hierarchy 很敏感，特别是 L2 和 L3 的大小。loop blocking 优化就是如果两层循环都比较大，那么可能内层循环中的元素会在一轮中被 evict 掉，从而导致外层循环在下轮中重新加载。通过重排循环，可以减少重新加载的次数。可以详细看 <a href="https://zhuanlan.zhihu.com/p/292539074" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/292539074</a> 的解读。</p><h2 id="Data-Driven-Optimizations"><a href="#Data-Driven-Optimizations" class="headerlink" title="Data-Driven Optimizations"></a>Data-Driven Optimizations</h2><p>Data-Driven 优化的一个经典案例是 Structure-Of-Array to Array-Of-Structures (SOA-to-AOS)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> b[N];</span><br><span class="line"><span class="keyword">int</span> c[N];</span><br><span class="line"><span class="comment">// many other fields</span></span><br><span class="line">&#125;;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">struct S &#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line"><span class="comment">// many other fields</span></span><br><span class="line">&#125;;</span><br><span class="line">S s[N];</span><br></pre></td></tr></table></figure><p>如何选择取决于数据的读取模式，我理解类似于行存和列存的区别：</p><ol><li>If the program iterates over the data structure and only accesses field b, then SOA is better because all memory accesses will be sequential (spatial locality). </li><li>If the program iterates over the data structure and does excessive operations on all the fields of the object (i.e. a, b, c), then AOS is better because it’s likely that all the members of the structure will reside in the same cache line. It will additionally better utilize the memory bandwidth since fewer cache line reads will be required.</li></ol><p>Data-Driven 优化的另一个案例是 Small Size optimization。也就是提前分配一些内存，用来减少后续的动态内存分配开销。</p><h1 id="CPU-Front-End-Optimizations"><a href="#CPU-Front-End-Optimizations" class="headerlink" title="CPU Front-End Optimizations"></a>CPU Front-End Optimizations</h1><p>CPU Front-End (FE) component is discussed in section 3.8.1. Most of the time, inefficiencies in CPU FE can be described as a situation when Back-End is waiting for instructions to execute, but FE is not able to provide them. As a result, CPU cycles are wasted without doing any actual useful work. Because modern processors are 4-wide (i.e., they can provide four uops every cycle), there can be a situation when not all four available slots are filled. This can be a source of inefficient execution as well. In fact, IDQ_UOPS_NOT_DELIVERED performance event is counting how many available slots were not utilized due to a front-end stall. TMA uses this performance counter value to calculate its “Front-End Bound” metric.</p><h2 id="Machine-code-layout"><a href="#Machine-code-layout" class="headerlink" title="Machine code layout"></a>Machine code layout</h2><p>Assembly instructions will be encoded and laid out in memory consequently. This is what is called machine code layout.</p><h2 id="Basic-Block"><a href="#Basic-Block" class="headerlink" title="Basic Block"></a>Basic Block</h2><p>A basic block is a sequence of instructions with a single entry and single exit.<br>一个 basic block 中的代码会并且只会被执行一次，所以可以减少 control flow graph analysis and transformations。</p><h2 id="Basic-block-placement"><a href="#Basic-block-placement" class="headerlink" title="Basic block placement"></a>Basic block placement</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hot path</span></span><br><span class="line"><span class="keyword">if</span> (cond)</span><br><span class="line">    coldFunc();</span><br><span class="line"><span class="comment">// hot path again</span></span><br></pre></td></tr></table></figure><p><img src="/img/patmc/7.41.png"></p><p>原因：</p><ol><li>Not taken branches are fundamentally cheaper than taken.<br> In the general case, modern Intel CPUs can execute two untaken branches per cycle but only one taken branch every two cycles.</li><li>右边这幅图能够更好地利用 instruction cache 和 uop cache（之前提到的 DSB）。这是因为如果把所有的 hot code 连起来，就没有 cache line fragmentation。L1I Cache 中的所有的 Cache line 都被 hot code 使用。这点对 uop cache 也是一样的，因为它的 cache 也是基于下层的 code layout。</li><li>如果 taken branch 了，CPU 的 fetch 部分也会受影响。因为它也是 fetch 连续的 16 bytes 指令的。</li></ol><p>通过指定 likely 和 unlikely 可以帮助编译器优化。如果一个分支是 unlikely 的，编译器可能选择不 inline，从而减少大小。likely 还可以在 switch 中使用。</p><h2 id="Basic-block-alignment"><a href="#Basic-block-alignment" class="headerlink" title="Basic block alignment"></a>Basic block alignment</h2><p>Skylake 的 instruction cache line 的大小是 64 bytes，下面的代码可能被编译得跨越两个 cache line。这对 CPU 前端的性能会有影响，特别是像这种小循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">benchmark_func</span><span class="params">(<span class="keyword">int</span>* a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i)</span><br><span class="line">        a[i] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的优化通过添加 nop 指令让整个循环都在一个缓存行里面。为什么这能提高性能比较复杂，因此就不解释了。<br><img src="/img/patmc/7.42.png"></p><p>By default, the LLVM compiler recognizes loops and aligns them at 16B boundaries，就和上面图中未优化的情况一样。通过指定 <code>-mllvm -align-all-blocks</code> 可以变成优化后的样子。但是要慎重做这样的处理，因为增加 NOP 指令会影响执行时间。尽管 NOP 不执行，但是他同样需要被 fetch、解码、retire。所以需要额外地耗费在 FE 中的空间。</p><h2 id="Function-splitting"><a href="#Function-splitting" class="headerlink" title="Function splitting"></a>Function splitting</h2><p>目的是将 hot 部分和 cold 部分分离出来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">bool</span> cond1, <span class="keyword">bool</span> cond2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hot path</span></span><br><span class="line">    <span class="keyword">if</span> (cond1) &#123;</span><br><span class="line">        <span class="comment">// large amount of cold code (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hot path</span></span><br><span class="line">    <span class="keyword">if</span> (cond2) &#123;</span><br><span class="line">        <span class="comment">// large amount of cold code (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分离后</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">bool</span> cond1, <span class="keyword">bool</span> cond2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hot path</span></span><br><span class="line">    <span class="keyword">if</span> (cond1)</span><br><span class="line">        cold1();</span><br><span class="line">    <span class="comment">// hot path</span></span><br><span class="line">    <span class="keyword">if</span> (cond2)</span><br><span class="line">        cold2();</span><br><span class="line">&#125;</span><br><span class="line">void cold1() __attribute__((noinline)) &#123; // cold code (1) &#125;</span><br><span class="line">void cold2() __attribute__((noinline)) &#123; // cold code (2) &#125;</span><br></pre></td></tr></table></figure><p>如下图所示，因为在 hot path 中只保留了 CALL，所以下一条指令很有可能在同一个 cache line 里面。这也说明了，对冷代码而言，应该避免它被 inline。<br><img src="/img/patmc/7.43.png"></p><p>特别地，冷函数可以被放在 .text.old 中，从而避免在运行时加载。</p><h2 id="Function-grouping"><a href="#Function-grouping" class="headerlink" title="Function grouping"></a>Function grouping</h2><p>Figure 44 gives a graphical representation of grouping foo, bar, and zoo. The default layout (see fig. 44a) requires four cache line reads, while in the improved version (see fig. 44b), code of foo, bar and zoo fits in only three cache lines. Additionally, when we call zoo from foo, the beginning of zoo is already in the I-cache since we fetched that cache line already.</p><p><img src="/img/patmc/7.44.png"></p><p>和之前一样，function grouping 能提高 I-Cache 和 DSB-cache 的效率。</p><p>使用 ld.gold 链接器来指定顺序：</p><ol><li><code>-ffunction-sections</code> flag, which will put each function into a separate section.</li><li><code>--section-ordering-file=order.txt</code> option should be used to provide a file with a sorted list of function names that reflects the desired final layout.</li></ol><p>一个叫 HFSort 的工具可以帮助 group function。</p><h2 id="Profile-Guided-Optimizations"><a href="#Profile-Guided-Optimizations" class="headerlink" title="Profile Guided Optimizations"></a>Profile Guided Optimizations</h2><h2 id="Optimizing-for-ITLB"><a href="#Optimizing-for-ITLB" class="headerlink" title="Optimizing for ITLB"></a>Optimizing for ITLB</h2><p>Virtual-to-physical address translation of memory address 也影响了 CPU FE 的效率。通常，这是被 TLB 来处理，TLB 会缓存最近的地址。When TLB cannot serve translation request, a time-consuming page walk of the kernel page table takes place to calculate the correct physical address for each referenced virtual address.</p><p>如果 TMA 指示了 high ITLB overhead，那么下面的内容就很重要：</p><ol><li>将一些 performance-critical code 中的部分映射到较大的 page 中。</li><li>使用一些标准的 I-cache performance 优化办法，例如 reorder 函数让 hot 函数更为 collocated。或者通过 LTO 或者 IPO 技术减少 hot region 的大小。或者使用 profile guided optimization。或者使用激进的 inline 技术。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="/img/patmc/t6.png"></p><h1 id="CPU-Back-End-Optimizations"><a href="#CPU-Back-End-Optimizations" class="headerlink" title="CPU Back-End Optimizations"></a>CPU Back-End Optimizations</h1><p>Most of the time, inefficiencies in CPU BE can be described as a situation when FE has fetched and decoded instructions, but BE is overloaded and can’t handle new instructions. Technically speaking, it is a situation when FE cannot deliver uops due to a lack of required resources for accepting new uops in the Backend. An example of it may be a stall due to data-cache miss or a stall due to the divider unit being overloaded.<br>I want to emphasize to the reader that it’s recommended to start looking into optimizing code for CPU BE only when TMA points to a high “Back-End Bound” metric. TMA further divides the Backend Bound metric into two main categories: Memory Bound and Core Bound, which we will discuss next.</p><h2 id="Memory-Bound"><a href="#Memory-Bound" class="headerlink" title="Memory Bound"></a>Memory Bound</h2><p>如下图所示，截止 2010 年，CPU 的提升比内存的提升要快很多。【Q】最近还是这样么？<br><img src="/img/patmc/8.45.png"></p><p>通过 TMA，Memory Bound estimates a fraction of slots where the CPU pipeline is likely stalled due to demand load or store instructions。</p><h3 id="Cache-Friendly-Data-Structures"><a href="#Cache-Friendly-Data-Structures" class="headerlink" title="Cache-Friendly Data Structures"></a>Cache-Friendly Data Structures</h3><p>A variable can be fetched from the cache in just a few clock cycles, but it can take more than a hundred clock cycles to fetch the variable from RAM memory if it is not in the cache.<br>下面一张图展示了各个 CPU 操作的耗时。<br><img src="/img/patmc/ext1.png"></p><p>Cache-friendly code 的关键是 temporal 和 spatial locality。</p><h4 id="Access-data-sequentially"><a href="#Access-data-sequentially" class="headerlink" title="Access data sequentially"></a>Access data sequentially</h4><p>让 HW Prefetcher 感知到我们在顺序访问，从而提前取出下一个 chunk 的数据。<br>下面代码之所以是 cache friendly 的，是因为它的访问模式和它存储的 layout 是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (row = <span class="number">0</span>; row &lt; NUMROWS; row++)</span><br><span class="line">    <span class="keyword">for</span> (column = <span class="number">0</span>; column &lt; NUMCOLUMNS; column++)</span><br><span class="line">        matrix[row][column] = row + column;</span><br></pre></td></tr></table></figure><p>又比如，传统的二分查找算法并没有很好的空间局部性，因为它会测试彼此之间相距很远的元素，这些元素可能在不同的 cache line 上。一个解决方案是使用 <a href="https://en.algorithmica.org/hpc/data-structures/binary-search/" target="_blank" rel="noopener">Eytzinger layout</a>。我理解就是存在一个类似二叉堆的结构中。</p><h4 id="Use-appropriate-containers"><a href="#Use-appropriate-containers" class="headerlink" title="Use appropriate containers"></a>Use appropriate containers</h4><p>或者说是在 array 中直接存对象，还是存指针。如果排序，适合存指针。如果仅仅是线性遍历，适合存对象。</p><h4 id="Packing-the-data"><a href="#Packing-the-data" class="headerlink" title="Packing the data"></a>Packing the data</h4><ol><li>位域</li><li>重新排列 field 以减少 padding 和 aligning 带来的内存浪费 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span> &#123;</span></span><br><span class="line">    <span class="keyword">bool</span> b;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">&#125;; <span class="comment">// S1 is sizeof(int) * 3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">bool</span> b;</span><br><span class="line">&#125;; <span class="comment">// S2 is sizeof(int) * 2</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Aligning-and-padding"><a href="#Aligning-and-padding" class="headerlink" title="Aligning and padding"></a>Aligning and padding</h4><p>比如，一个 16 bytes 的对象可能占用两个 cache line。读取这样的对象需要读两次 cache line。</p><p>A variable is accessed most efficiently if it is stored at a memory address, which is divisible by the size of the variable.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make an aligned array</span></span><br><span class="line">alignas(<span class="number">16</span>) <span class="keyword">int16_t</span> a[N];</span><br><span class="line"><span class="comment">// Objects of struct S are aligned at cache line boundaries</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHELINE_ALIGN alignas(64)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CACHELINE_ALIGN</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Padding 技术还可以备用来解决 cache contention 和 false sharing 问题。</p><p>For example, false sharing issues might occur in multithreaded applications when two threads, A and B, access different fields of the same structure. An example of code when such a situation might happen is shown on Listing 24. Because a and b members of struct S could potentially occupy the same cache line, cache coherency issues might significantly slow down the program.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// written by thread A</span></span><br><span class="line">    <span class="keyword">int</span> b; <span class="comment">// written by thread B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 padding 来解决伪共享</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CACHELINE_ALIGN alignas(64)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a; <span class="comment">// written by thread A</span></span><br><span class="line">    CACHELINE_ALIGN <span class="keyword">int</span> b; <span class="comment">// written by thread B</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>When it comes to dynamic allocations via malloc, it is guaranteed that the returned memory address satisfies the target platform’s minimum alignment requirements. Some applications might benefit from a stricter alignment. For example, dynamically allocating 16 bytes with a 64 bytes alignment instead of the default 16 bytes alignment. In order to leverage this, users of POSIX systems can use memalign API.</p><h4 id="Dynamic-memory-allocation"><a href="#Dynamic-memory-allocation" class="headerlink" title="Dynamic memory allocation"></a>Dynamic memory allocation</h4><ol><li>使用诸如 jemalloc 或者 tcmalloc 的实现</li><li>使用 custom allocator<br> 例如 arena allocator。这样 allocator 不需要在每次分配的时候都 sys call。<br> 另外，也更灵活，支持不同的策略。比如冷数据一个 arena，热数据一个 arena。将热数据放一起可以有机会共享 cache line。从而提高内存贷款和 spatial locality。同时还可以提高 TLB 利用率，因为 hot data 会占用更少的 page。<br> 此外，还是 thread-aware 的，可以实现 thread local 的分配策略，从而避免线程间的同步。</li></ol><h4 id="Tune-the-code-for-memory-hierarchy"><a href="#Tune-the-code-for-memory-hierarchy" class="headerlink" title="Tune the code for memory hierarchy"></a>Tune the code for memory hierarchy</h4><p>这里还是 loop blocking 的例子。也就是将 matrix 切成多个小块，让每一块能够被装在 L2 cache 里面。</p><h3 id="Explicit-Memory-Prefetching"><a href="#Explicit-Memory-Prefetching" class="headerlink" title="Explicit Memory Prefetching"></a>Explicit Memory Prefetching</h3><p>如下代码所示，如果 calcNextIndex 返回的是很随机的数字，那么 arr[j] 会频繁 cache miss。如果 arr 很大，那么 HW prefetcher 就不能去识别 pattern，然后 prefetch。<br>因为在计算 j 和访问 arr[j] 之间有不少操作，所以可以借助 <code>__builtin_prefetch</code> 来 prefetch。这也是要点，一定要提前足够的时间。但也不能提前太多，从而污染 cache。在后面的 6.2.5 节中会介绍如何选择。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = calcNextIndex();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    doSomeExtensiveComputation();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    x = arr[j]; <span class="comment">// this load misses in L3 cache a lot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般比较通用的是提前获取下一个 iter 的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> j = calcNextIndex();</span><br><span class="line">    __builtin_prefetch(a + j, <span class="number">0</span>, <span class="number">1</span>); <span class="comment">// well before the load</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    doSomeExtensiveComputation();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    x = arr[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，Explicit Memory Prefetching 不是 portable 的。可能在别的平台上反而会让性能变差。Consider a situation when we want to insert a prefetch instruction into the piece of code that has average IPC=2, and every DRAM access takes 100 cycles. To have the best effect, we would need to insert prefetching instruction 200 instructions before the load. It is not always possible, especially if the load address is computed right before the load itself. The pointer chasing problem can be a good example when explicit prefetching is helpless.</p><p>另外，prefetch 指令会加重 CPU 前端的开销。</p><h3 id="Optimizing-For-DTLB"><a href="#Optimizing-For-DTLB" class="headerlink" title="Optimizing For DTLB"></a>Optimizing For DTLB</h3><p>如前介绍，TLB is a fast but finite per-core cache for virtual-to-physical address translations of memory addresses. 没有它，每次内存访问都需要去遍历内核的 page table，然后计算出正确的 physical address。</p><p>TLB 由 L1 ITLB(instructions)、L1 DTLB(data) 和 L2 STLB(shared by data and instructions) 组成。L1 ITLB 的 cache miss 的惩罚很小，通常能够被 OOO 执行掩盖掉。L2 STLB 的 cache miss 就会导致遍历内核的 page table 了。这个 penalty 是可被观测的，因为这段时间 CPU 是 stall 的。假设 Linux 的默认 page size 是 4KB，L1 TLB 只能够存几百个 entry，覆盖大约 1MB 的地址空间。L2 STLB 覆盖大概一千多个。</p><p>一种减少 ITLB cache miss 的方案是使用更大的 page size。TLB 也支持使用 2MB 和 1GB 的 page。</p><p>Large memory applications such as relational database systems (e.g., MySQL, PostgreSQL, Oracle, etc.) and Java applications configured with large heap regions frequently benefit from using large pages.</p><p>On Linux OS, there are two ways of using large pages in an application: Explicit and Transparent Huge Pages.</p><h4 id="Explicit-Hugepages"><a href="#Explicit-Hugepages" class="headerlink" title="Explicit Hugepages"></a>Explicit Hugepages</h4><p>用户可以通过 mmap 等指令去访问。可以通过 <code>cat /proc/meminfo</code> 并检查 <code>HugePages_Total</code> 来检查相关配置。</p><p>Huge page 可以在系统启动，或者运行的时候被保留。在启动期间保留的成功率更高，因为此时系统的内存空间没有被显著碎片化(fragmented)。</p><p>可以通过 libhugetlbfs 来 override 掉 malloc 调用。只需要调整环境变量酒席了。</p><ol><li>mmap using the MAP_HUGETLB flag<br> <a href="https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/map_hugetlb.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/map_hugetlb.c</a></li><li>mmap using a file from a mounted hugetlbfs filesystem<br> <a href="https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/hugepage-mmap.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/hugepage-mmap.c</a></li><li>shmget using the SHM_HUGETLB flag<br> <a href="https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/hugepage-shm.c" target="_blank" rel="noopener">https://elixir.bootlin.com/linux/latest/source/tools/testing/selftests/vm/hugepage-shm.c</a></li></ol><h4 id="Transparent-Hugepages"><a href="#Transparent-Hugepages" class="headerlink" title="Transparent Hugepages"></a>Transparent Hugepages</h4><p>Linux also offers Transparent Hugepage Support(THP)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line">always [madvise] never</span><br></pre></td></tr></table></figure><p>always 表示 system wide，madvise 表示 per process。</p><h4 id="Explicit-vs-Transparent-Hugepages"><a href="#Explicit-vs-Transparent-Hugepages" class="headerlink" title="Explicit vs. Transparent Hugepages"></a>Explicit vs. Transparent Hugepages</h4><ol><li>Background maintenance of transparent huge pages incurs non-deterministic latency overhead from the kernel as it manages the inevitable fragmentation and swapping issues. EHP is not subject to memory fragmentation and cannot be swapped to the disk.</li><li>EHP is available for use on all segments of an application, including text segments (i.e., benefits both DTLB and ITLB), while THP is only available for dynamically allocated memory regions.</li></ol><h2 id="Core-Bound"><a href="#Core-Bound" class="headerlink" title="Core Bound"></a>Core Bound</h2><p>也就是在 OOO 执行过程中所有不是因为内存原因造成的 stall。包含：</p><ol><li>Shortage in hardware compute resources<br> 比如除法和平方根计算被 Divider Unit 处理，耗时比较长。如果这方面的操作比较多，那么就会造成 stall。</li><li>Dependencies between software’s instructions</li></ol><h3 id="Inlining-Functions"><a href="#Inlining-Functions" class="headerlink" title="Inlining Functions"></a>Inlining Functions</h3><p>它不仅能够去掉调用函数的开销，同时也让其他优化变为可能。因为此时编译期能看到更多的代码。<br>对 LLVM 编译期而言，基于 computing cost 和 a threshold for each function call(callsite) 来计算。如果 cost 比 threshold 更低，就会 inline。</p><p>threshold 的选取通常是固定的，一般来说有一些启发式的方法：</p><ol><li>小函数基本总是会被 inline</li><li>只有一个 callsite 的函数会被倾向于 inline</li><li>大函数通常不会 inline，因为它们让 caller 变大</li></ol><p>有些不能 inline 的情况：</p><ol><li>递归函数不能 inline</li><li>Function that is referred to through a pointer can be inlined in place of a direct call but has to stay in the binary, i.e., cannot be fully inlined and eliminated. The same is true for functions with external linkage.</li></ol><p>One way to find potential candidates for inlining in a program is by looking at the profiling data, and in particular, how hot is the prologue and the epilogue of the function. 下面的 demo 中，这个函数的 profile 中体现了 prologue 和 epilogue 花费了大概 50% 的时间。这<strong>可能</strong>说明了如果我们 inline 这个函数，就能减少 prologue 和 epilogue 的开销。但这不是绝对的，因为 inline 会导致一系列变化，所以很难预测结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Overhead | Source code &amp; Disassembly</span><br><span class="line">(%) | of function `foo`</span><br><span class="line">--------------------------------------------</span><br><span class="line">3.77 : 418be0: push r15 # prologue</span><br><span class="line">4.62 : 418be2: mov r15d,0x64</span><br><span class="line">2.14 : 418be8: push r14</span><br><span class="line">1.34 : 418bea: mov r14,rsi</span><br><span class="line">3.43 : 418bed: push r13</span><br><span class="line">3.08 : 418bef: mov r13,rdi</span><br><span class="line">1.24 : 418bf2: push r12</span><br><span class="line">1.14 : 418bf4: mov r12,rcx</span><br><span class="line">3.08 : 418bf7: push rbp</span><br><span class="line">3.43 : 418bf8: mov rbp,rdx</span><br><span class="line">1.94 : 418bfb: push rbx</span><br><span class="line">0.50 : 418bfc: sub rsp,0x8</span><br><span class="line">...</span><br><span class="line"># # function body</span><br><span class="line">...</span><br><span class="line">4.17 : 418d43: add rsp,0x8 # epilogue</span><br><span class="line">3.67 : 418d47: pop rbx</span><br><span class="line">0.35 : 418d48: pop rbp</span><br><span class="line">0.94 : 418d49: pop r12</span><br><span class="line">4.72 : 418d4b: pop r13</span><br><span class="line">4.12 : 418d4d: pop r14</span><br><span class="line">0.00 : 418d4f: pop r15</span><br><span class="line">1.59 : 418d51: ret</span><br></pre></td></tr></table></figure><h3 id="Loop-Optimizations"><a href="#Loop-Optimizations" class="headerlink" title="Loop Optimizations"></a>Loop Optimizations</h3><p>通常，循环的性能被下面几点限制：</p><ol><li>memory lantency</li><li>memory bandwidth</li><li>机器的 compute capability</li></ol><p>Roofline Perfoemance Model 是评估 HW 理论最大值和不同的 loop 实际之间的方法。Top-Down Microarchitecture Analusis 是另外一个瓶颈相关的信息来源。</p><p>这一节中，首先讨论 low-level 的优化，也就是将代码在一个 loop 中移动。这样的优化方式让循环内的计算更有效率。然后是 high-level 的优化，会 restructure loops，通常会影响多个 loop。第二种优化的目的主要是提高 memory access。eliminating memory bandwidth 和 memory lantency 问题。</p><h4 id="Low-level-optimizations"><a href="#Low-level-optimizations" class="headerlink" title="Low-level optimizations"></a>Low-level optimizations</h4><p>下面这些优化通常能够提高具有 high arithmetic intensity 的 loop 的性能，比如循环是 CPU-compute-bound 的。大部分情况下，编译器能够自己做相关优化，少部分情况下，需要人工帮助。</p><h5 id="Loop-Invariant-Code-Motion-LICM"><a href="#Loop-Invariant-Code-Motion-LICM" class="headerlink" title="Loop Invariant Code Motion (LICM)"></a>Loop Invariant Code Motion (LICM)</h5><p>将循环中的不变量移出循环。<br>什么是循环中的不变量呢？ Expressions evaluated in a loop that never change are called loop invariants.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; N; ++i)</span><br><span class="line">    for (int j = 0; j &lt; N; ++j)</span><br><span class="line">        a[j] = b[j] * c[i]; </span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">    auto temp = c[i];</span><br><span class="line">    for (int j = 0; j &lt; N; ++j)</span><br><span class="line">        a[j] = b[j] * temp;</span><br></pre></td></tr></table></figure><h5 id="Loop-Unrolling"><a href="#Loop-Unrolling" class="headerlink" title="Loop Unrolling"></a>Loop Unrolling</h5><p>循环的 induction variable，也就是 for i 的那个 i，每个 iteration 去修改它的代价是比较大的。所以可以选择 unroll 一个循环。</p><p>下面的例子中，unroll the loop by a factor of 2. 从而减少了 compare 和 branch 指令的开销到原来的一半。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; N; ++i)</span><br><span class="line">    a[i] = b[i] * c[i];</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; N; i+=2) &#123;</span><br><span class="line">    a[i] = b[i] * c[i];</span><br><span class="line">    a[i+1] = b[i+1] * c[i+1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作者建议不要手工展开循环：</p><ol><li>编译器很擅长做这个，并且做得很好</li><li>处理器有一个 “embedded unroller”，thanks to their OOO speculative execution engine<br> 当处理器正等待第一个 iteration 的负载完成时，它可能预先开始执行第二个 iteration 的负载了。This spans to multiple iterations ahead, effectively unrolling the loop in the instruction Reorder Buffer (ROB).</li></ol><h5 id="Loop-Strength-Reduction-LSR"><a href="#Loop-Strength-Reduction-LSR" class="headerlink" title="Loop Strength Reduction (LSR)"></a>Loop Strength Reduction (LSR)</h5><p>将开销比较大的操作换为开销更小的操作。通常和 induction variable 上的计算有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; N; ++i)</span><br><span class="line">    a[i] = b[i * 10] * c[i];</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line">int j = 0;</span><br><span class="line">for (int i = 0; i &lt; N; ++i) &#123;</span><br><span class="line">    a[i] = b[j] * c[i];</span><br><span class="line">    j += 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Loop-Unswitching"><a href="#Loop-Unswitching" class="headerlink" title="Loop Unswitching"></a>Loop Unswitching</h5><p>这个很简单，尝试能不能把 loop 中的 branch 提出来，分成两个 loop</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">for (i = 0; i &lt; N; i++) &#123;</span><br><span class="line">    a[i] += b[i];</span><br><span class="line">    if (c)</span><br><span class="line">        b[i] = 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if (c)</span><br><span class="line">    for (i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">        b[i] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">else</span><br><span class="line">    for (i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        a[i] += b[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="High-level-optimizations"><a href="#High-level-optimizations" class="headerlink" title="High-level optimizations"></a>High-level optimizations</h4><p>下面的一些变换，从编译器的角度比较难合法地或者自动地进行。所以很多时候可能需要手动做。</p><h5 id="Loop-Interchange"><a href="#Loop-Interchange" class="headerlink" title="Loop Interchange"></a>Loop Interchange</h5><p>交换多层循环的 order。<br>目的是 perform sequential memory accesses to the elements of a multi-dimensional array。<br>如下所示，在一个按行存储的数组中，让 i 到内层循环的空间局部性更好。</p><p><img src="/img/patmc/l32.png"></p><h5 id="Loop-Blocking-Tiling"><a href="#Loop-Blocking-Tiling" class="headerlink" title="Loop Blocking (Tiling)"></a>Loop Blocking (Tiling)</h5><h5 id="Loop-Fusion-and-Distribution-Fission"><a href="#Loop-Fusion-and-Distribution-Fission" class="headerlink" title="Loop Fusion and Distribution (Fission)"></a>Loop Fusion and Distribution (Fission)</h5><p>Loop fusion 可以用来：</p><ol><li>减少 loop overhead，因为它会复用相同的 induction variable</li><li>可以提高 memory access 的 temporal locality<br> 如下代码中，如果 x 和 y 都位于同一个缓存行上面，那么将两个 loop fuse 在一起能够避免加载同一个缓存行两次。<br> 这样就能减少 cache footprint，并且提高 memory bandwidth utilization。</li></ol><p><img src="/img/patmc/l34.png"></p><p>相反地有 Loop Distribution 即 Loop Fission。其目的是：</p><ol><li>可以先在一个循环中 pre-filter、sort、reorg 数据</li><li>减少一个 iteration 中需要访问的数据，从而提高 memory access 的 temporal locality。这对具有较高 cache contention 的场景，也就是大 loop 中会比较有用</li><li>减少对寄存器的压力，同样是因为一个 iteration 中会执行更少的操作了</li><li>通常还可能提升 CPU FE 的性能，因为 cache utilization 会更好</li><li>编译期能够更好地优化小循环</li></ol><h4 id="Discovering-loop-optimization-opportunities"><a href="#Discovering-loop-optimization-opportunities" class="headerlink" title="Discovering loop optimization opportunities"></a>Discovering loop optimization opportunities</h4><p>如下所示，编译器不能把 strlen 移出循环体。这是因为 a 和 b 两个数组可能是 overlap 的。所以，需要通过 restrict 关键词来显式声明这两段内存不会 overlap。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">char</span>* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i)</span><br><span class="line">        b[i] = (a[i] == <span class="string">'x'</span>) ? <span class="string">'y'</span> : <span class="string">'n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一些时候，编译期可以通过 compiler optimization remarks (sec 5.7) 告诉我们失败了的优化。但对于上面的情况，Clang 10 和 GCC 10 目前还都不行。目前只能通过反编译出来的代码才能看出来。</p><p>有一些指令可以配置编译器的优化行为，例如 <code>#pragma unroll(8)</code>。</p><h4 id="Use-Loop-Optimization-Frameworks"><a href="#Use-Loop-Optimization-Frameworks" class="headerlink" title="Use Loop Optimization Frameworks"></a>Use Loop Optimization Frameworks</h4><p>目前有一些框架可以检测 loop transformation 的合法性了。例如 polyhedral 框架，polyhedral 的意思是多面体。LLVM 系列也有自己的 polyheral 框架，即 Polly。LLVM 默认不启用。对于 GEMM 内核，Polly 能提供 20 倍左右的提速。</p><h3 id="Vectorization"><a href="#Vectorization" class="headerlink" title="Vectorization"></a>Vectorization</h3><p>大部分情况下，Vectorization 能够被编译器发现，然后自动发生。<br>一般来说，在编译器中完成三种 Vectorization：</p><ol><li>inner loop vectorization</li><li>outer loop vectorization</li><li>SLP (Superword-Level Parallelism) vectorization</li></ol><p>第一种最常见。</p><h4 id="Compiler-Autovectorization"><a href="#Compiler-Autovectorization" class="headerlink" title="Compiler Autovectorization"></a>Compiler Autovectorization</h4><p>阻止 Autovectorization 的情况：</p><ol><li>unsigned loop-indices 溢出</li><li>两个指针可能指向重叠的内存区间</li><li>处理器本身不支持比如 predicated (bitmask-controlled) load and store operation</li><li>vector-wide format conversion between signed integers to doubles because the result operates on vector registers of different sizes</li></ol><p>所以一般分为三步：</p><ol><li>Legality-check<br> 检查 the loop progresses linearly。<br> 确保 the memory and arithmetic operations in the loop can be widened into consecutive operations。<br> That the control flow of the loop is uniform across all lanes and that the memory access patterns are uniform。没看懂是在说什么。<br> 确保不会访问和修改不应该的内存。<br> analyze the possible range of pointers, and if it has some missing information, it has to assume that the transformation is illegal。看不懂。</li><li>Profitability-check<br> It needs to take into account the added instructions that shuffle data into registers, predict register pressure, and estimate the cost of the loop guards that ensure that preconditions that allow vectorizations are met. 我觉得作者这样说就是在让人看不懂。</li><li>Transformation</li></ol><h4 id="Discovering-vectorization-opportunities"><a href="#Discovering-vectorization-opportunities" class="headerlink" title="Discovering vectorization opportunities"></a>Discovering vectorization opportunities</h4><p>检查 compiler vectorization remarks 可以发现编译期进行了什么优化，包含是否 vectorized 了，vectorization factor(VF) 是多少。</p><h4 id="Vectorization-is-illegal"><a href="#Vectorization-is-illegal" class="headerlink" title="Vectorization is illegal"></a>Vectorization is illegal</h4><p>下面的函数不是 vectorizable 的。因为是 read-after-write dependence.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vectorDependence</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        A[i] = A[i<span class="number">-1</span>] * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的函数不是 vectorizable 的。因为是 floating-point arithmetic。一般来说，浮点数加法是可交换的，但浮点数加法不是可结合的。如果向量化，则会导致不同的 round decision，和一个不同的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">calcSum</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下所示的代码，GCC 会为其创建两个不同的版本。如果发现 a 和 b 和 c 有 overlap，则运行普通版本，否则运行 simd 版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>* a, <span class="keyword">float</span>* b, <span class="keyword">float</span>* c, <span class="keyword">unsigned</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        c[i] = b[i];</span><br><span class="line">        a[i] = c[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -O3 -march=core-avx2 -fopt-info</span><br><span class="line">a.cpp:2:26: optimized: loop vectorized using 32 byte vectors</span><br><span class="line">a.cpp:2:26: optimized: loop versioned for vectorization because of possible</span><br><span class="line">aliasing</span><br></pre></td></tr></table></figure><h4 id="Vectorization-is-not-beneficial"><a href="#Vectorization-is-not-beneficial" class="headerlink" title="Vectorization is not beneficial"></a>Vectorization is not beneficial</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stridedLoads</span><span class="params">(<span class="keyword">int</span> *A, <span class="keyword">int</span> *B, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        A[i] += B[i * <span class="number">3</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Loop-vectorized-but-scalar-version-used"><a href="#Loop-vectorized-but-scalar-version-used" class="headerlink" title="Loop vectorized but scalar version used"></a>Loop vectorized but scalar version used</h4><p>一般是因为 loop trip 比较小。比如以 AVX2 来说，如果同时加上 unroll 循环的技术，假设 unroll 4-5 倍，那么一个 loop iteration 需要处理 40 个元素。所以这种情况下，会直接 fallback 到处理剩余尾数的普通循环中。<br>此时，可以强制使用更小的 vectorization factor 或者 unroll count。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang loop vectorize_width(N)</span></span><br></pre></td></tr></table></figure><h4 id="Loop-vectorized-in-a-suboptimal-way"><a href="#Loop-vectorized-in-a-suboptimal-way" class="headerlink" title="Loop vectorized in a suboptimal way"></a>Loop vectorized in a suboptimal way</h4><p>最优的 vectorization factor 是难以通过直觉判断的，因为存在以下因素：</p><ol><li>很难在大脑中模拟 CPU 的运行模式<br> Vector shuffles that touch multiple vector lanes could be more or less expensive than expected, depending on many factors.<br> 什么是 vector shuffle？</li><li>运行时，程序可能以非预期的方式运行，取决于 port pressure 或者其他因素<br> 人类可以通过 Vectorization pragmas 来尝试各种  vectorization factor。也可以尝试各种 unroll factor 来选出最优的。但编译器做不到。</li><li>非 vec 的版本可能更好<br> 因为 gather/scatter loads, masking, shuffle 这些向量操作更昂贵。<br> 所以也需要尝试禁用向量化比较性能。如使用 <code>-fno-vectorize</code> 和 <code>-fno-slp-vectorize</code>，或者 <code>#pragma clang loop vectorize(enable)</code>。</li></ol><h4 id="Use-languages-with-explicit-vectorization"><a href="#Use-languages-with-explicit-vectorization" class="headerlink" title="Use languages with explicit vectorization"></a>Use languages with explicit vectorization</h4><h4 id="“Close-to-the-metal”-programming-model"><a href="#“Close-to-the-metal”-programming-model" class="headerlink" title="“Close to the metal” programming model"></a>“Close to the metal” programming model</h4><p>这里说的是传统的 C 和 C++ 中没有向量化的概念，所以总是需要通过 compiler intrinsics 来做这个工作。而像 ISPC 这样的语言中 <code>+=</code> 这样的操作符会被隐式地认为是 SIMD 操作，并会并行的执行多个加法。</p><h1 id="Optimizing-Bad-Speculation"><a href="#Optimizing-Bad-Speculation" class="headerlink" title="Optimizing Bad Speculation"></a>Optimizing Bad Speculation</h1><p>Mispredicting a branch can add a significant speed penalty when it happens regularly. When such an event happens, a CPU is required to clear all the speculative work that was done ahead of time and later was proven to be wrong. It also needs to flush the whole pipeline and start filling it with instructions from the correct path. Typically, modern CPUs experience a 15-20 cycles penalty as a result of a branch misprediction.</p><p>现在的处理器能够进行分支预测，不仅仅是静态的规则，甚至可以发现动态的模式。</p><p>我们可以通过 TMA Bad Speculation 指标来查看一个程序在多大程度上收到分支预测的影响。对此，作者推荐只有当分支预测失败率在 10% 以上的时候，再进行关注。</p><p>从前，可以在分治命令前加上前缀 0x2E 或者 0x3E 来分别表示是否选择这个分支。但随着后面分支预测机制的完善，这个功能被去掉了。所以目前唯一能够避免分支预测失败的<strong>直接</strong>办法是不使用分支。下面介绍两种避免分支的办法。</p><p>注：likely 和 unlikely 是通过放置可能性较大的指令到靠近分支跳转指令<a href="https://zhuanlan.zhihu.com/p/357434227" target="_blank" rel="noopener">来实现优化</a>的。</p><h2 id="Replace-branches-with-lookup"><a href="#Replace-branches-with-lookup" class="headerlink" title="Replace branches with lookup"></a>Replace branches with lookup</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="keyword">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">0</span> &amp;&amp; v &lt; <span class="number">10</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">10</span> &amp;&amp; v &lt; <span class="number">20</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">20</span> &amp;&amp; v &lt; <span class="number">30</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">30</span> &amp;&amp; v &lt; <span class="number">40</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (v &gt;= <span class="number">40</span> &amp;&amp; v &lt; <span class="number">50</span>) <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> buckets[<span class="number">256</span>] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">    <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>,</span><br><span class="line">    <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>,</span><br><span class="line">    <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">    <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>,</span><br><span class="line">... &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mapToBucket</span><span class="params">(<span class="keyword">unsigned</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; (<span class="keyword">sizeof</span> (buckets) / <span class="keyword">sizeof</span> (<span class="keyword">int</span>)))</span><br><span class="line">    <span class="keyword">return</span> buckets[v];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Replace-branches-with-predication"><a href="#Replace-branches-with-predication" class="headerlink" title="Replace branches with predication"></a>Replace branches with predication</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;According to 老板，according to yifan，这本书很好，所以我就来学习一下了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="性能" scheme="http://www.calvinneo.com/tags/性能/"/>
    
  </entry>
  
  <entry>
    <title>Grafana 使用 histogram_quantile 和 rate 的精度问题</title>
    <link href="http://www.calvinneo.com/2023/09/11/grafana-issue-floating/"/>
    <id>http://www.calvinneo.com/2023/09/11/grafana-issue-floating/</id>
    <published>2023-09-11T14:57:32.000Z</published>
    <updated>2023-12-18T15:48:09.856Z</updated>
    
    <content type="html"><![CDATA[<p>Grafana 上如果观测离群点，会发现它的值漂移地很厉害。往往一个实际 2min 的指标能显示出是几个 hour。<br>如 <a href="https://github.com/pingcap/tiflash/issues/8076" target="_blank" rel="noopener">https://github.com/pingcap/tiflash/issues/8076</a> 所述。这个问题发生需要同时使用 histogram_quantile 和 rate。</p><a id="more"></a><p>其原因是 rate 会将 count 除成小数，因为 IEEE 浮点数不能精确表示，所以引入了噪音数据。<br>如下所示，8.192 和 67108.864 这两个桶对应的 sum 应该是相等的。但因为浮点数加法的问题，它们不相等了。因此这些立群值就会被放到 bucket 序号更大的桶里面了。<br><img src="/img/grafana/1.jpg"></p><p><a href="https://github.com/m3db/m3/issues/3706" target="_blank" rel="noopener">https://github.com/m3db/m3/issues/3706</a></p><p>The problem is that the rate function, while doing its magic, turns counts into fractions. Most fractions can’t be expressed exactly as a floating point number (IEEE754 standard). The resulting number that represents the fraction is just an approximation that uses up all bits of mantissa.</p><p>因为精度的问题，导致在某个 edge 上会进一位。所以可以用 <code>histogram_quantile(1.0, sum(round(1000000000*rate(xxx{}[5m]))) by (le) / 1000000000)</code> 这样来规避。</p><p>这也体现出浮点数的性质不咋样，连结合律都不满足。在工程上来讲，不满足结合律意味着没法分治。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Grafana 上如果观测离群点，会发现它的值漂移地很厉害。往往一个实际 2min 的指标能显示出是几个 hour。&lt;br&gt;如 &lt;a href=&quot;https://github.com/pingcap/tiflash/issues/8076&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/pingcap/tiflash/issues/8076&lt;/a&gt; 所述。这个问题发生需要同时使用 histogram_quantile 和 rate。&lt;/p&gt;</summary>
    
    
    
    
    <category term="grafana" scheme="http://www.calvinneo.com/tags/grafana/"/>
    
  </entry>
  
  <entry>
    <title>关于 TiKV、TiDB、TiFlash 的一些思考</title>
    <link href="http://www.calvinneo.com/2023/07/22/tikv-tidb-thought/"/>
    <id>http://www.calvinneo.com/2023/07/22/tikv-tidb-thought/</id>
    <published>2023-07-22T15:20:37.000Z</published>
    <updated>2024-01-28T16:47:34.238Z</updated>
    
    <content type="html"><![CDATA[<p>一些常见问题的思考，只代表个人见解。</p><a id="more"></a><h1 id="TiKV-相关"><a href="#TiKV-相关" class="headerlink" title="TiKV 相关"></a>TiKV 相关</h1><h2 id="TiKV-写入性能"><a href="#TiKV-写入性能" class="headerlink" title="TiKV 写入性能"></a>TiKV 写入性能</h2><h3 id="KV-热点"><a href="#KV-热点" class="headerlink" title="KV 热点"></a>KV 热点</h3><p>如果出现热点 Key，机器会吃不消么？写热点是难以避免的。TiKV 选择按 Range 切割，但是 User Key 不跨 Region。一段区间内的写热点，会导致容量超过上限而分裂，新分裂出来的 Region 可以被调度到其他 Node 上，从而实现负载均衡。在<a href="https://zhuanlan.zhihu.com/p/81316899" target="_blank" rel="noopener">文章</a>中提到，可以通过预分区的方式来划分 Region。可是对于单调递增的主键，或者索引，它会永远写在最后一个 Region 上。但我认为热点 Region 未必意味着热点机器，可以先进行 Split，然后通过 Leader Transfer 给其他的 Peer，或者通过 Conf Change 直接干掉自己。我猜测这个主要取决于数据迁移的效率和中心化服务的质量，如果在 Raft Log 阶段就能检测到流量问题并分裂，那么负载有可能被分流到多个相邻的 Region 中。</p><p>TiKV 提供了 SHARD_ROW_ID_BITS 来进行打散，这类似于 Spanner 架构中提到的利用哈希解决 Append 写的思路。TiBD 提供了 AUTO_RANDOM 替代 AUTO_INCREMENT。</p><p>注意，如果负载是频繁对某个特定的 key 更新，则 TS 一定也被用来计算哈希，不然热点 key 一定是在同一个 Region 内。这样一个 key 的不同版本就分布在不同的 Region 中，就不利于扫表了。因为下推到 TiKV 的请求可以理解为从 [l, r] 去扫出来所有 <a href="https://blog.csdn.net/TiDB_PingCAP/article/details/100535768" target="_blank" rel="noopener">commit_ts &lt;= scan_ts</a> 的数据，这样的扫表一定是会涉及到所有的机器，性能会很差。对于点查也一样，我们始终要找一个大于 user_key + ts 的 TiKV Key，哈希分片不好 seek。特别地，如果是 SI，那还得扫 [0, scan_ts] 中有没有 Lock，这个过程也要访问多个机器。</p><p>如果在构造 key 的时候就进行分片，比如在最左边加一个 shard_id，这样 rehash 会很困难。shard_id 可以比如是通过某个特定字段哈希得到。</p><p>在 Spanner 中存在 Tablet，也就是将多个同时访问比较频繁的 Region co-locate，这些 Region 彼此之间未必是有序的，甚至可能属于不同的表。</p><h3 id="关于-Region-数量的讨论"><a href="#关于-Region-数量的讨论" class="headerlink" title="关于 Region 数量的讨论"></a>关于 Region 数量的讨论</h3><p>较小的 Region 的好处：</p><ol><li>每个 Region 中较低的并发</li><li>更加快速的调度</li></ol><p>较大的 Region 的好处：</p><ol><li>Placement Driver 的压力变小</li><li>CompactLog、Heartbeat 等网络开销变小</li></ol><h3 id="Raft-存储"><a href="#Raft-存储" class="headerlink" title="Raft 存储"></a>Raft 存储</h3><p>原来 TiKV 使用 RocksDB 存储 Raft Log 和相关 Meta，存在几个问题：</p><ol><li>WAL + 实际数据，需要写两次盘。</li><li>数据变多，Compaction 负担变大，写放大更大。层数更多，写放大更大。</li></ol><p>因此引入了类似 bitcask 架构的 RaftEngine 来解决这个问题。RaftEngine 中每个 Region 对应一个 Memtable，数据先通过 Group Write 写入到文件中，然后再注册到 Memtable 中。在读取时从 Memtable 获取位置，再从文件中读取。因此随着 Region 日志 Apply 进度的不同，RaftEngine 在文件中会存在空洞，因此需要 rewrite。这使得存在一部分 CPU 和 IO 花费在 rewrite 逻辑上，而不能像 PolarDB 一样按照水位线直接删除。RaftEngine 这么做可以减少 fsync 的调用频率，并且充分利用文件系统 buffer 来做聚合。</p><p>此外，Raftstore 还使用 async_io 来异步落盘 Raft 日志和 Raft 状态。这样，Raftstore 线程不被 io 阻塞，能够处理更多的 Raft 相关请求和日志。需要注意，这反过来可能会加重 PeerFsm、ApplyFsm 和网络的负担，对 CPU 的要求更高。</p><h3 id="日志和数据分离存储"><a href="#日志和数据分离存储" class="headerlink" title="日志和数据分离存储"></a>日志和数据分离存储</h3><h3 id="Titan"><a href="#Titan" class="headerlink" title="Titan"></a>Titan</h3><p>Titan 的思路是将 RocksDB 中的 value 拿出来存，减少 Compaction 对 CPU 和 IO 的开销，但会带来空间放大。并且数据局部性差，所以范围查询性能较差。</p><p>Titan 将这些大 value 有序地存放在一些 blob file 中，并且保存了 value 对应的 user key 用来反查 RocksDB。反查的原因是 blob file 本身需要 gc，所以要通过 user key 来查询是否过期，这会带来一些写放大。</p><p>Titan 有两种 gc 策略：</p><ol><li>定时 rewrite blob file<br> 监听每次 Compaction 事件，从而维护每个 blob 文件中无效数据的大小。每次重写 invalid 率最高的几个文件，并更新回 RocksDB。旧的文件需要确保不再有 Snapshot 引用才可被删除。</li><li>在 LSM-tree compaction 的时候同时进行 blob 文件的重写<br> 也就是在 Compaction 的同时写到一份新的 blob 文件中。因为不需要的 kv 会在 Compaction 的时候被过滤掉，也就相当于自动完成了 gc。<br> 这种方案要求 blob 文件也需要伴随着 SST 进行分层，从而带来写放大。并且也有不小的空间放大。因此，该策略只对最下面两层生效。</li></ol><p>在有限的场景中，Titan 能够带来收益。</p><p>业界也有类似 Titan 的 KV 分离存储方案，比如 WiscKey 等。</p><h2 id="TiKV-读取"><a href="#TiKV-读取" class="headerlink" title="TiKV 读取"></a>TiKV 读取</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>TiKV 处理读请求对 Block Cache 要求较高，较低的 Block Cache Hit 会导致读性能倍数下滑。Block Cache 需要占用接近一般的内存，但也需要保留一部分给系统作为 Page Cache，以及处理查询时的内存。</p><p>不同的压缩方式，对 CPU 的压力不同。</p><h1 id="Multi-Raft-相关"><a href="#Multi-Raft-相关" class="headerlink" title="Multi Raft 相关"></a>Multi Raft 相关</h1><h2 id="关于-Raft-协议本身"><a href="#关于-Raft-协议本身" class="headerlink" title="关于 Raft 协议本身"></a>关于 Raft 协议本身</h2><h3 id="Follower-Replication-和-Follower-Snapshot"><a href="#Follower-Replication-和-Follower-Snapshot" class="headerlink" title="Follower Replication 和 Follower Snapshot"></a>Follower Replication 和 Follower Snapshot</h3><h3 id="关于读"><a href="#关于读" class="headerlink" title="关于读"></a>关于读</h3><p>Raft 的一个问题就是读的时候无论是 Leader 还是 Follower 都需要 Read Index。比如，对 Leader 而言，它需要问 quorum 自己当前是否还是 Leader。TiKV 一般 Leader Read 提供两种方案，第一种是 read_local，也就是 Leader 节点上 lease 读，另一种是 read_index，也就是在不确定自己是否还是 Leader 的时候，进行 ReadIndex。</p><h2 id="Raft-状态的思考"><a href="#Raft-状态的思考" class="headerlink" title="Raft 状态的思考"></a>Raft 状态的思考</h2><p>RaftLocalState 中相比 Raft 协议多包含了 last_index 和 commit。其中 commit 可以避免重启后不能立即 apply 的情况。</p><h2 id="存储-Raft-状态和-Region-状态"><a href="#存储-Raft-状态和-Region-状态" class="headerlink" title="存储 Raft 状态和 Region 状态"></a>存储 Raft 状态和 Region 状态</h2><p>TiKV 使用 Raft Engine 存储 Raft 元信息和 Raft 日志。使用 KV Engine 存 Region 信息、Region Apply 信息和具体的 KV数据。</p><h3 id="一个-Eager-落盘导致的问题"><a href="#一个-Eager-落盘导致的问题" class="headerlink" title="一个 Eager 落盘导致的问题"></a>一个 Eager 落盘导致的问题</h3><p>并不是所有时候，eager 落盘都能保证正确性问题。下面就是一个例子。<br>前面说过，在 TiKV 的实现中有两个 engine，KVEngine 存储 KV Meta 和 KV Data，RaftEngine 存储 Raft Meta 和 Raft Data。其中有一个 Apply Snapshot 的场景会同时原子地修改这两个 Engine，但可惜这两个 Engine 无法做到原子地落盘。并且因为两个 Engine 中都存有 Meta 和 Data，所以任意的先后顺序，都会导致数据不一致。这里的解决方式是将 RaftEngine 中的的 Raft Meta 写到 KVEngine 中，称为 Snapshot Meta。写入的时候，会先写 KVEngine，再写 RaftEngine。当在两个非原子写入中间出现宕机，从而不一致的时候，会使用 KVEngine 中的 Raft Meta 替换 RaftEngine 中的 Raft Meta。</p><p>在<a href="https://github.com/tikv/tikv/blob/1ce8ee7df84503e889ff8bc6834a57128a858a16/components/raftstore/src/store/peer_storage.rs#L645" target="_blank" rel="noopener">Apply Snapshot</a>阶段开始时，它会调用 <code>clear_meta</code> 删除掉 KV Meta、Raft Meta 和 Raft Data，但这个删除是不应该立即落盘的，而是在 WriteBatch 里面。在这之后，还会再往 WriteBatch 中写入 Snapshot Meta 等。这些写入会被一起发送给一个 Async Write 写入。我们的错误是，在实现删除 Raft Engine 数据时，并不是写 Write Batch，而是直接写盘。在 <code>clear_meta</code> 之后系统又立即宕机了。这样重启恢复后，就会看到空的 Raft Meta 和 Raft Data，但 KV Meta 却还存在。这是一个 Panic 错误，因为两个 Meta 不一致了。</p><p>这样的错误是难以调查的，我们可以加日志获得重启后从磁盘中读到的结果，但仍然不知道这个结果是如何被写入的。查的方式是脑补，也就是针对这样的场景，假设在不同时刻宕机，考虑会出现什么样的持久化状态。<br>这里，KV Meta 的落盘信息是有的，它可能是没清就宕机了，也可能是写完新的数据之后宕机的。考量这个可以看一些 Meta 信息有没有写入，比如我们发现 Snapshot Meta 并不存在，因此说明是前一种情况。既然如此，为什么 Raft Meta 和 Data 都没了呢？只能说明是 Raft 的清早了。</p><p>当然，这里有个迷惑点，就是 KV Meta 提示当前是在 Applying Snapshot 状态，而如果我们是第一种情况的话，这个 Applying 状态应该还没有被写入。这个原因是这个实例发生了多次重启，在 T-2 次启动后 Apply Snapshot 时，KVEngine 和 RaftEngine 都落盘成功了，但是后续的流程没进行下去就重启了。所以在 T-1 次启动会重新 Apply Snapshot，但这一次甚至没到落盘就重启了，而 Snapshot Meta 是金标准。然后就是我们见到的 T 次启动的错误。这启示我们不能只通过一个元数据来判断当前集群的状态，而是要检查所有的元数据，来石锤当前状态是如何得到的。</p><h2 id="Multi-Raft-的思考"><a href="#Multi-Raft-的思考" class="headerlink" title="Multi Raft 的思考"></a>Multi Raft 的思考</h2><h3 id="共识层和事务层的关系"><a href="#共识层和事务层的关系" class="headerlink" title="共识层和事务层的关系"></a>共识层和事务层的关系</h3><p>TiKV 的共识层在事务层之下。在事务 Commit 之前的很多数据也会被复制到多数节点上，这产生了一些写放大。但也需要注意其带来的好处：</p><ol><li>共识层实际为 Percolator 提供了类似 BigTable 的存储。<br> 首先提供了外部一致性。<br> 然后提供了 PUT default/PUT lock 和 PUT write/DEL lock 的原子性写入。<br> 当然，这里要先读后写，可能会有 Write Skew。</li><li>共识层本身也可以作为一个 Raw KV 对外服务。</li><li>Percolator 事务的定序依赖于存储于共识层上 lock 中的时间戳。<br> 当然这也存在一个 argue 点，因为 Raft Log 本身也是 total order 的。看起来会有一些冗余。</li></ol><p>特别地，在 CDC 服务和 TiFlash 中，我们实际上不会处理未 Commit 的数据。</p><h3 id="共识序和事务序"><a href="#共识序和事务序" class="headerlink" title="共识序和事务序"></a>共识序和事务序</h3><p>目前 TiKV 通过一个 pd 分配一个全局的 tso 来作为事务的 start_ts 和 commit_ts，所以它们之间彼此构成全序关系。通过 start_ts 和 commit_ts 可以构建有依赖的事务之间偏序关系，也可以用来判断事务是否是 concurrent 的。当时，如果在单个节点上串行地 commit 这些事务，这样做的代价太大了。<br>为了解决这个问题，TiKV 在多个线性一致的存储(Region)上储存这些事务，它保证了每个事务在每个 Region 上都遵循了 start_ts 和 commit_ts 所 imply 的顺序，也 Percolator 那一套。这样尽管各个 Region 之间是并发的了，但只要 Region 内遵循这个 order 就行了。这实际上也减弱了查询的约束，只需要遵循 raft 序就行了。</p><p>当然，这个切分也未必是按照 Region 来，比如 CDC 会使用表来切分。无论按照哪种方式来切分，我觉得一个实现的要点是每个 shard 在调度上是不可以再分的了。比如一个 Region 的一部分数据在 store 1 上，另一部分数据在 store 2 上，这样做实际上会导致无论在 store 1 和 store 2 上都很难独立构建出该 Region 上数据的全序关系，比如 store 1 如果不和 store 2 交互，那么就很难知道 store 2 上还有没有 happen before 它的事务了。比如说，如果两个 store 上 apply 这个 Region 的 log 的进度不一样。</p><h3 id="Split-Merge-和事务"><a href="#Split-Merge-和事务" class="headerlink" title="Split/Merge 和事务"></a>Split/Merge 和事务</h3><h3 id="Split-Merge-和-Read"><a href="#Split-Merge-和-Read" class="headerlink" title="Split/Merge 和 Read"></a>Split/Merge 和 Read</h3><p>Split 和 Merge 会导致 Region 发生变化，自然也可能会影响读取。主要体现在下面几个方面：</p><ol><li>影响 Lease 本身或者 Lease 续约</li><li>推高 RegionEpoch 从而导致 ReadIndex 失败</li></ol><h3 id="Split-Merge-和-Apply-Snapshot"><a href="#Split-Merge-和-Apply-Snapshot" class="headerlink" title="Split/Merge 和 Apply Snapshot"></a>Split/Merge 和 Apply Snapshot</h3><p>Multi Raft 实现的复杂度，很大程度在处理 Split/Merge 和 Apply Snapshot 的冲突上。</p><h4 id="Split-和-Apply-Snapshot-的冲突"><a href="#Split-和-Apply-Snapshot-的冲突" class="headerlink" title="Split 和 Apply Snapshot 的冲突"></a>Split 和 Apply Snapshot 的冲突</h4><p>我们需要处理一个 Region 上的 Follower 还没有执行到分裂为 Base 和 Derived 前，一份来自 Derived 的 Snapshot 已经被发过来的情况。这会产生 Region Overlap 的问题，在一些下层存储中会导致数据损坏。一种方案是在 Base 完成分裂前根据 Epoch 拒绝掉这些 Snapshot。</p><h4 id="Merge-和-Apply-Snapshot-的冲突"><a href="#Merge-和-Apply-Snapshot-的冲突" class="headerlink" title="Merge 和 Apply Snapshot 的冲突"></a>Merge 和 Apply Snapshot 的冲突</h4><p>Merge 过程可以简单理解为下面几步：</p><ol><li>调度 Source 和 Target Region 的各个 Peer，让它们对齐到同一个 Store 上。</li><li>Source Peer 执行 Prepare Merge。</li><li>Source Peer 等待 Target Peer 追完 Source Peer 的日志。</li><li>Source Peer 对 Target Peer 去 Propose Commit Merge。</li><li>Target Peer 执行 Commit Merge。</li></ol><p>可能在下面一些阶段收到 Snapshot：</p><ol><li>Prepare Merge 结束</li><li>Leader 上的 Commit Merge 结束，但 Follower 上的 Commit Merge 还没有开始</li></ol><h4 id="Split-和-Generate-Snapshot-的冲突"><a href="#Split-和-Generate-Snapshot-的冲突" class="headerlink" title="Split 和 Generate Snapshot 的冲突"></a>Split 和 Generate Snapshot 的冲突</h4><p>主要指 Split 等会改变 RegionEpoch 从而导致 Snapshot 失效。</p><h3 id="Raft-Group-和-Region-的对应关系"><a href="#Raft-Group-和-Region-的对应关系" class="headerlink" title="Raft Group 和 Region 的对应关系"></a>Raft Group 和 Region 的对应关系</h3><p>TiKV 中，Raft Group 和 Region 严格一一对应。在这里将 Region 看做一段范围内的数据。讨论下这个设计：</p><ol><li>Raft 本身和 Region 数据的版本引入了全序关系<br> 首先，Raft Admin Command 会穿插在写入之间形成很多 barrier，带来额外的持久化负担。<br> 然后，这导致了新创建的 peer 只能通过 Snapshot 追进度的情况。从 Raft 协议来看，ConfChange 之前的日志的提交和复制应当遵守 C_old 的配置项目，但是它并没有禁止进入 C_new 状态的 Leader 给新 peer 发送 ConfChange 之前的日志。但考虑到如果新 peer 还在处理 C_old 时代的日志，它的本地状态比如 RegionLocalState 肯定对应了 C_old，这个时候它接受到了一个“不认识”的 store 的 AppendEntries，这是比较奇怪的。</li><li>Raft Group 不稳定<br> Split 会分出独立的 Raft Group，给 pd 调度带来压力。也变相增大了 recover 的工作量。<br> Merge 两个 Region 会销毁一个 Raft Group，这里面有不少 corner case。比如 Leader 关掉后的孤儿 Learner 问题。</li></ol><p>我觉得可能 Spanner 的架构会更好一点。也就是说：</p><ol><li>一个 “Spanner Region” 一个 Raft Group，但这个 “Spanner Region” 不再和某个 Key range 绑定。</li><li>一个 “Spanner Region” 下可以被调度多个 Key range。例如有局部性的 Key range 可以被调度在一起，或者处于打散负载的目的可以将 Key range 进行随机的分布。</li></ol><p>但是这样的架构下，一个 Raft Group 可能需要处理不同 Key range 的数据。但这里的全局关系肯定是过强了，所以这里会更倾向于引入乱序 Apply 机制来提高 RSM 的吞吐量。</p><h3 id="Raft-日志的内容"><a href="#Raft-日志的内容" class="headerlink" title="Raft 日志的内容"></a>Raft 日志的内容</h3><p>Raft 日志中到底记录什么呢？可以看下面的总结：</p><ol><li>TiKV<br> TiKV 中 Raft 日志分为 Admin 和 Write。Admin 基本只和 Raft 和 Region 管理有关。Raft 指的是 Raft 的成员变更，比如 Add/Remove Voter/Learner，TransferLeader 等。Region 指的是管理的 key range 的元数据变更，比如 Split、Merge、数据校验等。<br> Admin 和 Write 在一起构成全序关系，这个话题之前已经展开讨论过了。<br> Write 包含 Put、Delete、DeleteRange 和 IngestSST，这些都是逻辑日志，或者说是不 aware 下层 rocksdb 的。</li><li>OceanBase<br> OceanBase 中复制的是 clog。从<a href="https://en.oceanbase.com/docs/common-oceanbase-database-10000000001029737" target="_blank" rel="noopener">文档</a>来看，它们复制的是物理日志。通过 replay clog，能够得到同样的 log 文件，其中记录的是 redo log。<br> 下面来自<a href="https://www.oceanbase.com/docs/community-observer-cn-10000000000016344" target="_blank" rel="noopener">Oceanbase文档</a><blockquote><p>OceanBase 数据库单台物理机上启动一个 observer 进程，有几万到十万分区，所有分区同时共用一个 Clog 文件，当写入的 Clog 文件超过配置的阈值（默认为 64 MB）时，会打开新的 Clog 文件进行写入。<br>OBServer 收到的某个分区 Leader 的写请求产生的 Clog、其他节点 OBServer 同步过来的 Clog（存在分区同在一个 Paxos Group)，都写入 Log Buffer 中，由单个 IO 线程批量刷入 Clog 文件。</p></blockquote></li><li>PolarDB<br> 在《PolarFS: An Ultra-low Latency and Failure Resilient Distributed File System for Shared Storage Cloud Database》中讲得比较清楚。<br> PolarDB 的存储层基于 PolarFS，计算节点共享地访问这个存储层。PolarDB 中每个数据库对应 PolarFS 中的一个卷，每个卷由若干 Chunk 组成。不同于 TiKV 的 Region，这里 Chunk 大小为 10GB，而卷的大小在 10GB 到 100TB 之间，所以它们元数据节点的调度压力会小很多，并且所有节点的元数据都可以缓存在内存中。一个 Chunck Server 管理多个 Chunk，PolarDB 通过增加 ChunkServer 的数量来平衡热点。这里我觉得 TiKV 的 multi rocks 方案可能更好，因为它允许一个 hot region 被分裂。在 PolarDB 中，一个服务器上运行多个 ChunkServer，但每个 ChunkServer 对应一个专用的 SSD，并且绑定一个专用的 CPU 核心。<br> 一个 Chunk 由 64KB 大小的 block 组成。PolarFS 的 Raft 日志实际复制的是这些 block 的 WAL。</li></ol><h3 id="进一步讨论：日志和选举的关系"><a href="#进一步讨论：日志和选举的关系" class="headerlink" title="进一步讨论：日志和选举的关系"></a>进一步讨论：日志和选举的关系</h3><p>Raft 中的领导人完全性原则要求 Leader 必须拥有所有已提交的日志，这实际上是一个比较强的约束。在 Ongaro 等人对于 MultiPaxos 的描述中，可以发现该约束是可以被消减掉的，从而选举过程可以不关注日志的完备性。<br>在此基础上，可以让选举体现出其他的优先级。以 Ob 的 Palf 为例，它的“一呼百应”的方案，可以始终给距离自己最“近”的节点投票。而 Raft 选举的实质是谁状态更新，谁就更容易当选。这个方案目前来看，无论是否效果最优，但确实代价比较大。</p><p>有关 Raft 的日志和选举关系的讨论，可以见 <a href="/2019/03/12/raft-algorithm/">Raft 算法介绍中的“日志和选举”章节</a> 详细讨论。</p><h3 id="进一步讨论：日志和事务的关系"><a href="#进一步讨论：日志和事务的关系" class="headerlink" title="进一步讨论：日志和事务的关系"></a>进一步讨论：日志和事务的关系</h3><p>将多个分区的写入统一到一个 Raft Group 中进行复制，应该是有利于事务的。因为如果一个事务跨 Region，就会是一个分布式事务，而如果只有一个 Raft Group，那么就不会涉及到跨 Region 的问题。</p><h3 id="Mono-LSM-和-Multi-LSM-的考量"><a href="#Mono-LSM-和-Multi-LSM-的考量" class="headerlink" title="Mono LSM 和 Multi LSM 的考量"></a>Mono LSM 和 Multi LSM 的考量</h3><p>这里指的是不同的 Region 的数据是否 share 一个 LSM 树。我认为如果使用 range partition，那么 multi lsm 的策略是一个非常重要的优化。</p><h2 id="线性一致读"><a href="#线性一致读" class="headerlink" title="线性一致读"></a>线性一致读</h2><h3 id="Follower-Read"><a href="#Follower-Read" class="headerlink" title="Follower Read"></a>Follower Read</h3><p>TiDB 支持<a href="https://docs.pingcap.com/zh/tidb/stable/follower-read" target="_blank" rel="noopener">多种读取方式</a>，例如最近 Peer、Leader、Follower、Learner、自适应等多种模式，这些依赖于 Follower Read，在这之前都需要从 Raft Leader 读取。</p><p>不同于 ParallelRaft 和 MultiPaxos 的部分实现，TiKV 会串行地 apply raft log。这样的好处是，更容易通过 Read Index 实现 Follower Read 了。<br>但这样的坏处是，引入了更强的全序关系。而实际上不少无关的写入之间是没有全序关系的，而定序的工作可以由事务层来完成一部分。TiKV 在这一点上行得通，主要还是因为它的数据和 Raft Group 绑定的缘故。也就是以 scheduler 为代价来实现分区，从而减少各个 Raft Group 的压力。</p><h3 id="Learner-Read"><a href="#Learner-Read" class="headerlink" title="Learner Read"></a>Learner Read</h3><p>不同于 Follower，Learner 不是 Voter，没有选举功能。所以 Learner Read 和 Follower Read 有不同。<br>Learner Read 在 TiFlash 场景下更为丰富，在 TiFlash 章节讨论。</p><h3 id="Stale-Read"><a href="#Stale-Read" class="headerlink" title="Stale Read"></a>Stale Read</h3><p>Stale Read 是读 ts 时间点上所有已提交事务的旧数据。因为读不到最新的写入，所以不是强一致的。但它仍然保持有<a href="https://docs.pingcap.com/zh/tidb/stable/stale-read" target="_blank" rel="noopener">全局事务记录一致性</a>，并且不破坏隔离级别。Stale Read 可以让读请求被分配到任一节点上，从而避免某热点机器，或者跨数据中心的 read index 请求产生的延迟。</p><p>所以它并不是“弱一致读”，无论从哪一个节点返回的结果都是一致的，不会出现 A 返回 1000 笔记录，而 B 返回 1111 笔记录的情况。</p><h1 id="事务相关"><a href="#事务相关" class="headerlink" title="事务相关"></a>事务相关</h1><h2 id="加锁的时机"><a href="#加锁的时机" class="headerlink" title="加锁的时机"></a>加锁的时机</h2><p>无论是悲观锁还是乐观锁，都面临加锁时机的选取。</p><p>在提交时加锁存在下面的问题：</p><ol><li>乐观锁的问题</li><li>因为整个事务需要缓存在内存中，所以大事务面临 OOM</li></ol><p>在 DML 时加锁存在下面的问题：</p><ol><li>每写一个 key 都要和 TiKV 通讯一次</li><li>多次对同一个 key 的 prewrite 无法确认先后（网络可能被任意延迟）</li><li>对 TiFlash 而言，因为列需要按照 commit_ts 排序，所以最好等到 commit 之后再行转列，而 DML 加锁意味着 DML 阶段 prewrite，那么在 DML 阶段就可以行转列了</li></ol><h2 id="Percolator-事务和共识层乱序"><a href="#Percolator-事务和共识层乱序" class="headerlink" title="Percolator 事务和共识层乱序"></a>Percolator 事务和共识层乱序</h2><p>在什么程度上共识层可以乱序呢？我的结论是：</p><ol><li>跨 Region 情况下会破坏线性一致读，并且从事务层修正的难度比较大，可能引入很长的等待</li><li>单 Region 上，如果保证 Lock 和 Write 的全局序，但只在发现事务 A 的第一个 commit 的时候，将事务相关的所有的 Default 写入，这种情况应该是可以的。对于较为基础的 case 我有 tla 证明<br> 根据具体实现，需要落盘 Default 和 Lock 是一起的，比如先落盘 Lock 再落盘 Default。可以不用原子落盘两个 cf。</li></ol><h1 id="Partitioned-RaftKV-相关"><a href="#Partitioned-RaftKV-相关" class="headerlink" title="Partitioned RaftKV 相关"></a>Partitioned RaftKV 相关</h1><h2 id="和-Mono-store-RaftKV-的兼容性问题"><a href="#和-Mono-store-RaftKV-的兼容性问题" class="headerlink" title="和 Mono-store RaftKV 的兼容性问题"></a>和 Mono-store RaftKV 的兼容性问题</h2><p>新架构简化了 Snapshot 的生成和注入流程：</p><ol><li>在生成时，只需要对当前 Region 对应的 RocksDB 做一个 Snapshot 就行。这个 Snapshot 包含的数据可以新于 Raft Local State。</li><li>在注入时，只需要重命名 RocksDB 文件夹即可。不需要处理 range overlap 的问题。因此不需要引入单线程的 region worker。</li></ol><p>因此 Mono-store RaftKV 需要处理下列问题：</p><ol><li>RocksDB 数据和 Raft 状态不一致。</li><li>Snapshot 的 Range 可能和其他本地 Region Overlap。</li></ol><p>不光是 Snapshot，在 Partitioned RaftKV 中，Region Peer 之间也可能互相 Overlap。所幸这个场景只会出现在 BatchSplit 和调度 Peer 发生冲突的情况下。</p><p>在新架构中，Apply 的落盘也实现了异步化，现在下层引擎可以选择在任意时刻落盘数据，并且在落盘完毕后通知 raftstore。这对 TiFlash 来说是一件好事，我们可以由此来让 KVStore 的落盘不再阻塞。</p><h2 id="采用更大的-Region-的性能影响"><a href="#采用更大的-Region-的性能影响" class="headerlink" title="采用更大的 Region 的性能影响"></a>采用更大的 Region 的性能影响</h2><ol><li>可以采用 Parallel Raft 的方式实现并行 Apply。</li><li>单个 Region 的 Apply 压力会增大，但是下层 RocksDB 的负担减轻了。相比于单个实例的 RocksDB，新架构的层数更少，并且并发写入也更少。后续还可以尝试支持多盘部署。</li></ol><p>另一个考量点是如果集群中出现很多小表，那么大 Region 的效果不能完全展示：</p><ol><li>因为编码的问题，table 编码不相邻的表不能被合并到同一个 Region 中。</li><li>相邻的 table 合并会给 TiFlash 带来不少问题。例如如果给一些小表添加 TiFlash 副本，并且这个小表被合并到一个大 Region 中，那么发来的 Snapshot 可能非常大，并且包含了大量 TiFlash 不需要的数据。此外，TiFlash 本身的存储引擎也需要做出调整。</li></ol><h1 id="TiFlash-相关"><a href="#TiFlash-相关" class="headerlink" title="TiFlash 相关"></a>TiFlash 相关</h1><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="为什么-TiFlash-实现-HTAP-基于-Raft？"><a href="#为什么-TiFlash-实现-HTAP-基于-Raft？" class="headerlink" title="为什么 TiFlash 实现 HTAP 基于 Raft？"></a>为什么 TiFlash 实现 HTAP 基于 Raft？</h3><p>Raft 帮助我们实现：</p><ol><li>LB</li><li>HA</li><li>Sharding</li></ol><p>但是 TiFlash 只通过 Raft 同步各个表的 record 部分的数据。我们不同步索引，因为不需要。我们不同步 DDL 相关结构，因为并不是所有表都存在 TiFlash 副本。取而代之的是在解析失败，或者后台任务中，定期取请求 TiKV 的 Schema。</p><p>另一种强一致的方案是基于 CDC 和 safe TS，这样的方案理论上达不到和 Raft 一样的性能。这是因为类似 CDC 的方案的 safe TS 是基于表的，而 Raft 的 applied_index 是基于 Region 的。在一些场景下，如果一个 write 涉及到多个 Region，那么为了保证原子性，需要这些 Region 上的数据全部被写完，才能前进 ts，这会影响大事务的同步效率。另外，在读取时，也需要等待 safe TS 前进之后，才能读取。而基于 Raft 的方案只需要相关的 Region 的 applied_index 前进到 ReadIndex 就可以了。另外，CDC 也只保证单表事务。</p><h3 id="为什么在-TiSpark-之外还开发-TiFlash"><a href="#为什么在-TiSpark-之外还开发-TiFlash" class="headerlink" title="为什么在 TiSpark 之外还开发 TiFlash"></a>为什么在 TiSpark 之外还开发 TiFlash</h3><p>TiSpark 直接操作 TiKV，绕过了事务层，可能产生一致性问题。<br>TiSpark 没有自己的列式存储，处理分析性查询并不占优势。</p><h3 id="TiFlash-是副本越多越好么？"><a href="#TiFlash-是副本越多越好么？" class="headerlink" title="TiFlash 是副本越多越好么？"></a>TiFlash 是副本越多越好么？</h3><p>不是。理论上是 1 副本的性能最好，但是考虑到高可用，通常建议 2 副本。</p><p>1 副本性能最好的原因是，DeltaTree 的 Segment 的粒度要显著比 TiKV 的 region 大，因此同一个 Segment 上会存在多个 Region。</p><p>考虑存在 4 个 Region，从 A 到 D，如果只设置一个副本，其分布类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store1: [A0, B0]</span><br><span class="line">Store2: [C0, D0]</span><br></pre></td></tr></table></figure><p>而如果设置两个副本，其分布类似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Store1: [A0, B0, C0, D0]</span><br><span class="line">Store2: [A1, B1, C1, D1]</span><br></pre></td></tr></table></figure><p>假如一个查询同时覆盖这 4 个 region，那么一副本的情况下，Store1 和 Store2 分别扫描自己的一部分数据就行了。而两副本的情况下，则可能扫描到多余的 Region 的数据。</p><p>有一些人还会觉得副本数越多，并发能力越强。但在基于 Raft 的分区策略下，并发能力是通过合理的 Sharding 来提升的。而具体到一个副本上是可以支持大量的并发查询的，并且我们也更容易对这些查询做 Cache，当然在 AP 场景下可能有限。</p><h3 id="DDL-如何同步？"><a href="#DDL-如何同步？" class="headerlink" title="DDL 如何同步？"></a>DDL 如何同步？</h3><p>TiDB 的 DDL 的优化点：</p><ol><li>延迟 reorg 到读<br> 例如 add column 的 reorg 阶段实际上不会写入默认值，而是在读的时候才返回默认值。</li><li>以新增代替变更<br> 例如 alter column 只会扩大列的值域，比如 int8 扩大为 int64。如果涉及缩小至于或者改变类型，则会体现为新增一个 column，然后把老的 detach 掉。<br> 因此新的 Schema 能够解析老的 Schema。</li></ol><p>TiFlash 上 DDL 的特点：</p><ol><li>TiFlash 只需要同步需要表的 DDL。</li><li>TiFlash 只需要同步部分 DDL 类型，诸如 add index 等 DDL 并不需要处理，更没有 reorg 过程。</li><li>尽管 TiDB 将 schema 存在 TiKV 上，但 TiKV 是 schemaless 的。所以如果 TiFlash 只从 TiKV 同步数据，就会涉及解码等工作。</li></ol><p>因此，TiFlash 有两种 DDL 同步方式：</p><ol><li>定期拉取（一般是 10s）并更新<br> 根据 TiFlash 和 TiDB 上 version 落后的情况，可以分为拉 diff 和拉全量。<br> 该方式已经能解决大部分 drop table 的问题了。但通过该方式无法保证当前任意时间点上的 schema 一定和 TiDB 是一致的，所以一定存在解析失败的情况。</li><li>当解析 row 失败的时候更新 schema，称为 lazy sync</li></ol><p>在更新之后，TiFlash 会自己维护一份 schema。</p><p>这里面存在的问题主要是两种 DDL 同步方式和实际 raft log 是异步的。因为 TiDB 和 TiFlash 的特点，这个异步是可以被处理的，并且尽可能去掉全序的依赖是很多系统的设计理念，所以这种做法本身也是挺好的，但其中 corner case 很多。例如：</p><ol><li>Schema 和 row data 中的列数对不上。这种情况无论是谁缺，至少可以通过拉一次 Schema 来解决。有些场景甚至可以不拉 schema。</li><li>某个列的类型变了</li><li>一张表 drop 后，TiKV 中就无法读取该表的 schema 了。如果在 drop 前有一条 add column，但 lazy sync 又没有读到，那么 TiFlash 就看不到。所以如果后续有一条 row 写入过来，TiFlash 就会丢弃这个 column。假如这个 table 被 recover 了，那么 TiFlash 就会读不到这个 column 的数据。</li><li><a href="https://github.com/pingcap/tiflash/pull/8422" target="_blank" rel="noopener">在</a>一张表对应的 DeltaMerge 实例创建前，这张表就被 drop 掉了。在此之后，row 数据到来，并导致 DeltaMerge 实例被创建。</li></ol><h3 id="TiFlash-的高可用"><a href="#TiFlash-的高可用" class="headerlink" title="TiFlash 的高可用"></a>TiFlash 的高可用</h3><p>对于复制自动机的系统，高可用主要取决于选举的速度。<br>对于 TiFlash 来说，它不参与选举，但选举本身同样会有影响，一方面是 ReadIndex，另一方面是无主的时候无法复制日志。但除此之外，TiFlash 自身的宕机和重启也影响高可用。因为一个批量查询会被下推给 tiflash，以避免影响 TP，如果此时 TiFlash 没追上，则查询会 hang 住。所以 TiFlash 的高可用还和追日志的规模有关。</p><h2 id="Raft-共识层"><a href="#Raft-共识层" class="headerlink" title="Raft 共识层"></a>Raft 共识层</h2><h3 id="有关-Learner-的问题"><a href="#有关-Learner-的问题" class="headerlink" title="有关 Learner 的问题"></a>有关 Learner 的问题</h3><h4 id="Peer-活性"><a href="#Peer-活性" class="headerlink" title="Peer 活性"></a>Peer 活性</h4><p>Learner 尽管在 Raft Group 中，但不参与投票。所以当 Voter 节点因为 Region 被销毁（通常因为 merge）全部被销毁后，Learner 节点就无法找到 Leader 节点。对于 Voter 节点来说，这种情况它可以发起选举，然后发现其他节点上的 Tombstone 标记，从而确认 Region 已经被摧毁了。但因为 Learner 不参与投票，所以是无法发现这种情况的，从而僵死。这给 TiFlash 带来了不少 Corner Case：</p><ol><li>在 Region 销毁的场景如 CommitMerge，target region 的 Voter 至少可以在 Leader 销毁之后，因为超时触发选举，从而启动自毁。而 Learner 则不行，会 miss leader 然后卡死<br> 特别地，CommitMerge 本身对 Source Peer 也会有检查，所以这里可能造成连环等待。比如如果在等待 Source 追数据，就会 Yield 为 WaitMergeSource。如果卡在 CommitMerge 上，那么后续的 RemovePeer 也无法执行。</li><li>在 ConfChange 中，如果删除了某个 Learner，但又没有能够将该日志复制给 Learner，那么稍后 Learner 就不会得到 Leader 的任何消息，从而一样卡死。</li><li>在 BatchSplit 中，如果新 Split 出来的 Region 在 TiFlash apply BatchSplit 命令前就在所有 Voter 节点中被删除的话，后续 TiFlash 节点即使 apply 完 BatchSplit，也无法再收到任何日志，因为 Leader peer 已经不存在了</li></ol><p>上述的卡死在之前需要等待 2h 之后触发存活性检查才会被发现。或者人工将僵死的 Region peer 设置为 tombstone 状态。</p><h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>另外，Raft Log GC 也需要 respect Learner 的进度，不然会导致频繁的 Snapshot 生成失败。</p><h3 id="有关-LearnerRead"><a href="#有关-LearnerRead" class="headerlink" title="有关 LearnerRead"></a>有关 LearnerRead</h3><p>由 Follower Read 派生出来的 Learner Read 也让 TiFlash 成为一个强一致的 HTAP。</p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="为什么在列存前还有一个-KVStore？"><a href="#为什么在列存前还有一个-KVStore？" class="headerlink" title="为什么在列存前还有一个 KVStore？"></a>为什么在列存前还有一个 KVStore？</h3><p>在 CStore 模型中，WS 和 RS 都是列存，WS 的数据通过 Tuple Mover 被批量合并到 RS 中。体现在 TiFlash 中，WS 是 DM 中基于 PS 的 Delta 层，而 RS 是 Stable 层。</p><p>除此之外，TiFlash 还有一个 KVStore，目的是：</p><ol><li>保存未提交的数据，并实现 Percolator 事务的部分功能<br> 因为只有已提交的数据才会写入行存，为了和 Apply 状态机一致，所以未提交的数据同样需要持久化，因此引入 KVStore。</li><li>KVStore 管控 Apply 进度，对 DM 屏蔽了上游。DM 可以异步落盘。日志复制的架构下，上游的落盘进度不能比下游更新，因为下游更新，重放是幂等的；而上游更新，会丢数据。</li></ol><p>为什么不将未提交的数据直接写在列存中呢？</p><ol><li>KVStore 需要负责维护 apply 状态机<br> 当然我们可以将这一部分作为单独的 Raft 模块，所以这不是很 solid 的理由。</li><li>KVStore 不仅是一个容器，还是 Percolator 事务的执行器<br> 例如，它需要维护当前 Region 上的所有 Lock。在一个查询过来时，需要检查该查询是否和 Lock 冲突，并尝试 resolve lock。而在列存中维护 lock cf 会很奇怪。</li><li>这意味着要执行近乎实时的行转列<br> 首先，如果存一些未提交数据在 KVStore 中，然后在提交时 batch 执行行转列，有可能可以只读取一次 schema 结构，减少开销。<br> 其次，TiDB 中存在乐观事务和悲观事务。如果使用乐观事务，并且冲突比较大，那么很可能 TiFlash 要花费大量时间在多余的行转列上。</li></ol><h3 id="KVStore-的落盘模式相关问题"><a href="#KVStore-的落盘模式相关问题" class="headerlink" title="KVStore 的落盘模式相关问题"></a>KVStore 的落盘模式相关问题</h3><p>理论上 KVStore 也可以做到独立写盘，从而使得 DM 的落盘进度不会阻塞 Raft Log 的回收。缺点是会使 KVStore 完全变成上游，写链路更长。虽然我们底层用的 PS，Compaction 相对较少，但同样有写放大。但这目前也无法实现，因为：</p><ol><li>KVStore 落盘是全量的，KVStore 和 DM 的内存操作又绑在一块。<br> 这导致在落盘 KVStore 前必须先落盘 DM。并且整个过程还需要加自己的锁，否则会导致数据丢失，而加锁导致阻塞 Apply。特别在一些场景下，少量的 Raft Log 就会导致 KVStore 和 DM 的落盘，严重影响读取延迟。</li><li>Raftstore V1 的 Apply 落盘又是同步的。<br> 在 Raftstore V1 中，写入的数据可能在操作系统的 Page Cache 中，也有可能被刷入了磁盘。如果是前者，那么会在 raftlog_gc 等地方被显式地 sync。但困难在于，V1 中无法精确获得这些时刻，从而进行通知。又因为 TiFlash 的状态不能落后于 Proxy，否则 Proxy 的 applied_index 可能比 KVStore 新从而丢数据。所以这里索性当做同步落盘处理，让 TiFlash 先落盘。代价是我们要劫持 TiKV 所有可能写 apply state 的行为，哪怕这个写不是 sync 写。后面会介绍我的一些异步落盘的想法。</li></ol><p>一个优化方案是解耦 KVStore 和 DM 的落盘。也就是在 DM 落盘后，再清理掉 KVStore 中的数据。这需要将 Region 中的数据拆分成 KV 对落盘，但这会失去对 KV 对做聚合的能力，从而将顺序写转换为随机写，如果写入很密集，性能也许会比较差，所以这个在功能和性能上都依赖 UniPS。</p><p>另一种方案比较简单，也就是限制由 KVStore，实际上就是 Raftstore 发起的落盘，改为由 DM 发起。但这个方案并不感知 Raft Log 的占用，可能导致它膨胀。</p><p>前面提到异步落盘 KVStore 的问题，一个思路是落盘时使用过去的状态+当前的数据。但存在一些问题：</p><ol><li>这个“过去的状态”也需要比 DM 的落盘状态要新，所以还是要先加锁获取 KVStore 状态，再无锁落盘 DM，再用旧状态落盘 KVStore。这样不能解耦和 DM 的落盘，但能够在落盘 DM 的时候无锁已经很好了。</li><li>Split/Merge 或者可能 Apply Snapshot 改变了全局状态。这样的指令在 V1 中是不能被重放的，不然新 Split 出来的 Region 可能和重启前已经被 Split 和 Persist 出来的 Region 冲突。这样就需要在处理这些 Admin 指令的时候同步等待异步的 Persist 完成。其实更简单的方式是根据之前加锁获取的状态来推断有没有执行这些 Admin。</li><li>需要让 KVStore 支持其他命令的重放。目前来看，应该存在一些 corner case。</li><li>需要让 KVStore 通知 Proxy，当前落盘的 applied_index 并不是期望的 applied_index。这实际上破坏了 TiKV 的 MultiRaft 约束，更好的方式是拒接来自 Proxy 的落盘请求，然后从 KVStore 重新主动发起一个。</li><li>落盘 KVStore 同样需要加锁，从而阻塞 Raft 层的写入。</li></ol><p>另一种方案是过去的状态和过去的数据。比如可以在 KVStore 在落盘时，新开一个 Memtable 处理新写入。此时需要处理新 Memtable 上的 Write 可能依赖老 Memtable 上的 Default 之类的问题。这样的好处是在落盘 KVStore 的时候都不需要加锁了。但是还存在两个问题：</p><ol><li>在这前面需要落盘 DM，当然这个锁先前说了可以去掉。</li><li>如果写入很大，那么可能在旧的 Memtable 还没写完之前，新的 Memtable 就满了。这样还是 Write Stall。</li></ol><p>如果希望彻底和 DM 解耦，就需要想办法保存上次 DM 落盘到现在落盘 KVStore 期间被写到 DMCache 上的数据。这是困难的。</p><h3 id="KVStore-如何处理事务"><a href="#KVStore-如何处理事务" class="headerlink" title="KVStore 如何处理事务"></a>KVStore 如何处理事务</h3><p>在每一次 Raftstore 的 apply 写入时，会遍历所有 write 写入，并进行事务提交，也就是将数据从 KVStore 移动到 DeltaMerge。事务提交并不一定落盘，大部分情况是写在 DeltaMerge 的 DeltaCache 中的。<br>如果出现事务 rollback 回滚，则 TiKV 不仅会删除掉之前写的 default 和 lock，还会写一条 Rollback 记录，它也会被写到 Write CF 中，其用途是避免同 start_ts 事务再次被发起，client 需要用新请求的 start_ts。<br>可以看到，因为共识层的存在，TiFlash 无需处理事务 rollback 的问题。这也是 KVStore 存在的意义之一。</p><h3 id="KVStore-的存储格式"><a href="#KVStore-的存储格式" class="headerlink" title="KVStore 的存储格式"></a>KVStore 的存储格式</h3><h4 id="是否直接用-protobuf-存储-Region？"><a href="#是否直接用-protobuf-存储-Region？" class="headerlink" title="是否直接用 protobuf 存储 Region？"></a>是否直接用 protobuf 存储 Region？</h4><p>protobuf 具有的几个特性让它不适合存储 Region：</p><ol><li>较大的 size 下性能较差</li><li>不能只读取部分数据</li></ol><h4 id="是否使用-flag-存储-Region-Extension？"><a href="#是否使用-flag-存储-Region-Extension？" class="headerlink" title="是否使用 flag 存储 Region Extension？"></a>是否使用 flag 存储 Region Extension？</h4><p><a href="https://github.com/pingcap/tiflash/issues/8590" target="_blank" rel="noopener">https://github.com/pingcap/tiflash/issues/8590</a> 不建议这样做。</p><h3 id="Raft-机制带来的内存和存储开销"><a href="#Raft-机制带来的内存和存储开销" class="headerlink" title="Raft 机制带来的内存和存储开销"></a>Raft 机制带来的内存和存储开销</h3><p>有没有可能 TiFlash 自己 truncate 日志呢？理论上 Learner 不会成为 Leader 从而发送日志，也不会处理 Follower Snapshot 请求。而 Raft 协议本身就是让每个节点自己做 Snapshot 然后 truncate 日志的。</p><p>我们在云上 TiFlash 做这样的优化，因为云上使用的 UniPS 对内存更敏感。PageDirectory 为每个 Page 占用大约 0.5KB 的内存。另一方面，UniPS 全部受我们控制，所以相比 Raft Engine 也更好做透明的回收。透明回收小于 persisted applied_index 的所有 Entry，如果 Raftstore 会访问已经被回收的 Entry，会给一个 Panic。</p><h3 id="为什么-TiFlash-使用-DeltaTree-作为存储"><a href="#为什么-TiFlash-使用-DeltaTree-作为存储" class="headerlink" title="为什么 TiFlash 使用 DeltaTree 作为存储"></a>为什么 TiFlash 使用 DeltaTree 作为存储</h3><p>目的是为了适应频繁的更新。我们采用类似 <a href="https://gogim1.github.io/posts/c_store" target="_blank" rel="noopener">CStore</a>的思路，引入了 PageStorage 这个对象存储。其中针对写优化的部分称为 Delta 层，类似于 RocksDB 的 L0，存储在 PageStorage 中。针对读优化的部分称为 Stable 层，以 DTFile 文件的形式存储，但文件路径在 PageStorage 作为 External Page 的形式维护。</p><h3 id="存储模型的进一步讨论"><a href="#存储模型的进一步讨论" class="headerlink" title="存储模型的进一步讨论"></a>存储模型的进一步讨论</h3><h4 id="其他的存储模型的比较"><a href="#其他的存储模型的比较" class="headerlink" title="其他的存储模型的比较"></a>其他的存储模型的比较</h4><p>例如可以将 update 操作分为 delete 和 insert 操作。查询时，同时查询 delete 和 insert，并决定最终的输出。StarRocks 使用这样的方式，他们指出 Delete+Insert 这样的模式<a href="https://zhuanlan.zhihu.com/p/566219916" target="_blank" rel="noopener">有利于下推 Filter</a>。StarRocks 据此实现了<a href="https://docs.starrocks.io/zh/docs/table_design/table_types/primary_key_table/" target="_blank" rel="noopener">主键模型</a>。<br>这里需要区分他们的<a href="https://docs.starrocks.io/zh/docs/table_design/table_types/unique_key_table/" target="_blank" rel="noopener">更新模型</a>，也就是一种不支持 MVCC，始终返回最新数据的模型。这种模型应该就是一种类似 LSM 的方案，在 Compaction 的时候只保留一个版本。但是在查询的时候仍然需要 merge 多个版本，并且不支持下推 filter。<br>主键模型的优势就是查询时不需要 merge，并且支持下推 filter 和索引。这种方式主要是将主键索引加载到内存中，对于 Update 操作，通过主键索引找到记录的位置，写一个 Delete，然后再写一个 Insert。可以发现这种方案仍然是不支持 MVCC 的，我理解如果要支持 MVCC 那么 merge 可能是必然的。<br>此外，主键模型对内存是有开销的，我理解这个应该不是关键问题。首先，如果数据有冷热之分，可以持久化一部分主键索引到磁盘上。其次，这个场景在大宽表有优势。</p><h4 id="来自-TiKV-的约束"><a href="#来自-TiKV-的约束" class="headerlink" title="来自 TiKV 的约束"></a>来自 TiKV 的约束</h4><p>从 Raft 层接入数据导致 TiFlash 的存储层的分区会收到 TiKV Key Format 的影响。例如尽管 TiFlash 的 Segment 和 TiKV 的 Region 并不对应，Segment 远大于 Region。但它们都被映射到同一个 Key Range 上。</p><p>这就导致 TiFlash 数据的物理排列一定是根据 TiKV 的主键有序的，TiFlash 无法自行指定主键。另外 TiFlash 本身也没有二级索引。</p><p>目前来自 TiKV 的约束有：</p><ol><li>MVCC 字段<br> 如果要和 TiDB 一起玩，就必须要支持 MVCC，不能只保存最新的版本。</li><li>Unique 的主键</li></ol><h3 id="DM-的-Delta-层是如何实现的？"><a href="#DM-的-Delta-层是如何实现的？" class="headerlink" title="DM 的 Delta 层是如何实现的？"></a>DM 的 Delta 层是如何实现的？</h3><p>PageStorage 先前使用 Append 写加上 GC 的方案，但带来写放大、读放大和空间放大。因为这里 GC 采用的 Copy Out 的方式，所以理论上写放大和空间放大构成一个 trade off：</p><ol><li>如果允许更少的有效数据和更多的碎片，那么空间放大更严重</li><li>否则，写放大更严重</li></ol><p>旧的 PageStorage 主要存在下面的问题：</p><ol><li>GC 开销很大，因为需要遍历所有的 Version 或者说 Snapshot 才能得到可以被安全删除的数据。这样会产生很多额外的遍历。</li><li>每张表一个实例，如果存在很多小表，则会产生非常多的文件，甚至会用光 fd。</li><li>冷热数据分离。因为 meta 一般会被频繁更新，而实际上存在一些比较冷的 data。这会导致冷 data 阻碍 meta 进行 gc，这样会产生空间放大。到一定程度之后，又会触发 gc，进一步加剧问题。</li></ol><p>在 SSD 盘上，随机写和顺序写的差距不大，原因是 FTL 会将随机写转换为顺序写，所以寻址相关的开销并不是很大。尽管如此，顺序写依然存在优势，首先顺序写可以做聚合，同样的 IOPS 写入带宽是会比随机写要大很多，然后是顺序写的 gc 会更容易。此外，因为变成随机读，性能会变差。特别是对类似 Raft Log 这样的 scan 场景。</p><p>新一版本的设计，TiFlash 会通过 SpaceMap 尽量选择从已有的文件中分配一块合适的空间用来写入 blob。当 blob 被分配完毕后，多个 writer 可以并发地写自己的部分。在写入 blob 完成后，会写 WAL 记录相关元信息。在这之后就可以更新内存中的数据。</p><h3 id="为什么-DM-的-Stable-只有一层？"><a href="#为什么-DM-的-Stable-只有一层？" class="headerlink" title="为什么 DM 的 Stable 只有一层？"></a>为什么 DM 的 Stable 只有一层？</h3><p>DM 的设计目标包含优化读性能和支持 MVCC 过滤。这就导致要<a href="https://tidb.net/book/tidb-monthly/2022/2022-04/update/tiflash-storage" target="_blank" rel="noopener">解决下面的场景</a>：</p><blockquote><p>TiFlash 有比较多的数据更新操作，与此同时承载的读请求，都会需要通过 MVCC 版本过滤出需要读的数据。而以 LSM Tree 形式组织数据的话，在处理 Scan 操作的时候，会需要从 L0 的所有文件，以及其他层中与查询的 key-range 有 overlap 的所有文件，以堆排序的形式合并、过滤数据。在合并数据的这个入堆、出堆的过程中 CPU 的分支经常会 miss，cache 命中也会很低。测试结果表明，在处理 Scan 请求的时候，大量的 CPU 都消耗在这个堆排序的过程中。</p></blockquote><blockquote><p>另外，采用 LSM Tree 结构，对于过期数据的清理，通常在 level compaction 的过程中，才能被清理掉（即 Lk-1 层与 Lk 层 overlap 的文件进行 compaction）。而 level compaction 的过程造成的写放大会比较严重。当后台 compaction 流量比较大的时候，会影响到前台的写入和数据读取的性能，造成性能不稳定。</p></blockquote><p>为了缓解单层带来的写放大，DM 按照 key range 分成了多个 Segment。每个 Segment 中包含自己的 Stable 和 Delta。其中 Delta 合并 Stable 会产生一个新的 Stable。</p><h3 id="为什么-TiFlash-按-TSO-升序存储？"><a href="#为什么-TiFlash-按-TSO-升序存储？" class="headerlink" title="为什么 TiFlash 按 TSO 升序存储？"></a>为什么 TiFlash 按 TSO 升序存储？</h3><p>TiKV 的 TSO 按照逆序存，有利于找新版本。<br>TiFlash 因为都是处理扫表，所以逆序的收益不是很大。ClickHouse 使用升序存储，所以 TiFlash 也沿用了升序。<br>但这里就导致在处理 Snapshot 写入的时候，需要读完每个 row key 的所有版本，并在一个 read 调用中返回给下游的 stream。</p><h3 id="TiFlash-如何处理-Raft-Snapshot？"><a href="#TiFlash-如何处理-Raft-Snapshot？" class="headerlink" title="TiFlash 如何处理 Raft Snapshot？"></a>TiFlash 如何处理 Raft Snapshot？</h3><h3 id="为什么-TiFlash-不处理-DeleteRange？"><a href="#为什么-TiFlash-不处理-DeleteRange？" class="headerlink" title="为什么 TiFlash 不处理 DeleteRange？"></a>为什么 TiFlash 不处理 DeleteRange？</h3><p>TiKV 通过 DeleteRange 来删表。TiFlash 则是通过拉取 DDL，并确保已经过了 gc safepoint 后，才会物理删除表。</p><p>需要注意的是，除了删表之外，pd 可能从 TiFlash 调度走某个 Region，这也涉及删除操作。对于这样的操作，TiFlash 就得立即响应。</p><p>在 gc 时，在 write cf 上写一个 DEL 记录，也就是所谓的 tombstone key 是比较少见的。现在的做法是在 Compaction 的时候将这些 key filter 掉。当然在提交事务的时候，DEL lock cf 是很常见的。</p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="为什么-TiFlash-没有-buffer-pool"><a href="#为什么-TiFlash-没有-buffer-pool" class="headerlink" title="为什么 TiFlash 没有 buffer pool"></a>为什么 TiFlash 没有 buffer pool</h3><p>对于 AP 负载，扫表的数据规模很大，Cache 起不到太大作用。</p><h2 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h2><h3 id="弹性的资源管理和存算分离"><a href="#弹性的资源管理和存算分离" class="headerlink" title="弹性的资源管理和存算分离"></a>弹性的资源管理和存算分离</h3><p>在目前的计算机架构下，进程是资源的分配单位。这就意味着如果程序对除了 CPU 之外的某个资源的需求存在很大的弹性，那么就需要将这一部分单独剥离出来。<br>TiFlash Cloud 中就使用了存算分离，当然还使用了 OSS 等方案，但我认为是正交的设计。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>历史上计算层出现过不少因为查询过大导致的 OOM，计算层通过 kill query 或者 spill 的方式进行解决。但存储层目前还缺少这块。理论上存储层的开销主要分为几类：</p><ol><li>Memtable<br> 包含 KVStore 的 RegionData 和 DeltaTree 的 DeltaCache。<br> 这类场景下，OOM 主要发生在大事务场景。</li><li>Cache<br> 主要用来服务计算节点，列存主要是扫表，所以没有做 Block cache 或者 row cache。</li><li>索引<br> 包含 DeltaTree 的 DeltaIndex，PageStorage 的 PageDirectory 等。</li><li>Compact 相关，比如 delte merge 等</li><li>行转列相关</li></ol><p>在一些场景下，因为存储层和计算层并不互相感知，会导致存储层会被计算层的大任务干到 OOM 或者报异常。而实际上这些任务可以被 kill，stall 或者通过 kill query 抢占计算层的内存。</p><p>因此，在 TiFlash 侧实现一个统一的内存管理还是有必要的。</p><h4 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h4><p>严格来讲避免空指针也不完全算是内存管理。但确实是工作中遇到的一个比较关键的问题。我在 <a href="/2023/01/12/high-concurrency/">分布式架构和高并发相关场景</a> 这篇文章里面说吧。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h1 id="TiFlash-Cloud"><a href="#TiFlash-Cloud" class="headerlink" title="TiFlash Cloud"></a>TiFlash Cloud</h1><h2 id="快速扩容-FAP-What-amp-why？"><a href="#快速扩容-FAP-What-amp-why？" class="headerlink" title="快速扩容(FAP) What &amp; why？"></a>快速扩容(FAP) What &amp; why？</h2><p>目的：</p><ol><li>复用 TiFlash 行转列的结果。减少 TiKV 生成、传输和 TiFlash 接收、转换 Snapshot 的开销。<br> 在测试中，发现能够减少 96% 的 CPU 开销和 20% 的内存开销。<br> 如果提升调度的 limiter，能够大幅提高吞吐量，体现为添加副本总时间的减少。但该增长不是线性的，也取决于 TiFlash 侧线程池的大小，以及串行 ingest 的开销。<br> 需要注意，因为 Region 和 Raft Group 绑定，导致 FAP 必须等待 apply Confchange 之后的 Checkpoint，所以对于单个小 Region 来说，可能要花费更长的时间来处理。</li><li>利用如 S3 的特性，减少跨 Region 通信。</li><li>提高副本迁移，特别是单副本迁移的效率。</li><li>在扩容场景下，新节点可能因为处理全量 Snapshot 更慢，导致进度落后，从而进一步触发全量 Snapshot。此时新机器无法处理被 dispatch 过来的请求。</li></ol><p>要点：</p><ol><li>使用 PageStorage 替换 RaftEngine。这样使得 Raft、KVStore 和 DeltaTree 数据都一起被存到同一个 checkpoint 里面，保证原子性和一致性。</li><li>副本选择和由 Learner 管理的副本创建。用来快速扩容的 TiFlash Checkpoint，必须要比扩容对应的 confchange log entry 要新。这是因为 TiKV 通过一个 Snapshot 来帮助新 node 追日志，而这个 Snapshot 必然在 confchange 后产生。如果接受一个更早的 Checkpoint，那么就要确保 raft 能够给新 peer 发送 confchange 前的日志。即使能，这也意味着新 peer 要处理添加自己的 confchange cmd。即使通过忽略等方案处理，那么在这之前的 batch split cmd 就需要伪装成生成 Checkpoint 的那个 peer，并将这个 region 重新切开（涉及一些行转列和写盘）。而如果与此同时，batch split 得到的某个 split 的最新版本又通过正常途径调度过来，并且在 apply snapshot，那么这里就可能产生 region overlap 导致的数据问题。可以看出，因为违反了 TiKV 的约束，所以产生了很多的潜在问题。</li><li>注入数据。需要注意，原有的 TiKV 的通过 Snapshot 初始化副本的流程需要重新走一遍。</li><li>对旧版本数据的清理。</li></ol><p>这个 feature 类似于 Learner Snapshot，所以为什么不通过 Follower/Learner Snapshot 来实现 FAP 呢？</p><ol><li>TiKV 主要需要该 Feature 来避免跨地区的 Snapshot 复制，而 TiFlash 需要该 Feature 实现异构的 Snapshot，侧重点上有所不同。</li><li>该 feature 需要在 TiKV 或者 PD 等组件中实现一定的调度机制。所以 FAP 实际可以视为一个部分的实现，后续有可能进行推广。届时 FAP 的 phase 1 过程就有可能被移动到 prehandle snapshot 中处理了。</li></ol><h2 id="使用-UniPS-替换-RaftEngine"><a href="#使用-UniPS-替换-RaftEngine" class="headerlink" title="使用 UniPS 替换 RaftEngine"></a>使用 UniPS 替换 RaftEngine</h2><p>目前 TiKV 使用 engine_traits 描述了一个可以用来作为 raftstore 的存储的 engine 所需要的接口。这些接口基本是基于 RocksDB 而抽象出来的。因此 UniPS 需要模拟出其中关键的特性，例如 WriteBatch 等。</p><p>UniPS 的性能劣于 RaftEngine，写入延迟大约是两倍。但是仍有不少优化空间。</p><h2 id="为什么-TiFlash-Cloud-目前还是两副本？"><a href="#为什么-TiFlash-Cloud-目前还是两副本？" class="headerlink" title="为什么 TiFlash Cloud 目前还是两副本？"></a>为什么 TiFlash Cloud 目前还是两副本？</h2><p>目前快速恢复还是实验状态。TiFlash 重启后也需要进行一些整理和追日志才能服务，可能影响 HA，这些需要时间优化。尽管如此，快速恢复依然是一个很好的特性，因为：</p><ol><li>快速恢复在 1 wn 下，可以从本节点重启，减少 TiKV 生成 Snapshot 的负担。而这个负担在 v1 版本的 TiKV 上是比较大的。</li><li>减少宕机一个节点恢复后，集群恢复到正常 2 副本的时间。</li></ol><p>因为基于 Raft，所以本地数据的丢失只会导致从上一个 S3 Checkpoint 开始回放。如果只有一个存储节点，会失去 HA 特性。</p><h2 id="S3-在-TiFlash-Cloud-中起到什么作用？"><a href="#S3-在-TiFlash-Cloud-中起到什么作用？" class="headerlink" title="S3 在 TiFlash Cloud 中起到什么作用？"></a>S3 在 TiFlash Cloud 中起到什么作用？</h2><ol><li>TiFlash Cloud 会定期上传 Checkpoint 到 S3 上，Checkpoint 是一个完整的快照，可以用来做容灾。即使在存储节点宕机后，其上传的那部分数据依然可以被用来查询，可能只能用来服务 stale read？</li><li>TiFlash 计算节点可以从 S3 获得数据，相比从存储节点直接获取要更为便宜。存储节点只需要提供一些比较新的数据的读取，减少压力。</li><li>快速扩容逻辑可以复用其他存储节点的数据，此时新节点并不需要从 TiKV 或者其他 TiFlash 获得全部的数据。副本迁移同理，不需要涉及全部数据的移动。</li></ol><p>尽管如此，S3 并不是当前 TiFlash 数据的全集。本地会存在：</p><ol><li>上传间隔时间内，还没有上传到 S3 的数据。</li><li>因为生命周期太短，在上传前就被 tombstone 的数据。</li><li>尚在内存中的数据。</li></ol><h3 id="S3-vs-EBS"><a href="#S3-vs-EBS" class="headerlink" title="S3 vs EBS"></a>S3 vs EBS</h3><p>对于 <a href="https://aws.amazon.com/cn/s3/storage-classes/" target="_blank" rel="noopener">S3</a> 而言：</p><ol><li>具备 99.999999999% 的持久性和 99.99% 的可用性。<br> 也就是说一天中的不可用时间大约在 9s 左右。</li></ol><p><a href="https://aws.amazon.com/cn/s3/pricing/?nc=sn&loc=4" target="_blank" rel="noopener">定价</a>：</p><ol><li>PUT/POST/LIST/COPY 0.005</li><li>GET/SELECT 0.0004</li><li>存储每 GB 0.022 USD 每月</li></ol><p>可以看到，S3 的定价相比 EBS 要便宜不少。此外，从灾备上来讲，使用 EBS 可能需要为跨 AZ 容灾付出更多的成本，而 S3 可以实现跨 AZ 容灾。</p><p>当然 S3 也有缺陷，比如访问延迟比较高。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://docs.pingcap.com/zh/tidb/stable/troubleshoot-hot-spot-issues" target="_blank" rel="noopener">https://docs.pingcap.com/zh/tidb/stable/troubleshoot-hot-spot-issues</a></li><li><a href="https://www.infoq.com/articles/raft-engine-tikv-database/" target="_blank" rel="noopener">https://www.infoq.com/articles/raft-engine-tikv-database/</a> RaftEngine</li><li><a href="https://www.zhihu.com/question/47544675" target="_blank" rel="noopener">https://www.zhihu.com/question/47544675</a> 固态硬盘性能</li><li><a href="https://docs.pingcap.com/zh/tidb/stable/titan-overview" target="_blank" rel="noopener">https://docs.pingcap.com/zh/tidb/stable/titan-overview</a> Titan 设计</li><li>Fast scans on key-value stores</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;一些常见问题的思考，只代表个人见解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>TiFlash 性能测试的一个场景</title>
    <link href="http://www.calvinneo.com/2023/07/14/tiflash-pt-1/"/>
    <id>http://www.calvinneo.com/2023/07/14/tiflash-pt-1/</id>
    <published>2023-07-14T15:20:37.000Z</published>
    <updated>2024-01-03T15:59:34.592Z</updated>
    
    <content type="html"><![CDATA[<p>我们需要测试在有大量活跃 Region 情况下 TiFlash 的性能，具体负载是对一个大表压 update where。因为原有的测试工具需要加载全量数据到内存，并且只能单线程运行，所以重新做了<a href="https://github.com/CalvinNeo/pressure" target="_blank" rel="noopener">一个专门的压测工具</a>。这个工具是从 N 条数据中 sample 出 K 个出来，并启动多个 worker 发送 SQL 命令。</p><p>本文讲述在压测过程中发现的几个现象，并讲述作为工程师如何快速定位集群中出现的这些。</p><a id="more"></a><h1 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h1><p>第一个问题很好解决，原因是我用了 mysql 这个 crate，而它是阻塞的。这样我们开了很多线程，从而带来了很多的上下文切换。后面替换成 async-mysql 并且基于 tokio runtime，这样当任务需要等待的时候只会 yield，原线程还可以接着做其他任务。</p><table><thead><tr><th align="center">前</th><th align="center">后</th></tr></thead><tbody><tr><td align="center"><img src="/img/tiflash-pt/perf1.jpg"></td><td align="center"><img src="/img/tiflash-pt/perf2.jpg"></td></tr></tbody></table><h1 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h1><p>现在 N = 500m，b = 10k，它们是尽量平均存放的。因为压测机器内存的限制，它只能选取 N 中的 K 个数据作为集合，然后在这个集合上 sample 构造请求。因为 cpu 的限制，一次只能 sample i 个作为请求发送。现在观察到下面的现象：</p><ol><li>如果 k 较小，则这些请求分布的 region 很不均匀。反之，则分布更均匀。<br> 这里是因为如果 region 分布均匀，那么同样数量的请求会覆盖更多的 region，从而导致更多 region 被激活。而集群的某个指标和 region 被激活的数量有关。所以我们通过这个性质判断是否分布均匀。</li><li>请求的 QPS 是稳定的。</li></ol><p>现在调查这个问题，首先是进行统计学的分析，k 的大小会不会影响对 k 进行二次抽样得到的 i 个数据的分布均匀度呢？不得而知，但可以考虑一个简单的问题，也就是从 N 中抽 K 个，那么能覆盖多少个 region？得到下面的期望 E(cover)</p><p>$$<br>E(cover) = b (1 - (\frac{b - 1}{b})^k)<br>$$</p><p>从这个期望看到，只要 k 达到 N 的 1%，那么就基本能够覆盖全部的 region 了。那对于有 N 和 i 的场景，就借助于模拟进行验证。通过<a href="/asset/highconcurrency/sim.py">模拟的验证</a>，上面的期望是也是使用的。</p><p>如果既然直接 sample i 和在 k 中 sample i 是一样的，也就是不影响均匀程度，那么上面观察的结果是非预期的。这是因为对于同样的 i，k 不同，均匀程度不同，于是怀疑代码实现。特别地，如果数据处理算法没有问题，那么会首先考虑数据本身的问题。</p><p>我们的数据是从 n 个数据中抽样 k 个得到的，抽样算法是蓄水池算法。于是怀疑蓄水池算法的实现。果不其然，我发现 evict 的判定被我写反了，应该是满足 <code>k / j</code> 的情况下，会 evict，结果我按照不 evict 处理了。</p><p>综上，对于这种因为随机数写错了，导致的非 panic 的 bug。我们通过先统计学建模，再计算机模拟验证的方式，证明了数据生成过程是不符合预期的，进而找到了 bug。</p><h1 id="第三个问题"><a href="#第三个问题" class="headerlink" title="第三个问题"></a>第三个问题</h1><p>在解决这个问题之后，请求确实均匀了。但并发还是上不去，只有 1K+ QPS，检查发现是 TiKV 磁盘满了，导致限流。</p><h1 id="第四个问题"><a href="#第四个问题" class="headerlink" title="第四个问题"></a>第四个问题</h1><p>在解决上面三个问题后，压测的 SQL 可以达到 3K+ QPS。但进一步观察到另一个奇怪的现象。当 K 为 N 的 1% 的时候，是打到了 3K 并发，但是进一步增大 K，并发数反而降低了。调节压测程序的参数，发现压不上去，因此判定是集群的问题。</p><p>这里让人奇怪的点是，K 无论是 1% 还是 10% 的 N，它的 E(cover) 都已经能覆盖所有 region 了。那为什么 QPS 会不一样？</p><p>出于第三个问题的经验，首先查看了 TiKV 的写入指标。这里 15.15 对应的 10% 的情况，15.25 对应的是 1% 的情况。</p><p><img src="/img/tiflash-pt/ioutil.jpg"></p><p>可以看出两个情况下 SSD 都满了，那么为啥 QPS 还能分出个高下呢？同事说 <code>procinfo::pid::io_task</code> 测出来是 100%，但不意味着 SSD 到了瓶颈。</p><p>进一步查看写入，可以发现前台写入确实拉开了不小的差距。<br><img src="/img/tiflash-pt/fgw.jpg"></p><p>总体的写入上来看，也看不出两个负载之间有什么特别大的区别。<br><img src="/img/tiflash-pt/allw.jpg"></p><p>比较 io，可以看到前半段 write iops 稍微高一点或者相等，但是 write bandwidth 明显低，考虑是有较多的小写入。难道是因为前面的写入更散导致的？</p><table><thead><tr><th align="center">IOPS</th><th align="center">IO bandwidth</th></tr></thead><tbody><tr><td align="center"><img src="/img/tiflash-pt/iops.jpg"></td><td align="center"><img src="/img/tiflash-pt/ioband.jpg"></td></tr></tbody></table><p>后面，大佬同事给出一个观察，他认为 QPS 的问题可能是因为读取慢而不是写入慢导致的。确实从下面的监控来说，后半段读取耗时少了很多。</p><p><img src="/img/tiflash-pt/read.jpg"></p><p>他也发现了 running task 出现了堆积。也就是入得多出得少。并且 1 和 2 两台机器尤其吃紧。</p><p><img src="/img/tiflash-pt/rt.jpg"></p><p>进一步检查 qps，发现不同机器之间的写 qps 差别也比较大。读的 qps 差距不大，但这可能是因为 lb 的原因，例如如果有机器是 15kops，那么其他机器计算能到 30kops 也会被限制在 15kops 的。<br><img src="/img/tiflash-pt/qps.jpg"></p><p>关于写入的问题，检查 compaction，发现非 L0 到 L1 的 Major Compaction 很多。从而怀疑是否是因为第二个负载的池子比较有限，最多就涉及总共的 1% 的数据，而第一个池子的负载有总共池子的 10% 的数据。导致第二个池子的 hot key 实际上很少，compaction 不会到很下层。但因为第一个负载的 Compaction 没有明显多余第二个负载，所以这个怀疑应该也是不正确的。<br><img src="/img/tiflash-pt/compaction.jpg"></p><p>这里大佬又观察到 Block Cache Hit 上第二个负载明显高于第一个负载。这能解释一部分问题了。因为第一个池子是 10% 的样本，写入更散，Block Cache 容易被打穿到磁盘，所以读就变慢了。而我们的 update where 又是需要读的。<br><img src="/img/tiflash-pt/bchit.jpg"></p><p>这也解释了为什么要从 1Kops 跑一段时间才能到 3Kops，其实是在预热缓存。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;我们需要测试在有大量活跃 Region 情况下 TiFlash 的性能，具体负载是对一个大表压 update where。因为原有的测试工具需要加载全量数据到内存，并且只能单线程运行，所以重新做了&lt;a href=&quot;https://github.com/CalvinNeo/pressure&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个专门的压测工具&lt;/a&gt;。这个工具是从 N 条数据中 sample 出 K 个出来，并启动多个 worker 发送 SQL 命令。&lt;/p&gt;
&lt;p&gt;本文讲述在压测过程中发现的几个现象，并讲述作为工程师如何快速定位集群中出现的这些。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>tuxun 游戏经验</title>
    <link href="http://www.calvinneo.com/2023/05/28/tuxun/"/>
    <id>http://www.calvinneo.com/2023/05/28/tuxun/</id>
    <published>2023-05-28T11:20:33.000Z</published>
    <updated>2023-06-09T17:05:53.203Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tuxun.fun/" target="_blank" rel="noopener">图寻</a>是一个有趣的通过图片猜测地点的游戏。</p><a id="more"></a><script>    var show = false;    function btnClick() {        document.getElementById("mainbody").style.display = "block";    }</script><p><strong>注意，本文所引用的图片均来自于诸如百度、新浪、维基百科等官方资料网站。这些地图中的标注可能存在有主权争议的标注，这些标注是资料提供方的立场，而非我本人的立场。本人谴责部分人群居高临下，罔顾历史和主权去划分国界的行为。当然，本人使用这些图片的目的只是作为和国家主权领土无关的方面的示意，我发现在这些特定方面上，这些图片的水平很高。但限于地理知识和精力有限，本人没有能力对此一一校核。即使发现有问题，也没有能力基于这些图片进行改正。</strong></p><button onclick="btnClick()"><a>我同意上述免责声明，请向我展示内容</a></button><div style="display: none" id="mainbody"><br><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="基础方位"><a href="#基础方位" class="headerlink" title="基础方位"></a>基础方位</h2><p>判断南北半球，点击左下角指南针归正，此时面向北方。如果能明显见到太阳，则说明太阳在北方，我们位于南半球。反之则在北半球。如果太阳出现在头顶，或者东西两侧，则不太好分辨南北半球。<br>或者可以让指南针指向太阳，看对着的方向。<br>如果太阳在头顶，那么这个地方肯定在回归线以内。<br>还可以通过卫星锅的夹角来判断纬度。</p><p>判断和海洋的方位。</p><h2 id="行车方向"><a href="#行车方向" class="headerlink" title="行车方向"></a>行车方向</h2><p>根据行车方向判断国家或地区。</p><ul><li>亚洲：<ul><li>巴基斯坦</li><li>马来西亚</li><li>斯里兰卡</li><li>新加坡</li><li>香港</li></ul></li><li>欧洲：<ul><li>英国</li><li>爱尔兰</li><li>马耳他</li><li>塞浦路斯</li></ul></li><li>非洲：<ul><li>非洲南部<ul><li>南非</li><li>斯威士兰<br>  南非国中国</li><li>莱索托<br>  南非国中国</li><li>博茨瓦纳<br>  南非北边</li><li>津巴布韦<br>  博茨瓦纳北边</li><li>纳米比亚<br>  博茨瓦纳西边</li><li>赞比亚<br>  津巴布韦北边</li></ul></li><li>非洲岛国<ul><li>马达加斯加</li><li>毛里求斯<br>  马达加斯加旁边的岛国</li><li>塞舌尔<br>  马达加斯加北边</li></ul></li></ul><ul><li>开曼群岛</li><li>马拉维</li><li>常绿岛</li></ul></li><li>大洋洲：<ul><li>澳大利亚</li><li>新西兰</li><li>巴布亚新几内亚</li><li>萨摩亚</li><li>所罗门群岛</li><li>汤加</li></ul></li></ul><h2 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h2><p>根据语言判断国家或地区。</p><ul><li>西班牙语<br>  <img src="/img/tuxun/lang/his.svg"></li><li>法语<br>  <img src="/img/tuxun/lang/fra.svg"></li><li>葡萄牙语<br>  <img src="/img/tuxun/lang/por.svg"></li><li>欧洲各国语言<br>  <img src="/img/tuxun/lang/eur.png"></li></ul><p>西班牙语字母表<br><img src="/img/tuxun/lang/his_alpha.png"></p><p>葡萄牙语字母表<br><img src="/img/tuxun/lang/por_alpha.png"><br>部分方言包含Ç。</p><p>法语字母表<br><img src="/img/tuxun/lang/fra_alpha.png"></p><p>印地語、孟加拉语<a href="https://zhuanlan.zhihu.com/p/635034128" target="_blank" rel="noopener">对照</a></p><blockquote><p>以”我爱你”为例，各语言文字的写法如下：<br>印地語：मुझे तुमसे प्यार है<br>孟加拉语：আমি তোমাকে ভালোবাসি<br>马拉地语：मी तुझ्यावर प्रेम करतो<br>泰卢固语：నేను నిన్ను ప్రేమిస్తున్నాను<br>泰米尔语：நான் உன்னை காதலிக்கிறேன்<br>古吉拉特语：હું તને પ્રેમ કરું છુ</p></blockquote><h2 id="国旗"><a href="#国旗" class="headerlink" title="国旗"></a>国旗</h2><p>根据国旗判断国家或地区。<br><img src="/img/tuxun/flag/flag2023.png"></p><h1 id="自然气候"><a href="#自然气候" class="headerlink" title="自然气候"></a>自然气候</h1><h2 id="气候类型"><a href="#气候类型" class="headerlink" title="气候类型"></a>气候类型</h2><h3 id="气候分布图"><a href="#气候分布图" class="headerlink" title="气候分布图"></a>气候分布图</h3><p><img src="/img/tuxun/cli/simple.jpg"></p><h4 id="欧洲详图"><a href="#欧洲详图" class="headerlink" title="欧洲详图"></a>欧洲详图</h4><p><img src="/img/tuxun/cli/eur.jpg"></p><h4 id="北美洲详图"><a href="#北美洲详图" class="headerlink" title="北美洲详图"></a>北美洲详图</h4><p><img src="/img/tuxun/cli/nm.png"></p><h4 id="南美洲详图"><a href="#南美洲详图" class="headerlink" title="南美洲详图"></a>南美洲详图</h4><p><img src="/img/tuxun/cli/sm.jpg"></p><h4 id="非洲详图"><a href="#非洲详图" class="headerlink" title="非洲详图"></a>非洲详图</h4><p><img src="/img/tuxun/cli/af.webp"></p><h4 id="大洋洲详图"><a href="#大洋洲详图" class="headerlink" title="大洋洲详图"></a>大洋洲详图</h4><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>海洋性气候、大陆性气候、季风性气候：</p><ol><li>大陆性气候特点是降水少</li><li>海洋性气候特点是降水多且均匀，年温差小</li><li>季风气候的特点是降水差别大，年温差大</li></ol><h3 id="温带大陆性气候"><a href="#温带大陆性气候" class="headerlink" title="温带大陆性气候"></a>温带大陆性气候</h3><ol><li>北美洲中东部</li><li>西伯利亚</li><li>巴塔哥尼亚高原<br> 位于阿根廷和智利。也就是安第斯山脉东边的一长条。</li><li>欧洲部分</li></ol><p>温带大陆性气候的植被根据纬度不同可以是<strong>荒漠</strong>、<strong>草原</strong>和<strong>针叶林</strong>。<br>温带大陆性气候会被一些地方细分为温带沙漠气候和温带草原气候等。</p><h3 id="温带海洋性气候"><a href="#温带海洋性气候" class="headerlink" title="温带海洋性气候"></a>温带海洋性气候</h3><ol><li>西欧<br> 例如英国、比利时。</li><li>落基山脉西的北美<br> 例如西雅图、温哥华。</li><li>澳大利亚东南、新西兰</li><li>智利最南端</li></ol><p>温带海洋性气候通常出现在大陆西端。<br>植被类型是温带落叶阔叶林。<br>温带海洋性气候给人一种位于青山绿水的童话世界中的感觉。</p><h3 id="温带季风气候"><a href="#温带季风气候" class="headerlink" title="温带季风气候"></a>温带季风气候</h3><ol><li>中国北方的东部地区、俄罗斯远东地区南部、日本朝鲜等北部。</li></ol><p>温带季风气候通常出现在大陆东端。<br>温带季风气候的主要植被是落叶阔叶林，以及针阔叶混交林。</p><h3 id="亚热带季风气候"><a href="#亚热带季风气候" class="headerlink" title="亚热带季风气候"></a>亚热带季风气候</h3><ol><li>中国东南沿海</li><li>美国东南沿海</li><li>澳大利亚东部沿海</li></ol><p>温带季风气候的主要植被是常绿阔叶林。</p><h3 id="地中海气候"><a href="#地中海气候" class="headerlink" title="地中海气候"></a>地中海气候</h3><p>地中海气候是一种亚热带气候。</p><ol><li>地中海沿岸</li><li>黑海沿岸</li><li>加州</li><li>澳大利亚珀斯、阿德莱德</li><li>南非西南</li><li>智利中部</li></ol><p>雨热不同期。</p><p>典型植被为硬叶常绿旱生林和灌丛。<br>夏季过后，树林中干燥的枯枝落叶多。</p><h3 id="热带草原气候"><a href="#热带草原气候" class="headerlink" title="热带草原气候"></a>热带草原气候</h3><ol><li>非洲中部<br> <img src="/img/tuxun/cli/tsny.jpg"></li><li>南美巴西大部</li><li>澳大利亚东部和北部<br> <img src="/img/tuxun/cli/north_australia.jpg"></li></ol><p>特点是全年高温，分为明显的干季和湿季。<br>热带草原的植物具有旱生特性，不少植物<strong>树干粗大，树皮厚</strong>，可贮存大量水分以保证在旱季能进行生命活动。代表树种有猴面包树、纺锤树、金合欢树、波巴布树等，另外是具有许多珍稀的多肉植物种类。</p><h3 id="热带沙漠气候"><a href="#热带沙漠气候" class="headerlink" title="热带沙漠气候"></a>热带沙漠气候</h3><ol><li>撒哈拉沙漠</li><li>TODO</li></ol><h3 id="热带季风气候"><a href="#热带季风气候" class="headerlink" title="热带季风气候"></a>热带季风气候</h3><ol><li>印度、斯里兰卡</li><li>泰国北部、缅甸、越南等</li></ol><p>植被和热带雨林的<a href="http://www.igsnrr.cas.cn/cbkx/kpyd/dlzs/climate/202009/t20200910_5692629.html" target="_blank" rel="noopener">差别</a>在于：</p><ol><li>树木多数不再常绿，每到旱季便落叶</li><li>森林结构简化，树木的密度及分层减少</li></ol><p>所以人们称之为季雨林。</p><p>热带季风气候需要和温带大陆性气候区分，因为两者都会落叶。但热带季风更可能是干枯，可以看 Case5。</p><h3 id="热带雨林气候"><a href="#热带雨林气候" class="headerlink" title="热带雨林气候"></a>热带雨林气候</h3><ol><li>非洲西部刚果河流域，几内亚湾（也就是西南角）北岸<br> 注意，非洲其实大部分是热带草原和热带沙漠</li><li>马达加斯加岛东部</li><li>印尼，马来半岛南部，马来群岛，菲律宾群岛南部</li><li>亚马逊河流域</li><li>中美洲东部</li><li>澳大利亚的东北部</li></ol><p>植被<a href="http://www.igsnrr.cas.cn/cbkx/kpyd/dlzs/climate/202009/t20200910_5692631.html" target="_blank" rel="noopener">特点</a>：</p><ol><li>种类最丰富，树种混杂</li><li>树林有明显的分层，一般有五到八层<br> 最高的乔木层高达60～80米，林下有小乔木、灌木和草本植物，加上树上缠绕的藤本植物、附生植物和寄生植物</li><li>四季常青</li><li>为争夺阳光，植物都拼命往高处长</li></ol><h3 id="寒带气候"><a href="#寒带气候" class="headerlink" title="寒带气候"></a>寒带气候</h3><p>分为极地苔原气候和极地冰原气候。<br>极地苔原气候：</p><ol><li>北美洲北部</li><li>亚欧大陆北部</li><li>格陵兰以及北冰洋群岛</li><li>马尔维纳斯群岛、南设得兰群岛、南奥克尼群岛</li></ol><p>极地冰原气候：</p><ol><li>格陵兰、南极大陆和北冰洋群岛</li></ol><h2 id="植被"><a href="#植被" class="headerlink" title="植被"></a>植被</h2><p>温带落叶林</p><ol><li>枫树<br> <img src="/img/tuxun/green/fs.png"></li><li>橡树<br> <img src="/img/tuxun/green/xs.png"></li><li>白桦树<br> <img src="/img/tuxun/green/bhs.png"></li><li>水青冈属如山毛榉<br> <img src="/img/tuxun/green/smj.png"></li><li>榆树<br> <img src="/img/tuxun/green/ys.png"></li></ol><p>尽管可以通过叶子颜色判断是否是落叶林。但需要注意，有些颜色并不是来自于叶子，而可能来自于枝干。</p><p>热带亚热带常绿阔叶林</p><ol><li>樟科<br> <img src="/img/tuxun/green/zs.png"></li><li>山茶科</li><li>木兰科<br> <img src="/img/tuxun/green/ml.png"></li><li>水青冈属如山毛榉</li></ol><p>热带稀树草原</p><h1 id="地形地貌"><a href="#地形地貌" class="headerlink" title="地形地貌"></a>地形地貌</h1><h2 id="全球地形"><a href="#全球地形" class="headerlink" title="全球地形"></a>全球地形</h2><p>全球山地<br><img src="/img/tuxun/geo/global_mountain.jpg"></p><h2 id="各地土壤"><a href="#各地土壤" class="headerlink" title="各地土壤"></a>各地土壤</h2><p>巴西红土<br>美国平原黑土</p><p>一般热带雨林+红土考虑非洲。</p><h2 id="各地的山"><a href="#各地的山" class="headerlink" title="各地的山"></a>各地的山</h2><h1 id="人文"><a href="#人文" class="headerlink" title="人文"></a>人文</h1><h2 id="建筑"><a href="#建筑" class="headerlink" title="建筑"></a>建筑</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>吊脚楼</p><h3 id="外墙"><a href="#外墙" class="headerlink" title="外墙"></a>外墙</h3><h3 id="屋顶"><a href="#屋顶" class="headerlink" title="屋顶"></a>屋顶</h3><p>一般有积雪的地方会修斜顶屋。</p><h2 id="民族服饰"><a href="#民族服饰" class="headerlink" title="民族服饰"></a>民族服饰</h2><h2 id="作物和畜牧业"><a href="#作物和畜牧业" class="headerlink" title="作物和畜牧业"></a>作物和畜牧业</h2><p>牧场</p><h2 id="交通"><a href="#交通" class="headerlink" title="交通"></a>交通</h2><h3 id="道路划线"><a href="#道路划线" class="headerlink" title="道路划线"></a>道路划线</h3><p>中间白线主要是在欧洲。</p><p>中间白线，两边黄线是在南非。</p><p>中间黄线主要是在北美南美</p><ol><li>加拿大</li><li>芬兰</li></ol><h3 id="路桩"><a href="#路桩" class="headerlink" title="路桩"></a>路桩</h3><p>出现在澳大利亚。<br><img src="/img/tuxun/traffic/pile/1.png"></p><h3 id="护栏"><a href="#护栏" class="headerlink" title="护栏"></a>护栏</h3><h3 id="交通标志"><a href="#交通标志" class="headerlink" title="交通标志"></a>交通标志</h3><h3 id="电线杆"><a href="#电线杆" class="headerlink" title="电线杆"></a>电线杆</h3><p>木头电线杆：</p><ol><li>加拿大</li></ol><p>马来西亚电线杆上有黄色或者黑色贴纸。<br>日本北海道电线杆上有一个写满数字的牌子。</p><h2 id="车牌"><a href="#车牌" class="headerlink" title="车牌"></a>车牌</h2><h3 id="欧盟"><a href="#欧盟" class="headerlink" title="欧盟"></a>欧盟</h3><p>塞浦路斯、荷兰、卢森堡的车牌主体是黄色，而不是其他国家的白色。<br>法国和意大利车牌的右边也是蓝色。<br>葡萄牙的车牌右边是黄色的。</p><h3 id="欧洲"><a href="#欧洲" class="headerlink" title="欧洲"></a>欧洲</h3><p>阿尔巴尼亚和土耳其不是欧盟国家，但车牌和欧盟类似。<br>英国车牌前白后黄，emm，和香港一样啊。<br>俄罗斯车牌是白色底的。</p><h3 id="亚洲"><a href="#亚洲" class="headerlink" title="亚洲"></a>亚洲</h3><p>印度的车牌是白色长条。</p><p>马来西亚的车牌是黑色长条。</p><h2 id="插座"><a href="#插座" class="headerlink" title="插座"></a>插座</h2><h1 id="Fine-tune"><a href="#Fine-tune" class="headerlink" title="Fine tune"></a>Fine tune</h1><h2 id="找路"><a href="#找路" class="headerlink" title="找路"></a>找路</h2><h1 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h1><p>同样是温带大陆性气候，如何判断是在美洲还是亚欧大陆呢？</p><p>如何分辨巴西中部、非洲以及澳大利亚的热带草原气候呢？</p><h1 id="Case"><a href="#Case" class="headerlink" title="Case"></a>Case</h1><h2 id="1-10"><a href="#1-10" class="headerlink" title="1-10"></a>1-10</h2><p>下图所示，植被为草，考虑热带草原或者温带大陆性气候。但观察到远处有雪山，则选项只有：埃塞尔比亚、巴西阿根廷附近、美国、青藏高原附近。显然要排除埃塞尔比亚和青藏高原。本题是在阿根廷。<br><img src="/img/tuxun/cases/1.png"></p><p>下图所示，植被为草。明显感觉更旺盛一点，考虑热带草原。本题位于澳大利亚 Bourke 附近的 B71 公路。<br><img src="/img/tuxun/cases/2.png"></p><p>下图所示，植被为草，灌木和树叶有枯黄，考虑温带大陆性气候。本题位于加里宁格勒。<br><img src="/img/tuxun/cases/3.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=7e9a0270-ff12-11ed-914f-4914ef59bdbe&round=4" target="_blank" rel="noopener">下图所示</a>，植被为草，草是会枯黄的。地形高低起伏，有牧场。第一印象就是新西兰。但总觉得这个比较干，感觉是温带大陆性气候。其实这确实应该是海洋性，只是在秋天黄了一些。大陆性感觉类似于“温带沙漠/草原气候”？<br><img src="/img/tuxun/cases/4.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=eaeb2350-ffb7-11ed-b236-951b8abb12f6&round=6" target="_blank" rel="noopener">下图所示</a>位于泰国沙湾拿吉附近。这个我会把它认为是温带大陆性气候，原因是叶子枯萎，然后比较干燥。但这个可能是热带季风的干季。<br><img src="/img/tuxun/cases/5.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=83d757e0-ffcd-11ed-9b28-99b63e42e398&round=4" target="_blank" rel="noopener">下图所示</a>是在南非。我们错选了巴西。这两个都是南半球的热带草原气候。<br><img src="/img/tuxun/cases/6.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=55243880-06d2-11ee-ab40-2bdea2c51865&round=2" target="_blank" rel="noopener">下图所示</a>是在土耳其的亚洲部分。观察到国旗，并且是温带大陆性气候，并且四周较为平坦。<br><img src="/img/tuxun/cases/7.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=16ecb580-06d0-11ee-ab40-2bdea2c51865&amp;round=3" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=16ecb580-06d0-11ee-ab40-2bdea2c51865&amp;round=3</a> 是在喜马拉雅山南麓的不丹廷布。这个山看上去比较光，感觉是大陆性或者草原气候，我选了热带草原。但廷布确实是比较干燥的气候，但确实乔木要比热带草原要多。<br><img src="/img/tuxun/cases/8.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=55243880-06d2-11ee-ab40-2bdea2c51865&amp;round=1" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=55243880-06d2-11ee-ab40-2bdea2c51865&amp;round=1</a> 考虑是温带海洋性气候，所以考虑欧洲。看到有雪山，但是有树林，考虑是阿尔卑斯山，或者北欧。这里我选了阿尔卑斯，是错的。答案是在挪威北部。其实这里的海洋性不是很明显，因为气候看上去比较干燥，并且也是以针叶林为主，实际上应该是是大陆性气候。<br><img src="/img/tuxun/cases/9.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=55243880-06d2-11ee-ab40-2bdea2c51865&amp;round=3" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=55243880-06d2-11ee-ab40-2bdea2c51865&amp;round=3</a> 这个我填的是格陵兰，但实际上是喀喇昆仑附近。</p><p><img src="/img/tuxun/cases/10.png"></p><h2 id="11-20"><a href="#11-20" class="headerlink" title="11-20"></a>11-20</h2><p><a href="https://tuxun.fun/replay_pano?gameId=6c141871-06ce-11ee-b443-ed29a6596b57&amp;round=4" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=6c141871-06ce-11ee-b443-ed29a6596b57&amp;round=4</a> 这我对了，这就是典型的墨西哥。<br><img src="/img/tuxun/cases/11.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=3fcedfa0-06df-11ee-96e6-452f8f9a8409&amp;round=4" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=3fcedfa0-06df-11ee-96e6-452f8f9a8409&amp;round=4</a> 这张图我看植被常绿分层比较明显，考虑是热带雨林。道路左行，考虑是赞比亚。但实际上这是南非的热带草原气候，这还比较有趣。<br><img src="/img/tuxun/cases/12.png"></p><p>但我往前走了点，确实发现树干比较粗大。<br><img src="/img/tuxun/cases/12b.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=3fcedfa0-06df-11ee-96e6-452f8f9a8409&amp;round=3" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=3fcedfa0-06df-11ee-96e6-452f8f9a8409&amp;round=3</a> 这个一眼菲律宾南部的雨林气候。<br><img src="/img/tuxun/cases/13.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=2" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=2</a> 这个我觉得是非洲刚果河附近的热带雨林气候，但实际上是柬埔寨西南角的戈功附近。不知道为啥这是一个热带季风气候。可能你去想深圳其实也是季风气候，和这个有点像。<br><img src="/img/tuxun/cases/14.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=1" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=1</a> 看到这道路和广袤的农田，觉得是美国中部。但实际上是英国的剑桥北边一点。其实英国是有很多这样的平原的。<br><img src="/img/tuxun/cases/15.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=3" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=873b1af0-06e1-11ee-86d7-1101216a0f3c&amp;round=3</a> 这个居然也还是南非。这个确实看上去就是热带草原或者温带大陆性。我选了温带大陆性，那么就是阿根廷的南部。实际上这是热带草原，温带大陆性的话应该不会有这么典型的一团一团的草的。<br><img src="/img/tuxun/cases/16.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=16ecb580-06d0-11ee-ab40-2bdea2c51865&amp;round=1" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=16ecb580-06d0-11ee-ab40-2bdea2c51865&amp;round=1</a> 这是希腊，我选的俄罗斯。因为我觉得这里叶子有枯，并且是变黄的，应该是秋冬的落叶，而不是干燥所致，所以是大陆性气候。<br><img src="/img/tuxun/cases/17.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=3f2b8c00-06e5-11ee-96e6-452f8f9a8409&amp;round=2" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=3f2b8c00-06e5-11ee-96e6-452f8f9a8409&amp;round=2</a> 这是第二次遇到日本九州岛了。我又把它当成北方的温带大陆气候了。这图里面很多芦苇。<br><img src="/img/tuxun/cases/18.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=3f2b8c00-06e5-11ee-96e6-452f8f9a8409&amp;round=1" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=3f2b8c00-06e5-11ee-96e6-452f8f9a8409&amp;round=1</a> 这是典型的热带草原，南半球。东西北三面环山，我选的巴西东北，实际上阿根廷西北也构成。<br><img src="/img/tuxun/cases/19.png"><br>这题是看电线杆来判定么？<br><img src="/img/tuxun/cases/19b.png"></p><p><a href="https://tuxun.fun/replay_pano?gameId=31403e90-06e7-11ee-86d7-1101216a0f3c&amp;round=3" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=31403e90-06e7-11ee-86d7-1101216a0f3c&amp;round=3</a> 这是个热带季风气候。实际上是印度靠近新德里附近。<br><img src="/img/tuxun/cases/20.png"></p><h2 id="21-30"><a href="#21-30" class="headerlink" title="21-30"></a>21-30</h2><p><a href="https://tuxun.fun/replay_pano?gameId=31403e90-06e7-11ee-86d7-1101216a0f3c&amp;round=1" target="_blank" rel="noopener">https://tuxun.fun/replay_pano?gameId=31403e90-06e7-11ee-86d7-1101216a0f3c&amp;round=1</a> 这种树林墙我就想到俄罗斯。但这个是阔叶林的墙，俄罗斯的可能偏针叶林一点，最终这个是在拉脱维亚和爱沙尼亚交界处。所谓波罗的海三国。看来漂亮的还是海洋性气候啊。</p><h1 id="有趣的复盘链接"><a href="#有趣的复盘链接" class="headerlink" title="有趣的复盘链接"></a>有趣的复盘链接</h1><p><a href="https://tuxun.fun/replay?gameId=58618676-ff01-11ed-9f6a-9f7cb4f02bb2" target="_blank" rel="noopener">https://tuxun.fun/replay?gameId=58618676-ff01-11ed-9f6a-9f7cb4f02bb2</a></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E9%81%93%E8%B7%AF%E9%80%9A%E8%A1%8C%E6%96%B9%E5%90%91" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E9%81%93%E8%B7%AF%E9%80%9A%E8%A1%8C%E6%96%B9%E5%90%91</a><br> 道路行驶方向</li><li><a href="https://zhuanlan.zhihu.com/p/95605737" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/95605737</a></li><li><a href="https://www.bilibili.com/video/BV1Zg4y1V7Pe/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5814e098499298bf9802aa74e8e48451" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Zg4y1V7Pe/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5814e098499298bf9802aa74e8e48451</a></li></ol></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://tuxun.fun/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图寻&lt;/a&gt;是一个有趣的通过图片猜测地点的游戏。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游戏" scheme="http://www.calvinneo.com/tags/游戏/"/>
    
    <category term="地理" scheme="http://www.calvinneo.com/tags/地理/"/>
    
  </entry>
  
  <entry>
    <title>Hazard Pointer</title>
    <link href="http://www.calvinneo.com/2023/05/16/hazptr/"/>
    <id>http://www.calvinneo.com/2023/05/16/hazptr/</id>
    <published>2023-05-16T12:34:22.000Z</published>
    <updated>2023-05-19T16:41:58.642Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Hazard Pointer。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><a href="http://www.cs.otago.ac.nz/cosc440/readings/hazard-pointers.pdf" target="_blank" rel="noopener">Hazard Pointer</a>类似于面向多线程的智能指针，它能够无等待地进行<strong>线程安全的 GC</strong>。在前面提到的 MS 队列中，它的 free 就可以由 HazardPointer 实现。<br>维护一个全局数组 <code>HP hp[N]</code>，其中 N 表示线程的数量。HP 看上去是 ThreadLocal 的，但实际上不是。因为虽然每个线程只能写自己的 HP，但是却可以读所有其他线程的 HP。<br>当需要访问某个指针时，就将这个指针赋值给自己的 HP，也就是通知别人不要释放这个指针。这里的释放被称为 reclaim 或者 deallocate，指的是销毁这个对象。<br>如果同时访问多个指针呢？同样可以扩展HP。比如 HazardPointer 的思维通常是在无锁队列中出现，这个场景最多也就操作一个节点的指针。而如果操作其他数据结构比如树或者图，那么一个线程可以同时访问多个指针。<br>每个线程维护一个私有链表，称为 retired。当该线程准备释放一个指针时，如果此时这个指针还有 reader，则不能立即 gc 掉这个指针，此时把该指针放入 retired 链表中。被 retire 的指针不再可以被新的 reader 访问了，但它仍旧可以被之前就已经指向了的 reader 访问。<br>当一个线程要释放某个指针时，它需要检查全局的 HP 数组。如果有一个线程的 HP 指向这个指针，则不能释放。</p><h2 id="Why-Hazard-Pointer"><a href="#Why-Hazard-Pointer" class="headerlink" title="Why Hazard Pointer"></a>Why Hazard Pointer</h2><p>HP 是用来实现安全地释放某个指针的。这里的安全指的是当有 reader 在读的时候，不能立即销毁该指针指向的对象。例如考虑一个线程在遍历链表，另一个线程在移除链表中的某些节点，这两个线程是不互相知晓对方的。如果在删除时，读线程已经持有了访问该节点的指针，那么这个节点就不能被立即删除。诸如此类的场景称为 Deferred Reclamation。</p><p>一些做法可以解决该问题，比如引用计数。例如可以分别维护读引用计数和写引用计数，这样当一个写在发生前，总可以先检查两个引用计数是否都是0。它的缺点是，无论是读还是写，都需要访问一个共享的用来计数的结构。也许这个结构可以借助于原子操作实现得“轻量”，但无论如何，竞争访问(contention)是少不了的。但考虑一个读多写少的场景，也就是大部分时候压根就不会写那个借助引用计数维护的对象，无论它是一个链表节点，或者是一个别的什么。那是否可以让读操作避免去访问共享对象，从而减少竞争呢？这就是 Hazard Pointer 的思想。这样各个读操作之间没有竞争。</p><p>除了 hazard pointer，还有诸如 epoch-based 或者 RCU 的做法来解决问题。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>本章节中会进一步研究 hp 实现的原理，并基于 folly 的实现给出一份 Rust 的实现。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>如下所示，蓝色的是读线程，紫色的是写线程。reader 在读 hp 指向的那个 x，而 writer 通过 cas 来把 x 替换成 y。每个 reader，都持有一个 harzard pointer。这里面的东西，要么是空的，要么是当前线程正在使用的 pointer。writer 会检查所有的 hp，检查里面是否包含了自己要 gc 的地址。如果有，说明现在还有 reader 访问，writer 就会 yield 掉，做一些其他的事情，等过一段时间再检查 hazard pointer。等到没有 reader 访问这个 old value 了，writer 就会销毁掉它。</p><p>对于每个对象，它所有的 reader 组成一个链表。如何保证 hp 链表的线程安全？我们不会在使用完某个 hp 后就释放它，而是通过 cas 将它设置为空。所以这些链表中的 hp 是可以被复用的。所以，在获取 hp 的时候，是有一些竞争的，但相比新分配一个 hp，或者 cas 整个链表会好很多。</p><p><img src="/img/hazptr/folly1.png"></p><blockquote><p>这里还讲了 wait free 的实现依赖于 memory reclamation，而不是反过来。所以无法利用某种 wait free 的算法来实现 hp。</p></blockquote><blockquote><p>epoch 的方式更 batch 一些，也更消耗内存。因为只有在 epoch 结束之后，才能释放这个 epoch 中的所有对象。</p></blockquote><p>reader 如何访问 x 呢？ reader 设置 hp，然后后面的 writer 在释放 old value 前进行检查会看到有 hp 被设置了，从而推迟销毁。<br>但这个方案是存在问题的，问题的实质是 hp 和 hp 保护的 ptr 的读写不是原子的。所以考虑下面的顺序，可以发现 W 在还有 R 读 old value 的时候就把 old value 销毁了，这显然是不安全的</p><ol><li>R 读 ptr</li><li>W 更新 ptr</li><li>W 检查 hp</li><li>W 销毁 old value</li><li>R 更新 hp</li></ol><p><img src="/img/hazptr/folly2.png"></p><p>这里有个疑问，如果先更新 hp，再读取 ptr 是否可行呢？这是不可行的，因为 hp 里面要填入它保护的 ptr，所以必须先取到 ptr。</p><p>因此设计下面的过程：</p><ol><li>R 读 ptr，读到值为 ptr1。</li><li>R 更新 hp。</li><li>R 再读 ptr，确保此时读到的值还是 ptr1，此时视为 R 可以安全读 ptr 的值。否则 R 就需要加载最新的 ptr，然后重复这个过程。</li><li>W 更新 ptr。</li><li>W 检查 hp。</li></ol><p>这样的话，如果在 2 和 3 之间有一个 writer 进行了 CAS，那么它会导致 3 读出来的 ptr 发生变化，这样 reader 就能重试。如果在 3 之后有一个 writer，那么 writer 在看到 hp 之后就会重试。</p><h2 id="folly-的接口"><a href="#folly-的接口" class="headerlink" title="folly 的接口"></a>folly 的接口</h2><p>本章节中，研究 folly 的接口，并尝试用 Rust 来实现一份接口。</p><p>一个类继承 hazptr_obj_base 才可以被用 hp 维护。这个 hazptr_obj_base 中有一个 retire 方法。为什么要这么做呢？其实大可以把 MyType 用 HazPtrTarget 包一层，但这样就多了一层间接，用起来不方便。就是想把 HazPtrTarget 里面的一些功能 trait 出来，让 MyType 实现。这样的话，就不需要外面包一层了。当然，后面会发现因为 Rust 中不能往 trait 里面放比如 <code>hazptrs: LinkedList&lt;HazPtrHolder&gt;</code> 之类的 field，所以作者还是包了一层。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicPtr&lt;MyType&gt;</span><br><span class="line">AtomicPtr&lt;HazPtrTarget&lt;MyType&gt;&gt;</span><br></pre></td></tr></table></figure><p>一个 retire 的对象，不再 accessible，但仍然被 hp 保护。在 reclaim 阶段，会检查该对象是否可以被删除。</p><p>另外，为什么提供一个显式的 retire 函数，而不直接在析构的时候做 retire 相关的事情。作者觉得这是一个 taste 的问题，<code>drop(*)</code> 有点奇怪的。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> old: *<span class="keyword">mut</span> HazPtrTarget&lt;MyType&gt; = x.swap(new);</span><br><span class="line">HazPtrTarget::retire(old); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">drop</span>(*old); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>在访问需要保护的对象前，需要首先创建一个 hazptr_holder。holder 是 reader 实际操作的对象。holder 会检查自己是否拥有 hp，如果没有的话，会从对应的 domain 去 acquire 一个。<br>holder 的方法 get_protected 接受一个 <code>AtomicPtr&lt;T&gt;</code>，也就是需要保护的对象。它返回一个不可变引用，这个引用是被 hp 保护的了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> HazPtrHolder &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_protected</span></span>&lt;<span class="symbol">'a</span>, T&gt;(&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="keyword">self</span>, &amp;<span class="symbol">'_</span> AtomicPtr&lt;T&gt;) -&gt; &amp;<span class="symbol">'a</span> T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，无所谓这个 <code>AtomicPtr&lt;T&gt;</code> 的生命周期，因为实际是为了拿到它维护的指针。【Q】那为什么要这个 AtomicPtr 保护一下呢？这和之前说的要读两次 ptr 有关，也就是需要原子地从 ptr 上 load 出它当前的值。<br>其次，即使返回 &amp;T，我们依旧需要 &amp;mut self。这是为了避免先 get_protected a 之后又 get_protected b，这样 a 实际上就不被保护了。<br>最后，返回的 &amp;T 的生命周期是和 HazPtrHolder 一致的。</p><p>如图所示，retire(x) 调用时，发现 x 还在被访问，不能直接 reclaim，所以记录到 retire 表中。retire(y) 调用的时候，发现 y 在被访问，但 x 已经不再被访问了，所以 reclaim x，然后把 y 记录在表中。<br><img src="/img/hazptr/folly3.png"></p><p>演讲者认为 folly 的 demo 存在一些疏漏。如果 V 是一个引用类型的话，则可能出现问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///   // Called frequently</span></span><br><span class="line"><span class="comment">///   U get_config(V v) &#123;</span></span><br><span class="line"><span class="comment">///     hazptr_holder h = make_hazard_pointer();</span></span><br><span class="line"><span class="comment">///     Config* ptr = h.protect(config_);</span></span><br><span class="line"><span class="comment">///     /* safe to access *ptr as long as it is protected by h */</span></span><br><span class="line"><span class="comment">///     return ptr-&gt;get_config(v);</span></span><br><span class="line"><span class="comment">///     /* h dtor resets and releases the owned hazard pointer,</span></span><br><span class="line"><span class="comment">///        *ptr will be no longer protected by this hazard pointer */</span></span><br><span class="line"><span class="comment">///   &#125;</span></span><br></pre></td></tr></table></figure><p>下图列出 haz holder、haz pointer、atomic 和 haz obj 的关系。<br>看起来 holder 是 reader 实际操作的对象。holder 会检查自己是否拥有 hp，如果没有的话，会从对应的 domain 去 acquire 一个。<br><img src="/img/hazptr/folly4.png"></p><p>这里 non-typical 的是比如去 dfs 遍历一棵树，然后对于树的每一层都有一个 hp 来记录。这样的话，每个线程的 hp 的数量是 log(d) 而不是常数。<br>第二段的意思是，retire 但还没有 reclaim 的 haz ptr 的数量，和 hp 的数量是线性的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Memory Usage</span></span><br><span class="line"><span class="comment">/// ------------</span></span><br><span class="line"><span class="comment">/// - The size of the metadata for the hazptr library is linear in the</span></span><br><span class="line"><span class="comment">///   number of threads using hazard pointers, assuming a constant</span></span><br><span class="line"><span class="comment">///   number of hazard pointers per thread, which is typical.</span></span><br><span class="line"><span class="comment">/// - The typical number of reclaimable but not yet reclaimed of</span></span><br><span class="line"><span class="comment">///   objects is linear in the number of hazard pointers, which</span></span><br><span class="line"><span class="comment">///   typically is linear in the number of threads using hazard</span></span><br><span class="line"><span class="comment">///   pointers.</span></span><br></pre></td></tr></table></figure><p>下面的 Rust 代码展示了 hp 的大概使用方法。这里的 HazPtrHolder::load 类似于 get_protected。可以看到，当 HazPtrHolder 被析构后，就不再可以使用 my_x 了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">feels_good</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = AtomicPtr::new(<span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="number">42</span>))); <span class="comment">// x: AtomicPtr&lt;i32&gt;</span></span><br><span class="line">    <span class="comment">// As a reader:</span></span><br><span class="line">    <span class="keyword">let</span> h = HazPtrHolder::<span class="keyword">default</span>();</span><br><span class="line">    <span class="keyword">let</span> my_x: &amp;<span class="built_in">i32</span> = h.load(&amp;x);</span><br><span class="line">    <span class="built_in">drop</span>(h);</span><br><span class="line">    <span class="comment">// invalid:</span></span><br><span class="line">    <span class="keyword">let</span> _ = *my_x;</span><br><span class="line">    <span class="comment">// As a writer:</span></span><br><span class="line">    <span class="keyword">let</span> old = x.swap(</span><br><span class="line">        <span class="built_in">Box</span>::into_raw(<span class="built_in">Box</span>::new(<span class="number">9001</span>)),</span><br><span class="line">        Ordering::SeqCst,</span><br><span class="line">    );</span><br><span class="line">    HazPtrobject::retire(old);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码也有几个不尽如人意的地方：</p><ol><li>首先是 AtomicPtr 可能接受一个 null，但我们的场景中实际要禁止 null。显然 Rust 中缺少一个 NotNullAtomicPtr 的结构。</li></ol><p>下面就是 load 的实现。分为两部分：</p><ol><li>尝试获得一个 hp，如果当前的 holder 尚未绑定一个 hp，就从 domain 上 acquire 一个。acquire 的实现类似从链表里面取一个可用节点，这在后面介绍。</li><li>从 AtomicPtr 中加载 ptr，放到刚才获得的 hp 里面，也就是 protect 方法。然后再从 ptr 中读一遍，确保现在读到的 ptr2 等于之前的 ptr1。</li></ol><p>这里能够在 ptr1 == ptr2 的时候返回 ptr1，其安全性在于：</p><ol><li>ptr1 不可能被释放，因为它此时至少受到我们刚创建的 hp 的保护。</li><li>caller 保证 AtomicPtr 非空，并且只可能通过 retire 来被释放掉。</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">load</span></span>&lt;T&gt;(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, ptr: &amp;<span class="symbol">'_</span> AtomicPtr&lt;T&gt;) -&gt; <span class="built_in">Option</span>&lt;&amp;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> hazptr = <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(hazptr) = <span class="keyword">self</span>.<span class="number">0</span> &#123;</span><br><span class="line">        hazptr</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> hazptr = SHARED_DOMAIN.acquire();</span><br><span class="line">        <span class="keyword">self</span>.<span class="number">0</span> = <span class="literal">Some</span>(hazptr);</span><br><span class="line">        hazptr</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> ptr1 = ptr.load(Ordering::SeqCst);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        hazptr.protect(ptr1);</span><br><span class="line">        <span class="keyword">let</span> ptr2 = ptr.load(Ordering::SeqCst);</span><br><span class="line">        <span class="keyword">if</span> ptr1 == ptr2 &#123;</span><br><span class="line">            <span class="comment">// All good -- protected</span></span><br><span class="line">            <span class="keyword">break</span> <span class="literal">Some</span>(todo!())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ptr1 = ptr2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面卡在 <code>impl&lt;T&gt; HazPtrObject for T</code> 的 domain 方法上了。这个 domain 方法要返回一个 HazPtrDomain，但写不下去了。因为无法从 trait HazPtrObject 或者任一类型 T 中去取到它被绑定的 domain。所以我们得引入一个 <code>HazPtrObjectWrapper&lt;T&gt;</code> 来保存 domain。这个 Wrapper 可以解引用为 T，还实现了 HazPtrObject。哎，所以这不是走回 <code>AtomicPtr&lt;HazPtrTarget&lt;MyType&gt;&gt;</code> 这样的老路了么。</p><p>这里遇到一个 Drop 相关的问题，他要把 self cast 成一个 <code>*mut dyn Drop</code>，这要求 HazPtrObject 的 Self 必须 impl Drop。但 Rust 又报一个 warning 说 HazPtrObject 继承一个 Drop trait 是多余的。搞到最后作者也没办法去掉这 warning，只能通过 drop_bounds 去禁用掉这个 warning。在视频的第二部分，通过用一个新的空的 trait Reclaim 替换 Drop 来解决掉那个多的 warning。毕竟我们核心只是要一个虚表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(drop_bounds)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">HazPtrObject</span></span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    <span class="keyword">Self</span>: <span class="built_in">Sized</span> + <span class="built_in">Drop</span> + <span class="symbol">'static</span>,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">domain</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;HazPtrDomain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">retire</span></span>(<span class="keyword">self</span>: *<span class="keyword">mut</span> <span class="keyword">Self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> !std::mem::needs_drop::&lt;<span class="keyword">Self</span>&gt;() &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; &amp;*<span class="keyword">self</span> &#125;.domain().retire(<span class="keyword">self</span> <span class="keyword">as</span> *<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续引入一个 trait Deleter，给到 retire 函数，用来指定如何删除这个对象。</p><p>然后说了下，测试里面的 swap 之后，还需要 retire 才能语义上保证 old 不会再 accessible 了。borrow checker 保证了，在调用 reset 的时候，不可能持有一个 load 得到的 &amp;T 指针。这是因为 load 和 reset 都需要 mut borrow。</p><p>下面实现 HazPtrDomain::acquire。我们遍历 domain 维护的整个链表，找到第一个 active 为 false 的节点并返回。注意 active 为 true 表示这个 node 正在被使用。如果遍历完整个链表都找不到，则需要扩容链表。这里的链表扩容挺符合直觉的，是一个经典的 loop cas，每次都想办法更新 head。如果 cas 失败，说明 head 已经被其他线程更新了，就重试一次。但是重试前要更新自己的 next 为新的 head。</p><p>bulk_reclaim 尝试 reclaim 掉所有可以被 gc 的对象。这里说一下，一个对象 retire 之后，就会从 hp 链表中被删掉，然后放到 retire 链表里。如果是这样的话，又在放到 retire 链表之前线程崩了，那么这个对象是不是泄露了？其实 retire 只会设置 hp 的 active 为 false。</p><p>如果此时 retire 被某个线程拿过去回收了，所以 retire 是 nullptr，然后又有一个新的节点要加到 retire 上，会不会导致出现两个 retire 链表？关于这个问题，看后面的实现就可以知道不会发生。他的做法并不是 swap 两个链表，而是在处理完老 retire 的 tail 后，将它的 next 设置为新 retired 链表的 head，然后再尝试更新 retire 为老 retire 的 head。结果就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| 老 retire 中尚未释放的链表的 head | 新 retire 的 head |</span><br></pre></td></tr></table></figure><p>如何判断 retire 链表中的元素是可以被安全删除的呢？这里会遍历 hazptrs 链表，将遍历得到的指针全记录在 guarded_ptrs 中。我想其中一个要点是，如果一个指针被 retire 了：</p><ol><li>那么它就不会再出现在 hazptrs 链表中，因为它不可能被新的线程所访问。</li><li>因为它还没有被 reclaim，所以也不会在 hazptrs 中出现分配在同一个位置上的另一个对象。</li></ol><p>后面是对 Deleter 的实现。Deleter 是负责真正 reclaim 这个 ptr 的。Deleter 的作用是标记到底要 delete 什么对象。这个是通过 trait 里面的 vtable 来实现的。<br>第一版是这个写法。DropBox 适合用来析构从 Box 创建的对象。而 drop_in_place 应该可以在任何情况下被使用。但如果这个 ptr type 本身需要 drop 的话，可能会内存泄露。所以作者两种都提供了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DropInPlace</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Deleter <span class="keyword">for</span> DropInPlace &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(ptr: *<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> std::ptr::drop_in_place(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">DropBox</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Deleter <span class="keyword">for</span> DropBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(ptr: *<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> _ = <span class="built_in">Box</span>::from_raw(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可能是他觉得用一个类包一下有点丑，所以就写了下面的方案。但这样写会报错，说后面那个 fn 没有 impl Deleter。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Deleter <span class="keyword">for</span> <span class="function"><span class="keyword">fn</span></span>(*<span class="keyword">mut</span> (dyn <span class="built_in">Drop</span> +<span class="symbol">'static</span>)) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(&amp;<span class="keyword">self</span>, ptr:*<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) &#123;</span><br><span class="line">        (*<span class="keyword">self</span>)(ptr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的原因是，需要传一个 fat pointer，一个带虚表的 pointer 给 retire，但一个 raw function 不是 fat pointer。</p><p>下面的代码是可以过的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">drop_box</span></span>(ptr:*<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _ = <span class="keyword">unsafe</span> &#123; <span class="built_in">Box</span>::from_raw(ptr) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> FOO: <span class="function"><span class="keyword">fn</span></span>(*<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) = drop_box;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123; old.retire(&amp;FOO) &#125;;</span><br></pre></td></tr></table></figure><p>另外，类型转换也能过</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">drop_in_place</span></span>(ptr: *<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; std::ptr::drop_in_place(ptr) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123; old.retire(&amp;(drop_in_place <span class="keyword">as</span> <span class="function"><span class="keyword">fn</span></span>(*<span class="keyword">mut</span> dyn <span class="built_in">Drop</span>))) &#125;;</span><br></pre></td></tr></table></figure><p>在这个讲座的第二部分，介绍了原代码的几个问题：</p><ol><li>在 reclaim 统计 ptr 数量的时候，需要过滤掉 inactive 的。这个也说明了 active 的作用，就是当一个 hp 被 retire 之后，它会被标记为 inactive，等待下一轮被拿出来复用，而不是从链表中摘出来释放掉。</li><li>在之前 HazPtrObject::reclaim 的实现中，也许 Self 不需要被 drop。但 <code>*mut Self</code> 可能来自于一个 Box，这个 Box 本身需要被 drop。因此不能简单判断 needs_drop 然后就跳过。</li><li>在 HazPtrDomain::bulk_reclaim 中，在没有判断 <code>guarded_ptrs.contains(&amp;(n.ptr as *mut u8))</code> 的前提下，就在前面 Box::from_raw 去获取所有权了。这个是不正确的，因为此时可能有 reader 在访问。<br> 正确的做法应该如下所示，去获取 <code>n</code> 也就是解出来的一个共享的引用。 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n = <span class="keyword">unsafe</span> &#123; &amp;*node &#125;;</span><br><span class="line">node = n.next.get_mut():</span><br></pre></td></tr></table></figure></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r3.pdf" target="_blank" rel="noopener">https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1121r3.pdf</a></li><li><a href="https://github.com/jonhoo/haphazard/blob/7f0d8d62e071f8bc55233a3d2437225d6282e368/src/lib.rs" target="_blank" rel="noopener">https://github.com/jonhoo/haphazard/blob/7f0d8d62e071f8bc55233a3d2437225d6282e368/src/lib.rs</a><br> Rust HazPtr 作者的第一部视频结束后的代码。</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Hazard Pointer。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
    <category term="多线程" scheme="http://www.calvinneo.com/tags/多线程/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>Excerpt from Harry Potter</title>
    <link href="http://www.calvinneo.com/2023/04/09/excerpt_harry_potter/"/>
    <id>http://www.calvinneo.com/2023/04/09/excerpt_harry_potter/</id>
    <published>2023-04-09T15:20:37.000Z</published>
    <updated>2024-01-20T13:25:51.099Z</updated>
    
    <content type="html"><![CDATA[<p>While rereading Harry Potter, I found these fragments are inspiring and interesting.</p><a id="more"></a><h1 id="HP1"><a href="#HP1" class="headerlink" title="HP1"></a>HP1</h1><p>“No, thanks,” said Harry. “The poor toilet’s never had anything as horrible as your head down it — it might be sick.” Then he ran, before Dudley could work out what he’d said. </p><p>But from that moment on, Hermione Granger became their friend. There are some things you can’t share without ending up liking each other, and knocking out a twelve-foot mountain troll is one of them. </p><p>It does not do to dwell on dreams and forget to live, remember that.</p><p>Everyone fell over laughing except Hermione, who leapt up and performed the countercurse. Neville’s legs sprang apart and he got to his feet, trembling. </p><p>“Call him Voldemort, Harry. Always use the proper name for things. Fear of a name increases fear of the thing itself.”</p><p>“There are all kinds of courage,” said Dumbledore, smiling. “It takes a great deal of bravery to stand up to our enemies, but just as much to stand up to our friends. I therefore award ten points to Mr. Neville Longbottom.”</p><h1 id="HP2"><a href="#HP2" class="headerlink" title="HP2"></a>HP2</h1><p>“Did you really?” said Mr. Weasley eagerly. “Did it go all right? I — I mean,” he faltered as sparks flew from Mrs. Weasley’s eyes, “that — that was very wrong, boys — very wrong indeed. . . .” </p><blockquote><p>help will always be given at Hogwarts to those who ask for it.</p></blockquote><p>“However,” said Dumbledore, speaking very slowly and clearly so that none of them could miss a word, “you will find that I will only truly have left this school when none here are loyal to me. You will also find that help will always be given at Hogwarts to those who ask for it.” </p><blockquote><p>“because I asked not to go in Slytherin.” What really matters is one’s choice.</p></blockquote><p>“It only put me in Gryffindor,” said Harry in a defeated voice,<br>“because I asked not to go in Slytherin. . . .”<br>“Exactly,” said Dumbledore, beaming once more. “Which makes you very different from Tom Riddle. It is our choices, Harry, that show what we truly are, far more than our abilities.” Harry sat motionless in his chair, stunned. “If you want proof, Harry, that you belong in Gryffindor, I suggest you look more closely at this.”<br>Dumbledore reached across to Professor McGonagall’s desk, picked up the blood-stained silver sword, and handed it to Harry. Dully, Harry turned it over, the rubies blazing in the firelight. And then he saw the name engraved just below the hilt.<br>Godric Gryffindor.<br>“Only a true Gryffindor could have pulled that out of the hat, Harry,” said Dumbledore simply.</p><blockquote><p>“Dobby is free”</p></blockquote><p>“Master has given a sock,” said the elf in wonderment. “Master gave it to Dobby.”<br>“What’s that?” spat Mr. Malfoy. “What did you say?”<br>“Got a sock,” said Dobby in disbelief. “Master threw it, and Dobby caught it, and Dobby — Dobby is free.”</p><h1 id="HP3"><a href="#HP3" class="headerlink" title="HP3"></a>HP3</h1><blockquote><p>Very accurate prophecy</p></blockquote><p>“I dare not, Headmaster! If I join the table, we shall be thirteen! Nothing could be more unlucky! Never forget that when thirteen dine together, the first to rise will be the first to die!”</p><blockquote><p>Very accurate prophecy too</p></blockquote><p>“If you must know, Minerva, I have seen that poor Professor Lupin will not be with us for very long. He seems aware, himself, that his time is short. He positively fled when I offered to crystal gaze for him —“ </p><blockquote><p>This scene is a wonderful scene in the movie<br>“Have you ever seen anything quite as pathetic?” said Malfoy.<br>“And he’s supposed to be our teacher!”<br>Harry and Ron both made furious moves toward Malfoy, but Hermione got there first — SMACK!<br>She had slapped Malfoy across the face with all the strength she could muster. Malfoy staggered. Harry, Ron, Crabbe, and Goyle stood flabbergasted as Hermione raised her hand again.</p></blockquote><p>“YOU CHEATING SCUM!” Lee Jordan was howling into the megaphone, dancing out of Professor McGonagall’s reach. “YOU FILTHY, CHEATING B —“</p><blockquote><p>In Chinese version, it is fist rather than finger. But finger here is more vivid.<br>Professor McGonagall didn”t even bother to tell him off. She was actually shaking her finger in Malfoy’s direction, her hat had fallen off, and she too was shouting furiously.</p></blockquote><p>“I must admit, Peter, I have difficulty in understanding why an innocent man would want to spend twelve years as a rat,” said Lupin evenly.</p><p>“If you made a better rat than a human, it’s not much to boast about, Peter,” said Black harshly. </p><p>“You don’t understand!” whined Pettigrew. “He would have killed me, Sirius!”<br>“THEN YOU SHOULD HAVE DIED!” roared Black. “DIED RATHER THAN BETRAY YOUR FRIENDS, AS WE WOULD HAVE DONE FOR YOU!”<br>Black and Lupin stood shoulder to shoulder, wands raised.<br>“You should have realized,” said Lupin quietly, “if Voldemort didn’t kill you, we would. Good-bye, Peter.” </p><p>“I’m not doing this for you. I’m doing it because — I don’t reckon my dad would’ve wanted them to become killers — just for you.”</p><blockquote><p>You know, Minister, I disagree with Dumbledore on many counts . . . but you cannot deny he’s got style. . . .</p></blockquote><p>“What we need,” said Dumbledore slowly, and his light blue eyes moved from Harry to Hermione, “is more time.”<br>“But —“ Hermione began. And then her eyes became very round. “OH!”<br>“Now, pay attention,” said Dumbledore, speaking very low, and very clearly. “Sirius is locked in Professor Flitwick’s office on the seventh floor. Thirteenth window from the right of the West Tower. If all goes well, you will be able to save more than one innocent life tonight. But remember this, both of you: you must not be seen. Miss Granger, you know the law — you know what is at stake. . . . You — must — not — be — seen.”</p><p>“Dumbledore just said — just said we could save more than one innocent life. . . .” And then it hit him. “Hermione, we’re going to save Buckbeak!”</p><blockquote><p>He knew it!</p></blockquote><p>Harry tugged harder on the rope around Buckbeak’s neck. The hippogriff began to walk, rustling its wings irritably. They were still ten feet away from the forest, in plain view of Hagrid’s back door.<br>“One moment, please, Macnair,” came Dumbledore’s voice.<br>“You need to sign too.” The footsteps stopped. Harry heaved on the rope. Buckbeak snapped his beak and walked a little faster. </p><blockquote><p>You can always rely on yourself</p></blockquote><p>And then it hit him — he understood. He hadn’t seen his father — he had seen himself — Harry flung himself out from behind the bush and pulled out his wand.<br>“EXPECTO PATRONUM!” he yelled. </p><blockquote><p>It made all the difference in the world</p></blockquote><p>“It didn’t make any difference,” said Harry bitterly. “Pettigrew got away.”<br>“Didn’t make any difference?” said Dumbledore quietly. “It made all the difference in the world, Harry. You helped uncover the truth. You saved an innocent man from a terrible fate.”</p><blockquote><p>We all know in HP7, Pettigrew gave his life to save Harry.</p></blockquote><p>This is magic at its deepest, its most impenetrable, Harry. But trust me … the time may come when you will be very glad you saved Pettigrew’s life.</p><p>“You think the dead we loved ever truly leave us? You think that<br>we don”t recall them more clearly than ever in times of great trouble? Your father is alive in you, Harry, and shows himself most plainly when you have need of him. How else could you produce that particular Patronus? Prongs rode again last night.”<br>It took a moment for Harry to realize what Dumbledore had said.</p><h1 id="HP4"><a href="#HP4" class="headerlink" title="HP4"></a>HP4</h1><blockquote><p>The bar that leads to diag alley is called leaking cauldron<br>“We’re not thundering,” said Ron irritably. “We’re walking. Sorry if we’ve disturbed the top-secret workings of the Ministry of Magic.”<br>“What are you working on?” said Harry.<br>“A report for the Department of International Magical Cooperation,” said Percy smugly. “We’re trying to standardize cauldron thickness. Some of these foreign imports are just a shade too thin — leakages have been increasing at a rate of almost three percent a year —“<br>“That’ll change the world, that report will,” said Ron. “Front page of the Daily Prophet, I expect, cauldron leaks.” </p></blockquote><blockquote><p>Crouch can’t even spell Percy’s name correctly.</p></blockquote><p>“Ludo, we need to meet the Bulgarians, you know,” said Mr. Crouch sharply, cutting Bagman’s remarks short. “Thank you for the tea, Weatherby.” </p><blockquote><p>It was the only time the brothers have seem what they will look like when they get old.</p></blockquote><p>The entrance hall rang with laughter. Even Fred and George joined in, once they had gotten to their feet and taken a good look at each other’s beards.</p><blockquote><p>“because Dobby wants paying now”</p></blockquote><p>“Dobby has traveled the country for two whole years, sir, trying to find work!” Dobby squeaked. “But Dobby hasn’t found work, sir, because Dobby wants paying now!”<br>The house-elves all around the kitchen, who had been listening and watching with interest, all looked away at these words, as though Dobby had said something rude and embarrassing.<br>Hermione, however, said, “Good for you, Dobby!”<br>“Thank you, miss!” said Dobby, grinning toothily at her. “But most wizards doesn’t want a house-elf who wants paying, miss. ‘That’s not the point of a house-elf,’ they says, and they slammed the door in Dobby’s face! Dobby likes work, but he wants to wear clothes and he wants to be paid, Harry Potter. . . . Dobby likes being free!”</p><p>“Oh no, sir, no,” said Dobby, looking suddenly serious. “ ‘Tis part of the house-elf’s enslavement, sir. We keeps their secrets and our silence, sir. We upholds the family’s honor, and we never speaks ill of them — though Professor Dumbledore told Dobby he does not insist upon this. Professor Dumbledore said we is free to — to —“<br>Dobby looked suddenly nervous and beckoned Harry closer.<br>Harry bent forward. Dobby whispered, “He said we is free to call him a — a barmy old codger if we likes, sir!”<br>Dobby gave a frightened sort of giggle.<br>“But Dobby is not wanting to, Harry Potter,” he said, talking normally again, and shaking his head so that his ears flapped.<br>“Dobby likes Professor Dumbledore very much, sir, and is proud to keep his secrets and our silence for him.”</p><blockquote><p>“temporarily deaf”</p></blockquote><p>“Of course we still want to know you!” Harry said, staring at Hagrid. “You don’t think anything that Skeeter cow — sorry, Professor,” he added quickly, looking at Dumbledore.<br>“I have gone temporarily deaf and haven’t any idea what you said, Harry,” said Dumbledore, twiddling his thumbs and staring at the ceiling. </p><p>“Really, Hagrid, if you are holding out for universal popularity,<br>I’m afraid you will be in this cabin for a very long time,” said Dumbledore, now peering sternly over his half-moon spectacles. “Not a week has passed since I became headmaster of this school when I haven’t had at least one owl complaining about the way I run it. But what should I do? Barricade myself in my study and refuse to talk to anybody?”</p><blockquote><p>Another subtle foreshadowing. One must finish reading the entire book before being impressed by Dumbledore’s foresight.</p></blockquote><p>For a fleeting instant, Harry thought he saw a gleam of something like triumph in Dumbledore’s eyes.</p><p>“You are blinded,” said Dumbledore, his voice rising now, the aura of power around him palpable, his eyes blazing once more, “by the love of the office you hold, Cornelius! You place too much importance, and you always have done, on the so-called purity of blood! You fail to recognize that it matters not what someone is born, but what they grow to be! Your dementor has just destroyed the last remaining member of a pure-blood family as old as any — and see what that man chose to make of his life! </p><blockquote><p>“make a choice between what is right and what is easy”.</p></blockquote><p>Remember Cedric. Remember, if the time should come when you have to make a choice between what is right and what is easy, remember what happened to a boy who was good, and kind, and brave, because he strayed across the path of Lord Voldemort. Remember Cedric Diggory.</p><p>“Listen,” said Harry firmly. “If you don’t take it, I’m throwing it down the drain. I don’t want it and I don’t need it. But I could do with a few laughs. We could all do with a few laughs. I’ve got a feeling we’re going to need them more than usual before long.” </p><h1 id="HP5"><a href="#HP5" class="headerlink" title="HP5"></a>HP5</h1><blockquote><p>DO NOT SURRENDER YOUR WAND</p></blockquote><p>Harry —<br>Dumbledore’s just arrived at the Ministry, and he’s trying to sort it all out. DO NOT LEAVE YOUR AUNT AND UNCLE’S HOUSE. DO NOT DO ANY MORE MAGIC. DO NOT SURRENDER YOUR WAND</p><blockquote><p>I think it’s funny, since it remind me of Sir Humphrey Appleby.</p></blockquote><p>… because some changes will be for the better, while others will come, in the fullness of time, to be recognized as errors of judgment. Meanwhile, some old habits will be retained, and rightly so, whereas others, outmoded and outworn, must be abandoned. Let us move forward, then, into a new era of openness, effectiveness, and accountability, intent on preserving what ought to be preserved, perfecting what needs to be perfected, and pruning wherever we find practices that ought to be prohibited.</p><p>“You told her He-Who-Must-Not-Be-Named is back?<br>“Yes.”<br>Professor McGonagall sat down behind her desk, frowning at Harry.<br>Then she said, “Have a biscuit, Potter.”</p><blockquote><p>That tells the difference between Hermione and Percy.</p></blockquote><p>“You disagree?”<br>“Yes, I do,” said Hermione, who, unlike Umbridge, was not whispering, but speaking in a clear, carrying voice that had by now attracted the rest of the class’s attention. “Mr. Slinkhard doesn’t like jinxes, does he? But I think they can be very useful when they’re used defensively.” </p><blockquote><p>Ron’s awkward compliment shows the subtle change in his relationship with Hermione.</p></blockquote><p>“We do try,” said Ron. “We just haven’t got your brains or your memory or your concentration — you’re just cleverer than we are — is it nice to rub it in?”<br>“Oh, don’t give me that rubbish,” said Hermione, but she looked slightly mollified as she led the way out into the damp courtyard. </p><blockquote><p>Excellent sarcasm.</p></blockquote><p>“For disrupting my class with pointless interruptions,” said Professor Umbridge smoothly. “I am here to teach you using a Ministry approved method that does not include inviting students to give their opinions on matters about which they understand very little. Your previous teachers in this subject may have allowed you more license, but as none of them — with the possible exception of Professor Quirrell, who did at least appear to have restricted himself to age-appropriate subjects — would have passed a Ministry inspection —“<br>“Yeah, Quirrell was a great teacher,” said Harry loudly, “there was just that minor drawback of him having Lord Voldemort sticking out of the back of his head.” </p><blockquote><p>Hermione is not a nerd.</p></blockquote><p>Nobody raised objections after Ernie, though Harry saw Cho’s friend give her a rather reproachful look before adding her name. When the last person — Zacharias — had signed, Hermione took the parchment back and slipped it carefully into her bag. There was an odd feeling in the group now. It was as though they had just signed some kind of contract.</p><p>He was on the sixth stair when it happened. There was a loud, wailing, klaxonlike sound and the steps melted together to make a long, smooth stone slide. There was a brief moment when Ron tried to keep running, arms working madly like windmills, then he toppled over backward and shot down the newly created slide, coming to rest on his back at Harry’s feet. </p><blockquote><p>Umbridge’s confrontation with Snape. Snape refused to say one more word to deal with Umbridge’s nonsense.</p></blockquote><p>“Well, the class seems fairly advanced for their level,” she said briskly to Snape’s back. “Though I would question whether it is advisable to teach them a potion like the Strengthening Solution. I think the Ministry would prefer it if that was removed from the syllabus.”<br>Snape straightened up slowly and turned to look at her.<br>“Now … how long have you been teaching at Hogwarts?” she asked, her quill poised over her clipboard.<br>“Fourteen years,” Snape replied. His expression was unfathomable.<br>His eyes on Snape, Harry added a few drops to his potion; it hissed menacingly and turned from turquoise to orange.<br>“You applied first for the Defense Against the Dark Arts post, I believe?” Professor Umbridge asked Snape.<br>“Yes,” said Snape quietly.<br>“But you were unsuccessful?”<br>Snape’s lip curled.<br>“Obviously.”<br>Professor Umbridge scribbled on her clipboard.<br>“And you have applied regularly for the Defense Against the Dark Arts post since you first joined the school, I believe?”<br>“Yes,” said Snape quietly, barely moving his lips. He looked very angry.<br>“Do you have any idea why Dumbledore has consistently refused to appoint you?” asked Umbridge.<br>“I suggest you ask him,” said Snape jerkily.<br>“Oh I shall,” said Professor Umbridge with a sweet smile.<br>“I suppose this is relevant?” Snape asked, his black eyes narrowed.</p><blockquote><p>It is always wise to take fate firmly in one’s own hands.</p></blockquote><p>“Well, better expelled and able to defend yourselves than sitting safely in school without a clue,” said Sirius. </p><blockquote><p>Some parents are “living through us”.</p></blockquote><p>“You don’t think he has become … sort of … reckless … since he’s been cooped up in Grimmauld Place? You don’t think he’s … kind of … living through us?” </p><blockquote><p>there are things worth dying for</p></blockquote><p>“Your father knew what he was getting into, and he won’t thank you for messing things up for the Order!” said Sirius angrily in his turn. “This is how it is — this is why you’re not in the Order — you don’t understand — there are things worth dying for!”<br>“Easy for you to say, stuck here!” bellowed Fred. “I don’t see you risking your neck!” </p><blockquote><p>Being a victim is not a shame. However, being a fighter is more honorable.</p></blockquote><p>“What’s this?” said Mrs. Longbottom sharply. “Haven’t you told your friends about your parents, Neville?”<br>Neville took a deep breath, looked up at the ceiling, and shook his head. Harry could not remember ever feeling sorrier for anyone, but he could not think of any way of helping Neville out of the situation.<br>“Well, it’s nothing to be ashamed of!” said Mrs. Longbottom angrily. “You should be proud, Neville, proud! They didn’t give their health and their sanity so their only son would be ashamed of them, you know!”<br>“I’m not ashamed,” said Neville very faintly, still looking anywhere but at Harry and the others. Ron was now standing on tiptoe to look over at the inhabitants of the two beds.<br>“Well, you’ve got a funny way of showing it!” said Mrs. Longbottom. “My son and his wife,” she said, turning haughtily to Harry, Ron, Hermione, and Ginny, “were tortured into insanity by You-Know-Who’s followers.”<br>Hermione and Ginny both clapped their hands over their mouths.<br>Ron stopped craning his neck to catch a glimpse of Neville’s parents and looked mortified.<br>“They were Aurors, you know, and very well respected within the Wizarding community,” Mrs. Longbottom went on. “Highly gifted, the pair of them. I — yes, Alice dear, what is it?” </p><blockquote><p>An incisive comment on speech censorship. </p></blockquote><p>“Oh Harry, don’t you see?” Hermione breathed. “If she could have done one thing to make absolutely sure that every single person in this school will read your interview, it was banning it!”</p><blockquote><p>Brilliant irony.</p></blockquote><p>“Oh, so that’s why he wasn’t prosecuted for setting up all those regurgitating toilets!” said Professor McGonagall, raising her eyebrows. “What an interesting insight into our justice system!” </p><blockquote><p>I cannot allow you to manhandle my students</p></blockquote><p>“Well, usually when a person shakes their head,” said McGonagall coldly, “they mean ‘no.’ So unless Miss Edgecombe is using a form of sign language as yet unknown to humans —“<br>Professor Umbridge seized Marietta, pulled her around to face her, and began shaking her very hard. A split second later Dumbledore was on his feet, his wand raised. Kingsley started forward and Umbridge leapt back from Marietta, waving her hands in the air as though they had been burned.<br>“I cannot allow you to manhandle my students, Dolores,” said Dumbledore, and for the first time, he looked angry.<br>“You want to calm yourself, Madam Umbridge,” said Kingsley in  his deep, slow voice. “You don’t want to get yourself into trouble now.”</p><blockquote><p>Dumbledore’s contempt of Fudge jumps off the page.</p></blockquote><p>“Well, the game is up,” he said simply. “Would you like a written confession from me, Cornelius — or will a statement before these witnesses suffice?”<br>Harry saw McGonagall and Kingsley look at each other. There was fear in both faces. He did not understand what was going on, and neither, apparently, did Fudge.<br>“Statement?” said Fudge slowly. “What — I don’t — ?”<br>“Dumbledore’s Army, Cornelius,” said Dumbledore, still smiling as he waved the list of names before Fudge’s face. “Not Potter’s Army. Dumbledore’s Army.”<br>“But — but —“<br>Understanding blazed suddenly in Fudge’s face. He took a horrified step backward, yelped, and jumped out of the fire again.<br>“You?” he whispered, stamping again on his smoldering cloak.<br>“That’s right,” said Dumbledore pleasantly.<br>“You organized this?”<br>“I did,” said Dumbledore.<br>“You recruited these students for — for your army?”<br>“Tonight was supposed to be the first meeting,” said Dumbledore, nodding. “Merely to see whether they would be interested in joining me. I see now that it was a mistake to invite Miss Edgecombe, of course.”<br>Marietta nodded. Fudge looked from her to Dumbledore, his chest swelling.<br>“Then you have been plotting against me!” he yelled.<br>“That’s right,” said Dumbledore cheerfully.<br>“NO!” shouted Harry.<br>Kingsley flashed a look of warning at him, McGonagall widened her eyes threateningly, but it had suddenly dawned upon Harry what Dumbledore was about to do, and he could not let it happen.<br>“No — Professor Dumbledore!”<br>“Be quiet, Harry, or I am afraid you will have to leave my office,” said Dumbledore calmly.<br>“Yes, shut up, Potter!” barked Fudge, who was still ogling Dumbledore with a kind of horrified delight. “Well, well, well — I came here tonight expecting to expel Potter and instead —“<br>“Instead you get to arrest me,” said Dumbledore, smiling. “It’s like losing a Knut and finding a Galleon, isn’t it?”<br>“Weasley!” cried Fudge, now positively quivering with delight, “Weasley, have you written it all down, everything he’s said, his confession, have you got it?”<br>“Yes, sir, I think so, sir!” said Percy eagerly, whose nose was splattered with ink from the speed of his note-taking.<br>“The bit about how he’s been trying to build up an army against the Ministry, how he’s been working to destabilize me?”<br>“Yes, sir, I’ve got it, yes!” said Percy, scanning his notes joyfully.<br>“Very well, then,” said Fudge, now radiant with glee. “Duplicate your notes, Weasley, and send a copy to the Daily Prophet at once. If we send a fast owl we should make the morning edition!” Percy dashed from the room, slamming the door behind him, and Fudge turned back to Dumbledore. “You will now be escorted back to the Ministry, where you will be formally charged and then sent to Azkaban to await trial!”<br>“Ah,” said Dumbledore gently, “yes. Yes, I thought we might hit that little snag.”<br>“Snag?” said Fudge, his voice still vibrating with joy. “I see no snag, Dumbledore!”<br>“Well,” said Dumbledore apologetically, “I’m afraid I do.”<br>“Oh really?”<br>“Well — it’s just that you seem to be laboring under the delusion that I am going to — what is the phrase? ‘Come quietly’ I am afraid I am not going to come quietly at all, Cornelius. I have absolutely no intention of being sent to Azkaban. I could break out, of course — but what a waste of time, and frankly, I can think of a whole host of things I would rather be doing.”<br>Umbridge’s face was growing steadily redder, she looked as though she was being filled with boiling water. Fudge stared at Dumbledore with a very silly expression on his face, as though he had just been stunned by a sudden blow and could not quite believe it had happened. He made a small choking noise and then looked around at Kingsley and the man with short gray hair, who alone of everyone in the room had remained entirely silent so far. The latter gave Fudge a reassuring nod and moved forward a little, away from the wall. Harry saw his hand drift, almost casually, toward his pocket.<br>“Don’t be silly, Dawlish,” said Dumbledore kindly. “I’m sure you are an excellent Auror, I seem to remember that you achieved ‘Outstanding’ in all your N.E.W.T.s, but if you attempt to — er — ‘bring me in’ by force, I will have to hurt you.”<br>The man called Dawlish blinked, looking rather foolish. He looked toward Fudge again, but this time seemed to be hoping for a clue as to what to do next.<br>“So,” sneered Fudge, recovering himself, “you intend to take on Dawlish, Shacklebolt, Dolores, and myself single-handed, do you, Dumbledore?”<br>“Merlin’s beard, no,” said Dumbledore, smiling. “Not unless you are foolish enough to force me to.”<br>“He will not be single-handed!” said Professor McGonagall loudly, plunging her hand inside her robes.<br>“Oh yes he will, Minerva!” said Dumbledore sharply. “Hogwarts needs you!”<br>“Enough of this rubbish!” said Fudge, pulling out his own wand.<br>“Dawlish! Shacklebolt! Take him!”<br>A streak of silver light flashed around the room. There was a bang  like a gunshot, and the floor trembled. A hand grabbed the scruff of  Harry’s neck and forced him down on the floor as a second silver flash went off — several of the portraits yelled, Fawkes screeched, and a cloud of dust filled the air. Coughing in the dust, Harry saw a dark figure fall to the ground with a crash in front of him. There was a shriek and a thud and somebody cried, “No!” Then the sound of breaking glass, frantically scuffling footsteps, a groan — and silence.<br>Harry struggled around to see who was half-strangling him and saw  Professor McGonagall crouched beside him. She had forced both him and Marietta out of harm’s way. Dust was still floating gently down  through the air onto them. Panting slightly, Harry saw a very tall figure moving toward them. </p><p>“ ‘Course we have,” said George. “Never been expelled, have we?”<br>“We’ve always known where to draw the line,” said Fred.<br>“We might have put a toe across it occasionally,” said George.<br>“But we’ve always stopped short of causing real mayhem,” said Fred.<br>“But now?” said Ron tentatively.<br>“Well, now —“ said George.<br>“— what with Dumbledore gone —“ said Fred.<br>“— we reckon a bit of mayhem —“ said George.<br>“— is exactly what our dear new Head deserves,” said Fred.<br>“You mustn’t!” whispered Hermione. “You really mustn’t! She’d love a reason to expel you!”<br>“You don’t get it, Hermione, do you?” said Fred, smiling at her.<br>“We don’t care about staying anymore. We’d walk out right now if we weren’t determined to do our bit for Dumbledore first. So anyway,” he checked his watch, “phase one is about to begin. I’d get in the Great Hall for lunch if I were you, that way the teachers will see you can’t have had anything to do with it.”</p><p>“Thank you so much, Professor!” said Professor Flitwick in his squeaky little voice. “I could have got rid of the sparklers myself, of course, but I wasn’t sure whether I had the authority… .” </p><blockquote><p>Hermione and rebellious…</p></blockquote><p>“Oh, why don’t we have a night off?” said Hermione brightly, as a silver-tailed Weasley rocket zoomed past the window. “After all, the Easter holidays start on Friday, we’ll have plenty of time then… .”<br>“Are you feeling all right?” Ron asked, staring at her in disbelief.<br>“Now you mention it,” said Hermione happily, “d’you know … I think I’m feeling a bit … rebellious.” </p><blockquote><p>When it comes to satire, McGonagall will never let you down.</p></blockquote><p>“I should have made my meaning plainer,” said Professor McGonagall, turning at last to look Umbridge directly in the eyes. “He has achieved high marks in all Defense Against the Dark Arts tests set by a competent teacher.” </p><blockquote><p>“She towered over”</p></blockquote><p>Professor McGonagall got to her feet too, and in her case this was a much more impressive move. She towered over Professor Umbridge.<br>“Potter,” she said in ringing tones, “I will assist you to become an Auror if it is the last thing I do! If I have to coach you nightly I will make sure you achieve the required results!”<br>“The Minister of Magic will never employ Harry Potter!” said Umbridge, her voice rising furiously.<br>“There may well be a new Minister of Magic by the time Potter is ready to join!” shouted Professor McGonagall. </p><blockquote><p>Glorious finale of Fred and George’s schooling.</p></blockquote><p>“You know what?” said Fred. “I don’t think we are.”<br>He turned to his twin.<br>“George,” said Fred, “I think we’ve outgrown full-time education.”<br>“Yeah, I’ve been feeling that way myself,” said George lightly.<br>“Time to test our talents in the real world, d’you reckon?” asked Fred.<br>“Definitely,” said George.<br>And before Umbridge could say a word, they raised their wands and said together, “Accio Brooms!”<br>Harry heard a loud crash somewhere in the distance. Looking to his left he ducked just in time — Fred and George’s broomsticks, one still trailing the heavy chain and iron peg with which Umbridge had fastened them to the wall, were hurtling along the corridor toward their owners. They turned left, streaked down the stairs, and stopped sharply in front of the twins, the chain clattering loudly on the flagged stone floor.<br>“We won’t be seeing you,” Fred told Professor Umbridge, swinging his leg over his broomstick.<br>“Yeah, don’t bother to keep in touch,” said George, mounting his own.<br>Fred looked around at the assembled students, and at the silent, watchful crowd.<br>“If anyone fancies buying a Portable Swamp, as demonstrated upstairs, come to number ninety-three, Diagon Alley — Weasleys’ Wizarding Wheezes,” he said in a loud voice. “Our new premises!”<br>“Special discounts to Hogwarts students who swear they’re going to use our products to get rid of this old bat,” added George, pointing at Professor Umbridge.<br>“STOP THEM!” shrieked Umbridge, but it was too late. As the Inquisitorial Squad closed in, Fred and George kicked off from the floor, shooting fifteen feet into the air, the iron peg swinging dangerously below. Fred looked across the hall at the poltergeist bobbing on his level above the crowd.<br>“Give her hell from us, Peeves.”<br>And Peeves, whom Harry had never seen take an order from a student before, swept his belled hat from his head and sprang to a salute as Fred and George wheeled about to tumultuous applause from the students below and sped out of the open front doors into the glorious sunset. </p><p>Indeed, a week after Fred and George’s departure Harry witnessed Professor McGonagall walking right past Peeves, who was determinedly loosening a crystal chandelier, and could have sworn he heard her tell the poltergeist out of the corner of her mouth, “It unscrews the other way.”</p><blockquote><p>there are things much worse than death</p></blockquote><p>“We both know that there are other ways of destroying a man, Tom,” Dumbledore said calmly, continuing to walk toward Voldemort as though he had not a fear in the world, as though nothing had happened to interrupt his stroll up the hall. “Merely taking your life would not satisfy me, I admit —“<br>“There is nothing worse than death, Dumbledore!” snarled Voldemort.<br>“You are quite wrong,” said Dumbledore, still closing in upon Voldemort and speaking as lightly as though they were discussing the matter over drinks. Harry felt scared to see him walking along, undefended, shieldless. He wanted to cry out a warning, but his headless guard kept shunting him backward toward the wall, blocking his every attempt to get out from behind it. “Indeed, your failure to understand that there are things much worse than death has always been your greatest weakness —“</p><blockquote><p>faltered … as surveyed … magisterially over …<br>This is one of the few scenes in which Dumbledore act very aggresively. Don’t forget that he used to hand out with Grindelwald.</p></blockquote><p>“Now see here, Dumbledore!” said Fudge, as Dumbledore picked up the head and walked back to Harry carrying it. “You haven’t got authorization for that Portkey! You can’t do things like that right in front of the Minister of Magic, you — you —“<br>His voice faltered as Dumbledore surveyed him magisterially over his half-moon spectacles.<br>“You will give the order to remove Dolores Umbridge from Hogwarts,” said Dumbledore. “You will tell your Aurors to stop searching for my Care of Magical Creatures teacher so that he can return to work. I will give you …” Dumbledore pulled a watch with twelve hands from his pocket and glanced at it, “half an hour of my time tonight, in which I think we shall be more than able to cover the important points of what has happened here. After that, I shall need to return to my school. If you need more help from me you are, of course, more than welcome to contact me at Hogwarts. Letters addressed to the headmaster will find me.”</p><p>“Kreacher is what he has been made by wizards, Harry,” said Dumbledore. “Yes, he is to be pitied. His existence has been as miserable as your friend Dobby’s. He was forced to do Sirius’s bidding, because Sirius was the last of the family to which he was enslaved, but he felt no true loyalty to him. And whatever Kreacher’s faults, it must be admitted that Sirius did nothing to make Kreacher’s lot easier —“ </p><p>“Sirius did not hate Kreacher,” said Dumbledore. “He regarded him as a servant unworthy of much interest or notice. Indifference and neglect often do much more damage than outright dislike… .<br>The fountain we destroyed tonight told a lie. We wizards have mistreated and abused our fellows for too long, and we are now reaping our reward.”</p><p>Well, Flitwick’s got rid of Fred and George’s swamp,” said Ginny.<br>“He did it in about three seconds. But he left a tiny patch under the window and he’s roped it off —“<br>“Why?” said Hermione, looking startled.<br>“Oh, he just says it was a really good bit of magic,” said Ginny, shrugging.<br>“I think he left it as a monument to Fred and George,” said Ron through a mouthful of chocolate. “They sent me all these, you know,” he told Harry, pointing at the small mountain of Frogs beside him.<br>“Must be doing all right out of that joke shop, eh?” </p><blockquote><p>who can be intimidated</p></blockquote><p>“And do I look like the kind of man who can be intimidated?” barked Uncle Vernon.<br>“Well …” said Moody, pushing back his bowler hat to reveal his sinisterly revolving magical eye. Uncle Vernon leapt backward in horror and collided painfully with a luggage trolley. “Yes, I’d have to say you do, Dursley.” </p><h1 id="HP6"><a href="#HP6" class="headerlink" title="HP6"></a>HP6</h1><blockquote><p>“You are determined to hate him”</p></blockquote><p>“You are determined to hate him, Harry,” said Lupin with a faint smile. </p><blockquote><p>Snape’s irony </p></blockquote><p>“Yes, indeed, most admirable,” said Snape in a bored voice. “Of course, you weren’t a lot of use to him in prison, but the gesture was undoubtedly fine —“<br>“Gesture!” she shrieked; in her fury she looked slightly mad.<br>“While I endured the dementors, you remained at Hogwarts, comfortably playing Dumbledore’s pet!”</p><blockquote><p>Greate self-defending</p></blockquote><p>“Think!” said Snape, impatient again. “Think! By waiting two hours, just two hours, I ensured that I could remain at Hogwarts as a spy! By allowing Dumbledore to think that I was only returning to the Dark Lord’s side because I was ordered to, I have been able to pass information on Dumbledore and the Order of the Phoenix ever since! Consider, Bellatrix: The Dark Mark had been growing stronger for months. I knew he must be about to return, all the Death Eaters knew! I had plenty of time to think about what I wanted to do, to plan my next move, to escape like Karkaroff, didn’t I?</p><p>Harry got to his feet. As he walked across the room, his eyes fell upon the little table on which Marvolo Gaunt’s ring had rested last time, but the ring was no longer there.<br>“Yes, Harry?” said Dumbledore, for Harry had come to a halt.<br>“The ring’s gone,” said Harry, looking around. “But I thought you might have the mouth organ or something.”<br>Dumbledore beamed at him, peering over the top of his halfmoon spectacles.<br>“Very astute, Harry, but the mouth organ was only ever a mouth organ.”<br>And on that enigmatic note he waved to Harry, who understood himself to be dismissed. </p><blockquote><p>A very tough conversation with the Ministry.</p></blockquote><p>“But if I keep running in and out of the Ministry,” said Harry, still endeavoring to keep his voice friendly, “won’t that seem as though I approve of what the Ministry’s up to?”<br>“Well,” said Scrimgeour, frowning slightly, “well, yes, that’s partly why we’d like —“<br>“No, I don’t think that’ll work,” said Harry pleasantly. “You see, I don’t like some of the things the Ministry’s doing. Locking up Stan Shunpike, for instance.”<br>Scrimgeour did not speak for a moment but his expression hardened instantly. “I would not expect you to understand,” he said, and he was not as successful at keeping anger out of his voice as Harry had been. “These are dangerous times, and certain measures need to be taken. You are sixteen years old —“<br>“Dumbledore’s a lot older than sixteen, and he doesn’t think Stan should be in Azkaban either,” said Harry. “You’re making Stan a scapegoat, just like you want to make me a mascot.”<br>They looked at each other, long and hard. Finally Scrimgeour said, with no pretense at warmth, “I see. You prefer — like your hero, Dumbledore — to disassociate yourself from the Ministry?”<br>“I don’t want to be used,” said Harry.<br>“Some would say it’s your duty to be used by the Ministry!”<br>“Yeah, and others might say it’s your duty to check that people really are Death Eaters before you chuck them in prison,” said Harry, his temper rising now. “You’re doing what Barty Crouch  did. You never get it right, you people, do you? Either we’ve got Fudge, pretending everything’s lovely while people get murdered right under his nose, or we’ve got you, chucking the wrong people into jail and trying to pretend you’ve got ‘the Chosen One’ working for you!”<br>“So you’re not ‘the Chosen One’?” said Scrimgeour.<br>“I thought you said it didn’t matter either way?” said Harry, with a bitter laugh. “Not to you anyway.”<br>“I shouldn’t have said that,” said Scrimgeour quickly. “It was tactless —“<br>“No, it was honest,” said Harry. “One of the only honest things you’ve said to me. You don’t care whether I live or die, but you do care that I help you convince everyone you’re winning the war against Voldemort. I haven’t forgotten, Minister… .”<br>He raised his right fist. There, shining white on the back of his cold hand, were the scars which Dolores Umbridge had forced him to carve into his own flesh: I must not tell lies.<br>“I don’t remember you rushing to my defense when I was trying to tell everyone Voldemort was back. The Ministry wasn’t so keen to be pals last year.”<br>They stood in silence as icy as the ground beneath their feet. The gnome had finally managed to extricate his worm and was now sucking on it happily, leaning against the bottommost branches of the rhododendron bush.<br>“What is Dumbledore up to?” said Scrimgeour brusquely.<br>“Where does he go when he is absent from Hogwarts?”<br>“No idea,” said Harry.<br>“And you wouldn’t tell me if you knew,” said Scrimgeour, “would you?”<br>“No, I wouldn’t,” said Harry. </p><blockquote><p>“a baboon brandishing a stick”, LOL<br>“Harry’s already Apparated,” Ron told a slightly abashed Seamus, after Professor Flitwick had dried himself off with a wave of his wand and set Seamus lines: “I am a wizard, not a baboon brandishing a stick.” “Dum — er — someone took him. Side-Along Apparition, you know.”</p></blockquote><p>“He accused me of being ‘Dumbledore’s man through and through.’ “<br>“How very rude of him.”<br>“I told him I was.” </p><p>He raised his glass as though toasting Voldemort, whose face remained expressionless. Nevertheless, Harry felt the atmosphere in the room change subtly: Dumbledore’s refusal to use Voldemort’s chosen name was a refusal to allow Voldemort to dictate the terms of the meeting, and Harry could tell that Voldemort took it as such. </p><blockquote><p>“For the greater good”.</p></blockquote><p>“You call it ‘greatness,’ what you have been doing, do you?” asked Dumbledore delicately.<br>“Certainly,” said Voldemort, and his eyes seemed to burn red. “I have experimented; I have pushed the boundaries of magic further, perhaps, than they have ever been pushed —“<br>“Of some kinds of magic,” Dumbledore corrected him quietly. “Of some. Of others, you remain … forgive me … woefully ignorant.” </p><p>“I am glad to hear that you consider them friends,” said Dumbledore. “I was under the impression that they are more in the order of servants.”</p><p>“Let us speak openly. Why have you come here tonight, surrounded by henchmen, to request a job we both know you do not want?”<br>Voldemort looked coldly surprised. “A job I do not want? On the contrary, Dumbledore, I want it very much.”<br>“Oh, you want to come back to Hogwarts, but you do not want to teach any more than you wanted to when you were eighteen. What is it you’re after, Tom? Why not try an open request for once?”<br>Voldemort sneered. “If you do not want to give me a job —“<br>“Of course I don’t,” said Dumbledore. “And I don’t think for a moment you expected me to. Nevertheless, you came here, you asked, you must have had a purpose.” </p><blockquote><p>The most valuable thing of a man is braveness.</p></blockquote><p>“Of course, it doesn’t matter how he looks… . It’s not r-really important … but he was a very handsome little b-boy … always very handsome … and he was g-going to be married!”<br>“And what do you mean by zat?” said Fleur suddenly and loudly.<br>“What do you mean, ‘ ‘e was going to be married?’ “<br>Mrs. Weasley raised her tear-stained face, looking startled.<br>“Well — only that —“<br>“You theenk Bill will not wish to marry me anymore?” demanded Fleur. “You theenk, because of these bites, he will not love me?”<br>“No, that’s not what I —“<br>“Because ‘e will!” said Fleur, drawing herself up to her full height and throwing back her long mane of silver hair. “It would take more zan a werewolf to stop Bill loving me!”<br>“Well, yes, I’m sure,” said Mrs. Weasley, “but I thought perhaps — given how — how he —“<br>“You thought I would not weesh to marry him? Or per’aps, you hoped?” said Fleur, her nostrils flaring. “What do I care how he looks? I am good-looking enough for both of us, I theenk! All these scars show is zat my husband is brave! And I shall do zat!” she added fiercely, pushing Mrs. Weasley aside and snatching the ointment from her.<br>Mrs. Weasley fell back against her husband and watched Fleur mopping up Bill’s wounds with a most curious expression upon her face. Nobody said anything; Harry did not dare move. Like everybody else, he was waiting for the explosion.<br>“Our Great-Auntie Muriel,” said Mrs. Weasley after a long pause, “has a very beautiful tiara — goblin-made — which I am sure I could persuade her to lend you for the wedding. She is very fond of Bill, you know, and it would look lovely with your hair.”<br>“Thank you,” said Fleur stiffly. “I am sure zat will be lovely.”<br>And then, Harry did not quite see how it happened, both women were crying and hugging each other. Completely bewildered, wondering whether the world had gone mad, he turned around: Ron looked as stunned as he felt and Ginny and Hermione were exchanging startled looks. </p><blockquote><p>she would not say, “Be careful,” or “Don’t do it,” but accept his decision, because she would not have expected anything less of him</p></blockquote><p>Harry looked at Ginny, Ron, and Hermione: Ron’s face was screwed up as though the sunlight were blinding him. Hermione’s face was glazed with tears, but Ginny was no longer crying. She met Harry’s gaze with the same hard, blazing look that he had seen when she had hugged him after winning the Quidditch Cup in his absence, and he knew that at that moment they understood each other perfectly, and that when he told her what he was going to do now, she would not say, “Be careful,” or “Don’t do it,” but accept his decision, because she would not have expected anything less of him. And so he steeled himself to say what he had known he must say ever since Dumbledore had died.</p><h1 id="HP7"><a href="#HP7" class="headerlink" title="HP7"></a>HP7</h1><blockquote><p>“He must’ve known you’d always want to come back.”</p></blockquote><p>But I don’t think so, not anymore. He knew what he was doing when he gave me the Deluminator, didn’t he? He — well,” Ron’s ears turned bright red and he became engrossed in a tuft of grass at his feet, which he prodded with his toe, “he must’ve known I’d run out on you.”<br>“No,” Harry corrected him. “He must’ve known you’d always want to come back.” </p><blockquote><p>“And if it does fall into his grasp,” said Dumbledore, almost, it seemed, as an aside, “I have your word that you will do all in your power to protect the students of Hogwarts?”</p></blockquote><p>“Professor Snape sent them into the Forbidden Forest, to do some work for the oaf, Hagrid.”<br>“Hagrid’s not an oaf!” said Hermione shrilly.<br>“And Snape might’ve thought that was a punishment,” said Harry, “but Ginny, Neville, and Luna probably had a good laugh with Hagrid. The Forbidden Forest . . . they’ve faced plenty worse than the Forbidden Forest, big deal!” </p><blockquote><p>This is a very giant change of Harry. He finally learned how to shut his mind from Voldemort, and he’s no longer obsessed with Hallows.</p></blockquote><p>His scar burned, but he was master of the pain; he felt it, yet was apart from it. He had learned control at last, learned to shut his mind to Voldemort, the very thing Dumbledore had wanted him to learn from Snape. Just as Voldemort had not been able to possess Harry while Harry was consumed with grief for Sirius, so his thoughts could not penetrate Harry now, while he mourned Dobby.<br>Grief, it seemed, drove Voldemort out . . . though Dumbledore, of course, would have said that it was love. . . .<br>On Harry dug, deeper and deeper into the hard, cold earth, subsuming his grief in sweat, denying the pain in his scar. In the darkness, with nothing but the sound of his own breath and the rushing sea to keep him company, the things that had happened at the Malfoys’ returned to him, the things he had heard came back to him, and understanding blossomed in the darkness. . . .<br>The steady rhythm of his arms beat time with his thoughts. Hallows . . . Horcruxes . . . Hallows . . . Horcruxes . . . Yet he no longer burned with that weird, obsessive longing. Loss and fear had snuffed it out: He felt as though he had been slapped awake again.<br>Deeper and deeper Harry sank into the grave, and he knew where Voldemort had been tonight, and whom he had killed in the topmost cell of Nurmengard, and why. . . .<br>And he thought of Wormtail, dead because of one small unconscious impulse of mercy. . . . Dumbledore had foreseen that. . . . How much more had he known?</p><blockquote><p>Another side depiction of Naville’s family.</p></blockquote><p>“Yeah, well, I couldn’t ask people to go through what Michael did, so we dropped those kinds of stunts. But we were still fighting, doing underground stuff, right up until a couple of weeks ago. That’s when they decided there was only one way to stop me, I suppose, and they went for Gran.”<br>“They what?” said Harry, Ron, and Hermione together.<br>“Yeah,” said Neville, panting a little now, because the passage was climbing so steeply, “well, you can see their thinking. It had worked really well, kidnapping kids to force their relatives to behave, I s’pose it was only a matter of time before they did it the other way around. Thing was,” he faced them, and Harry was astonished to see that he was grinning, “they bit off a bit more than they could chew with Gran. Little old witch living alone, they probably thought they didn’t need to send anyone particularly powerful. Anyway,” Neville laughed, “Dawlish is still in St. Mungo’s and Gran’s on the run. She sent me a letter,” he clapped a hand to the breast pocket of his robes, “telling me she was proud of me, that I’m my parents’ son, and to keep it up.” </p><blockquote><p>This little episode shows Ron’s character traits vividly.<br>“Your mother can’t produce food out of thin air,” said Hermione. “No one can. Food is the first of the five Principal Exceptions to Gamp’s Law of Elemental Transfigur —“<br>“Oh, speak English, can”t you?” Ron said, prising a fish bone outfrom between his teeth. </p></blockquote><p>“Yeah, well, food’s one of the five exceptions to Gamp’s Law of Elemental Transfiguration,” said Ron to general astonishment. </p><p>“Why would Harry Potter try to get inside Ravenclaw Tower? Potter belongs in my House!”<br>Beneath the disbelief and anger, Harry heard a little strain of pride in her voice, and affection for Minerva McGonagall gushed up inside him. </p><p>“It’s not a case of what you’ll permit, Minerva McGonagall. Your time’s over. It’s us what’s in charge here now, and you’ll back me up or you’ll pay the price.” And he spat in her face.<br>Harry pulled the Cloak off himself, raised his wand, and said, “You shouldn’t have done that.”<br>As Amycus spun around, Harry shouted, “Crucio!” </p><p>“Potter, I — that was very — very gallant of you — but don’t you realize — ?”</p><p>There was a sound of movement, of clinking glass: Amycus was coming round. Before Harry or Luna could act, Professor McGonagall rose to her feet, pointed her wand at the groggy Death Eater, and said, “Imperio.” </p><p>The aged caretaker had just come hobbling into view, shouting, “Students out of bed! Students in the corridors!”<br>“They’re supposed to be, you blithering idiot!” shouted McGonagall. “Now go and do something constructive! Find Peeves!”</p><blockquote><p>Percy returns to the arms of his family.</p></blockquote><p>“I was a fool!” Percy roared, so loudly that Lupin nearly dropped his photograph. “I was an idiot, I was a pompous prat, I was a — a —“<br>“Ministry-loving, family-disowning, power-hungry moron,” said Fred.<br>Percy swallowed.<br>“Yes, I was!”<br>“Well, you can’t say fairer than that,” said Fred, holding out his hand to Percy.<br>Mrs. Weasley burst into tears. She ran forward, pushed Fred aside, and pulled Percy into a strangling hug, while he patted her on the back, his eyes on his father. </p><p>“Well, we do look to our prefects to take a lead at times such as these,” said George in a good imitation of Percy’s most pompous manner. “Now let’s get upstairs and fight, or all the good Death Eaters’ll be taken.”</p><blockquote><p>“I am not such a coward.”</p></blockquote><p>“Karkaroff’s Mark is becoming darker too. He is panicking, he fears retribution; you know how much help he gave the Ministry after the Dark Lord fell.” Snape looked sideways at Dumbledore’s crooked-nosed profile. “Karkaroff intends to flee if the Mark burns.”<br>“Does he?” said Dumbledore softly, as Fleur Delacour and Roger Davies came giggling in from the grounds. “And are you tempted to join him?”<br>“No,” said Snape, his black eyes on Fleur’s and Roger’s retreating figures. “I am not such a coward.”<br>“No,” agreed Dumbledore. “You are a braver man by far than Igor Karkaroff. You know, I sometimes think we Sort too soon… .”</p><blockquote><p>Snape began to care for his soul. This is a big change of him.</p></blockquote><p>“If you don’t mind dying,” said Snape roughly, “why not let Draco do it?”<br>“That boy’s soul is not yet so damaged,” said Dumbledore. “I would not have it ripped apart on my account.”<br>“And my soul, Dumbledore? Mine?”<br>“You alone know whether it will harm your soul to help an old man avoid pain and humiliation,” said Dumbledore.</p><blockquote><p>This is also a very important conversation. Snape no longer fight only for Lily, but for justice now.</p></blockquote><p>“Don’t be shocked, Severus. How many men and women have you watched die?”<br>“Lately, only those whom I could not save,” said Snape. He stood up. “You have used me.”<br>“Meaning?”<br>“I have spied for you and lied for you, put myself in mortal danger for you. Everything was supposed to be to keep Lily Potter’s son safe. Now you tell me you have been raising him like a pig for slaughter —“<br>“But this is touching, Severus,” said Dumbledore seriously. “Have you grown to care for the boy, after all?”<br>“For him?” shouted Snape. “Expecto Patronum!”<br>From the tip of his wand burst the silver doe: She landed on the office floor, bounded once across the office, and soared out of the window. Dumbledore watched her fly away, and as her silvery glow faded he turned back to Snape, and his eyes were full of tears.<br>“After all this time?”<br>“Always,” said Snape.</p><blockquote><p>There is always something worth giving your life for.</p></blockquote><p>“I am sorry too,” said Lupin. “Sorry I will never know him … but he will know why I died and I hope he will understand. I was trying to make a world in which he could live a happier life.” </p><p>“Would I?” asked Dumbledore heavily. “I am not so sure. I had proven, as a very young man, that power was my weakness and my temptation. It is a curious thing, Harry, but perhaps those who are best suited to power are those who have never sought it. Those who, like you, have leadership thrust upon them, and take up the mantle because they must, and find to their own surprise that they wear it well. </p><p>At last he said, “Grindelwald tried to stop Voldemort going after the wand. He lied, you know, pretended he had never had it.”</p><p>You are the true master of death, because the true master does not seek to run away from Death. He accepts that he must die, and understands that there are far, far worse things in the living world than dying.</p><blockquote><p>Pity the living</p></blockquote><p>“I’ve got to go back, haven’t I?”<br>“That is up to you.”<br>“I’ve got a choice?”<br>“Oh yes.” Dumbledore smiled at him. “We are in King’s Cross, you say? I think that if you decided not to go back, you would be able to … let’s say … board a train.”<br>“And where would it take me?”<br>“On,” said Dumbledore simply.<br>Silence again.<br>“Voldemort’s got the Elder Wand.”<br>“True. Voldemort has the Elder Wand.”<br>“But you want me to go back?”<br>“I think,” said Dumbledore, “that if you choose to return, there is a chance that he may be finished for good. I cannot promise it. But I know this, Harry, that you have less to fear from returning here than he does.”<br>Harry glanced again at the raw-looking thing that trembled and choked in the shadow beneath the distant chair.<br>“Do not pity the dead, Harry. Pity the living, and, above all, those who live without love. By returning, you may ensure that fewer souls are maimed, fewer families are torn apart. If that seems to you a worthy goal, then we say good-bye for the present.” </p><p>“Of course it is happening inside your head, Harry, but why on earth should that mean that it is not real?” </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;While rereading Harry Potter, I found these fragments are inspiring and interesting.&lt;/p&gt;</summary>
    
    
    
    
    <category term="文学" scheme="http://www.calvinneo.com/tags/文学/"/>
    
    <category term="读书笔记" scheme="http://www.calvinneo.com/tags/读书笔记/"/>
    
  </entry>
  
  <entry>
    <title>Church 编码</title>
    <link href="http://www.calvinneo.com/2023/04/04/church-encoding/"/>
    <id>http://www.calvinneo.com/2023/04/04/church-encoding/</id>
    <published>2023-04-04T15:20:37.000Z</published>
    <updated>2023-04-10T13:53:40.059Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 Church 编码和 Scott 编码。</p><a id="more"></a><p>邱奇数使用 lambda 构成的高阶函数来描述自然数。事实上邱奇编码可以用来描述一些很基本的结构，例如布尔值、元组、列表和 tagged unions。<br>可以将 0 表示为函数 zero 即 <code>\f x. x</code>。x 是什么并不重要，但我们可以将 f 令为 add1，将 x 令为 0。那么 0 就是 <code>zero(add1, 0) = 0</code>。<br>然后，可以将 1 表示为函数 one 即 <code>\f x. f x</code>。进行代换可以得到 <code>one(add1, 0) = add1(0)</code>。同理，将 2 表示为 <code>\f x. f (f x)</code>。<br>任意一个数 <code>n</code> 可以表示为<code>($) f^n x</code>，我们要想出一个结构实现把 <code>f</code> 执行 <code>n</code> 次，那实际上需要套一个递归的概念。下面来定义这个 Successor 函数 <code>s</code>。<br>递推函数 <code>s</code> 可以求出 <code>n</code> 的 Successor 为 <code>\n f x -&gt; f (($) n f x)</code>。检查类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :t s</span><br><span class="line">s :: ((t1 -&gt; t2) -&gt; t3 -&gt; t1) -&gt; (t1 -&gt; t2) -&gt; t3 -&gt; t2</span><br></pre></td></tr></table></figure><p>可以理解为 <code>s</code> 是接受一个函数 <code>n</code>，返回另一个和 <code>f</code>/<code>x</code> 有关的函数。不妨简单带入</p><ol><li><code>add1 (($) zero add1 0)</code> 为 1</li><li><code>add1 (($) one add1 0)</code> 为 2</li></ol><p>实现加法函数<code>plus(m, n) = m + n</code>，<code>plus = \m n f x. m f(n f x)</code>。这里用到了性质<code>f^(m+n) x = f^m f^n x</code>。<br>实现乘法函数<code>multi(m, n) = m * n</code>，<code>multi = \m n f x. m (n f) x</code>。相当于将 <code>n f</code> 应用 <code>m</code> 次在 <code>x</code> 上。而 <code>n f</code> 表示 <code>n</code>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">add1</span> x = x + <span class="number">1</span></span><br><span class="line"><span class="title">shownat</span> n = ($) n add1 <span class="number">0</span></span><br><span class="line"><span class="title">zero</span> = \f x -&gt; x</span><br><span class="line"><span class="title">s</span> = \n f x -&gt; f (($) n f x)</span><br><span class="line"><span class="title">one</span> = s zero</span><br><span class="line"><span class="title">two</span> = s one</span><br><span class="line"><span class="title">three</span> = s two</span><br><span class="line"><span class="title">shownat</span> one</span><br><span class="line"></span><br><span class="line"><span class="title">add</span> n m f x = ($) n f (($) m f x)</span><br><span class="line"><span class="title">multi</span> n m f = n (m f)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; :t zero</span><br><span class="line">zero :: p1 -&gt; p2 -&gt; p2</span><br><span class="line">ghci&gt; :t one</span><br><span class="line">one :: (t1 -&gt; t2) -&gt; t1 -&gt; t2</span><br><span class="line">ghci&gt; :t two</span><br><span class="line">two :: (t3 -&gt; t3) -&gt; t3 -&gt; t3</span><br><span class="line">ghci&gt; :t three</span><br><span class="line">three :: (t3 -&gt; t3) -&gt; t3 -&gt; t3</span><br></pre></td></tr></table></figure><p>下面定义和 bool 量有关的函数。可以看到，true 就是传两个元素选择第一个，false 就是选择第二个。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">true</span> x y = x</span><br><span class="line"><span class="title">false</span> x y = y</span><br><span class="line"><span class="title">showbool</span> b = ($) b <span class="type">True</span> <span class="type">False</span></span><br></pre></td></tr></table></figure><p>容易看出，通过 true 和 false，可以自然而然定义出 if-then-else 语义</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ifte</span> pred x y = ($) pred x y</span><br></pre></td></tr></table></figure><p>下面定义 pair 结构。不同于一般编程中指定如何构造结构，这里的思路是定义如何去消费这个结构。这里可以传入一个 sel。sel 可以是 fst 和 snd，表示选出 a 或者 b。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pair</span> a b sel = ($) sel a b</span><br><span class="line"><span class="title">fst</span> p = p true</span><br><span class="line"><span class="title">snd</span> p = p false</span><br><span class="line"><span class="title">shownat</span> (fst (($) pair one two))</span><br></pre></td></tr></table></figure><p>这里有个小问题，写成 <code>pair a b sel = sel $ a b</code> 会有错误</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;interactive&gt;:<span class="number">28</span>:<span class="number">1</span>: error:</span><br><span class="line">    ? <span class="type">Non</span> <span class="class"><span class="keyword">type</span>-variable argument in the constraint: <span class="type">Num</span> (<span class="title">t3</span> -&gt; <span class="title">t3</span>)</span></span><br><span class="line">      (<span class="type">Use</span> <span class="type">FlexibleContexts</span> to permit this)</span><br><span class="line">    ? <span class="type">When</span> checking the inferred <span class="class"><span class="keyword">type</span></span></span><br><span class="line">        it :: <span class="keyword">forall</span> &#123;t3&#125;. <span class="type">Num</span> (t3 -&gt; t3) =&gt; t3 -&gt; t3</span><br></pre></td></tr></table></figure><p>下面定义 pair 上的函数 next。<code>(next (: pair a b))</code> 返回 <code>(: pair (s a) a)</code>，可以理解为 pair 上的 Successor。<br>思路很简单，新构造一个 pair，它的第二个元素是 <code>(fst p)</code>，第一个元素是 <code>s (fst p)</code>&gt;</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">next</span> p = ($) pair (s (fst p)) (fst p)</span><br><span class="line"><span class="title">nn_of_a</span> a = ($) fst (next (($) pair a a))</span><br><span class="line"><span class="title">shownat</span> $ nn_of_a one</span><br></pre></td></tr></table></figure><p>实现减法函数，首先先实现一个 pred 函数。它可以求出 n - 1 是什么。例如 <code>pred two</code> 是 <code>one</code>，但 <code>pred zero</code> 是 <code>zero</code>。这里的方案是从 <code>pair zero zero</code> 开始，调用 n 次 next，就可以得到 <code>(n, n - 1)</code>。使用 snd 返回就行。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pred</span> n = snd (($) n next (($) pair zero zero))</span><br></pre></td></tr></table></figure><p>减法函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sub</span> m n = ($) m (pred n)</span><br></pre></td></tr></table></figure><p>下面这个函数用来判断 n 是不是 0。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">isZero</span> n = ($) n (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p>不妨进行代入来看看原理</p><ol><li><p>zero</p> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($) (\f x -&gt; x) (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p> 这里的 <code>f</code> 实际上就是 <code>(\x -&gt; false)</code>，而 x 就是 true。所以肯定是 true。</p></li><li><p>one</p> <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($) (\f x -&gt; f x) (\x -&gt; false) true</span><br></pre></td></tr></table></figure><p> 这里代入就是 <code>(\x -&gt; false) true</code>，即 false。</p></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">http://learnyouahaskell.com</a></li><li><a href="https://www.zhihu.com/question/19804597" target="_blank" rel="noopener">https://www.zhihu.com/question/19804597</a><br> Church 编码</li><li><a href="https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/lambda-calculus-2/index.html" target="_blank" rel="noopener">https://faculty.iiit.ac.in/~venkatesh.choppella/popl/current-topics/lambda-calculus-2/index.html</a><br> Church 编码</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 Church 编码和 Scott 编码。&lt;/p&gt;</summary>
    
    
    
    
    <category term="lambda" scheme="http://www.calvinneo.com/tags/lambda/"/>
    
    <category term="函数式" scheme="http://www.calvinneo.com/tags/函数式/"/>
    
  </entry>
  
  <entry>
    <title>线性代数复习——以MIT18.06为指导(3)</title>
    <link href="http://www.calvinneo.com/2023/03/01/linear-alg-3/"/>
    <id>http://www.calvinneo.com/2023/03/01/linear-alg-3/</id>
    <published>2023-03-01T14:40:32.000Z</published>
    <updated>2023-04-11T15:02:44.814Z</updated>
    
    <content type="html"><![CDATA[<p>本文从<a href="https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&p=16" target="_blank" rel="noopener">MIT的线代教程</a>的角度重新学习线性代数。</p><p>这是第三部分，从 L26 开始。</p><a id="more"></a><h1 id="L26-对称矩阵和正定矩阵"><a href="#L26-对称矩阵和正定矩阵" class="headerlink" title="L26 对称矩阵和正定矩阵"></a>L26 对称矩阵和正定矩阵</h1><p>本章讲对称矩阵。<br>这里注意，因为对称矩阵不一定满秩，比如<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;1 \\<br>    1&amp;1<br>\end{bmatrix}<br>\end{equation}<br>$$<br>就不满秩。</p><p>首先介绍实对称矩阵，有两个特性：</p><ol><li>特征值都是实数</li><li>特征向量正交<br> 这里注意，如果出现重特征值，则可能一个平面中都是特征向量。所以这里说的是总能选出一套完全正交的特征向量。<br> 其实这里我不是很懂，投影矩阵是个什么样的例子呢？</li></ol><p>在 L22 已经讲过如何判断是否存在 n 个线性无关的特征向量了。现在假设存在，那么矩阵可以对角化为 $A = S \Lambda S^{-1}$。<br>对对称矩阵进行对角化，因为特征向量正交，所以 S 实际是正交矩阵，这里改写为 Q。因为 Q 是正交矩阵，根据正交矩阵的性质，有 $Q Q^T = I$，即 $Q^{-1} = Q^T$。所以有<br>所以可以得到下面的式子。<br>$$<br>A = Q \Lambda Q^{-1} = Q \Lambda Q^T<br>$$</p><p>上面的定理又被称为谱定理或者主轴定理。</p><p>在笔记上还写了一段<br><img src="/img/linalg/symmat_note.png"></p><hr><p>下面来证明为什么实对称矩阵的特征值都是实数。特别地，第二个性质教授说直接看课本就行。</p><p>首先他介绍了一个特性，其中 $\overline{c}$ 表示复数 c 的共轭。<br>$$<br>\overline{A} \overline{x} = \overline{\lambda} \overline{x}<br>$$</p><p>考虑上面的式子，可以得到<br>$$<br>\overline{x}^T \overline{A}^T = \overline{x}^T \overline{\lambda}<br>$$</p><p>考虑到 $\overline{A} = A$ 和 $A = A^T$ 可以得到<br>$$<br>\overline{x}^T A = \overline{x}^T \overline{\lambda}<br>$$</p><p>两边同时右乘 x 有<br>$$<br>\overline{x}^T A x = \overline{x}^T x \overline{\lambda}<br>$$</p><p>接下来考虑 $ A x = \lambda x$，两边同时左乘 $\overline{x}^T$ 有</p><p>$$<br>\overline{x}^T A x = \lambda \overline{x}^T x<br>$$</p><p>比较可得，$\overline{\lambda} = \lambda$ 或者 $\overline{x}^T A$ 为0。下面要证明后者不为0。<br>不妨展开看一下<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    \overline{x_1}&amp;…&amp;\overline{x_n}<br>\end{bmatrix}<br>\begin{bmatrix}<br>    \overline{x_1} \\<br>    … \\<br>    \overline{x_n}<br>\end{bmatrix}<br>\end{equation}<br>$$<br>其中每一个 $\overline{x_i} x_i$ 都可以看做是 $(a + bi)(a - bi)$，结果为复向量的模。只有当向量是0的时候，模才是0。</p><hr><p>特别地，如果 A 是复矩阵，那么要满足上面两个条件则需要 $ A = \overline{A}^T$。</p><hr><p>TODO</p><hr><p>下面介绍一个性质，也就是主元的符号和特征值的符号数量是匹配的。例如有 x 个主元为正，n - x 个主元为负，那么就有 x 个特征值为正，n - x 个特征值为负。</p><hr><p>正定矩阵是对称矩阵。它的所有特征值为正。所以它对应的微分方程是收敛的。</p><p>【Q】这里为什么要在对称矩阵上定义正定矩阵呢？</p><p>正定矩阵的主元都为正。</p><p>可以通过行列式判断是否是正定。如果 A 正定，则 $det(A) \gt 0$。但反之就未必，例如矩阵<br>$$<br>\begin{bmatrix}<br>    -1&amp;0 \\<br>    0&amp;-3 \\<br>\end{bmatrix}<br>$$</p><p>其实要所有的子行列式都为正才行。</p><h1 id="L27-复矩阵和快速傅里叶变换"><a href="#L27-复矩阵和快速傅里叶变换" class="headerlink" title="L27 复矩阵和快速傅里叶变换"></a>L27 复矩阵和快速傅里叶变换</h1><p>我们如何定义两个复向量正交呢？$z^T z = 0$ 可以么？不行。因为 $z^T z$ 是向量模长的平方，它应该是一个正数。但如果考虑<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;i<br>\end{bmatrix}<br>\begin{bmatrix}<br>    1 \\<br>    i \\<br>\end{bmatrix}<br>= 0<br>\end{equation}<br>$$<br>难道向量的长度为0？</p><p>实际上我们定义复向量 z 的模是 $\overline{z}^T z$，也可以写作 $z^H z$。这里的 H 表示埃尔米特(Hermitian)矩阵的意思。</p><hr><p>进行延伸，我们定义复矩阵中的“对称矩阵”。它被称作埃尔米特矩阵，定义为 $\overline{A}^T$ 即 $A^H$。它的特性是 $\overline{A}^T = A$。</p><p>下面的例子是一个埃尔米特矩阵，可以发现主对角线上一定都是实数，主对角线两边的元素“共轭对称”。<br>$$<br>\begin{bmatrix}<br>    2&amp;3+i \\<br>    3-i&amp;5 \\<br>\end{bmatrix}<br>$$</p><p>埃尔米特矩阵具有实数特征值和正交的特性向量，这个应该是从对称矩阵上类比得到的，教授在上节课证明的时候已经带过了。</p><hr><p>类似地，我们定义对应于“正交矩阵”的概念即酉矩阵。</p><p>假如 $q_1$、$q_2$、……、$q_n$ 彼此标准正交，即<br>$$<br>\begin{equation}<br>\overline{q_i}^T q_i =<br>\left\{<br>    \begin{array}{lr}<br>    0, \quad i\ne j \\<br>    1, \quad i=j<br>    \end{array}<br>\right.<br>\end{equation}<br>$$</p><p>可以得到 $Q^H Q = I$，这里 $Q^H$ 就是酉矩阵。</p><hr><p>求逆方便的原因是 $F_4^H F = I$，所以逆就是共轭转置。</p><p>容易想到 $F_{64}$ 和 $F_{32}$ 之间可能有联系。在 $F_{64}$ 中，w 是 1 的 64 次方根，不妨记作 $w_{64}$。可以发现 $w_{64}^2 = w_{32}$。</p><p>如何建立 $F_{64}$ 和 $F_{32}$ 之间的联系呢？不妨考虑下面的式子，$F_{64}$ 被拆成两个 $F_{32}$ 组合起来很稀疏的矩阵。<br>$$<br>\begin{equation}<br>F_{64} =<br>X<br>\begin{bmatrix}<br>    F_{32}&amp;0 \\<br>    0&amp;F_{32}<br>\end{bmatrix}<br>P<br>\end{equation}<br>$$</p><p>当然，整个式子要乘上 X 和 Y 才能成立。</p><p>这里的 Y 是一个奇偶置换矩阵，如下所示。从矩阵乘法的第四种方法可以看出。</p><p>而 X 是一个<br>$$<br>\begin{bmatrix}<br>    I&amp;D \\<br>    I&amp;-D<br>\end{bmatrix}<br>$$</p><p>其中 D 是对角矩阵，对角线上的值为从 $w^0$ 到 $w^{32}$。</p><p>建立上面联系的目的是什么呢？比如如果要做傅里叶变换，那么就要用 $F_{64}$ 乘以某个向量，这是 $64^2$ 的复杂度。但经过上面的分解，我们只需要 $2*32^2 + 32$ 即可。</p><p>还可以从 32 继续分解为 16/8/4/2/1。最终中间的矩阵越来越简单，但两侧会补上很多的修正矩阵。</p><h1 id="L28-正定矩阵和最小值"><a href="#L28-正定矩阵和最小值" class="headerlink" title="L28 正定矩阵和最小值"></a>L28 正定矩阵和最小值</h1><p>首先是复习上上节课介绍的正定性的判断方法。主要分为：</p><ol><li>特征值法</li><li>行列式法</li><li>主元法<br> 这里需要注意之前讲的一个性质，也就是主元的积等于行列式的值。</li><li>$x^T A x \gt 0$，实际上一般这才是定义<br> 注意，这里是不是要把原点扣掉？因为令 x 为零向量，那么肯定是等于0的啊？</li></ol><hr><p>下面教授举了几个例子。</p><p>[2 6; 6 18] 是一个半正定矩阵。因为它是奇异矩阵，所以有一个特征值为0，只有一个主元。半正定矩阵的特征值大于等于0。</p><p>而 [2 6; 6 7]就是不定矩阵，它实际上是一个马鞍面。</p><p>[2 6; 6 20]是正定矩阵。</p><hr><p>从微积分的角度来看，极小值点满足一阶导数为零，且二阶导数为正。这里教授说的是 minimum，不知道翻译成啥。</p><p>从线性代数中，f(x1, x2, … xn) 存在极小值的条件是二阶导数矩阵是正定的。</p><hr><p>事实上对 [2 6; 6 20] 进行配方，得到的是 $2(x + 3y)^2 + 2y^2$，它的图像是一个碗形。它的某个截面是椭圆，其实可以从椭圆的方程就能看出来了。</p><hr><p>其实配方法就是矩阵消元，可以从矩阵消元得到。<br>例如我们将矩阵 [2 6; 6 20] 进行 LU 分解。显然 U 是 [2 6; 0 2]。因为我们是用第二行减去了第一行的三倍，所以 L 是 [1 0; 3 1]，也就是加回来。</p><hr><p>什么是二阶导数矩阵呢？</p><p>其中 $f_{xx}$ 和 $f_{yy}$ 必须为正，才有最小值。并且还需要足够大以抵消混合导数的影响。<br>$$<br>\begin{bmatrix}<br>    f_{xx}&amp;f_{xy} \\<br>    f_{yx}&amp;f_{yy}<br>\end{bmatrix}<br>$$</p><p>这里 $f_{xy} = f_{yx}$，所以也能看出为什么二阶导数矩阵是对称的了。</p><p>TODO</p><h1 id="L29-相似矩阵和若尔当标准型"><a href="#L29-相似矩阵和若尔当标准型" class="headerlink" title="L29 相似矩阵和若尔当标准型"></a>L29 相似矩阵和若尔当标准型</h1><p>正定矩阵从何而来？它实际上来自于最小二乘法。不放先复习下，这里的 A 是一个长方形矩阵。<br>$$<br>\hat{x} = (A^T A)^{-1} A^T b<br>$$</p><p>我们要研究在什么情况下 $A^T A$ 是正定的。</p><p>先来想一想，正定矩阵肯定是对称的。正定矩阵的逆矩阵一定也是正定的，判断正定性有四种做法，$x^T A x \gt 0$、主元、特征值、子行列式。我们知道逆矩阵的特征值是倒数，那么不影响正负号。这里补充下，对称矩阵的逆矩阵也是对称的，可以由很早之前证明的 $(A^{-1})^T = (A^T)^{-1}$ 得到。</p><p>如果 A 和 B 都是正定矩阵，那么 A + B 是正定矩阵。这个可以从第一种判定办法得到。</p><p>回到一开始的问题，也就是什么情况下 m 行 n 列的长方形矩阵 $A$，有 $A^T A$ 是正定的。直觉上来看，它像是一个数的平方，肯定大于等于0，但矩阵中是否这样呢？</p><p>我们选用第一种判定办法来研究。也就是证明 $x^T A^T A x$ 大于0。即要证明 $(A x)^T A x \gt 0$，而 $A x$ 是个向量，向量的模是大于等于0的，并且等号只在零向量取得。那么什么时候 $A x$ 为 0 呢，或者更有用的是反过来，如何保证 $A x$ 不为0呢？这样我们就取不到等号了。这个也就是在问什么时候 A 的零空间里面只有零向量，这个很简单，满秩的情况下。也就是说如果 A 满秩，那么 $A^T A$ 正定。</p><p>现在已经很接近最后的核心内容，正定性将之前的东西联系起来。</p><hr><p>现在我们不再讨论对称阵了，而是普通的方阵。</p><p>A 和 B 是相似的，则存在某个可逆矩阵 M，有 $B = M^{-1} A M$。这个式子有什么意义？其实先前在对角化的时候就已经见到过。$S^{-1} A S = \Lambda$ 可以描述为 A 和 $\Lambda$ 相似。</p><p>【Q】其实我觉得这里只要 M 可逆就行了。</p><p>但如果我们不取特征向量矩阵 S，而是取另一个 M，同样可以得到另一个相似矩阵 B。所以所有的相似矩阵可以划为一类，并可以由其中最好的矩阵 $\Lambda$ 来代表。</p><p>例如考虑 [2 1; 1 2]，它的特征值矩阵 $\Lambda$ 是 [3 0; 0 1]。但我们也可以取另一个可逆矩阵 M = [1 4; 0 1]，它是上三角矩阵，可以轻松算到逆矩阵是 [1 -4; 0 1]，通过 M 可以得到另一个相似矩阵。总而言之，下面的几个矩阵都是相似矩阵，可以从特征值来验证。</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    1&amp;2<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    3&amp;0 \\<br>    0&amp;1<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    3&amp;7 \\<br>    0&amp;1<br>\end{bmatrix}<br>\sim<br>\begin{bmatrix}<br>    1&amp;7 \\<br>    0&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>所有的相似矩阵的特征值是相同的。可以给出如下的证明：<br>$$<br>A x = \lambda x \\<br>A M M^{-1} x = \lambda x \\<br>M^{-1} A M M^{-1} x = M^{-1} \lambda x \\<br>B M^{-1} x = M^{-1} \lambda x<br>$$</p><p>因此这些矩阵都具有特征值 $\lambda$。但对应的特征向量则未必一样，为 $M^{-1} x$。</p><p>【Q】不妨考虑这个问题，如果两个矩阵的特征向量都相同，那么这两个矩阵一定相同么？答案不是，可以考虑</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    1&amp;2<br>\end{bmatrix}<br>\begin{bmatrix}<br>    3&amp;2 \\<br>    2&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(np.array([[<span class="number">2</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">2</span>]]))</span><br><span class="line">(array([<span class="number">3.</span>, <span class="number">1.</span>]), array([[ <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>],</span><br><span class="line">       [ <span class="number">0.70710678</span>,  <span class="number">0.70710678</span>]]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(np.array([[<span class="number">3</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">3</span>]]))</span><br><span class="line">(array([<span class="number">5.</span>, <span class="number">1.</span>]), array([[ <span class="number">0.70710678</span>, <span class="number">-0.70710678</span>],</span><br><span class="line">       [ <span class="number">0.70710678</span>,  <span class="number">0.70710678</span>]]))</span><br></pre></td></tr></table></figure><p>如果两个矩阵的特征值和特征向量都相同呢？这两个矩阵也不一定相同，可以考虑<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    2&amp;1 \\<br>    0&amp;2<br>\end{bmatrix}<br>\begin{bmatrix}<br>    2&amp;0 \\<br>    1&amp;2<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>下面介绍一些比较难的情况。首先是有重特征值的情况，这意味着特征向量未必是线性无关的了，当然还是有可能线性无关的。但如果不存在 n 个线性无关的特征向量，那么就不能对角化。<br>假设有重特征值4，可以分为下面的情况：<br>第一种如下，和单位矩阵相关<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    4&amp;0 \\<br>    0&amp;4<br>\end{bmatrix}<br>\end{equation}<br>$$<br>对于这种矩阵 $M^{-1} A M = A = 4I$。</p><p>所有其他的矩阵类似于<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    4&amp;1 \\<br>    0&amp;4<br>\end{bmatrix}<br>\end{equation}<br>$$<br>不同于上面的单位矩阵，这是一个不可对角化的矩阵。这里可以看出，矩阵经过初等变换之后，可能从原来的可对角化变成不可对角化了。<br>这样的矩阵称为若尔当标准型。</p><p>不是所有的矩阵都可以很容易被变成若尔当标准型，因为这需要特征值严格相等。而在数值计算中，一个值些微的变化就能导致特征值变化甚至秩的变化。所以计算若尔当标准型很不友好。</p><p>下面的矩阵也拥有特征值4和4，所以<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    5&amp;1 \\<br>    -1&amp;3<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>下面的矩阵的四个特征向量都是0，秩为2，有两个线性无关的特征向量。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    0&amp;1&amp;0&amp;0 \\<br>    0&amp;0&amp;1&amp;0 \\<br>    0&amp;0&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;0<br>\end{bmatrix}<br>\end{equation}<br>$$<br>下面的矩阵也一样<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    0&amp;1&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;0 \\<br>    0&amp;0&amp;0&amp;1 \\<br>    0&amp;0&amp;0&amp;0<br>\end{bmatrix}<br>\end{equation}<br>$$<br>但这两个矩阵不是相似矩阵，从它们有不同的若尔当块可以看出。</p><p>若尔当块如下，主对角线上是重特征值 $\lambda_i$，上方对角线都是1，其他位置的元素都是0。每个若尔当块只有一个特征向量，多个若尔当块可以拼成一个若尔当矩阵。<br><img src="/img/linalg/jordanblock.png"></p><p>教授说，第一个矩阵上面 3x3 是一个若尔当块，下面 1x1 是一个若尔当块。我不是很明白，因为上面 3x3 不是有两个特征向量么？其实我搞错了，特征向量对应的是 $ A - \lambda I$ 的零空间而不是列空间。</p><hr><p>若尔当的理论是，每个方阵 A 和某个若尔当矩阵 J 相似。而这个若尔当矩阵中的块的数量是特征向量的数量。</p><p>而对于比较好的情况，也就是有不同的特征值，那么若尔当矩阵就是对角阵 $\Lambda$。也就是说若尔当块只是比对角矩阵多了对角线上方的一些1，这已经是最优的了。</p><hr><p>这里补充下几何重数和代数重数。<br>代数重数：也就是矩阵特征多项式中，某个解也就是特征值的重数。<br><img src="/img/linalg/tzdxs.webp"></p><p>几何重数：矩阵某个特征值对应的特征空间的维度。也就是 $A-\lambda I$ 的零空间的维度。</p><h1 id="L30-奇异值分解-SVD"><a href="#L30-奇异值分解-SVD" class="headerlink" title="L30 奇异值分解(SVD)"></a>L30 奇异值分解(SVD)</h1><p>这是线性代数的核心部分。是矩阵最终和最好的分解。</p><p>一个矩阵会被分解为一个正交矩阵 $U$，一个对角矩阵 $\Sigma$ 和一个正交矩阵 $V$ 的乘积。即 $A = U \Sigma V^T$。<br>首先介绍两个特殊情况：</p><ol><li>A 是正定矩阵，那么 A 可以被分解为 $Q A Q^T$<br> 在第 L26 课中讲过，实对称矩阵的特征向量是正交的。</li><li>A 可对角化，那么 A 可以被分解为 $ S A S^{-1}$<br> 但需要注意，这里的正交向量矩阵 S 未必是正交的。</li></ol><p>如何做到呢？我们可以在行空间找某个 $v_1$，它变换到列空间里是 $ u_1 = A v_1$。在奇异值分解中，找的是行空间里面的一组正交基，变换到列空间里面的一组正交基上。<br>此外，零空间上的向量对应了对角矩阵对角线上为0的元素。<br><img src="/img/linalg/svd.png"></p><p>首先，通过施密特正交化，可以将行空间的一组基转化为一组正交基。但并不是所有的正交基在变换后都还是正交的，所以要找特殊的一组正交基。</p><p>这里的 r 表示矩阵的秩。如果加上零空间的部分，则有 $A V = U \Sigma$。其中零空间对应的正交基是 $v_{r+1} , …, v_n$。<br><img src="/img/linalg/svd_core.png"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/470026382" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/470026382</a><br> 几何重数和代数重数</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文从&lt;a href=&quot;https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&amp;p=16&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MIT的线代教程&lt;/a&gt;的角度重新学习线性代数。&lt;/p&gt;
&lt;p&gt;这是第三部分，从 L26 开始。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
    <category term="公开课" scheme="http://www.calvinneo.com/tags/公开课/"/>
    
    <category term="代数" scheme="http://www.calvinneo.com/tags/代数/"/>
    
    <category term="线性代数" scheme="http://www.calvinneo.com/tags/线性代数/"/>
    
  </entry>
  
  <entry>
    <title>线性代数复习——以MIT18.06为指导(2)</title>
    <link href="http://www.calvinneo.com/2023/02/16/linear-alg-2/"/>
    <id>http://www.calvinneo.com/2023/02/16/linear-alg-2/</id>
    <published>2023-02-16T14:40:32.000Z</published>
    <updated>2023-04-02T13:06:24.336Z</updated>
    
    <content type="html"><![CDATA[<p>本文从<a href="https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&p=16" target="_blank" rel="noopener">MIT的线代教程</a>的角度重新学习线性代数。</p><p>这是第二部分，从 L14 开始。</p><p><img src="/img/linalg/mitbad.png"></p><a id="more"></a><h1 id="L14-正交向量和子空间"><a href="#L14-正交向量和子空间" class="headerlink" title="L14 正交向量和子空间"></a>L14 正交向量和子空间</h1><p>这张图其实在四个子空间那一节课已经展示了，但当时我没有搞明白，为什么这四个空间的位置这么诡异。因为这4个空间两两正交。<br><img src="/img/linalg/4space.png"></p><hr><p>正交(orthogonal)向量 $x$、$y$ 满足 $x^T y = 0$。可以用它证明勾股定理即 $ |x|^2 + |y|^2 = |x+y|^2 $。注意这里向量点乘，所以 $x^T y = y^T x$。</p><p>根据定义，零向量和所有向量正交。</p><hr><p>两个子空间正交是什么意思呢？即 A 中的所有向量，和 B 中的所有向量正交。考虑教室作为一个三维空间，墙上的向量和地板上的向量未必正交。或者其实考虑 $ [1,1,0]$ 和 $[1,0,1]$ 即可。或者考虑踢脚线的那个向量，它同时处于两个空间中，肯定不会自己和自己正交。</p><p>所以如果两个空间正交，它们的交集一定不会是某个非零向量。当然这不是充分的。</p><hr><p>证明行空间和零空间正交。</p><p>不如把 A 写完整。可以看到每一行 $r_i$ 乘上 $x$ 都为 0。<br>$$<br>Ax = 0 \\<br>\Leftrightarrow \\<br>\begin{equation}<br>\begin{bmatrix}<br>    r_1 \\<br>    r_2 \\<br>    … \\<br>    r_m \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    x_1 \\<br>    x_2 \\<br>    … \\<br>    x_m \\<br>\end{bmatrix}<br>= 0<br>\end{equation}<br>$$</p><p>然后我们证明这些行的线性组合，和 $x$ 正交。这是肯定的。</p><hr><p>那么它们可能是什么呢？考虑 $R^3$，行空间和零空间不可能是两条直线，因为维度加起来不对。其实我们可以考虑是一条线和一个面的正交。</p><p>可以看出，行空间和零空间“划分”整个 $R^m$。这称为 $m$ 维空间里的正交补。也就是说行空间包含了所有和零空间垂直的向量。</p><hr><p>如何求一个无解方程组的解？这里指的是 $m$ 很大的时候。比如进行很多次测量，里面存在各种噪声，方程组大概率无解。所以我们要采取比如最小二乘法的技巧来“拟合”。</p><p>如果 $A$ 是 $m$ 行 $n$ 列 的矩阵，则 $A^T A$ 有一些很好的特性：</p><ol><li>它是方阵</li><li>它是对称矩阵<br> 这是因为 $ (A^T A)^T = A^T A $</li></ol><p>所以当我们发现 $ A x = b$ 无解时，两边乘以 $A^T$ 就会得到一个“好”的方程 $ A^T A \hat {x} = A^T x$。</p><hr><p>现在考虑 $A^T A$什么时候是可逆的呢？<br>首先这个矩阵未必可逆，比如零矩阵，比如下面这个 $A$<br>$$<br>\begin{bmatrix}<br>    1&amp;3 \\<br>    1&amp;3 \\<br>    1&amp;3 \\<br>\end{bmatrix}<br>$$</p><p>事实上 $N(A^T A)=N(A)$，且 $r(A^T A) = r(A)$。为什么呢？关于这个性质，在 L16 最后会进行证明，这里不妨假设它是对的。</p><p><img src="/img/linalg/bthz.png"></p><p>所以 $N(A^T A)$ 可逆，当且仅当 $A$ 的各列线性无关，这样零空间就是0维的了。</p><h1 id="L15-子空间投影"><a href="#L15-子空间投影" class="headerlink" title="L15 子空间投影"></a>L15 子空间投影</h1><p>向量 $b$ 和它在向量 $a$ 上的投影 $p$ 正交。如果我们将 $p$ 视为 $b$ 的近似，那么 $e = b - p$ 就是这近似的误差。这里 $p$ 是 $a$ 的某个倍数，即 $p = x a$。<br><img src="/img/linalg/projection_error.png"></p><p>$e$ 等于 $b - x a$。整理一下上面的关系，有<br>$$<br>a^T (b - x a) = 0<br>$$</p><p>化简一下，可以求得 $x$</p><p>$$<br>x a^T a = a^T b \\<br>x = \frac{a^T b}{a^T a}<br>$$</p><p>投影 p 就是<br>$$<br>p = a \frac{a^T b}{a^T a}<br>$$</p><hr><p>投影矩阵 P，上面一行是一个矩阵(列乘以行)，下面一行是一个数。投影矩阵 P 作用于 b，得到 b 向量在 a 上的投影。<br>$$<br>P = \frac{a a^T}{a^T a} \\<br>p = P b<br>$$</p><p>看看这个矩阵的列空间，先想想几何意义。因为 $P$ 是投影矩阵，它就是要投到 $a$ 这根向量上。所以 $P$ 的列空间就是通过 $a$ 的一条直线。所以 $P$ 的秩是1。</p><p>其实根据上节课末尾介绍的 $r(A^T A) = r(A)$，可以知道分式上面的 $ a a^T $ 的秩就是 $a$ 的秩是1，下面是一个常数。</p><p>这个矩阵是对称的么？是的，因为 $ a a^T $ 是对称的。</p><p>还能发现，投影两次是自己，即 $ P^2 = P$。</p><hr><p>下面来看在更高维，比如 $R^3$ 上投影。现在 $b$ 不是在 $a$ 上投影，而是在 $A$ 上投影了。</p><p>为什么要投影呢？因为 $Ax = b$ 无解，也就是说 $b$ 不一定在 $A$ 的列空间中。所以我们就退而求其次，求 $A \hat{x} = p$。也就是求 $b$ 在 $A$ 列空间上的投影。</p><p>这里的 $e$ 向量是垂直于平面的了。</p><p><img src="/img/linalg/proj_3d.png"></p><p>此时我们的投影是</p><p>$$<br>p = \hat{x}_1 a_1 + \hat{x}_2 a_2 = A \hat{x}<br>$$</p><p>因为 e 垂直于由 $a_1$ 和 $a_2$ 构成的平面，可以表示为 $b - A \hat{x}$，所以可以得到两个方程<br>$$<br>a_1^T (b - A \hat{x}) = 0 \\<br>a_2^T (b - A \hat{x}) = 0 \\<br>\Leftrightarrow \\<br>A^T (b - A \hat{x}) = 0<br>\Leftrightarrow \\<br>A^T A \hat{x} = A^T b<br>$$</p><p>这个方程看上去和二维的有点出入，但其实你把二维里面的 $a$ 看做是 $A$ 就对的上了。这个式子铭记在心，它很重要。</p><p>$e$ 在 $A^T$ 的零空间中，也就是说 $e$ 垂直于 $A$ 的列空间。其实我觉得从图上就能看出来吧……</p><hr><p>现在不妨讨论下方程的解<br>$$<br>\hat{x} = (A^T A)^{-1} A^T b<br>$$</p><p>投影 $p$ 就是<br>$$<br>p = A \hat{x} = A (A^T A)^{-1} A^T b<br>$$</p><p>形式上很像 </p><p>$$<br>\frac{a a^T}{a^T a}<br>$$</p><p>我们能简化为 $ P = A A^{-1} (A^T)^{-1} A^T $，结果居然是 $I$。这肯定有问题，可是哪里有问题呢？教授说因为 $A$ 不是方阵。所以我们不能直接写成分式，即下面未必成立</p><p>$$<br>p = \frac{A A^T}{A^T A} b<br>$$</p><p>而如果 $A$ 是一个可逆的方阵，那么列空间是整个 $R^m$，而投影矩阵确实就是单位阵。</p><p>同理，$ P $ 也是对称阵。<br>$ P^2 = P$，写出来可以发现中间可以消掉。</p><hr><p><img src="/img/linalg/ls.png"></p><p>最小二乘求得是 $ A^T A \hat{x} = A^T b$。这个方程之前介绍过，说的是 $e$ 和 $A$ 的列空间正交。</p><h1 id="L16-投影矩阵和最小二乘"><a href="#L16-投影矩阵和最小二乘" class="headerlink" title="L16 投影矩阵和最小二乘"></a>L16 投影矩阵和最小二乘</h1><p>如果 $b$ 垂直于列空间，则 $P b = 0$。因为 $A^T b = 0$。<br>如果 $b$ 属于列空间，则 $P b = b$。将 $Ax$ 带入，发现等于 $b$。</p><p>所以这里有点向量分解的意思。已经知道投到列空间的向量是 $P b$，那么投到左零空间的向量是 $(I - P) b$。<br><img src="/img/linalg/xlfj.png"></p><hr><p>回到最小二乘，我们要最小化的是 $ | Ax - b |^2 $，因为 $Ax - b = e$，所以也就是最小化 $e^2$。对这个有疑问的，可以多去看一下二维的情况。</p><p>最小二乘很容易受到离群点的影响，因为这个离群点会导致误差的平方非常大。</p><p>如下图所示，如果我们不是把 b1、b2、b3 放入方程，而是将 p1、p2、p3 放入方程，则好处是方程是有解的。并且我们也能发现它们确实是“最近”的。而我们要最小化的是 $e1^2 + e2^2 + e3^2$。<br><img src="/img/linalg/peb.png"></p><p>现在我们求<br>$$<br>\begin{equation}<br>\hat{x} =<br>\begin{bmatrix}<br>    \hat{C} \\<br>    \hat{D} \\<br>\end{bmatrix}<br>\end{equation}<br>$$<br>以及 $p$。</p><p>$\hat{x}$ 是什么呢？之前说过是<br>$$<br>A^T A \hat{x} = A^T b<br>$$</p><p>下面这种图中对这个方程进行了化简，最后得到右边的矩阵<br><img src="/img/linalg/solve-linear.png"></p><p>那么解就是下面的方程组<br>$$<br>3C + 6D = 5 \\<br>6C + 14D = 11 \\<br>$$</p><p>可以用分析的办法来解决，即考虑最小化 $e1^2 + e2^2 + e3^2$。分别对 $C$ 和 $D$ 求偏导数，可以同样得到上面两个方程。</p><p>最后我们求出 $b = p + e$，可以发现 $e$ 和 $p$ 互相垂直。<br><img src="/img/linalg/bpe.png"></p><hr><p>填坑，证明如果 $A$ 各列线性无关，则 $A^T A$ 可逆。</p><p>只需要证明如果 $A^T A x = 0$，则 $x = 0$。因为在 L09 讲过，如果矩阵可逆，那么它的零空间只有0。</p><p>第一种办法，是两边都左乘 $x^T$，得到 $ x^T A^T A x = 0$。其实就是 $(Ax)^T (Ax) = 0$，很有趣。而如果 $y^T y = 0$，说明 $y$ 是零向量，因为这个表示向量长度的平方。</p><p>【Q】如果这里 $A$ 是矩阵，$A^T A = 0$，是什么性质呢？A 也是0，可以看下<a href="https://math.stackexchange.com/questions/1044527/prove-that-aat-0-implies-a-0" target="_blank" rel="noopener">这个证明</a>。这个证明引入的符号也很实用。</p><p>上面得到 $Ax = $，因为 $A$ 各列线性无关，所以 $x$ 一定是零向量。</p><hr><p>下节课的预告：相互垂直的向量一定线性无关。</p><h1 id="L17-正交矩阵和施密特正交化"><a href="#L17-正交矩阵和施密特正交化" class="headerlink" title="L17 正交矩阵和施密特正交化"></a>L17 正交矩阵和施密特正交化</h1><p>首先定义正交向量 $q_i$ 和 $q_j$，如果 $ i \ne j$ 则 $q^T_i q_j = 0$，如果 $ i = j$ 则 $ q^T_i q_j = 1 $。我觉得这个 0 表明了正交，1 表明了标准。</p><p>下面教授证明性质如果 Q 的列向量为标准正交向量，则 $ Q^T Q = I$ 为单位阵。</p><p>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    q_1&amp;q_2&amp;x&amp;q_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>$$<br>Q^T Q =<br>\begin{equation}<br>\begin{bmatrix}<br>    q_1 \\<br>    q_2 \\<br>    x \\<br>    q_n \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    q_1&amp;q_2&amp;x&amp;q_n \\<br>\end{bmatrix}<br>= I<br>\end{equation}<br>$$</p><p>教授说，尽管这个性质对非方阵也有效，但仅<strong>方阵并且标准正交</strong>的情况下，我们才会将它称为正交矩阵。</p><hr><p>下面举例说明正交矩阵的定义。</p><p>例如下面的置换矩阵是正交矩阵。其实我想，根据上面的性质，可以知道如果 Q 还是方阵，则 $ Q^T = Q^{-1}$。而正交矩阵 P 也满足这个关系，所以很容易想到它是正交矩阵。<br>$$<br>\begin{equation}<br>P =<br>\begin{bmatrix}<br>    0&amp;0&amp;1 \\<br>    1&amp;0&amp;0 \\<br>    0&amp;1&amp;0 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>同理，下面这个矩阵也是正交矩阵，因为它的的两个列向量都是单位向量。<br>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    cos\theta&amp;-sin\theta \\<br>    sin\theta&amp;cos\theta \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>下面这个矩阵的列向量正交，但因为列向量不是单位向量，所以不是正交矩阵<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    1&amp;1 \\<br>    1&amp;-1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>后面还介绍了 Hadamard 矩阵，略了。</p><hr><p>下面的矩阵的列向量是标准正交的，但它不是方阵，所以不是正交矩阵，但我们可以拓展它成为正交矩阵。<br>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    1&amp;-2 \\<br>    2&amp;-1 \\<br>    2&amp;2 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>我们之前已经介绍过了，如果 Q 的列向量是标准正交向量，但 Q 未必是方阵，则投影到 Q 的列空间的投影矩阵为</p><p>$$<br>P = Q (Q^T Q)^{-1} Q^T<br>$$</p><p>因为标准正交，所以有 $Q^T Q = I$。即 $ P = Q Q^T$。</p><p>其实当时学到这我就有疑问，为啥 $ Q Q^T$ 不能也是 I，后来才发现不一定是方阵……不过如果 $Q$ 确实是方阵，那么 $ Q^ Q = I$，即 $P$ 就是单位阵了。因为 $Q$ 的列向量张成了整个空间，所以投影过程不会对向量有任何改变。</p><hr><p>正规方阵 $Q$ 可以之前讲过的所谓“线性代数基本方程”即 $A^T A \hat{x} = A^T b$ 进行简化。也就是说，如果 $A$ 是 $Q$，那么 $ \hat{x} = Q^T b$。即 $\hat{x_i}=q_i^T b$。</p><hr><p>下面介绍施密特正交化，教授吐槽了下这个东西居然还能两个人冠名。</p><p>首先施密特说，一个正交基除以自己的长度得到标准正交基，即<br>$$<br>q_1 = \frac{A}{|A|}<br>$$</p><p>然后就是如何求得正交，其实从下面的图中就可以看出，前面讲的 b 和 A 的误差 e 就是正交基。</p><p><img src="/img/linalg/gcmethod.png"></p><p>即 $ B = b - \frac{A^T b}{A^T A} A$。其实这里我很困惑，不应该是 $ B = b - A(A^T A)^{-1} A^T b$ 么？搞了半天，原来这里的 A 和 B 啥的都是向量而不是矩阵……所以这里能直接用分式除也是这个原因。哈哈，想到 Artin 书里面直接写不要写成分式，就挺好笑，MIT 老师的风格都好不一样。</p><p>我们可以验证正交性。<br>$$<br>A^T B = A^T (b - \frac{A^T b}{A^T A} A)<br>$$<br>教授的意思是可以像这样提出来 $A^T b$。不知道这里为啥可以分配，可能是我瞎猜的<br>$$<br>A^T b = A^T (I - \frac{A^T A}{A^T A}) = 0<br>$$</p><hr><p>最后，教授又将 Q 和 LU 分解联系起来。他说 $A = Q R$，R 就是行最简阶梯矩阵，randomwalk 的笔记说可以放宽到上三角矩阵。</p><p>他说下面的式子中，$a_1^T q_2$是0。因为 $q_2$ 和 $a_1$ 垂直。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a_1&amp;a_2 \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    q_1&amp;q_2 \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    a_1^T q_1&amp;a_2^T q_1 \\<br>    a_1^T q_2&amp;a_2^T q_2 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><h1 id="L18-行列式和它的性质"><a href="#L18-行列式和它的性质" class="headerlink" title="L18 行列式和它的性质"></a>L18 行列式和它的性质</h1><p>开始着重介绍方阵。首先介绍行列式，它的作用是引出后面的特征值。</p><p>行列式中包含了很多有关这个矩阵的信息，例如可逆矩阵的行列式不是0，奇异矩阵的行列式是0。</p><hr><p>首先介绍三个行列式的性质，通过下面这三个性质，我们可以定义出所有矩阵的行列式<br>第一个性质说，$det(I) = 1$。<br>第二个性质说，行交换导致行列式符号相反。通过行交换，我们可以得到所有的置换矩阵。容易知道 $det(P)= \pm 1$。<br>第3a个性质说，行列式的一行中的每个元素都乘上一个 t，则行列式的值就会乘上一个 t。<br>第3b个性质说，行列式可以对某一行进行线性组合，听起来很怪，不如直接看下面的性质。同时注意，教授不是在说 $det(A+B)=det(A)+det(B)$。<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a + a’&amp;b + b’ \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    a’&amp;b’ \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>听到这里，我不禁点了暂停进行了验证，确实通过三个性质推出所有矩阵的行列式了。关于为什么最右边的行列式为0可以看看后面的推导。<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    1&amp;2 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    1&amp;0 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;2 \\<br>    0&amp;4 \\<br>\end{matrix} \right |<br>= 4<br>\left | \begin{matrix}<br>    1&amp;0 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>+<br>2 \times 4<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$<br>不得不说，上面三个性质非常容易理解，比用代数余子式的定义好多了，比什么鬼逆序数更是高到不知高哪里去。</p><hr><p>下面介绍行列式的其他性质，它们都可以从上面三个性质得到。<br>第四个性质说，如果行列式的两个行相等，那么行列式的值为0。这里推理的方法很巧妙，根据性质2，如果我们交换两行，行列式会反号。但我们交换的行又是相等的，照理说行列式符号不变。又要反号，又要不变，那行列式的值只能为0了。</p><p>第五个性质说，行 k 减去行 i 的若干倍，行列式的值不变。其实应该能猜到不变，消元如果能让行列式的值变化，那岂不是消元就有可能让不可逆矩阵可逆了？<br>所以<br>$$<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;1 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    0&amp;1 \\<br>    0&amp;0 \\<br>\end{matrix} \right |<br>$$</p><p>第六个性质说，如果矩阵的某一行都是0，则行列式是0。</p><p>第七个性质，上三角矩阵的行列式 U 等于对角线元素的乘积。这个很容易理解，因为可以通过之前的性质消掉上三角，得到一个对角矩阵，其行列式不变。然后可以用性质 3a “提取公因式”。</p><p>第八个性质，$det(A) = 0$ 当且仅当 A 是奇异矩阵。因为矩阵如果可逆，那么每一行都有主元，那么始终可以 <code>A -&gt; U -&gt; D -&gt; d1 d2 ... dn</code>这样计算。<br>比如<br>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    0&amp;d-\frac{c}{a}b \\<br>\end{matrix} \right |<br>= ad - bc<br>\end{equation}<br>$$</p><p>第九个性质，$det(AB) = det(A) det(B)$。所以虽然行列式不具备所谓的 adding property，但对乘法是有性质的。关于这个的证明教授没给出，randomwalk 说书上有，但其实书上也没找到。</p><p>从第九个性质可以推出 $det(A^{-1}) det(A) = det(I) = 1$，所以 $det(A^{-1}) = \frac{1}{det(A)}$。</p><p>另一个更有趣的性质是 $det(2A) = 2^n det(A)$，相当于每行都需要乘以一个 2。这就将行列式和体积联系起来了，如果正方体的边长扩大到原来的两倍，那么体积扩大到原来的 $2^3$ 倍。关于体积，后面还会详细介绍。</p><p>第十个性质，$det(A^T) = det(A)$，这就将行的性质可以推广到列上。<br>更有意思的是教授给了一个直觉的证明。我们可以将方阵进行 LU 分解，所以实际是要证明</p><p>$$<br>|U^T L^T| = |L U|<br>$$<br>根据性质九，实际是要证明<br>$$<br>|U^T| |L^T| = |L| |U|<br>$$</p><p>而这个是显然的，因为上下三角阵都等于主对角线的乘积，而转置不会改变主对角线。</p><hr><p>后面是一个非常有趣的观察，也就是置换具有奇偶性。这个往深了讲还能扯到交错群上。</p><p>教授说，进行一次行交换，行列式符号取反，所以得到的矩阵“是不一样”的。这听起来有点循环论证，因为交换行符号取反是教授的行列式定义啊。</p><h1 id="L19-行列式和代数余子式"><a href="#L19-行列式和代数余子式" class="headerlink" title="L19 行列式和代数余子式"></a>L19 行列式和代数余子式</h1><p>首先介绍从行列式的性质推导出行列式的计算公式。</p><p>对于二阶行列式，教授上节课已经从消元的角度推导过一次了，这次他用类似我上节课尝试的做法做的。其中第一和第四个行列式等于0。</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    a&amp;0 \\<br>    c&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    a&amp;0 \\<br>    0&amp;d \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;b \\<br>    c&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    0&amp;b \\<br>    0&amp;d \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>容易想到，对于3阶方阵，我们这样能拆出来 27 个行列式，这也太多了。但其中有很多行列式必然是0，因为它们的某一行或者列是0。有哪些行列式有可能不是0呢？</p><p>考虑三阶方阵，这里我省略下标，即 $a_{ij}$ 写成 $ij$ 了。如果我们选定第一行是 11，那么如果第二行选 22，那么最终可以被 11 消掉，所以只能选 22 或者 23。在第二行选完之后，第三行能选的也就唯一确定了。</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;23 \\<br>    0&amp;32&amp;33 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>所以可以得到</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;23 \\<br>    0&amp;32&amp;33 \\<br>\end{matrix} \right |<br>=<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;0&amp;23 \\<br>    0&amp;32&amp;0 \\<br>\end{matrix} \right |<br>+<br>\left | \begin{matrix}<br>    11&amp;0&amp;0 \\<br>    0&amp;22&amp;0 \\<br>    0&amp;0&amp;33 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>这里行列式是加，但如果再往下算，会发现符号会取反</p><p>$$<br>… = 11 * 22 * 33 - 11 * 23 * 32<br>$$</p><p>所以这里正负号有什么规律么？3阶方阵是有个规律，但没必要去记，因为4阶方阵不一样了。比如4阶方阵的副对角线上那四个数乘起来的 $14 * 23 * 32 * 41$ 其实符号应该为正。这是因为 $(4 , 3 , 2 , 1)$ 这样的排列，只需要进行两次即偶数次交换，即 1 和 4，2 和 3 交换即可。行列式的符号不变。</p><hr><p>下面推导一个行列式的通用公式，称为 The Big Formula。</p><p>$$<br>det(A) = \sum_{n! items} \pm a_{1\alpha} a_{2\beta} … a_{n\omega}<br>$$<br>其中，$\alpha, \beta, …, \omega$ 是从 1 到 n 的一个排列。</p><p>这个公式的 intuition 很简单，因为第一行可以在 n 列中选一个元素，第二行只能在剩下没选的 n-1 列中选一个元素，否则必然是0，由此往下推，总共就是 n! 中方案。</p><hr><p>下面介绍代数余子式。</p><p>以三阶矩阵为例</p><p>$$<br>det(A) = a_{11} + (a_{22} a_{33} - a_{23} a_{32}) \\<br>    + a12 (…) \\<br>    + … \\<br>$$</p><p>如果我们同时对 $a_{11}$ 展开行列式，可以看出，右下角的那个2阶方阵就是上面括号中的数字。即代数余子式 $C_{ij}$。</p><p>$$<br>\left | \begin{matrix}<br>    a_{11}&amp;0&amp;0 \\<br>    0&amp;a_{22}&amp;a_{23} \\<br>    0&amp;a_{32}&amp;a_{33} \\<br>\end{matrix} \right |<br>$$</p><p>不难猜出规律，正负号和 $i+j$ 有关。偶数正，奇数负。</p><p>可以得到行列式的代数余子式的计算方法<br>$$<br>det(A) = a_{11} C_{11} .. a_{1n} C_{1n}<br>$$</p><hr><p>下面，同样是用代数余子式来算二阶矩阵的行列式</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    a&amp;b \\<br>    c&amp;d \\<br>\end{matrix} \right |<br>= a d + b (-c)<br>\end{equation}<br>$$</p><p>可以看到，代数余子式求行列式也不简单。其实根据之前的性质7，也就是所谓的 pivot formula，可以发现，消元之后将主元都乘起来是最简单的。</p><hr><p>下面，介绍了一个叫三对角线阵的方阵。</p><p>$$<br>\begin{equation}<br>A_4 =<br>\left | \begin{matrix}<br>    1&amp;1&amp;0&amp;0 \\<br>    1&amp;1&amp;1&amp;0 \\<br>    0&amp;1&amp;1&amp;1 \\<br>    0&amp;0&amp;1&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><p>这里算 A3，我的方法更取巧，因为只需要消元成下面的形式，就可以发现交换 1 和 2 行得到 I。这样就可以知道行列式的值为 -1。</p><p>$$<br>\left | \begin{matrix}<br>    0&amp;1&amp;0 \\<br>    1&amp;0&amp;0 \\<br>    0&amp;0&amp;1 \\<br>\end{matrix} \right |<br>$$</p><p>这里算 A4 很有意思，选取 $a_{11}$，其代数余子式为 $A_3$。选取 $a_{12}$，代数余子式如下，我们不认识。但如果将它先转置，那么算起来会方便很多。这是一个很有趣的技巧。</p><p>$$<br>\left | \begin{matrix}<br>    1&amp;1&amp;0 \\<br>    0&amp;1&amp;1 \\<br>    0&amp;1&amp;1 \\<br>\end{matrix} \right |<br>$$</p><p>后面教授推到<br>$$<br>A_n = |A_{n-1}| - |A_{n-2}|<br>$$</p><p>得到 $A_n$ 的行列式的值随着 n 增大有个长度为 6 的循环节。这个略过了。</p><h1 id="L20-克莱默法则和体积"><a href="#L20-克莱默法则和体积" class="headerlink" title="L20 克莱默法则和体积"></a>L20 克莱默法则和体积</h1><p>基于行列式求逆矩阵如下，其中 $C^T$ 为各个 $a_{ij}$ 对应的 $C_{ij}$ 构成的矩阵的转置，称为伴随矩阵。</p><p>$$<br>A^{-1} = \frac{1}{det(A)} C^T<br>$$</p><p>教授说，det(A) 是 n 个 entry 的 product，而 $C^T$ 是 n-1 个 entry 的 product，不知道这有什么深层含义。</p><hr><p>下面教授证明上面的式子是对的，也就是要证明 $A C^T = (det(A)) T$。</p><p>首先确认主对角线上的每一个元素都是 det(A)。<br>不妨直接写出来。可以看出第一行乘以第一列就是 $a_{11} C_{11} + … + a_{1n} C_{1n}$，也就是行列式的值。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a_{11}&amp;…&amp;a_{1n} \\<br>    \ &amp;\ddots&amp; \ \\<br>    a_{n1}&amp;…&amp;a_{nn} \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    c_{11}&amp;…&amp;c_{1n} \\<br>    \ &amp;\ddots&amp; \ \\<br>    c_{n1}&amp;…&amp;c_{nn} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>然后确认非主对角线上的元素都是0。我们不妨考虑二阶矩阵这个简单的情况。<br>下面这个矩阵，它的行列式的值是0，两行相同。<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    a&amp;b \\<br>    a&amp;b \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>如果求 A 的第一行，和 C^T 的最后一列的内积，即 C 的最后一行的内积，也就相当于是求一个第一行和最后一行相等的矩阵的行列式。而如果两行相等，则行列式的值为0。</p><hr><p>考虑 $Ax = b$，有 $x = \frac{1}{det(A)} C^T b$，这就是克莱默法则。</p><p>这个神奇的 $C^T b$ 是怎么来的呢？教授说，一个余子式乘以一个数字，总让人想起行列式的值。不妨考虑 b 是个 n 维向量，那么其中一个分量的解就可以写成如下的形式，其中 $det(B_1)$ 就是那个不知道是什么的行列式的值。</p><p>$$<br>x_1 = \frac{det(B_1)}{det(A)}<br>$$</p><p>克莱默发现，这个行列式对应的矩阵 $B_1$ 实际上就是用 b 替换掉 A 的第一列，从而得到的矩阵。</p><p>$$<br>\begin{equation}<br>\left [ \begin{matrix}<br>    b_1&amp;a_{12}&amp;…&amp;a_{1n} \\<br>    b_2&amp;\ n &amp; - &amp;1 \\<br>    …&amp;\ cols&amp; \ &amp; of \\<br>    b_n&amp;\  &amp;\ A \\<br>\end{matrix} \right ]<br>\end{equation}<br>$$</p><p>容易看出，上面矩阵的右下角的部分就是 $C_11$。那么 $B_1$ 的行列式可以写成</p><p>$$<br>C_{11} b_1 + C_{21} b_2 + … + C_{n1} b_n<br>$$</p><p>而如下所示，上面这个式子等于 $C^T b$</p><p>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    c_{11} &amp; c_{21} &amp; \ldots &amp; c_{n1} \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    b_{1} \\<br>    b_{2} \\<br>    \vdots \\<br>    b_{n} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>行列式的值和体积有对应的关系。例如三阶行列式的值，就是对应三个向量组成的平行六面体的体积。</p><p>如何证明呢？这里有个神来一笔，我们只需要证明体积满足行列式的那三个定义就行了。</p><p>对于第一个定义，可以发现单位立方体的体积是1，这对应了 I 的行列式。</p><p>特别地，如果 A 是正交矩阵 Q，它对应的也是单位立方体，只是可能会发生旋转。它的体积也是 1，这是因为 $Q^T Q = I$。所以行列式相等，即 $ |Q^T Q| = |I|$，然后观察到 $ |Q^T Q| = |I|<br>\Rightarrow |Q| |Q| = |I| = 1 $，所以 $|Q| = \pm 1$。</p><p>对于第二个定义，显然交换行相当于坐标轴对调，不会改变体积。</p><p>对于第 3a 个定义，是显然的。</p><p>对于第 3b 个定义，下面的图一目了然。</p><p><img src="/img/linalg/volume3b.png"></p><hr><p>特别地，教授还讲了三顶点都不过原点的三角形的面积，是</p><p>$$<br>\begin{equation}<br>\left | \begin{matrix}<br>    x_1&amp;y_1&amp;1 \\<br>    x_2&amp;y_2&amp;1 \\<br>    x_3&amp;y_3&amp;1 \\<br>\end{matrix} \right |<br>\end{equation}<br>$$</p><h1 id="L21-特征向量和特征值"><a href="#L21-特征向量和特征值" class="headerlink" title="L21 特征向量和特征值"></a>L21 特征向量和特征值</h1><p>对于特定的向量 x，我们要 $ Ax = \lambda x$，也就是说 $ Ax$ 和 $x$ 平行。</p><hr><p>不妨考虑一下一些特殊矩阵的特征值和特征向量。</p><p>如果 $A$ 是个奇异矩阵，它可以将某个非零向量变为0，所以它的一个特征值是0。这是肯定的，因为如果 $A$ 是奇异矩阵，则 $A$ 不可逆，且 $Ax = 0$ 存在非零解，即 $Ax$ 的零空间中不只有 0 向量。</p><p>考虑投影矩阵 $P$，它所投影到的平面上的所有向量是特征向量。这是因为对于任意平面内的向量 x 有 $P x = x$，此时 $\lambda=1$。<br>还有没有其他的特征向量么？所有垂直于平面的向量也是特征向量，这是因为总有 $P x = 0$，此时 $\lambda=0$。</p><p>考虑置换矩阵 A = [0 1; 1 0]。容易发现向量 $[1 , 1]^T$ 是它的一个特征向量，对应特征值为 1。教授说，肯定还有个特征值是 -1，对应特征向量是 $[-1 , 1]$。<br>这么厉害的么？原来根据代数基本定理，在 n 阶方阵中肯定有 n 个特征值，并且它们的和等于矩阵的迹，也就是主对角线的和。<br>因为 A 是对称矩阵，所以这两个向量互相垂直。</p><hr><p>下面来解 $ Ax = \lambda x$ 这个方程了，简单移项可以得到 $(A - \lambda I) x = 0$。</p><p>教授说，$A - \lambda I$ 一定是奇异的，否则 x 只能为零向量了。</p><p>所以 $det(A - \lambda I)=0$。对于这个行列式，可以用消元法求出主列。</p><p>例如考虑矩阵 [3 1; 1 3]，$det(A - \lambda I) = \lambda^2 - 6 \lambda + 8$。有趣的是这里的 6 刚好是 trace(A)，8 则是 det(A)。这有点像韦达定理，不知道对于更高阶的矩阵，是不是也是对应的韦达定理呢。</p><p>现在求出特征值了，下面需要求特征向量。可以用消元法解 $ A - \lambda I $，这一矩阵零空间中的向量为矩阵<br>A 的特征向量。不妨先考虑 $\lambda_1 = 4$，对应的 $A - \lambda I$ 是<br>$$<br>\begin{bmatrix}<br>    -1&amp;1 \\<br>    1&amp;-1 \\<br>\end{bmatrix}<br>$$<br>显然这个矩阵一定是奇异矩阵。我们要找的就是它的零空间。同样可以消元得到<br>$$<br>\begin{bmatrix}<br>    1&amp;-1 \\<br>    0&amp;0 \\<br>\end{bmatrix}<br>$$<br>然后可以得到<br>$$<br>\begin{equation}<br>\begin{bmatrix}<br>    -F \\<br>    I \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    1 \\<br>    1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>进一步考虑上面的问题 [3 1; 1 3] 相比 [0 1; 1 0]，它的特征向量没变，但是特征值都增加了3。所以如果 $Ax = \lambda x$，则 $(A + 3 I)x = \lambda x + 3 x = (\lambda + 3)x$。</p><p>但是两个矩阵的和的特征值不等于两个矩阵特征值的和。教授说因为特征向量可能不一样。反正这一块他讲得很奇怪，我就不记录了。</p><hr><p>下面讨论一些特殊的矩阵。</p><p>首先是旋转矩阵，它是正交的，所以教授用 Q 表示</p><p>$$<br>\begin{equation}<br>Q =<br>\begin{bmatrix}<br>    0&amp;-1 \\<br>    -1&amp;0 \\<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>    cos90^{\circ}&amp;-sin90^{\circ} \\<br>    sin90^{\circ}&amp;cos90^{\circ} \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>这里教授补充了下，特征值的积等于行列式的值。【Q】看起来特征值还和体积有关系？</p><p>教授发出灵魂拷问，什么样的向量在旋转之后还是它自己呢？除了0向量之外，我似乎想不到别的，那 $A x = \lambda x$ 如何成立呢？然后教授就推到 $\lambda^2 + 1 = 0$。原来如此，特征值可能是虚数！</p><p>教授说，对称矩阵都是实特征值，而我们的这个矩阵是反对称矩阵，也就是说 $Q^T Q = -1$。所以它的特征值是纯虚数。所以看起来，实数特征值是让特征向量伸缩的部分，而虚数是让特征向量的旋转部分？</p><p>另外从这也可以看出，如果 $a+bi$ 是特征值，那么共轭复数 $a-bi$ 也是特征值。</p><hr><p>然后是上三角矩阵，它的特征值全部在对角线上。我们发现，它的两个特征值相等，都为3。<br>$$<br>\begin{bmatrix}<br>    3&amp;1 \\<br>    0&amp;3 \\<br>\end{bmatrix}<br>$$</p><p>可以找到一个特征向量 $[1, 0]$。这是显然的，因为我们有一个主元，一个自由列。但因为另一个特征值是重复的，所以找不到第二个线性无关的特征向量了。这说明矩阵是个退化矩阵。</p><p>下一节会继续讨论这个问题。</p><h1 id="L22-对角化和矩阵的幂"><a href="#L22-对角化和矩阵的幂" class="headerlink" title="L22 对角化和矩阵的幂"></a>L22 对角化和矩阵的幂</h1><p>这里，定义 S 是<strong>特征向量组成的矩阵</strong>。我们同时要求 S 是可逆的，这说明 A 要有 n 个线性无关的特征向量。</p><p>S 有很神奇的性质，不妨算算<br>$$<br>AS = A [x1 , x2 , … , xn] \\<br>= [\lambda_1 x1 , \lambda_2 x2, …, \lambda_n xn] \\<br>=<br>\begin{equation}<br>\begin{bmatrix}<br>    x1&amp;x2&amp;…&amp;xn \\<br>\end{bmatrix}<br>\begin{bmatrix}<br>    \lambda_1 &amp; … &amp; 0 \\<br>    0 &amp; … &amp; 0 \\<br>    0 &amp; … &amp; \lambda_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>这里最后一步，可以正好用来复习列操作。也就是矩阵乘法的第四种看待方式。所以接下来可以得到</p><p>$$<br>\begin{equation}<br>AS = S<br>\begin{bmatrix}<br>    \lambda_1&amp;…&amp;0 \\<br>    \vdots &amp; \ddots &amp; \vdots \\<br>    0&amp;…&amp;\lambda_n \\<br>\end{bmatrix}<br>= S \Lambda<br>\end{equation}<br>$$</p><p>从上面可以总结得到</p><p>$$<br>S^{-1} A S = \Lambda \\<br>A = S \Lambda S^{-1}<br>$$</p><p>所以我们有了在 LU、QR 分解之外的另一种分解矩阵的思路。</p><hr><p>这种新的矩阵分解方式常常被用来计算矩阵的幂。即</p><p>$$<br>A^k x = S \Lambda^k S^{-1}<br>$$</p><p>当所有的特征值的绝对值都小于 1 时，$|A^k|$ 趋向于零矩阵。</p><hr><p>A 必存在 n 个线性无关的特征向量才能对角化。<br>可是<strong>如何判断是否有 n 个线性无关的特征向量</strong>呢？</p><ol><li>当所有的特征值不同，那么一定有 n 个线性无关的特征向量。</li><li>当有重复的特征值，则需要进一步检查<br> 例如对 I 来说，有 n 个线性无关的特征向量。<br> 对之前说的矩阵来说则没有。</li></ol><p>代数重度 几何重度 都是啥？</p><hr><p>下面介绍差分方程，以及斐波拉契数列作为一个例子。<br>差分方程类似 $u_{k+1} = A u_k$。它的解是 $u_k = A^k u_0$。这个形式虽然很对，但是对我们计算没有意义。</p><p>如何解呢，我们可以将 $u_k$ 表示成 A 的特征向量的线性组合。如下式所示，其中 S 和之前一样是特征向量组成的矩阵。<br>$$<br>u_1 = c_1 u_0 + … + c_n x_n = S c<br>$$</p><p>这里是因为 A 可以对角化，所以一定能得到 n 个线性无关的向量，它们是张成 n 维空间的一组基。【Q】如果不可以对角化呢？</p><p>然后，乘上 A，得到<br>$$<br>A u_0 = c_1 \lambda_1 x_1 + … + c_n \lambda_n x_n<br>$$</p><p>那么根据特征值和特征向量的性质 $ Ax = \lambda x$，有<br>$$<br>u_k = A^k u_0 = c_1 \lambda_1^k x_1 + … + c_n \lambda_n^k x_n =<br>$$</p><p>结果等于 $\Lambda^k S c$。</p><hr><p>下面举了斐波拉契数列的例子。</p><p>【Q】这里教授插了句嘴，说对称矩阵特征值都是实数，不知道是怎么得到的。</p><p>在斐波拉契数列的计算中，求出两个特征值后，可以根据大的那个进行估计。这是因为较小的那个绝对值小于1，所以影响会越来越收敛。</p><h1 id="L23-微分方程"><a href="#L23-微分方程" class="headerlink" title="L23 微分方程"></a>L23 微分方程</h1><p>考虑微分方程<br>$$<br>\frac{du_1}{dt} = -u_1 + 2u_2 \\<br>\frac{du_2}{dt} = u_1 - 2u_2 \\<br>$$</p><p>可以写出 A 为 [-1 2; 1 -2]。显然这是一个奇异矩阵，奇异矩阵的行列式为0。而特征值的积等于行列式，所以一定有一个特征值为0。而根据迹可以求出另一个特征值为-3。</p><p>如果特征值是0，则会得到一个稳态，因为解是 $e^{0t} = 1$。</p><p>下面求特征向量。不要觉得 A 是奇异矩阵，那么0特征值对应的特征向量就可以随意取了。我们还是要按部就班来算，最后得到是 [2; 1]。同理，-3对应的特征向量是 [1; -1]。</p><p>通解是 $u(t) = c_1 e^{\lambda_1 t} x_1 + c_2 e^{\lambda_2 t} x_2$。</p><p>为什么可以这样将通解和矩阵的特征值联系起来呢？可以参考 randomwalk 的注解。这里 $x_1$ 和 $x_2$ 是对初值 $u_0$ 的分解。$\lambda$ 部分可以凑 e。</p><p>接着带入 $u_0$ 求出 $c_1$ 和 $c_2$，即 $S c = u_0$，这个上一讲我们也见过了。得到通解为</p><p>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    2 \\<br>    1 \\<br>\end{bmatrix}<br>+<br>\frac{1}{3} e^{-3t}<br>\begin{bmatrix}<br>    1 \\<br>    -1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><p>其中，前者为稳态状态，后者随时间衰减。最终，趋于<br>$$<br>\begin{equation}<br>\frac{1}{3}<br>\begin{bmatrix}<br>    2 \\<br>    1 \\<br>\end{bmatrix}<br>\end{equation}<br>$$</p><hr><p>什么时候微分方程得到稳态呢？</p><ol><li>负的特征值一定会得到稳态</li><li>如果是复数，那么还是看实部的正负号。虚部只是让它在单位圆上转圈。</li></ol><p>容易看出，如果 A 是收敛的，那么 -A 是发散的。因为 -A 的特征值都变号了。</p><p>而需要注意，如果特征值都为负数，那么迹是负数；反之则不成立。</p><hr><p>这里，教授讲到原微分方程组中有两个相互耦合的未知数 $u_1$、$u_2$。我们通过对角化来解耦。即 $u = S v$。即<br>$$<br>\frac{du}{dt} = A u \\<br>S \frac{dv}{dt} = A S v<br>$$<br>所以<br>$$<br>\frac{du}{dt} = S^{-1} A S v = \Lambda v<br>$$<br>则解为<br>$$<br>v(t) = e^{\Lambda t} v(0) \\<br>u(t) = S e^{\Lambda t} S^{-1} u(0)<br>$$</p><p>然后有一个奇怪的式子。可以发现 $e^{At}$ 就是原方程的解。<br>$$<br>S e^{\Lambda t} S^{-1} = e^{At}<br>$$</p><p>这里用矩阵作为 e 的指数很奇怪，需要往下介绍矩阵指数函数。</p><hr><p>定义指数函数的办法是将它分解为幂级数的形式，这样就可以当矩阵称为底数了。这边需要一些泰勒分解的基础，就不详细讲了。</p><p>同理 $(I - At)^{-1}$ 可以写成几何级数的形式，但是需要 $At$ 特征值的绝对值小于1，否则不收敛。这里 randomwalk 写错了吧。</p><p>然后教授通过幂级数定义了以矩阵为指数的指数函数。</p><p>需要注意的是，有一些矩阵，它的特征向量并不全部线性无关，<strong>所以它们无法对角化</strong>。<strong>但它们仍然可以三角化</strong>。</p><hr><p>下图是一个复平面。<br>图中阴影部分表示矩阵的的指数函数收敛于0的特征值范围。<br>图中圆圈中的部分表示矩阵的幂函数收敛于0的特征值范围。</p><p><img src="/img/linalg/converge.png"></p><hr><p>二阶微分方程。</p><h1 id="L24-马尔科夫矩阵和傅里叶级数"><a href="#L24-马尔科夫矩阵和傅里叶级数" class="headerlink" title="L24 马尔科夫矩阵和傅里叶级数"></a>L24 马尔科夫矩阵和傅里叶级数</h1><p>马尔科夫矩阵的两个性质：</p><ol><li>每个元素都大于等于0</li><li>所有列的加和都为1</li></ol><p>马尔科夫矩阵的幂还是马尔科夫矩阵。【Q】这个很奇怪，性质2是怎么保持的？</p><p>教授说，每列加和为1这个性质保证了马尔科夫矩阵有一个特征值为1。并且其他的所有特征值小于等于1。<br>下面证明这个性质。需要证明 $A-I$ 是奇异的。结合之前的课程知道，如果 $A-I$ 不是奇异的，那么 $(A-I)x=0$ 只有0这一个解，这样的话就不存在特征值1对应的特征向量了。证明奇异很简单，只需要观察到每一列的和都是0，这说明行向量线性相关。实际上我们把每一行相加，就会得到零。从线性组合来理解，即 [1, 1, 1] 位于 $A-I$ 的左零空间中。而特征向量 $x_1$ 位于 $A-I$ 的零空间中。</p><hr><p>$A$ 和 $A^T$ 的特征值相同。这是因为 $det(A^T -\lambda I) = det(A - \lambda I)$。</p><hr><p>用加州和麻省的人口迁徙作为例子。求出马尔科夫矩阵的特征值1对应的特征向量为 [2, 1]，这说明在稳态时，加州人口占 2/3，麻省占 1/3。</p><hr><p>上面是将向量分解为各个特征向量的线性组合。现在将向量 v 分解为若干个标准正交向量的线性组合。</p><p>如下所示，如果我们有一组正交基，那么每个基向量的系数 $x_i$ 很容易求得，只需要乘上 $q_i$ 即可。即 $x_i = q_i^T v$。<br>$$<br>v = x_1 q_1 + … + x_n q_n<br>$$</p><p>写成矩阵形式，即<br>$$<br>\begin{equation}<br>v =<br>\begin{bmatrix}<br>    q_1&amp;…&amp;q_n<br>\end{bmatrix}<br>\begin{bmatrix}<br>    x_1 \\<br>    \vdots \\<br>    x_n \\<br>\end{bmatrix}<br>\end{equation}<br>$$<br>也就是说 $v = Qx$。所以 $x = Q^{-1}v = Q^T v$。</p><hr><p>下面模仿正交向量，定义了两个正交的函数。</p><p>$$<br>f^T g = \int f(x) g(x) dx<br>$$</p><p>容易看出 $sin x$ 和 $cos x$ 是正交的。</p><p>$$<br>\int_0^{2 \pi} sinx cosx dx = 0<br>$$</p><h1 id="L25-复习"><a href="#L25-复习" class="headerlink" title="L25 复习"></a>L25 复习</h1><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><p>从公式可以推出。或者可以看出 A 是向量，用二维的简化形式算，这样可以直接做除法。</p><p>至于 P 的秩可以从向量是一维来看，所以秩是一维。</p><p>P 的列空间是一条直线。</p><p>P 的特征值很好算。因为 P 的行列式是0，所以有特征值是0。【Q】这里有一点不明白的是为什么0一定是重特征值呢？</p><p>不过后面既然知道0是重特征值就可以从迹算出最后一个特征值是1。</p><p>求P对应特征值为1的特征向量。这里考虑到 P 为投影矩阵的性质，在投影空间中的向量比如 a 就是对应特征值 1 的特征向<br>量。</p><p>如果有 $u_{k+1} = P u_k$，且有初值 $u_0$，求 $u_k$。这个就是考虑投影第二次之后，结果就不会变化了。</p><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><p>小问2是如何从投影的角度理解最小二乘？这个其实教授也讲过了，因为 b 不在 Ax 的列空间中，所以原方程是无解的。但是如果将 b 投影到 A 的列空间，就能得到 Ax=b 的近似解。</p><h2 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h2><p>使用施密特正交化来求正交基。</p><h2 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h2><p>小问1：一个四阶方阵 A 的特征值要满足什么条件，A 才是可逆的？我觉得这四个特征值都不为零，哪怕有重特征值都行。因为特征值的乘积是行列式，行列式不为零矩阵可逆。而重特征值只和特征向量的线性相关性有关系。</p><p>小问2：求 $A^{-1}$ 的特征值。【Q】我似乎没印象教授讲过逆矩阵的特征值是倒数。</p><p>小问3：求 A + I 的迹。</p><h2 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h2><p>已知三对角矩阵 $A_4$，令 $D_n = det(A_n)$。</p><h2 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h2><p>小问1：求投影到 $A_3$ 列空间的投影矩阵 P。什么叫投影到列空间？我想如果一个矩阵的列空间是一个平面，那么投影到它的列空间就是投影到一个平面上。</p><p>那么 $A_3$ 的列空间是什么呢？可以发现它的秩是2，所以列空间是一个平面，零空间是一条线，不要搞混。</p><p>小问2：求 $A_3$ 的特征值和特征向量</p><p>小问3：找到投影到 $A_4$ 列空间的投影矩阵 P<br>这里解法很巧妙，因为 $A_4$ 可逆，所以列空间是整个 $R^4$，所以 P 是 I。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%88%97%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A9%BA%E9%97%B4%E4%B8%8E%E5%88%97%E7%A9%BA%E9%97%B4</a></li><li><a href="https://zh.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/LU%E5%88%86%E8%A7%A3</a></li><li><a href="/asset/linalg-vector-eig.ggb">特征向量</a><br> 一个 Geogebra 的关于特征向量的演示。</li><li><a href="https://randomwalk.top/archives/569" target="_blank" rel="noopener">https://randomwalk.top/archives/569</a></li><li><a href="https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/" target="_blank" rel="noopener">https://ocw.mit.edu/resources/res-18-010-a-2020-vision-of-linear-algebra-spring-2020/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文从&lt;a href=&quot;https://www.bilibili.com/video/BV1Kt411y7jN?t=773.6&amp;p=16&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MIT的线代教程&lt;/a&gt;的角度重新学习线性代数。&lt;/p&gt;
&lt;p&gt;这是第二部分，从 L14 开始。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/linalg/mitbad.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
    <category term="公开课" scheme="http://www.calvinneo.com/tags/公开课/"/>
    
    <category term="代数" scheme="http://www.calvinneo.com/tags/代数/"/>
    
    <category term="线性代数" scheme="http://www.calvinneo.com/tags/线性代数/"/>
    
  </entry>
  
  <entry>
    <title>停机问题</title>
    <link href="http://www.calvinneo.com/2023/02/01/the-halt-problem/"/>
    <id>http://www.calvinneo.com/2023/02/01/the-halt-problem/</id>
    <published>2023-02-01T15:20:37.000Z</published>
    <updated>2023-02-12T13:25:42.511Z</updated>
    
    <content type="html"><![CDATA[<p>介绍停机问题相关证明。</p><a id="more"></a><h1 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a>停机问题</h1><p>令<code>H(P, I)</code>，返回对于程序<code>P</code>在输入<code>I</code>的情况下是否可停机，假如<code>P(I)</code>能停机，则<code>H</code>停机，否则<code>H</code>死循环。</p><p>不妨假设<code>U(X) = H(X, X)</code>。现在考虑<code>U(X)</code>的定义：</p><ol><li>如果<code>H(X, X)</code>停机，则<code>U(X)</code>死循环。</li><li>如果<code>H(X, X)</code>死循环，则<code>U(X)</code>停机。</li></ol><p>也就是<code>U(X)</code>是对<code>H(X, X)</code>取反。</p><p>下面考虑<code>U(U)</code>的结果：</p><ol><li>如果<code>H(U,U)</code>停机，那么<code>U(U)</code>应该输出死循环。</li><li>但是考虑<code>H(U,U)</code>的定义是<code>U</code>在输入为<code>U</code>的情况下是否停机，如果<code>H(U,U)</code>停机了，说明<code>U(U)</code>是可以停机的。</li></ol><p>于是上面两者矛盾。</p><p>其实这个证明的 intuition 很简单，比如女朋友说“我觉得你对我有意见”时：</p><ol><li>如果你说“你说的对”，那说明你对女朋友有意见，你就完蛋了。</li><li>如果你说“你说的不对”，那你居然反对女朋友，你完蛋了。</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">https://zh.wikipedia.org/zh-hans/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍停机问题相关证明。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数学" scheme="http://www.calvinneo.com/tags/数学/"/>
    
  </entry>
  
  <entry>
    <title>valgrind 用法</title>
    <link href="http://www.calvinneo.com/2023/01/26/valgrind-usage/"/>
    <id>http://www.calvinneo.com/2023/01/26/valgrind-usage/</id>
    <published>2023-01-26T02:04:26.000Z</published>
    <updated>2023-01-30T16:09:25.326Z</updated>
    
    <content type="html"><![CDATA[<p>介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。</p><a id="more"></a><h1 id="Memcheck"><a href="#Memcheck" class="headerlink" title="Memcheck"></a>Memcheck</h1><p>功能是：</p><ol><li>未允许的内存访问，例如 overrun 或者 underrun 堆内存，或者 oveerrun 栈顶，或者访问已经被释放的内存。</li><li>使用未定义的值，例如没有被初始化的值，或者从其他未初始化的值派生出来的值。</li><li>错误释放堆内存，类似于 double free，或者错误搭配 new/new[]/malloc。</li><li>在内存分配时，传入负数作为大小。</li><li>内存泄露。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --track-origins=yes</span><br></pre></td></tr></table></figure><h2 id="Illegal-read-Illegal-write-errors"><a href="#Illegal-read-Illegal-write-errors" class="headerlink" title="Illegal read / Illegal write errors"></a>Illegal read / Illegal write errors</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, *(<span class="keyword">int</span>*)(&amp;y + <span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==25724== Invalid read of size 4</span><br><span class="line">==25724==    at 0x400674: main</span><br><span class="line">==25724==  Address 0x0 is not stack&apos;d, malloc&apos;d or (recently) free&apos;d</span><br></pre></td></tr></table></figure><h2 id="Use-of-uninitialised-values"><a href="#Use-of-uninitialised-values" class="headerlink" title="Use of uninitialised values"></a>Use of uninitialised values</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">==38591== Use of uninitialised value of size 8</span><br><span class="line">==38591==    at 0x571A32B: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line"></span><br><span class="line">==38591== Conditional jump or move depends on uninitialised value(s)</span><br><span class="line">==38591==    at 0x571A335: _itoa_word (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x571E5B0: vfprintf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x57254E8: printf (in /usr/lib64/libc-2.17.so)</span><br><span class="line">==38591==    by 0x400682: main</span><br><span class="line">==38591==  Uninitialised value was created by a stack allocation</span><br><span class="line">==38591==    at 0x400667: main</span><br></pre></td></tr></table></figure><p>在程序操作未初始化的数据时，memcheck 会记录这些数据，但不会输出错误。只有当这个程序尝试使用这些未初始化的数据，并且会影响这个程序的外部可见性时，才会报错。在这个例子中，x 没有被初始化。memcheck 观察到这个值被传给 printf 和 vfprintf，但并没有输出错误。当 vfprintf 检查 x 的值，并且试图将其转换为 ASCII 字符串时，memcheck 才会输出错误。</p><p>可以通过设置 <code>--track-origins=yes</code> 来检查这些未初始化的数据。它会使得 memcheck 跑得更慢，但更容易发现问题。</p><h2 id="Use-of-uninitialised-or-unaddressable-values-in-system-calls"><a href="#Use-of-uninitialised-or-unaddressable-values-in-system-calls" class="headerlink" title="Use of uninitialised or unaddressable values in system calls"></a>Use of uninitialised or unaddressable values in system calls</h2><p>Memcheck 检查 system call 中所有的未初始化变量，包括：</p><ol><li>所有的直接变量。</li><li>或者，如果一个 system call 需要读取程序中的某一段缓存，memcheck 会检查整个缓存是否 addressable，并且其内容是否被初始化。</li><li>或者，如果这个 system call 需要写到用户提供的某一段缓存中，memcheck 需要检查这段缓存是否 addressable。</li></ol><h2 id="Illegal-frees"><a href="#Illegal-frees" class="headerlink" title="Illegal frees"></a>Illegal frees</h2><p>Memcheck 记录通过 malloc 和 new 分配的所有块，所以他可以知道某个 free 或者 delete 是否合法。在这里，出现了 double free。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">    <span class="built_in">free</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在出现非法读写的错误时，memcheck 会尝试解析被释放的地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==27728== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006E4: main</span><br><span class="line">==27728==  Address 0x5ab1c80 is 0 bytes inside a block of size 10 free&apos;d</span><br><span class="line">==27728==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==27728==    by 0x4006D8: main</span><br><span class="line">==27728==  Block was alloc&apos;d at</span><br><span class="line">==27728==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27728==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><p>注意，如果我们释放的是指向某个堆空间内部的指针，则也会出现类似的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，报错为 <code>is 1 bytes inside ... alloc&#39;d</code>。这样的报错说明不是 double free 的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==31870== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==31870==    at 0x4C2B06D: free (vg_replace_malloc.c:540)</span><br><span class="line">==31870==    by 0x4006DC: main</span><br><span class="line">==31870==  Address 0x5ab1c81 is 1 bytes inside a block of size 10 alloc&apos;d</span><br><span class="line">==31870==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==31870==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h3 id="C-1"><a href="#C-1" class="headerlink" title="C++"></a>C++</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">    <span class="keyword">delete</span> [] x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">==12625== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x400705: main</span><br><span class="line">==12625==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 free&apos;d</span><br><span class="line">==12625==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==12625==    by 0x4006F2: main</span><br><span class="line">==12625==  Block was alloc&apos;d at</span><br><span class="line">==12625==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==12625==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> [] (x + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==18227== Invalid free() / delete / delete[] / realloc()</span><br><span class="line">==18227==    at 0x4C2BB8F: operator delete[](void*) (vg_replace_malloc.c:651)</span><br><span class="line">==18227==    by 0x4006FC: main</span><br><span class="line">==18227==  Address 0x5ab1c84 is 4 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==18227==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==18227==    by 0x4006C8: main</span><br></pre></td></tr></table></figure><h2 id="When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function"><a href="#When-a-heap-block-is-freed-with-an-inappropriate-deallocation-function" class="headerlink" title="When a heap block is freed with an inappropriate deallocation function"></a>When a heap block is freed with an inappropriate deallocation function</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>]&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==29865== Mismatched free() / delete / delete []</span><br><span class="line">==29865==    at 0x4C2B6DF: operator delete(void*, unsigned long) (vg_replace_malloc.c:595)</span><br><span class="line">==29865==    by 0x400710: main</span><br><span class="line">==29865==  Address 0x5ab1c80 is 0 bytes inside a block of size 8 alloc&apos;d</span><br><span class="line">==29865==    at 0x4C2AC38: operator new[](unsigned long) (vg_replace_malloc.c:433)</span><br><span class="line">==29865==    by 0x4006E8: main</span><br></pre></td></tr></table></figure><p>C++ 中的 allocate 和 deallocate 操作包含：</p><ol><li>If allocated with malloc, calloc, realloc, valloc or memalign, you must deallocate with free.</li><li>If allocated with new, you must deallocate with delete.</li><li>If allocated with new[], you must deallocate with delete[].</li></ol><p>最要命的是在 Linux 中其实无所谓搞混这些 allocate 和 deallocate 操作。但是这样错误的搭配在其他平台比如 Solaris 上则会导致 crash。</p><h2 id="Overlapping-source-and-destination-blocks"><a href="#Overlapping-source-and-destination-blocks" class="headerlink" title="Overlapping source and destination blocks"></a>Overlapping source and destination blocks</h2><p>在 <code>memcpy</code>、<code>strcpy</code>、<code>strncpy</code>、<code>strcat</code>、<code>strncat</code> 中，指向 src 和 dst 的指针不能 overlap。</p><p>比较奇怪的是下面的代码并不会出现这样的错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * x = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(x + <span class="number">1</span>, x, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">void</span> * y = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memset</span>(y, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(y + <span class="number">1</span>, y, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是 gcc 会把 memcpy 优化掉，通过 <code>-fno-builtin-memcpy</code> 可以禁用这个性质。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">==15974== Source and destination overlap in memcpy(0x5ab1c81, 0x5ab1c80, 2)</span><br><span class="line">==15974==    at 0x4C2E81D: memcpy@@GLIBC_2.14 (vg_replace_strmem.c:1035)</span><br><span class="line">==15974==    by 0x40075E: main</span><br><span class="line">==15974==</span><br></pre></td></tr></table></figure><h2 id="Fishy-argument-values"><a href="#Fishy-argument-values" class="headerlink" title="Fishy argument values"></a>Fishy argument values</h2><p>所有的内存分配函数都需要指定需要分配的大小，而这个大小肯定是一个非负数，并且不会特别大。例如我们不太可能在64位机器上分配 <code>2**23</code> 个字节。这样的大小通常来自于一个人为的错误，而这样的值就被称为 fishy value。在 <code>malloc</code>、<code>calloc</code>、<code>realloc</code>、<code>memalign</code>、<code>new</code>、<code>new []</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * x = <span class="built_in">malloc</span>(<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">==27571== Argument &apos;size&apos; of function malloc has a fishy (possibly negative) value: -2</span><br><span class="line">==27571==    at 0x4C29F73: malloc (vg_replace_malloc.c:309)</span><br><span class="line">==27571==    by 0x40067A: main</span><br></pre></td></tr></table></figure><p>但同时注意到编译器也会触发警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">warning: argument 1 value ‘18446744073709551614’ exceeds maximum object size 9223372036854775807 [-Walloc-size-larger-than=]</span><br><span class="line">void * x = malloc(-2);</span><br></pre></td></tr></table></figure><h2 id="Memory-leak-detection"><a href="#Memory-leak-detection" class="headerlink" title="Memory leak detection"></a>Memory leak detection</h2><p>Memcheck 会记录所有分配的堆对象。<br>通过设置 <code>--leak-check</code>，对于在结束时尚未被释放的 block，Memcheck 会检查这个 block 是否可以从 root set 被访问。这里的 root set 包括：</p><ol><li>通用寄存器</li><li>在所有可访问内存，包括栈中的 initialised, aligned, pointer-sized data words</li></ol><p>有两种方法可以访问一个 block：</p><ol><li>start-pointer，也就是指向 block 开始位置的指针</li><li>interior-pointer，也就是指向 block 中间位置的指针</li></ol><p>一个 interior-pointer 是如何产生的呢？</p><ol><li>它可能开始是一个 start-pointer，但后来被程序故意或者非故意地向前移动<br> 比如如果程序使用 tagged pointer。因为对齐的缘故，指针最右边的几位通常是0，所以会被用来存储额外的信息。这些信息可能导致指针被前进。</li><li>可能是内存中的某个垃圾</li><li>【stdstring】可能是指向 std::string 内部持有的 char[] 的指针<br> 例如某些编译期会在 std::string 的头部存3个字段，分别表示数组的 length、capacity 和 refcount，在这3个字段之后再放置真正的 char[]。但是它返回的指针是指向 char[] 的。这个有点类似 Redis 的 SDS 的实现。</li><li>【length64】Some code might allocate a block of memory, and use the first 8 bytes to store (block size - 8) as a 64bit number. sqlite3MemMalloc does this.</li><li>【newarray】可能是执行某个 T[] 中的指针。这里的 T 是一个 C++ 对象，它具有自定义的析构函数，并使用 new[] 分配，delete[] 删除<br> 在这种情况下，一些编译器会在指针的前面放一个 magic cookie，用来存放长度。</li><li>【multipleinheritance】It might be a pointer to an inner part of a C++ object using multiple inheritance.</li></ol><p>You can optionally activate heuristics to use during the leak search to detect the interior pointers corresponding to the stdstring, length64, newarray and multipleinheritance cases. If the heuristic detects that an interior pointer corresponds to such a case, the block will be considered as reachable by the interior pointer. In other words, the interior pointer will be treated as if it were a start pointer.</p><p>下面一张图阐释了几种内存泄露的情况：</p><ol><li><code>DR</code>: Directly reachable</li><li><code>IR</code>: Indirectly reachable</li><li><code>DL</code>: Directly lost</li><li><code>IL</code>: Indirectly lost</li><li><code>(y)XY</code>: it’s XY if the interior-pointer is a real pointer</li><li><code>(n)XY</code>: it’s XY if the interior-pointer is not a real pointer</li><li><code>(_)XY</code>: it’s XY in either case</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(1)  RRR ------------&gt; BBB                    DR</span><br><span class="line">(2)  RRR ---&gt; AAA ---&gt; BBB    DR              IR</span><br><span class="line">(3)  RRR               BBB                    DL</span><br><span class="line">(4)  RRR      AAA ---&gt; BBB    DL              IL</span><br><span class="line">(5)  RRR ------?-----&gt; BBB                    (y)DR, (n)DL</span><br><span class="line">(6)  RRR ---&gt; AAA -?-&gt; BBB    DR              (y)IR, (n)DL</span><br><span class="line">(7)  RRR -?-&gt; AAA ---&gt; BBB    (y)DR, (n)DL    (y)IR, (n)IL</span><br><span class="line">(8)  RRR -?-&gt; AAA -?-&gt; BBB    (y)DR, (n)DL    (y,y)IR, (n,y)IL, (_,n)DL</span><br><span class="line">(9)  RRR      AAA -?-&gt; BBB    DL              (y)IL, (n)DL</span><br><span class="line"></span><br><span class="line">Pointer chain legend:</span><br><span class="line">- RRR: a root set node or DR block</span><br><span class="line">- AAA, BBB: heap blocks</span><br><span class="line">- ---&gt;: a start-pointer</span><br><span class="line">- -?-&gt;: an interior-pointer</span><br></pre></td></tr></table></figure><p>前四行比较简单。<br>第5行，如果这个 interior pointer 是一个 real pointer，则是 directly reachable。如果不是 real pointer 则是 directly lost。<br>第6行，相当于是2+5，没啥特殊的。<br>第7行，相当于是5+1，没啥特殊的。<br>第8行，可以分成三种情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     Pointer chain            AAA Leak Case   BBB Leak Case</span><br><span class="line">     -------------            -------------   -------------</span><br><span class="line">(8)  RRR -?-&gt; AAA -?n-&gt; BBB   (y)DR, (n)DL    DL</span><br><span class="line">(8)  RRR -?y-&gt; AAA -?y-&gt; BBB  DR              IR</span><br><span class="line">(8)  RRR -?n-&gt; AAA -?y-&gt; BBB  DL              IL</span><br></pre></td></tr></table></figure><p>但实际输出的时候，不会按照上面9个情况来输出，而是设计为如下的形式：</p><ol><li>Still reachable 1-2行</li><li>Definitely lost 3行</li><li>Indirectly lost 4/9行</li><li>Possibly lost 5-8行<br> 这种情况下可能存在1或者多个指针构成的链，但其中至少有一个指针是 interior pointer。这个可能只是内存中的随机值，并恰巧指向了某个块。</li></ol><h2 id="Details-of-Memcheck’s-checking-machinery"><a href="#Details-of-Memcheck’s-checking-machinery" class="headerlink" title="Details of Memcheck’s checking machinery"></a>Details of Memcheck’s checking machinery</h2><p>这一节介绍 Memcheck 的原理。</p><h3 id="Valid-value-V-bits"><a href="#Valid-value-V-bits" class="headerlink" title="Valid-value (V) bits"></a>Valid-value (V) bits</h3><p>It is simplest to think of Memcheck implementing a synthetic CPU which is identical to a real CPU, except for one crucial detail. Every bit (literally) of data processed, stored and handled by the real CPU has, in the synthetic CPU, an associated “valid-value” bit, which says whether or not the accompanying bit has a legitimate value. In the discussions which follow, this bit is referred to as the V (valid-value) bit.</p><p>Each byte in the system therefore has a 8 V bits which follow it wherever it goes. For example, when the CPU loads a word-size item (4 bytes) from memory, it also loads the corresponding 32 V bits from a bitmap which stores the V bits for the process’ entire address space. If the CPU should later write the whole or some part of that value to memory at a different address, the relevant V bits will be stored back in the V-bit bitmap.</p><p>In short, each bit in the system has (conceptually) an associated V bit, which follows it around everywhere, even inside the CPU. Yes, all the CPU’s registers (integer, floating point, vector and condition registers) have their own V bit vectors. For this to work, Memcheck uses a great deal of compression to represent the V bits compactly.</p><p>Copying values around does not cause Memcheck to check for, or report on, errors. However, when a value is used in a way which might conceivably affect your program’s externally-visible behaviour, the associated V bits are immediately checked. If any of these indicate that the value is undefined (even partially), an error is reported.</p><h3 id="Valid-address-A-bits"><a href="#Valid-address-A-bits" class="headerlink" title="Valid-address (A) bits"></a>Valid-address (A) bits</h3><h3 id="结合-VV-和-VA"><a href="#结合-VV-和-VA" class="headerlink" title="结合 VV 和 VA"></a>结合 VV 和 VA</h3><h2 id="Debugging-MPI-Parallel-Programs-with-Valgrind"><a href="#Debugging-MPI-Parallel-Programs-with-Valgrind" class="headerlink" title="Debugging MPI Parallel Programs with Valgrind"></a>Debugging MPI Parallel Programs with Valgrind</h2><h1 id="Callgrind"><a href="#Callgrind" class="headerlink" title="Callgrind"></a>Callgrind</h1><p>检查程序中函数调用过程中出现的问题。</p><h1 id="Cachegrind"><a href="#Cachegrind" class="headerlink" title="Cachegrind"></a>Cachegrind</h1><p>检查程序中缓存使用出现的问题。</p><h1 id="Helgrind"><a href="#Helgrind" class="headerlink" title="Helgrind"></a>Helgrind</h1><p>检查多线程程序中出现的竞争问题。</p><h1 id="Massif"><a href="#Massif" class="headerlink" title="Massif"></a>Massif</h1><p>检查程序中堆栈使用中出现的问题。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs" target="_blank" rel="noopener">https://valgrind.org/docs/manual/mc-manual.html#mc-manual.errormsgs</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍 valgrind 的 Memcheck、Callgrind、Helgrind、Massif 等工具的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="valgrind" scheme="http://www.calvinneo.com/tags/valgrind/"/>
    
    <category term="工具" scheme="http://www.calvinneo.com/tags/工具/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构和高并发相关场景</title>
    <link href="http://www.calvinneo.com/2023/01/12/high-concurrency/"/>
    <id>http://www.calvinneo.com/2023/01/12/high-concurrency/</id>
    <published>2023-01-12T15:20:37.000Z</published>
    <updated>2024-01-18T14:41:09.507Z</updated>
    
    <content type="html"><![CDATA[<p>介绍分布式架构和高并发相关场景下的设计和问题定位的相关经验，持续更新。</p><p>在分布式架构下，我们不得不摆脱一些下层硬件为提供的屏障，而要去解决真实环境带来的难题。<br>如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。</p><a id="more"></a><h1 id="一些传送门"><a href="#一些传送门" class="headerlink" title="一些传送门"></a>一些传送门</h1><ol><li>CPU 相关 <a href="/2023/12/17/patmc/">Performance analysis and tuning on modern CPUs</a></li></ol><h1 id="计算机工程工具"><a href="#计算机工程工具" class="headerlink" title="计算机工程工具"></a>计算机工程工具</h1><p>这些工具主要是：</p><ol><li>O11y</li><li>Metrics</li><li>Perf 相关</li></ol><h2 id="Trace-任意函数的执行时间"><a href="#Trace-任意函数的执行时间" class="headerlink" title="Trace 任意函数的执行时间"></a>Trace 任意函数的执行时间</h2><p>该方案整理自某同事的 idea。</p><p>考虑下面的场景，我们需要查看某动态链接库 <code>/path/to/libtiflash_proxy.so</code> 中 <code>handle_pending_applies</code> 函数每次调用的耗时。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">perf probe --del <span class="string">'probe_libtiflash_proxy:*'</span></span><br><span class="line">BIN=/path/to/libtiflash_proxy.so</span><br><span class="line">TOKEN=handle_pending_applies</span><br><span class="line">ITER=0</span><br><span class="line">objdump <span class="variable">$BIN</span> --syms | grep <span class="variable">$TOKEN</span> | awk <span class="string">'&#123;print $6&#125;'</span> | <span class="keyword">while</span> <span class="built_in">read</span> -r tok ; <span class="keyword">do</span></span><br><span class="line">    ITER=$(expr <span class="variable">$ITER</span> + 1)</span><br><span class="line">    NAME=<span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$NAME</span>, <span class="variable">$TOKEN</span>, <span class="variable">$ITER</span>, <span class="variable">$TOKEN</span>\_<span class="variable">$ITER</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span></span><br><span class="line">    perf probe -x <span class="variable">$BIN</span> --no-demangle <span class="variable">$NAME</span>=<span class="variable">$tok</span>%<span class="built_in">return</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">perf record -e probe_libtiflash_proxy:\* -aR sleep 10</span><br><span class="line">perf script -s perf-script.py</span><br></pre></td></tr></table></figure><p><a href="/asset/highconcurrency/perf-script.py">附上 perf-script.py</a></p><h2 id="分析某段时刻的调用栈"><a href="#分析某段时刻的调用栈" class="headerlink" title="分析某段时刻的调用栈"></a>分析某段时刻的调用栈</h2><h2 id="生成火焰图"><a href="#生成火焰图" class="headerlink" title="生成火焰图"></a>生成火焰图</h2><h2 id="记录线程名"><a href="#记录线程名" class="headerlink" title="记录线程名"></a>记录线程名</h2><p>有一些方法设置线程名，包括：</p><ol><li>pthread_setname_np</li><li>prctl</li></ol><p>出于下列原因，建议线程名具有唯一性：</p><ol><li>诸如一些线程池的实际工作内容不一样，最好以数字区分。</li><li>有一些库会扩展 std::mutex，记录上锁的线程名，用来避免重复加锁。当然这个并不好，最好用线程 id。</li></ol><p>在一些很老的 c 库中，没有提供 pthread_setname_np 函数。诸如 CK 之类的会写一个 dummy 的函数来替换，这可能导致<a href="https://github.com/pingcap/tiflash/issues/6616" target="_blank" rel="noopener">一些情况下</a>不能设置成功线程名。</p><h1 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h1><h2 id="统计学方法"><a href="#统计学方法" class="headerlink" title="统计学方法"></a>统计学方法</h2><p>介绍一个很有趣的<a href="/2023/07/14/tiflash-pt-1"> case，它是一个压测程序中出现的问题</a>。</p><h1 id="Intuition"><a href="#Intuition" class="headerlink" title="Intuition"></a>Intuition</h1><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>有一些典型的特征：</p><ol><li>时间偏移<br> 比如某些周期性的时间，如日志等，突然失去周期性，而在一瞬间打印了很多。</li></ol><p>注意，阻塞的原因有很多：</p><ol><li>不能正确解耦逻辑和 IO</li><li>队列积压，工作线程数偏少，导致对于每个任务而言，自己的等待时间会越来越大，似乎自己正在被阻塞</li></ol><h3 id="解耦-IO"><a href="#解耦-IO" class="headerlink" title="解耦 IO"></a>解耦 IO</h3><p>如下所示，一瞬间打印了很多发送消息的日志，实际上这是由于没有正确解耦消息发送逻辑和 IO 逻辑。导致 IO 阻塞了同一个线程，从而积攒了大量的消息。特别地，如果因此产生了消息延迟，可能会雪崩。<br>在这个场景下，虽然我们使用了 ClickHouse 的线程池来处理异步的 IO，但由于线程池的队列大小过小，并且也没有指定等待超时时间，所以我们以为的异步实际上变成了同步。<br><img src="/img/high-concurrency/many-simu-logs.png"></p><p>在解耦 IO 时，常常会将一些消息或者写入缓存到 Queue 或者 WriteBatch 以攒批 IO。对于这样的情况，在判断时首先需要检查对象是否已经被真的发送或者写入，因为这会导致后续完全不同的调查方向。</p><h2 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h2><p>可能发生在基于消息传输进行同步的系统中。不妨以 Raft 为例，如果因为一些阻塞的原因，一些发给 Follower 的 Append 消息没有被及时处理，很可能该 Follower 就会认为 Leader 挂了，从而发起选举。而选举会产生更多的消息，从而导致消息进一步积压，甚至会扩散到其他正常的 Region 中。</p><h2 id="概率"><a href="#概率" class="headerlink" title="概率"></a>概率</h2><p>在某个接口被高频调用时，应当认为其中小概率事件也是可能被发生的。</p><h2 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h2><p>当一个程序异常退出，但看不到异常日志时，考虑：</p><ol><li>日志服务是否未初始化，或者该段异常日志被直接打印到标准错误</li><li>该程序是否由于异常信号/OOM退出<br> 可以从 return code 或者 dmesg 或者 coredump 或者 stderr 等信息来看。</li><li>该程序是否主动退出<br> 在一些程序中，会针对一些异常情况直接调用 exit 退出程序。此时可以用 gdb 去 hook <code>_exit</code> 函数来查看退出时的堆栈。</li></ol><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><p>一些程序会基于时间片的算法来进行调度。一些实现会从任务队列中取出所有等待的任务，执行这些任务，再检查是否超出时间片。如果执行这些任务本身的时间就比较长，甚至可能占用多个时间片，这就会导致调度算法接近于失效。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h2 id="落盘"><a href="#落盘" class="headerlink" title="落盘"></a>落盘</h2><p>一般写入的阶段可以分为：</p><ol><li>Write Batch</li><li>Memtable<br> 在写入到 Memtable 之后就是可读的了。<br> 在 Memtable 后，有的系统可能会异步 flush。所以需要辨别此时数据是否已经被写入。因为很多时候不是持久化越快越正确，因为很多东西必须要同时确定已经被持久化。</li><li>Disk</li></ol><p>因为磁盘往往比内存操作更慢，所以存储系统通常会考虑内存路径和磁盘路径。通常需要考虑下列问题：</p><ol><li>持久化是否是原子的<br> 如果涉及两个非原子的写入，则需要处理在写入间出现宕机的问题。</li><li>什么时候数据可以被读了<br> 如果一个数据没有被持久化，那么它不能被读。否则一个客户端可能第一次读到该数据，而后服务器宕机重启之后出现 data loss 导致第二次读不到。这是不太好的一致性。</li></ol><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="使用什么锁？"><a href="#使用什么锁？" class="headerlink" title="使用什么锁？"></a>使用什么锁？</h3><p>std::recursive_mutex 是否应该被使用呢？<a href="/2017/12/28/Concurrency-Programming-Compare/">我觉得大部分在准备使用递归锁的时候</a>，需要首先考虑架构问题。</p><h3 id="死锁怎么办？"><a href="#死锁怎么办？" class="headerlink" title="死锁怎么办？"></a>死锁怎么办？</h3><p>通过 gdb 可以找到对应 mutex 结构中的 owner，对应的值表示 LWP 的编号。<br>对于一些程序，可能 debug info 被优化掉了，<a href="https://stackoverflow.com/questions/76489792/how-to-identify-which-thread-holds-the-stdrecursive-mutex-by-gdb" target="_blank" rel="noopener">此时可以选择</a>：</p><ol><li>根据提示的行号，拷贝一份对应的源码到指定位置</li><li>自己编译一个同样 layout 的对象，然后 load 进去解析</li></ol><h2 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h2><h3 id="避免依赖-coredump"><a href="#避免依赖-coredump" class="headerlink" title="避免依赖 coredump"></a>避免依赖 coredump</h3><p>首先，如果 coredump 很大，它常常会被截断，即使我们设置了 <code>ulimit -c unlimited</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BFD: Warning: core.36322 is truncated: expected core file size &gt;= 14835945472, found: 1073742080</span><br></pre></td></tr></table></figure><p>其次，在发生诸如 segfault 时，我们也未必需要 coredump 才能拿到堆栈。例如<a href="https://github.com/pingcap/tiflash/blob/865ba65dcc5fa5b5847466b06993bc4f8387bcdd/libs/libdaemon/src/BaseDaemon.cpp#LL371C4-L371C4" target="_blank" rel="noopener">可以启动一个专门</a>的 sigHandler 线程，并配合 libunwind 来在其他线程出现 segfault 的时候打印出足够的信息，甚至包括堆栈。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池的设计考虑几点：</p><ol><li>支持取一小部分线程组建新的线程池。</li><li>支持固定线程和临时线程，临时线程可以在空闲一段时间后自动销毁。</li></ol><h2 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h2><h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>C++ 中的空指针影响会比较大。比如对 <code>nullptr</code> 调用 <code>operator-&gt;()</code> 就会得到一个 segfault，对应的 addr 可能漂到不知道哪里去了，很难定位问题。</p><p>特别地，C++ 还不太容易实现 Rust 中的 NotNull 指针，从而减少心智负担。这是因为 C++ 本身的移动语义会将移动后的对象的指针设置为空，而这就导致 NotNull 无法移动。而 unique_ptr 又是天生只支持移动的，这就导致了 NotNull 和 unique_ptr 无法兼容。Rust 能支持是因为编译期保证了使用移动后的对象一定是不能通过编译的。</p><p>一般有下面的一些做法：</p><ol><li>使用 ASAN 进行检测。但这需要代码本身的 coverage 足够高，实际上要求有一个比较好的写单测或者做集成测试的习惯</li><li>使用线程池维护对象，避免使用任何形式的 shared_ptr、unique_ptr 以及裸指针</li><li>使用一些 not_null ptr 的实现，这些实现能够 workaround 掉 unique_ptr 的相关问题<br> <a href="https://github.com/bitwizeshift/not_null/blob/master/include/not_null.hpp" target="_blank" rel="noopener">https://github.com/bitwizeshift/not_null/blob/master/include/not_null.hpp</a> 这样的库可以选择使用 check_not_null 在创建的时候执行运行期检查，也可以使用 assume_not_null 执行有限的编译期检查（但如果值在编译期无法确定，则编译期检查无效）。<br> 这个库也支持移动语义 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Should never be null, but not yet refactored to be 'not_null'</span></span><br><span class="line">auto old_api(std::unique_ptr&lt;Widget&gt; p) -&gt; void;</span><br><span class="line"></span><br><span class="line">auto new_api(cpp::not_null&lt;std::unique_ptr&lt;Widget&gt;&gt; p) -&gt; void</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Extract the move-only unique_ptr, and push along to 'old_api'</span></span><br><span class="line">  old_api(<span class="built_in">std</span>::move(p).as_nullable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>特别地，我不觉得 <code>if likely(!ptr) throw_or_panic();</code> 这样的写法有太大问题，因为现代 CPU 的 speculation 机制让这个 if 的开销变得很低。但毫无疑问，每次都要判断，无疑加重了开发人员的心智负担，每一个函数的开头需要防御性编程写一堆 check。而实际上至少从某一层开始，工具函数就可以要求传入的 ptr 是 not null 了。特别地，对于一个全新 init 的工程，可以始终通过 <code>std::optional&lt;not_null&gt;</code> 来代替 <code>std::shared_ptr</code>。</p><h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>并不是野指针才算内存泄露。如果有一些结构存在于某些队列或者哈希表中，但并不是所有路径都会最终回收掉该结构，那么同样可以认为存在内存泄露。</p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="重构测试"><a href="#重构测试" class="headerlink" title="重构测试"></a>重构测试</h2><p>对正确性要求很高的子系统进行重构，如何设计测试？可以从几个层面来讨论：</p><ol><li>Unit test<br> 单测用来保护逻辑。<br> 首先对原来的子系统对外提供的每个接口进行设计单测，以获得其行为。这个单测是简单的，我们只需要设计不同的输入，并观测其返回值和副作用即可。<br> 然后基于生成的单测来校验新的子系统。</li><li>Random test<br> 随机构造操作序列，并设定多种配置集合，运行测试。<br> 这个测试既对子系统运行，也对使用不同子系统的上层系统进行测试。</li><li>Chaos test<br> 随机注入各种错误。</li><li>对拍<br> 基于 Chaos test 中的宕机重启，使得程序在新老子系统中切换。</li></ol><h2 id="减少耦合"><a href="#减少耦合" class="headerlink" title="减少耦合"></a>减少耦合</h2><p>需要避免一个测试同时覆盖多个功能。例如有一个 Region Serde 的测试中允许写入 flexible 的扩展字段，并支持升降级。这个功能因为涉及到升降级和持久化，所以需要测试来保护。<br>而这些 flexible 的字段可能属于某个 feature，这个 feature 本身也需要测试。<br>因此，最好的做法是 mock 一些 flexible 的字段，这些字段只用来测试。</p><h2 id="注入的方式"><a href="#注入的方式" class="headerlink" title="注入的方式"></a>注入的方式</h2><ol><li><code>#ifdef TEST</code> 宏</li><li>failpoint</li><li>trait Mocker</li><li>lambda<br> 让被注入的函数接受一个 lambda 作为参数。正常逻辑中，该 lambda 为 <code>[](){}</code>，而测试逻辑中，该 lambda 为 mock 逻辑。<br> 在 release 编译时，该 lambda 会被优化掉。</li></ol><h1 id="架构漫谈"><a href="#架构漫谈" class="headerlink" title="架构漫谈"></a>架构漫谈</h1><h2 id="无状态的架构"><a href="#无状态的架构" class="headerlink" title="无状态的架构"></a>无状态的架构</h2><p>首先引入一个最原始的系统。它通常是单服务器单库的架构。但随着用户请求越来越大，需要逐步进行升级。</p><p>首先可以对服务器进行集群化和负载均衡。这个并不难，因为用户的请求从接入层打过来，通常已经经过了一系列路由、鉴权、限流、降级、LB 等过程。在业务层通常就是去处理每一个请求，其中涉及到与各种中间件和数据库交互。对业务层而言，这些只是 API 的调用。</p><p>但是业务虽然扩容了，所有的请求还是打到同一个数据库上，数据库成为瓶颈。首先我们可以在业务侧做些聚合啥的，但终归这是一个暂时的缓解。</p><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层解决。我们可以在服务器和数据库之间加上一层缓存。缓存的加入是为了减少数据库的压力。</p><p>显而易见的，如果双写缓存和数据库，那么就一定产生一致性问题：</p><ol><li>比如先写库，再删缓存(Cache Aside Pattern)，那么在这一段时间中缓存就是脏的</li><li>又比如我们先删缓存再写库，那么只要这个操作不是原子的，其实大多数情况下都不是原子地，那么就可能中间有个读线程在读库的时候再重新写一遍旧数据到缓存中。</li></ol><p>有一些方案能够尽可能处理缓存和数据库一致的问题。可以见<a href="/2017/09/20/distributed-system-consistency-and-consensus/">分布式一致性和分布式共识协议</a>。</p><p>随着请求进一步增多，数据库压力的进一步增大，这个时候就需要对数据库本身进行扩展。例如：</p><ol><li>主从架构<br> 通常用来实现容错+读写分离带来的高可用。<br> 数据库的主从方案可以通过 MySQL Proxy 等机制实现，阿里巴巴有一个 Canal 的数据库中间件，能够实现数据库的增量订阅和消费业务。</li><li>分库分表</li></ol><h1 id="一些元设计"><a href="#一些元设计" class="headerlink" title="一些元设计"></a>一些元设计</h1><p>我们往往在异步线程中预处理一些对象，并最后将它们 link 到主干上，或者从主干上 unlink 对象，并最后 gc 掉。如果这中间发生重启，那么这些对象就会游离在存储中。如何区分被 unlink 但尚未被回收的对象，和刚被创建但还没有被 link 的对象呢？这里的通用思路是在重启后对比主干和存储中的对象，所有不出现在主干中的对象就需要被删掉。然后依赖重放来解决第一种情况。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/264825380" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/264825380</a><br> PebbleDB 的测试方案</li><li><a href="https://www.cnblogs.com/chanshuyi/p/mycat_enlighten.html" target="_blank" rel="noopener">https://www.cnblogs.com/chanshuyi/p/mycat_enlighten.html</a><br> 描述了一个业务系统的架构升级之路</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍分布式架构和高并发相关场景下的设计和问题定位的相关经验，持续更新。&lt;/p&gt;
&lt;p&gt;在分布式架构下，我们不得不摆脱一些下层硬件为提供的屏障，而要去解决真实环境带来的难题。&lt;br&gt;如果将普通的程序比作是经典力学，那么研究高并发系统有点类似于研究热力学。当成千上万个过程彼此交互、竞争、等待，在有限的集群资源中将会产生不一样的场景。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 const 的用法</title>
    <link href="http://www.calvinneo.com/2022/11/20/C++-const/"/>
    <id>http://www.calvinneo.com/2022/11/20/C++-const/</id>
    <published>2022-11-19T16:29:16.000Z</published>
    <updated>2023-05-21T04:47:54.766Z</updated>
    
    <content type="html"><![CDATA[<p>把<a href="/2016/12/22/C++-meta-programming/">文章</a>中的相关部分独立出来。</p><a id="more"></a><h1 id="const不是编译期常量"><a href="#const不是编译期常量" class="headerlink" title="const不是编译期常量"></a>const不是编译期常量</h1><p>在<a href="/2016/12/30/C++%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F/">C++初始化方式</a>中已经提到常量<code>const</code>是不能在构造函数体中初始化的，但可以在初始化列表中可以进行初始化，对于常量数组或者标准库的<code>std::vector</code>等容器，现在可以使用花括号<code>{}</code>进行初始化。<br>需要额外说明的是<code>const</code>甚至不能作为模板参数等编译期常量使用。例如在MSVC2015中，下面的代码是无法通过编译的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    C(<span class="keyword">int</span> _x) :x(_x) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> C <span class="title">c</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> a[c.x];</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因是在<code>C.x</code>虽然是常量，但是要到运行期才能知道，这里应该使用的是<code>static const</code>或者<code>constexpr</code>，<code>const</code>修饰符实际上的意义更接近于<code>readonly</code>。如果说<code>const</code>能够“节省空间”，那是由于其不可变，所以发生拷贝时，<a href="http://www.prglab.com/bbs/viewthread.php?tid=23" target="_blank" rel="noopener">const对象实际上并不发生复制</a>，但只<code>const</code>修饰的类成员仍然是占空间的。</p><h1 id="实现member-function的const版本"><a href="#实现member-function的const版本" class="headerlink" title="实现member function的const版本"></a>实现member function的const版本</h1><p>有些member function的const版本相对于非const版本只是加上了const的限制，重复实现一遍会造成代码的浪费。根据<a href="http://stackoverflow.com/questions/856542/elegant-solution-to-duplicate-const-and-non-const-getters" target="_blank" rel="noopener">stackoverflow</a>，可以直接<code>const_cast</code> <code>this</code>指针即可。对一个非const加const限制是安全的，但反过来不一定。如果说const函数需要修改非mutable成员，那么可以实现一个static非成员模板函数，将this传进去</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;把&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;文章&lt;/a&gt;中的相关部分独立出来。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>解决 bindgen 的一个奇怪问题</title>
    <link href="http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/"/>
    <id>http://www.calvinneo.com/2022/10/31/rust-bindgen-problem/</id>
    <published>2022-10-31T12:20:33.000Z</published>
    <updated>2023-05-21T07:15:11.237Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。</p><a id="more"></a><h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><ol><li>没有问题的版本(旧版本)<br> <a href="https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a" target="_blank" rel="noopener">https://github.com/pingcap/tidb-engine-ext/commit/01454150386e05c978a8970613b2426354d0fd0a</a></li><li>有问题的版本(新版本)<br> <a href="https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen" target="_blank" rel="noopener">https://github.com/CalvinNeo/tidb-engine-ext/tree/demo/article-for-bindgen</a></li></ol><p>具体报错如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Finished dev [unoptimized] target(s) in 2.51s</span><br><span class="line">     Running `target/debug/gen_proxy_ffi`</span><br><span class="line">dyld: Library not loaded: @rpath/libclang.dylib</span><br><span class="line">  Referenced from: /Users/calvin/tidb-engine-ext/target/debug/gen_proxy_ffi</span><br><span class="line">  Reason: image not found</span><br><span class="line">zsh: abort      cargo run --package gen-proxy-ffi --bin gen_proxy_ffi</span><br></pre></td></tr></table></figure><p>首先，这两个版本之间的区别是啥呢？主要两点：</p><ol><li>将 workspace 改成 virtual<br> 也就是有 workspace 段，但是没有 package 段。</li><li>将 cargo dependency 从 path 改成 git</li></ol><p>它们都不涉及 gen-proxy-ffi 这个 crate。</p><h1 id="调查"><a href="#调查" class="headerlink" title="调查"></a>调查</h1><h2 id="深入了解情况"><a href="#深入了解情况" class="headerlink" title="深入了解情况"></a>深入了解情况</h2><p>“dyld: Library not loaded” 这个错误表示 gen-proxy-ffi 依赖 libclang 这个库，也就是所谓的 clang-sys，并且要在运行期加载，但我们并没有在运行期找到这个库。我们可以通过类似 ldd 的指令来确认这一点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">otool -L target/debug/gen_proxy_ffi</span><br><span class="line">target/debug/gen_proxy_ffi:</span><br><span class="line"> @rpath/libclang.dylib (compatibility version 1.0.0, current version 1205.0.22)</span><br><span class="line"> /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1292.100.5)</span><br><span class="line"> /usr/lib/libiconv.2.dylib (compatibility version 7.0.0, current version 7.0.0)</span><br><span class="line"> /usr/lib/libresolv.9.dylib (compatibility version 1.0.0, current version 1.0.0)</span><br></pre></td></tr></table></figure><p>从 <a href="https://github.com/rust-lang/rust-bindgen/tree/v0.57.0" target="_blank" rel="noopener">https://github.com/rust-lang/rust-bindgen/tree/v0.57.0</a> 可以看到，这个项目确实依赖 clang-sys</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">clang-sys</span> = &#123; version = <span class="string">"1"</span>, features = [<span class="string">"clang_6_0"</span>] &#125;</span><br></pre></td></tr></table></figure><p>所以我们的问题是，为啥旧版本能跑呢？</p><h2 id="通过-unit-graph-分析"><a href="#通过-unit-graph-分析" class="headerlink" title="通过 unit-graph 分析"></a>通过 unit-graph 分析</h2><p>可以通过<code>--unit-graph</code>命令来检查编译时实际的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build -Z unstable-options --unit-graph --package gen-proxy-ffi --bin gen_proxy_ffi</span><br></pre></td></tr></table></figure><p>通过下面的代码可以找到所有的 bindgen。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bindgens = [v <span class="keyword">for</span> v <span class="keyword">in</span> j[<span class="string">'units'</span>] <span class="keyword">if</span> v[<span class="string">'pkg_id'</span>].startswith(<span class="string">"bindgen"</span>)]</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> bindgens:</span><br><span class="line">    print(x)</span><br><span class="line">    print(<span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>对于旧版本，我们发现有两个 bindgen 的项目。其中一个 bindgen 依赖 index 为 4 和 11 的两个项目，而另一个则不依赖任何项目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;u&apos;profile&apos;: &#123;u&apos;name&apos;: u&apos;dev&apos;, u&apos;codegen_units&apos;: None, u&apos;debug_assertions&apos;: False, u&apos;debuginfo&apos;: 0, u&apos;codegen_backend&apos;: None, u&apos;rpath&apos;: False, u&apos;overflow_checks&apos;: False, u&apos;incremental&apos;: False, u&apos;strip&apos;: u&apos;none&apos;, u&apos;opt_level&apos;: u&apos;0&apos;, u&apos;split_debuginfo&apos;: None, u&apos;lto&apos;: u&apos;false&apos;, u&apos;panic&apos;: u&apos;unwind&apos;&#125;, u&apos;features&apos;: [], u&apos;platform&apos;: None, u&apos;dependencies&apos;: [&#123;u&apos;index&apos;: 4, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;build_script_build&apos;&#125;, &#123;u&apos;index&apos;: 11, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;build_script_build&apos;&#125;], u&apos;mode&apos;: u&apos;run-custom-build&apos;, u&apos;pkg_id&apos;: u&apos;bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)&apos;, u&apos;target&apos;: &#123;u&apos;kind&apos;: [u&apos;custom-build&apos;], u&apos;name&apos;: u&apos;build-script-build&apos;, u&apos;doc&apos;: False, u&apos;src_path&apos;: u&apos;/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs&apos;, u&apos;edition&apos;: u&apos;2018&apos;, u&apos;doctest&apos;: False, u&apos;test&apos;: False, u&apos;crate_types&apos;: [u&apos;bin&apos;]&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;u&apos;profile&apos;: &#123;u&apos;name&apos;: u&apos;dev&apos;, u&apos;codegen_units&apos;: None, u&apos;debug_assertions&apos;: True, u&apos;debuginfo&apos;: 0, u&apos;codegen_backend&apos;: None, u&apos;rpath&apos;: False, u&apos;overflow_checks&apos;: False, u&apos;incremental&apos;: False, u&apos;strip&apos;: u&apos;none&apos;, u&apos;opt_level&apos;: u&apos;0&apos;, u&apos;split_debuginfo&apos;: None, u&apos;lto&apos;: u&apos;false&apos;, u&apos;panic&apos;: u&apos;unwind&apos;&#125;, u&apos;features&apos;: [], u&apos;platform&apos;: None, u&apos;dependencies&apos;: [], u&apos;mode&apos;: u&apos;build&apos;, u&apos;pkg_id&apos;: u&apos;bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)&apos;, u&apos;target&apos;: &#123;u&apos;kind&apos;: [u&apos;custom-build&apos;], u&apos;name&apos;: u&apos;build-script-build&apos;, u&apos;doc&apos;: False, u&apos;src_path&apos;: u&apos;/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs&apos;, u&apos;edition&apos;: u&apos;2018&apos;, u&apos;doctest&apos;: False, u&apos;test&apos;: False, u&apos;crate_types&apos;: [u&apos;bin&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><p>这里很多 extern_crate_name 都是 build_script_build，具体看不出究竟是什么。但可以通过 index 直接对应到 “units” 这个数组的下标。检查发现，其中包含了 clang-sys。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;u&apos;profile&apos;: &#123;u&apos;name&apos;: u&apos;dev&apos;, u&apos;codegen_units&apos;: None, u&apos;debug_assertions&apos;: True, u&apos;debuginfo&apos;: 0, u&apos;codegen_backend&apos;: None, u&apos;rpath&apos;: False, u&apos;overflow_checks&apos;: False, u&apos;incremental&apos;: False, u&apos;strip&apos;: u&apos;none&apos;, u&apos;opt_level&apos;: u&apos;0&apos;, u&apos;split_debuginfo&apos;: None, u&apos;lto&apos;: u&apos;false&apos;, u&apos;panic&apos;: u&apos;unwind&apos;&#125;, u&apos;features&apos;: [], u&apos;platform&apos;: None, u&apos;dependencies&apos;: [], u&apos;mode&apos;: u&apos;build&apos;, u&apos;pkg_id&apos;: u&apos;bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)&apos;, u&apos;target&apos;: &#123;u&apos;kind&apos;: [u&apos;custom-build&apos;], u&apos;name&apos;: u&apos;build-script-build&apos;, u&apos;doc&apos;: False, u&apos;src_path&apos;: u&apos;/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/build.rs&apos;, u&apos;edition&apos;: u&apos;2018&apos;, u&apos;doctest&apos;: False, u&apos;test&apos;: False, u&apos;crate_types&apos;: [u&apos;bin&apos;]&#125;&#125;</span><br><span class="line">&#123;u&apos;profile&apos;: &#123;u&apos;name&apos;: u&apos;dev&apos;, u&apos;codegen_units&apos;: None, u&apos;debug_assertions&apos;: False, u&apos;debuginfo&apos;: 0, u&apos;codegen_backend&apos;: None, u&apos;rpath&apos;: False, u&apos;overflow_checks&apos;: False, u&apos;incremental&apos;: False, u&apos;strip&apos;: u&apos;none&apos;, u&apos;opt_level&apos;: u&apos;0&apos;, u&apos;split_debuginfo&apos;: None, u&apos;lto&apos;: u&apos;false&apos;, u&apos;panic&apos;: u&apos;unwind&apos;&#125;, u&apos;features&apos;: [u&apos;clang_3_5&apos;, u&apos;clang_3_6&apos;, u&apos;clang_3_7&apos;, u&apos;clang_3_8&apos;, u&apos;clang_3_9&apos;, u&apos;clang_4_0&apos;, u&apos;clang_5_0&apos;, u&apos;clang_6_0&apos;], u&apos;platform&apos;: None, u&apos;dependencies&apos;: [&#123;u&apos;index&apos;: 12, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;build_script_build&apos;&#125;], u&apos;mode&apos;: u&apos;run-custom-build&apos;, u&apos;pkg_id&apos;: u&apos;clang-sys 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)&apos;, u&apos;target&apos;: &#123;u&apos;kind&apos;: [u&apos;custom-build&apos;], u&apos;name&apos;: u&apos;build-script-build&apos;, u&apos;doc&apos;: False, u&apos;src_path&apos;: u&apos;/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/clang-sys-1.1.1/build.rs&apos;, u&apos;edition&apos;: u&apos;2015&apos;, u&apos;doctest&apos;: False, u&apos;test&apos;: False, u&apos;crate_types&apos;: [u&apos;bin&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><p>对于新版本，发现只有一个 bindgen 项目，可以看到它会依赖 clang_sys。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;u&apos;profile&apos;: &#123;u&apos;name&apos;: u&apos;dev&apos;, u&apos;codegen_units&apos;: 4, u&apos;debug_assertions&apos;: True, u&apos;debuginfo&apos;: 0, u&apos;codegen_backend&apos;: None, u&apos;rpath&apos;: False, u&apos;overflow_checks&apos;: False, u&apos;incremental&apos;: False, u&apos;strip&apos;: u&apos;none&apos;, u&apos;opt_level&apos;: u&apos;0&apos;, u&apos;split_debuginfo&apos;: None, u&apos;lto&apos;: u&apos;false&apos;, u&apos;panic&apos;: u&apos;unwind&apos;&#125;, u&apos;features&apos;: [], u&apos;platform&apos;: None, u&apos;dependencies&apos;: [&#123;u&apos;index&apos;: 3, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;build_script_build&apos;&#125;, &#123;u&apos;index&apos;: 5, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;bitflags&apos;&#125;, &#123;u&apos;index&apos;: 9, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;cexpr&apos;&#125;, &#123;u&apos;index&apos;: 10, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;clang_sys&apos;&#125;, &#123;u&apos;index&apos;: 18, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;lazy_static&apos;&#125;, &#123;u&apos;index&apos;: 19, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;lazycell&apos;&#125;, &#123;u&apos;index&apos;: 29, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;peeking_take_while&apos;&#125;, &#123;u&apos;index&apos;: 30, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;proc_macro2&apos;&#125;, &#123;u&apos;index&apos;: 33, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;quote&apos;&#125;, &#123;u&apos;index&apos;: 34, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;regex&apos;&#125;, &#123;u&apos;index&apos;: 36, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;rustc_hash&apos;&#125;, &#123;u&apos;index&apos;: 38, u&apos;noprelude&apos;: False, u&apos;public&apos;: False, u&apos;extern_crate_name&apos;: u&apos;shlex&apos;&#125;], u&apos;mode&apos;: u&apos;build&apos;, u&apos;pkg_id&apos;: u&apos;bindgen 0.57.0 (registry+https://github.com/rust-lang/crates.io-index)&apos;, u&apos;target&apos;: &#123;u&apos;kind&apos;: [u&apos;lib&apos;], u&apos;name&apos;: u&apos;bindgen&apos;, u&apos;doc&apos;: True, u&apos;src_path&apos;: u&apos;/Users/calvin/.cargo/registry/src/github.com-1ecc6299db9ec823/bindgen-0.57.0/src/lib.rs&apos;, u&apos;edition&apos;: u&apos;2018&apos;, u&apos;doctest&apos;: True, u&apos;test&apos;: True, u&apos;crate_types&apos;: [u&apos;lib&apos;]&#125;&#125;</span><br></pre></td></tr></table></figure><p>至此可以得出猜测，老版本之所以能运行原因是 gen-proxy-ffi 链接到了不依赖 clang-sys 的 bindgen 上了。</p><h2 id="最终结论"><a href="#最终结论" class="headerlink" title="最终结论"></a>最终结论</h2><p>可为什么依赖 clang-sys 的 bindgen 可以实际上不依赖 clang-sys 呢？为此，我们首先怀疑 build.rs，可并没有发现什么异常。</p><p>然后尝试从源码中搜索 clang 关键词，发现了下面的代码。似乎我们可以在代码运行过程中，用类似 dlopen 的方式懒加载 libclang。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(feature = <span class="meta-string">"runtime"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">ensure_libclang_is_loaded</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> clang_sys::is_loaded() &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// XXX (issue #350): Ensure that our dynamically loaded `libclang`</span></span><br><span class="line">    <span class="comment">// doesn't get dropped prematurely, nor is loaded multiple times</span></span><br><span class="line">    <span class="comment">// across different threads.</span></span><br><span class="line"></span><br><span class="line">    lazy_static! &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">ref</span> LIBCLANG: std::sync::Arc&lt;clang_sys::SharedLibrary&gt; = &#123;</span><br><span class="line">            clang_sys::load().expect(<span class="string">"Unable to find libclang"</span>);</span><br><span class="line">            clang_sys::get_library().expect(</span><br><span class="line">                <span class="string">"We just loaded libclang and it had better still be \</span></span><br><span class="line"><span class="string">                 here!"</span>,</span><br><span class="line">            )</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    clang_sys::set_library(<span class="literal">Some</span>(LIBCLANG.clone()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是恍然大悟，如果指定让程序懒加载 libclang，但实际上我们又不会真的去用到它，那样老版本代码确实可以这么很苟地运行。因此我们去掉了<code>default-features = false</code>，结果运行正常了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;今天遇到一个奇怪的现象，前后两个版本 Cargo.lock 相同，但是后面的版本却报错”dyld: Library not loaded: @rpath/libclang.dylib”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>C++中类型和类型转换</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-type-cast/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-type-cast/</id>
    <published>2022-10-25T12:06:10.000Z</published>
    <updated>2023-06-15T12:38:19.778Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍 C++ 中的类型转换。<br>部分内容来自<a href="/2016/12/22/C++-meta-programming/">C++元编程</a>。隐式转换部分和重载决议有关，需要结合起来看。</p><a id="more"></a><h1 id="涉及-type-的一些概念"><a href="#涉及-type-的一些概念" class="headerlink" title="涉及 type 的一些概念"></a>涉及 type 的一些概念</h1><h2 id="Incomplete-type"><a href="#Incomplete-type" class="headerlink" title="Incomplete type"></a>Incomplete type</h2><ol><li>void 以及其 cv-qualified 形式</li><li>incompletely-defined object type<br> 一个 class 被声明(比如一个前向声明)，却没有定义。<br> bound 未知的数组。<br> imcomplete type 构成的数组。<br> enum，从它的声明，到它的 underlying type 被确定期间。</li></ol><p>这里说明一下，bound 未知的数组未必是 flex 数组。它可能是如下面这种 extern 形式定义的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> x[];      <span class="comment">// the type of x is "array of unknown bound of int"</span></span><br><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// the type of a is "array of 3 int"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a[][<span class="number">2</span>]; <span class="comment">// okay: array of unknown bound of arrays of 2 int</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> b[<span class="number">2</span>][]; <span class="comment">// error: array has incomplete element type</span></span><br></pre></td></tr></table></figure><p>Incomplete type 经常让人头大，需要各种头文件魔法或者 pimpl 来解决。</p><p>在下列情况下，需要类型是 Complete 的：</p><ol><li>TODO</li></ol><h2 id="typd-id"><a href="#typd-id" class="headerlink" title="typd-id"></a>typd-id</h2><p>我们可以通过 class/union/enum/typedef/using(type alias) 这些方式定义一个具名的类型。但是在 C++ 中，我们经常使用那些不具名的类型，例如下面的情况。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p;               <span class="comment">// declaration of a pointer to int</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(p); <span class="comment">// type-id is "int*"</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>];   <span class="comment">// declaration of an array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">// type-id is "int[3]" (called new-type-id)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> (*(*x[<span class="number">2</span>])())[<span class="number">3</span>];      <span class="comment">// declaration of an array of 2 pointers to functions</span></span><br><span class="line">                          <span class="comment">// returning pointer to array of 3 int</span></span><br><span class="line"><span class="keyword">new</span> (<span class="keyword">int</span> (*(*[<span class="number">2</span>])())[<span class="number">3</span>]); <span class="comment">// type-id is "int (*(*[2])())[3]"</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;                    <span class="comment">// declaration of a function taking int and returning void</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; x = f; <span class="comment">// type template parameter is a type-id "void(int)"</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">auto</span>(<span class="keyword">int</span>) -&gt; <span class="keyword">void</span>&gt; y = f; <span class="comment">// same</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;       <span class="comment">// declaration of a vector of int</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;); <span class="comment">// type-id is "std::vector&lt;int&gt;"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">int</span> x; &#125; b;         <span class="comment">// creates a new type and declares an object b of that type</span></span><br><span class="line"><span class="keyword">sizeof</span>(struct &#123; <span class="keyword">int</span> x; &#125;);   <span class="comment">// error: cannot define new types in a sizeof expression</span></span><br><span class="line"><span class="keyword">using</span> t = struct &#123; <span class="keyword">int</span> x; &#125;; <span class="comment">// creates a new type and declares t as an alias of that type</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">static</span> <span class="keyword">int</span>); <span class="comment">// error: storage class specifiers not part of type-specifier-seq</span></span><br><span class="line">std::function&lt;inline void(int)&gt; f; // error: neither are function specifiers</span><br></pre></td></tr></table></figure><p>此外，RTTI 机制还提供了一个 typeid 运算符(不是函数)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>&amp;) != <span class="keyword">typeid</span>(<span class="keyword">int</span>*));</span><br><span class="line">    assert(<span class="keyword">typeid</span>(<span class="keyword">int</span>) == <span class="keyword">typeid</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h1><p>显式转换有几种类型：</p><p><code>(new-type) expr</code> 型。这是 C-style 的，C++ 会按顺序尝试：</p><ol><li>const_cast</li><li>static_cast(增强的)<br> 注意，子类的指针或者引用，可以被转成无歧义的基类，即使基类不可访问。对于成员函数的指针也同样适用</li><li>static_cast(增强的) + const_cast</li><li>reinterpret_cast</li><li>reinterpret_cast + const_cast</li></ol><p><code>new-type (expr)</code> 型。</p><p>需要注意，这种 function-style cast expression 容易和声明产生歧义。此时，这些歧义都会被视作声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">M</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">L</span> &#123;</span> L(M&amp;); &#125;;</span><br><span class="line"> </span><br><span class="line">M n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    M(m);    <span class="comment">// declaration, equivalent to M m;</span></span><br><span class="line">    L(n);    <span class="comment">// ill-formed declaration</span></span><br><span class="line">    L(l)(m); <span class="comment">// still a declaration</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【C++11起】<code>new-type {expr}</code>型。</p><p>一个显式类型转换的类型是什么呢？</p><ol><li>对于 lvalue reference，结果是一个 lvalue</li><li>对于函数的 rvalue reference，结果是一个 lvalue</li><li>对于 rvalue reference，结果是一个 xvalue</li><li>对于其他情况，结果是一个 prvalue</li></ol><h1 id="Value-categories"><a href="#Value-categories" class="headerlink" title="Value categories"></a>Value categories</h1><p>介绍<a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">Value categories</a>。</p><ol><li>一个 glvalue，即 generalized lvalue 是一个表达式，对它求值 determines the identity of an object or function。</li><li>一个 prvalue 即 pure rvalue，是一表达式，对它求值<ol><li>计算某个 builtin 操作符的操作数<br> 这种情况称作这个 prvalue 没有 result object。</li><li>初始化某个对象<br> 这种情况称作这个 prvalue 有 result object。<br> 结果对象可以是一个变量，或者由 new 表达式创建的对象，或者由临时量实质化创建的临时对象，或者前述三类对象的成员。<br> 注意非 void 的弃值表达式有 result object，称为 materialized temporary。<br> 并且除了作为 decltype 的操作数，每个类类型或数组类型的纯右值都有 result object。</li></ol></li><li>一个 xvalue，即 eXpiring value 是一个 glvalue，它的资源能够被重新利用</li><li>an lvalue 是一个 glvalue，但不是 xvalue。</li><li>an rvalue 是一个 prvalue 或者 xvalue。</li></ol><h2 id="lvalue"><a href="#lvalue" class="headerlink" title="lvalue"></a>lvalue</h2><ol><li>解引用</li><li>++a 等</li><li>+=、=、%= 等</li><li><code>a.m</code> 和 <code>a.*mp</code></li><li><code>p-&gt;m</code> 和 <code>p-&gt;*mp</code></li><li>逗号运算符</li><li>某些三目运算符的计算结果</li><li>字符串直接量</li><li>返回左值的 cast</li><li></li></ol><h2 id="xvalue"><a href="#xvalue" class="headerlink" title="xvalue"></a>xvalue</h2><h2 id="prvalue"><a href="#prvalue" class="headerlink" title="prvalue"></a>prvalue</h2><ol><li>literal</li><li>一个函数调用或者 overloaded operator expression，它的返回值如果不是引用</li><li>某些 builtin operator<br> a++ 等，注意 ++a 是 lvalue。</li><li>某些三目运算符的计算结果</li><li>this</li><li>enumerator</li><li>lambda 表达式</li></ol><h1 id="User-defined-conversion-function"><a href="#User-defined-conversion-function" class="headerlink" title="User-defined conversion function"></a>User-defined conversion function</h1><p>用户自定义的类型转换函数，用来支持显式或者隐式地从某个 class 类型转化到另一个类型。</p><p>有三种方式：</p><ol><li>operator conversion-type-id</li><li>【C++11】 explicit operator conversion-type-id<br> 只允许在 direct-initialization 和 explicit conversions 场景下使用。</li><li>【C++20】 explicit ( expression ) operator conversion-type-id   </li></ol><p>需要注意，conversion-type-id 中不能带有 <code>[]</code> 或者 <code>()</code>。如果想提供到某个数组指针或者函数的转换，我们需要先 typedef 一下。但无论如何，任何情况下都不能转化成数组或者函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Error: array operator not allowed in conversion-type-id</span></span><br><span class="line"><span class="comment">//  operator int(*)[3]() const &#123; return nullptr; &#125;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">arr_t</span> = <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">arr_t</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125; <span class="comment">// OK if done through typedef</span></span><br><span class="line"><span class="comment">//  operator arr_t () const; // Error: conversion to array not allowed in any case</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的代码展示了 implicit 和 explicit 的 conversion 的区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// implicit conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="number">7</span>; &#125;</span><br><span class="line">    <span class="comment">// explicit conversion</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="keyword">int</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X x;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显式转换</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(x);   <span class="comment">// OK: sets n to 7</span></span><br><span class="line">    <span class="comment">// copy initialization</span></span><br><span class="line">    <span class="keyword">int</span> m = x;                     <span class="comment">// OK: sets m to 7</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// explicit conversions</span></span><br><span class="line">    <span class="keyword">int</span>* p = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>*&gt;(x); <span class="comment">// OK: sets p to null</span></span><br><span class="line">    <span class="comment">// direct initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>* <span class="title">q</span><span class="params">(x)</span></span>;</span><br><span class="line">    <span class="comment">// int* q = x; // Error: no implicit conversion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于隐式转换而言，user-defined conversion function 发生在第二阶段，在本文的对应章节有论述。</p><h1 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h1><p>一个隐式类型转换序列包含：</p><ol><li><p>一系列 standard conversion sequence</p></li><li><p>可选的 user-defined conversion<br> 一个 user-defined conversion 包含两种情况：</p><ol><li>由0或1个单参数的<a href="https://en.cppreference.com/w/cpp/language/converting_constructor" target="_blank" rel="noopener">Converting constructor</a><br> 这里指的是没有被标记为 explicit 的构造函数。</li><li>一个 non-explicit <a href="https://en.cppreference.com/w/cpp/language/cast_operator" target="_blank" rel="noopener">conversion function call</a><br> 这里指的是 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> conversion-type-id</span><br></pre></td></tr></table></figure></li></ol></li><li><p>一系列 standard conversion sequence</p></li></ol><p><img src="/img/cpp_meta_programming/implicit_conversion_cat11.jpg"></p><p>When considering the argument to a constructor or to a user-defined conversion function, only a standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). 当一个 non-class 类型转换到另一个 non-class 类型，只允许一个 standard conversion sequence。</p><p>Standard conversion 的顺序：</p><ol><li>zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion;</li><li>zero or one numeric promotion or numeric conversion;</li><li>【C++17】 zero or one function pointer conversion;</li><li>zero or one qualification conversion.</li></ol><p>当且仅当 T2 能从 表达式 e 被 copy-initialized 时，也就是说 <code>T2 t = e</code> 是 well-formed 时，e 可以被隐式转换为 T2。这里注意 copy-initialized 不是 direct initialization <code>T2 t(e)</code>。对于后者，需要考虑 explicit constructors 和 conversion functions。</p><h2 id="Converting-constructor"><a href="#Converting-constructor" class="headerlink" title="Converting constructor"></a>Converting constructor</h2><p>简单再介绍下 Converting constructor。总的来说，构造函数分为两类，explicit constructor 和 converting constructor。explicit constructor 只在 direct initialization，其中包含显式类型转换比如 static_cast 时使用。converting constructor 在 copy initialization 也可以被使用，此时作为 user-defined conversion sequence，其实就是上面讲的第二阶段的一部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A() &#123; &#125;         <span class="comment">// converting constructor (since C++11)  </span></span><br><span class="line">    A(<span class="keyword">int</span>) &#123; &#125;      <span class="comment">// converting constructor</span></span><br><span class="line">    A(<span class="keyword">int</span>, <span class="keyword">int</span>) &#123; &#125; <span class="comment">// converting constructor (since C++11)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">()</span> </span>&#123; &#125;            <span class="comment">// explicit constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; &#125;         <span class="comment">// explicit constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123; &#125;    <span class="comment">// explicit constructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于上面的定义，下面列出了一些 case。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1 = <span class="number">1</span>;      <span class="comment">// OK: copy-initialization selects A::A(int)</span></span><br><span class="line">    <span class="function">A <span class="title">a2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects A::A(int)</span></span><br><span class="line">    A a3&#123;<span class="number">4</span>, <span class="number">5</span>&#125;;    <span class="comment">// OK: direct-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a4 = &#123;<span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// OK: copy-list-initialization selects A::A(int, int)</span></span><br><span class="line">    A a5 = (A)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast, direct-initialization</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//  B b1 = 1;      // error: copy-initialization does not consider B::B(int)</span></span><br><span class="line">    <span class="function">B <span class="title">b2</span><span class="params">(<span class="number">2</span>)</span></span>;       <span class="comment">// OK: direct-initialization selects B::B(int)</span></span><br><span class="line">    B b3&#123;<span class="number">4</span>, <span class="number">5</span>&#125;;    <span class="comment">// OK: direct-list-initialization selects B::B(int, int)</span></span><br><span class="line"><span class="comment">//  B b4 = &#123;4, 5&#125;; // error: copy-list-initialization selected an explicit constructor</span></span><br><span class="line">                   <span class="comment">//        B::B(int, int)</span></span><br><span class="line">    B b5 = (B)<span class="number">1</span>;   <span class="comment">// OK: explicit cast performs static_cast, direct-initialization</span></span><br><span class="line">    B b6;          <span class="comment">// OK, default-initialization</span></span><br><span class="line">    B b7&#123;&#125;;        <span class="comment">// OK, direct-list-initialization</span></span><br><span class="line"><span class="comment">//  B b8 = &#123;&#125;;     // error: copy-list-initialization selected an explicit constructor</span></span><br><span class="line">                   <span class="comment">//        B::B()</span></span><br><span class="line"> </span><br><span class="line">    [](...)&#123;&#125;(a1, a4, a4, a5, b5); <span class="comment">// may suppress "unused variable" warnings</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个有趣的问题"><a href="#一个有趣的问题" class="headerlink" title="一个有趣的问题"></a>一个有趣的问题</h3><p><a href="https://stackoverflow.com/questions/76323736/why-optionalvalue-or-takes-a-u-rather-than-t" target="_blank" rel="noopener">为什么 optional::value_or 接受一个 U&amp;&amp; 参数而不直接使用 T&amp;&amp;呢</a>？</p><p>原因有两个：</p><ol><li><code>U&amp;&amp;</code> 实际上是一个 universal reference，方便我们进行完美转发</li><li>构造默认的值的成本可能比较大，例如他可能是有100个元素的一个 vector。如果实际不需要用到这个默认的值，使用 U&amp;&amp; 能允许我们做一个优化，让它不被构造。方案是引入一个 U，这个 U 只是一个 generator，只有在实际被用到也就是调用 <code>operator T()</code> 时，才会生成一个 vector。如果在调用 value_or 之前就将 U&amp;&amp; 转换为 T&amp;&amp;，这个优化就不能做了。<br> 当然了，我还是觉得 rust 的方案好，也就是让你传一个 closure 过去。</li></ol><h2 id="decay"><a href="#decay" class="headerlink" title="decay"></a>decay</h2><p>首先来看一下什么是 decay。例如，对于数组 <code>T a[n]</code>，除了 <code>sizeof</code>、<code>alignof</code>、引用限定符 <code>&amp;</code> 以及字符串常量等<a href="https://stackoverflow.com/questions/16570716/c-warning-format-s-expects-type-char-but-argument-2-has-type-char" target="_blank" rel="noopener">少数情形</a>外，<code>a</code>出现时会被 decay 成指向 T 的指针。例如下面代码往 <code>char s[N]</code> 数组中读入了数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s);</span><br></pre></td></tr></table></figure><p>而很多人会误写为以下的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, &amp;s);</span><br></pre></td></tr></table></figure><p>此时，<code>s</code> 的类型实际上是 <code>char (*) [N]</code>，称为 pointer to an array of char ，而 <code>scanf</code> 希望接受到的是<code>char *</code>，称为 pointer to char 类型。</p><h2 id="各种-convertion-类型"><a href="#各种-convertion-类型" class="headerlink" title="各种 convertion 类型"></a>各种 convertion 类型</h2><h3 id="Contextual-conversions"><a href="#Contextual-conversions" class="headerlink" title="Contextual conversions"></a>Contextual conversions</h3><p>Case1: 【C++11】从 T 到 bool 的转换。如果 <code>bool t(e)</code> 是 well-formed，也就是说存在 <code>explicit T::operator bool() const;</code>。在下列场景中，这样的表达式 e 会被转换为 bool：</p><ol><li>if、while、for 的条件</li><li>逻辑运算符</li><li>三目运算符的条件</li><li>static_assert</li><li>noexcept</li><li>【C++20】explicit 表达式</li></ol><p>Case2: In the following contexts, a context-specific type T is expected, and the expression e of class type E is only allowed if：</p><ol><li>【until C++14】E has a single non-explicit (since C++11) user-defined conversion function to an allowable type.</li><li>【since C++14】对于 E 的所有的 non-explicit conversion functions，如果它们的返回类型是都是 T，或者带 CV 和引用修饰的 T，这样的 e 可以 implicitly convertible to T。</li></ol><p>Such expression e is said to be contextually implicitly converted to the specified type T. 【C++11】Note that explicit conversion functions are not considered, even though they are considered in contextual conversions to bool.</p><ol><li>the argument of the delete-expression (T is any object pointer type);</li><li>integral constant expression, where a literal class is used (T is any integral or unscoped (since C++11) enumeration type, the selected user-defined conversion function must be constexpr);</li><li>the controlling expression of the switch statement (T is any integral or enumeration type).</li></ol><h3 id="Value-transformations"><a href="#Value-transformations" class="headerlink" title="Value transformations"></a>Value transformations</h3><h4 id="temporary-materialization"><a href="#temporary-materialization" class="headerlink" title="temporary materialization"></a>temporary materialization</h4><p>提一个 temporary materialization 的概念。指的是一个完整类型 T 的 prvalue，可以被转换成同类型的一个 xvalue。这个转换会创建一个临时的 T 的对象，by evaluating the prvalue with the temporary object as its result object and produces an xvalue denoting the temporary object。</p><p>如果 T 是一个类，或者一个成员为类的数组，它必须有可访问的、非 delete 的修够函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="keyword">int</span> m; &#125;;</span><br><span class="line"><span class="keyword">int</span> i = S().m; <span class="comment">// member access expects glvalue as of C++17;</span></span><br><span class="line">               <span class="comment">// S() prvalue is converted to xvalue</span></span><br></pre></td></tr></table></figure><h4 id="Lvalue-to-rvalue-conversion"><a href="#Lvalue-to-rvalue-conversion" class="headerlink" title="Lvalue-to-rvalue conversion"></a>Lvalue-to-rvalue conversion</h4><p>不考虑旧版本，从 C++11 开始说。<br>一个非 function 且非 array 类型的 glvalue T 可以被隐式转换为一个 prvalue。此时：</p><ol><li>如果 T 不是 class type, 那么这个 prvalue 的类型是 T，但会去掉 cv 限定符。</li><li>如果 T 是 class type，那么这个 prvalue 的类型是 T。</li></ol><p>如果 T 是一个不完整类型，那么执行 lvalue-to-rvalue conversion 是 ill-formed 的。</p><p>When an lvalue-to-rvalue conversion is applied to an expression E, the value contained in the referenced object is not accessed if:</p><ol><li>E is not <a href="https://en.cppreference.com/w/cpp/language/expressions#Potentially-evaluated_expressions" target="_blank" rel="noopener">potentially evaluated</a>，也就是它是 unevaluated operand，或者 unevaluated operand 中的子表达式。</li><li>the evaluation of E results in the evaluation of a member Ex of the set of potential results of E, and Ex names a variable x that is not <a href="https://en.cppreference.com/w/cpp/language/definition#ODR-use" target="_blank" rel="noopener">odr-used</a> by Ex.</li></ol><h4 id="Array-to-pointer-conversion"><a href="#Array-to-pointer-conversion" class="headerlink" title="Array-to-pointer conversion"></a>Array-to-pointer conversion</h4><p>An lvalue or rvalue of type “array of N T” or “array of unknown bound of T” can be implicitly converted to a prvalue of type “pointer to T”.<br>【C++17】If the array is a prvalue, temporary materialization occurs.<br>The resulting pointer refers to the first element of the array (see array to pointer decay for details)</p><h4 id="Function-to-pointer-conversion"><a href="#Function-to-pointer-conversion" class="headerlink" title="Function-to-pointer conversion"></a>Function-to-pointer conversion</h4><h3 id="Numeric-promotions"><a href="#Numeric-promotions" class="headerlink" title="Numeric promotions"></a>Numeric promotions</h3><h4 id="Integral-promotion"><a href="#Integral-promotion" class="headerlink" title="Integral promotion"></a>Integral promotion</h4><h4 id="Floating-point-promotion"><a href="#Floating-point-promotion" class="headerlink" title="Floating-point promotion"></a>Floating-point promotion</h4><h3 id="Numeric-conversions"><a href="#Numeric-conversions" class="headerlink" title="Numeric conversions"></a>Numeric conversions</h3><h4 id="Integral-conversions"><a href="#Integral-conversions" class="headerlink" title="Integral conversions"></a>Integral conversions</h4><h4 id="Floating-point-conversions"><a href="#Floating-point-conversions" class="headerlink" title="Floating-point conversions"></a>Floating-point conversions</h4><h4 id="Floating–integral-conversions"><a href="#Floating–integral-conversions" class="headerlink" title="Floating–integral conversions"></a>Floating–integral conversions</h4><h4 id="Pointer-conversions"><a href="#Pointer-conversions" class="headerlink" title="Pointer conversions"></a>Pointer conversions</h4><h4 id="Pointer-to-member-conversions"><a href="#Pointer-to-member-conversions" class="headerlink" title="Pointer-to-member conversions"></a>Pointer-to-member conversions</h4><h4 id="Boolean-conversions"><a href="#Boolean-conversions" class="headerlink" title="Boolean conversions"></a>Boolean conversions</h4><h3 id="Qualification-conversions"><a href="#Qualification-conversions" class="headerlink" title="Qualification conversions"></a>Qualification conversions</h3><h3 id="【C-17】Function-pointer-conversions"><a href="#【C-17】Function-pointer-conversions" class="headerlink" title="【C++17】Function pointer conversions"></a>【C++17】Function pointer conversions</h3><h2 id="重载决议的顺序-rank"><a href="#重载决议的顺序-rank" class="headerlink" title="重载决议的顺序(rank)"></a>重载决议的顺序(rank)</h2><p>在<a href="https://en.cppreference.com/w/cpp/language/overload_resolution" target="_blank" rel="noopener">重载决议</a>时，采取下列顺序，可参考 Ranking of implicit conversion sequences 章节。<br>任何一个 standard conversion sequence 被划分为下面三个 rank：</p><ol><li><p>精确匹配<br> 此时，不需要进行任何的转换。<br> 下面列举出了几种情况：</p><ol><li>无转换</li><li>Lvalue-to-rvalue conversion</li><li>【C++17】function pointer conversion</li><li>user-defined conversion of class type to the same class</li><li>Qualification conversions，即限定符转换<br> 我们可以为任意类型加上CV限定符。对于多重指针来说，前面的重数的限制要高于后面重数的限制，如 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>** p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>** p1 = p; <span class="comment">// error: level 2 more cv-qualified but level 1 is not const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> * p2 = p; <span class="comment">// OK: level 2 more cv-qualified and const added at level 1</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>Promotion<br> 即Numeric promotions，包含Integral promotion和Floating-point promotion<br> 这里注意，<a href="http://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">非promotion的整数之间转换都作为conversion</a>，如<code>char -&gt; int</code></p></li><li><p>Conversion</p><ol><li>integral conversion</li><li>floating-point conversion</li><li>floating-integral conversion</li><li>pointer conversion</li><li>pointer-to-member conversion</li><li>boolean conversion</li><li>user-defined conversion of a derived class to its base</li></ol></li></ol><p>The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to three conversions)</p><p>注意能进行隐式类型转换<strong>并不意味着类型相同</strong>，所以使用<code>std::is_same</code>进行的判断都是false，例如下面的代码输出都是false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_same&lt;<span class="keyword">int</span>, <span class="keyword">const</span> <span class="keyword">int</span> &amp;&gt;::value &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/explicit_cast" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/explicit_cast</a></li><li><a href="https://en.cppreference.com/w/cpp/language/implicit_conversion" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/implicit_conversion</a></li><li><a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/type</a></li><li><a href="https://en.cppreference.com/w/cpp/language/cast_operator" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/cast_operator</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍 C++ 中的类型转换。&lt;br&gt;部分内容来自&lt;a href=&quot;/2016/12/22/C++-meta-programming/&quot;&gt;C++元编程&lt;/a&gt;。隐式转换部分和重载决议有关，需要结合起来看。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto关键字的用法</title>
    <link href="http://www.calvinneo.com/2022/10/25/C++-auto/"/>
    <id>http://www.calvinneo.com/2022/10/25/C++-auto/</id>
    <published>2022-10-25T11:06:10.000Z</published>
    <updated>2022-10-25T16:04:51.535Z</updated>
    
    <content type="html"><![CDATA[<p>在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>auto 的作用：</p><ol><li>对于变量，自动推导其类型</li><li>【C++14起】对于函数，自动推导返回值</li><li>【C++17起】对于非类型模板参数，自动推导其类型</li></ol><p>有两种用法<br>【C++11起】auto<br>基于<a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts" target="_blank" rel="noopener">template type deduction</a>进行推导。</p><p>在推导变量类型时，这种推导方式会将每个 auto 出现的地方代换做一个模板参数 U。U 的类型可以从等号左边的 P(<code>下面的const auto&amp;</code>) 和等号右边的 A(下面的<code>1+2</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// P = const U&amp;, A = 1 + 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">void</span> <span class="title">f</span>(<span class="title">const</span> <span class="title">U</span>&amp; <span class="title">u</span>) &#123;</span>...&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; x = f(<span class="number">1</span> + <span class="number">2</span>); <span class="comment">// U = int, so the type of x is const int&amp;</span></span><br></pre></td></tr></table></figure><p>特别地，对于 copy-list-initialization 的情况，auto 要被代换为 <code>initializer_list&lt;U&gt;</code>。U 的类型同样可以从 P 和 A 推导出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = &#123;<span class="number">13</span>&#125;; <span class="comment">// P = std::initializer_list&lt;U&gt;, A = &#123;13&#125;:</span></span><br><span class="line">               <span class="comment">// deduced U = int, the type of l is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">auto</span> x1 = &#123;<span class="number">3</span>&#125;; <span class="comment">// x1 is std::initializer_list&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p>对于 direct-list-initialization 的情况，大括号内只允许有一个元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x2&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// error: not a single element</span></span><br><span class="line"><span class="keyword">auto</span> x3&#123;<span class="number">3</span>&#125;;    <span class="comment">// x3 is int</span></span><br><span class="line">               <span class="comment">// (before N3922 x2 and x3 were both std::initializer_list&lt;int&gt;)</span></span><br></pre></td></tr></table></figure><p>在推导返回值类型时，同样用模板参数 U 去替换。这个时候 A 就是 return 后面跟的表达式。如果有多个 return，那么它们推导出来必须是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// P = auto, A = 42:</span></span><br><span class="line">                        <span class="comment">// deduced U = int, the return type of f is int</span></span><br></pre></td></tr></table></figure><p>【C++14起】decltype(auto)<br>类型是<code>decltype(expr)</code>，expr 就是用来初始化的表达式。它不走上面的 template type deduction 逻辑。<br>那么这个到底有啥用呢？<a href="https://stackoverflow.com/questions/24109737/what-are-some-uses-of-decltypeauto" target="_blank" rel="noopener">举几个例子</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">auto</span> x3a = i;                  <span class="comment">// decltype(x3a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x3d = i;        <span class="comment">// decltype(x3d) is int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> x4a = (i);                <span class="comment">// decltype(x4a) is int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x4d = (i);      <span class="comment">// decltype(x4d) is int&amp;</span></span><br></pre></td></tr></table></figure><p>如果一个函数返回右值引用，则其<code>decltype(auto)</code>是右值引用，但<code>auto</code>推导为值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp;&amp; <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> x5a = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5a), <span class="keyword">int</span>&gt;::value, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x5b = f();</span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(x5b), <span class="keyword">int</span>&amp;&amp;&gt;::value, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>对于大括号的形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x6a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;           <span class="comment">// decltype(x6a) is std::initializer_list&lt;int&gt;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) x6d = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;; <span class="comment">// error, &#123; 1, 2 &#125; is not an expression</span></span><br></pre></td></tr></table></figure><p>此外，<code>decltype(auto)</code>不能有其他的修饰了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> *x7a = &amp;i;                <span class="comment">// decltype(x7a) is int*</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>)*x7d = &amp;i;       <span class="comment">// error, declared type is not plain decltype(auto)</span></span><br></pre></td></tr></table></figure><p>【C++23】auto 可以被用作显式类型转换。如<code>auto (expr)</code>和<code>auto {expr}</code></p><p>注意，在 trailing return type 中，auto 会在开头来开始这个声明。但它同样可以作为 placeholder 出现在尾部，虽然我也不知道意义在哪里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> (*p)() -&gt; <span class="keyword">int</span>; <span class="comment">// declares p as pointer to function returning int</span></span><br><span class="line"><span class="keyword">auto</span> (*q)() -&gt; <span class="keyword">auto</span> = p; <span class="comment">// declares q as pointer to function returning T</span></span><br><span class="line">                         <span class="comment">// where T is deduced from the type of p</span></span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://en.cppreference.com/w/cpp/language/auto" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/auto</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在最近几个 C++ 版本中，auto 越来越常见。很多人打趣说将来 C++ 里面一定全是 auto。本文介绍 C++ 中 auto(新)关键字的用法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础机制分析</title>
    <link href="http://www.calvinneo.com/2022/10/15/redis-common/"/>
    <id>http://www.calvinneo.com/2022/10/15/redis-common/</id>
    <published>2022-10-15T15:52:20.000Z</published>
    <updated>2023-05-31T03:56:55.474Z</updated>
    
    <content type="html"><![CDATA[<p>因为原<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：</p><ol><li>redisDb，以及在这上面的增删改查</li><li>Redis的expire和evict机制</li><li>Redis的事件机制</li><li>Redis的主从复制(一部分)<br> 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。<br> 本文介绍的部分比如propagate机制。</li></ol><p>本文中不介绍的是，它们在系列的其他文章中讲解：</p><ol><li>Redis的对象实现</li><li>Redis Sentinel</li><li>Redis Cluster</li><li>Redis AOF/RDB</li></ol><a id="more"></a><h1 id="Redis源码结构"><a href="#Redis源码结构" class="headerlink" title="Redis源码结构"></a>Redis源码结构</h1><p>在3.0版本中，redis的主要结构都定义在redis.h中，在新版本中，它们被放到了server.h中。</p><p>我们主要介绍</p><ol><li>一些常用的类<ol><li>redisServer</li><li>redisDb</li><li>redisObject<br> 包含添加对象的逻辑</li></ol></li><li>删除逻辑<br> 包含对同步删除和异步删除的讨论。</li><li>查找逻辑</li><li>expire</li><li>evict</li><li>propagate</li><li>事件机制</li><li>内存管理</li></ol><h1 id="Redis-Server"><a href="#Redis-Server" class="headerlink" title="Redis Server"></a>Redis Server</h1><p>这个章节中介绍Redis数据库顶层键的架构和增删改查的实现，主要包括：</p><h2 id="redisDb类"><a href="#redisDb类" class="headerlink" title="redisDb类"></a>redisDb类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* 数据库键空间 */</span></span><br><span class="line">    dict *expires;              <span class="comment">/* 键的过期时间，字典的键为键，字典的值为过期时间 */</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* 用来服务诸如BLPOP的命令，记录目前被阻塞的键 */</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* 数据库键的平均TTL，统计信息 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> expires_cursor; <span class="comment">/* Cursor of the active expire cycle. */</span></span><br><span class="line">    <span class="built_in">list</span> *defrag_later;         <span class="comment">/* List of key names to attempt to defrag one by one, gradually. */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><p>可以发现，<code>redisDb</code>本身就依赖<code>dict</code>和<code>list</code>等Redis底层结构的实现，说明Redis的复用性还是很好的。</p><h2 id="client类"><a href="#client类" class="headerlink" title="client类"></a>client类</h2><p>client类对应了3.0版本中的<code>redisClient</code>类。因为Redis对IO是多路复用的，所以需要为每个客户端连接维护一个状态，所以<code>client</code>实际上类似于session一样，是在服务器端维护的一个状态。而真正的Redis客户端定义在redis-cli.c这个文件里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    connection *conn;</span><br><span class="line">    <span class="keyword">int</span> resp;               <span class="comment">/* RESP protocol version. Can be 2 or 3. */</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br></pre></td></tr></table></figure><h2 id="redisServer类"><a href="#redisServer类" class="headerlink" title="redisServer类"></a>redisServer类</h2><p><code>server</code>是一个全局对象，它的类型是<code>redisServer</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> <span class="title">server</span>;</span> <span class="comment">/* Server global state */</span></span><br></pre></td></tr></table></figure><h1 id="Redis基础类"><a href="#Redis基础类" class="headerlink" title="Redis基础类"></a>Redis基础类</h1><h2 id="增删改查涉及的系统梳理"><a href="#增删改查涉及的系统梳理" class="headerlink" title="增删改查涉及的系统梳理"></a>增删改查涉及的系统梳理</h2><ol><li>DB部分<br> 更新dirty</li><li>Cluster部分</li><li>事件部分<br> signalModifiedKey：包含通知WATCH列表、通知客户端更新缓存<br> notifyKeyspaceEvent：通过PUBLUSH发送消息</li><li>主从复制/持久化部分<br> propagate对应命令（在call中处理）</li><li>Module部分</li></ol><h2 id="Redis-Object"><a href="#Redis-Object" class="headerlink" title="Redis Object"></a>Redis Object</h2><p>诸如<code>dict</code>、<code>sds</code>之类的对象，在db层面实际上是用<code>redisObject</code>封装的，需要的时候通过<code>robj-&gt;ptr</code>获取实际需要的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 由OBJ_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 由OBJ_ENCODING_的值指定</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br></pre></td></tr></table></figure><p>Redis对象的类型是用<code>OBJ_</code>宏来列出的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">/* The actual Redis Object */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The "module" object type is a special one that signals that the object</span></span><br><span class="line"><span class="comment"> * is one directly managed by a Redis module. In this case the value points</span></span><br><span class="line"><span class="comment"> * to a moduleValue struct, which contains the object value (which is only</span></span><br><span class="line"><span class="comment"> * handled by the module itself) and the RedisModuleType struct which lists</span></span><br><span class="line"><span class="comment"> * function pointers in order to serialize, deserialize, AOF-rewrite and</span></span><br><span class="line"><span class="comment"> * free the object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Inside the RDB file, module types are encoded as OBJ_MODULE followed</span></span><br><span class="line"><span class="comment"> * by a 64 bit module type ID, which has a 54 bits module-specific signature</span></span><br><span class="line"><span class="comment"> * in order to dispatch the loading to the right module, plus a 10 bits</span></span><br><span class="line"><span class="comment"> * encoding version. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_MODULE 5    <span class="comment">/* Module object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STREAM 6    <span class="comment">/* Stream object. */</span></span></span><br></pre></td></tr></table></figure><p>Redis对象实际使用的内部结构是用<code>OBJ_ENCODING_</code>宏来表示的，如前文所列举的，同一个对象可能有不同的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="comment">// OBJ_ENCODING_RAW是普通的SDS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="comment">// embstr是对短字符串的一种优化编码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>有两种特殊的引用计数值：</p><ol><li><code>OBJ_SHARED_REFCOUNT</code><br> 由<code>makeObjectShared</code>函数生成，在这种情况下这个对象是immutable的，因此可以不加锁地进行访问。这种对象也不受<code>incrRefCount</code>/<code>decrRefCount</code>控制。<br> 注意，这种对象设为immutable是合理的，它的一个通常作用是共享小整数对象，例如Redis会共享0到9999。</li><li><code>OBJ_STATIC_REFCOUNT</code><br> 一般由<code>initStaticStringObject</code>宏生成。看上去这个一般用在在栈上面分配的临时对象的refcount，我对此也不是很确定。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SHARED_REFCOUNT INT_MAX     <span class="comment">/* Global object never destroyed. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STATIC_REFCOUNT (INT_MAX-1) <span class="comment">/* Object allocated in the stack. */</span></span></span><br><span class="line"><span class="comment">// 第一个有特殊含义的refcount值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_FIRST_SPECIAL_REFCOUNT OBJ_STATIC_REFCOUNT</span></span><br></pre></td></tr></table></figure></li></ol><p>一般来说，使用引用计数可能存在循环引用的问题。Redis巧妙地避免了这个问题，首先在Redis的所有<code>redisObject</code>里面，只有String会被嵌入到其他类型中，也就是说ZSET等其他的数据类型不会互相引用（在Geo等新数据结构里面也是这样的么？）。而Redis对String类型引入对象共享机制，保证了不会产生互相引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount &lt; OBJ_FIRST_SPECIAL_REFCOUNT) &#123;</span><br><span class="line">        o-&gt;refcount++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount == OBJ_SHARED_REFCOUNT) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do: this refcount is immutable. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;refcount == OBJ_STATIC_REFCOUNT) &#123;</span><br><span class="line">            serverPanic(<span class="string">"You tried to retain an object allocated in the stack"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>decrRefCount</code>还负责销毁对象，步骤是<code>freeXXXObject</code>，然后在<code>zfree</code>。前者用来释放<code>o-&gt;ptr</code>指向的对象的内存，后者用来释放<code>o</code>的内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STREAM: freeStreamObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样理解<code>incr/decrRefCount</code>，如果我们创建或者复制一个对象，就要incr，如果我们要删除一个对象就要decr。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>通过<code>createObject</code>创建对象，<code>refcount</code>设为1。<code>encoding</code>设为<code>OBJ_ENCODING_RAW</code>，也就是普通SDS字符串。传入的<code>type</code>是<code>OBJ_</code>宏的某个特定值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般在创建完对象后，还需要通过<code>dbAdd</code>将它插入到数据库里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add the key to the DB. It's up to the caller to increment the reference</span></span><br><span class="line"><span class="comment"> * counter of the value if needed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The program is aborted if the key already exists. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,retval == DICT_OK);</span><br><span class="line">    signalKeyAsReady(db, key, val-&gt;type);</span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) slotToKeyAdd(key-&gt;ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象装箱拆箱"><a href="#对象装箱拆箱" class="headerlink" title="对象装箱拆箱"></a>对象装箱拆箱</h3><p>这个都是返回一个“新”对象，这里“新”的意思是在使用完这个对象都应该<code>decrRefCount</code>。<br>如果是原生encoding储存的，就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sdsEncodedObject(objptr) (objptr-&gt;encoding == OBJ_ENCODING_RAW || objptr-&gt;encoding == OBJ_ENCODING_EMBSTR)</span></span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">getDecodedObject</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    robj *dec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdsEncodedObject(o)) &#123;</span><br><span class="line">        incrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果使用SDS保存的整数，实际上里面是个long long，那么就需要先<code>ll2string</code>把这个转换成字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">        ll2string(buf,<span class="number">32</span>,(<span class="keyword">long</span>)o-&gt;ptr);</span><br><span class="line">        dec = createStringObject(buf,<span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">return</span> dec;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown encoding type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-Command"><a href="#Redis-Command" class="headerlink" title="Redis Command"></a>Redis Command</h2><h3 id="redisCommand对象"><a href="#redisCommand对象" class="headerlink" title="redisCommand对象"></a>redisCommand对象</h3><p>redisCommand对象有新旧很多种版本，新旧版本中存在一些区别，例如<code>sflag</code>的内容，我们以新版本为主。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line">    <span class="keyword">char</span> *sflags;   <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> flags; <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * 通常用在Redis Cluster转发过程中 */</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br></pre></td></tr></table></figure><p>command id，是从0开始递增的，作用是检查ACL。一个connection在执行命令前，服务器先要检查第<code>id</code>位有没有设置，如果设置了，说明这个connection有对应的权限。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解释如下：</p><ol><li><code>sflags</code>是字符串格式的，表示这个命令的一些特性<br> <a href="https://segmentfault.com/a/1190000017104165" target="_blank" rel="noopener">例如</a>：<br> write对应CMD_WRITE<br> read-only对应CMD_READONLY</li><li><code>flags</code>是通过<code>populateCommandTableParseFlags</code><strong>从<code>sflags</code>生成的二进制表示</strong>。详见server.h中的<code>CMD_</code>定义，我们在下面会讲解。</li><li>下面是key三元组：<code>firstkey</code>表示第一个key参数的位置，<code>lastkey</code>表示最后一个key参数的位置，<code>keystep</code>表示key参数步长。通过上面三个参数，可以拿到所有的key。通常发生在<code>getKeysFromCommand</code>到<code>getKeysUsingCommandTable</code>函数调用链中。引入这个三元组的目的是有一些指令（如<code>mset</code>和<code>msetnx</code>的<code>keystep</code>取2）是支持在一个命令中对多个key/value对进行赋值的。我们需要注意的是诸如<code>ZADD</code>的指令虽然可以同时添加很多个<code>(score, member)</code>对，但是实际上他们是对一个key添加的，所以它们的三元组都是1。</li><li><code>getkeys_proc</code>表示<a href="https://developer.aliyun.com/article/754089" target="_blank" rel="noopener">从命令中判断命令的key</a>，实际上就是当<code>firstkey</code>、<code>lastkey</code>和<code>keystep</code>不能描述的时候，就会用到这个，返回一个<code>int*</code>表示所有key。例如后面举的eval的例子。</li><li><code>microseconds</code>表示该命令的调用总时间</li><li><code>calls</code>表示该命令的调用总次数</li><li><code>id</code>是在运行时给每个指令分配的id</li></ol><h4 id="flags枚举"><a href="#flags枚举" class="headerlink" title="flags枚举"></a>flags枚举</h4><p>从sflags可以解析得到flags，枚举如下：</p><ol><li><code>CMD_WRITE (1ULL&lt;&lt;0)</code></li><li><code>CMD_READONLY (1ULL&lt;&lt;1)</code><br> 对应read-only，一般包括所有的非特殊的命令，例如返回keys的值，或者返回一些其他信息，例如TIME等。诸如admin、transaction相关的信息，也不会被标记为readonly，因为他们会影响服务器状态。<br> 只读命令和非只读命令在主从复制时，<a href="https://luoming1224.github.io/2019/04/08/[redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0]redis%E4%B8%ADGeo%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">是不一样的</a>。</li><li><code>CMD_DENYOOM (1ULL&lt;&lt;2)</code><br> 对应use-memory，表示这个命令可能导致内存增加。需要在发生OOM的时候拒绝掉。</li><li><code>CMD_MODULE (1ULL&lt;&lt;3)</code></li><li><code>CMD_ADMIN (1ULL&lt;&lt;4)</code><br> 对应admin，诸如SAVE或者SHUTDOWN的命令。</li><li><code>CMD_PUBSUB (1ULL&lt;&lt;5)</code><br> SUBSCRIBE、UNSUBSCRIBE</li><li><code>CMD_NOSCRIPT (1ULL&lt;&lt;6)</code><br> 这样的命令不能在lua脚本中使用，例如AUTH、SAVE等。</li><li><code>CMD_RANDOM (1ULL&lt;&lt;7)</code><br> 对应random，有的命令即使在相同的情况下的运行结果也是不确定的，诸如SPOP、RANDOMKEY。</li><li><code>CMD_SORT_FOR_SCRIPT (1ULL&lt;&lt;8)</code><br> 对应to-sort，需要对输出序列进行排序。</li><li><code>CMD_LOADING (1ULL&lt;&lt;9)</code><br> 在服务器启动载入过程中可以执行的命令。如果没标记该项目的命令，启动过程中不能执行。</li><li><code>CMD_STALE (1ULL&lt;&lt;10)</code></li><li><code>CMD_SKIP_MONITOR (1ULL&lt;&lt;11)</code><br> no-monitor，不自动将这个命令propagate到MONITOR。</li><li><code>CMD_SKIP_SLOWLOG (1ULL&lt;&lt;12)</code><br> no-slowlog，不自动将这个命令propagate到slowlog。比如EXEC、AUTH之类的命。</li><li><code>CMD_ASKING (1ULL&lt;&lt;13)</code></li><li><code>CMD_FAST (1ULL&lt;&lt;14)</code><br> 这个命令是O(1)或者O(log(N))复杂度的，他们不会延误执行。注意所有可能导致DEL操作的并不是FAST命令，例如SET。</li><li><code>CMD_NO_AUTH (1ULL&lt;&lt;15)</code></li></ol><h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>我们结合一个具体的定义来了解这个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">redisCommandTable</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"module"</span>,moduleCommand,<span class="number">-2</span>, <span class="comment">// -2表示大于等于2个参数</span></span><br><span class="line">     <span class="string">"admin no-script"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"get"</span>,getCommand,<span class="number">2</span>, <span class="comment">// 这个叫get的指令对应到void getCommand(client *c)，有2个参数</span></span><br><span class="line">     <span class="string">"read-only fast @string"</span>, <span class="comment">// sflags 中是只读的，fast表示命令执行时间超过阈值时，会记录延迟事件。</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// flags</span></span><br><span class="line">     <span class="literal">NULL</span>, <span class="comment">// getkeys_proc</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// firstkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// lastkey</span></span><br><span class="line">     <span class="number">1</span>, <span class="comment">// keystep</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// microseconds</span></span><br><span class="line">     <span class="number">0</span>, <span class="comment">// calls</span></span><br><span class="line">     <span class="number">0</span> <span class="comment">// id</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we can't flag set as fast, since it may perform an</span></span><br><span class="line"><span class="comment">     * implicit DEL of a large key. */</span></span><br><span class="line">    &#123;<span class="string">"set"</span>,setCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"write use-memory @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"setnx"</span>,setnxCommand,<span class="number">3</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @string"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line"></span><br><span class="line">    &#123;<span class="string">"eval"</span>,evalCommand,<span class="number">-3</span>,</span><br><span class="line">     <span class="string">"no-script @scripting"</span>,</span><br><span class="line">     <span class="number">0</span>,</span><br><span class="line">     evalGetKeys, <span class="comment">// eval无法通过key三元组描述，所以这里指定一个特殊的getkeys_proc</span></span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    </span><br><span class="line">    &#123;<span class="string">"zadd"</span>,zaddCommand,<span class="number">-4</span>,</span><br><span class="line">     <span class="string">"write use-memory fast @sortedset"</span>,</span><br><span class="line">     <span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="命令的处理顺序"><a href="#命令的处理顺序" class="headerlink" title="命令的处理顺序"></a>命令的处理顺序</h3><ol><li>call<ol><li>processCommand<ol><li>processCommandAndResetClient<ol><li>processInputBuffer<ol><li>readQueryFromClient</li><li>handleClientsWithPendingReadsUsingThreads</li></ol></li><li>handleClientsWithPendingReadsUsingThreads<ol><li>stopThreadedIO</li><li>beforeSleep</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="processCommand"><a href="#processCommand" class="headerlink" title="processCommand"></a>processCommand</h3><p>这个函数很复杂：</p><ol><li>通过call执行命令</li><li>准备从客户端进行一次读取</li></ol><p>返回<code>C_OK</code>表示这个客户端还存在，否则表示这个客户端没了。</p><p>首先需要特别处理quit命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    moduleCallCommandFilters(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The QUIT command is handled separately. Normal command procs will</span></span><br><span class="line"><span class="comment">     * go through checking for replication and QUIT will cause trouble</span></span><br><span class="line"><span class="comment">     * when FORCE_REPLICATION is enabled and would be implemented in</span></span><br><span class="line"><span class="comment">     * a regular command proc. */</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"quit"</span>)) &#123;</span><br><span class="line">        addReply(c,shared.ok);</span><br><span class="line">        c-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面通过<code>lookupCommand</code>查找对应的命令结构，并处理找不到或者命令格式错误的情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now lookup the command and check ASAP about trivial error conditions</span></span><br><span class="line"><span class="comment"> * such as wrong arity, bad command name and so forth. */</span></span><br><span class="line">c-&gt;cmd = c-&gt;lastcmd = lookupCommand(c-&gt;argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line"><span class="keyword">if</span> (!c-&gt;cmd) &#123;</span><br><span class="line">    sds args = sdsempty();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; c-&gt;argc &amp;&amp; sdslen(args) &lt; <span class="number">128</span>; i++)</span><br><span class="line">        args = sdscatprintf(args, <span class="string">"`%.*s`, "</span>, <span class="number">128</span>-(<span class="keyword">int</span>)sdslen(args), (<span class="keyword">char</span>*)c-&gt;argv[i]-&gt;ptr);</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"unknown command `%s`, with args beginning with: %s"</span>,</span><br><span class="line">        (<span class="keyword">char</span>*)c-&gt;argv[<span class="number">0</span>]-&gt;ptr, args);</span><br><span class="line">    sdsfree(args);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((c-&gt;cmd-&gt;arity &gt; <span class="number">0</span> &amp;&amp; c-&gt;cmd-&gt;arity != c-&gt;argc) ||</span><br><span class="line">           (c-&gt;argc &lt; -c-&gt;cmd-&gt;arity)) &#123;</span><br><span class="line">    rejectCommandFormat(c,<span class="string">"wrong number of arguments for '%s' command"</span>,</span><br><span class="line">        c-&gt;cmd-&gt;name);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断命令的性质，是只读的，还是可写的等性质。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> is_write_command = (c-&gt;cmd-&gt;flags &amp; CMD_WRITE) ||</span><br><span class="line">                       (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_WRITE));</span><br><span class="line"><span class="keyword">int</span> is_denyoom_command = (c-&gt;cmd-&gt;flags &amp; CMD_DENYOOM) ||</span><br><span class="line">                         (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_flags &amp; CMD_DENYOOM));</span><br><span class="line"><span class="keyword">int</span> is_denystale_command = !(c-&gt;cmd-&gt;flags &amp; CMD_STALE) ||</span><br><span class="line">                           (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_STALE));</span><br><span class="line"><span class="keyword">int</span> is_denyloading_command = !(c-&gt;cmd-&gt;flags &amp; CMD_LOADING) ||</span><br><span class="line">                             (c-&gt;cmd-&gt;proc == execCommand &amp;&amp; (c-&gt;mstate.cmd_inv_flags &amp; CMD_LOADING));</span><br></pre></td></tr></table></figure><p>进行auth和ACL检查。<br>auth也就是登录状态检查。<br>ACL，即Access Control List，有一系列条件规则组成，用来具体控制某些用户是否可以运行某些命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Check if the user is authenticated. This check is skipped in case</span></span><br><span class="line"><span class="comment">     * the default user is flagged as "nopass" and is active. */</span></span><br><span class="line">    <span class="keyword">int</span> auth_required = (!(DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS) ||</span><br><span class="line">                          (DefaultUser-&gt;flags &amp; USER_FLAG_DISABLED)) &amp;&amp;</span><br><span class="line">                        !c-&gt;authenticated;</span><br><span class="line">    <span class="keyword">if</span> (auth_required) &#123;</span><br><span class="line">        <span class="comment">/* AUTH and HELLO and no auth modules are valid even in</span></span><br><span class="line"><span class="comment">         * non-authenticated state. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;cmd-&gt;flags &amp; CMD_NO_AUTH)) &#123;</span><br><span class="line">            rejectCommand(c,shared.noautherr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the user can run this command according to the current</span></span><br><span class="line"><span class="comment">     * ACLs. */</span></span><br><span class="line">    <span class="keyword">int</span> acl_keypos;</span><br><span class="line">    <span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line">    <span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">        addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (acl_retval == ACL_DENIED_CMD)</span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to run "</span></span><br><span class="line">                <span class="string">"the '%s' command or its subcommand"</span>, c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-NOPERM this user has no permissions to access "</span></span><br><span class="line">                <span class="string">"one of the keys used as arguments"</span>);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>如果启用了Redis Cluster，就要进行转发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* If cluster is enabled perform the cluster redirection here.</span></span><br><span class="line"><span class="comment">     * However we don't perform the redirection if:</span></span><br><span class="line"><span class="comment">     * 1) The sender of this command is our master.</span></span><br><span class="line"><span class="comment">     * 2) The command has no key arguments. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_LUA &amp;&amp;</span><br><span class="line">          server.lua_caller-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        !(!cmdHasMovableKeys(c-&gt;cmd) &amp;&amp; c-&gt;cmd-&gt;firstkey == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != execCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> hashslot;</span><br><span class="line">        <span class="keyword">int</span> error_code;</span><br><span class="line">        clusterNode *n = getNodeByQuery(c,c-&gt;cmd,c-&gt;argv,c-&gt;argc,</span><br><span class="line">                                        &amp;hashslot,&amp;error_code);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="literal">NULL</span> || n != server.cluster-&gt;myself) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == execCommand) &#123;</span><br><span class="line">                discardTransaction(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flagTransaction(c);</span><br><span class="line">            &#125;</span><br><span class="line">            clusterRedirectClient(c,n,hashslot,error_code);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>处理oom相关行为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Handle the maxmemory directive.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that we do not want to reclaim memory if we are here re-entering</span></span><br><span class="line"><span class="comment">     * the event loop since there is a busy Lua script running in timeout</span></span><br><span class="line"><span class="comment">     * condition, to avoid mixing the propagation of scripts with the</span></span><br><span class="line"><span class="comment">     * propagation of DELs due to eviction. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory &amp;&amp; !server.lua_timedout) &#123;</span><br><span class="line">        <span class="keyword">int</span> out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;</span><br><span class="line">        <span class="comment">/* freeMemoryIfNeeded may flush slave output buffers. This may result</span></span><br><span class="line"><span class="comment">         * into a slave, that may be the active client, to be freed. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.current_client == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> reject_cmd_on_oom = is_denyoom_command;</span><br><span class="line">        <span class="comment">/* If client is in MULTI/EXEC context, queuing may consume an unlimited</span></span><br><span class="line"><span class="comment">         * amount of memory, so we want to stop that.</span></span><br><span class="line"><span class="comment">         * However, we never want to reject DISCARD, or even EXEC (unless it</span></span><br><span class="line"><span class="comment">         * contains denied commands, in which case is_denyoom_command is already</span></span><br><span class="line"><span class="comment">         * set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != execCommand &amp;&amp;</span><br><span class="line">            c-&gt;cmd-&gt;proc != discardCommand) &#123;</span><br><span class="line">            reject_cmd_on_oom = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (out_of_memory &amp;&amp; reject_cmd_on_oom) &#123;</span><br><span class="line">            rejectCommand(c, shared.oomerr);</span><br><span class="line">            <span class="keyword">return</span> C_OK;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Save out_of_memory result at script start, otherwise if we check OOM</span></span><br><span class="line"><span class="comment">         * untill first write within script, memory used by lua stack and</span></span><br><span class="line"><span class="comment">         * arguments might interfere. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;cmd-&gt;proc == evalCommand || c-&gt;cmd-&gt;proc == evalShaCommand) &#123;</span><br><span class="line">            server.lua_oom = out_of_memory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure to use a reasonable amount of memory for client side</span></span><br><span class="line"><span class="comment">     * caching metadata. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.tracking_clients) trackingLimitUsedSlots();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are problems persisting on disk</span></span><br><span class="line"><span class="comment">     * and if this is a master instance. */</span></span><br><span class="line">    <span class="keyword">int</span> deny_write_type = writeCommandsDeniedByDiskError();</span><br><span class="line">    <span class="keyword">if</span> (deny_write_type != DISK_ERROR_TYPE_NONE &amp;&amp;</span><br><span class="line">        server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        (is_write_command ||c-&gt;cmd-&gt;proc == pingCommand))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deny_write_type == DISK_ERROR_TYPE_RDB)</span><br><span class="line">            rejectCommand(c, shared.bgsaveerr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            rejectCommandFormat(c,</span><br><span class="line">                <span class="string">"-MISCONF Errors writing to the AOF file: %s"</span>,</span><br><span class="line">                strerror(server.aof_last_write_errno));</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if there are not enough good slaves and</span></span><br><span class="line"><span class="comment">     * user configured the min-slaves-to-write option. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_to_write &amp;&amp;</span><br><span class="line">        server.repl_min_slaves_max_lag &amp;&amp;</span><br><span class="line">        is_write_command &amp;&amp;</span><br><span class="line">        server.repl_good_slaves_count &lt; server.repl_min_slaves_to_write)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.noreplicaserr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't accept write commands if this is a read only slave. But</span></span><br><span class="line"><span class="comment">     * accept write commands if this is our master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ro &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp;</span><br><span class="line">        is_write_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.roslaveerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow a subset of commands in the context of Pub/Sub if the</span></span><br><span class="line"><span class="comment">     * connection is in RESP2 mode. With RESP3 there are no limits. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_PUBSUB &amp;&amp; c-&gt;resp == <span class="number">2</span>) &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != pingCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != subscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != unsubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != psubscribeCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != punsubscribeCommand) &#123;</span><br><span class="line">        rejectCommandFormat(c,</span><br><span class="line">            <span class="string">"Can't execute '%s': only (P)SUBSCRIBE / "</span></span><br><span class="line">            <span class="string">"(P)UNSUBSCRIBE / PING / QUIT are allowed in this context"</span>,</span><br><span class="line">            c-&gt;cmd-&gt;name);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Only allow commands with flag "t", such as INFO, SLAVEOF and so on,</span></span><br><span class="line"><span class="comment">     * when slave-serve-stale-data is no and we are a slave with a broken</span></span><br><span class="line"><span class="comment">     * link with master. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        server.repl_serve_stale_data == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        is_denystale_command)</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.masterdownerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loading DB? Return an error if the command has not the</span></span><br><span class="line"><span class="comment">     * CMD_LOADING flag. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; is_denyloading_command) &#123;</span><br><span class="line">        rejectCommand(c, shared.loadingerr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lua script too slow? Only allow a limited number of commands.</span></span><br><span class="line"><span class="comment">     * Note that we need to allow the transactions commands, otherwise clients</span></span><br><span class="line"><span class="comment">     * sending a transaction with pipelining without error checking, may have</span></span><br><span class="line"><span class="comment">     * the MULTI plus a few initial commands refused, then the timeout</span></span><br><span class="line"><span class="comment">     * condition resolves, and the bottom-half of the transaction gets</span></span><br><span class="line"><span class="comment">     * executed, see Github PR #7022. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.lua_timedout &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != authCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != helloCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != replconfCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != multiCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != watchCommand &amp;&amp;</span><br><span class="line">          c-&gt;cmd-&gt;proc != unwatchCommand &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == shutdownCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'n'</span>) &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;proc == scriptCommand &amp;&amp;</span><br><span class="line">          c-&gt;argc == <span class="number">2</span> &amp;&amp;</span><br><span class="line">          <span class="built_in">tolower</span>(((<span class="keyword">char</span>*)c-&gt;argv[<span class="number">1</span>]-&gt;ptr)[<span class="number">0</span>]) == <span class="string">'k'</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        rejectCommand(c, shared.slowscripterr);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面才是真正的执行，对于非multi，会调用call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Exec the command */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p><code>call</code>就是调用指令的函数，有一系列的flag：</p><ol><li><code>CMD_CALL_NONE</code></li><li><code>CMD_CALL_SLOWLOG</code><br> 检查指令执行的速度，是否记录到slow log中呢？</li><li><code>CMD_CALL_STATS</code><br> Populate command stats.</li><li><code>CMD_CALL_PROPAGATE_AOF</code><br> 如果对数据有改动（可以通过<code>server.dirty</code>字段看出），或者client有一个强迫propagate的<code>CLIENT_FORCE_AOF</code>，就加到AOF上。<br> 相应的，如果client设置了<code>CLIENT_PREVENT_AOF_PROP</code>，那么即使数据集变动了，也不会写AOF。<br> 注意，无论client设置了什么，如果没有<code>CMD_CALL_PROPAGATE_AOF</code>，那么永远不会写AOF。</li><li><code>CMD_CALL_PROPAGATE_REPL</code><br> 同理，但是对Slave。同样有<code>CLIENT_FORCE_REPL</code>/<code>CLIENT_PREVENT_REPL_PROP</code>。</li><li><code>CMD_CALL_PROPAGATE</code><br> 相当于<code>PROPAGATE_AOF|PROPAGATE_REPL</code></li><li><code>CMD_CALL_FULL</code><br> 相当于<code>SLOWLOG|STATS|PROPAGATE</code></li></ol><p><code>call</code>主要就是用<code>c-&gt;cmd-&gt;proc(c)</code>执行命令，后者实际上就是<code>xxxCommand()</code>这样的命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;</span><br><span class="line">    <span class="keyword">ustime_t</span> start, duration;</span><br><span class="line">    <span class="keyword">int</span> client_old_flags = c-&gt;flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">real_cmd</span> = <span class="title">c</span>-&gt;<span class="title">cmd</span>;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>fixed_time_expire</code>在expire机制中见到过的，如果有命令在执行过程中，这个值就不是0。<br>还会把除了ADMIN之外的命令发送给MONITOR，ADMIN命令展示出来太危险了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.fixed_time_expire++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the command to clients in MONITOR mode if applicable.</span></span><br><span class="line"><span class="comment">     * Administrative commands are considered too dangerous to be shown. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp;</span><br><span class="line">        !server.loading &amp;&amp;</span><br><span class="line">        !(c-&gt;cmd-&gt;flags &amp; (CMD_SKIP_MONITOR|CMD_ADMIN)))</span><br><span class="line">    &#123;</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些初始化和执行工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Initialization: clear the flags that must be set by the command on</span></span><br><span class="line"><span class="comment">     * demand, and initialize the array for additional commands propagation. */</span></span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">    redisOpArray prev_also_propagate = server.also_propagate;</span><br><span class="line">    redisOpArrayInit(&amp;server.also_propagate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the command. */</span></span><br><span class="line">    dirty = server.dirty;</span><br><span class="line">    updateCachedTime(<span class="number">0</span>);</span><br><span class="line">    start = server.ustime;</span><br><span class="line">    c-&gt;cmd-&gt;proc(c);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在执行后，统计数据库被修改的次数<code>dirty</code>。在<a href="/2018/07/23/redis_learn_object/">《Redis底层对象实现原理分析》</a>中看到，比如我新加一个元素，或者修改一个元素，都会导致<code>dirty</code>增加。也就对应了数据的改变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    duration = ustime()-start;</span><br><span class="line">    dirty = server.dirty-dirty;</span><br><span class="line">    <span class="keyword">if</span> (dirty &lt; <span class="number">0</span>) dirty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When EVAL is called loading the AOF we don't want commands called</span></span><br><span class="line"><span class="comment">     * from Lua to go into the slowlog or to populate statistics. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading &amp;&amp; c-&gt;flags &amp; CLIENT_LUA)</span><br><span class="line">        flags &amp;= ~(CMD_CALL_SLOWLOG | CMD_CALL_STATS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the caller is Lua, we want to force the EVAL caller to propagate</span></span><br><span class="line"><span class="comment">     * the script if the command flag or client flag are forcing the</span></span><br><span class="line"><span class="comment">     * propagation. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)</span><br><span class="line">            server.lua_caller-&gt;flags |= CLIENT_FORCE_AOF;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>记录延迟信息，并记录slowlog。其中<code>latencyAddSampleIfNeeded</code>在适当的时候调用<code>latencyAddSample</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Log the command into the Slow log if needed, and populate the</span></span><br><span class="line"><span class="comment">     * per-command statistics that we show in INFO commandstats. */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_SLOWLOG &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_SKIP_SLOWLOG)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *latency_event = (c-&gt;cmd-&gt;flags &amp; CMD_FAST) ?</span><br><span class="line">                              <span class="string">"fast-command"</span> : <span class="string">"command"</span>;</span><br><span class="line">        latencyAddSampleIfNeeded(latency_event,duration/<span class="number">1000</span>);</span><br><span class="line">        slowlogPushEntryIfNeeded(c,c-&gt;argv,c-&gt;argc,duration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_STATS) &#123;</span><br><span class="line">        <span class="comment">/* use the real command that was executed (cmd and lastamc) may be</span></span><br><span class="line"><span class="comment">         * different, in case of MULTI-EXEC or re-written commands such as</span></span><br><span class="line"><span class="comment">         * EXPIRE, GEOADD, etc. */</span></span><br><span class="line">        real_cmd-&gt;microseconds += duration;</span><br><span class="line">        real_cmd-&gt;calls++;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理propagate的情况，这个对应了<code>CALL_</code>开头的一些规则，就不详解了。最终会计算得到一个<code>propagate_flags</code>传给<code>propagate</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp;</span><br><span class="line">        (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the command operated changes in the data set. If so</span></span><br><span class="line"><span class="comment">         * set for replication / AOF propagation. */</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client forced AOF / replication of the command, set</span></span><br><span class="line"><span class="comment">         * the flags regardless of the command effects on the data set. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF) propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* However prevent AOF / replication propagation if the command</span></span><br><span class="line"><span class="comment">         * implementations called preventCommandPropagation() or similar,</span></span><br><span class="line"><span class="comment">         * or if we don't have the call() flags to do so. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP ||</span><br><span class="line">            !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">                propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call propagate() only if at least one of AOF / replication</span></span><br><span class="line"><span class="comment">         * propagation is needed. Note that modules commands handle replication</span></span><br><span class="line"><span class="comment">         * in an explicit way, so we never replicate them automatically. */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在结束之后，我们需要还原一下有关propagate的相关flag，因为<code>call</code>可能被递归调用。<br>【Q】我觉得这里一个典型的例子就是这里的multi、exec。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Restore the old replication flags, since call() can be executed</span></span><br><span class="line"><span class="comment"> * recursively. */</span></span><br><span class="line">c-&gt;flags &amp;= ~(CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br><span class="line">c-&gt;flags |= client_old_flags &amp;</span><br><span class="line">    (CLIENT_FORCE_AOF|CLIENT_FORCE_REPL|CLIENT_PREVENT_PROP);</span><br></pre></td></tr></table></figure><p><code>alsoPropagate</code>函数可以往<code>server.also_propagate</code>里面加一些其他的op。下面就处理<code>alsoPropagate</code>的逻辑，也就是当propagate完当前的命令之后，还可以再去propagate一些命令。并且这些命令不被<code>CLIENT_PREVENT_PROP</code>影响。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.also_propagate.numops) &#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    redisOp *rop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE) &#123;</span><br><span class="line">        <span class="keyword">int</span> multi_emitted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>如果说已经被包在了MULTI里面，就不在继续包在<code>also_propagate</code>里面propagate了。<br><code>execCommandPropagateMulti</code>实际上就是下面的propagate调用。这里的<code>shared.multi</code>或者<code>shared.exec</code>实际上是缓存的字符串对象<code>EXEC</code>和<code>MULTI</code>，减少频繁的内存分配的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateMulti</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.multiCommand,c-&gt;db-&gt;id,&amp;shared.multi,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommandPropagateExec</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    propagate(server.execCommand,c-&gt;db-&gt;id,&amp;shared.exec,<span class="number">1</span>,</span><br><span class="line">              PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是做propagate。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="comment">/* Wrap the commands in server.also_propagate array,</span></span><br><span class="line"><span class="comment">             * but don't wrap it if we are already in MULTI context,</span></span><br><span class="line"><span class="comment">             * in case the nested MULTI/EXEC.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * And if the array contains only one command, no need to</span></span><br><span class="line"><span class="comment">             * wrap it, since the single command is atomic. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.also_propagate.numops &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">                !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE) &amp;&amp;</span><br><span class="line">                !(c-&gt;flags &amp; CLIENT_MULTI) &amp;&amp;</span><br><span class="line">                !(flags &amp; CMD_CALL_NOWRAP))</span><br><span class="line">            &#123;</span><br><span class="line">                execCommandPropagateMulti(c);</span><br><span class="line">                multi_emitted = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.also_propagate.numops; j++) &#123;</span><br><span class="line">                rop = &amp;server.also_propagate.ops[j];</span><br><span class="line">                <span class="keyword">int</span> target = rop-&gt;target;</span><br><span class="line">                <span class="comment">/* Whatever the command wish is, we honor the call() flags. */</span></span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_AOF)) target &amp;= ~PROPAGATE_AOF;</span><br><span class="line">                <span class="keyword">if</span> (!(flags&amp;CMD_CALL_PROPAGATE_REPL)) target &amp;= ~PROPAGATE_REPL;</span><br><span class="line">                <span class="keyword">if</span> (target)</span><br><span class="line">                    propagate(rop-&gt;cmd,rop-&gt;dbid,rop-&gt;argv,rop-&gt;argc,target);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (multi_emitted) &#123;</span><br><span class="line">                execCommandPropagateExec(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        redisOpArrayFree(&amp;server.also_propagate);</span><br><span class="line">    &#125;</span><br><span class="line">    server.also_propagate = prev_also_propagate;</span><br></pre></td></tr></table></figure><p>这个应该是和客户端缓存有关的，如果client提供了keys tracking功能，要通知。这个函数里面维护了一个tracking invalidation表，这样客户端会收到一个invalidation信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* If the client has keys tracking enabled for client side caching,</span></span><br><span class="line"><span class="comment">     * make sure to remember the keys it fetched via this command. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;cmd-&gt;flags &amp; CMD_READONLY) &#123;</span><br><span class="line">        client *caller = (c-&gt;flags &amp; CLIENT_LUA &amp;&amp; server.lua_caller) ?</span><br><span class="line">                            server.lua_caller : c;</span><br><span class="line">        <span class="keyword">if</span> (caller-&gt;flags &amp; CLIENT_TRACKING &amp;&amp;</span><br><span class="line">            !(caller-&gt;flags &amp; CLIENT_TRACKING_BCAST))</span><br><span class="line">        &#123;</span><br><span class="line">            trackingRememberKeys(caller);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.fixed_time_expire--;</span><br><span class="line">    server.stat_numcommands++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除逻辑实现"><a href="#删除逻辑实现" class="headerlink" title="删除逻辑实现"></a>删除逻辑实现</h1><p>为了理解下面论述中涉及到的expire相关实现，我们需要先介绍一些<code>UNLINK</code>和<code>DEL</code>的实现。<br>delGenericCommand的实现是比较Legacy的，从<code>c-&gt;argv</code>中读取所有需要被删除的key，然后调用dbAsyncDelete或者dbSyncDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This command implements DEL and LAZYDEL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numdel = <span class="number">0</span>, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        expireIfNeeded(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">int</span> deleted  = lazy ? dbAsyncDelete(c-&gt;db,c-&gt;argv[j]) :</span><br><span class="line">                              dbSyncDelete(c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">        <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>容易发现，删除有两种模式：异步(lazy)删除和同步删除。异步删除的情况包括：</p><ol><li>delete逻辑<ol><li><code>delGenericCommand</code>中传入lazy<br> 如果是unlink命令，那么一定是异步删除。<br> 如果是del命令，则取决于<code>server.lazyfree_lazy_user_del</code>。</li><li><code>dbDelete</code>中设置了<code>server.lazyfree_lazy_server_del</code></li></ol></li><li>expire逻辑<ol><li><code>expireIfNeeded</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应了Redis的lazy过期策略。</li><li><code>activeExpireCycleTryExpire</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 对应着Redis的定期循环，主动过期策略。</li><li><code>expireGenericCommand</code>中如果设置<code>server.lazyfree_lazy_expire</code>，则使用异步删除<br> 直接运行expire命令，主动检查一下有没有过期。</li></ol></li><li>evict逻辑<ol><li><code>freeMemoryIfNeeded</code>中如果设置<code>server.lazyfree_lazy_eviction</code>，则使用异步删除</li></ol></li><li>其他<ol><li><code>RM_UnlinkKey</code></li></ol></li></ol><p>这些<code>lazyfree_lazy_</code>开头的配置，默认都是0。也就是说这些情况下默认都是同步删除。</p><p>同步删除的情况类似，除了“其他”中发生了变化：</p><ol><li>其他<ol><li><code>rdbLoadRio</code></li></ol></li></ol><p>下面的代码会进行事件通知，我们将专门进行介绍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【续】delGenericCommand函数</span></span><br><span class="line">...</span><br><span class="line">            signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">                <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">            server.dirty++;</span><br><span class="line">            numdel++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,numdel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>del和unlink的唯一区别是，unlink一定是lazy删除的，但是del取决于配置<code>lazyfree_lazy_user_del</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,server.lazyfree_lazy_user_del);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlinkCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    delGenericCommand(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步删除"><a href="#同步删除" class="headerlink" title="同步删除"></a>同步删除</h2><p>看简单的同步实现。<br>首先，如果<code>db-&gt;expires</code>非空，从<code>db-&gt;expires</code>里面删除<code>key</code>，实际上是删除的过期时间。<br>这里有个注释，说从<code>db-&gt;expires</code>中删除一个entry不会释放<code>key-&gt;ptr</code>这个sds，因为它和<code>db-&gt;dict</code>是共享的。这里应该说的是在<code>setExpire</code>里面往<code>db-&gt;expires</code>添加key的时候，加的实际上是指向<code>db-&gt;dict</code>中的指针。<br>但果真是这样的么？继续看<code>dictDelete</code>最终调用<code>dictGenericDelete</code>。查看<code>dictDelete</code>实际上是<code>dictGenericDelete</code>的实现(在“dict的其他相关方法”这个章节中介绍)，发现新版本的代码肯定会调用<code>dictFreeKey</code>(Redis3.0里面有个<code>dictFreeEntryKey</code>，不要混淆了)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbSyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>检查dictFreeKey的实现发现，这个函数调用<code>keyDestructor</code>，它似乎一定会导致对应sds的析构。看上去和上面的注释是矛盾的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dict.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dictFreeKey(d, entry) \</span></span><br><span class="line">    <span class="keyword">if</span> ((d)-&gt;type-&gt;keyDestructor) \</span><br><span class="line">        (d)-&gt;type-&gt;keyDestructor((d)-&gt;privdata, (entry)-&gt;key)</span><br></pre></td></tr></table></figure><p>究竟是怎么回事呢？我们看下keyptrDictType和dbDictType这两个dict类型就有了答案。原来对于<code>db-&gt;expires</code>，它实际的类型就没有设置keyDestructor，所以不会析构key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line">server.db[j].dict = dictCreate(&amp;dbDictType,<span class="literal">NULL</span>);</span><br><span class="line">server.db[j].expires = dictCreate(&amp;keyptrDictType,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;expires */</span></span><br><span class="line">dictType keyptrDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key destructor */</span></span><br><span class="line">    <span class="literal">NULL</span>                        <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Db-&gt;dict, keys are sds strings, vals are Redis objects. */</span></span><br><span class="line">dictType dbDictType = &#123;</span><br><span class="line">    dictSdsHash,                <span class="comment">/* hash function */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* key dup */</span></span><br><span class="line">    <span class="literal">NULL</span>,                       <span class="comment">/* val dup */</span></span><br><span class="line">    dictSdsKeyCompare,          <span class="comment">/* key compare */</span></span><br><span class="line">    dictSdsDestructor,          <span class="comment">/* key destructor */</span></span><br><span class="line">    dictObjectDestructor   <span class="comment">/* val destructor */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以说一下<code>#define DICT_NOTUSED(V) ((void) V)</code>是经典的关闭编译器unused variable warning的办法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictSdsDestructor</span><span class="params">(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DICT_NOTUSED(privdata);</span><br><span class="line"></span><br><span class="line">    sdsfree(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面接着看<code>dbSyncDelete</code>的逻辑，刚才是删除的<code>db-&gt;expires</code>，还需要删除<code>db-&gt;dict</code>。<br>此外<code>server.cluster_enabled</code>的情况进行了额外的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 再从db-&gt;dict里面删除key</span></span><br><span class="line">    <span class="keyword">if</span> (dictDelete(db-&gt;dict,key-&gt;ptr) == DICT_OK) &#123;</span><br><span class="line">        <span class="comment">// Redis Cluster相关函数</span></span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异步删除"><a href="#异步删除" class="headerlink" title="异步删除"></a>异步删除</h2><p>异步删除的核心是调用<code>dictUnlink</code>而不是<code>dictDelete</code>。<br>前面的是大差不差的，删除<code>db-&gt;expires</code>里面的字段，因为他们的dictType不一样，他们的析构行为(<code>keyDestructor</code>)也不一样。这就导致expire可以直接dictDelete。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lazyfree.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Delete a key, value, and associated expiration entry if any, from the DB.</span></span><br><span class="line"><span class="comment"> * If there are enough allocations to free the value object may be put into</span></span><br><span class="line"><span class="comment"> * a lazy free list instead of being freed synchronously. The lazy free list</span></span><br><span class="line"><span class="comment"> * will be reclaimed in a different bio.c thread. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LAZYFREE_THRESHOLD 64</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dbAsyncDelete</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Deleting an entry from the expires dict will not free the sds of</span></span><br><span class="line"><span class="comment">     * the key, because it is shared with the main dictionary. */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) &gt; <span class="number">0</span>) dictDelete(db-&gt;expires,key-&gt;ptr);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面调用<code>dictUnlink</code>而不是<code>dictDelete</code>了。这里注意区别一下<code>dictUnlink</code>和前面提到的UNLINK命令。<code>dictUnlink</code>的作用是将对应的key从dict中删除，但不会释放对应的结构，而是直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">    <span class="comment">/* If the value is composed of a few allocations, to free in a lazy way</span></span><br><span class="line"><span class="comment">     * is actually just slower... So under a certain limit we just free</span></span><br><span class="line"><span class="comment">     * the object synchronously. */</span></span><br><span class="line">    dictEntry *de = dictUnlink(db-&gt;dict,key-&gt;ptr);</span><br></pre></td></tr></table></figure><p>拿到这个<code>de</code>，我们手动来析构。会首先使用<code>lazyfreeGetFreeEffort</code>来计算析构的代价，如果代价过高，就将这个对象放到lazy free list里面让它后台去析构。不然的话就在后面的代码中同步析构，这是因为如果对象很小，那么再搞这一套异步反而更耗时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line">        <span class="keyword">size_t</span> free_effort = lazyfreeGetFreeEffort(val);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先来看lazy的实现，如果算出来值得，那么就lazy。但这里还有个特殊情况我们不能异步删除，根据注释，如果这个对象是被共享的(<code>val-&gt;refcount</code>就是一个大于1的值)，我们不能就直接把它现在就回收掉。这个倒不经常发生，但确实Redis的一些实现代码会用<code>incrRefCount</code>来保护对象，然后调用<code>dbDelete</code>。在这种情况下我们会fall through到下面<code>dictFreeUnlinkedEntry</code>的调用，它的最终效果相当于直接调用<code>decrRefCount</code>。<br>经过了上述的判断，我们就可以使用bioCreateBackgroundJob来异步删除了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD &amp;&amp; val-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">            atomicIncr(lazyfree_objects,<span class="number">1</span>);</span><br><span class="line">            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">            dictSetVal(db-&gt;dict,de,<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就是同步删除的实现。<code>dictFreeUnlinkedEntry</code>这一块就是给之前<code>nofree</code>没做的事情擦一下屁股，包含调用<code>dictFreeKey</code>啥的来释放key和value所占用的内存。<br><code>slotToKeyDel</code>这个是Redis Cluster的实现逻辑，用来算出来这个key在哪个slot上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 续dbAsyncDelete</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* Release the key-val pair, or just the key if we set the val</span></span><br><span class="line"><span class="comment">     * field to NULL in order to lazy free it later. */</span></span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        dictFreeUnlinkedEntry(db-&gt;dict,de);</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) slotToKeyDel(key-&gt;ptr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dict.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dictFreeUnlinkedEntry</span><span class="params">(dict *d, dictEntry *he)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (he == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    dictFreeKey(d, he);</span><br><span class="line">    dictFreeVal(d, he);</span><br><span class="line">    zfree(he);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面涉及的几个函数来讲解一下</p><h3 id="lazyfreeGetFreeEffort"><a href="#lazyfreeGetFreeEffort" class="headerlink" title="lazyfreeGetFreeEffort"></a>lazyfreeGetFreeEffort</h3><p>这个函数计算并返回释放一个对象的代价。返回值不一定是这个对象对应的内存分配次数，但是和这个量成比例的。具体来说：</p><ol><li>对于字符串，函数永远返回1。</li><li>对于用诸如哈希表等数据结构表示的聚合对象，返回组成该对象元素的数量。</li><li>对于只需要一次内存分配就产生的对象，认为是独立的一个对象，即使实际上是由多个造成的。</li><li>对于列表对象，返回quicklist里面的元素数量。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> lazyfreeGetFreeEffort(robj *obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">        quicklist *ql = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> ql-&gt;len;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_SET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br></pre></td></tr></table></figure><p>对于ZSET，如果是跳表实现，就返回跳表的长度。如果是ziplist实现就返回1？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_ZSET &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_SKIPLIST)&#123;</span><br><span class="line">        zset *zs = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> zs-&gt;zsl-&gt;length;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_HASH &amp;&amp; obj-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        dict *ht = obj-&gt;ptr;</span><br><span class="line">        <span class="keyword">return</span> dictSize(ht);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;type == OBJ_STREAM) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> effort = <span class="number">0</span>;</span><br><span class="line">        stream *s = obj-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make a best effort estimate to maintain constant runtime. Every macro</span></span><br><span class="line"><span class="comment">         * node in the Stream is one allocation. */</span></span><br><span class="line">        effort += s-&gt;rax-&gt;numnodes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Every consumer group is an allocation and so are the entries in its</span></span><br><span class="line"><span class="comment">         * PEL. We use size of the first group's PEL as an estimate for all</span></span><br><span class="line"><span class="comment">         * others. */</span></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;cgroups) &#123;</span><br><span class="line">            raxIterator ri;</span><br><span class="line">            streamCG *cg;</span><br><span class="line">            raxStart(&amp;ri,s-&gt;cgroups);</span><br><span class="line">            raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">/* There must be at least one group so the following should always</span></span><br><span class="line"><span class="comment">             * work. */</span></span><br><span class="line">            serverAssert(raxNext(&amp;ri));</span><br><span class="line">            cg = ri.data;</span><br><span class="line">            effort += raxSize(s-&gt;cgroups)*(<span class="number">1</span>+raxSize(cg-&gt;pel));</span><br><span class="line">            raxStop(&amp;ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> effort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* Everything else is a single allocation. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="atomicIncr"><a href="#atomicIncr" class="headerlink" title="atomicIncr"></a>atomicIncr</h3><p>是一个原子操作，更新lazyfree里面的一个static变量<code>lazyfree_objects</code>。根据不同的操作系统的支持，有三种实现：<br>如果支持atomic语义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __atomic_add_fetch(&amp;var,(count),__ATOMIC_RELAXED)</span></span><br></pre></td></tr></table></figure><p>如果有sync语义，一般是gcc的一个内置宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) __sync_add_and_fetch(&amp;var,(count))</span></span><br></pre></td></tr></table></figure><p>如果什么都没有，用mutex，mutex的名字是变量名加上<code>_mutex</code>，这些mutex随着变量名一起被定义，只是可能不会被用到，如lazyfree_objects_mutex。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomicIncr(var,count) do &#123; \</span></span><br><span class="line">    pthread_mutex_lock(&amp;var ## _mutex); \</span><br><span class="line">    var += (count); \</span><br><span class="line">    pthread_mutex_unlock(&amp;var ## _mutex); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="bioCreateBackgroundJob"><a href="#bioCreateBackgroundJob" class="headerlink" title="bioCreateBackgroundJob"></a>bioCreateBackgroundJob</h3><p>所有的bio开头的函数表示Redis的Background IO服务。根据注释，将来也许会迁移到libeio。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictSetVal"><a href="#dictSetVal" class="headerlink" title="dictSetVal"></a>dictSetVal</h3><p>见dict相关</p><h3 id="slotToKeyDel"><a href="#slotToKeyDel" class="headerlink" title="slotToKeyDel"></a>slotToKeyDel</h3><p>见 Redis Cluster 相关</p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>lookUpKey相关方法根据查找目的是读或者写区分了<code>lookupKeyRead</code>、<code>lookupKeyWrite</code>两个方向的函数，此外还根据是否<code>WithFlags</code>或者<code>OrReply</code>派生出其他几种函数。</p><p>对于<code>lookupKeyWrite</code>来讲，有一个副作用，就是会先检查一下要不要expire，如果需要就直接expire掉。<br>对于<code>lookupKeyRead</code>来讲，也要处理expire的问题，但是因为涉及到主从复制的问题，所以要进行额外处理。【Q】为什么不需要对写处理呢？我想应该是因为只有Master处理写，处理完再发指令给Slave。</p><p>直接介绍带Flags的版本。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyRead</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyReadWithFlags(db,key,LOOKUP_NONE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWrite</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lookupKeyWriteWithFlags(db, key, LOOKUP_NONE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WithFlags</code>目前只包含了<code>LOOKUP_NONE</code>和<code>LOOKUP_NOTOUCH</code>两个选项。：</p><ol><li><code>LOOKUP_NONE</code></li><li><code>LOOKUP_NOTOUCH</code><br> 表示这次访问不要更新LRU啥的，例如type这样的命令就带上这个参数。</li></ol><h2 id="lookupKeyReadWithFlags"><a href="#lookupKeyReadWithFlags" class="headerlink" title="lookupKeyReadWithFlags"></a>lookupKeyReadWithFlags</h2><p>下面查看<code>lookupKeyReadWithFlags</code>的实现，相比于写要复杂点，因为要处理键过期的时候读的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">lookupKeyReadWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expireIfNeeded(db,key) == <span class="number">1</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Master的<code>masterhost</code>肯定是NULL，这是一个经典判定。首先考虑Master的情况，如果key过期了，那么就直接安全地返回NULL，并且触发一个keymiss事件。这里注释上说在Master情况下，<code>expireIfNeeded</code>返回0当且只当这个key不存在。<br>为什么强调Master呢，实际上可以结合<code>expireIfNeeded</code>的实现来看。提前说一下，<strong>对Slave而言</strong>，<code>expireIfNeeded</code>并<strong>不会真的让key过期并删除</strong>，而只是返回key在逻辑上是过期的，而真正的过期是由Master来同步的，其目的是保持Slave和Master的一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Key expired. If we are in the context of a master, expireIfNeeded()</span></span><br><span class="line"><span class="comment">         * returns 0 only when the key does not exist at all, so it's safe</span></span><br><span class="line"><span class="comment">         * to return NULL ASAP. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>更新统计信息，<code>server.stat_keyspace_misses</code>可以通过<code>INFO keyspace_misses</code>命令来查看。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面是对Master情况的处理，下面是对Slave的情况。我们已经知道，Slave并不会真的删除过期key，而是等待Master的Del指令。所以即使<code>expireIfNeeded</code>返回1表示过期，<br>但根据注释，对Slave而言，作为一个额外的安全措施，如果相关指令是只读的，还是可以在这里安全地返回NULL。Redis的说法是：对于只读命令，这样可以向client提供一个更加一致性的行为。这个会包含GETS，当使用Slave来扩容读的时候。我的理解就是尽管slave上还没有删除，但是过期就是过期，我们要和Master一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.current_client &amp;&amp;</span><br><span class="line">            server.current_client != server.master &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd &amp;&amp;</span><br><span class="line">            server.current_client-&gt;cmd-&gt;flags &amp; CMD_READONLY)</span><br><span class="line">        &#123;</span><br><span class="line">            server.stat_keyspace_misses++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    val = lookupKey(db,key,flags);</span><br><span class="line">    <span class="keyword">if</span> (val == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        server.stat_keyspace_misses++;</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_KEY_MISS, <span class="string">"keymiss"</span>, key, db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        server.stat_keyspace_hits++;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookupKeyWriteWithFlags"><a href="#lookupKeyWriteWithFlags" class="headerlink" title="lookupKeyWriteWithFlags"></a>lookupKeyWriteWithFlags</h2><p>首先查看<code>lookupKeyWriteWithFlags</code>的实现，直接先检查下expire，然后调用<code>lookupKey</code>。这里的<code>expireIfNeeded</code>也是Redis的lazy过期策略的实现，在每次查找的时候都会调用，检查这个键是不是已经过期了。<br>不同于<code>lookupKeyReadWithFlags</code>，这里就不会统计keymiss啥的了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* Lookup a key for write operations, and as a side effect, if needed, expires</span></span><br><span class="line"><span class="comment"> * the key if its TTL is reached.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns the linked value object if the key exists or NULL if the key</span></span><br><span class="line"><span class="comment"> * does not exist in the specified DB. */</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKeyWriteWithFlags</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    expireIfNeeded(db,key);</span><br><span class="line">    <span class="keyword">return</span> lookupKey(db,key,flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lookUpKey"><a href="#lookUpKey" class="headerlink" title="lookUpKey"></a>lookUpKey</h2><p><code>lookUpKey</code>的主要内容包括从db里面找到对应的key，并且维护LRU或LFU。它是一个较为底层的 API。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="function">robj *<span class="title">lookupKey</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 从db中获得key对应的entry</span></span><br><span class="line">    dictEntry *de = dictFind(db-&gt;dict,key-&gt;ptr);</span><br><span class="line">    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">        <span class="comment">// 如果找到了，就取出val</span></span><br><span class="line">        robj *val = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有设置</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是LRU和LFU的实现，更新每个key的访问情况，从而方便后续evict。详细见有关updateLFU的实现见”Redis的LRU和LFU实现”这一章节。<br>但先要做一些判断：</p><ol><li>如果设置了<code>LOOKUP_NOTOUCH</code>。</li><li>如果有子进程正在进行保存，就不进行LFU操作，以免破坏COW。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">            <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">                updateLFU(val);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                val-&gt;lru = LRU_CLOCK();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h1><h2 id="如何判断键已过期？"><a href="#如何判断键已过期？" class="headerlink" title="如何判断键已过期？"></a>如何判断键已过期？</h2><p>诸如<code>EXPIRE</code>/<code>RENAME</code>等的实现中会调用<code>setExpire</code>函数设置过期时间。<code>setExpire</code>会把每个键的过期时间都被存在<code>db-&gt;expires</code>这个字典里面。<br>通过<code>getExpire</code>可以从字典中读取到过期时间。</p><h3 id="getExpire"><a href="#getExpire" class="headerlink" title="getExpire"></a>getExpire</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return the expire time of the specified key, or -1 if no expire</span></span><br><span class="line"><span class="comment"> * is associated with this key (i.e. the key is non volatile) */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* No expire? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;expires) == <span class="number">0</span> ||</span><br><span class="line">       (de = dictFind(db-&gt;expires,key-&gt;ptr)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The entry was found in the expire dict, this means it should also</span></span><br><span class="line"><span class="comment">     * be present in the main dict (safety check). */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,key,dictFind(db-&gt;dict,key-&gt;ptr) != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> dictGetSignedIntegerVal(de);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="keyIsExpired"><a href="#keyIsExpired" class="headerlink" title="keyIsExpired"></a>keyIsExpired</h3><p>keyIsExpired作用是判断某个键有没有过期。主要功能就是比较现在的时间，和获得的key的过期时间。被expireIfNeeded调用，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if the key is expired. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">keyIsExpired</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面一段代码的目的是：如果在执行lua脚本，将时间设置成脚本执行开始的时间，这样在脚本执行过程中就不会expire。这么做的原因是源自Github上面的<a href="https://github.com/redis/redis/issues/1525" target="_blank" rel="noopener">Issue1525</a>。作者发现这个脚本在Master和Slave上的执行是不一样的。原因是在Master上第一次执行可能key存在，第二次就不存在了。这导致<code>incr</code>实际只被执行了一次。但是因为此时Master会合成一个DEL指令，让Slave也删除并过期这个Key。此时，如果相同的脚本运行在Slave上面，那么<code>incr</code>一次也不会被执行。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"exists"</span>,KEYS[<span class="number">1</span>]) == <span class="number">1</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"incr"</span>,<span class="string">"mycounter"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>为了保障向Slave和AOF的propagate是一致的，首先在执行lua脚本的时候，要禁止expire(就是这里的行为)；但是在执行脚本之前，先要对涉及的key做下<code>expireIfNeeded</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.lua_caller) &#123;</span><br><span class="line">        now = server.lua_time_start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we are in the middle of a command execution, we still want to use</span></span><br><span class="line"><span class="comment">     * a reference time that does not change: in that case we just use the</span></span><br><span class="line"><span class="comment">     * cached time, that we update before each call in the call() function.</span></span><br><span class="line"><span class="comment">     * This way we avoid that commands such as RPOPLPUSH or similar, that</span></span><br><span class="line"><span class="comment">     * may re-open the same key multiple times, can invalidate an already</span></span><br><span class="line"><span class="comment">     * open object in a next call, if the next call will see the key expired,</span></span><br><span class="line"><span class="comment">     * while the first did not. */</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.fixed_time_expire &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        now = server.mstime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* For the other cases, we want to use the most fresh time we have. */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        now = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The key expired if the current (virtual or real) time is greater</span></span><br><span class="line"><span class="comment">     * than the expire time of the key. */</span></span><br><span class="line">    <span class="keyword">return</span> now &gt; when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="expireIfNeeded"><a href="#expireIfNeeded" class="headerlink" title="expireIfNeeded"></a>expireIfNeeded</h2><p><code>expireIfNeeded</code>用来删除过期的键，它是<strong>被动expire</strong>的关键步骤。返回0表示键有效(键未过期，或永不过期)，否则返回1表示已经过期并被删除。<br>对于Master，如果找到的键是expire的，会被从数据库中evict掉。并且会导致想AOF和Slave流propagate一条DEL或者UNLINK指令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* This function is called when we are going to perform some operation</span></span><br><span class="line"><span class="comment"> * in a given key, but such key may be already logically expired even if</span></span><br><span class="line"><span class="comment"> * it still exists in the database. The main way this function is called</span></span><br><span class="line"><span class="comment"> * is via lookupKey*() family of functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>如果没有过期，就返回0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先，通过<code>keyIsExpired</code>检测是不是已经过期了，如果还没有过期，上面就直接返回0了，再往下就是处理过期的情况。<br>根据注释，如果Redis运行在主从模式下，并且是在Slave上，<code>expireIfNeeded</code>直接返回，而不是继续删除键。这是因为Slave上的key过期是由Master控制的，Slave并不直接处理key的过期。Master会发送一个同步的<code>DEL</code>命令给Slave来删除某个键，Slave等到那时候再删除，<strong>这样做的目的是出于一致性的考量</strong>。<br>但尽管如此，对Slave调用<code>expireIfNeeded</code>也应该返回一个正确的值，也就是这个时候键应不应该过期。因此，Slave上是先过期，然后再删除键的，这其中存在一个窗口时间，因为Slave还没有来得及收到并处理Master的<code>DEL</code>。<br>下面肯定对应了已经过期的情况了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面负责通知删除事件，这里还出现了<code>propagateExpire</code>函数，我们也统一在后面讲解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line">    <span class="comment">// 向AOF文件和Slave节点传播过期信息，实际会调用propagate函数</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,<span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是真正的过期删除的过程。这里根据<code>server.lazyfree_lazy_expire</code>的配置，可以选择异步删除或者同步删除，这类似于上面讨论过的<code>UNLINK</code>和<code>DEL</code>的实现。事实上在<code>expireGenericCommand</code>上就可以看到对应的映射关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">int</span> retval = server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key);     </span><br><span class="line">    <span class="keyword">if</span> (retval) signalModifiedKey(<span class="literal">NULL</span>,db,key);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主动expire实现"><a href="#主动expire实现" class="headerlink" title="主动expire实现"></a>主动expire实现</h2><p>在<code>databasesCron</code>可以看到，如果开启了主动expire，并且自己是master，则会定时运行activeExpireCycle。<br>介绍<a href="https://stackoverflow.com/questions/33370047/configuring-redis-expire-algorithm" target="_blank" rel="noopener">参数</a>：<br><code>active_expire_effort</code>默认值为1，表示<a href="https://docs.aws.amazon.com/memorydb/latest/devguide/parametergroups.redis.html" target="_blank" rel="noopener">避免有超过<code>10%</code>的过期key，同时CPU占用不超过25%</a>。<br><code>config_keys_per_loop</code>表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">activeExpireCycle</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span></span><br><span class="line">    effort = server.active_expire_effort<span class="number">-1</span>, <span class="comment">/* Rescale from 0 to 9. */</span></span><br><span class="line">    config_keys_per_loop = ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP +</span><br><span class="line">                           ACTIVE_EXPIRE_CYCLE_KEYS_PER_LOOP/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_fast_duration = ACTIVE_EXPIRE_CYCLE_FAST_DURATION +</span><br><span class="line">                                 ACTIVE_EXPIRE_CYCLE_FAST_DURATION/<span class="number">4</span>*effort,</span><br><span class="line">    config_cycle_slow_time_perc = ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC +</span><br><span class="line">                                  <span class="number">2</span>*effort,</span><br><span class="line">    config_cycle_acceptable_stale = ACTIVE_EXPIRE_CYCLE_ACCEPTABLE_STALE-</span><br><span class="line">                                    effort;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是几个全局变量：</p><ol><li>timelimit_exit表示是否已经超时了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* This function has some global state in order to continue the work</span></span><br><span class="line"><span class="comment">     * incrementally across calls. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> current_db = <span class="number">0</span>; <span class="comment">/* Last DB tested. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> timelimit_exit = <span class="number">0</span>;      <span class="comment">/* Time limit hit in previous call? */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> last_fast_cycle = <span class="number">0</span>; <span class="comment">/* When last fast cycle ran. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j, iteration = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> dbs_per_call = CRON_DBS_PER_CALL;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start = ustime(), timelimit, elapsed;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>如果所有的clients停止了，那么我们的主动expire循环也要停止，从而保持数据库是静态的。没搞懂为啥这么设计。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* When clients are paused the dataset should be static not just from the</span></span><br><span class="line"><span class="comment">     * POV of clients not being able to write, but also from the POV of</span></span><br><span class="line"><span class="comment">     * expires and evictions of keys not being performed. */</span></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里，Redis的主动过期策略分为了fast和slow两个模式。第一种在key比较少的情况下尝试是用较少的cpu，一旦这些过期的键的数量小于某个给定值，就退出。第二种更激进一点，以减少内存占用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST) &#123;</span><br><span class="line">        <span class="comment">/* Don't start a fast cycle if the previous cycle did not exit</span></span><br><span class="line"><span class="comment">         * for time limit, unless the percentage of estimated stale keys is</span></span><br><span class="line"><span class="comment">         * too high. Also never repeat a fast cycle for the same period</span></span><br><span class="line"><span class="comment">         * as the fast cycle total duration itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (!timelimit_exit &amp;&amp;</span><br><span class="line">            server.stat_expired_stale_perc &lt; config_cycle_acceptable_stale)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; last_fast_cycle + (<span class="keyword">long</span> <span class="keyword">long</span>)config_cycle_fast_duration*<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        last_fast_cycle = start;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>每次扫多少db呢？默认<code>dbs_per_call</code>为CRON_DBS_PER_CALL，即16：</p><ol><li><code>dbs_per_call</code>不能超过总的db数。</li><li>如果<code>timelimit_exit</code>，需要扫描全部db<br> 我的理解是如果上次active expire都超时了，说明肯定有很多expire key等待清理，我们全部做一遍，以免占用太多内存。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We usually should test CRON_DBS_PER_CALL per iteration, with</span></span><br><span class="line"><span class="comment">     * two exceptions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Don't test more DBs than we have.</span></span><br><span class="line"><span class="comment">     * 2) If last time we hit the time limit, we want to scan all DBs</span></span><br><span class="line"><span class="comment">     * in this iteration, as there is work to do in some DB and we don't want</span></span><br><span class="line"><span class="comment">     * expired keys to use memory for too much time. */</span></span><br><span class="line">    <span class="keyword">if</span> (dbs_per_call &gt; server.dbnum || timelimit_exit)</span><br><span class="line">        dbs_per_call = server.dbnum;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在这里通过计算耗时，来限制active expire循环对CPU的占用。默认CPU限制是ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC。我们最多在这个函数中只能用timelimit这么多<strong>微秒</strong>。<code>server.hz</code>指的是表示一秒钟被触发多少次，<code>config_cycle_slow_time_perc</code>是个CPU的百分比，也就是每次迭代中只能用<code>config_cycle_slow_time_perc/100</code>这么久。因为每次迭代的耗时是<code>1/server.hz</code>秒，即<code>1000000/server.hz</code>微秒。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We can use at max 'config_cycle_slow_time_perc' percentage of CPU</span></span><br><span class="line"><span class="comment">     * time per iteration. Since this function gets called with a frequency of</span></span><br><span class="line"><span class="comment">     * server.hz times per second, the following is the max amount of</span></span><br><span class="line"><span class="comment">     * microseconds we can spend in this function. */</span></span><br><span class="line">    timelimit = config_cycle_slow_time_perc*<span class="number">1000000</span>/server.hz/<span class="number">100</span>;</span><br><span class="line">    timelimit_exit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (timelimit &lt;= <span class="number">0</span>) timelimit = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == ACTIVE_EXPIRE_CYCLE_FAST)</span><br><span class="line">        timelimit = config_cycle_fast_duration; <span class="comment">/* in microseconds. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accumulate some global stats as we expire keys, to have some idea</span></span><br><span class="line"><span class="comment">     * about the number of keys that are already logically expired, but still</span></span><br><span class="line"><span class="comment">     * existing inside the database. */</span></span><br><span class="line">    <span class="keyword">long</span> total_sampled = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> total_expired = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>外层的循环，遍历所有的数据库。如果<code>timelimit_exit</code>为1，说明内层循环中已经发现执行超时了，外层循坏也退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; dbs_per_call &amp;&amp; timelimit_exit == <span class="number">0</span>; j++) &#123;</span><br><span class="line">        <span class="comment">/* Expired and checked in a single loop. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> expired, sampled;</span><br><span class="line"></span><br><span class="line">        redisDb *db = server.db+(current_db % server.dbnum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment the DB now so we are sure if we run out of time</span></span><br><span class="line"><span class="comment">         * in the current DB we'll restart from the next. This allows to</span></span><br><span class="line"><span class="comment">         * distribute the time evenly across DBs. */</span></span><br><span class="line">        current_db++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>内层的循环，如果每次循环结束，还是有很高的没有处理的过期的key，就需要继续做。但我们也不能一直这么做下去，所以每过16次，就会检查是否超过timelimit。如果是的话，就设置timelimit_exit为1，然后退出当前循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> num, slots;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> now, ttl_sum;</span><br><span class="line">            <span class="keyword">int</span> ttl_samples;</span><br><span class="line">            iteration++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If there is nothing to expire try next DB ASAP. */</span></span><br><span class="line">            <span class="keyword">if</span> ((num = dictSize(db-&gt;expires)) == <span class="number">0</span>) &#123;</span><br><span class="line">                db-&gt;avg_ttl = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slots = dictSlots(db-&gt;expires);</span><br><span class="line">            now = mstime();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When there are less than 1% filled slots, sampling the key</span></span><br><span class="line"><span class="comment">             * space is expensive, so stop here waiting for better times...</span></span><br><span class="line"><span class="comment">             * The dictionary will be resized asap. */</span></span><br><span class="line">            <span class="keyword">if</span> (num &amp;&amp; slots &gt; DICT_HT_INITIAL_SIZE &amp;&amp;</span><br><span class="line">                (num*<span class="number">100</span>/slots &lt; <span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The main collection cycle. Sample random keys among keys</span></span><br><span class="line"><span class="comment">             * with an expire set, checking for expired ones. */</span></span><br><span class="line">            expired = <span class="number">0</span>;</span><br><span class="line">            sampled = <span class="number">0</span>;</span><br><span class="line">            ttl_sum = <span class="number">0</span>;</span><br><span class="line">            ttl_samples = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 每个db最多抽样这么多个</span></span><br><span class="line">            <span class="keyword">if</span> (num &gt; config_keys_per_loop)</span><br><span class="line">                num = config_keys_per_loop;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Here we access the low level representation of the hash table</span></span><br><span class="line"><span class="comment">             * for speed concerns: this makes this code coupled with dict.c,</span></span><br><span class="line"><span class="comment">             * but it hardly changed in ten years.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Note that certain places of the hash table may be empty,</span></span><br><span class="line"><span class="comment">             * so we want also a stop condition about the number of</span></span><br><span class="line"><span class="comment">             * buckets that we scanned. However scanning for free buckets</span></span><br><span class="line"><span class="comment">             * is very fast: we are in the cache line scanning a sequential</span></span><br><span class="line"><span class="comment">             * array of NULL pointers, so we can scan a lot more buckets</span></span><br><span class="line"><span class="comment">             * than keys in the same time. */</span></span><br><span class="line">            <span class="keyword">long</span> max_buckets = num*<span class="number">20</span>;</span><br><span class="line">            <span class="keyword">long</span> checked_buckets = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (sampled &lt; num &amp;&amp; checked_buckets &lt; max_buckets) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> table = <span class="number">0</span>; table &lt; <span class="number">2</span>; table++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (table == <span class="number">1</span> &amp;&amp; !dictIsRehashing(db-&gt;expires)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> idx = db-&gt;expires_cursor;</span><br><span class="line">                    idx &amp;= db-&gt;expires-&gt;ht[table].sizemask;</span><br><span class="line">                    dictEntry *de = db-&gt;expires-&gt;ht[table].table[idx];</span><br><span class="line">                    <span class="keyword">long</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Scan the current bucket of the current table. */</span></span><br><span class="line">                    checked_buckets++;</span><br><span class="line">                    <span class="keyword">while</span>(de) &#123;</span><br><span class="line">                        <span class="comment">/* Get the next entry now since this entry may get</span></span><br><span class="line"><span class="comment">                         * deleted. */</span></span><br><span class="line">                        dictEntry *e = de;</span><br><span class="line">                        de = de-&gt;next;</span><br><span class="line"></span><br><span class="line">                        ttl = dictGetSignedIntegerVal(e)-now;</span><br><span class="line">                        <span class="keyword">if</span> (activeExpireCycleTryExpire(db,e,now)) expired++;</span><br><span class="line">                        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">/* We want the average TTL of keys yet</span></span><br><span class="line"><span class="comment">                             * not expired. */</span></span><br><span class="line">                            ttl_sum += ttl;</span><br><span class="line">                            ttl_samples++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        sampled++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                db-&gt;expires_cursor++;</span><br><span class="line">            &#125;</span><br><span class="line">            total_expired += expired;</span><br><span class="line">            total_sampled += sampled;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update the average TTL stats for this database. */</span></span><br><span class="line">            <span class="keyword">if</span> (ttl_samples) &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl = ttl_sum/ttl_samples;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Do a simple running average with a few samples.</span></span><br><span class="line"><span class="comment">                 * We just use the current estimate with a weight of 2%</span></span><br><span class="line"><span class="comment">                 * and the previous estimate with a weight of 98%. */</span></span><br><span class="line">                <span class="keyword">if</span> (db-&gt;avg_ttl == <span class="number">0</span>) db-&gt;avg_ttl = avg_ttl;</span><br><span class="line">                db-&gt;avg_ttl = (db-&gt;avg_ttl/<span class="number">50</span>)*<span class="number">49</span> + (avg_ttl/<span class="number">50</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里就是检查并设置timelimit_exit</span></span><br><span class="line">            <span class="keyword">if</span> ((iteration &amp; <span class="number">0xf</span>) == <span class="number">0</span>) &#123; <span class="comment">/* check once every 16 iterations. */</span></span><br><span class="line">                elapsed = ustime()-start;</span><br><span class="line">                <span class="keyword">if</span> (elapsed &gt; timelimit) &#123;</span><br><span class="line">                    timelimit_exit = <span class="number">1</span>;</span><br><span class="line">                    server.stat_expired_time_cap_reached_count++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (sampled == <span class="number">0</span> ||</span><br><span class="line">                 (expired*<span class="number">100</span>/sampled) &gt; config_cycle_acceptable_stale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    elapsed = ustime()-start;</span><br><span class="line">    server.stat_expire_cycle_time_used += elapsed;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"expire-cycle"</span>,elapsed/<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update our estimate of keys existing but yet to be expired.</span></span><br><span class="line"><span class="comment">     * Running average with this sample accounting for 5%. */</span></span><br><span class="line">    <span class="keyword">double</span> current_perc;</span><br><span class="line">    <span class="keyword">if</span> (total_sampled) &#123;</span><br><span class="line">        current_perc = (<span class="keyword">double</span>)total_expired/total_sampled;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        current_perc = <span class="number">0</span>;</span><br><span class="line">    server.stat_expired_stale_perc = (current_perc*<span class="number">0.05</span>)+</span><br><span class="line">                                     (server.stat_expired_stale_perc*<span class="number">0.95</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="propagateExpire"><a href="#propagateExpire" class="headerlink" title="propagateExpire"></a>propagateExpire</h2><p>在前面的代码中，还看到<code>propagateExpire</code>的使用。我们知道，在主从结构下，键实际的expire操作是在Master完成的。在expire之后，Master会发送DEL指令给Slave和AOF，也就是这个函数。<br>在注释中还指出，因为AOF，以及Master到Slave的连接都是保证有序的，所以即使有操作去写已经失效的key，都能保证结果是一致的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    robj *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    argv[<span class="number">0</span>] = lazy ? shared.unlink : shared.del;</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    incrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    propagate(server.delCommand,db-&gt;id,argv,<span class="number">2</span>,PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="propagate机制"><a href="#propagate机制" class="headerlink" title="propagate机制"></a>propagate机制</h1><p>在 expire 中，提到了 <code>propagate</code> 函数，因此这里也顺便介绍一些 propagate 机制。<br>propagate 机制是 Redis 主从复制逻辑的一部分。通常来说，Redis主从复制<a href="http://redisbook.com/preview/replication/replicate-before-2-8.html" target="_blank" rel="noopener">包含两个机制</a>：</p><ol><li>sync/psync<br> 用来处理 sync 和 psync 指令，也就是刚开始来个全量同步，将 Slave 的状态更新至 Master 当前状态。</li><li>propagate<br> 将指令从 Master 同步到 Slave 或者 AOF 文件。</li></ol><p>propagate 机制将特定的指令传播给 AOF 或者 Slave，这些指令有下面几种：</p><ol><li><code>PROPAGATE_NONE</code><br> 压根就不传播。</li><li><code>PROPAGATE_AOF</code><br> 如果开启了 AOF，就传播给 AOF。此时就会调用 AOF 的主入口函数 <code>feedAppendOnlyFile</code>。RDB 和 AOF 机制在专门的文章介绍。</li><li><code>PROPAGATE_REPL</code><br> 传播给 Slave。同样调用 <code>replicationFeedSlaves</code> 函数。</li></ol><p>根据注释，不能够在各个 command 的实现代码中使用这个函数，因为它不会 wrap the resulting commands in MULTI/EXEC，如果需要，应该用 <code>alsoPropagate</code>、<code>preventCommandPropagation</code>、<code>forceCommandPropagation</code> 等。<br>However for functions that need to (also) propagate out of the context of a command execution, for example when serving a blocked client, you want to use propagate().</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves,dbid,argv,argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="evict实现"><a href="#evict实现" class="headerlink" title="evict实现"></a>evict实现</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis对当前执行环节的判断</p><ol><li><code>server.masterhost == NULL</code><br> 常常被用来判断是不是 Master 服务器</li><li><code>server.current_client != server.master</code><br> 根据注释，这是指的服务器的当前客户端，仅用于崩溃报告。</li><li><code>sentinelRedisInstance-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)</code></li><li><code>sentinelRedisInstance-&gt;slave_master_host</code></li></ol><p>大家都知道，Redis里面有下面<a href="https://docs.redislabs.com/latest/rs/administering/database-operations/eviction-policy/" target="_blank" rel="noopener">几种evict policy</a>：</p><ol><li>noeviction<br> 这是默认情况。<br> 内存爆了，就直接报错。</li><li>allkeys-lru<br> 对所有的键做LRU。</li><li>allkeys-lfu<br> 对所有的键做LFU。</li><li>allkeys-random<br> 对所有的key做随机删除。</li><li>volatile-lru/volatile-lfu/volatile-random<br> 这是对有expire的键做对应的操作。</li><li>volatile-ttl<br> 删除剩余生命最短的键。</li></ol><p>而对应的实现，就在<code>freeMemoryIfNeeded</code>中。根据注释，这个函数被定时调用，当发现超出最大使用内存后，就会释放相关内存。如果释放内存成功，或者我们不需要释放内存，那么返回<code>C_OK</code>；如果我们没有能够释放足够的内存，那么返回<code>C_ERR</code>。总之一堆废话。。。其实想了解的是这几个问题：</p><ol><li>如何计算现在已经使用了多少内存？</li><li>如何实现LFU和LRU？</li><li>释放内存会对其他模块产生什么影响？</li></ol><h2 id="LRU和LFU的一般实现及优缺点讨论"><a href="#LRU和LFU的一般实现及优缺点讨论" class="headerlink" title="LRU和LFU的一般实现及优缺点讨论"></a>LRU和LFU的一般实现及优缺点讨论</h2><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>对于 LRU，一个队列就行了，把最近用到的元素放到队列尾部，需要 evict 的时候就弹出头部，一般用双向队列就行。但这样查找一个 Key 就变成 <code>O(n)</code> 的了，但这也不难，只需要用一个 map 记录一下对应元素在队列中的位置就行。也就是说，用hash+双向链表来维护。hash 用来实现 <code>O(1)</code>查询，双向链表用来维护顺序。</p><p>Redis并没有采用这个办法来维护一个LRU，显然内存开销很大，这是值得的么？Redis 有专门的<a href="https://github.com/redis/redis-doc/blob/master/docs/reference/eviction/index.md" target="_blank" rel="noopener">文章</a>中讨论这个事情。他们的结论是当 <code>maxmemory-samples</code> 数为<a href="https://segmentfault.com/a/1190000017555834" target="_blank" rel="noopener">10</a>的时候，也就是随机选10个里面去掉一个，这样的近似 LRU 算法的性能已经很好了。</p><p>因此，Redis 实际上是记录了最后一次访问某个 key 的时间戳的。当然这倒不是因为复用 LFU 的空间，毕竟 LRU 是先有的。此外，还有一个 <code>evictionPoolEntry</code>。这个 pool 的容量是16，里面的 key 是按照 LRU 有序排列的。</p><p>Redis 构造了一个负载。顺序地从头到尾访问，此时第一个 key 就是理想 LRU 的 candidate。然后再加入 50% 的 key，从而让 50% 的老 key 被 eveit 掉。比对四种算法。图中浅灰色点为被 evict 的 key，灰色点为没有被 evict 掉的 key，绿色点是新增加的 key。</p><ol><li>理论上的 LRU 中，前一半的 old key 全部被 evict 掉了。后一半的没有被 evict 掉，保持深灰色。</li><li>Redis 3.0 因为使用了 pool，所以比 2.8 好一些。</li></ol><p><img src="/img/redis_object/lru-perform.png"></p><h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>实现 LFU 时需要记录对应的访问次数。在淘汰时选择最少访问次数的键值对。此时队列的性质就不够用了，但可以考虑下面的方案</p><ol><li>用优先队列，把访问次数作为 key，大不了手动实现一个二叉堆嘛。</li><li>用一个双层链表，第一层是从0开始的访问次数，第二层是具有这个访问次数的所有键值对的开链表。为了节约空间，第一层可以是哈希表的形式。</li></ol><h2 id="Redis的LRU和LFU实现"><a href="#Redis的LRU和LFU实现" class="headerlink" title="Redis的LRU和LFU实现"></a>Redis的LRU和LFU实现</h2><p>本章介绍了 Redis 对 LRU 和 LFU 数据结构的维护，这是必要的前置知识。<br>这一部分实现在先前介绍过的 <code>lookupKey</code> 函数中。Redis 对每个 <code>robj</code> 对象去维护了一个 <code>lru:LRU_BITS</code>字段。在3.0版本，这个字段被用来存储当前秒级别的时间戳，服务于 LRU，后续版本还会服务 LFU。具体选择 LRU 还是 LFU 是根据 <code>server.maxmemory_policy</code>来定的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In lookUpKey</span></span><br><span class="line"><span class="keyword">if</span> (!hasActiveChildProcess() &amp;&amp; !(flags &amp; LOOKUP_NOTOUCH))&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        updateLFU(val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的 evict 的时刻是 <code>freeMemoryIfNeeded</code> 函数。</p><p>维护了的LRU或者是LFU在<code>evictionPoolPopulate</code>中起作用，会分别根据<code>estimateObjectIdleTime</code>和<code>255-LFUDecrAndReturn(e)</code>进行排序。</p><h3 id="LRU-1"><a href="#LRU-1" class="headerlink" title="LRU"></a>LRU</h3><p><code>LRU_CLOCK</code>这里会选择是直接用<code>server.lruclock</code>(也是在<code>serverCron</code>里面调用<code>getLRUClock</code>设置的)，或者直接自己调用一次<code>getLRUClock</code>。这个比较是怎么来的呢？有必要介绍一下，毕竟诸如<code>run_with_period</code>里面也有这样的比较。<br>首先，在<a href="/2020/10/18/redis-sentinel/">文章</a>中已经介绍过，<code>server.hz</code>指的是表示一秒钟被触发多少次。那么<code>1000/server.hz</code>就表示触发1次要多少毫秒。<code>LRU_CLOCK_RESOLUTION</code>的默认值是1000，表示时钟精度是1000毫秒调用一次。所以只要LRU的精度小于server调用的精度，就可以复用server.lruclock，从而少调用一次getLRUClock。<br>【Q】岂不是大多数情况下都可以复用server的时钟？毕竟hz不会为0.5啊。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LRU_BITS 24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">LRU_CLOCK</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1000</span>/server.hz &lt;= LRU_CLOCK_RESOLUTION) &#123;</span><br><span class="line">        lruclock = server.lruclock;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lruclock = getLRUClock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lruclock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LFU-1"><a href="#LFU-1" class="headerlink" title="LFU"></a>LFU</h3><p>在访问一个对象的时候，用 <code>updateLFU</code> 更新 <code>lru</code> 字段。这个函数会在高16位存一个分钟级别的时间戳 ldt，在低8位存访问计数 counter。这两个值被存放在一个字段中完全是为了节省空间和复用字段，其组合后的值整体上没有排序意义。<br>执行 LFU 策略时更新 <code>lru</code> 字段需要注意两点，<strong>即要根据时间衰减，但也要根据访问次数增长</strong>：</p><ol><li>首先，通过 <code>LFUDecrAndReturn</code>，减少 <code>counter</code>。<br> 减少的值与当前时间和记录的 ldt 的差值有关。也就是隔得时间越长，减的越多。</li><li>然后，通过 <code>LFULogIncr</code>以一定概率增加 counter。</li><li>最后，将最新的 counter 和 ldt 重新组装起来存入 <code>lru</code> 中。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * Firstly, decrement the counter if the decrement time is reached.</span></span><br><span class="line"><span class="comment"> * Then logarithmically increment the counter, and update the access time. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateLFU</span><span class="params">(robj *val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = LFUDecrAndReturn(val);</span><br><span class="line">    counter = LFULogIncr(counter);</span><br><span class="line">    <span class="comment">// 组装lru字段</span></span><br><span class="line">    val-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="衰减counter"><a href="#衰减counter" class="headerlink" title="衰减counter"></a>衰减counter</h4><p><code>LFUDecrAndReturn</code> 返回 <code>counter</code>，和当前对象的 frequency 正相关。这个函数在返回前会先根据当前访问时刻和上次记录的 ldt 的差值来减少 counter 的值。<br><code>counter</code> 具体减少多少由 <code>server.lfu_decay_time</code> 决定。它是个衰变因子，默认是1，这时候对 <code>counter</code> 的减少就是经过的分钟数。如果将它设为更大的值，则 counter 减少的量会变少。它还有个特殊值0，表示 counter 只能加不能减。<br>每次衰减会对 counter 减去 <code>num_periods</code>，知道减少到0为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUDecrAndReturn</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> ldt = o-&gt;lru &gt;&gt; <span class="number">8</span>; <span class="comment">// 取出老的分钟时间戳</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> counter = o-&gt;lru &amp; <span class="number">255</span>; <span class="comment">// 取出老的计数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> num_periods = server.lfu_decay_time ? </span><br><span class="line">        LFUTimeElapsed(ldt) / server.lfu_decay_time : </span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (num_periods)</span><br><span class="line">        counter = (num_periods &gt; counter) ? <span class="number">0</span> : counter - num_periods;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-decay-time"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_decay_time, <span class="number">1</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>简单介绍 <code>LFUTimeElapsed</code>，用来计算从 <code>ldt</code> 开始经过了多少分钟。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得从ldt开始经过了多少分钟</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="title">LFUTimeElapsed</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> ldt)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> now = LFUGetTimeInMinutes();</span><br><span class="line">    <span class="keyword">if</span> (now &gt;= ldt) <span class="keyword">return</span> now-ldt;</span><br><span class="line">    <span class="comment">// 如果now小了，就当成已经wrap了刚好一次，这个和estimateObjectIdleTime的实现是类似的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">65535</span>-ldt+now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【Q】其实我觉得这里有个优化点，可能每次访问的时候 num_periods 都是 0.9 这样的数，结果导致每次都不衰减。我想对于这种情况，最好就不要更新 ldt，让它和下一次的攒起来一起算。</p><h4 id="增加counter"><a href="#增加counter" class="headerlink" title="增加counter"></a>增加counter</h4><p>介绍 <code>counter</code> 随访问次数的增长 <code>LFULogIncr</code>。<br>每次访问都需要增加访问计数，但未必每次都自增，而是随机出一个 <code>r</code>，当它小于阈值 <code>p</code> 后才会自增 <code>counter</code>。<br>其中<code>p</code>的值是<code>1.0/(baseval*lfu_log_factor+1)</code>，其中 <code>baseval</code> 为<code>max(0,counter-LFU_INIT_VAL)</code>。</p><p>可以发现 p 是在 0 和 1 之间的。但进一步讨论下 baseval 和 p 的关系：</p><ol><li>baseval=0，p=1</li><li>baseval=1，p=0.09</li><li>baseval=10，p=0.009</li></ol><p>可以看到：</p><ol><li><code>counter</code> 越大，<code>counter</code> 的自增概率就越小。</li><li><code>lfu_log_factor</code> 越大，<code>counter</code> 的自增概率就越小<br> 其实 <code>counter</code> 的增长和实际的访问次数是<strong>成对数关系</strong>的。如果我们需要存储很高的访问频次，可以设置更大的 <code>lfu_log_factor</code>。<br> 这样的设计使得区区 8 bits 足够存储很大的命中次数。</li></ol><p>在更新版本的<a href="https://github.com/redis/redis/blob/9ab873d9d35e789a228c5281d57c9c4fdc1e4ce1/redis.conf#L2156" target="_blank" rel="noopener">redis.conf</a>中，列出了不同 <code>lfu_log_factor</code> 取值下，若干次 hit 之后，counter 增加的数量。</p><p>因为r是随机取的，所以可能用数学计算挺困难的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| factor | <span class="number">100</span> hits   | <span class="number">1000</span> hits  | <span class="number">100</span>K hits  | <span class="number">1</span>M hits    | <span class="number">10</span>M hits   |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">0</span>      | <span class="number">104</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">1</span>      | <span class="number">18</span>         | <span class="number">49</span>         | <span class="number">255</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">10</span>     | <span class="number">10</span>         | <span class="number">18</span>         | <span class="number">142</span>        | <span class="number">255</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br><span class="line">| <span class="number">100</span>    | <span class="number">8</span>          | <span class="number">11</span>         | <span class="number">49</span>         | <span class="number">143</span>        | <span class="number">255</span>        |</span><br><span class="line">+--------+------------+------------+------------+------------+------------+</span><br></pre></td></tr></table></figure><p>还需要特别介绍下 <code>LFU_INIT_VAL</code>，每个对象在初始化时，对应的 counter 是 <code>LFU_INIT_VAL</code> 即 5。没有这个，新生对象就会在 <code>LFUDecrAndReturn</code> 的时候，因为 counter 很小被很快淘汰掉。</p><p>当然，在 <code>LFULogIncr</code> 时需要将它还原回实际的值来计算 p。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LFU_INIT_VAL 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// evict.c</span></span><br><span class="line"><span class="keyword">uint8_t</span> LFULogIncr(<span class="keyword">uint8_t</span> counter) &#123;</span><br><span class="line">    <span class="comment">// 确保不会回绕</span></span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">255</span>) <span class="keyword">return</span> <span class="number">255</span>;</span><br><span class="line">    <span class="comment">// 随机数r</span></span><br><span class="line">    <span class="keyword">double</span> r = (<span class="keyword">double</span>)rand()/RAND_MAX;</span><br><span class="line">    <span class="keyword">double</span> baseval = counter - LFU_INIT_VAL;</span><br><span class="line">    <span class="keyword">if</span> (baseval &lt; <span class="number">0</span>) baseval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> p = <span class="number">1.0</span>/(baseval*server.lfu_log_factor+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// p小于该随机数r才增长</span></span><br><span class="line">    <span class="keyword">if</span> (r &lt; p) counter++;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// config.c</span></span><br><span class="line">createIntConfig(<span class="string">"lfu-log-factor"</span>, <span class="literal">NULL</span>, MODIFIABLE_CONFIG, <span class="number">0</span>, INT_MAX, server.lfu_log_factor, <span class="number">10</span>, INTEGER_CONFIG, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><h2 id="evictionPoolEntry和evictionPoolPopulate"><a href="#evictionPoolEntry和evictionPoolPopulate" class="headerlink" title="evictionPoolEntry和evictionPoolPopulate"></a>evictionPoolEntry和evictionPoolPopulate</h2><p>来看 <code>evictionPoolPopulate</code> 这个函数，它作用是往 <code>evictionPool</code> 里面加一些 <code>evictionPoolEntry</code>。一个 <code>evictionPoolEntry</code> 表示数据库中的某个 key。一系列 <code>evictionPoolEntry</code> 组成一个 <code>evictionPool</code>。在 <code>evictionPool</code> 中的 entry 都是按照 <code>idle</code> 排序的，从小到大升序排列，最左边的 idle time 最小。因此 evict 的时候可以只看最左边的 pool。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_SIZE 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVPOOL_CACHED_SDS_SIZE 255</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;    <span class="comment">/* Object idle time (inverse frequency for LFU) */</span></span><br><span class="line">    sds key;                    <span class="comment">/* Key name. */</span></span><br><span class="line">    sds cached;                 <span class="comment">/* Cached SDS object for key name. */</span></span><br><span class="line">    <span class="keyword">int</span> dbid;                   <span class="comment">/* Key DB number. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">EvictionPoolLRU</span>;</span></span><br></pre></td></tr></table></figure><ol><li><code>idle</code><br> 表示每个对象的空闲时间。pool 里面只能加入具有更大 idle time 的键。如果还有空余空间，就始终加入。</li><li><code>cached</code><br> <strong>这是一个有趣的优化</strong>。<br> 如果 key 的长度比较小，它就会被存在预分配好空间的 cached 结构中，从而避免在 key 中分配空间的开销。</li><li><code>dbid</code><br> 表示这个键所属的数据库。</li></ol><p>如何根据 LRU 或者 LFU 计算 idle 呢？</p><ol><li><p>如果采用LRU<br> 调用 <code>estimateObjectIdleTime</code> 函数计算，实际上就是乘以一个 <code>LRU_CLOCK_RESOLUTION</code>。这里实现上还处理了一下回绕 wrap 的情况。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">estimateObjectIdleTime</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> lruclock = LRU_CLOCK();</span><br><span class="line">    <span class="keyword">if</span> (lruclock &gt;= o-&gt;lru) &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock - o-&gt;lru) * LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (lruclock + (LRU_CLOCK_MAX - o-&gt;lru)) *</span><br><span class="line">                    LRU_CLOCK_RESOLUTION;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果采用LFU<br> 这里要反向一下，就是用255减一下 <code>LFUDecrAndReturn(o)</code>。因为idle和访问频率是相反的。</p></li></ol><p>下面是 <code>evictionPoolPopulate</code> 的具体实现。<br>输入参数：</p><ol><li><code>sampledict</code> 表示从哪个 dict 里面进行采样，根据策略不同，可能是 dict(allkeys 策略) 或者 expire(volatile 策略)。</li><li><code>keydict</code> 只能是对应的 dict。因为 expire 里面只是存一个”引用”。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">evictionPoolPopulate</span><span class="params">(<span class="keyword">int</span> dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, k, count;</span><br><span class="line">    dictEntry *samples[server.maxmemory_samples];</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>dictGetSomeKeys</code> 函数从 dict 里面任意取出若干个entry。<code>server.maxmemory_samples</code> 默认被设置成5个，对应于前几章的论述，后面应该会改成10个吧。在取出这些 entry 到 <code>samples</code>后，挨个尝试将它们插入到 pool 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> idle;</span><br><span class="line">        sds key;</span><br><span class="line">        robj *o;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        de = samples[j];</span><br><span class="line">        key = dictGetKey(de);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面的一段代码计算这个对象的 <code>idle</code> 时间。具体的策略在前面讲过了，但首先需要考虑当前的 dict 可能是 expire，这样就要回 dict 表再查一次。得到对应的 <code>keydict</code> 中的 entry 即 <code>de</code>，以及 key 对应的 val 即 <code>o</code>：</p><ol><li>回表的情况<br> 显然，只要 <code>sampledict</code> 不等于 <code>keydict</code> 就需要回表。因为此时 <code>sampledict</code> 肯定是 expire。</li><li>不回表的情况就可以直接取 val</li><li>特殊情况：volatile-ttl 策略<br> 前面两种情况都是用的 <code>keydict</code> 中对应的 entry、key 和 val，但这里直接用 <code>sampledict</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy != MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sampledict != keydict) de = dictFind(keydict, key);</span><br><span class="line">            o = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Calculate the idle time according to the policy. This is called</span></span><br><span class="line"><span class="comment">         * idle just because the code initially handled LRU, but is in fact</span></span><br><span class="line"><span class="comment">         * just a score where an higher score means better candidate. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LRU) &#123;</span><br><span class="line">            idle = estimateObjectIdleTime(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">            idle = <span class="number">255</span>-LFUDecrAndReturn(o);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL) &#123;</span><br><span class="line">            <span class="comment">/* In this case the sooner the expire the better. */</span></span><br><span class="line">            idle = ULLONG_MAX - (<span class="keyword">long</span>)dictGetVal(de);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown eviction policy in evictionPoolPopulate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面计算出了当前 key 对应的 <code>idle</code> 时间。接下来将元素插入到 pool 中。这是一个类似<strong>插入排序</strong>的过程。<br>首先，找到第一个空 bucket，或者找到第一个 <code>idle &lt;= pool[k].idle</code> ，可以插到它前面。</p><p>下面的循环能够跳过所有不满足以上条件的情况。【Q】这里能直接二分么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Insert the element inside the pool.</span></span><br><span class="line"><span class="comment">         * First, find the first empty bucket or the first populated</span></span><br><span class="line"><span class="comment">         * bucket that has an idle time smaller than our idle time. */</span></span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; EVPOOL_SIZE &amp;&amp;</span><br><span class="line">               pool[k].key &amp;&amp;</span><br><span class="line">               pool[k].idle &lt; idle) k++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面处理两种特殊情况：</p><ol><li>我们在处理最左边的桶，此时待插入 key 的 <code>idle</code> 比 pool 里面所有的 idle 都要小，但没有空余的格子了。<br> 这说明这个 entry 非常新，我们没必要将它插入到 pool 中，所以直接诶 continue 掉。</li><li>bucket 完全空的情况，可以直接用最左边的格子。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span> &amp;&amp; pool[EVPOOL_SIZE<span class="number">-1</span>].key != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Can't insert if the element is &lt; the worst element we have</span></span><br><span class="line"><span class="comment">             * and there are no empty buckets. */</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; EVPOOL_SIZE &amp;&amp; pool[k].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Inserting into empty position. No setup needed before insert. */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，<code>key</code> 和 <code>cache</code> 有点类似于<strong>自引用结构</strong>的关系，但其实不是。因为 key 和 cached 实际上都是 sds，也就是个 <code>char*</code>。移动或者复制 sds，只是移动指针，并没有改变指向的内容。所以只需要保证<strong>只要它不释放就行</strong>。<br>当然，发散一下，如果 <code>key</code> 是一个指向 <code>cached</code> 的 <code>sds*</code>，那就真的是自引用结构了。但也并不需要绑定 <code>key</code> 和它可能指向的 <code>cached</code> 在一个结构中。因为如下所示，它们可以是一一对应的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| key 1 | key 2 | key 3 | nul k |</span><br><span class="line">| nul c | cac 3 | cac 2 | cac 1 |</span><br></pre></td></tr></table></figure><p>接下来看最一般的情况。此时 <code>k</code> 是第一个满足 <code>idle &lt;= pool[k].idle</code>，我们的新 entry 应该插入在 <code>k</code> 之前。下面就插入排序，把待插入的 <code>de</code> 插入，然后把原来 <code>k</code> 以及之后的数字往右边移动。这里使用了 memmove，它能自动检测 src 内存和 dest 内存重叠的情况并处理，是更安全的 memcpy。<br>又可以细分为两种情况：</p><ol><li>最右边还有空位，将 <code>[k,)</code> 整体右移一格，新 entry 预计插入 <code>k</code> 处<br> 尽管这时候最右边的 cached 是空，但还是要备份。否则就会泄露掉那一块内存。</li><li>最右边没有空位，将整个数组右移一格，新entry预计插入在<code>k-1</code>处<br> 此时最左边是idle最小的，将它从pool里面去掉，换成idle更大的。<br> 但同时，也要保证最左边的cached不被意外释放。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (pool[EVPOOL_SIZE<span class="number">-1</span>].key == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Free space on the right? Insert at k shifting</span></span><br><span class="line"><span class="comment">                 * all the elements from k to end to the right. */</span></span><br><span class="line"></span><br><span class="line">                sds cached = pool[EVPOOL_SIZE<span class="number">-1</span>].cached;</span><br><span class="line">                memmove(pool+k+<span class="number">1</span>,pool+k,</span><br><span class="line">                    <span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*(EVPOOL_SIZE-k<span class="number">-1</span>));</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* No free space on right? Insert at k-1 */</span></span><br><span class="line">                k--;</span><br><span class="line">                <span class="comment">/* Shift all elements on the left of k (included) to the</span></span><br><span class="line"><span class="comment">                 * left, so we discard the element with smaller idle time. */</span></span><br><span class="line">                sds cached = pool[<span class="number">0</span>].cached; <span class="comment">/* Save SDS before overwriting. */</span></span><br><span class="line">                <span class="keyword">if</span> (pool[<span class="number">0</span>].key != pool[<span class="number">0</span>].cached) sdsfree(pool[<span class="number">0</span>].key);</span><br><span class="line">                memmove(pool,pool+<span class="number">1</span>,<span class="keyword">sizeof</span>(pool[<span class="number">0</span>])*k);</span><br><span class="line">                pool[k].cached = cached;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，将新entry插入pool中。这里说明下cached的使用：</p><ol><li>如果<code>key</code>的长度大于<code>EVPOOL_CACHED_SDS_SIZE</code><br> 则复制<code>key</code>到<code>pool[k].key</code></li><li>如果<code>key</code>的长度较小，就可以尝试做优化，将它放在<code>cached</code>中，然后让把<code>cache</code>赋值给<code>key</code>，从而避免复制底层的字符串。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">// 尝试复用pool entry中的cached SDS。因为内存分配和回收还是开销比较大的。</span></span><br><span class="line">        <span class="keyword">int</span> klen = sdslen(key);</span><br><span class="line">        <span class="keyword">if</span> (klen &gt; EVPOOL_CACHED_SDS_SIZE) &#123;</span><br><span class="line">            pool[k].key = sdsdup(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memcpy</span>(pool[k].cached,key,klen+<span class="number">1</span>);</span><br><span class="line">            sdssetlen(pool[k].cached,klen);</span><br><span class="line">            pool[k].key = pool[k].cached;</span><br><span class="line">        &#125;</span><br><span class="line">        pool[k].idle = idle;</span><br><span class="line">        pool[k].dbid = dbid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dictGetSomeKeys"><a href="#dictGetSomeKeys" class="headerlink" title="dictGetSomeKeys"></a>dictGetSomeKeys</h3><p><code>dictGetSomeKeys</code>这个函数，是对一个dict来说的，而不是对db来说的。<br>它不保证一定返回正好count个，也不保证返回的元素都不重复。返回值被存到<code>des</code>里面，需要保证这个数组至少能容纳<code>count</code>个。<br>取出来的指针存在<code>des</code>中返回。<code>des</code>必须预分配至少<code>count</code>个空间，尽管函数可能未必能取到<code>count</code>个。其原因可能是本来就没那么多个，或者我们经过多轮迭代没添加完。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This function samples the dictionary to return a few keys from random</span></span><br><span class="line"><span class="comment"> * locations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that this function is not suitable when you need a good distribution</span></span><br><span class="line"><span class="comment"> * of the returned items, but only when you need to "sample" a given number</span></span><br><span class="line"><span class="comment"> * of continuous elements to run some kind of algorithm or to produce</span></span><br><span class="line"><span class="comment"> * statistics. However the function is much faster than dictGetRandomKey()</span></span><br><span class="line"><span class="comment"> * at producing N elements. */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGetSomeKeys</span><span class="params">(dict *d, dictEntry **des, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> j; <span class="comment">/* internal hash table id, 0 or 1. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> tables; <span class="comment">/* 1 or 2 tables? */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stored = <span class="number">0</span>, maxsizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> maxsteps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) &lt; count) count = dictSize(d);</span><br><span class="line">    maxsteps = count*<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>首先，执行一点渐进式rehash。然后将<code>maxsizemask</code>设置为所有ht(没有rehash是1个，有是2个)的最大容量。<br>将<code>i</code>设置为随机一个位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Try to do a rehashing work proportional to 'count'. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; count; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dictIsRehashing(d))</span><br><span class="line">            _dictRehashStep(d);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tables = dictIsRehashing(d) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    maxsizemask = d-&gt;ht[<span class="number">0</span>].sizemask;</span><br><span class="line">    <span class="keyword">if</span> (tables &gt; <span class="number">1</span> &amp;&amp; maxsizemask &lt; d-&gt;ht[<span class="number">1</span>].sizemask)</span><br><span class="line">        maxsizemask = d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">    <span class="comment">/* Pick a random point inside the larger table. */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> i = random() &amp; maxsizemask;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面进入主循环，循环条件有两个，一个是取满count个，一个是执行最多<code>maxsteps=count*10</code>次。<br>在每一次迭代中，对所有的ht（1或2个）进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> emptylen = <span class="number">0</span>; <span class="comment">/* Continuous empty entries so far. */</span></span><br><span class="line">    <span class="keyword">while</span>(stored &lt; count &amp;&amp; maxsteps--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; tables; j++) &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>涉及到rehashidx相关的逻辑，表示在每次进入<code>dictRehash</code>函数的时候，首先<code>ht[0].table[rehashidx]</code>这个桶。如果现在在rehash过程中，到<code>d-&gt;rehashidx</code>为止的所有index都已经被访问过了。实际上这些桶里面都空(not populated)了，因此我们可以跳过<code>ht[0]</code>里面$[0,idx-1]$这个区间的关卡，直接去看<code>ht[1]</code>里面的。这其实是一个优化，在<code>dictRehash</code>实现中，也有对空桶跳过的优化。<br>特别地，如果<code>i</code>在<code>ht[1]</code>里面也已经超了，这就表示截止到<code>rehashidx</code>两个表里面都没有了。【Q】为什么可以认为<code>ht[1]</code>中的<code>rehashidx</code>之前的也不需要判定了呢？或者说，为啥两个ht可以共享一个<code>i</code>呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (tables == <span class="number">2</span> &amp;&amp; j == <span class="number">0</span> &amp;&amp; i &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) d-&gt;rehashidx) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= d-&gt;ht[<span class="number">1</span>].size)</span><br><span class="line">                    i = d-&gt;rehashidx;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= d-&gt;ht[j].size) <span class="keyword">continue</span>; <span class="comment">/* Out of range for this table. */</span></span><br><span class="line">            dictEntry *he = d-&gt;ht[j].table[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Count contiguous empty buckets, and jump to other</span></span><br><span class="line"><span class="comment">             * locations if they reach 'count' (with a minimum of 5). */</span></span><br><span class="line">            <span class="keyword">if</span> (he == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 我们会统计遇到连续空桶的数量，如果超过了5个，就重新随机一个位置。</span></span><br><span class="line">                emptylen++;</span><br><span class="line">                <span class="keyword">if</span> (emptylen &gt;= <span class="number">5</span> &amp;&amp; emptylen &gt; count) &#123;</span><br><span class="line">                    i = random() &amp; maxsizemask;</span><br><span class="line">                    emptylen = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，我们使用桶里面所有的元素</span></span><br><span class="line">                emptylen = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (he) &#123;</span><br><span class="line">                    *des = he;</span><br><span class="line">                    des++;</span><br><span class="line">                    he = he-&gt;next;</span><br><span class="line">                    stored++;</span><br><span class="line">                    <span class="keyword">if</span> (stored == count) <span class="keyword">return</span> stored;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在主循环结束后，会自增<code>i</code>的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        i = (i+<span class="number">1</span>) &amp; maxsizemask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stored;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主逻辑freeMemoryIfNeeded"><a href="#主逻辑freeMemoryIfNeeded" class="headerlink" title="主逻辑freeMemoryIfNeeded"></a>主逻辑freeMemoryIfNeeded</h2><p><code>freeMemoryIfNeeded</code>函数是evict的主要逻辑。<br>首先，如果是从服务器，并且配置了<code>server.repl_slave_ignore_maxmemory</code>就忽略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">freeMemoryIfNeeded</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> keys_freed = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* By default replicas should ignore maxmemory</span></span><br><span class="line"><span class="comment">     * and just be masters exact copies. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_slave_ignore_maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面就来计算占用了多少内存<code>mem_reported</code>，主要函数<code>getMaxmemoryState</code>我们放在后面单独讲解。<code>mem_reported</code>表示总共用了多少内存，<code>mem_tofree</code>表示应该释放多少内存(不算Slave和AOF的缓存)。<br><code>clientsArePaused</code>的检查，有点奇怪。根据注释，它的意思是，如果client都被pause了，那么数据就是静止的。不仅对于所有的client是这样，对于还没有做expire和evict的所有key也是这样。我觉得这应该是一个优化，防止在这种情况下再走下面的逻辑。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_tofree, mem_freed;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency, eviction_latency, lazyfree_latency;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> delta;</span><br><span class="line">    <span class="keyword">int</span> slaves = listLength(server.slaves);</span><br><span class="line">    <span class="keyword">int</span> result = C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clientsArePaused()) <span class="keyword">return</span> C_OK;</span><br><span class="line">    <span class="keyword">if</span> (getMaxmemoryState(&amp;mem_reported,<span class="literal">NULL</span>,&amp;mem_tofree,<span class="literal">NULL</span>) == C_OK)</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    mem_freed = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>latencyStartMonitor</code>这个宏和stopwatch一样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面开始根据淘汰政策<code>maxmemory_policy</code>进行讨论，如果是noeviction，那就直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_NO_EVICTION)</span><br><span class="line">        <span class="keyword">goto</span> cant_free; <span class="comment">/* We need to free memory, but policy forbids. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>整个内存释放过程是多次的，因此用一个循环来。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">while</span> (mem_freed &lt; mem_tofree) &#123;</span><br><span class="line">        <span class="keyword">int</span> j, k, i;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> next_db = <span class="number">0</span>;</span><br><span class="line">        sds bestkey = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> bestdbid;</span><br><span class="line">        redisDb *db;</span><br><span class="line">        dict *dict;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理要排序的情况"><a href="#处理要排序的情况" class="headerlink" title="处理要排序的情况"></a>处理要排序的情况</h3><p>第一个 if 用来处理所有需要排序的情况。查看代码，要用 while 循环去找 <code>bestkey</code>，原因是可能从 pool 里面找到的 key 不存在了，【Q】可是究竟什么情况下会发生这个情况呢？<br>循环里面的过程就是我们去遍历整个数据库里面的所有db，如果它的<code>dict</code>或者<code>expires</code>不为空，则调用<code>evictionPoolPopulate</code>。这个函数会往pool里面加入一些key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="keyword">if</span> (server.maxmemory_policy &amp; (MAXMEMORY_FLAG_LRU|MAXMEMORY_FLAG_LFU) ||</span><br><span class="line">            server.maxmemory_policy == MAXMEMORY_VOLATILE_TTL)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">evictionPoolEntry</span> *<span class="title">pool</span> = <span class="title">EvictionPoolLRU</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(bestkey == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">long</span> total_keys = <span class="number">0</span>, keys;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* We don't want to make local-db choices when expiring keys,</span></span><br><span class="line"><span class="comment">                 * so to start populate the eviction pool sampling keys from</span></span><br><span class="line"><span class="comment">                 * every DB. */</span></span><br><span class="line">                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                    db = server.db+i;</span><br><span class="line">                    dict = (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) ?</span><br><span class="line">                            db-&gt;dict : db-&gt;expires;</span><br><span class="line">                    <span class="keyword">if</span> ((keys = dictSize(dict)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        evictionPoolPopulate(i, dict, db-&gt;dict, pool);</span><br><span class="line">                        total_keys += keys;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!total_keys) <span class="keyword">break</span>; <span class="comment">/* No keys to evict. */</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面遍历整个 pool，找到最合适的一个。解释几个问题：</p><ol><li>为什么要从尾往头遍历？<br> 在对evictionPool的介绍中提到，它是有序的，最左边的idle time最小，最右边的最大，因此优先淘汰右边的。</li><li>为什么要有bestdbid？将key之间的比较转化为数据库之间的比较么？</li><li><code>server.db[pool[k].dbid]</code>是什么鬼？<br> 实际上是要选择<code>pool[k].dbid</code>这个db。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">                <span class="comment">/* Go backward from best to worst element to evict. */</span></span><br><span class="line">                <span class="keyword">for</span> (k = EVPOOL_SIZE<span class="number">-1</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    bestdbid = pool[k].dbid;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_ALLKEYS) &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].dict,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        de = dictFind(server.db[pool[k].dbid].expires,</span><br><span class="line">                            pool[k].key);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* Remove the entry from the pool. */</span></span><br><span class="line">                    <span class="keyword">if</span> (pool[k].key != pool[k].cached)</span><br><span class="line">                        sdsfree(pool[k].key);</span><br><span class="line">                    pool[k].key = <span class="literal">NULL</span>;</span><br><span class="line">                    pool[k].idle = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/* If the key exists, is our pick. Otherwise it is</span></span><br><span class="line"><span class="comment">                     * a ghost and we need to try the next element. */</span></span><br><span class="line">                    <span class="keyword">if</span> (de) &#123;</span><br><span class="line">                        bestkey = dictGetKey(de);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">/* Ghost... Iterate again. */</span></span><br><span class="line">                        <span class="comment">// 这个很奇怪，什么时候会出现这种情况呢？</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="处理随机情况"><a href="#处理随机情况" class="headerlink" title="处理随机情况"></a>处理随机情况</h3><p>第二个if，用来处理随机的情况。这个很简单，直接调用<code>dictGetRandomKey</code>就行，和eviction pool也没啥关系了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* volatile-random and allkeys-random policy */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM ||</span><br><span class="line">                 server.maxmemory_policy == MAXMEMORY_VOLATILE_RANDOM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* When evicting a random key, we try to evict a key for</span></span><br><span class="line"><span class="comment">             * each DB, so we use the static 'next_db' variable to</span></span><br><span class="line"><span class="comment">             * incrementally visit all DBs. */</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; server.dbnum; i++) &#123;</span><br><span class="line">                j = (++next_db) % server.dbnum;</span><br><span class="line">                db = server.db+j;</span><br><span class="line">                dict = (server.maxmemory_policy == MAXMEMORY_ALLKEYS_RANDOM) ?</span><br><span class="line">                        db-&gt;dict : db-&gt;expires;</span><br><span class="line">                <span class="keyword">if</span> (dictSize(dict) != <span class="number">0</span>) &#123;</span><br><span class="line">                    de = dictGetRandomKey(dict);</span><br><span class="line">                    bestkey = dictGetKey(de);</span><br><span class="line">                    bestdbid = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>如果我们找到了要删除的元素<code>bestkey</code>，就执行删除元素过程。<br>首先，调用老朋友<code>propagateExpire</code>，这个会发送一条删除指令给AOF/Slave。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">        <span class="comment">/* Finally remove the selected key. */</span></span><br><span class="line">        <span class="keyword">if</span> (bestkey) &#123;</span><br><span class="line">            db = server.db+bestdbid;</span><br><span class="line">            robj *keyobj = createStringObject(bestkey,sdslen(bestkey));</span><br><span class="line">            propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，我们统计这次evict释放了多少内存，就是首尾两个<code>zmalloc_used_memory</code>相减。这个有点粗略了，就在刚才我们还将AOF/Slave缓存单独拿出来算的呢，现在直接总内存相减了。在注释中还提到，有可能用来<code>propagateExpire</code>的内存比我们释放的db内存还多呢，但我们是管不了的，否则<code>mem_freed &lt; mem_tofree</code>这个循环条件永远达不到了。并且，这些缓存终究会被释放的。<br>这里还统计了一下调用dictSyncDelete等的时间，并且通过<code>latencyAddSampleIfNeeded</code>放到统计里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            delta = (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            latencyStartMonitor(eviction_latency);</span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction)</span><br><span class="line">                dbAsyncDelete(db,keyobj);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dbSyncDelete(db,keyobj);</span><br><span class="line">            signalModifiedKey(<span class="literal">NULL</span>,db,keyobj);</span><br><span class="line">            latencyEndMonitor(eviction_latency);</span><br><span class="line">            latencyAddSampleIfNeeded(<span class="string">"eviction-del"</span>,eviction_latency);</span><br><span class="line">            delta -= (<span class="keyword">long</span> <span class="keyword">long</span>) zmalloc_used_memory();</span><br><span class="line">            mem_freed += delta;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是一些统计性的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            server.stat_evictedkeys++;</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_EVICTED, <span class="string">"evicted"</span>,</span><br><span class="line">                keyobj, db-&gt;id);</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">            keys_freed++;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们在循环中就强制往Slave发送数据，确保即使在要传的数据都很大的情况下，我们仍然能够快速传递。<br>特别地，我们在<code>while (mem_freed &lt; mem_tofree)</code>这个循环的最后，还会有条件地检查一下内存是不是达标。这个主要是对异步删除来说的，在这种情况下，<code>dbAsyncDelete</code>流程中对内存的释放未必能和我们循环这边同步起来。所以我们每释放16个键，就检查一次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">            <span class="keyword">if</span> (slaves) flushSlavesOutputBuffers();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (server.lazyfree_lazy_eviction &amp;&amp; !(keys_freed % <span class="number">16</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                    <span class="comment">/* Let's satisfy our stop condition. */</span></span><br><span class="line">                    mem_freed = mem_tofree;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">goto</span> cant_free; <span class="comment">/* nothing to free... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    result = C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">cant_free:</span><br><span class="line">    <span class="comment">/* We are here if we are not able to reclaim memory. There is only one</span></span><br><span class="line"><span class="comment">     * last thing we can try: check if the lazyfree thread has jobs in queue</span></span><br><span class="line"><span class="comment">     * and wait... */</span></span><br><span class="line">    <span class="keyword">if</span> (result != C_OK) &#123;</span><br><span class="line">        latencyStartMonitor(lazyfree_latency);</span><br><span class="line">        <span class="keyword">while</span>(bioPendingJobsOfType(BIO_LAZY_FREE)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getMaxmemoryState(<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>) == C_OK) &#123;</span><br><span class="line">                result = C_OK;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        latencyEndMonitor(lazyfree_latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"eviction-lazyfree"</span>,lazyfree_latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"eviction-cycle"</span>,latency);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getMaxmemoryState"><a href="#getMaxmemoryState" class="headerlink" title="getMaxmemoryState"></a>getMaxmemoryState</h2><p>这个函数获得内存的使用情况，包括：</p><ol><li>total<br> 总共使用的内存。<br> 来自<code>zmalloc_used_memory</code>。</li><li>logical<br> 即<code>mem_used</code>，表示出了Slave/AOF buffer之外的内存。<br> 这个计算就是要减去<code>overhead</code>，也就是Slave/AOF buffer的内存，用<code>freeMemoryGetNotCountedMemory</code>计算得到的。</li><li>level<br> 表示内存使用率</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxmemoryState</span><span class="params">(<span class="keyword">size_t</span> *total, <span class="keyword">size_t</span> *logical, <span class="keyword">size_t</span> *tofree, <span class="keyword">float</span> *level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> mem_reported, mem_used, mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are over the memory usage limit. If we are not, no need</span></span><br><span class="line"><span class="comment">     * to subtract the slaves output buffers. We can just return ASAP. */</span></span><br><span class="line">    mem_reported = zmalloc_used_memory();</span><br><span class="line">    <span class="keyword">if</span> (total) *total = mem_reported;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面获得了总内存量，如果没有设置最大内存，或者总内存量都没有操作，也不需要计算比例，那么就直接返回了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* We may return ASAP if there is no need to compute the level. */</span></span><br><span class="line">    <span class="keyword">int</span> return_ok_asap = !server.maxmemory || mem_reported &lt;= server.maxmemory;</span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap &amp;&amp; !level) <span class="keyword">return</span> C_OK;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>计算两个缓冲区占用的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">/* Remove the size of slaves output buffers and AOF buffer from the</span></span><br><span class="line"><span class="comment">     * count of used memory. */</span></span><br><span class="line">    mem_used = mem_reported;</span><br><span class="line">    <span class="keyword">size_t</span> overhead = freeMemoryGetNotCountedMemory();</span><br><span class="line">    mem_used = (mem_used &gt; overhead) ? mem_used-overhead : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute the ratio of memory usage. */</span></span><br><span class="line">    <span class="keyword">if</span> (level) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!server.maxmemory) &#123;</span><br><span class="line">            *level = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *level = (<span class="keyword">float</span>)mem_used / (<span class="keyword">float</span>)server.maxmemory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (return_ok_asap) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are still over the memory limit. */</span></span><br><span class="line">    <span class="keyword">if</span> (mem_used &lt;= server.maxmemory) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute how much memory we need to free. */</span></span><br><span class="line">    mem_tofree = mem_used - server.maxmemory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logical) *logical = mem_used;</span><br><span class="line">    <span class="keyword">if</span> (tofree) *tofree = mem_tofree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis事件"><a href="#Redis事件" class="headerlink" title="Redis事件"></a>Redis事件</h2><p>在前面的代码中可以看到下面的语句，实际上是对主数据库<code>c-&gt;db</code>进行修改后，需要进行事件通知，我们将在下面介绍这几个语句的作用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signalModifiedKey(c,c-&gt;db,c-&gt;argv[j]);</span><br><span class="line">notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">    <span class="string">"del"</span>,c-&gt;argv[j],c-&gt;db-&gt;id);</span><br><span class="line">server.dirty++;</span><br></pre></td></tr></table></figure><h3 id="signalModifiedKey"><a href="#signalModifiedKey" class="headerlink" title="signalModifiedKey"></a>signalModifiedKey</h3><p><code>signalModifiedKey</code>是key被修改的钩子函数，每当数据库<code>c-&gt;db</code>里面的key被改动时，会调用这个函数。这里的key发生改动也包括key对应的值发生改动，这是因为从<code>genericSetKey</code>的实现可以看到，SET指令也会导致<code>signalModifiedKey</code>被调用。<br>此外，根据注释，每一次DB被flush时，<code>signalFlushDb</code>会被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.c</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalModifiedKey</span><span class="params">(client *c, redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    touchWatchedKey(db,key);</span><br><span class="line">    trackingInvalidateKey(c,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="touchWatchedKey"><a href="#touchWatchedKey" class="headerlink" title="touchWatchedKey"></a>touchWatchedKey</h4><p><code>touchWatchedKey</code>字如其名，它的作用是让WATCH这个键的事务失效。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* "Touch" a key, so that if this key is being WATCHed by some client the</span></span><br><span class="line"><span class="comment"> * next EXEC will fail. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touchWatchedKey</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">list</span> *clients;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里先特判一下，如果<code>db-&gt;watched_keys</code>为空就直接返回，这个用法在redis中非常常见，我猜想可能是<code>dictFind</code>的开销还是比较大的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (dictSize(db-&gt;watched_keys) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面从<code>db-&gt;watched_keys</code>上拿到WATCH这个key的所有的client，并且对这个链表上的每一个client设置<code>CLIENT_DIRTY_CAS</code>这个flag。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">// 这个函数是dictFind(只能得到dictEntry)和dictGetVal的简单封装</span></span><br><span class="line">    clients = dictFetchValue(db-&gt;watched_keys, key);</span><br><span class="line">    <span class="keyword">if</span> (!clients) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark all the clients watching this key as CLIENT_DIRTY_CAS */</span></span><br><span class="line">    <span class="comment">/* Check if we are already watching for this key */</span></span><br><span class="line">    listRewind(clients,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *c = listNodeValue(ln);</span><br><span class="line"></span><br><span class="line">        c-&gt;flags |= CLIENT_DIRTY_CAS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trackingInvalidateKey"><a href="#trackingInvalidateKey" class="headerlink" title="trackingInvalidateKey"></a>trackingInvalidateKey</h4><p>下面看另一个函数<code>trackingInvalidateKey</code>。这个系列的函数是在Redis6.0左右被引入的，主要用途是维护客户端缓存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrapper (the one actually called across the core) to pass the key</span></span><br><span class="line"><span class="comment"> * as object. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKey</span><span class="params">(client *c, robj *keyobj)</span> </span>&#123;</span><br><span class="line">    trackingInvalidateKeyRaw(c,keyobj-&gt;ptr,sdslen(keyobj-&gt;ptr),<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当key的值被改变后，在keys tracking的逻辑下，我们的任务是给每一个有可能缓存了当前keys的client发送通知。如果传入的<code>c</code>为空，表示这个不是一个client的场景，而是例如服务器内部做expire。<br><code>bcast</code>参数的作用是是否要将这个key通过BCAST模式广播给client们。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * This is the case when the function is called from the Redis core once a key is modified, however</span></span><br><span class="line"><span class="comment"> * we also call the function in order to evict keys in the key table in case</span></span><br><span class="line"><span class="comment"> * of memory pressure: in that case the key didn't really change, so we want</span></span><br><span class="line"><span class="comment"> * just to notify the clients that are in the table for this key, that would</span></span><br><span class="line"><span class="comment"> * otherwise miss the fact we are no longer tracking the key for them. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trackingInvalidateKeyRaw</span><span class="params">(client *c, <span class="keyword">char</span> *key, <span class="keyword">size_t</span> keylen, <span class="keyword">int</span> bcast)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TrackingTable == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bcast &amp;&amp; raxSize(PrefixTable) &gt; <span class="number">0</span>)</span><br><span class="line">        trackingRememberKeyToBroadcast(c,key,keylen);</span><br><span class="line"></span><br><span class="line">    rax *ids = raxFind(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen);</span><br><span class="line">    <span class="keyword">if</span> (ids == raxNotFound) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    raxIterator ri;</span><br><span class="line">    raxStart(&amp;ri,ids);</span><br><span class="line">    raxSeek(&amp;ri,<span class="string">"^"</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(raxNext(&amp;ri)) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> id;</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;id,ri.key,<span class="keyword">sizeof</span>(id));</span><br><span class="line">        client *target = lookupClientByID(id);</span><br><span class="line">        <span class="comment">/* Note that if the client is in BCAST mode, we don't want to</span></span><br><span class="line"><span class="comment">         * send invalidation messages that were pending in the case</span></span><br><span class="line"><span class="comment">         * previously the client was not in BCAST mode. This can happen if</span></span><br><span class="line"><span class="comment">         * TRACKING is enabled normally, and then the client switches to</span></span><br><span class="line"><span class="comment">         * BCAST mode. */</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">NULL</span> ||</span><br><span class="line">            !(target-&gt;flags &amp; CLIENT_TRACKING)||</span><br><span class="line">            target-&gt;flags &amp; CLIENT_TRACKING_BCAST)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the client enabled the NOLOOP mode, don't send notifications</span></span><br><span class="line"><span class="comment">         * about keys changed by the client itself. */</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;flags &amp; CLIENT_TRACKING_NOLOOP &amp;&amp;</span><br><span class="line">            target == c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendTrackingMessage(target,key,keylen,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    raxStop(&amp;ri);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the tracking table: we'll create the radix tree and populate it</span></span><br><span class="line"><span class="comment">     * again if more keys will be modified in this caching slot. */</span></span><br><span class="line">    TrackingTableTotalItems -= raxSize(ids);</span><br><span class="line">    raxFree(ids);</span><br><span class="line">    raxRemove(TrackingTable,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)key,keylen,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="notifyKeyspaceEvent"><a href="#notifyKeyspaceEvent" class="headerlink" title="notifyKeyspaceEvent"></a>notifyKeyspaceEvent</h3><p>函数<code>notifyKeyspaceEvent</code>用来触发数据库事件，这个对应了Redis中的叫<a href="http://redisdoc.com/topic/notification.html" target="_blank" rel="noopener">“键空间通知”/“键事件通知”</a>的特性。这个特性是通过<strong>PUBLISH</strong>机制实现的。<br>简单来说，对<code>0</code>号数据库的键<code>mykey</code>执行<code>DEL key [key ...]</code>命令时，系统将分发两条消息，相当于执行以下两个<a href="http://redisdoc.com/pubsub/publish.html#publish" target="_blank" rel="noopener">PUBLISH channel message</a>命令。其中<code>__keyspace</code>系列命令称为键空间通知(key-space notification)，<code>__keyevent</code>系列命令称为键事件通知(key-event notification)。订阅第一个PUBLISH命令，可以接收<code>0</code>号数据库中所有修改键<code>mykey</code>的事件。订阅第二个PUBLISH命令，可以接收<code>0</code>号数据库中所有执行<code>del</code>命令的键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __keyspace@0__:mykey del</span><br><span class="line">PUBLISH __keyevent@0__:del mykey</span><br></pre></td></tr></table></figure><p>下面看看这个函数的具体实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyKeyspaceEvent</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">char</span> *event, robj *key, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    sds chan;</span><br><span class="line">    robj *chanobj, *eventobj;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If any modules are interested in events, notify the module system now.</span></span><br><span class="line"><span class="comment">     * This bypasses the notifications configuration, but the module engine</span></span><br><span class="line"><span class="comment">     * will only call event subscribers if the event type matches the types</span></span><br><span class="line"><span class="comment">     * they are interested in. */</span></span><br><span class="line">    moduleNotifyKeyspaceEvent(type, event, key, dbid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If notifications for this class of events are off, return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(server.notify_keyspace_events &amp; type)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    eventobj = createStringObject(event,<span class="built_in">strlen</span>(event));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyspace@&lt;db&gt;__:&lt;key&gt; &lt;event&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYSPACE) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyspace@"</span>,<span class="number">11</span>);</span><br><span class="line">        len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, key-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, eventobj);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* __keyevent@&lt;db&gt;__:&lt;event&gt; &lt;key&gt; notifications. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.notify_keyspace_events &amp; NOTIFY_KEYEVENT) &#123;</span><br><span class="line">        chan = sdsnewlen(<span class="string">"__keyevent@"</span>,<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">-1</span>) len = ll2string(buf,<span class="keyword">sizeof</span>(buf),dbid);</span><br><span class="line">        chan = sdscatlen(chan, buf, len);</span><br><span class="line">        chan = sdscatlen(chan, <span class="string">"__:"</span>, <span class="number">3</span>);</span><br><span class="line">        chan = sdscatsds(chan, eventobj-&gt;ptr);</span><br><span class="line">        chanobj = createObject(OBJ_STRING, chan);</span><br><span class="line">        pubsubPublishMessage(chanobj, key);</span><br><span class="line">        decrRefCount(chanobj);</span><br><span class="line">    &#125;</span><br><span class="line">    decrRefCount(eventobj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="Redis内存管理zmalloc"><a href="#Redis内存管理zmalloc" class="headerlink" title="Redis内存管理zmalloc"></a>Redis内存管理zmalloc</h2><p>Redis基于zmalloc系列函数进行内存分配。<br>zmalloc是为了解决什么问题呢？主要是为了做到异常处理和内存统计的功能。<br>下面看<code>zmalloc</code>的实现。<br>可以看到，它会额外分配一个<code>PREFIX_SIZE</code>，用来存储额外信息。<code>zmalloc</code>最终返回的是<code>(char*)ptr+PREFIX_SIZE</code>，这个有点类似于SDS的骚操作。<code>PREFIX_SIZE</code>的大小是由宏来定义的，并且可以通过<code>HAVE_MALLOC_SIZE</code>禁用内存统计的功能。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__sun) || defined(__sparc) || defined(__sparc__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(long long))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREFIX_SIZE (sizeof(size_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">zmalloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr = <span class="built_in">malloc</span>(size+PREFIX_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ptr) zmalloc_oom_handler(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_MALLOC_SIZE</span></span><br><span class="line">    <span class="comment">// 如果不记录内存分配大小</span></span><br><span class="line">    update_zmalloc_stat_alloc(zmalloc_size(ptr));</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果记录内存分配大小</span></span><br><span class="line">    *((<span class="keyword">size_t</span>*)ptr) = size;</span><br><span class="line">    update_zmalloc_stat_alloc(size+PREFIX_SIZE);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span>*)ptr+PREFIX_SIZE;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面仔细查看一下<code>update_zmalloc_stat_alloc</code>函数的实现，不出所料的话，应该是通过一个原子操作来实现更新的。实际上也果不其然，<code>atomicIncr</code>的实现在后面会讲到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span> used_memory = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> update_zmalloc_stat_alloc(__n) atomicIncr(used_memory,(__n))</span></span><br></pre></td></tr></table></figure><p>还可以看到的是一个用来处理oom的函数<code>zmalloc_oom_handler</code>。对于C语言来说，<code>malloc</code>在内存分配失败后会返回一个0指针，然后我们在进行后续操作的时候要自行判断。基本上对于oom的处理就是打印一条日志然后abort了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zmalloc.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zmalloc_default_oom</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"zmalloc: Out of memory trying to allocate %zu bytes\n"</span>,</span><br><span class="line">        size);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*zmalloc_oom_handler)</span><span class="params">(<span class="keyword">size_t</span>)</span> </span>= zmalloc_default_oom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisOutOfMemoryHandler</span><span class="params">(<span class="keyword">size_t</span> allocation_size)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Out Of Memory allocating %zu bytes!"</span>,</span><br><span class="line">        allocation_size);</span><br><span class="line">    serverPanic(<span class="string">"Redis aborting for OUT OF MEMORY. Allocating %zu bytes!"</span>, </span><br><span class="line">        allocation_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> serverPanic(...) _serverPanic(__FILE__,__LINE__,__VA_ARGS__),_exit(1)</span></span><br><span class="line"><span class="comment">// debug.c</span></span><br><span class="line"><span class="keyword">void</span> _serverPanic(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span> *msg, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap,msg);</span><br><span class="line">    <span class="keyword">char</span> fmtmsg[<span class="number">256</span>];</span><br><span class="line">    vsnprintf(fmtmsg,<span class="keyword">sizeof</span>(fmtmsg),msg,ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    bugReportStart();</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"------------------------------------------------"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"!!! Software Failure. Press left mouse button to continue"</span>);</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Guru Meditation: %s #%s:%d"</span>,fmtmsg,file,line);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.crashlog_enabled) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_BACKTRACE</span></span><br><span class="line">        logStackTrace(<span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        printCrashReport();</span><br><span class="line">    &#125;</span><br><span class="line">    bugReportEnd(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bugReportStart</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;bug_report_start_mutex);</span><br><span class="line">    <span class="keyword">if</span> (bug_report_start == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLogRaw(LL_WARNING|LL_RAW,</span><br><span class="line">        <span class="string">"\n\n=== REDIS BUG REPORT START: Cut &amp; paste starting from here ===\n"</span>);</span><br><span class="line">        bug_report_start = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;bug_report_start_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结一下本章节中比较有意思的实现：</p><ol><li>LFU算法</li><li>evictPoolEntry中，key和cached的维护</li><li>诸如keyptrDictType和dbDictType这种C形式的OOP的实现</li><li>Redis对OOM的管理</li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://my.oschina.net/lscherish/blog/4467394" target="_blank" rel="noopener">https://my.oschina.net/lscherish/blog/4467394</a><br> 对Redis中的LRU和LFU进行了讲解。本文吸纳了其中的部分内容并进行了修订。</li><li><a href="https://juejin.cn/post/6844903454654087182" target="_blank" rel="noopener">https://juejin.cn/post/6844903454654087182</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;因为原&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;《Redis底层对象实现原理分析》&lt;/a&gt;太大了，所以被拆解出来介绍Redis基础设施的相关实现，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;redisDb，以及在这上面的增删改查&lt;/li&gt;
&lt;li&gt;Redis的expire和evict机制&lt;/li&gt;
&lt;li&gt;Redis的事件机制&lt;/li&gt;
&lt;li&gt;Redis的主从复制(一部分)&lt;br&gt; 注意，很多实现在引入主从复制之后都变得非常复杂，有很多边边角角要考虑，这也导致Redis的代码相比3.0版本要难看很多。本文对主从复制的涉及，局限于帮助理解实现。&lt;br&gt; 本文介绍的部分比如propagate机制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文中不介绍的是，它们在系列的其他文章中讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis的对象实现&lt;/li&gt;
&lt;li&gt;Redis Sentinel&lt;/li&gt;
&lt;li&gt;Redis Cluster&lt;/li&gt;
&lt;li&gt;Redis AOF/RDB&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>我们如何消除两个开源项目之间长达 4 年的分叉</title>
    <link href="http://www.calvinneo.com/2022/10/13/decouple-tikv/"/>
    <id>http://www.calvinneo.com/2022/10/13/decouple-tikv/</id>
    <published>2022-10-13T11:20:33.000Z</published>
    <updated>2023-08-08T16:34:05.435Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects" target="_blank" rel="noopener">https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/how-we-eliminate-the-four-year-fork-between-two-open-source-projects&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>TiFlash 源码解读：TiFlash Proxy 模块</title>
    <link href="http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/"/>
    <id>http://www.calvinneo.com/2022/08/25/tiflash-proxy-reading/</id>
    <published>2022-08-25T11:20:33.000Z</published>
    <updated>2023-01-12T16:16:08.755Z</updated>
    
    <content type="html"><![CDATA[<p>转发我的文章<br><a href="https://cn.pingcap.com/blog/tiflash-source-code-reading-7" target="_blank" rel="noopener">https://cn.pingcap.com/blog/tiflash-source-code-reading-7</a></p><a id="more"></a>]]></content>
    
    
    <summary type="html">&lt;p&gt;转发我的文章&lt;br&gt;&lt;a href=&quot;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cn.pingcap.com/blog/tiflash-source-code-reading-7&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="Rust" scheme="http://www.calvinneo.com/tags/Rust/"/>
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
</feed>
