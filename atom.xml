<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Calvin&#39;s Marbles</title>
  
  
  <link href="http://www.calvinneo.com/atom.xml" rel="self"/>
  
  <link href="http://www.calvinneo.com/"/>
  <updated>2021-08-11T11:48:29.516Z</updated>
  <id>http://www.calvinneo.com/</id>
  
  <author>
    <name>Calvin Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WSL2使用的一些问题</title>
    <link href="http://www.calvinneo.com/2021/08/11/wsl2-probs/"/>
    <id>http://www.calvinneo.com/2021/08/11/wsl2-probs/</id>
    <published>2021-08-11T11:20:33.000Z</published>
    <updated>2021-08-11T11:48:29.516Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍WSL2使用的一些问题</p><a id="more"></a><h1 id="Windows-Store打不开"><a href="#Windows-Store打不开" class="headerlink" title="Windows Store打不开"></a>Windows Store打不开</h1><p>通常是代理问题。除了网上通用的方案，还需要在“Internet属性-局域网(LAN)设置”中关闭代理。</p><h1 id="共享SSH-Key"><a href="#共享SSH-Key" class="headerlink" title="共享SSH Key"></a>共享SSH Key</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a><br> WSL2的官方文档</li><li><a href="https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/" target="_blank" rel="noopener">https://devblogs.microsoft.com/commandline/sharing-ssh-keys-between-windows-and-wsl-2/</a><br> 共享SSH的问题</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍WSL2使用的一些问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="WSL2" scheme="http://www.calvinneo.com/tags/WSL2/"/>
    
  </entry>
  
  <entry>
    <title>Raft的TLA+验证介绍</title>
    <link href="http://www.calvinneo.com/2021/07/28/raft-tla/"/>
    <id>http://www.calvinneo.com/2021/07/28/raft-tla/</id>
    <published>2021-07-28T15:20:37.000Z</published>
    <updated>2021-07-29T16:05:08.926Z</updated>
    
    <content type="html"><![CDATA[<p>介绍使用TLA+对Raft的验证工作。</p><p><a href="https://github.com/ongardie/raft.tla/blob/master/raft.tla" target="_blank" rel="noopener">Ongaro等已经在Github上提供了一版TLA+的实现</a></p><a id="more"></a><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>容易发现，源码里面不包含TLC的Config，但是我们在<a href="https://github.com/ongardie/raft.tla/issues/1" target="_blank" rel="noopener">Issue 1</a>里面能找到一个。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">CONSTANTS<span class="built_in"> Server </span>= &#123;r1,r2,r3&#125;</span><br><span class="line">          Value = &#123;v1,v2&#125;</span><br><span class="line">          Follower = Follower</span><br><span class="line">          Candidate = Candidate</span><br><span class="line">          Leader = Leader</span><br><span class="line">          <span class="literal">Nil</span> = <span class="literal">Nil</span></span><br><span class="line">          RequestVoteRequest = RequestVoteRequest</span><br><span class="line">          RequestVoteResponse = RequestVoteResponse</span><br><span class="line">          AppendEntriesRequest = AppendEntriesRequest</span><br><span class="line">          AppendEntriesResponse = AppendEntriesResponse</span><br><span class="line">          TLC_MAX_TERM = 3</span><br><span class="line">          TLC_MAX_ENTRY = 1</span><br><span class="line">          TLC_MAX_MESSAGE = 1</span><br><span class="line">\*          PNat = &#123;1,2,3,4,5&#125;</span><br><span class="line">\*         <span class="built_in"> Nat </span>= &#123;0,1,2,3,4,5&#125;</span><br><span class="line">\*SYMMETRY Perms</span><br><span class="line">SPECIFICATION Spec</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT TermConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT LogConstraint</span><br><span class="line">\<span class="number">*C</span>ONSTRAINT MessageConstraint</span><br><span class="line">\*INVARIANT AtMostOneLeaderPerTerm</span><br><span class="line">\*INVARIANT TermAndIndexDeterminesLogPrefix</span><br><span class="line">\*INVARIANT StateMachineSafety</span><br><span class="line">\*INVARIANT NewLeaderHasCompleteLog</span><br><span class="line">\*INVARIANT CommitInOrder</span><br><span class="line"></span><br><span class="line">\*INVARIANT MessageTypeInv</span><br><span class="line">\*INVARIANT TypeInv</span><br></pre></td></tr></table></figure></p><p>需要限制一下Model<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: Len(log[i]) =&lt; maxLength</span><br><span class="line">/\ \A i \<span class="keyword">in</span><span class="built_in"> Server </span>: currentTerm[i] =&lt; maxTerm</span><br><span class="line">/\ Cardinality(DOMAIN messages) =&lt; maxMessage</span><br><span class="line">/\ restartNum =&lt; maxRestartNum</span><br><span class="line">/\ timeoutNum =&lt; maxTimeoutNum</span><br><span class="line">/\ actionNum =&lt; maxActionNum</span><br></pre></td></tr></table></figure></p><p>timeoutNum必须至少为1，不然不能触发选举</p><p>列出一下Safety条件<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OneLeader == Cardinality( &#123;i \<span class="keyword">in</span><span class="built_in"> Server </span>: state[i] = Leader&#125; ) &lt;= 1</span><br></pre></td></tr></table></figure></p><p>注意如下错误<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The subscript <span class="keyword">of</span> <span class="keyword">the</span> next-state relation specified <span class="keyword">by</span> <span class="keyword">the</span> specification</span><br><span class="line">does <span class="keyword">not</span> seem <span class="built_in">to</span> contain <span class="keyword">the</span> state <span class="built_in">variable</span> xxx</span><br></pre></td></tr></table></figure></p><p>看看xxx是不是在vars里面<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars</span><br></pre></td></tr></table></figure></p><p>打印语句<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Print</span><span class="params">(内容, Print语句的值)</span></span></span><br></pre></td></tr></table></figure></p><p>发现maxMessage必须为1，其他都可以变。</p><h1 id="总体模型"><a href="#总体模型" class="headerlink" title="总体模型"></a>总体模型</h1><h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>下面的变量是全局的：</p><ol><li><p>messages<br> 表示从一个Server发送到另一个Server的消息。因为TLAPS不支持Bags模块(也就是所谓的multiset)，所以这是一个将消息映射为Nat的<strong>函数</strong>。<br> 通过<code>WithMessage(m, msgs)</code>往<code>messages</code>添加一条消息，其中<code>m</code>是我们需要发送的消息，<code>msgs</code>就是<code>messages</code>这个变量。</p> <figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WithMessage(m, msgs) ==</span><br><span class="line"><span class="keyword">IF</span> m \<span class="keyword">in</span> DOMAIN msgs <span class="keyword">THEN</span></span><br><span class="line">    [msgs <span class="keyword">EXCEPT</span> ![m] = msgs[m] + <span class="number">1</span>]</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">    msgs @@ (m :&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 消息的格式如下图所示</p> <figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="name">mtype</span>         |-&gt; RequestVoteRequest,</span><br><span class="line"> mterm         |-&gt; currentTerm[<span class="name">i</span>],</span><br><span class="line"> mlastLogTerm  |-&gt; LastTerm(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> mlastLogIndex |-&gt; Len(<span class="name"><span class="builtin-name">log</span></span>[<span class="name">i</span>]),</span><br><span class="line"> msource       |-&gt; i,</span><br><span class="line"> mdest         |-&gt; j]</span><br></pre></td></tr></table></figure></li><li><p>elections<br> 仅在证明(proof)中需要，实现(implementation)并不需要。<br> 这个用来记录所有成功的选举。包括Leader和Voter的日志。其中一个元素类似下面。</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;[ <span class="function"><span class="title">eterm</span>     |-&gt;</span> currentTerm[i],</span><br><span class="line">   <span class="function"><span class="title">eleader</span>   |-&gt;</span> i,</span><br><span class="line">   <span class="function"><span class="title">elog</span>      |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">   <span class="function"><span class="title">evotes</span>    |-&gt;</span> votesGranted[i],</span><br><span class="line">   <span class="function"><span class="title">evoterLog</span> |-&gt;</span> voterLog[i]]&#125;</span><br></pre></td></tr></table></figure></li><li><p>allLogs<br> 同样仅在证明中需要。<br> 集合了每个Server上的日志</p> <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="literal">all</span>Logs' = <span class="literal">all</span>Logs \cup &#123;<span class="keyword">log</span>[i] : i \<span class="keyword">in</span> Server&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下面的变量是Per Server的：</p><ol><li>serverVars<br> 为<code>&lt;&lt;currentTerm, state, votedFor&gt;&gt;</code><br> 在Init中，currentTerm初始化为1，state初始化为Follower，voteFor初始化为Nil。</li><li><p>logVars<br> 为<code>&lt;&lt;log, commitIndex&gt;&gt;</code><br> 其中log是A Sequence of log entries，<code>log[i]</code>表示Server i上的日志。<br> 在Init中，log初始化为</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log = [i \<span class="keyword">in</span><span class="built_in"> Server </span>|-&gt; &lt;&lt; &gt;&gt;]</span><br></pre></td></tr></table></figure><p> 每个Log Entry的格式是</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[term  |-&gt; currentTerm[i],</span><br><span class="line"> value |-&gt; v]</span><br></pre></td></tr></table></figure><p> commitIndex初始化为0。</p></li><li>candidateVars<br> 为<code>&lt;&lt;votesResponded, votesGranted, voterLog&gt;&gt;</code></li><li>leaderVars<br> 为<code>&lt;&lt;nextIndex, matchIndex, elections&gt;&gt;</code><br> 在Init中，nextIndex全部被初始化为1，matchIndex全部被初始化为0。</li></ol><h2 id="Helper"><a href="#Helper" class="headerlink" title="Helper"></a>Helper</h2><p>Quorum实际上是一个集合的集合。表示Server中所有可以形成Quorum的子集。<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Quorum == &#123;i \<span class="keyword">in</span> SUBSET(<span class="built_in">Server</span>) : Cardinality(i) * <span class="number">2</span> &gt; Cardinality(<span class="built_in">Server</span>)&#125;</span><br></pre></td></tr></table></figure></p><h1 id="周边Action"><a href="#周边Action" class="headerlink" title="周边Action"></a>周边Action</h1><h2 id="Spec"><a href="#Spec" class="headerlink" title="Spec"></a>Spec</h2><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Next == /<span class="symbol">\ </span><span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Restart(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : Timeout(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : RequestVote(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : BecomeLeader(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server, v <span class="symbol">\i</span>n Value : ClientRequest(i, v)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i <span class="symbol">\i</span>n Server : AdvanceCommitIndex(i)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> i,j <span class="symbol">\i</span>n Server : AppendEntries(i, j)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : Receive(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DuplicateMessage(m)</span><br><span class="line">           <span class="symbol">\/</span> <span class="symbol">\E</span> m <span class="symbol">\i</span>n DOMAIN messages : DropMessage(m)</span><br><span class="line">           <span class="symbol">\*</span> History variable that tracks every log ever:</span><br><span class="line">        /<span class="symbol">\ </span>allLogs' = allLogs <span class="symbol">\c</span>up &#123;log[i] : i <span class="symbol">\i</span>n Server&#125;</span><br></pre></td></tr></table></figure><h1 id="主要Acttion"><a href="#主要Acttion" class="headerlink" title="主要Acttion"></a>主要Acttion</h1><h2 id="AppendEntries"><a href="#AppendEntries" class="headerlink" title="AppendEntries"></a>AppendEntries</h2><p>Enabling条件，就是自己是Leader，并且不能自己给自己发消息。<br><code>SubSeq(s,m,n)</code>表示<code>&lt;&lt; s[m], s[m+1], ..., s[n] &gt;&gt;</code><br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">AppendEntries(i, j) ==</span><br><span class="line">    /\ i /= j</span><br><span class="line">    /\ state[i] = Leader</span><br><span class="line">    /\ LET prevLogIndex == nextIndex[i][j] - <span class="number">1</span></span><br><span class="line">           prevLogTerm == IF prevLogIndex &gt; <span class="number">0</span> THEN</span><br><span class="line">                              <span class="built_in">log</span>[i][prevLogIndex].term</span><br><span class="line">                          ELSE</span><br><span class="line">                              <span class="number">0</span></span><br><span class="line">           \* Send up to <span class="number">1</span> entry, constrained <span class="keyword">by</span> the end of the <span class="built_in">log</span>.</span><br><span class="line">           lastEntry == Min(&#123;Len(<span class="built_in">log</span>[i]), nextIndex[i][j]&#125;)</span><br><span class="line">           entries == SubSeq(<span class="built_in">log</span>[i], nextIndex[i][j], lastEntry)</span><br><span class="line">       IN S<span class="function"><span class="title">end</span>([mtype          |-&gt;</span> AppendEntriesRequest,</span><br><span class="line">                <span class="function"><span class="title">mterm</span>          |-&gt;</span> currentTerm[i],</span><br><span class="line">                <span class="function"><span class="title">mprevLogIndex</span>  |-&gt;</span> prevLogIndex,</span><br><span class="line">                <span class="function"><span class="title">mprevLogTerm</span>   |-&gt;</span> prevLogTerm,</span><br><span class="line">                <span class="function"><span class="title">mentries</span>       |-&gt;</span> entries,</span><br><span class="line">                \* mlog <span class="keyword">is</span> used <span class="keyword">as</span> a history variable <span class="keyword">for</span> the proof.</span><br><span class="line">                \* It would <span class="built_in">not</span> exist <span class="built_in">in</span> a <span class="keyword">real</span> implementation.</span><br><span class="line">                <span class="function"><span class="title">mlog</span>           |-&gt;</span> <span class="built_in">log</span>[i],</span><br><span class="line">                <span class="function"><span class="title">mcommitIndex</span>   |-&gt;</span> Min(&#123;commitIndex[i], lastEntry&#125;),</span><br><span class="line">                <span class="function"><span class="title">msource</span>        |-&gt;</span> i,</span><br><span class="line">                <span class="function"><span class="title">mdest</span>          |-&gt;</span> j])</span><br><span class="line">    /\ UNCHANGED <span class="string">&lt;&lt;serverVars, candidateVars, leaderVars, logVars&gt;&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="对端处理AppendEntries"><a href="#对端处理AppendEntries" class="headerlink" title="对端处理AppendEntries"></a>对端处理AppendEntries</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">HandleAppendEntriesRequest</span><span class="params">(i, j, m)</span></span> ==</span><br><span class="line">    LET logOk == \/ m<span class="selector-class">.mprevLogIndex</span> = <span class="number">0</span></span><br><span class="line">                 \/ /\ m<span class="selector-class">.mprevLogIndex</span> &gt; <span class="number">0</span></span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogIndex</span> &lt;= Len(log[i])</span><br><span class="line">                    /\ m<span class="selector-class">.mprevLogTerm</span> = log[i][m.mprevLogIndex].term</span><br><span class="line">    IN /\ m<span class="selector-class">.mterm</span> &lt;= currentTerm[i]</span><br></pre></td></tr></table></figure><p>下面处理分为三个部分：<br>拒绝<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">       <span class="regexp">/\ \/ /</span><span class="string">\</span> <span class="string">\*</span> reject request</span><br><span class="line">                <span class="string">\/</span> m.mterm &lt; currentTerm[i]</span><br><span class="line">                <span class="string">\/</span> /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">                   /<span class="string">\</span> state[i] = Follower</span><br><span class="line">                   /<span class="string">\</span> <span class="string">\lnot</span> logOk</span><br><span class="line">             /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                       mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                       msuccess        |<span class="function">-&gt;</span> FALSE,</span><br><span class="line">                       mmatchIndex     |<span class="function">-&gt;</span> <span class="number">0</span>,</span><br><span class="line">                       msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                       mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                       m)</span><br><span class="line">             /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, logVars&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>切换为Follower<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          \/ \* return <span class="keyword">to</span> follower <span class="keyword">state</span></span><br><span class="line">             /\ m.mterm = currentTerm[i]</span><br><span class="line">             /\ <span class="keyword">state</span>[i] = Candidate</span><br><span class="line">             /\ <span class="keyword">state</span>' = [<span class="keyword">state</span> EXCEPT ![i] = Follower]</span><br><span class="line">             /\ UNCHANGED <span class="variable">&lt;&lt;currentTerm, votedFor, logVars, messages&gt;</span>&gt;</span><br></pre></td></tr></table></figure></p><p>接受<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">          <span class="string">\/</span> <span class="string">\*</span> accept request</span><br><span class="line">             /<span class="string">\</span> m.mterm = currentTerm[i]</span><br><span class="line">             /<span class="string">\</span> state[i] = Follower</span><br><span class="line">             /<span class="string">\</span> logOk</span><br><span class="line">             /<span class="string">\</span> LET index == m.mprevLogIndex + <span class="number">1</span></span><br><span class="line">                IN <span class="string">\/</span> <span class="string">\*</span> already done <span class="keyword">with</span> request</span><br><span class="line">                       <span class="regexp">/\ \/</span> m.mentries = &lt;&lt; &gt;&gt;</span><br><span class="line">                          <span class="string">\/</span> <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                             /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                             /<span class="string">\</span> log[i][index].term = m.mentries[<span class="number">1</span>].term</span><br><span class="line">                          <span class="string">\*</span> This could make our commitIndex decrease (<span class="keyword">for</span></span><br><span class="line">                          <span class="string">\*</span> example <span class="keyword">if</span> we process an old, duplicated request),</span><br><span class="line">                          <span class="string">\*</span> but <span class="literal">that</span> doesn<span class="string">'t really affect anything.</span></span><br><span class="line"><span class="string">                       /\ commitIndex'</span> = [commitIndex EXCEPT ![i] =</span><br><span class="line">                                              m.mcommitIndex]</span><br><span class="line">                       /<span class="string">\</span> Reply([mtype           |<span class="function">-&gt;</span> AppendEntriesResponse,</span><br><span class="line">                                 mterm           |<span class="function">-&gt;</span> currentTerm[i],</span><br><span class="line">                                 msuccess        |<span class="function">-&gt;</span> TRUE,</span><br><span class="line">                                 mmatchIndex     |<span class="function">-&gt;</span> m.mprevLogIndex +</span><br><span class="line">                                                     Len(m.mentries),</span><br><span class="line">                                 msource         |<span class="function">-&gt;</span> i,</span><br><span class="line">                                 mdest           |<span class="function">-&gt;</span> j],</span><br><span class="line">                                 m)</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, log&gt;&gt;</span><br><span class="line">                   <span class="string">\/</span> <span class="string">\*</span> conflict: remove <span class="number">1</span> entry</span><br><span class="line">                       <span class="regexp">/\ m.mentries /</span>= &lt;&lt; &gt;&gt;</span><br><span class="line">                       /<span class="string">\</span> Len(log[i]) &gt;= index</span><br><span class="line">                       <span class="regexp">/\ log[i][index].term /</span>= m.mentries[<span class="number">1</span>].term</span><br><span class="line">                       /<span class="string">\</span> LET <span class="keyword">new</span> == [index2 <span class="string">\in</span> <span class="number">1.</span>.(Len(log[i]) - <span class="number">1</span>) |<span class="function">-&gt;</span></span><br><span class="line">                                          log[i][index2]]</span><br><span class="line">                          IN log<span class="string">' = [log EXCEPT ![i] = new]</span></span><br><span class="line"><span class="string">                       /\ UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span></span><br><span class="line"><span class="string">                   \/ \* no conflict: append entry</span></span><br><span class="line"><span class="string">                       /\ m.mentries /= &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="string">                       /\ Len(log[i]) = m.mprevLogIndex</span></span><br><span class="line"><span class="string">                       /\ log'</span> = [log EXCEPT ![i] =</span><br><span class="line">                                      Append(log[i], m.mentries[<span class="number">1</span>])]</span><br><span class="line">                       /<span class="string">\</span> UNCHANGED &lt;&lt;serverVars, commitIndex, messages&gt;&gt;</span><br><span class="line">       /<span class="string">\</span> UNCHANGED &lt;&lt;candidateVars, leaderVars&gt;&gt;</span><br></pre></td></tr></table></figure></p><h2 id="AppendEntries处理对端返回"><a href="#AppendEntries处理对端返回" class="headerlink" title="AppendEntries处理对端返回"></a>AppendEntries处理对端返回</h2><h2 id="RequestVote"><a href="#RequestVote" class="headerlink" title="RequestVote"></a>RequestVote</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_membership.tla</a><br> Raft的Membership Change证明</li><li><a href="https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla" target="_blank" rel="noopener">https://github.com/dranov/raft-tla/blob/master/thirdparty/raft_dricketts.tla</a><br> 一个带有很多Inv的Raft的TLA+</li><li><a href="https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla" target="_blank" rel="noopener">https://github.com/tlaplus/CommunityModules/blob/master/modules/SequencesExt.tla</a><br> Sequences扩展</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍使用TLA+对Raft的验证工作。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ongardie/raft.tla/blob/master/raft.tla&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ongaro等已经在Github上提供了一版TLA+的实现&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="raft" scheme="http://www.calvinneo.com/tags/raft/"/>
    
    <category term="TLA" scheme="http://www.calvinneo.com/tags/TLA/"/>
    
  </entry>
  
  <entry>
    <title>TLA用法</title>
    <link href="http://www.calvinneo.com/2021/06/26/tla/"/>
    <id>http://www.calvinneo.com/2021/06/26/tla/</id>
    <published>2021-06-26T15:20:37.000Z</published>
    <updated>2021-08-11T15:21:31.905Z</updated>
    
    <content type="html"><![CDATA[<p>介绍TLA+用法。<br>TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。<br>TLC是TLA+的模型检验工具。</p><a id="more"></a><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><p>Module，是我们写TLA+ Specification的地方。<br>Model，是我们用TLC检验我们TLA+ Module的地方。</p><h2 id="Model-Value"><a href="#Model-Value" class="headerlink" title="Model Value"></a>Model Value</h2><p>在”What is the model?”中。</p><h2 id="模型-Model-行为"><a href="#模型-Model-行为" class="headerlink" title="模型(Model)行为"></a>模型(Model)行为</h2><p>在”What is the behavior spec?”中。</p><ol><li><p>Ordinary assignment<br> 例如</p> <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RM &lt;- &#123;<span class="string">"r1"</span>, <span class="string">"r2"</span>, <span class="string">"r3"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>Model value</p></li><li>Set of model values<br> 例如 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">RM</span> &lt;- &#123;<span class="built_in">r1</span>, <span class="built_in">r2</span>, <span class="built_in">r3</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="检查项目"><a href="#检查项目" class="headerlink" title="检查项目"></a>检查项目</h2><p>在”What to Check”中：</p><ol><li>Invariants<br> 例如各种Spec</li><li>Properties<br> 例如Termination</li></ol><h2 id="TLC-Option"><a href="#TLC-Option" class="headerlink" title="TLC Option"></a>TLC Option</h2><h2 id="如何调试"><a href="#如何调试" class="headerlink" title="如何调试"></a>如何调试</h2><p>创建一个Spec，写入我们要计算的函数。<br>新建一个Module，设置”What is the behavior spec?”为”No Behavior Spec”。<br>在”Evaluate Constant Expression”中，对我们要计算的函数带入具体值。</p><h2 id="从命令行执行"><a href="#从命令行执行" class="headerlink" title="从命令行执行"></a>从命令行执行</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java tlc2<span class="selector-class">.TLC</span> -config .\TESpecSafetyTest<span class="selector-class">.cfg</span> -workers <span class="number">4</span> -dfid <span class="number">10</span> .\TESpecTest.tla</span><br></pre></td></tr></table></figure><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="逻辑部分"><a href="#逻辑部分" class="headerlink" title="逻辑部分"></a>逻辑部分</h2><ol><li><code>\/</code><br> 表示or。</li><li><code>/\</code><br> 表示and。</li><li><code>\A x \in S: P(x)</code><br> <strong>对于任意的</strong>S中的x，满足<code>P(x)</code>。</li><li><code>\E x \in S: P(x)</code><br> S中<strong>存在</strong>某个x，满足<code>P(x)</code>。<br> 注意，一般会用<code>\E</code>来表示<strong>选择任意一个</strong>元素进行操作的语义。如下所示，我们在<code>AtoB</code>中移除任意一个位置的元素。因此我们进一步能看到，TLA并不是命令式的，而是描述式的。 <figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\E i \<span class="keyword">in</span> <span class="number">1</span>..Len(A<span class="keyword">to</span>B): A<span class="keyword">to</span>B' = Remove(i, A<span class="keyword">to</span>B)</span><br></pre></td></tr></table></figure></li></ol><h2 id="函数-映射部分"><a href="#函数-映射部分" class="headerlink" title="函数/映射部分"></a>函数/映射部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>函数通常用中括号括起来。</p><ol><li><p><code>F == [x \in S |-&gt; e]</code><br> 对S中的元素应用e，类似于mapper。<br> 函数的执行结果是一个tuple，例如下面函数的结果是<code>&lt;&lt;2, 3&gt;&gt;</code></p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i \in <span class="number">1.</span><span class="number">.2</span> |-&gt; i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>F[x \in S] == e</code></p></li><li><p><code>[S -&gt; T]</code><br> 表示了从S到T的<strong>一系列</strong>函数。<br> <a href="https://learntla.com/tla/functions/" target="_blank" rel="noopener">例如</a>，对于People中的p和Animals中的a，p对a可能like或者hate，我们可以写成下面的形式</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P<span class="function"><span class="title">ref</span> == [People -&gt;</span> [A<span class="function"><span class="title">nimals</span> -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [[person: People, animal: Animals] -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br><span class="line">P<span class="function"><span class="title">ref</span> == [People \X Animals -&gt;</span> &#123;<span class="string">"like"</span>, <span class="string">"hate"</span>&#125;]</span><br></pre></td></tr></table></figure><p> 需要区别<code>|-&gt;</code>和<code>-&gt;</code>，前者表示是从DOMAIN到某个特定的RANGE的<strong>一个函数</strong>，后者表示从DOMAIN到RANGE的一系列函数。</p></li><li><p><code>[S EXCEPT ![x] = v]</code><br> 这个语句通常用来表示返回整个集合，但是对集合中的某个特定元素的值进行变化。<br> 如果S是一个集合，表示返回S，除了x等于v。<br> 如果S是一个Record（类似于C里面的struct），表示返回S，除了x等于v。例如</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[f EXCEPT !.prof = <span class="string">"RED"</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>@@</code>和<code>:&gt;</code><br> 这两个符号用来定义函数。例如函数定义域是<code>{1,2}</code>，我们可以这么定义<code>f</code></p> <figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>:&gt; <span class="string">"ab"</span> @@ <span class="number">2</span> :&gt; <span class="string">"cd"</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="集合-元组-Record部分"><a href="#集合-元组-Record部分" class="headerlink" title="集合/元组/Record部分"></a>集合/元组/Record部分</h2><p>这一部分可以查看Specify System中的第300页开始。<br>此外，在第339页开始会介绍标准模块，如Sequences、Bags等。</p><ol><li><p>Record<br> Record类似于C++里面的struct。<br> 如何表示一个Record的实例？</p> <figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="function"><span class="title">type</span> |-&gt;</span> <span class="string">"Prepared"</span>, <span class="function"><span class="title">rm</span> |-&gt;</span> r]</span><br></pre></td></tr></table></figure></li><li><p><code>&lt;&lt;&quot;a&quot;, 42, {1,2}&gt;&gt;</code><br> 表示一个tuple，在P09a中也被Lamport称为Finite sequence。<br> tuple从1编号。</p></li><li><code>{1,2,3}</code><br> 表示一个Set。</li><li><p>Tuple简单运算符<br> Head和Tail类似于car和cdr。<br> <code>\o</code>表示concat。如果<code>seq /= &lt;&lt;&gt;&gt;</code>，有<code>seq = &lt;&lt;Head(seq)&gt;&gt; \o Tail(seq)</code>。<br> <code>Append(tuple,elem)</code>表示将elem放到tuple的末尾。<br> <code>Len</code>，返回长度。<br> <code>Remove(i, seq)</code>表示从<code>seq</code>移除<code>i</code>位置的元素之后的新seq。<br> <code>\X</code>表示计算笛卡尔积。<br> Seq表示所有由这个tuple中元素构成的序列。例如<code>Seq({2})</code>是<code>{&lt;&lt;&gt;&gt;,&lt;&lt;3&gt;&gt;, &lt;&lt;3,3&gt;&gt;, &lt;&lt;3,3,3&gt;&gt;, ...}</code>。我们可以进行下面的实验</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br><span class="line">&lt;&lt;<span class="number">2</span>&gt;&gt; \in Se<span class="string">q(&#123;0,1&#125;)</span></span><br></pre></td></tr></table></figure></li><li><p>Set运算符<br> <code>SUBSET(S)</code>求出所有子集，例如<code>SUBSET( {1,2,3} )</code>返回</p> <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; &#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p> <code>Cardinality(S)</code>计算一个集合的大小。<br> <code>IsFiniteSet(S)</code>计算一个集合是不是有限集。</p></li><li><code>DOMAIN &lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;</code><br> 表示一个集合。Lamport说Math中的DOMAIN，对应于Progamming中的Index Set。</li><li><code>&lt;&lt;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&gt;&gt;[2]</code><br> 表示集合中的第2个元素，即<code>&quot;b&quot;</code>。</li><li><p>“构造函数”<code>{e: v \in S}</code><br> 对S中的元素应用e，类似于mapper。<br> 需要区别<code>|-&gt;</code>和<code>:</code>：</p> <figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">Rem(i, seq) == [j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span> |-&gt; IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>]</span><br><span class="line">RemSet(i, seq) == &#123;(IF j&lt;i THEN se<span class="string">q[j]</span> ELSE se<span class="string">q[j+1]</span>) : j \in <span class="number">1</span>..Len(seq)-<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>“构造函数”<code>{v \in S: P}</code><br> 类似一个filter。</p></li><li><p><code>UNCHANGED &lt;&lt;x,y&gt;&gt;</code><br> 是一个语法糖，可以理解为</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/<span class="string">\</span> x<span class="string">' = x</span></span><br><span class="line"><span class="string">/\ y'</span> = y</span><br></pre></td></tr></table></figure></li><li><p><code>CHOOSE v \in S: P</code><br> 在S中满足P的元素中任选一个v。注意这个CHOOSE是没有随机性的，我们比较</p> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\E <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : x' = <span class="built_in">i</span></span><br><span class="line">x' = CHOOSE <span class="built_in">i</span> \in <span class="number">1.</span><span class="number">.99</span> : TRUE</span><br></pre></td></tr></table></figure><p> 上面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间任意一个数。<br> 下面的式子允许<code>x&#39;</code>下一个状态的值是1..99之间某个特定的数。<br> CHOOSE主要用法是：S中只有一个v满足P，比如最大值最小值等，我们将这个v取出来。所以一般CHOOSE和TRUE这个Predicate不会连用。<br> 下面，我们通过CHOOSE计算在一段区间中的最大质数。可以在模型中执行<code>LargestPrime(1..1000)</code>，得到结果997。</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXTENDS Integers, Sequences</span><br><span class="line">IsPrime(x) == x &gt; <span class="number">1</span> /<span class="string">\</span> ~<span class="string">\E</span> d <span class="string">\in</span> <span class="number">2.</span>.(x-<span class="number">1</span>) : x % d = <span class="number">0</span></span><br><span class="line">LargestPrime(S) == CHOOSE x <span class="string">\in</span> S:</span><br><span class="line">                    /<span class="string">\</span> IsPrime(x)</span><br><span class="line">                    /<span class="string">\</span> <span class="string">\A</span> y <span class="string">\in</span> S:</span><br><span class="line">                        IsPrime(y) =&gt; y &lt;= x</span><br></pre></td></tr></table></figure></li></ol><h2 id="Expression-Spec部分"><a href="#Expression-Spec部分" class="headerlink" title="Expression/Spec部分"></a>Expression/Spec部分</h2><ol><li>IF-THEN-ELSE</li><li><p>Enabling condition<br> 这是一个概念，例如下面式子中，第一个式子就是enabling condition，因为它并没有涉及下一个状态<code>rmState&#39;</code></p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DecideC(r) == /\ rmState<span class="string">[r]</span> = <span class="string">"prepared"</span></span><br><span class="line">              /\ rmState' = <span class="string">[rmState EXCEPT ![r]</span> = <span class="string">"committed"</span>]</span><br></pre></td></tr></table></figure><p> 如果在state s时满足了这些Enabling条件，则A被enabled，且<code>s-&gt;t</code>是一个A step。</p></li><li>Constant expression</li><li>State expression<br> 能够包含所有Constant expression能够包含的元素。此外，还能包含声明了的变量。<br> 需要注意的还是，在P08b里面，Lamport说一个State表示给variable进行赋值。这里的variable表示所有可能的variable，而不是被定义出来的variable。我觉得实际在说在一个formula里面，如果没有提到其他变量，并不代表不存在其他变量。<br> State的值取决于变量的值。</li><li>Action expression<br> 能够包含所有State expression能够包含的元素。此外，还能包含<code>&#39;</code>和<code>UNCHANGED</code>。<br> 一个State expression是一个Action expression，它在一个step<code>s-&gt;t</code>上具有一个值，这个值只取决于s。<br> 这里step表示一对状态之间的切换。例如，state s是<code>p &lt;- 42</code>，state t是<code>q &lt;- 24</code>，那么<code>p-q&#39;</code>在step<code>s-&gt;t</code>上具有值<code>42-24</code>。</li><li><p>THEOREM<br> 对于一个Temporal formula，<code>THEOREM TF</code>表示<code>TF</code>在每个可能行为下，都是true。<br> 例如下面的THEOREM表示对于每一个behavior，如果<code>TPSpec</code>是true（也就是这个behavior满足TPSpec的条件），那么<code>[]TPTypeOK</code>也是true（也就是对于这个bahavior下的每个state都是true）。</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM TPSpec =&gt; <span class="string">[]</span>TPTypeOK</span><br></pre></td></tr></table></figure><p> 我们进一步理解为，<code>TPTypeOK</code>是关于<code>TpSpec</code>的不变量。<br> 我们还可以说<code>TPSpec</code>实现(implement)了<code>[]TPTypeOK</code>。<br> 为了检查这个THEOREM，有两种方案：</p><ol><li>将<code>[]TPTypeOK</code>/<code>TPSpec</code>加入<strong>“What to check?”</strong>下面的<strong>Properties</strong>中。</li><li>将<code>TPTypeOK</code>加入<strong>“What to check?”</strong>下面的<strong>Invariants</strong>中。</li></ol></li><li>Behavior </li><li>Temporal(时序的) formula<br> 一般写成<code>Spec == Init /\ []Next</code>。<br> 在学习TCommit的时候，我们都是在Module标签页里面”Initial predicate and next-state relation”这个标签里面指定Init和Next的，现在<strong>可以直接在Temporal formula标签里面</strong>直接填我们的Spec了。</li><li><p>Stuttering steps<br> 在Temporal formula中，会见到下面的写法，在<code>TCNext</code>周围包围了中括号：</p> <figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[]</span><span class="string">[TCNext]</span>_rmState</span><br></pre></td></tr></table></figure><p> 它等价于下面的形式，也就是说满足TCNext，或者保持rmState不变。后者称为stuttering steps。</p> <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">TCNext</span> \/ (UNCHANGED rmState)</span><br></pre></td></tr></table></figure><p> 因此，一个常见的Temporal formula写法可以是</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>Stuttering steps和Termination<br> 一个有无限长的Stuttering steps作为结尾的behavior是一个Terminating execution。<br> 这个是容易理解的，在我们的系统停止之后，地球还是照转不误的。所以所有的behavior都是无限长的state构成的序列。</p></li><li><p>May和Must<br> 我觉得这是一个贯穿的思想，也就是Lamport反复强调TLA+是一个数学的，而不是命令的东西。<br> Spec中的主体部分都是May部分，规定了系统可能做什么，而不是必须做什么。可以加入<code>L</code>，作为Must部分</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>L</span><br></pre></td></tr></table></figure><p> 一个Safety Formula断言May发生的事件。<br> 一个Liveness Formula断言Must发生的事件。这表示在任何时候都不能违反的条件。</p></li><li><p><code>[]</code>和<code>~&gt;</code><br> 对于顺序执行的程序来说，只需要满足能够最终终止就行了。这里最终表示为<code>&lt;&gt;</code>。关于<code>&lt;&gt;</code>，有下面的关系</p> <figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&gt;<span class="keyword">P</span> == ~[]~<span class="keyword">P</span></span><br></pre></td></tr></table></figure><p> <code>~&gt;</code>表示lead to。对于ABSpec来说，它的Liveness property是</p> <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li><li><p>Fairness<br> Weak Fairness指，如果Action A持续(continuouesly) enabled（enabled定义见下面），那么一个A step会最终发生。也就是说，下图中的绿色部分一定会发生一个A step。<br> <img src="/img/tla/wf.png" alt=""><br> Weak Fairness使用下面的格式，其中vars是这个Spec中涉及的所有变量。</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">WF_vars</span><span class="params">(A)</span></span></span><br></pre></td></tr></table></figure><p> 容易看出，Weak Fairness是一个Liveness property。因为它在A step或者A没有被enabled的时候，都是true。<br> 对应的，还有Strong Fairness，如果Action A重复地(repeatedly) enabled，那么一个A step会最终发生。<br> 因此，我们可以总结得到具有Liveness的Spec的格式。其中Fairness是<code>WF_vars(A)</code>和<code>SF_vars(A)</code>的组合，其中A是Next的之动作。</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_&lt;&lt;...&gt;&gt; /<span class="tag">\<span class="name"> </span></span>Fairness</span><br></pre></td></tr></table></figure><p> 即</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spec == Init /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[Next]</span></span>_vars /<span class="tag">\<span class="name"> </span></span>WF_vars(Next)</span><br></pre></td></tr></table></figure><p> 在检查Liveness条件时，不能使用symmetry set。</p></li><li>精化(refinement)关系<br> 为了使用TLC检验在精化映射<code>φ</code>下，ImplSpec到AbsSpec的精化关系，我们在模块ImplModule中添加定义和THEAOREM <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AbsSub ==<span class="built_in"> INSTANCE </span>AbsModule</span><br><span class="line">THEOREM ImplSpec =&gt; AbsSub!AbsSpec</span><br></pre></td></tr></table></figure></li></ol><h2 id="尚未归类"><a href="#尚未归类" class="headerlink" title="尚未归类"></a>尚未归类</h2><ol><li>ASSUME<br> 必须是一个布尔量的常量表达式</li><li>CONSTANTS<br> 定义了一系列常量，这些常量都可以理解为是集合。<br> 根据Lamport的P10a，传统数学中的变量，类似于TLA+中的CONSTANT。传统数学中没有和TLA+中的VARIABLE对应的概念，这个概念属于Temporal Logic(时序逻辑)。</li><li>VARIABLE/VARIABLES<br> 以TCommit为例，我们定义了<code>CONSTANT RM</code>，还定义了<code>VARIABLE rmState</code>。<br> 如何区分VARIABLE和CONSTANTS呢？我们可以理解为<code>rmState</code>是一个数组，这个数组的indexer是我们定义的RM集合，而这个集合是一个常量。    </li><li><code>[]TPNext</code><br> 表示<code>TPNext</code>始终成立。</li><li>EXTENDS<br> 类似于C++里面的<code>#include</code></li><li>INSTANCE<br> 下面的语句表示我们现在的Module实现了TCommit，于是我们将TCommit中的所有定义import到我们当前Module中。 <figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSTANCE <span class="keyword">TCommit</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="DieHard"><a href="#DieHard" class="headerlink" title="DieHard"></a>DieHard</h1><p>在TLA中，需要在等式<code>==</code>右边指定全部状态。</p><h1 id="TCommit"><a href="#TCommit" class="headerlink" title="TCommit"></a>TCommit</h1><p>对应Lamport的第5节课。<br>TCommit主要定义了事务的提交模型。如下图所示，每个Resource Manager(RM)节点，可以理解为2PC里面的参与者节点，具有working、prepared、committed、aborted四种状态。在这个提交模型中，我们不考虑协调者，也就是只考虑怎么样，不考虑如何做。后者会在下一章中考虑。</p><p><img src="/img/tla/v5commit.png" alt=""></p><p>下面定义TypeOK对么？肯定是不对的，因为<code>rmState</code>是RM的集合。我们并不是希望这个集合属于这四个值，而是希望每个<code>rmState[r]</code>属于这四个值之中<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">TCTypeOK</span> == rmState \in &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>所以我们需要<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCT<span class="function"><span class="title">ypeOK</span> == rmState \<span class="built_in">in</span> [RM -&gt;</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;]</span><br></pre></td></tr></table></figure></p><p>其实我觉得应该也可以这么写<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCTypeOK == \A r \<span class="keyword">in</span> <span class="string">RM:</span> rmState[r] \<span class="keyword">in</span> &#123;<span class="string">"working"</span>, <span class="string">"prepared"</span>, <span class="string">"committed"</span>, <span class="string">"aborted"</span>&#125;</span><br></pre></td></tr></table></figure></p><p>在Module中不检查Deadlock，但检查TCConsistent和TCTypeOK。</p><p>注意，源码里面有一些诸如TCSpec的，并不会在这篇文章里面讲解。</p><h1 id="TwoPhase"><a href="#TwoPhase" class="headerlink" title="TwoPhase"></a>TwoPhase</h1><p>首先介绍一下消息：</p><ol><li>Prepared<br> RM-&gt;TM，表示某个RM已经Prepared了。</li><li>Commit<br> TM-&gt;RM</li><li>Abort<br> TM-&gt;RM</li></ol><p>然后介绍下动作：</p><ol><li>TMRcvPrepared<br> TM收到了某个RM的Prepared消息。</li><li>TMCommit<br> TM决定commit事务。<br> 此时TM必须在initial态，并且所有的RM都已经发送了Prepared消息。</li><li>TMAbort<br> TM自发地abort事务。</li><li>RMPrepare<br> 某个RM决定prepare。</li><li>RMChooseToAbort<br> 某个RM决定abort。<br> 注意，此时RM不会发送任何消息。这个是正常的，例如我宕机了，那还怎么发送消息。</li><li>RMRcvCommitMsg<br> 某个RM收到了来自TM的Commit消息。</li><li>RMRcvAbortMsg<br> 某个RM收到了来自TM的Abort消息。</li></ol><p>下面介绍状态：</p><ol><li>rmState<br> 包含<code>{&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;}</code>。</li><li>tmState<br> 包含<code>{&quot;init&quot;, &quot;done&quot;}</code>。<br> done表示TM进行了Commit或者Abort操作。</li><li>tmPrepared<br> TM接受到了哪些RM的准备消息。</li><li>msgs<br> 是一个表示所有已经发送的消息的集合。</li></ol><p>这里面涉及到定义类型，有点类似于Haskell的ADT。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Messages == [<span class="symbol">type:</span> &#123;<span class="string">"Prepared"</span>&#125;, <span class="symbol">rm:</span> RM] \<span class="class"><span class="keyword">union</span> [<span class="title">type</span>: &#123;"<span class="title">Commit</span>", "<span class="title">Abort</span>"&#125;]</span></span><br></pre></td></tr></table></figure></p><p>这里<code>\subseteq</code>是子集的意思，这两句话实际就是在说<code>tmPrepared</code>和<code>msgs</code>中的值一定属于<code>RM</code>或者<code>Message</code>。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TPTypeOK == /<span class="string">\</span> tmPrepared <span class="string">\subseteq</span> RM</span><br><span class="line">            /<span class="string">\</span> msgs <span class="string">\subseteq</span> Messages</span><br></pre></td></tr></table></figure></p><h1 id="PaxosCommit-P07"><a href="#PaxosCommit-P07" class="headerlink" title="PaxosCommit (P07)"></a>PaxosCommit (P07)</h1><p>通过2PC，我们通过协调者TM去处理事务的提交。但如果TM宕掉怎么办呢？一个通常的实践是在主TM宕机后切换到备份的TM。这个操作的问题是，可能主TM决定Commit后分区/暂停了，但是备份TM决定Abort。但当它发送这个消息后，主TM恢复，并且发送Commit消息。这可能导致某些RM会Commit，另一些会Abort。</p><p>需要检查：</p><ol><li>PCTypeOK</li><li>TCConsistent</li></ol><p>Lamport强调，随着模型的线性增大，运行时间会以指数增大。</p><h1 id="P08a-P08b"><a href="#P08a-P08b" class="headerlink" title="P08a+P08b"></a>P08a+P08b</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><h2 id="Implication"><a href="#Implication" class="headerlink" title="Implication"></a>Implication</h2><p>介绍蕴含关系(implication)，也就是<code>=&gt;</code><br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">p</span> =&gt; Q</span><br></pre></td></tr></table></figure></p><p>等同<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">IF</span> P <span class="keyword">THEN</span> Q <span class="keyword">ELSE</span> <span class="literal">TRUE</span></span><br></pre></td></tr></table></figure></p><p>我们知道原命题的逆否命题成立，即<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="function"><span class="params">Q</span> =&gt;</span> ~P</span><br></pre></td></tr></table></figure></p><p>其中<code>~</code>也可以表示为<code>\lnot</code>或者<code>\neg</code></p><p>在口语中，implication通常断言因果。但是在数学中，只断言相关性。</p><h2 id="Module-closed-expression"><a href="#Module-closed-expression" class="headerlink" title="Module-closed expression"></a>Module-closed expression</h2><p>一个module-closed formula是一个不二良的module-closed expression。例如<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x \in <span class="number">1.</span><span class="number">.42</span>) /\ (y' = x + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h1 id="P09a"><a href="#P09a" class="headerlink" title="P09a"></a>P09a</h1><p>这一章节中的大部分内容被归纳到Expression/Spec章节。</p><p>介绍了ABSpec，即AlteringBits这个协议。</p><p>我们需要进行Liveness检查，分为以下步骤</p><ol><li>选择Temporal Formula为<code>FairSpec</code></li><li>设置”What is the model?”为”Set of model values”，但是关闭”Symmetry sets”选项。</li><li>在<strong>“What to check?”</strong>下面的<strong>“Properties”</strong>中填入下面的检查 <figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\A</span> v <span class="string">\in</span> Data <span class="string">\X</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;: <span class="function"><span class="params">(AVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span> ~&gt;</span> (BVar = &lt;&lt;<span class="string">"hi"</span>,<span class="number">0</span>&gt;&gt;)</span><br></pre></td></tr></table></figure></li></ol><h1 id="P09b"><a href="#P09b" class="headerlink" title="P09b"></a>P09b</h1><p>这一章节介绍AB，也就是AlteringBits这个协议的具体实现。</p><p>这个协议如下所示，A向B同步信息。开始，A和B都是<code>&lt;&lt;&quot;&quot;,0&gt;&gt;</code>。接着A开始发送<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>，会不断重传。当B收到<code>&lt;&lt;&quot;Mary&quot;,1&gt;&gt;</code>后，就更新自己的值，并且开始不断向A发送1，而不是0。<br><img src="/img/tla/ab2.png" alt=""></p><p>在实现完AB之后，需要进行Safety检查。但不能直接检查Spec。这是因为A和B可以不断地给彼此发送消息，并且发送的速度远远比丢包或者对端接收要快，这样的话会导致有无数的可到达状态，我们的TCL程序可能永远不会结束！<br>此时需要打开”Additional Spec Options”标签，在”State Constraint”中设置。这样我们就限制了消息的最大长度。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ <span class="built_in">Len</span>(AtoB) =&lt; <span class="number">3</span></span><br><span class="line">/\ <span class="built_in">Len</span>(BtoA) =&lt; <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>此外，我们还要在”What to check?”下面的”Properties”中填入<code>ABS!Spec</code>，表示我们要检查ABSpec里面的Spec。</p><p><img src="/img/tla/find_states.png" alt=""></p><p>下面进行Liveness检查，也就是添加Fairness条件，从而imply消息能够持续被发送以及接收。<br>此时Weak Fairness是不够的。因为这实际上允许了B一直向A发送1，如下如所示。【Q】为什么呢？稍后解释<br><img src="/img/tla/wf_fail.png" alt=""></p><p>因此我们得使用下面的<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  SF_vars<span class="comment">(ARcv)</span> /\ SF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure></p><p>【Q】能不能改成全是WF呢，如下所示<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FairSpec == Spec  /\  WF_vars<span class="comment">(ARcv)</span> /\ WF_vars<span class="comment">(BRcv)</span> /\</span><br><span class="line">                      WF_vars<span class="comment">(ASnd)</span> /\ WF_vars<span class="comment">(BSnd)</span></span><br></pre></td></tr></table></figure></p><p>尝试一下，可以发现下面的错误：<br><img src="/img/tla/all_wf.png" alt=""><br>它的路径如下，容易发现形成了循环。</p><ol><li>BSnd: 1</li><li>ASnd: <code>&lt;&lt;a, 1&gt;&gt;</code></li><li>LoseMsg: BtoA from <code>&lt;&lt;1&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code></li><li>BRcv: AtoB from <code>&lt;&lt;&lt;&lt;a, 1&gt;&gt;&gt;&gt;</code> to <code>&lt;&lt;&gt;&gt;</code><br> 回到了状态1</li></ol><p>Why？这是因为<code>WF_var(ASnd)</code>和<code>WF_var(BSnd)</code>是true，因为ASnd和BSnd一直在发生。<br>现在考虑<code>WF_vars(ARcv)</code>。在Init状态，它没有enable，因为BtoA是空的。在B发送消息之后，它enable了，但是如果发生了LostMsg，那么它又不enable了。容易看出，<code>WF_vars(ARcv)</code>也是true，因为<code>ARcv</code>并不能<strong>continuouesly enable</strong>。<br>所以，我们满足了<code>FairSpec</code>，但并不满足<code>ABS!FailSpec</code>，所以下面的THEOREM也不成立了<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM FairSpec =&gt; <span class="keyword">ABS</span>!FailSpec</span><br></pre></td></tr></table></figure></p><p>因此，我们要引入Strong Fairness。</p><h1 id="P10a"><a href="#P10a" class="headerlink" title="P10a"></a>P10a</h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>实现<code>RemoveX</code>，用来移除一个Tuple中的所有<code>&quot;X&quot;</code>。我们需要一个前置声明。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RECURSIVE RemoveX(_)</span><br><span class="line">RemoveX(l) == <span class="keyword">IF</span> l = &lt;&lt;&gt;&gt; <span class="keyword">THEN</span> l</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="keyword">IF</span> Head(l) = <span class="string">"X"</span> <span class="keyword">THEN</span> RemoveX(Tail(l))</span><br><span class="line">                     <span class="keyword">ELSE</span> &lt;&lt;Head(l)&gt;&gt; \o RemoveX(Tail(l))</span><br></pre></td></tr></table></figure></p><h2 id="代入-Substitution"><a href="#代入-Substitution" class="headerlink" title="代入(Substitution)"></a>代入(Substitution)</h2><p>考虑传统数学中的代入逻辑，即把<code>e</code>导入到<code>f(v)</code>中<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">v</span> = e) =&gt; (<span class="name">f</span> = (<span class="name">f</span> WITH v &lt;- e))</span><br></pre></td></tr></table></figure></p><p>其中WITH是Lamport定义的描述性的语句，其作用如下<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y^<span class="number">3</span>-y) WITH y &lt;- x+<span class="number">2</span> = (x+<span class="number">2</span>)^<span class="number">3</span>-(x+<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>因为TLA关注时序的逻辑，我们不能在写TLA+的时候这么进行代换，我们考虑下面的代入：<code>v &lt;- y</code>、<code>e &lt;- x + 2</code>、<code>f &lt;- y&#39;</code>，其实未必是一直成立的<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM (<span class="name">y</span> = x + <span class="number">2</span>) =&gt; (<span class="name">y</span>' = (<span class="name">x</span> + <span class="number">2</span>)')</span><br></pre></td></tr></table></figure></p><p>因此，我们使用Temporal Substitution Law<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="comment">(v = e)</span> =&gt; <span class="comment">(f = (f WITH v &lt;- e)</span>)</span><br></pre></td></tr></table></figure></p><p>即写成下面的形式<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM [] (y = x + <span class="number">2</span>) =&gt; (y<span class="string">' = (x + 2)'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="AB2"><a href="#AB2" class="headerlink" title="AB2"></a>AB2</h2><p>这个协议旨在处理出现消息损坏(Corrupted)的情况。<br>为此，我们引入了一个新消息Bad。并且Bad一定不等于所有的其他消息。我们用ASSUME来描述这个性质。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ASSUME Bad \notin (Data \X &#123;<span class="number">0</span>,<span class="number">1</span>&#125;) \cup &#123;<span class="number">0</span>,<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure></p><p>此外在运行Module的时候，需要给Bad赋一个不同于所有其他消息的值，一个Idea是用字符串”Bad”来代表。但这会遇到错误”Attempted to check equality of interger 0 with non-integer: “Bad””。所以，实际上我们可以直接用Model Value，即我们给Bad的值就是Bad。</p><p>我们需要保证消息需要在他们Corrupted之前被Receive，这个靠目前的Fairness条件是不够的，我们需要修改Safety条件。<br>首先，我们加入了AtoBgood和BtoAgood用来表示某条信息是不是肯定不会Corrupt。<br>然后，如果我们将AtoB2里面的Bad消息去掉，就可以得到一个等价的AtoB，因此我们得到了SpecH。去掉可以通过<code>RemoveBad</code>，类似于之前提到的<code>RemoveX</code>。<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SpecH == /<span class="tag">\<span class="name"> </span></span>AB2!Spec</span><br><span class="line">         /<span class="tag">\<span class="name"> </span><span class="string">[]</span></span> /<span class="tag">\<span class="name"> </span></span>AtoB = RemoveBad(AtoB2)</span><br><span class="line">               /<span class="tag">\<span class="name"> </span></span>BtoA = RemoveBad(BtoA2)</span><br></pre></td></tr></table></figure></p><p>我们的目标是，但此时我们的SpecH并不符合TLA+的Safety检查的格式，即<code>Init /\ [][Next]_vars</code>。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">THEOREM SpecH =&gt; AB!Spec</span><br></pre></td></tr></table></figure></p><p>为此，我们引入了SpecHH<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SpecHH == InitH /<span class="tag">\<span class="name"> </span><span class="string">[]</span><span class="string">[NextH]</span></span>_varsH</span><br><span class="line">THEOREM SpecHH &lt;=&gt; SpecH</span><br></pre></td></tr></table></figure></p><p>其中<code>&lt;=&gt;</code>的作用等价于<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\ SpecHH =&gt; SpecH</span><br><span class="line">/\ SpecH  =&gt; SpecHH</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://www.jianshu.com/p/12fda75ddf9e" target="_blank" rel="noopener">https://www.jianshu.com/p/12fda75ddf9e</a><br> 介绍TLA+的语法</li><li><a href="http://lamport.azurewebsites.net/video/videos.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/video/videos.html</a><br> Lamport的视频教学<br> 这里面有课件，以及视频教程里面的代码，这些在<a href="https://github.com/tlaplus/Examples" target="_blank" rel="noopener">https://github.com/tlaplus/Examples</a>并没有。</li><li><a href="https://github.com/parlarjb/tla_workshop" target="_blank" rel="noopener">https://github.com/parlarjb/tla_workshop</a><br> Lamport的代码的整理</li><li><a href="https://learntla.com/tla/" target="_blank" rel="noopener">https://learntla.com/tla/</a><br> 一个TLA+学习的网站</li><li><a href="https://lamport.azurewebsites.net/tla/book-02-08-08.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/book-02-08-08.pdf</a><br> Specifying Systems这本书，这是终极版本的讲义</li><li><a href="http://lamport.azurewebsites.net/tla/newmodule.html" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/newmodule.html</a><br> TLA中的module的相关说明，包含了很多语法相关的讲解</li><li><a href="http://lamport.azurewebsites.net/tla/book-21-07-04.pdf" target="_blank" rel="noopener">http://lamport.azurewebsites.net/tla/book-21-07-04.pdf</a><br> Specifying Systems这本书的新版本？</li><li><a href="https://lamport.azurewebsites.net/tla/tla2-guide.pdf" target="_blank" rel="noopener">https://lamport.azurewebsites.net/tla/tla2-guide.pdf</a><br> TLA2</li><li><a href="https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1X54y1U7LU?from=search&amp;seid=1851114600685541822</a><br> 教学视频，包含P10</li><li><a href="https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1yW411s7Hg?from=search&amp;seid=1851114600685541822</a><br> 教学视频，不包含P10，但是赠送了对Paxos的讲解</li><li><a href="https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf" target="_blank" rel="noopener">https://github.com/BinyuHuang-nju/raft-tla/blob/master/2021-JoS-PRaft.pdf</a></li><li><a href="https://github.com/tlaplus/DrTLAPlus" target="_blank" rel="noopener">https://github.com/tlaplus/DrTLAPlus</a></li><li><a href="https://www.youtube.com/watch?v=6Kwx8zfGW0Y" target="_blank" rel="noopener">https://www.youtube.com/watch?v=6Kwx8zfGW0Y</a><br> 从1.07开始有个简单的对Raft的TLA+的讲解</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍TLA+用法。&lt;br&gt;TLA全称为Temporal Logic of Actions，相比传统数学，更着重研究时序逻辑。&lt;br&gt;TLC是TLA+的模型检验工具。&lt;/p&gt;</summary>
    
    
    
    
    <category term="TLA" scheme="http://www.calvinneo.com/tags/TLA/"/>
    
  </entry>
  
  <entry>
    <title>概率论中的几个有趣问题</title>
    <link href="http://www.calvinneo.com/2021/05/15/probability-problems/"/>
    <id>http://www.calvinneo.com/2021/05/15/probability-problems/</id>
    <published>2021-05-15T11:20:33.000Z</published>
    <updated>2021-05-19T13:28:41.753Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍概率论中一些有趣的问题，其中很多是反直觉的</p><a id="more"></a><h1 id="三门问题"><a href="#三门问题" class="headerlink" title="三门问题"></a>三门问题</h1><h1 id="两个男孩"><a href="#两个男孩" class="headerlink" title="两个男孩"></a>两个男孩</h1><h1 id="基本比率谬误"><a href="#基本比率谬误" class="headerlink" title="基本比率谬误"></a>基本比率谬误</h1><p>假设同性恋染上某病的概率是异性恋的9倍。已知小明染上某病，求小明同性恋的概率。<br>错误的答案是$\frac{9}{10}$。正确答案是无法计算，因为我们并不知道同性恋和异性恋的比例。</p><p>令同性恋是$S$，异性恋是$H$，患某病是$X$。已知</p><p>$$<br>P(X|S) = 9 \quad P(X|H)<br>$$</p><p>求$P(S|X)$</p><p>我们计算</p><p>$$<br>P(S|X) = \frac{P(S)P(X|S)}{P(X)}<br>$$</p><p>我们考虑另一个问题，我们统计篮球比赛中两个球员的三分球和二分球命中率，假如A的三分球命中率比B高，二分球命中率也比B高，那么A的总命中率比B高么？<br>答案是不确定。我们不如考虑下面这个极端情况：</p><ol><li>A的二分球命中率是100\%，B的是99\%</li><li>A的三分球命中率是1\%，B的是0\%</li></ol><p>那B说好的，我田忌赛马了，我就直投二分球，你A只投三分球。结果B的总命中率是99\%，而A的是1\%。</p><h1 id="婚姻-秘书问题或者博士后问题"><a href="#婚姻-秘书问题或者博士后问题" class="headerlink" title="婚姻/秘书问题或者博士后问题"></a>婚姻/秘书问题或者博士后问题</h1><p>我们在海滩捡贝壳，必须在捡贝壳的时候决定留不留下，并且只有一次选择留下的机会，问如何最大化<strong>选到最佳贝壳</strong>的概率。</p><h1 id="贝特朗悖论"><a href="#贝特朗悖论" class="headerlink" title="贝特朗悖论"></a>贝特朗悖论</h1><h1 id="凯利公式"><a href="#凯利公式" class="headerlink" title="凯利公式"></a>凯利公式</h1><h1 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h1><ol><li><a href="https://blog.csdn.net/itnerd/article/details/107348933" target="_blank" rel="noopener">https://blog.csdn.net/itnerd/article/details/107348933</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%9F%BA%E6%9C%AC%E6%AF%94%E7%8E%87%E8%AC%AC%E8%AA%A4</a></li><li><a href="https://www.zhihu.com/question/330408241" target="_blank" rel="noopener">https://www.zhihu.com/question/330408241</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍概率论中一些有趣的问题，其中很多是反直觉的&lt;/p&gt;</summary>
    
    
    
    
    <category term="概率论" scheme="http://www.calvinneo.com/tags/概率论/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://www.calvinneo.com/2021/05/15/redis-replication/"/>
    <id>http://www.calvinneo.com/2021/05/15/redis-replication/</id>
    <published>2021-05-14T17:20:33.000Z</published>
    <updated>2021-05-13T14:41:38.549Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a>这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。</p><p>主从复制涉及到RDB等机制，其中持久化部分在<a href="/2021/03/13/redis-persist/">Redis持久化机制实现</a>中介绍。</p><a id="more"></a><h1 id="Redis主从复制流程简介"><a href="#Redis主从复制流程简介" class="headerlink" title="Redis主从复制流程简介"></a>Redis主从复制流程简介</h1><p>Redis Sentinel是对主从复制流程而言的，所以我们先要理解主从复制的大概流程。这里需要注意，主从复制并不是Redis Cluster。</p><ol><li>Slave接受到SLAVEOF命令</li><li>Slave连接Master</li><li>Slave PING Master</li><li>鉴权</li><li>Slave发送SYNC/PSYNC命令</li></ol><h2 id="PSYNC命令用法"><a href="#PSYNC命令用法" class="headerlink" title="PSYNC命令用法"></a>PSYNC命令用法</h2><p>PSYNC命令如下所示，其中：</p><ol><li>replicationid表示我们断线重连前Master服务器的id</li><li>offset表示Slave接受到最后命令的偏移量，以字节计算</li></ol><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 旧</span></span><br><span class="line">PSYNC runid <span class="keyword">offset</span></span><br><span class="line"><span class="comment">// 新</span></span><br><span class="line">PSYNC replicationid <span class="keyword">offset</span></span><br></pre></td></tr></table></figure><p>这里还有个特殊用法，表示我们要触发一次全量复制。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><p>在Redis 2.8后，提供了PSYNC，这个命令能够支持全量复制和部分复制。这样在Slave断线重连之后，就可以部分复制，从而节省Master的计算资源和带宽。<br>在Redis 4.0版本后，优化了增量复制，主要包括：</p><ol><li>重启后，也可以进行部分复制<br> 之前这种情况，重启后会丢失runid，从而触发<code>PSYNC ? -1</code></li><li>当Slave被promote称为Master后，其他Slave可以从新Master处复制</li></ol><h1 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h1><h2 id="主要类以及常数"><a href="#主要类以及常数" class="headerlink" title="主要类以及常数"></a>主要类以及常数</h2><p>在服务器类中定义了<code>masterhost</code>，表示Master节点的地址。如果是NULL，表示自己就是Master。所以这个字段<strong>会被用来判断是MAster还是Slave</strong>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *masteruser;               <span class="comment">/* AUTH with this user and masterauth with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterauth;               <span class="comment">/* AUTH with this password with master */</span></span><br><span class="line">    <span class="keyword">char</span> *masterhost;               <span class="comment">/* Hostname of master */</span></span><br><span class="line">    <span class="keyword">int</span> masterport;                 <span class="comment">/* Port of master */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>介绍下<code>repl_state</code>的状态：</p><ol><li><code>REPL_STATE_NONE 0</code><br> 表示现在是SLAVEOF NO ONE的</li><li><code>REPL_STATE_CONNECT 1</code><br> 在<code>replicationCron</code>判断，如果处于这个状态，表示现在要去尝试连接Master了。</li><li><code>REPL_STATE_CONNECTING 2</code></li></ol><p>下面的状态是握手过程中的状态：</p><ol><li><code>REPL_STATE_RECEIVE_PONG 3</code></li><li><code>REPL_STATE_SEND_AUTH 4</code></li><li><code>REPL_STATE_RECEIVE_AUTH 5</code></li><li><code>REPL_STATE_SEND_PORT 6</code></li><li><code>REPL_STATE_RECEIVE_PORT 7</code></li><li><code>REPL_STATE_SEND_IP 8</code></li><li><code>REPL_STATE_RECEIVE_IP 9</code></li><li><code>REPL_STATE_SEND_CAPA 10</code></li><li><code>REPL_STATE_RECEIVE_CAPA 11</code></li><li><code>REPL_STATE_SEND_PSYNC 12</code></li><li><code>REPL_STATE_RECEIVE_PSYNC 13</code></li></ol><p>下面状态是握手完毕的状态：</p><ol><li><code>REPL_STATE_TRANSFER 14</code></li><li><code>REPL_STATE_CONNECTED 15</code></li></ol><h2 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h2><ol><li>connectWithMaster</li></ol><h2 id="Full-Sync流程"><a href="#Full-Sync流程" class="headerlink" title="Full Sync流程"></a>Full Sync流程</h2><h2 id="Partial-Sync流程"><a href="#Partial-Sync流程" class="headerlink" title="Partial Sync流程"></a>Partial Sync流程</h2><h1 id="代码解释-Slave部分"><a href="#代码解释-Slave部分" class="headerlink" title="代码解释 Slave部分"></a>代码解释 Slave部分</h1><h2 id="connectWithMaster-建立套接口连接"><a href="#connectWithMaster-建立套接口连接" class="headerlink" title="connectWithMaster: 建立套接口连接"></a>connectWithMaster: 建立套接口连接</h2><p><code>connConnect</code>系列函数，以及<code>connection</code>类封装了有关网络连接的库。<br>实际上<code>connConnect</code>通过<code>anetTcpNonBlockBestEffortBindConnect</code>尝试建立一个非阻塞的套接字，此时<code>connect</code>函数可能返回<code>EINPROGRESS</code>表示连接还在建立过程中，但我们其实可以不用等。通过<code>aeCreateFileEvent</code>将这个Socket描述符加入到事件循环里面，等到这个套接字可以写之后，会触发对应的回调。<br>等到连接建立后，回调会通过<code>connSocketEventHandler</code>被唤起。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectWithMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();</span><br><span class="line">    <span class="keyword">if</span> (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,</span><br><span class="line">                NET_FIRST_BIND_ADDR, syncWithMaster) == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to connect to MASTER: %s"</span>,</span><br><span class="line">                connGetLastError(server.repl_transfer_s));</span><br><span class="line">        connClose(server.repl_transfer_s);</span><br><span class="line">        server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; REPLICA sync started"</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="syncWithMaster-握手以及准备传输RDB"><a href="#syncWithMaster-握手以及准备传输RDB" class="headerlink" title="syncWithMaster: 握手以及准备传输RDB"></a>syncWithMaster: 握手以及准备传输RDB</h2><p>在连接完毕后，<code>connectWithMaster</code>会回调<code>syncWithMaster</code>，此时状态是<code>REPL_STATE_CONNECTING</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncWithMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>], *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> dfd = <span class="number">-1</span>, maxtries = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> psync_result;</span><br></pre></td></tr></table></figure></p><p>检查一下，如果现在又是SLAVEOF NO ONE了，就把这个连接关掉。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If this event fired after the user turned the instance into a master</span></span><br><span class="line"><span class="comment"> * with SLAVEOF NO ONE we must just return ASAP. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">    connClose(conn);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为是非阻塞的连接，所以我们要检查一下现在连接的状态。如果失败，就goto error，里面内容是重置状态，例如，<code>server.repl_state</code>会被重置为<code>REPL_STATE_CONNECT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check for errors in the socket: after a non blocking connect() we</span></span><br><span class="line"><span class="comment"> * may find that the socket is in error state. */</span></span><br><span class="line"><span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Error condition on socket for SYNC: %s"</span>,</span><br><span class="line">            connGetLastError(conn));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是一个状态机的实现。我们在Sentinel中已经见过类似的了，Redis中状态机的实现就是，对于状态X，表示状态X前一个状态已经处理完了，目前正在处理状态X的工作。<strong>当状态机处理完一个状态后</strong>，在最后将状态设置为下一个要做的事情。也就是我们不用类似<code>X_FINISHED</code>这样的状态，因为<code>X_FINISHED</code>根据完成的情形不同，<strong>可能有多种状态转移</strong>。<br>【REPL_STATE_CONNECTING】这个状态下，我们尝试发送一个同步命令PING，然后直接修改状态到<code>REPL_STATE_RECEIVE_PONG</code>。如果这个同步命令发送有问题，就直接goto error了，不会走到下面流程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send a PING to check the master is able to reply without errors. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Non blocking connect for SYNC fired the event."</span>);</span><br><span class="line">    <span class="comment">/* Delete the writable event so that the readable event remains</span></span><br><span class="line"><span class="comment">     * registered and we can wait for the PONG reply. */</span></span><br><span class="line">    connSetReadHandler(conn, syncWithMaster);</span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</span><br><span class="line">    <span class="comment">/* Send the PING, don't check for errors at all, we have the timeout</span></span><br><span class="line"><span class="comment">     * that will take care about this. */</span></span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PING"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_RECEIVE_PONG】我们只要收到对PING的回复，就进入了<code>REPL_STATE_RECEIVE_PONG</code>状态，但这个回复未必是PONG，也可能是一个AUTH错误。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive the PONG command. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We accept only two replies as valid, a positive +PONG reply</span></span><br><span class="line"><span class="comment">     * (we just check for "+") or an authentication error.</span></span><br><span class="line"><span class="comment">     * Note that older versions of Redis replied with "operation not</span></span><br><span class="line"><span class="comment">     * permitted" instead of using a proper error code, so we test</span></span><br><span class="line"><span class="comment">     * both. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">'+'</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOAUTH"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-NOPERM"</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">"-ERR operation not permitted"</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Error reply to PING from master: '%s'"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master replied to PING, replication can continue..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_AUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_SEND_AUTH】如果需要AUTH认证，我们就发送AUTH，进入<code>REPL_STATE_RECEIVE_AUTH</code>。否则直接进入<code>REPL_STATE_SEND_PORT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* AUTH with the master if required. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masteruser &amp;&amp; server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,</span><br><span class="line">                                     server.masteruser,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"AUTH"</span>,server.masterauth,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_RECEIVE_AUTH】如果验证通过，就进入<code>REPL_STATE_SEND_PORT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive AUTH reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to AUTH to MASTER: %s"</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_SEND_PORT】下面一步，我们需要发送我们当前的端口，进入<code>REPL_STATE_RECEIVE_PORT</code>状态。<br>在发送完之后，我们在主节点执行<code>INFO replication</code>，会在其中显示我们反馈的port。<br>【Q】<code>slave_announce_port</code>和<code>port</code>的区别是什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set the slave port, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave listening port correctly. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">if</span> (server.slave_announce_port) port = server.slave_announce_port;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port) port = server.tls_port;</span><br><span class="line">    <span class="keyword">else</span> port = server.port;</span><br><span class="line">    sds portstr = sdsfromlonglong(port);</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"listening-port"</span>,portstr, <span class="literal">NULL</span>);</span><br><span class="line">    sdsfree(portstr);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_RECEIVE_PORT】接下来，我们用类似的办法发送IP，这里注意，如果没有指定<code>slave_announce_ip</code>就直接跳转到<code>REPL_STATE_SEND_CAPA</code>，否则跳转到<code>REPL_STATE_SEND_IP</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Receive REPLCONF listening-port reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF listening-port: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_IP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip REPLCONF ip-address if there is no slave-announce-ip option set. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp;</span><br><span class="line">    server.slave_announce_ip == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">        server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set the slave ip, so that Master's INFO command can list the</span></span><br><span class="line"><span class="comment"> * slave IP address port correctly in case of port forwarding or NAT. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"ip-address"</span>,server.slave_announce_ip, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive REPLCONF ip-address reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                            <span class="string">"REPLCONF ip-address: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_SEND_CAPA】发送IP的过程很类似，我们就不说了。下面这一对状态是<code>REPL_STATE_SEND_CAPA</code>，用来发送Slave的容量。这一对状态结束之后，进入<code>REPL_STATE_SEND_PSYNC</code>状态。<br>【Q】这个容量指的是什么？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Inform the master of our (slave) capabilities.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * EOF: supports EOF-style RDB transfer for diskless replication.</span></span><br><span class="line"><span class="comment"> * PSYNC2: supports PSYNC v2, so understands +CONTINUE &lt;new repl ID&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The master will ignore capabilities it does not understand. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"REPLCONF"</span>,</span><br><span class="line">            <span class="string">"capa"</span>,<span class="string">"eof"</span>,<span class="string">"capa"</span>,<span class="string">"psync2"</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive CAPA reply. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF capa. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"(Non critical) Master does not understand "</span></span><br><span class="line">                              <span class="string">"REPLCONF capa: %s"</span>, err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【REPL_STATE_SEND_PSYNC】下面，我们尝试PSYNC。主要就是调用若干次<code>slaveTryPartialResynchronization</code>：第一次传0进去，让它发PSYNC指令，并且设置状态为<code>REPL_STATE_RECEIVE_PSYNC</code>；后面就不断地传1进去，查询结果。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try a partial resynchonization. If we don't have a cached master</span></span><br><span class="line"><span class="comment"> * slaveTryPartialResynchronization() will at least try to use PSYNC</span></span><br><span class="line"><span class="comment"> * to start a full resynchronization so that we get the master run id</span></span><br><span class="line"><span class="comment"> * and the global offset, to try a partial resync at the next</span></span><br><span class="line"><span class="comment"> * reconnection attempt. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">    <span class="keyword">if</span> (slaveTryPartialResynchronization(conn,<span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">        err = sdsnew(<span class="string">"Write error sending the PSYNC command."</span>);</span><br><span class="line">        <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC. */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"syncWithMaster(): state machine error, "</span></span><br><span class="line">                         <span class="string">"state should be RECEIVE_PSYNC but is %d"</span>,</span><br><span class="line">                         server.repl_state);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">psync_result = slaveTryPartialResynchronization(conn,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>下面查看返回值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_WAIT_REPLY) <span class="keyword">return</span>; <span class="comment">/* Try again later... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the master is in an transient error, we should try to PSYNC</span></span><br><span class="line"><span class="comment"> * from scratch later, so go to the error path. This happens when</span></span><br><span class="line"><span class="comment"> * the server is loading the dataset or is not connected with its</span></span><br><span class="line"><span class="comment"> * master and so forth. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_TRY_LATER) <span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Note: if PSYNC does not return WAIT_REPLY, it will take care of</span></span><br><span class="line"><span class="comment"> * uninstalling the read handler from the file descriptor. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization."</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Partial Resynchronization accepted. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* PSYNC failed or is not supported: we want our slaves to resync with us</span></span><br><span class="line"><span class="comment"> * as well, if we have any sub-slaves. The master may transfer us an</span></span><br><span class="line"><span class="comment"> * entirely different data set and we have no way to incrementally feed</span></span><br><span class="line"><span class="comment"> * our slaves after that. */</span></span><br><span class="line">disconnectSlaves(); <span class="comment">/* Force our slaves to resync with us as well. */</span></span><br><span class="line">freeReplicationBacklog(); <span class="comment">/* Don't allow our chained slaves to PSYNC. */</span></span><br></pre></td></tr></table></figure></p><p>如果PSYNC能支持，我们前面就返回了，下面对于不支持的情况，我们就得用老的SYNC方法。在开始传输后，进入<code>REPL_STATE_TRANSFER</code>状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC</span></span><br><span class="line"><span class="comment"> * and the server.master_replid and master_initial_offset are</span></span><br><span class="line"><span class="comment"> * already populated. */</span></span><br><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_NOT_SUPPORTED) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Retrying with SYNC..."</span>);</span><br><span class="line">    <span class="keyword">if</span> (connSyncWrite(conn,<span class="string">"SYNC\r\n"</span>,<span class="number">6</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"I/O error writing to MASTER: %s"</span>,</span><br><span class="line">            strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果不支持无盘加载，那么就要在磁盘上创建一个临时文件。<br>查看函数<code>useDisklessLoad</code>，无盘加载需要满足：</p><ol><li><code>repl_diskless_load</code>配置</li><li>所有的模块都能处理读错误</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Prepare a suitable temp file for bulk transfer */</span></span><br><span class="line"><span class="keyword">if</span> (!useDisklessLoad()) &#123;</span><br><span class="line">    <span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,</span><br><span class="line">            <span class="string">"temp-%d.%ld.rdb"</span>,(<span class="keyword">int</span>)server.unixtime,(<span class="keyword">long</span> <span class="keyword">int</span>)getpid());</span><br><span class="line">        dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">        <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Opening the temp file needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,strerror(errno));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_transfer_tmpfile = zstrdup(tmpfile);</span><br><span class="line">    server.repl_transfer_fd = dfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面非阻塞地进行SYNC，设置读取SYNC数据的回调<code>readSyncBulkPayload</code>，如果成功就切换状态为<code>REPL_STATE_TRANSFER</code>。<br>这里，我们设置了<code>repl_transfer_size</code>为1，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Setup the non blocking download of the bulk file. */</span></span><br><span class="line"><span class="keyword">if</span> (connSetReadHandler(conn, readSyncBulkPayload)</span><br><span class="line">        == C_ERR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> conninfo[CONN_INFO_LEN];</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Can't create readable event for SYNC: %s (%s)"</span>,</span><br><span class="line">        strerror(errno), connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.repl_state = REPL_STATE_TRANSFER;</span><br><span class="line">server.repl_transfer_size = <span class="number">-1</span>;</span><br><span class="line">server.repl_transfer_read = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_last_fsync_off = <span class="number">0</span>;</span><br><span class="line">server.repl_transfer_lastio = server.unixtime;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></p><p>下面是错误处理，需要将状态重置为等待连接的<code>REPL_STATE_CONNECT</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (dfd != <span class="number">-1</span>) close(dfd);</span><br><span class="line">    connClose(conn);</span><br><span class="line">    server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_fd != <span class="number">-1</span>)</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_tmpfile)</span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">    server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">write_error: <span class="comment">/* Handle sendSynchronousCommand(SYNC_CMD_WRITE) errors. */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Sending command to master in replication handshake: %s"</span>, err);</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="slaveTryPartialResynchronization-PSYNC分支"><a href="#slaveTryPartialResynchronization-PSYNC分支" class="headerlink" title="slaveTryPartialResynchronization: PSYNC分支"></a>slaveTryPartialResynchronization: PSYNC分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Try a partial resynchronization with the master if we are about to reconnect.</span></span><br><span class="line"><span class="comment"> * If there is no cached master structure, at least try to issue a</span></span><br><span class="line"><span class="comment"> * "PSYNC ? -1" command in order to trigger a full resync using the PSYNC</span></span><br><span class="line"><span class="comment"> * command in order to obtain the master run id and the master replication</span></span><br><span class="line"><span class="comment"> * global offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is designed to be called from syncWithMaster(), so the</span></span><br><span class="line"><span class="comment"> * following assumptions are made:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) We pass the function an already connected socket "fd".</span></span><br><span class="line"><span class="comment"> * 2) This function does not close the file descriptor "fd". However in case</span></span><br><span class="line"><span class="comment"> *    of successful partial resynchronization, the function will reuse</span></span><br><span class="line"><span class="comment"> *    'fd' as file descriptor of the server.master client structure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function is split in two halves: if read_reply is 0, the function</span></span><br><span class="line"><span class="comment"> * writes the PSYNC command on the socket, and a new function call is</span></span><br><span class="line"><span class="comment"> * needed, with read_reply set to 1, in order to read the reply of the</span></span><br><span class="line"><span class="comment"> * command. This is useful in order to support non blocking operations, so</span></span><br><span class="line"><span class="comment"> * that we write, return into the event loop, and read when there are data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When read_reply is 0 the function returns PSYNC_WRITE_ERR if there</span></span><br><span class="line"><span class="comment"> * was a write error, or PSYNC_WAIT_REPLY to signal we need another call</span></span><br><span class="line"><span class="comment"> * with read_reply set to 1. However even when read_reply is set to 1</span></span><br><span class="line"><span class="comment"> * the function may return PSYNC_WAIT_REPLY again to signal there were</span></span><br><span class="line"><span class="comment"> * insufficient data to read to complete its work. We should re-enter</span></span><br><span class="line"><span class="comment"> * into the event loop and wait in such a case.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PSYNC_CONTINUE: If the PSYNC command succeeded and we can continue.</span></span><br><span class="line"><span class="comment"> * PSYNC_FULLRESYNC: If PSYNC is supported but a full resync is needed.</span></span><br><span class="line"><span class="comment"> *                   In this case the master run_id and global replication</span></span><br><span class="line"><span class="comment"> *                   offset is saved.</span></span><br><span class="line"><span class="comment"> * PSYNC_NOT_SUPPORTED: If the server does not understand PSYNC at all and</span></span><br><span class="line"><span class="comment"> *                      the caller should fall back to SYNC.</span></span><br><span class="line"><span class="comment"> * PSYNC_WRITE_ERROR: There was an error writing the command to the socket.</span></span><br><span class="line"><span class="comment"> * PSYNC_WAIT_REPLY: Call again the function with read_reply set to 1.</span></span><br><span class="line"><span class="comment"> * PSYNC_TRY_LATER: Master is currently in a transient error condition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Notable side effects:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1) As a side effect of the function call the function removes the readable</span></span><br><span class="line"><span class="comment"> *    event handler from "fd", unless the return value is PSYNC_WAIT_REPLY.</span></span><br><span class="line"><span class="comment"> * 2) server.master_initial_offset is set to the right value according</span></span><br><span class="line"><span class="comment"> *    to the master reply. This will be used to populate the 'server.master'</span></span><br><span class="line"><span class="comment"> *    structure replication offset.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ol><li><code>PSYNC_WRITE_ERROR 0</code><br> 套接口不可写。</li><li><code>PSYNC_WAIT_REPLY 1</code><br> 需要<code>read_erply</code>设置为1，并调用函数。</li><li><code>PSYNC_CONTINUE 2</code></li><li><code>PSYNC_FULLRESYNC 3</code><br> 表示虽然支持PSYNC，但现在仍然需要一次Full SYNC。在这情况下，我们需要保存Master的runid和offset。</li><li><code>PSYNC_NOT_SUPPORTED 4</code><br> 不支持PSYNC。</li><li><code>PSYNC_TRY_LATER 5</code><br> 暂时连不上Master，要重试。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psync_replid;</span><br><span class="line">    <span class="keyword">char</span> psync_offset[<span class="number">32</span>];</span><br><span class="line">    sds reply;</span><br></pre></td></tr></table></figure><p>首先，是写部分。这里的写，指的是往连接里面发送<code>PSYNC</code>指令:</p><ol><li>如果我们缓存了<code>server.master</code>到<code>server.cached_master</code><br> 通常是在<code>replicationCacheMaster</code>中设置的</li><li>如果是第一次连<br> 发送 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSYNC ? <span class="number">-1</span></span><br></pre></td></tr></table></figure></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Writing half */</span></span><br><span class="line"><span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">    <span class="comment">/* Initially set master_initial_offset to -1 to mark the current</span></span><br><span class="line"><span class="comment">     * master run_id and offset as not valid. Later if we'll be able to do</span></span><br><span class="line"><span class="comment">     * a FULL resync using the PSYNC command we'll set the offset at the</span></span><br><span class="line"><span class="comment">     * right value, so that this information will be propagated to the</span></span><br><span class="line"><span class="comment">     * client structure representing the master into server.master. */</span></span><br><span class="line">    server.master_initial_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.cached_master) &#123;</span><br><span class="line">        psync_replid = server.cached_master-&gt;replid;</span><br><span class="line">        <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">"%lld"</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Trying a partial resynchronization (request %s:%s)."</span>, psync_replid, psync_offset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Partial resynchronization not possible (no cached master)"</span>);</span><br><span class="line">        psync_replid = <span class="string">"?"</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(psync_offset,<span class="string">"-1"</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Issue the PSYNC command */</span></span><br><span class="line">    reply = sendSynchronousCommand(SYNC_CMD_WRITE,conn,<span class="string">"PSYNC"</span>,psync_replid,psync_offset,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unable to send PSYNC to master: %s"</span>,reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们读出Master的回复，如果是空，我们就返回继续等待<code>PSYNC_WAIT_REPLY</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Reading half */</span></span><br><span class="line">reply = sendSynchronousCommand(SYNC_CMD_READ,conn,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">/* The master may send empty newlines after it receives PSYNC</span></span><br><span class="line"><span class="comment">     * and before to reply, just to keep the connection alive. */</span></span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>如果回复是<code>+FULLRESYNC</code>，表示需要一次Full SYNC。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+FULLRESYNC"</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">    <span class="keyword">char</span> *replid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* FULL RESYNC, parse the reply in order to extract the run id</span></span><br><span class="line"><span class="comment">     * and the replication offset. */</span></span><br><span class="line">    replid = <span class="built_in">strchr</span>(reply,<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span> (replid) &#123;</span><br><span class="line">        replid++;</span><br><span class="line">        offset = <span class="built_in">strchr</span>(replid,<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!replid || !offset || (offset-replid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Master replied with wrong +FULLRESYNC syntax."</span>);</span><br><span class="line">        <span class="comment">/* This is an unexpected condition, actually the +FULLRESYNC</span></span><br><span class="line"><span class="comment">         * reply means that the master supports PSYNC, but the reply</span></span><br><span class="line"><span class="comment">         * format seems wrong. To stay safe we blank the master</span></span><br><span class="line"><span class="comment">         * replid to make sure next PSYNCs will fail. */</span></span><br><span class="line">        <span class="built_in">memset</span>(server.master_replid,<span class="number">0</span>,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(server.master_replid, replid, offset-replid<span class="number">-1</span>);</span><br><span class="line">        server.master_replid[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line">        server.master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Full resync from master: %s:%lld"</span>,</span><br><span class="line">            server.master_replid,</span><br><span class="line">            server.master_initial_offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    <span class="keyword">return</span> PSYNC_FULLRESYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>否则，我们可以部分同步。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"+CONTINUE"</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">    <span class="comment">/* Partial resync was accepted. */</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">        <span class="string">"Successful partial resynchronization with master."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the new replication ID advertised by the master. If it</span></span><br><span class="line"><span class="comment">     * changed, we need to set the new ID as primary ID, and set or</span></span><br><span class="line"><span class="comment">     * secondary ID as the old master ID up to the current offset, so</span></span><br><span class="line"><span class="comment">     * that our sub-slaves will be able to PSYNC with us after a</span></span><br><span class="line"><span class="comment">     * disconnection. */</span></span><br><span class="line">    <span class="keyword">char</span> *start = reply+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">char</span> *end = reply+<span class="number">9</span>;</span><br><span class="line">    <span class="keyword">while</span>(end[<span class="number">0</span>] != <span class="string">'\r'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\n'</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">'\0'</span>) end++;</span><br></pre></td></tr></table></figure></p><p>这里new表示Master端传来的runid。如果和我们当前的<code>server.replid</code>不一样，我们要重新设置一下，并且将老的<code>server.replid</code>复制给<code>server.replid2</code>。<br>【Q】这里涉及到三个replid，他们的区别是什么呢？</p><ol><li><code>server.replid</code></li><li><code>server.replid2</code></li><li><code>server.cached_master-&gt;replid</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (end-start == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(<span class="keyword">new</span>,start,CONFIG_RUN_ID_SIZE);</span><br><span class="line">    <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">new</span>,server.cached_master-&gt;replid)) &#123;</span><br><span class="line">        <span class="comment">/* Master ID changed. */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Master replication ID changed to %s"</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the old ID as our ID2, up to the current offset+1. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid2,server.cached_master-&gt;replid,</span><br><span class="line">            <span class="keyword">sizeof</span>(server.replid2));</span><br><span class="line">        server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the cached master ID and our own primary ID to the</span></span><br><span class="line"><span class="comment">         * new one. */</span></span><br><span class="line">        <span class="built_in">memcpy</span>(server.replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">        <span class="built_in">memcpy</span>(server.cached_master-&gt;replid,<span class="keyword">new</span>,<span class="keyword">sizeof</span>(server.replid));</span><br></pre></td></tr></table></figure><p>如果当前Slave有Sub Slave，全部断开，让他们重新走PSYNC流程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">                <span class="comment">/* Disconnect all the sub-slaves: they need to be notified. */</span></span><br><span class="line">                disconnectSlaves();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup the replication to continue. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        replicationResurrectCachedMaster(conn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this instance was restarted and we read the metadata to</span></span><br><span class="line"><span class="comment">         * PSYNC from the persistence file, our replication backlog could</span></span><br><span class="line"><span class="comment">         * be still not initialized. Create it. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">        <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we reach this point we received either an error (since the master does</span></span><br><span class="line"><span class="comment">     * not understand PSYNC or because it is in a special state and cannot</span></span><br><span class="line"><span class="comment">     * serve our request), or an unexpected reply from the master.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise</span></span><br><span class="line"><span class="comment">     * return PSYNC_TRY_LATER if we believe this is a transient error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">"-NOMASTERLINK"</span>,<span class="number">13</span>) ||</span><br><span class="line">        !<span class="built_in">strncmp</span>(reply,<span class="string">"-LOADING"</span>,<span class="number">8</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master is currently unable to PSYNC "</span></span><br><span class="line">            <span class="string">"but should be in the future: %s"</span>, reply);</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_TRY_LATER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(reply,<span class="string">"-ERR"</span>,<span class="number">4</span>)) &#123;</span><br><span class="line">        <span class="comment">/* If it's not an error, log the unexpected event. */</span></span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Unexpected reply to PSYNC from master: %s"</span>, reply);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Master does not support PSYNC or is in "</span></span><br><span class="line">            <span class="string">"error state (reply: %s)"</span>, reply);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(reply);</span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    <span class="keyword">return</span> PSYNC_NOT_SUPPORTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="readSyncBulkPayload-SYNC分支-接受RDB"><a href="#readSyncBulkPayload-SYNC分支-接受RDB" class="headerlink" title="readSyncBulkPayload: SYNC分支 接受RDB"></a>readSyncBulkPayload: SYNC分支 接受RDB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Asynchronously read the SYNC payload we receive from a master */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_MAX_WRITTEN_BEFORE_FSYNC (1024*1024*8) <span class="comment">/* 8 MB */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readSyncBulkPayload</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread, readlen, nwritten;</span><br><span class="line">    <span class="keyword">int</span> use_diskless_load = useDisklessLoad();</span><br><span class="line">    redisDb *diskless_load_backup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC :</span><br><span class="line">                                                        EMPTYDB_NO_FLAGS;</span><br><span class="line">    <span class="keyword">off_t</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Static vars used to hold the EOF mark, and the last bytes received</span></span><br><span class="line"><span class="comment">     * form the server: when they match, we reached the end of the transfer. */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> eofmark[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> lastbytes[CONFIG_RUN_ID_SIZE];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> usemark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If repl_transfer_size == -1 we still have to read the bulk length</span></span><br><span class="line"><span class="comment">     * from the master reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSyncReadLine(conn,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"I/O error reading bulk count from MASTER: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"MASTER aborted replication with an error: %s"</span>,</span><br><span class="line">                buf+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">'\0'</span>) &#123;</span><br><span class="line">            <span class="comment">/* At this stage just a newline works as a PING in order to take</span></span><br><span class="line"><span class="comment">             * the connection live. So we refresh our last interaction</span></span><br><span class="line"><span class="comment">             * timestamp. */</span></span><br><span class="line">            server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Bad protocol from MASTER, the first byte is not '$' (we received '%s'), are you sure the host and port are right?"</span>, buf);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* There are two possible forms for the bulk payload. One is the</span></span><br><span class="line"><span class="comment">         * usual $&lt;count&gt; bulk format. The other is used for diskless transfers</span></span><br><span class="line"><span class="comment">         * when the master does not know beforehand the size of the file to</span></span><br><span class="line"><span class="comment">         * transfer. In the latter case, the following format is used:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * At the end of the file the announced delimiter is transmitted. The</span></span><br><span class="line"><span class="comment">         * delimiter is long and random enough that the probability of a</span></span><br><span class="line"><span class="comment">         * collision with the actual file content can be ignored. */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">"EOF:"</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            usemark = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="comment">/* Set any repl_transfer_size to avoid entering this code path</span></span><br><span class="line"><span class="comment">             * at the next call. */</span></span><br><span class="line">            server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF %s"</span>,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usemark = <span class="number">0</span>;</span><br><span class="line">            server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master %s"</span>,</span><br><span class="line">                (<span class="keyword">long</span> <span class="keyword">long</span>) server.repl_transfer_size,</span><br><span class="line">                use_diskless_load? <span class="string">"to parser"</span>:<span class="string">"to disk"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!use_diskless_load) &#123;</span><br><span class="line">        <span class="comment">/* Read the data from the socket, store it to a file and search</span></span><br><span class="line"><span class="comment">         * for the EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">            readlen = (left &lt; (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nread = connRead(conn,buf,readlen);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">                <span class="comment">/* equivalent to EAGAIN */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"I/O error trying to sync with MASTER: %s"</span>,</span><br><span class="line">                (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"connection lost"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        server.stat_net_input_bytes += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When a mark is used, we want to detect EOF asap in order to avoid</span></span><br><span class="line"><span class="comment">         * writing the EOF mark into the file... */</span></span><br><span class="line">        <span class="keyword">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="comment">/* Update the last bytes array, and check if it matches our</span></span><br><span class="line"><span class="comment">             * delimiter. */</span></span><br><span class="line">            <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes,buf+nread-CONFIG_RUN_ID_SIZE,</span><br><span class="line">                       CONFIG_RUN_ID_SIZE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">                memmove(lastbytes,lastbytes+nread,rem);</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the last I/O time for the replication transfer (used in</span></span><br><span class="line"><span class="comment">         * order to detect timeouts during replication), and write what we</span></span><br><span class="line"><span class="comment">         * got from the socket to the dump file on disk. */</span></span><br><span class="line">        server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(server.repl_transfer_fd,buf,nread)) != nread) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Write error or short write writing to the DB dump file "</span></span><br><span class="line">                <span class="string">"needed for MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                (nwritten == <span class="number">-1</span>) ? strerror(errno) : <span class="string">"short write"</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line">        server.repl_transfer_read += nread;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Delete the last 40 bytes from the file if we reached EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"Error truncating the RDB file received from the master "</span></span><br><span class="line">                    <span class="string">"for SYNC: %s"</span>, strerror(errno));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Sync data on disk from time to time, otherwise at the end of the</span></span><br><span class="line"><span class="comment">         * transfer we may suffer a big delay as the memory buffers are copied</span></span><br><span class="line"><span class="comment">         * into the actual disk. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_transfer_read &gt;=</span><br><span class="line">            server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">off_t</span> sync_size = server.repl_transfer_read -</span><br><span class="line">                              server.repl_transfer_last_fsync_off;</span><br><span class="line">            rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">                server.repl_transfer_last_fsync_off, sync_size);</span><br><span class="line">            server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the transfer is now complete */</span></span><br><span class="line">        <span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the transfer is yet not complete, we need to read more, so</span></span><br><span class="line"><span class="comment">         * return ASAP and wait for the handler to be called again. */</span></span><br><span class="line">        <span class="keyword">if</span> (!eof_reached) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We reach this point in one of the following cases:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. The replica is using diskless replication, that is, it reads data</span></span><br><span class="line"><span class="comment">     *    directly from the socket to the Redis memory, without using</span></span><br><span class="line"><span class="comment">     *    a temporary RDB file on disk. In that case we just block and</span></span><br><span class="line"><span class="comment">     *    read everything from the socket.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. Or when we are done reading from the socket to the RDB file, in</span></span><br><span class="line"><span class="comment">     *    such case we want just to read the RDB file in memory. */</span></span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Flushing old data"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to stop any AOF rewriting child before flusing and parsing</span></span><br><span class="line"><span class="comment">     * the RDB, otherwise we'll create a copy-on-write disaster. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF) stopAppendOnly();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When diskless RDB loading is used by replicas, it may be configured</span></span><br><span class="line"><span class="comment">     * in order to save the current DB instead of throwing it away,</span></span><br><span class="line"><span class="comment">     * so that we can restore it in case of failed transfer. */</span></span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load &amp;&amp;</span><br><span class="line">        server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Create a backup of server.db[] and initialize to empty</span></span><br><span class="line"><span class="comment">         * dictionaries */</span></span><br><span class="line">        diskless_load_backup = disklessLoadMakeBackups();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We call to emptyDb even in case of REPL_DISKLESS_LOAD_SWAPDB</span></span><br><span class="line"><span class="comment">     * (Where disklessLoadMakeBackups left server.db empty) because we</span></span><br><span class="line"><span class="comment">     * want to execute all the auxiliary logic of emptyDb (Namely,</span></span><br><span class="line"><span class="comment">     * fire module events) */</span></span><br><span class="line">    emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before loading the DB into memory we need to delete the readable</span></span><br><span class="line"><span class="comment">     * handler, otherwise it will get called recursively since</span></span><br><span class="line"><span class="comment">     * rdbLoad() will call the event loop to process events from time to</span></span><br><span class="line"><span class="comment">     * time for non blocking loading. */</span></span><br><span class="line">    connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Loading DB in memory"</span>);</span><br><span class="line">    rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">    <span class="keyword">if</span> (use_diskless_load) &#123;</span><br><span class="line">        rio rdb;</span><br><span class="line">        rioInitWithConn(&amp;rdb,conn,server.repl_transfer_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Put the socket in blocking mode to simplify RDB transfer.</span></span><br><span class="line"><span class="comment">         * We'll restore it when the RDB is received. */</span></span><br><span class="line">        connBlock(conn);</span><br><span class="line">        connRecvTimeout(conn, server.repl_timeout*<span class="number">1000</span>);</span><br><span class="line">        startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,RDBFLAGS_REPLICATION,&amp;rsi) != C_OK) &#123;</span><br><span class="line">            <span class="comment">/* RDB loading failed. */</span></span><br><span class="line">            stopLoading(<span class="number">0</span>);</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization DB "</span></span><br><span class="line">                <span class="string">"from socket"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">                <span class="comment">/* Restore the backed up databases. */</span></span><br><span class="line">                disklessLoadRestoreBackups(diskless_load_backup,<span class="number">1</span>,</span><br><span class="line">                                           empty_db_flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Remove the half-loaded data in case we started with</span></span><br><span class="line"><span class="comment">                 * an empty replica. */</span></span><br><span class="line">                emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on SYNC</span></span><br><span class="line"><span class="comment">             * failure, it'll be restarted when sync succeeds or the replica</span></span><br><span class="line"><span class="comment">             * gets promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        stopLoading(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* RDB loading succeeded if we reach this point. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">            <span class="comment">/* Delete the backup databases we created before starting to load</span></span><br><span class="line"><span class="comment">             * the new RDB. Now the RDB was loaded with success so the old</span></span><br><span class="line"><span class="comment">             * data is useless. */</span></span><br><span class="line">            disklessLoadRestoreBackups(diskless_load_backup,<span class="number">0</span>,empty_db_flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Verify the end mark is correct. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!rioRead(&amp;rdb,buf,CONFIG_RUN_ID_SIZE) ||</span><br><span class="line">                <span class="built_in">memcmp</span>(buf,eofmark,CONFIG_RUN_ID_SIZE) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Replication stream EOF marker is broken"</span>);</span><br><span class="line">                cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">                rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup and restore the socket to the original state to continue</span></span><br><span class="line"><span class="comment">         * with the normal replication. */</span></span><br><span class="line">        rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">        connNonBlock(conn);</span><br><span class="line">        connRecvTimeout(conn,<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Ensure background save doesn't overwrite synced data */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replica is about to load the RDB file received from the "</span></span><br><span class="line">                <span class="string">"master, but there is a pending RDB child running. "</span></span><br><span class="line">                <span class="string">"Killing process %ld and removing its temp file to avoid "</span></span><br><span class="line">                <span class="string">"any race"</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) server.rdb_child_pid);</span><br><span class="line">            killRDBChild();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Rename rdb like renaming rewrite aof asynchronously. */</span></span><br><span class="line">        <span class="keyword">int</span> old_rdb_fd = open(server.rdb_filename,O_RDONLY|O_NONBLOCK);</span><br><span class="line">        <span class="keyword">if</span> (rename(server.repl_transfer_tmpfile,server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to rename the temp DB into %s in "</span></span><br><span class="line">                <span class="string">"MASTER &lt;-&gt; REPLICA synchronization: %s"</span>,</span><br><span class="line">                server.rdb_filename, strerror(errno));</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) close(old_rdb_fd);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Close old rdb asynchronously. */</span></span><br><span class="line">        <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)old_rdb_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbLoad(server.rdb_filename,&amp;rsi,RDBFLAGS_REPLICATION) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Failed trying to load the MASTER synchronization "</span></span><br><span class="line">                <span class="string">"DB from disk"</span>);</span><br><span class="line">            cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                    <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                    <span class="string">"disabled"</span>);</span><br><span class="line">                bg_unlink(server.rdb_filename);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Note that there's no point in restarting the AOF on sync failure,</span></span><br><span class="line"><span class="comment">               it'll be restarted when sync succeeds or replica promoted. */</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Cleanup. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Removing the RDB file obtained from "</span></span><br><span class="line">                                <span class="string">"the master. This replica has persistence "</span></span><br><span class="line">                                <span class="string">"disabled"</span>);</span><br><span class="line">            bg_unlink(server.rdb_filename);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zfree(server.repl_transfer_tmpfile);</span><br><span class="line">        close(server.repl_transfer_fd);</span><br><span class="line">        server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">        server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Final setup of the connected slave &lt;- master link */</span></span><br><span class="line">    replicationCreateMasterClient(server.repl_transfer_s,rsi.repl_stream_db);</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line">    server.repl_down_since = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the master link modules event. */</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* After a full resynchroniziation we use the replication ID and</span></span><br><span class="line"><span class="comment">     * offset of the master. The secondary ID / offset are cleared since</span></span><br><span class="line"><span class="comment">     * we are starting a new history. */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(server.replid,server.master-&gt;replid,<span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">    server.master_repl_offset = server.master-&gt;reploff;</span><br><span class="line">    clearReplicationId2();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Let's create the replication backlog if needed. Slaves need to</span></span><br><span class="line"><span class="comment">     * accumulate the backlog regardless of the fact they have sub-slaves</span></span><br><span class="line"><span class="comment">     * or not, in order to behave correctly if they are promoted to</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">"MASTER &lt;-&gt; REPLICA sync: Finished with success"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.supervised_mode == SUPERVISED_SYSTEMD) &#123;</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"STATUS=MASTER &lt;-&gt; REPLICA sync: Finished with success. Ready to accept connections.\n"</span>);</span><br><span class="line">        redisCommunicateSystemd(<span class="string">"READY=1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send the initial ACK immediately to put this replica in online state. */</span></span><br><span class="line">    <span class="keyword">if</span> (usemark) replicationSendAck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restart the AOF subsystem now that we finished the sync. This</span></span><br><span class="line"><span class="comment">     * will trigger an AOF rewrite, and when done will start appending</span></span><br><span class="line"><span class="comment">     * to the new file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_enabled) restartAOFAfterSYNC();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="主事件循环"><a href="#主事件循环" class="headerlink" title="主事件循环"></a>主事件循环</h1><h2 id="replicationCron"><a href="#replicationCron" class="headerlink" title="replicationCron"></a>replicationCron</h2><p>主要代码位于replication.c中。<br>主函数<code>replicationCron</code>被<code>serverCron</code>触发，每隔一秒钟触发一次。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run_with_period(<span class="number">1000</span>) replicationCron();</span><br></pre></td></tr></table></figure></p><p>下面查看主函数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replication.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>首先，下面是几个超时判断：</p><ol><li>建立连接过程中超时</li><li>传输过程中超时</li><li>心跳/数据超时</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">    (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">     slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">     (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">    cancelReplicationHandshake(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">    freeClient(server.master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否需要连接Master。<br><code>connectWithMaster</code>这个函数会将状态设置为<code>REPL_STATE_CONNECTING</code>，并设置回调<code>syncWithMaster</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">        server.masterhost, server.masterport);</span><br><span class="line">    connectWithMaster();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果Master支持PSYNC，就定期发送ACK。<br>这个ACK的作用是发送一个<code>REPLCONF ACK</code>命令给Master，从而通知自己当前的复制偏移。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment"> * Note that we do not send periodic acks to masters that don't</span></span><br><span class="line"><span class="comment"> * support PSYNC and replication offsets. */</span></span><br><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">    !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">    replicationSendAck();</span><br></pre></td></tr></table></figure></p><p>下面，我们对所有Slave发送PING。根据注释，如果我们连接了Slave（是不是说明当前节点是Master？），就按时PING它们。这样Slave们能够维护到Master的显式的超时时间，从而在TCP连接并没有真正丢失的时候，检查一个断线的情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we have attached slaves, PING them from time to time.</span></span><br><span class="line"><span class="comment"> * So slaves can implement an explicit timeout to masters, and will</span></span><br><span class="line"><span class="comment"> * be able to detect a link disconnection even if the TCP connection</span></span><br><span class="line"><span class="comment"> * will not actually go down. */</span></span><br><span class="line">listIter li;</span><br><span class="line">listNode *ln;</span><br><span class="line">robj *ping_argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* First, send PING according to ping_slave_period. */</span></span><br><span class="line"><span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">    listLength(server.slaves))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Note that we don't send the PING if the clients are paused during</span></span><br><span class="line"><span class="comment">     * a Redis Cluster manual failover: the PING we send will otherwise</span></span><br><span class="line"><span class="comment">     * alter the replication offsets of master and slave, and will no longer</span></span><br><span class="line"><span class="comment">     * match the one stored into 'mf_master_offset' state. */</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover_in_progress =</span><br><span class="line">        server.cluster_enabled &amp;&amp;</span><br><span class="line">        server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">        clientsArePaused();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manual_failover_in_progress) &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">            ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Second, send a newline to all the slaves in pre-synchronization</span></span><br><span class="line"><span class="comment"> * stage, that is, slaves waiting for the master to create the RDB file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also send the a newline to all the chained slaves we have, if we lost</span></span><br><span class="line"><span class="comment"> * connection from our master, to keep the slaves aware that their</span></span><br><span class="line"><span class="comment"> * master is online. This is needed since sub-slaves only receive proxied</span></span><br><span class="line"><span class="comment"> * data from top-level masters, so there is no explicit pinging in order</span></span><br><span class="line"><span class="comment"> * to avoid altering the replication offsets. This special out of band</span></span><br><span class="line"><span class="comment"> * pings (newlines) can be sent, they will have no effect in the offset.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The newline will be ignored by the slave but will refresh the</span></span><br><span class="line"><span class="comment"> * last interaction timer preventing a timeout. In this case we ignore the</span></span><br><span class="line"><span class="comment"> * ping period and refresh the connection once per second since certain</span></span><br><span class="line"><span class="comment"> * timeouts are set at a few seconds (example: PSYNC response). */</span></span><br><span class="line">listRewind(server.slaves,&amp;li);</span><br><span class="line"><span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">    client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> is_presync =</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||</span><br><span class="line">        (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">         server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_presync) &#123;</span><br><span class="line">        connWrite(slave-&gt;conn, <span class="string">"\n"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">"Disconnecting timedout replica: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a master without attached slaves and there is a replication</span></span><br><span class="line"><span class="comment">     * backlog active, in order to reclaim memory we can free it after some</span></span><br><span class="line"><span class="comment">     * (configured) time. Note that this cannot be done for slaves: slaves</span></span><br><span class="line"><span class="comment">     * without sub-slaves attached should still accumulate data into the</span></span><br><span class="line"><span class="comment">     * backlog, in order to reply to PSYNC queries if they are turned into</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp; server.repl_backlog_time_limit &amp;&amp;</span><br><span class="line">        server.repl_backlog &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle = server.unixtime - server.repl_no_slaves_since;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (idle &gt; server.repl_backlog_time_limit) &#123;</span><br><span class="line">            <span class="comment">/* When we free the backlog, we always use a new</span></span><br><span class="line"><span class="comment">             * replication ID and clear the ID2. This is needed</span></span><br><span class="line"><span class="comment">             * because when there is no backlog, the master_repl_offset</span></span><br><span class="line"><span class="comment">             * is not updated, but we would still retain our replication</span></span><br><span class="line"><span class="comment">             * ID, leading to the following problem:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. We are a master instance.</span></span><br><span class="line"><span class="comment">             * 2. Our slave is promoted to master. It's repl-id-2 will</span></span><br><span class="line"><span class="comment">             *    be the same as our repl-id.</span></span><br><span class="line"><span class="comment">             * 3. We, yet as master, receive some updates, that will not</span></span><br><span class="line"><span class="comment">             *    increment the master_repl_offset.</span></span><br><span class="line"><span class="comment">             * 4. Later we are turned into a slave, connect to the new</span></span><br><span class="line"><span class="comment">             *    master that will accept our PSYNC request by second</span></span><br><span class="line"><span class="comment">             *    replication ID, but there will be data inconsistency</span></span><br><span class="line"><span class="comment">             *    because we received writes. */</span></span><br><span class="line">            changeReplicationId();</span><br><span class="line">            clearReplicationId2();</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replication backlog freed after %d seconds "</span></span><br><span class="line">                <span class="string">"without connected replicas."</span>,</span><br><span class="line">                (<span class="keyword">int</span>) server.repl_backlog_time_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If AOF is disabled and we no longer have attached slaves, we can</span></span><br><span class="line"><span class="comment">     * free our Replication Script Cache as there is no need to propagate</span></span><br><span class="line"><span class="comment">     * EVALSHA at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.aof_state == AOF_OFF &amp;&amp;</span><br><span class="line">        listLength(server.repl_scriptcache_fifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    replicationStartPendingFork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remove the RDB file used for replication if Redis is not running</span></span><br><span class="line"><span class="comment">     * with any persistence. */</span></span><br><span class="line">    removeRDBUsedToSyncReplicas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    replication_cron_loops++; <span class="comment">/* Incremented with frequency 1 HZ. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如果SLAVEOF自己会怎么样？"><a href="#如果SLAVEOF自己会怎么样？" class="headerlink" title="如果SLAVEOF自己会怎么样？"></a>如果SLAVEOF自己会怎么样？</h1><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/" target="_blank" rel="noopener">http://cbsheng.github.io/posts/redis%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1servercron/</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html</a></li><li><a href="https://youjiali1995.github.io/redis/replication/" target="_blank" rel="noopener">https://youjiali1995.github.io/redis/replication/</a></li><li><a href="https://wenfh2020.com/2020/05/31/redis-replication-next/" target="_blank" rel="noopener">https://wenfh2020.com/2020/05/31/redis-replication-next/</a><br> 有注释</li><li><a href="https://redis.io/commands/psync" target="_blank" rel="noopener">https://redis.io/commands/psync</a></li><li><a href="https://zhuanlan.zhihu.com/p/44105707" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44105707</a></li><li><a href="https://zhuanlan.zhihu.com/p/86617437" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/86617437</a><br> 讲解sub slave</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;这篇文。Sentinel是为主从复制服务的，所以在这篇文章里面，我们反过来讲一下主从复制的实现。&lt;/p&gt;
&lt;p&gt;主从复制涉及到RDB等机制，其中持久化部分在&lt;a href=&quot;/2021/03/13/redis-persist/&quot;&gt;Redis持久化机制实现&lt;/a&gt;中介绍。&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>重庆攻略</title>
    <link href="http://www.calvinneo.com/2021/05/09/meet-in-chongqing/"/>
    <id>http://www.calvinneo.com/2021/05/09/meet-in-chongqing/</id>
    <published>2021-05-08T17:20:33.000Z</published>
    <updated>2021-05-19T10:02:06.830Z</updated>
    
    <content type="html"><![CDATA[<p>今年五一的主题是重庆。<br>因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。</p><a id="more"></a><h1 id="Prelude"><a href="#Prelude" class="headerlink" title="Prelude"></a>Prelude</h1><p>首先，我们整理了一份重庆景点资料</p><ol><li>江北渝中体系：<br> 主要位于居住点附近的渝中区舌头上，这边人很多，很密集<ol><li>小什字北<br> 洪崖洞<br> 千厮门大桥</li><li>小什字南<br> 解放碑（实际上离小什字还有点远，但可以从那边走，因为下坡）<br> 长江索道<br> 湖广会馆</li><li>朝天门<br> 朝天门<br> 朝天门码头-弹子石码头</li><li>李子坝：<br> 网红轻轨，以及观景台<br> 鹅岭二厂</li><li>两路口地区<br> 山城步道<br> 宋庆龄故居<br> 两路口地铁站大扶梯</li><li>红土地地铁站</li></ol></li><li>东岸体系(实际位于南岸区)：<ol><li>弹子石<br> 杜莎夫人<br> 弹子石老街<br> 法国水师兵营旧址</li><li>南山<br> 一棵树观景园<br> 壹华里</li></ol></li><li>沙坪坝体系<ol><li>磁器口<br> 磁器口古镇<br> 白公馆<br> 渣滓洞</li></ol></li><li>九龙坡体系<ol><li>川美<br> 四川美术学院<br> 涂鸦一条街</li></ol></li></ol><p>总体来讲，重庆的行主要靠打车即可，这边无论是的士还是滴滴都非常便宜。但是需要有两点考量：</p><ol><li>打滴滴接单比较慢，并且如果在一些很有重庆特色的地方，你的定位很容易就不准，建议手动输入旁边的路名。</li><li>节假日下重庆的堵车比较严重，堵车主要分布在<ol><li>渝中区朝天宫-小什字-较场口附近，强烈建议坐地铁出渝中区再打车</li><li>途径千厮门大桥和东水关大桥，建议由地铁六号线过江</li><li>山路，例如壹华里的下山路</li><li>前往涂鸦一条街（根本打不到车，有条件的可以选择做三蹦子）</li></ol></li><li>很多地图上看起来近的点，是需要绕的</li></ol><p>同理，如果走路的话，也需要做好规划，因为高差的原因，很多地方是要绕的，会走断脚，例如：</p><ol><li>长江索道和湖广会馆</li><li>解放碑到长江索道（有个大上坡）</li><li>【打车】南滨路上东水门大桥</li><li>【打车】南滨路去较场口等区域，需要绕行重庆长江大桥</li></ol><p>由于我们住在东原1891时光道，所以我们的行程规划是：</p><ol><li>D1<br> 【午】和记火爆<br> 弹子石老街<br> 法国水师兵营旧址<br> 弹子石码头乘船到朝天门<br> 逛重庆来福士以寻找可以轻松前往地铁站的道路<br> 朝天门地铁到红土地地铁站<br> 红土地地铁站到小什字出<br> 【临时】一只酸奶牛<br> 走到解放碑步行街<br> 【临时】排队买好又来酸辣粉和玫瑰糍粑冰粉，小酥肉<br> 【晚】秦云老太婆摊摊面<br> 南滨路<br> 在小区平台看渝中区夜景</li><li>D2<br> 打车前往较场口地铁站，坐到李子坝站下<br> 观赏李子坝轻轨穿楼<br> 根据小红书上列举的short cut，从李子坝地铁站走到二厂文创公园<br> 【午】大王油茶<br> 游览二厂文创公园<br> 坐地铁前往杨家坪站<br> 【临时】重庆特色的某面包房<br> 在钟书阁排队，并参观<br> 坐233路去涂鸦一条街<br> 在涂鸦一条街寻找真正的涂鸦，发现西洋景<br> 【临时】梯坎豆花，并放弃人太多的交通茶馆<br> 从涂鸦一条街打车去九九牛肉馆<br> 【晚】九九牛肉馆（老店）<br> 从九九牛肉馆打车到壹华里公园<br> 在壹华里公园爬山，玩手机，以及观赏落日<br> 回宾馆打牌</li><li>D3<br> 【午】洪崖洞猴三火锅店<br> 重庆美术馆假装欣赏艺术<br> 在当当网书店喝一只酸奶牛，并旁听自称可能是重庆最好玩的脱口秀<br> 长江索道体验VIP待遇<br> 步行抵达洪崖洞(11楼)<br> 【晚】体验重庆KFC，并手机斗地主和充电<br> 分别参观洪崖洞的4楼和底楼<br> 挤两部电梯回到11楼，并前往千厮门大桥<br> 桥上步行观光，从大剧院站乘搭地铁，观赏洪崖洞<br> 上新街站打车回家</li></ol><h1 id="D0"><a href="#D0" class="headerlink" title="D0"></a>D0</h1><h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><p>在从红土地回来的路上，我们发现明天的长江索道票不知何时已经被定完了，于是我们只能去定人均100的讲解票，票面上说是免排队的，我感觉还是可以的。</p><h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><p>钟书阁是在这个商场的某个正数楼层，这么说是因为商场太古怪了，地下室有B1到B6，向上是L1和L2，也就是我们进来的地方，在往上又从1开始编号了。反正我们很不瑞雪地从B6上来之后，就发现了一条超级长的队——当然是去钟书阁的了。路上我还搜了钟书阁，在上海甚至无锡都有好几家，但从来没听过，所以这帮人来重庆排这家店干嘛。考虑到Z她们去上厕所了，我想着也没事做，就去排了。前面两个人是腾讯的，穿着那个灰色的文化衫，非常有辨识度。队伍的前进速度是意料之外的快，等到Z上完厕所回来，我都快到门口了。中途还有人发了一下旁边一家奶茶店的优惠券。<br>进去之后，就明白为啥这家店这么网红了，原来在一个跨越两层楼的空间的天花板上装上了玻璃，这个玻璃反射了四面墙壁上的书架和扶梯，显得很壮观。</p><p>逛完钟书阁，打算去涂鸦一条街。站在路边打车，拦车，等了好久，都没有响应。是因为打车的人太多了么？旁边倒是挤满了人，但都是往公交站台走的。我看了会两个人下棋，单车对单车单炮，很没意思。最后，我们还是选择了坐公交车，这个体验真的非常酸爽的。公交车相对是比较挤，路又很颠簸。这是一条风情街，附近应该之前是很多工厂，所以路边的人行道上隔三差五放了很多工业零件的雕塑。</p><p>过了一座桥之后，路两边的涂鸦渐渐多了起来。</p><p>到了公交站，发现路两边的房子都涂满了涂鸦，一栋楼一个风格，于是我们满心欢喜打算去涂鸦一条街，没想到这楼的涂鸦已经是巅峰了。</p><p>往前走，路过交通茶馆和蹄花店，人都在排老长的队，所以我们再往前去吃梯坎豆花。这家豆花便宜好吃，才三块钱，另外一定要加上3块钱一碗的调料。调料虽然看起来很红，但实际上并不辣。</p><p>很多清洁工在擦地。</p><p>我们顺着之前的巷子一直往前走。</p><p>越走，标语就越哲学。</p><p>走到了一所中学门边，我们准备打车。对面有人在排长队，我正好找厕所，就去看了下，原来是易烊千玺的一个雕塑在那边，大家都去合影。上完厕所回来，发现这家中学竞赛基本都是省二，但居然有3个清华，看起来重庆教育也不是很卷啊。</p><p>打车去久久牛肉馆。这趟路是最长的，大约有十几公里，但是总共也就花了五十多。</p><h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;今年五一的主题是重庆。&lt;br&gt;因为疫情刚解封的缘故，所以大家出门游玩的热情十分高涨，限于钱包有限，我们选择了1号晚上从无锡出发，5号中午从重庆返回无锡的计划，在重庆玩三个整天。&lt;/p&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://www.calvinneo.com/tags/游记/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之流程概览</title>
    <link href="http://www.calvinneo.com/2021/04/24/leveldb-proc/"/>
    <id>http://www.calvinneo.com/2021/04/24/leveldb-proc/</id>
    <published>2021-04-24T15:09:06.000Z</published>
    <updated>2021-05-06T14:31:27.816Z</updated>
    
    <content type="html"><![CDATA[<p>在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：</p><ol><li>Memtable</li><li>SSTable</li><li>Compaction机制</li></ol><a id="more"></a><p>先跑一个Demo。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">leveldb::DB* db;</span><br><span class="line">leveldb::Options options;</span><br><span class="line">options.create_if_missing = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">leveldb::Status status = leveldb::DB::Open(options,<span class="string">"./testdb"</span>,&amp;db);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"calvinneo"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> value = <span class="string">"calvinneo@calvinneo.com"</span>;</span><br><span class="line"></span><br><span class="line">status = db-&gt;Put(leveldb::WriteOptions(), key, value);<span class="comment">//添加</span></span><br><span class="line">status = db-&gt;Get(leveldb::ReadOptions(), key, &amp;value);<span class="comment">//获取</span></span><br></pre></td></tr></table></figure></p><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>创建的逻辑实际上是在打开逻辑<code>DB::Open</code>里面分出来的。但由于这部分逻辑简单独立，并且有益于理解整个数据库的layout所以提出来单独讲。<br>首先设置几个数：</p><ol><li><code>SetLogNumber</code>将日志号设置为0</li><li><code>DescriptorFileName</code>生成Manifest文件，序号为1</li><li><code>SetNextFile</code>设置为2<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::NewDB() &#123;</span><br><span class="line">  VersionEdit new_db;</span><br><span class="line">  new_db.SetComparatorName(user_comparator()-&gt;Name());</span><br><span class="line">  new_db.SetLogNumber(<span class="number">0</span>);</span><br><span class="line">  new_db.SetNextFile(<span class="number">2</span>);</span><br><span class="line">  new_db.SetLastSequence(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> manifest = DescriptorFileName(dbname_, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面创建Manifest文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WritableFile* file;</span><br><span class="line">Status s = env_-&gt;NewWritableFile(manifest, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面一连串操作，就是把<code>new_db</code>去Encode到<code>log</code>里面，并且刷盘<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Writer <span class="title">log</span><span class="params">(file)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">  new_db.EncodeTo(&amp;record);</span><br><span class="line">  s = <span class="built_in">log</span>.AddRecord(record);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Sync();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = file-&gt;Close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> file;</span><br></pre></td></tr></table></figure></p><p>设置CURRENT指向最新的Manifest<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Make "CURRENT" file that points to the new manifest file.</span></span><br><span class="line">    s = SetCurrentFile(env_, dbname_, <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    env_-&gt;RemoveFile(manifest);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h1><p>调用链如下所示<br><img src="/img/leveldb/proc/recoverlink.png" alt=""></p><h2 id="DB-Open"><a href="#DB-Open" class="headerlink" title="DB::Open"></a>DB::Open</h2><p><code>DBImpl</code>的构造函数只是一个初始化成员列表，并不包含其他逻辑了。<br>在得到<code>DBImpl</code>对象后，我们首先<strong>加锁</strong>，并且调用<code>Recover</code>方法。这个方法内容是加载Manifest文件，并恢复故障。<br>值得注意的是<code>save_manifest</code>这个参数，会被通过调用链传得很深，具体作用是：</p><ol><li>在<code>RecoverLogFile</code>中可能出现Memtable被Dump的情况</li><li>在<code>Version::Recover</code>中，如果不能<code>ReuseManifest</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname, DB** dbptr) &#123;</span><br><span class="line">  *dbptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  DBImpl* impl = <span class="keyword">new</span> DBImpl(options, dbname);</span><br><span class="line">  impl-&gt;mutex_.Lock();</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></span><br><span class="line">  <span class="keyword">bool</span> save_manifest = <span class="literal">false</span>;</span><br><span class="line">  Status s = impl-&gt;Recover(&amp;edit, &amp;save_manifest);</span><br></pre></td></tr></table></figure></li></ol><p>创建一个新的log文件。如果没有Memtable，需要创建一个。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok() &amp;&amp; impl-&gt;mem_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Create new log and a corresponding memtable.</span></span><br><span class="line">  <span class="keyword">uint64_t</span> new_log_number = impl-&gt;versions_-&gt;NewFileNumber();</span><br><span class="line">  WritableFile* lfile;</span><br><span class="line">  s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</span><br><span class="line">                                   &amp;lfile);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetLogNumber(new_log_number);</span><br><span class="line">    impl-&gt;logfile_ = lfile;</span><br><span class="line">    impl-&gt;logfile_number_ = new_log_number;</span><br><span class="line">    impl-&gt;log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">    impl-&gt;mem_ = <span class="keyword">new</span> MemTable(impl-&gt;internal_comparator_);</span><br><span class="line">    impl-&gt;mem_-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【Q】有个问题，这里为啥还需要调用LogAndApply？因为在<code>VersionSet::Recover</code>里面已经看到有类似的过程了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></span><br><span class="line">    edit.SetLogNumber(impl-&gt;logfile_number_);</span><br><span class="line">    s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    impl-&gt;RemoveObsoleteFiles();</span><br><span class="line">    impl-&gt;MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  impl-&gt;mutex_.Unlock();</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    assert(impl-&gt;mem_ != <span class="literal">nullptr</span>);</span><br><span class="line">    *dbptr = impl;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> impl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DBImpl-Recover"><a href="#DBImpl-Recover" class="headerlink" title="DBImpl::Recover"></a>DBImpl::Recover</h2><p>首先创建数据库目录，并且加文件锁，也就是目录下的<code>LOCK</code>文件，这个函数很有意思，后面专门来讲。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Recover(VersionEdit* edit, <span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></span><br><span class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></span><br><span class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></span><br><span class="line">  env_-&gt;CreateDir(dbname_);</span><br><span class="line">  assert(db_lock_ == <span class="literal">nullptr</span>);</span><br><span class="line">  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>下面我们检查db目录下有没有CURRENT文件。如果没有，我们认为数据库就不存在，如果此时设置了<code>options_.create_if_missing</code>，就创建，否则返回错误。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.create_if_missing) &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Creating DB %s since it was missing."</span>,</span><br><span class="line">        dbname_.c_str());</span><br><span class="line">    s = NewDB();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(</span><br><span class="line">        dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (options_.error_if_exists) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::InvalidArgument(dbname_,</span><br><span class="line">                                   <span class="string">"exists (error_if_exists is true)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面调用VersionSet里面的Recover函数。这个函数负责读取Manifest文件，恢复版本信息。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = versions_-&gt;Recover(save_manifest);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面，我们要分析Log文件，如果有Log文件大于Manifest中记录的值，就说明这些日志是上次关闭时丢失的数据，我们需要恢复这些日志。<br>注意<code>PrevLogNumber</code>不再使用了，但是出于兼容性，我们依旧关注这个字段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">// Recover from all newer log files than the ones named in the</span></span><br><span class="line"><span class="comment">// descriptor (new log files may have been added by the previous</span></span><br><span class="line"><span class="comment">// incarnation without registering them in the descriptor).</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">s = env_-&gt;GetChildren(dbname_, &amp;filenames);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</span><br><span class="line">versions_-&gt;AddLiveFiles(&amp;expected);</span><br><span class="line"><span class="keyword">uint64_t</span> number;</span><br><span class="line">FileType type;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</span><br></pre></td></tr></table></figure></p><p><code>filenames</code>表示数据库目录下面的所有文件，我们依次遍历这些文件，并用<code>ParseFileName</code>解析出他们的number。这里的number就是诸如<code>MANIFEST-000002</code>里面的2，应该也是对应到<code>FileMetaData</code>里面的number字段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</span><br><span class="line">    expected.erase(number);</span><br><span class="line">    <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</span><br><span class="line">      logs.push_back(number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!expected.empty()) &#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">50</span>];</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>RecoverLogFile</code>的作用是回放日志，既然这样，就需要对日志进行排序。回放日志会修改VersionEdit，并且可能会导致Compaction。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Recover in the order in which the logs were generated</span></span><br><span class="line"><span class="built_in">std</span>::sort(logs.begin(), logs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</span><br><span class="line">  s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</span><br><span class="line">                     &amp;max_sequence);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>MarkFileNumberUsed</code>的作用就是设置<code>next_file_number_</code>，确保<code>next_file_number_</code>要严格大于传入的<code>logs[i]</code>。即，如果小于等于传入的<code>logs[i]</code>，就将它设置为<code>logs[i]+1</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></span><br><span class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></span><br><span class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></span><br><span class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</span><br><span class="line">    versions_-&gt;SetLastSequence(max_sequence);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="VersionSet-Recover"><a href="#VersionSet-Recover" class="headerlink" title="VersionSet::Recover"></a>VersionSet::Recover</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::Recover(<span class="keyword">bool</span>* save_manifest) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Status* status;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>首先读取CURRENT文件内容，得到当前用的Manifest文件。注意，到这里为止，肯定是存在CURRENT文件的，如果不存在，<code>DBImpl::Recover</code>流程就已经会去创建了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read "CURRENT" file, which contains a pointer to the current manifest file</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current;</span><br><span class="line">Status s = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (current.empty() || current[current.size() - <span class="number">1</span>] != <span class="string">'\n'</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT file does not end with newline"</span>);</span><br><span class="line">&#125;</span><br><span class="line">current.resize(current.size() - <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>如果没找到Manifest，就返回一个错误。<a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">对于这种情况，应该也是能处理的</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> dscname = dbname_ + <span class="string">"/"</span> + current;</span><br><span class="line">SequentialFile* file;</span><br><span class="line">s = env_-&gt;NewSequentialFile(dscname, &amp;file);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (s.IsNotFound()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT points to a non-existent file"</span>,</span><br><span class="line">                              s.ToString());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是根据Manifest文件里面的内容，读取并设置VersionSet。<br>【Q】在哪里写入的呢？答案是在<code>VersionEdit::EncodeTo</code>和<code>Writer::AddRecord</code>里面，这个函数在LogAndApply的时候被调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</span><br><span class="line"><span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line"><span class="keyword">int</span> read_records = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.status = &amp;s;</span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面，我们用一个while循环，从reader中读取记录。<br><code>ReadRecord</code>这个函数，将下一个record读入<code>*record</code>中，如果读取成功，返回true；如果EOF了，就返回false。可能会使用<code>*scratch</code>作为临时存储。<code>*record</code>是有效的，直到下一个对<code>reader</code>的变化操作，或者对<code>*scratch</code>的变化操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Slice record;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</span><br><span class="line">  ++read_records;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  s = edit.DecodeFrom(record);</span><br></pre></td></tr></table></figure></p><p>Manifest里面会记录当时的Comparator（用文本编辑框打开这个文件，能看到一个类名一样的东西），VersionEdit会比较这两个是否一致。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</span><br><span class="line">      edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</span><br><span class="line">    s = Status::InvalidArgument(</span><br><span class="line">        edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</span><br><span class="line">        icmp_.user_comparator()-&gt;Name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>【Q】在LogAndApply实现中，<code>builder.Apply</code>之后还会跟着<code>builder.SaveTo</code>，这里为啥不跟了？稍等，Apply是一条记录Apply一次，SaveTo是最后全搞好了，一次SaveTo。我们往后看，就能看到对<code>SaveTo</code>的调用了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      builder.Apply(&amp;edit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_log_number_) &#123;</span><br><span class="line">      log_number = edit.log_number_;</span><br><span class="line">      have_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</span><br><span class="line">      prev_log_number = edit.prev_log_number_;</span><br><span class="line">      have_prev_log_number = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</span><br><span class="line">      next_file = edit.next_file_number_;</span><br><span class="line">      have_next_file = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</span><br><span class="line">      last_sequence = edit.last_sequence_;</span><br><span class="line">      have_last_sequence = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到此为止，这个文件就读取完毕了，我们释放这个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line">file = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!have_next_file) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-nextfile entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no meta-lognumber entry in descriptor"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</span><br><span class="line">    s = Status::Corruption(<span class="string">"no last-sequence-number entry in descriptor"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!have_prev_log_number) &#123;</span><br><span class="line">    prev_log_number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MarkFileNumberUsed(prev_log_number);</span><br><span class="line">  MarkFileNumberUsed(log_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是SaveTo、Finalize、AppendVersion的流程，和<code>LogAndApply</code>是类似的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  builder.SaveTo(v);</span><br><span class="line">  <span class="comment">// Install recovered version</span></span><br><span class="line">  Finalize(v);</span><br><span class="line">  AppendVersion(v);</span><br><span class="line">  manifest_file_number_ = next_file;</span><br><span class="line">  next_file_number_ = next_file + <span class="number">1</span>;</span><br><span class="line">  last_sequence_ = last_sequence;</span><br><span class="line">  log_number_ = log_number;</span><br><span class="line">  prev_log_number_ = prev_log_number;</span><br></pre></td></tr></table></figure></p><p>检查是继续用现有的Manifest文件，还是重新建一个。这个可能修改<code>descriptor_file_</code>，从而影响到<code>LogAndApply</code>，但是这样的影响只会存在于Recover里面。<br>【Q】这么处理的目的是什么呢？<br>目的是为了解决Manifest文件过大的问题。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></span><br><span class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</span><br><span class="line">      <span class="comment">// No need to save new manifest</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> error = s.ToString();</span><br><span class="line">    Log(options_-&gt;info_log, <span class="string">"Error recovering version set with %d records: %s"</span>,</span><br><span class="line">        read_records, error.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DBImpl-RecoverLogFile"><a href="#DBImpl-RecoverLogFile" class="headerlink" title="DBImpl::RecoverLogFile"></a>DBImpl::RecoverLogFile</h2><p>【在阅读这个函数前，需要先学习<code>VersionSet::Recover</code>】<br>RecoverLogFile用于读取Log，并且将应用尚未Apply到版本的Log。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::RecoverLogFile(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</span><br><span class="line">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</span><br><span class="line">                              SequenceNumber* max_sequence) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</span><br><span class="line">    Env* env;</span><br><span class="line">    Logger* info_log;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</span><br><span class="line">    Status* status;  <span class="comment">// null if options_.paranoid_checks==false</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> override </span>&#123;</span><br><span class="line">      Log(info_log, <span class="string">"%s%s: dropping %d bytes; %s"</span>,</span><br><span class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">nullptr</span> ? <span class="string">"(ignoring error) "</span> : <span class="string">""</span>), fname,</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.ToString().c_str());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">nullptr</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open the log file</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = LogFileName(dbname_, log_number);</span><br><span class="line">  SequentialFile* file;</span><br><span class="line">  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    MaybeIgnoreError(&amp;status);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create the log reader.</span></span><br><span class="line">  LogReporter reporter;</span><br><span class="line">  reporter.env = env_;</span><br><span class="line">  reporter.info_log = options_.info_log;</span><br><span class="line">  reporter.fname = fname.c_str();</span><br><span class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></span><br><span class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></span><br><span class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></span><br><span class="line">  <span class="comment">// large sequence numbers).</span></span><br><span class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span> <span class="comment">/*checksum*/</span>, <span class="number">0</span> <span class="comment">/*initial_offset*/</span>)</span></span>;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Recovering log #%llu"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)log_number);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read all the records and add to a memtable</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> scratch;</span><br><span class="line">  Slice record;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>;</span><br><span class="line">  MemTable* mem = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p><p>现在，我们开始循环读取日志到<code>record</code>中。接着调用<code>InsertInto</code>方法将它写到Memtable中，这个方法原理我们在介绍<code>DB::Write</code>时讲解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (record.size() &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    reporter.Corruption(record.size(),</span><br><span class="line">                        Status::Corruption(<span class="string">"log record too small"</span>));</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    mem = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">    mem-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</span><br><span class="line">  MaybeIgnoreError(&amp;status);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>接着我们更新<code>last_seq</code>。【Q】有点奇怪，这里为啥要加Count？参考写那一部分的分析。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SequenceNumber last_seq = WriteBatchInternal::Sequence(&amp;batch) +</span><br><span class="line">                                WriteBatchInternal::Count(&amp;batch) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</span><br><span class="line">  *max_sequence = last_seq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果Memtable内存超限了，就开启Minor Compaction。当然，这里是一个局部的Compaction，因为不需要维护版本，所以没有LogAndApply调用。因为也不会产生多余的文件，所以也没有<code>RemoveObsoleteFiles</code>调用。回忆一下WriteLevel0Table的实现，我们实际要做的是：</p><ol><li>生成SSTable</li><li>计算SSTable放到那哪一层</li><li>写VersionEdit</li></ol><p>如果需要将Memtable落盘，那么就要设置<code>save_manifest</code>为true。这个值是从<code>DBImpl::Open</code>开始一层一层传下来的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) &#123;</span><br><span class="line">    compactions++;</span><br><span class="line">    *save_manifest = <span class="literal">true</span>;</span><br><span class="line">    status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">    mem = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      <span class="comment">// Reflect errors immediately so that conditions like full</span></span><br><span class="line">      <span class="comment">// file-systems cause the DB::Open() to fail.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到现在为止，上面的while循环就结束了，我们释放掉这个日志文件。但是这里同样要看一下是否可以重新利用log文件<code>fname</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> file;</span><br><span class="line"></span><br><span class="line"><span class="comment">// See if we should keep reusing the last log file.</span></span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</span><br><span class="line">  assert(logfile_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(log_ == <span class="literal">nullptr</span>);</span><br><span class="line">  assert(mem_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">uint64_t</span> lfile_size;</span><br><span class="line">  <span class="keyword">if</span> (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;</span><br><span class="line">      env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) &#123;</span><br></pre></td></tr></table></figure></p><p>如果重新利用Log，就不需要走到后面的<code>WriteLevel0Table</code>了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Log(options_.info_log, <span class="string">"Reusing old log %s \n"</span>, fname.c_str());</span><br><span class="line">    log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(logfile_, lfile_size);</span><br><span class="line">    logfile_number_ = log_number;</span><br><span class="line">    <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      mem_ = mem;</span><br><span class="line">      mem = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// mem can be nullptr if lognum exists but was empty.</span></span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (mem != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// mem did not get reused; compact it.</span></span><br><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      *save_manifest = <span class="literal">true</span>;</span><br><span class="line">      status = WriteLevel0Table(mem, edit, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mem-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><h3 id="PosixLockTable"><a href="#PosixLockTable" class="headerlink" title="PosixLockTable"></a>PosixLockTable</h3><p><code>PosixLockTable</code>这个类用来管理所有通过<code>LockFile</code>锁住的文件。<br>需要注意的是<code>fcntl(F_SETLK)</code>也可以实现文件锁，但是它不能保证同一个进程中的并发访问，所以在此之外，还需要再包一层。<br>【Q】为什么进程中还会有并发访问？在下文中解释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PosixLockTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    <span class="keyword">bool</span> succeeded = locked_files_.insert(fname).second;</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">    <span class="keyword">return</span> succeeded;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> <span class="title">LOCKS_EXCLUDED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    mu_.Lock();</span><br><span class="line">    locked_files_.erase(fname);</span><br><span class="line">    mu_.Unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  port::Mutex mu_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="function">locked_files_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="LockFile"><a href="#LockFile" class="headerlink" title="LockFile"></a>LockFile</h3><p>为了加锁，我们首先得往自己进程中的<code>PosixLockTable locks_</code>中加入加锁记录。如果加锁失败，说明这个锁已经被我们进程持有了，就退出。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LockFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename, FileLock** lock)</span> override </span>&#123;</span><br><span class="line">  *lock = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> fd = ::open(filename.c_str(), O_RDWR | O_CREAT | kOpenBaseFlags, <span class="number">0644</span>);</span><br><span class="line">  <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> PosixError(filename, errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!locks_.Insert(filename)) &#123;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    <span class="keyword">return</span> Status::IOError(<span class="string">"lock "</span> + filename, <span class="string">"already held by process"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>如果我们进程没有持有锁，再调用<code>LockOrUnlock</code>加文件锁。如果加锁失败，说明锁已经被其他进程占用了，这时候就要将它从<code>locks_</code>移除出去。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (LockOrUnlock(fd, <span class="literal">true</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> lock_errno = errno;</span><br><span class="line">    ::close(fd);</span><br><span class="line">    locks_.Remove(filename);</span><br><span class="line">    <span class="keyword">return</span> PosixError(<span class="string">"lock "</span> + filename, lock_errno);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *lock = <span class="keyword">new</span> PosixFileLock(fd, filename);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixLockTable locks_;</span><br></pre></td></tr></table></figure></p><h3 id="LockOrUnlock"><a href="#LockOrUnlock" class="headerlink" title="LockOrUnlock"></a>LockOrUnlock</h3><p><code>LockOrUnlock</code>根据传入的<code>lock</code>对文件进行<code>F_SETLK</code>操作。<code>F_SETLK</code>是非阻塞的，还有一个<code>F_SETLKW</code>函数是阻塞的。<br><code>F_SETLK</code>可以锁定文件的某些部分，在这里，设置<code>l_start</code>和<code>l_len</code>都为0，表示锁定整个文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LockOrUnlock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> lock)</span> </span>&#123;</span><br><span class="line">  errno = <span class="number">0</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> :</span>:flock file_lock_info;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memset</span>(&amp;file_lock_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(file_lock_info));</span><br><span class="line">  file_lock_info.l_type = (lock ? F_WRLCK : F_UNLCK);</span><br><span class="line">  file_lock_info.l_whence = SEEK_SET;</span><br><span class="line">  file_lock_info.l_start = <span class="number">0</span>;</span><br><span class="line">  file_lock_info.l_len = <span class="number">0</span>;  <span class="comment">// Lock/unlock entire file.</span></span><br><span class="line">  <span class="keyword">return</span> ::fcntl(fd, F_SETLK, &amp;file_lock_info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="有关Linux进程和线程的补充说明"><a href="#有关Linux进程和线程的补充说明" class="headerlink" title="有关Linux进程和线程的补充说明"></a>有关Linux进程和线程的补充说明</h3><p>这里需要注意，Linux中pthread库创建出来的线程可能具有相同的PID，不同的TID，我们可以从下面的代码看到。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> gettid() syscall(SYS_gettid)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> msg[<span class="number">99</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg)<span class="number">-1</span>, <span class="string">"thd %d: getpid %d gettid %d\n"</span>, *(<span class="keyword">int</span>*)index, getpid(), gettid());</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, start_routine, &amp;th1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> th2 = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid2;</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, start_routine, &amp;th2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">"main: i am main\n"</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        write(<span class="number">1</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">main: i am main</span></span><br><span class="line"><span class="comment">thd 1: getpid 31270 gettid 31271</span></span><br><span class="line"><span class="comment">thd 2: getpid 31270 gettid 31272</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h1 id="写"><a href="#写" class="headerlink" title="写"></a>写</h1><p>LevelDB可以通过<code>WriteBatch</code>支持批量更新的功能。当然了，作为对<code>Write</code>函数的一个简易化封装，<code>Put</code>只会更新一个字段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DB::Put(<span class="keyword">const</span> WriteOptions&amp; opt, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  WriteBatch batch;</span><br><span class="line">  batch.Put(key, value);</span><br><span class="line">  <span class="keyword">return</span> Write(opt, &amp;batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写数据库的流程：</p><ol><li>写WAL</li><li>写MemTable</li><li>更新Sequence Number</li></ol><p>如下所示，写是可以并发的，因此会有类似于InnoDB中的组提交机制。<br><img src="/img/leveldb/proc/writeproc.png" alt=""></p><h2 id="DBImpl-Write"><a href="#DBImpl-Write" class="headerlink" title="DBImpl::Write"></a>DBImpl::Write</h2><p>首先，全局有个<code>writers_</code>队列，维护所有的写。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt; <span class="function">writers_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="function">WriteBatch* tmp_batch_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们新创建一个<code>DBImpl::Writer</code>这个对象，这个对象中有一个关联到<code>mutex_</code>的条件变量<code>w.cv</code>。<br>接着将这个Writer对象放到<code>writers_</code>中，然后我们等待下面的条件：</p><ol><li><code>w.done()</code><br> 表示其他线程已经帮<code>w</code>写完了。</li><li><code>w == writers_.front()</code><br> 表示这个Writer位于队头，并且抢到了锁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Write(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates) &#123;</span><br><span class="line">  <span class="function">Writer <span class="title">w</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  w.batch = updates;</span><br><span class="line">  w.sync = options.sync;</span><br><span class="line">  w.done = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ol><p>所以当一个写线程进入时，首先先要获得锁，这个锁可能会被其他的写入(的部分阶段)持有，或者被后台Compaction(的部分阶段)线程持有。<strong>获得锁之后，它能做的其实也就是把自己的<code>Writer</code>挂到<code>writers_</code>队列上</strong>，然后如果现在不是队头，就要去等待信号量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">writers_.push_back(&amp;w);</span><br><span class="line"><span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</span><br><span class="line">  w.cv.Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果从条件变量上醒过来，还是要再检查一下有没有<code>w.done()</code>，因为可能是另一个条件醒过来的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.done) &#123;</span><br><span class="line">  <span class="keyword">return</span> w.status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面调用<code>MakeRoomForWrite</code>，如果<code>updates</code>是nullptr的话，force就是1，强制<code>MakeRoomForWrite</code>进行Compaction。<br>【Q】什么时候<code>updates</code>是nullptr呢？<code>DBImpl::TEST_CompactMemTable</code>里面有个注释，说如果设置为nullptr，就是在催促。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// May temporarily unlock and wait.</span></span><br><span class="line">Status status = MakeRoomForWrite(updates == <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure></p><p>在<code>MakeRoomForWrite</code>之后，肯定是可以往数据库里面写东西的了。<br>我们需要得到一个Sequence Number才能写，我们首先取出上一次写的Sequence Number。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> last_sequence = versions_-&gt;LastSequence();</span><br><span class="line">Writer* last_writer = &amp;w;</span><br></pre></td></tr></table></figure></p><p><code>BuildBatchGroup</code>会合并队列里的多个写入到<code>tmp_batch_</code>里面。这个batch算作一次更新，具有<strong>全局唯一</strong>的一个Sequence Number，从之前递增而来。在合并的时候需要考虑：</p><ol><li>总写入数据大小</li><li>如果有请求是<code>sync==false</code>了，那么就不加入<code>sync==true</code>的<br>在合并结束后，<code>BuildBatchGroup</code>会更新<code>last_writer</code>，表示最后一个写入。<br>【Q】<strong>是不是可能在Memtable有两个record，他们的Sequence Number是相同的？</strong>现在看来是有可能的，这是因为批量写的话只会有一个Sequence Number。但是假如有Count个一次性写入，那么Sequence Number会在这个之后增加Count次。有点奇怪。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; updates != <span class="literal">nullptr</span>) &#123;  <span class="comment">// nullptr batch is for compactions</span></span><br><span class="line">  WriteBatch* write_batch = BuildBatchGroup(&amp;last_writer);</span><br><span class="line">  WriteBatchInternal::SetSequence(write_batch, last_sequence + <span class="number">1</span>);</span><br><span class="line">  last_sequence += WriteBatchInternal::Count(write_batch);</span><br></pre></td></tr></table></figure></li></ol><p>下面是写日志的操作对应<code>AddRecord</code>。<br>【Q】根据注释，这个操作是不需要加锁的，为什么呢？<a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">文章</a>说，这样可以先让其他请求进入队列中排队。<br>这样做是安全的，因为只有一个写，就是<code>&amp;w</code>。<br>同时，可以看出这一步会给写入速度带来比较好的提升，因为只有拿到锁才能往<code>writers_</code>里面push。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add to log and apply to memtable.  We can release the lock</span></span><br><span class="line"><span class="comment">// during this phase since &amp;w is currently responsible for logging</span></span><br><span class="line"><span class="comment">// and protects against concurrent loggers and concurrent writes</span></span><br><span class="line"><span class="comment">// into mem_.</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</span><br><span class="line">  <span class="keyword">bool</span> sync_error = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123;</span><br><span class="line">    status = logfile_-&gt;Sync();</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      sync_error = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>数据库的通用原理，写完日志，状态OK了，才能写Memtable，对应<code>InsertInto</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">      status = WriteBatchInternal::InsertInto(write_batch, mem_);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (sync_error) &#123;</span><br><span class="line">      <span class="comment">// The state of the log file is indeterminate: the log record we</span></span><br><span class="line">      <span class="comment">// just added may or may not show up when the DB is re-opened.</span></span><br><span class="line">      <span class="comment">// So we force the DB into a mode where all future writes fail.</span></span><br><span class="line">      RecordBackgroundError(status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (write_batch == tmp_batch_) tmp_batch_-&gt;Clear();</span><br><span class="line"></span><br><span class="line">  versions_-&gt;SetLastSequence(last_sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>逐个弹出<code>writers_</code>里的元素，并唤起等待write的线程，直到遇到<code>last_writer</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  Writer* ready = writers_.front();</span><br><span class="line">  writers_.pop_front();</span><br><span class="line">  <span class="keyword">if</span> (ready != &amp;w) &#123;</span><br><span class="line">    ready-&gt;status = status;</span><br><span class="line">    ready-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    ready-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们处理完<code>writers</code>队列中的一个项目了，应当Signal一下，通知下一个项目进来。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Notify new head of write queue</span></span><br><span class="line">  <span class="keyword">if</span> (!writers_.empty()) &#123;</span><br><span class="line">    writers_.front()-&gt;cv.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="DBImpl-BuildBatchGroup"><a href="#DBImpl-BuildBatchGroup" class="headerlink" title="DBImpl::BuildBatchGroup"></a>DBImpl::BuildBatchGroup</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: Writer list must be non-empty</span></span><br><span class="line"><span class="comment">// REQUIRES: First writer must have a non-null batch</span></span><br><span class="line">WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  Writer* first = writers_.front();</span><br><span class="line">  WriteBatch* result = first-&gt;batch;</span><br><span class="line">  assert(result != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>讨论第一个batch的大小来设置<code>max_size</code>：</p><ol><li>如果比较小<br> 就设置为<code>size + (128 &lt;&lt; 10)</code></li><li>如果还可以<br> 就设置为<code>1 &lt;&lt; 20</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> size = WriteBatchInternal::ByteSize(first-&gt;batch);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow the group to grow up to a maximum size, but if the</span></span><br><span class="line"><span class="comment">// original write is small, limit the growth so we do not slow</span></span><br><span class="line"><span class="comment">// down the small write too much.</span></span><br><span class="line"><span class="keyword">size_t</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"><span class="keyword">if</span> (size &lt;= (<span class="number">128</span> &lt;&lt; <span class="number">10</span>)) &#123; <span class="comment">// 128 &lt;&lt; 10 == 1 &lt;&lt; 17</span></span><br><span class="line">  max_size = size + (<span class="number">128</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>first</code>是<code>writers_</code>队头，下面，我们就遍历整个<code>writers_</code>队列，直到：</p><ol><li><strong>如果<code>first</code>是non sync的话，那么我们会在遇到第一个要加入的sync请求的时候就break掉。反之，如果<code>first</code>是sync的话，那么可以兼容non sync的请求的</strong>。</li><li>大小超限<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">*last_writer = first;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;Writer*&gt;::iterator iter = writers_.begin();</span><br><span class="line">++iter;  <span class="comment">// Advance past "first"</span></span><br><span class="line"><span class="keyword">for</span> (; iter != writers_.end(); ++iter) &#123;</span><br><span class="line">  Writer* w = *iter;</span><br><span class="line">  <span class="keyword">if</span> (w-&gt;sync &amp;&amp; !first-&gt;sync) &#123;</span><br><span class="line">    <span class="comment">// Do not include a sync write into a batch handled by a non-sync write.</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w-&gt;batch != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    size += WriteBatchInternal::ByteSize(w-&gt;batch);</span><br><span class="line">    <span class="keyword">if</span> (size &gt; max_size) &#123;</span><br><span class="line">      <span class="comment">// Do not make batch too big</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>我们把这些batch，全部加到<code>result</code>里面。如果涉及多个batch，result就指向<code>tmp_batch_</code>，否则就指向<code>first-&gt;batch</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Append to *result</span></span><br><span class="line">      <span class="keyword">if</span> (result == first-&gt;batch) &#123;</span><br><span class="line">        <span class="comment">// Switch to temporary batch instead of disturbing caller's batch</span></span><br><span class="line">        result = tmp_batch_;</span><br><span class="line">        assert(WriteBatchInternal::Count(result) == <span class="number">0</span>);</span><br><span class="line">        WriteBatchInternal::Append(result, first-&gt;batch);</span><br><span class="line">      &#125;</span><br><span class="line">      WriteBatchInternal::Append(result, w-&gt;batch);</span><br><span class="line">    &#125;</span><br><span class="line">    *last_writer = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DBImpl-MakeRoomForWrite"><a href="#DBImpl-MakeRoomForWrite" class="headerlink" title="DBImpl::MakeRoomForWrite"></a>DBImpl::MakeRoomForWrite</h2><p><code>MakeRoomForWrite</code>用来确保我们有空间写入，如果此时Memtable满了，就需要去dump成Immutable Memtable。如果现在Level0负荷过重，那么就要延迟一下写入速度。<br>在研究这个函数时，我们要特别注意各个if条件的判断顺序，这体现了优先级。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// REQUIRES: mutex_ is held</span></span><br><span class="line"><span class="comment">// REQUIRES: this thread is currently at the front of the writer queue</span></span><br><span class="line">Status DBImpl::MakeRoomForWrite(<span class="keyword">bool</span> force) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(!writers_.empty());</span><br><span class="line">  <span class="keyword">bool</span> allow_delay = !force;</span><br><span class="line">  Status s;</span><br></pre></td></tr></table></figure></p><p>一进来，首先一个while循环。唔，这个功能为啥要有while？原因是因为里面要等待信号量的。还有一个原因是，当产生Immutable Memtable之后，我们需要等待它刷盘。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Yield previous error</span></span><br><span class="line">    s = bg_error_;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>如果force为false，也就是不强制执行Compaction，就认为是允许延迟的。【Q】其实我没搞懂这个逻辑。<br>如果允许延迟，并且Level0的文件数达到至少8个，那么就开始慢速写。注意，Level0层最大文件数不是4，这是个误区。当有4个文件的时候开始Compaction，当有12个文件的时候，才停止写入。<br>慢速写的实现就是主线程睡1000ms，这个时候后台的Compaction线程是可以开始Compact的。在睡眠结束之后，要将<code>allow_delay</code>设为false，也就是说对于一次写，我们只慢速一次。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (allow_delay &amp;&amp; versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;=</span><br><span class="line">                              config::kL0_SlowdownWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// We are getting close to hitting a hard limit on the number of</span></span><br><span class="line">  <span class="comment">// L0 files.  Rather than delaying a single write by several</span></span><br><span class="line">  <span class="comment">// seconds when we hit the hard limit, start delaying each</span></span><br><span class="line">  <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></span><br><span class="line">  <span class="comment">// this delay hands over some CPU to the compaction thread in</span></span><br><span class="line">  <span class="comment">// case it is sharing the same core as the writer.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</span><br><span class="line">  allow_delay = <span class="literal">false</span>;  <span class="comment">// Do not delay a single write more than once</span></span><br><span class="line">  mutex_.Lock();</span><br></pre></td></tr></table></figure></p><p>下面，如果不强制Compaction，并且Memtable的大小没有超标，那么就啥都不要做，这个应该是最通常的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</span><br><span class="line">           (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</span><br><span class="line">  <span class="comment">// There is room in current memtable</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>如果此时上一轮Immutable Memtable还没有Minor Compact完毕，那么我们就在<code>background_work_finished_signal_</code>这个条件变量上面等待。<br>我们注意到在进入这个函数时是持有<code>mutex_</code>的，所以这个生产者消费者模式是安全的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// We have filled up the current memtable, but the previous</span></span><br><span class="line">  <span class="comment">// one is still being compacted, so we wait.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Current memtable full; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure></p><p>同理，如果Level0满了，即达到12个文件了，那我们同样要在信号量上等待。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</span><br><span class="line">  <span class="comment">// There are too many level-0 files.</span></span><br><span class="line">  Log(options_.info_log, <span class="string">"Too many L0 files; waiting...\n"</span>);</span><br><span class="line">  background_work_finished_signal_.Wait();</span><br></pre></td></tr></table></figure></p><p>对于剩余的情况，我们要将Memtable改成Immutable Memtable。<br>同时，我们注意到这个分支并不会在最后break掉！这是因为此时有了Immutable Memtable了，我们需要等它被刷成SSTable落盘，所以至少还需要一次while循环。<br>这个这个刷盘过程等到什么时候呢？</p><ol><li>对于<code>CompactMemTable</code>来说，至少要执行完LogAndApply之后，才会将<code>imm_</code>设置为nullptr。</li><li>而这个条件变量，在<code>MaybeScheduleCompaction</code>调用完之后会被Signal。当然，需要注意，在Major Compaction过程中，如果有Immutable Memtable需要落盘，那么还是要先执行<code>CompactMemTable</code>的，在这个之后，也会触发一次Signal。<br>注意，这一次刷盘还可能会导致Level0文件达到上限，那就要等更久了。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></span><br><span class="line">      assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">uint64_t</span> new_log_number = versions_-&gt;NewFileNumber();</span><br><span class="line">      WritableFile* lfile = <span class="literal">nullptr</span>;</span><br><span class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></span><br><span class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">delete</span> log_;</span><br><span class="line">      <span class="keyword">delete</span> logfile_;</span><br><span class="line">      logfile_ = lfile;</span><br><span class="line">      logfile_number_ = new_log_number;</span><br><span class="line">      log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(lfile);</span><br><span class="line">      imm_ = mem_;</span><br><span class="line">      has_imm_.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</span><br><span class="line">      mem_-&gt;Ref();</span><br><span class="line">      force = <span class="literal">false</span>;  <span class="comment">// Do not force another compaction if have room</span></span><br><span class="line">      MaybeScheduleCompaction();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="读"><a href="#读" class="headerlink" title="读"></a>读</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><ol><li>读要加锁么？<br> 我们首先考虑分布式共识这一块，为了实现一致读写，Raft即使是读请求，也需要走一遍LogEntry的。而ZK的话，可以选择直接读，所以未必是一致读。<br> 当然，这个离题了。我觉得根据LevelDB的MVCC模式，其实至少有一部分是可以不加锁的。</li><li>在哪些地方可以非线性地查找？<br> 在非0层找SSTable时，见FindFile。<br> 在BlockReader返回Iterator之后，可以通过Seek来二分。</li><li>在读取的时候会做缓存么？<br> LevelDB在Table和Block两个层面进行缓存。<br> 在Table层面通过TableCache。<br> 在Block层面通过BlockReader里面的<code>table-&gt;rep_-&gt;options.block_cache</code>分支。</li></ol><h2 id="DBImpl-Get"><a href="#DBImpl-Get" class="headerlink" title="DBImpl::Get"></a>DBImpl::Get</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="built_in">std</span>::<span class="built_in">string</span>* value) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  SequenceNumber snapshot;</span><br><span class="line">  <span class="keyword">if</span> (options.snapshot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    snapshot =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> SnapshotImpl*&gt;(options.snapshot)-&gt;sequence_number();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    snapshot = versions_-&gt;LastSequence();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* mem = mem_;</span><br><span class="line">  MemTable* imm = imm_;</span><br><span class="line">  Version* current = versions_-&gt;current();</span><br><span class="line">  mem-&gt;Ref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Ref();</span><br><span class="line">  current-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> have_stat_update = <span class="literal">false</span>;</span><br><span class="line">  Version::GetStats stats;</span><br></pre></td></tr></table></figure><p>可以看到，在获取了<code>current</code>之后，就可以解锁了。<br>【Q】<strong>这里还取出了<code>mem_</code>和<code>imm_</code>，是不是在MVCC下面，可能同时存在多个<code>mem_</code>和<code>imm_</code>？</strong>此时，永远写最新的Memtable，但是可能会读旧的Memtable。<br>下面就是经典的读取三部曲：</p><ol><li>首先看Memtable</li><li>然后看Immutable Memtable</li><li>然后就去SSTable里面找，具体是调用<code>current-&gt;Get</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unlock while reading from files and memtables</span></span><br><span class="line">&#123;</span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="comment">// First look in the memtable, then in the immutable memtable (if any).</span></span><br><span class="line">  <span class="function">LookupKey <span class="title">lkey</span><span class="params">(key, snapshot)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mem-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm != <span class="literal">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    s = current-&gt;Get(options, lkey, value, &amp;stats);</span><br><span class="line">    have_stat_update = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，锁要重新加回来。<br>【Q】看起来读操作也会触发Compaction。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) &#123;</span><br><span class="line">    MaybeScheduleCompaction();</span><br><span class="line">  &#125;</span><br><span class="line">  mem-&gt;Unref();</span><br><span class="line">  <span class="keyword">if</span> (imm != <span class="literal">nullptr</span>) imm-&gt;Unref();</span><br><span class="line">  current-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Version-Get"><a href="#Version-Get" class="headerlink" title="Version::Get"></a>Version::Get</h2><h3 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h3><p>这个函数根据smallest和largest找到对应的文件。<br>容易想到<code>func</code>的作用是在文件里面找key。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Version::ForEachOverlapping(Slice user_key, Slice internal_key, <span class="keyword">void</span>* arg,</span><br><span class="line">                                 <span class="keyword">bool</span> (*func)(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*)) &#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Search level-0 in order from newest to oldest.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; tmp;</span><br></pre></td></tr></table></figure></p><p>从Compaction一文的介绍中了解到，<code>files_</code>里面存放了当前Version中所有SSTable的元信息。<br>我们首先要遍历第0层的所有文件，放到<code>tmp</code>里面，按照<code>f-&gt;number</code>排序。排完序，我们就开始查找，在文件中查找需要借助于传入的<code>func</code>，实际上是<code>State::Match</code>这个函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tmp.reserve(files_[<span class="number">0</span>].size());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].size(); i++) &#123;</span><br><span class="line">  FileMetaData* f = files_[<span class="number">0</span>][i];</span><br><span class="line">  <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">      ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    tmp.push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tmp.empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::sort(tmp.begin(), tmp.end(), NewestFirst);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(*func)(arg, <span class="number">0</span>, tmp[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面，就可以用之前介绍过的<code>FindFile</code>来二分查找了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Search other levels.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> num_files = files_[level].size();</span><br><span class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Binary search to find earliest index whose largest key &gt;= internal_key.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index = FindFile(vset_-&gt;icmp_, files_[level], internal_key);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; num_files) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][index];</span><br><span class="line">      <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// All of "f" is past any data for user_key</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(*func)(arg, level, f)) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="State类"><a href="#State类" class="headerlink" title="State类"></a>State类</h3><p>State类中主要定义了从SSTable中找对应Key的函数<code>Match</code>。<br>在研究之前，我们先来复习一下SSTable的格式：</p><ol><li>data block</li><li>meta block</li><li>meta index block</li><li>index block<br> 记录每个data block的“largest”，满足<a href="/2021/04/12/leveldb-sstable/">两个性质</a>。<br> <strong>注意，这里的largest不是单纯的largest，而要进行一些修正</strong>，它实际上是分隔两个Data Block的最短Key，</li><li>footer<br> 记录index block和meta index block的位置</li></ol><p>所以，我们要先通过index block去定位data block，得到这个data block。</p><p>接着，我们复习一下block的格式</p><ol><li>record</li><li>restart</li><li>额外信息<br> num restarts<br> type<br> crc32<br>所以，我们要用LookupKey先去找restart，然后从restart开始找。</li></ol><p>同时，我们注意由于，meta block的存在，会有一些优化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">  Saver saver;</span><br><span class="line">  GetStats* stats;</span><br><span class="line">  <span class="keyword">const</span> ReadOptions* options;</span><br><span class="line">  Slice ikey;</span><br><span class="line">  FileMetaData* last_file_read;</span><br><span class="line">  <span class="keyword">int</span> last_file_read_level;</span><br><span class="line"></span><br><span class="line">  VersionSet* vset;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">bool</span> found;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">    State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;stats-&gt;seek_file == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        state-&gt;last_file_read != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></span><br><span class="line">      state-&gt;stats-&gt;seek_file = state-&gt;last_file_read;</span><br><span class="line">      state-&gt;stats-&gt;seek_file_level = state-&gt;last_file_read_level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state-&gt;last_file_read = f;</span><br><span class="line">    state-&gt;last_file_read_level = level;</span><br><span class="line"></span><br><span class="line">    state-&gt;s = state-&gt;vset-&gt;table_cache_-&gt;Get(*state-&gt;options, f-&gt;number,</span><br><span class="line">                                              f-&gt;file_size, state-&gt;ikey,</span><br><span class="line">                                              &amp;state-&gt;saver, SaveValue);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;s.ok()) &#123;</span><br><span class="line">      state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (state-&gt;saver.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> kNotFound:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Keep searching in other files</span></span><br><span class="line">      <span class="keyword">case</span> kFound:</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kDeleted:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">case</span> kCorrupt:</span><br><span class="line">        state-&gt;s =</span><br><span class="line">            Status::Corruption(<span class="string">"corrupted key for "</span>, state-&gt;saver.user_key);</span><br><span class="line">        state-&gt;found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Not reached. Added to avoid false compilation warnings of</span></span><br><span class="line">    <span class="comment">// "control reaches end of non-void function".</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TableCache-Get和TableCache-FindTable"><a href="#TableCache-Get和TableCache-FindTable" class="headerlink" title="TableCache::Get和TableCache::FindTable"></a>TableCache::Get和TableCache::FindTable</h3><p>TableCache这一块是一个缓存层，如果缓存中没有，才去读SSTable，并把它加到缓存里面。Get的第一步是FindTable，先介绍这个。<br>首先在<code>cache_</code>里面查文件的handle，如果没找到，就新建一个，并且调用<code>Table::Open</code>从文件中读取。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::FindTable(<span class="keyword">uint64_t</span> file_number, <span class="keyword">uint64_t</span> file_size,</span><br><span class="line">                             Cache::Handle** handle) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</span><br><span class="line">  EncodeFixed64(buf, file_number);</span><br><span class="line">  Slice key(buf, sizeof(buf));</span><br><span class="line">  *handle = cache_-&gt;Lookup(key);</span><br><span class="line">  <span class="keyword">if</span> (*handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> fname = TableFileName(dbname_, file_number);</span><br><span class="line">    RandomAccessFile* file = <span class="literal">nullptr</span>;</span><br><span class="line">    Table* table = <span class="literal">nullptr</span>;</span><br><span class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> old_fname = SSTTableFileName(dbname_, file_number);</span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;file).ok()) &#123;</span><br><span class="line">        s = Status::OK();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = Table::Open(options_, file, file_size, &amp;table);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><code>TableAndFile</code>就是打包<code>RandomAccessFile*</code>和<code>Table*</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      assert(table == <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">delete</span> file;</span><br><span class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></span><br><span class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</span><br><span class="line">      tf-&gt;file = file;</span><br><span class="line">      tf-&gt;table = table;</span><br><span class="line">      *handle = cache_-&gt;Insert(key, tf, <span class="number">1</span>, &amp;DeleteEntry);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面来看Get函数，现在我们已经能得到对应的<code>Table*</code>了，此时调用<code>InternalGet</code>方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status TableCache::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">uint64_t</span> file_number,</span><br><span class="line">                       <span class="keyword">uint64_t</span> file_size, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                       <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                             <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Cache::Handle* handle = <span class="literal">nullptr</span>;</span><br><span class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    Table* t = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</span><br><span class="line">    s = t-&gt;InternalGet(options, k, arg, handle_result);</span><br><span class="line">    cache_-&gt;Release(handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Table-InternalGet"><a href="#Table-InternalGet" class="headerlink" title="Table::InternalGet"></a>Table::InternalGet</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status Table::InternalGet(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; k, <span class="keyword">void</span>* arg,</span><br><span class="line">                          <span class="keyword">void</span> (*handle_result)(<span class="keyword">void</span>*, <span class="keyword">const</span> Slice&amp;,</span><br><span class="line">                                                <span class="keyword">const</span> Slice&amp;)) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  Iterator* iiter = rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);</span><br><span class="line">  iiter-&gt;Seek(k);</span><br><span class="line">  <span class="keyword">if</span> (iiter-&gt;Valid()) &#123;</span><br><span class="line">    Slice handle_value = iiter-&gt;value();</span><br><span class="line">    FilterBlockReader* filter = rep_-&gt;filter;</span><br><span class="line">    BlockHandle handle;</span><br></pre></td></tr></table></figure><p>首先，可以通过布隆过滤器判断这个block里面有没有。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filter != <span class="literal">nullptr</span> &amp;&amp; handle.DecodeFrom(&amp;handle_value).ok() &amp;&amp;</span><br><span class="line">    !filter-&gt;KeyMayMatch(handle.offset(), k)) &#123;</span><br><span class="line">  <span class="comment">// Not found</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p><p>由于布隆过滤器可能假阳，所以这边还需要实际Seek一下。我们<a href="/2021/04/12/leveldb-sstable/">先前</a>介绍过<code>BlockReader</code>，这个函数返回一个Iterator。实际上是一个<code>Block::Iter</code>对象。<br>当时他被用在创建<code>TwoLevelIterator</code>里面，这个双层迭代器实际上就是index block上的迭代器和data block上的迭代器的组合。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      Iterator* block_iter = BlockReader(<span class="keyword">this</span>, options, iiter-&gt;value());</span><br><span class="line">      block_iter-&gt;Seek(k);</span><br><span class="line">      <span class="keyword">if</span> (block_iter-&gt;Valid()) &#123;</span><br><span class="line">        (*handle_result)(arg, block_iter-&gt;key(), block_iter-&gt;value());</span><br><span class="line">      &#125;</span><br><span class="line">      s = block_iter-&gt;status();</span><br><span class="line">      <span class="keyword">delete</span> block_iter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    s = iiter-&gt;status();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> iiter;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Table-Open"><a href="#Table-Open" class="headerlink" title="Table::Open"></a>Table::Open</h3><p>【这一部分可以先不读，因为所有对SSTable的读key请求，最后都是从Cache里面处理了】<br><code>Table::Open</code>负责读取SSTable到表对象<code>Table</code>中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="line">                   <span class="keyword">uint64_t</span> size, Table** table) &#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>先读取footer。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">Slice footer_input;</span><br><span class="line">Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                      &amp;footer_input, footer_space);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">Footer footer;</span><br><span class="line">s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line"><span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure></p><p>再读取block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Read the index block</span></span><br><span class="line">  BlockContents index_block_contents;</span><br><span class="line">  ReadOptions opt;</span><br><span class="line">  <span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">    opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="主体函数"><a href="#主体函数" class="headerlink" title="主体函数"></a>主体函数</h3><p>主要就是构造一个state，然后调用<code>ForEachOverlapping</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</span><br><span class="line">                    <span class="built_in">std</span>::<span class="built_in">string</span>* value, GetStats* stats) &#123;</span><br><span class="line">  stats-&gt;seek_file = <span class="literal">nullptr</span>;</span><br><span class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  State state;</span><br><span class="line">  state.found = <span class="literal">false</span>;</span><br><span class="line">  state.stats = stats;</span><br><span class="line">  state.last_file_read = <span class="literal">nullptr</span>;</span><br><span class="line">  state.last_file_read_level = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  state.options = &amp;options;</span><br><span class="line">  state.ikey = k.internal_key();</span><br><span class="line">  state.vset = vset_;</span><br><span class="line"></span><br><span class="line">  state.saver.state = kNotFound;</span><br><span class="line">  state.saver.ucmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">  state.saver.user_key = k.user_key();</span><br><span class="line">  state.saver.value = value;</span><br><span class="line"></span><br><span class="line">  ForEachOverlapping(state.saver.user_key, state.ikey, &amp;state, &amp;State::Match);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state.found ? state.s : Status::NotFound(Slice());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h1><h2 id="Manifest损坏-丢失"><a href="#Manifest损坏-丢失" class="headerlink" title="Manifest损坏/丢失"></a>Manifest损坏/丢失</h2><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="http://luodw.cc/2015/10/30/leveldb-14/" target="_blank" rel="noopener">http://luodw.cc/2015/10/30/leveldb-14/</a><pre><code>介绍WriteBatch</code></pre></li><li><a href="https://zhuanlan.zhihu.com/p/340804308" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/340804308</a><pre><code>介绍Revocer逻辑</code></pre></li><li><a href="https://blog.csdn.net/sparkliang/article/details/9311487" target="_blank" rel="noopener">https://blog.csdn.net/sparkliang/article/details/9311487</a><pre><code>介绍RecoverLogFile</code></pre></li><li><a href="https://izualzhy.cn/leveldb-write-read" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-write-read</a><br> 介绍了LevelDB读写流程，我使用了它的部分图片</li><li><a href="https://leeshine.github.io/2019/01/24/leveldb-put-get/" target="_blank" rel="noopener">https://leeshine.github.io/2019/01/24/leveldb-put-get/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_10_details.html</a><br> 讲述多线程写的demo，很值得一看</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://www.cnblogs.com/cobbliu/p/6194072.html" target="_blank" rel="noopener">https://www.cnblogs.com/cobbliu/p/6194072.html</a><br> 介绍SSTable、Block的格式，一张大图，非常屌</li><li><a href="https://blog.csdn.net/weixin_42663840/article/details/82629473" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42663840/article/details/82629473</a><br> 我见过最屌有关读写的注释</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在了解了LevelDB的相关模块的实现后，本文时序地展示LevelDB的流程概览。至少要先了解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Memtable&lt;/li&gt;
&lt;li&gt;SSTable&lt;/li&gt;
&lt;li&gt;Compaction机制&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之Compaction实现</title>
    <link href="http://www.calvinneo.com/2021/04/18/leveldb-compaction/"/>
    <id>http://www.calvinneo.com/2021/04/18/leveldb-compaction/</id>
    <published>2021-04-18T15:09:06.000Z</published>
    <updated>2021-06-02T10:55:11.575Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：</p><ol><li>Minor Compaction<br> 对应Memtable到SSTable的过程。</li><li>Major Compaction<br> 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。<br> Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。</li></ol><p>在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。</p><p>同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。</p><a id="more"></a><p>我们首先来回顾一下LevelDB的整体架构<br><img src="/img/leveldb/compaction/arch.png" alt=""></p><p>之前提到过，当一个Memtable满了之后，会转化为Immutable Memtable。Immutable Memtable会被Dump成SSTable文件，SSTable文件是不可变的。<br>这里<code>GUARDED_BY(m)</code>实际上是<code>__attribute__(guarded_by(m))</code>这个线程安全注解，方便编译器帮助检查有没有遗漏掉加锁的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DBImpl</span> :</span> <span class="keyword">public</span> DB &#123;</span><br><span class="line">...</span><br><span class="line">  MemTable* mem_;</span><br><span class="line">  <span class="function">MemTable* imm_ <span class="title">GUARDED_BY</span><span class="params">(mutex_)</span></span>;  <span class="comment">// Memtable being compacted</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h1><h2 id="LCS和STCS"><a href="#LCS和STCS" class="headerlink" title="LCS和STCS"></a>LCS和STCS</h2><p>有两种Compacton方案：Size-Tiered Compaction Strategy(STCS)和Leveled Compaction Strategy(LCS)。</p><h3 id="STCS"><a href="#STCS" class="headerlink" title="STCS"></a>STCS</h3><p>Memtable刷成小sstable。当这些小的sstable达到一定个数时，会被compact成一个稍大些的sstable。当稍大些的sstable又达到一定个数时，又会被一起compact成更大的sstable。当然，如果说某些Key的更新频率比较高，那么在Compact的时候只会取最新的Sequence Number，这种情况下，可能不会增加太多。<br>下图是STCS的一个示意，可以看到，每层的SSTable<strong>数量不变</strong>，但是大小<strong>越来越大</strong>。<br><img src="/img/leveldb/compaction/STCS.png" alt=""></p><h3 id="LCS-Classic-Leveled"><a href="#LCS-Classic-Leveled" class="headerlink" title="LCS(Classic Leveled)"></a>LCS(Classic Leveled)</h3><p>STCS存在一些问题，是可以被优化的：</p><ol><li>存储放大1<br> 因为Compaction时，在新SSTable生成前，旧的SSTable不能删除（当然LevelDB中有Version的概念，其实更复杂点），所以可能会造成额外一倍的开销。<br> 于是我们临机一动，我们增加SSTable数量，而控制大小不变，不就能控制这额外一倍开销的绝对数量么？</li><li>存储放大2<br> 如果Key更新频繁，可能导致同一个Level以及不同Level中的SSTable中存在相同的Key。这里的Key实际上就是LevelDB里面的user key，而不是带有Sequence Number的InternalKey。<br> 【Q】为什么不同Level会存在呢？</li></ol><p>为此，我们就得到了LCS：</p><ol><li>当Level0层数量达到Level0层阈值时，将这些SSTable和L1层的所有SSTable做Compaction。<br> 实际上，具体涉及哪些SSTable，在LevelDB中控制更为精细。并且Compaction的条件也更复杂。</li><li>如果Level1层的SSTable数量还是超过L1层的阈值，再把这些超出的SSTable向上做Compaction。</li><li><strong>除了Level0，其他层的所有SSTable中的key都是不重叠的。</strong></li></ol><p>下图是LCS的一个示意<br><img src="/img/leveldb/compaction/LCS.png" alt=""></p><p>我们注意到，LCS中，SSTable的大小不变，但是数量会增多，Level N+1的<strong>文件数量</strong>是Level N的10倍。【Q】这里看上去和LevelDB的实现还有区别，LevelDB里面的<code>MaxBytesForLevel</code>函数更多的是计算了10倍的大小，Why？这个我们在“Major Compaction流程”章节中讨论过了，每个文件大小是固定的，LevelDB通过限制每层的总大小来间接限制文件数量。这是因为我们dump的时候更方便统计大小而不是文件数量。<br>所以，假如Level1有10个文件，Level2就有100个文件。但是key在两个level中都是均匀分布的，因此我Level1拿出一个文件出来，Level2中估计只会有10个文件和它重叠，所以我们只需要合并重叠的这些文件就行了。<br>当然，Level0彼此重叠，所以还是emmmm。。。</p><p>LCS的缺点是写放大会比STCS显著提高。</p><p>【Q】既然LCS的写放大高了很多，为什么说基于LSM的写性能很好呢？可能是因为下面几点</p><ol><li>SSTable是顺序写，性能好【Q】</li><li>根据<a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">RocksDB</a>的文档，在一些情况下写放大不是很严重<br> 首先是按key顺序的写，对于这种情况RocksDB可以优化。<br> 其次是有skew的写，会导致只有小部分的key被更新。</li></ol><h3 id="Level-N"><a href="#Level-N" class="headerlink" title="Level-N"></a>Level-N</h3><p>相比LCS(Classic Leveled)有更高的读放大，和更小的写放大。</p><h3 id="Tiered-Leveled"><a href="#Tiered-Leveled" class="headerlink" title="Tiered+Leveled"></a>Tiered+Leveled</h3><h1 id="常见文件"><a href="#常见文件" class="headerlink" title="常见文件"></a>常见文件</h1><p>需要注意的是，LevelDB是一个单机的数据库，所以实际承载的SSTable文件都位于一台机器上。</p><p><img src="/img/leveldb/compaction/cm.png" alt=""></p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileType &#123;</span><br><span class="line">  kLogFile,</span><br><span class="line">  kDBLockFile,</span><br><span class="line">  kTableFile,</span><br><span class="line">  kDescriptorFile,</span><br><span class="line">  kCurrentFile,</span><br><span class="line">  kTempFile,</span><br><span class="line">  kInfoLogFile  <span class="comment">// Either the current one, or an old one</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>kLogFile：WAL日志文件，文件名数字.log</li><li>kDBLockFile：db锁文件，文件名LOCK</li><li>kTableFile：SSTable文件，文件名数字.sst</li><li>kDescriptorFile：Manifest文件，存储VersionEdit信息，文件名为MANIFEST-数字<br> 对应<code>descriptor_file_</code>这个字段。<br> Manifest文件中维护了所有的SSTable的key范围，层级，以及其他的元信息。</li><li>kCurrentFile：记录当前的Manifest文件，文件名为CURRENT</li><li>kTempFile：临时文件，db在修复【？】过程中会产生临时文件，文件名为数字.dbtmp</li><li>kInfoLogFile：日志文件，文件名为LOG</li></ol><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>每一个VersionEdit对应Manifest里面的一个Entry，<a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">称为Session Record</a>。<br><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">其中第一条Session Record包含当时LevelDB的全量版本信息</a>，这个应该是通过<code>WriteSnapshot</code>来实现的，可以看下面的介绍。</p><p>如下所示，每个Entry包含</p><ol><li>增加的SSTable<br> kNewFile</li><li>删除的SSTable<br> kDeletedFile</li><li>当前Compaction的下标<br> kCompactPointer</li><li>日志文件编号<br> kLogNumber</li><li>数据库已经持久化数据项中最大的Sequence Number<br> kLastSequence</li></ol><p>对应的代码如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><img src="/img/leveldb/compaction/manifest.png" alt=""></p><p>写Manifest的代码应该是<code>Writer::AddRecord</code>。<br>读Manifest的代码，例如<code>VersionSet::Recover</code>。</p><h2 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h2><p>记录当前的Manifest文件名。</p><h1 id="MVCC介绍"><a href="#MVCC介绍" class="headerlink" title="MVCC介绍"></a>MVCC介绍</h1><p>参考<a href="/2017/09/20/transaction/">数据库系统中的事务</a></p><h1 id="Version机制"><a href="#Version机制" class="headerlink" title="Version机制"></a>Version机制</h1><p>大前提，Compaction过程是通过独立线程异步并发执行的。因此可能出现压缩前后的新老SSTable并存的情况。同时，我们不能立即删除老的SSTable文件，这可能是因为这个SSTable还在被读取，而要等到老SSTable的引用计数为0才行。因此Version机制可以用来辨别这些SSTable的版本。借助于Version机制，也能实现MVCC。</p><p>新版本New-Version由<code>Version</code>类和<code>VersionEdit</code>类来描述。即<code>VersionEdit</code>是New-Version相对于Version的改动。<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New-<span class="keyword">Version</span> = <span class="keyword">Version</span> + VersionEdit</span><br></pre></td></tr></table></figure></p><p><img src="/img/leveldb/compaction/version.png" alt=""></p><p>LevelDB将所有的Version置于一个双向链表之中，因此所有的Version组成一个名为VersionSet的集合。这个集合也代表了当前DB的状态，包含了最新的Version，以及其他正在服务的Version。<br><img src="/img/leveldb/compaction/versionset.png" alt=""></p><h2 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h2><p>介绍作为桥梁作用的<code>VersionEdit</code>类。这个类里面的方法大部分是用来读写里面的私有成员的，所以只介绍私有成员。</p><ol><li><code>std::string comparator_;</code></li><li><p><code>uint64_t log_number_;</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetLogNumber</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure><p> log文件的file number，也就是<code>000003.log</code>的这个3。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">小于这个值的Log是可以被删除的</a><br> 【Q】这个字段的作用是什么呢？<br> 目前来看，在Recover的时候会用到。<br> 【Q】为什么VersionSet里面也有？<br> 其实VersionSet里面的才是主要的，VersionEdit里面的这个字段，是在LogAndApply的时候，由VersionSet设置过来的。<br> 【Q】这个number，和版本的关系是什么，是一一对应的么？比如一次Compaction之后就要换个log？因为在实现上，可以看到<code>NewFileNumber</code>会产生log(<code>DB::Open</code>)和SSTable(<code>WriteLevel0Table</code>)文件的序列号。</p></li><li><code>uint64_t prev_log_number_;</code>/<code>bool has_prev_log_number_;</code><br> 包括<code>void SetPrevLogNumber(uint64_t num)</code>这个函数。<br> <a href="https://zhuanlan.zhihu.com/p/149794634" target="_blank" rel="noopener">这篇文章</a>说<code>prev_log_number_</code>已经废弃了，出于兼容性才保留的。</li><li><p><code>uint64_t next_file_number_;</code>/<code>bool has_next_file_number_;</code><br> 下一个可用的file number。VersionSet里面也有类似字段，详细介绍见VersionSet。<br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNextFile</span><span class="params">(<span class="keyword">uint64_t</span> num)</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>SequenceNumber last_sequence_;</code>/<code>bool has_last_sequence_;</code><br> SSTable 中的最大的Sequence Number。VersionSet里面也有个平行的。</p></li><li><code>bool has_comparator_;</code></li><li><code>bool has_log_number_;</code></li><li><code>std::vector&lt;std::pair&lt;int, InternalKey&gt;&gt; compact_pointers_;</code><br> 主要用于Major Compaction的时候选择文件。first表示每个level。<br> 【Q】在<code>Compaction</code>类和<code>VersionSet</code>类里面也有一个这个字段。它们的作用是什么呢？</li><li><p><code>DeletedFileSet deleted_files_;</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">uint64_t</span>&gt;&gt; DeletedFileSet;</span><br></pre></td></tr></table></figure><p> pair存储了level和file。表示将第level层中的file删除。</p></li><li><code>std::vector&lt;std::pair&lt;int, FileMetaData&gt;&gt; new_files_;</code><br> <code>FileMetaData</code>存储了文件大小，以及文件中最小的Key和最大的Key。</li></ol><h2 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h2><h3 id="相关字段"><a href="#相关字段" class="headerlink" title="相关字段"></a>相关字段</h3><ol><li><p>VersionSet相关<br> 指向这个Version所属的VersionSet，以及双向链表和引用计数。<br> 所以说每个Version只能属于一个VersionSet，这个也是很好理解的，</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VersionSet* vset_;  <span class="comment">// VersionSet to which this Version belongs</span></span><br><span class="line">Version* next_;     <span class="comment">// Next version in linked list</span></span><br><span class="line">Version* prev_;     <span class="comment">// Previous version in linked list</span></span><br><span class="line"><span class="keyword">int</span> refs_;          <span class="comment">// Number of live refs to this version</span></span><br></pre></td></tr></table></figure></li><li><p>SSTable相关<br> <code>files_</code>表示LevelDB中每一层中所有的SSTable的文件信息。<br> <code>file_to_compact(_level)_</code>标记下一个要Compact的文件以及属于的Level。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List of files per level</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; files_[config::kNumLevels];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Next file to compact based on seek stats.</span></span><br><span class="line">FileMetaData* file_to_compact_;</span><br><span class="line"><span class="keyword">int</span> file_to_compact_level_;</span><br></pre></td></tr></table></figure><p> 根据<code>SaveTo</code>函数的<a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">论述</a>，<strong><code>files_[level]</code>是有序的</strong>。</p></li><li>其他字段<br> <code>compaction_score_</code><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">计算最迫切需要Compaction的Level</a>，所以可以决定是否需要发起Major Compaction。这个分数取决于某一层所有SSTable的大小。<br> <code>NeedsCompaction</code>会读取这个字段，计算是否需要根据Version的情况来Compaction，并呈递给<code>MaybeScheduleCompaction</code>。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level that should be compacted next and its compaction score.</span></span><br><span class="line"><span class="comment">// Score &lt; 1 means compaction is not strictly needed.</span></span><br><span class="line"><span class="keyword">double</span> compaction_score_;</span><br><span class="line"><span class="keyword">int</span> compaction_level_;</span><br></pre></td></tr></table></figure></li></ol><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><ol><li><code>int PickLevelForMemTableOutput(const Slice&amp; smallest_user_key, const Slice&amp; largest_user_key);</code><br> 给定一个Memtable里面的Key的范围，返回这个Memtable被Dump的话要放到第几层。</li><li><code>Compaction* PickCompaction();</code><br> 用来处理size compaction和seek compaction。<br> 这个函数，在“Compaction主函数”这个章节介绍。</li><li><code>Compaction* CompactRange(int level, const InternalKey* begin, const InternalKey* end);</code></li></ol><h3 id="Version-PickLevelForMemTableOutput"><a href="#Version-PickLevelForMemTableOutput" class="headerlink" title="Version::PickLevelForMemTableOutput"></a>Version::PickLevelForMemTableOutput</h3><h4 id="OverlapInLevel"><a href="#OverlapInLevel" class="headerlink" title="OverlapInLevel"></a>OverlapInLevel</h4><p>先介绍辅助函数<code>OverlapInLevel</code>，作用是判断范围<code>[smallest_user_key,largest_user_key]</code>和level中的文件有没有Overlap。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Version::OverlapInLevel(<span class="keyword">int</span> level, <span class="keyword">const</span> Slice* smallest_user_key,</span><br><span class="line">                             <span class="keyword">const</span> Slice* largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">return</span> SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; <span class="number">0</span>), files_[level],</span><br><span class="line">                               smallest_user_key, largest_user_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="SomeFileOverlapsRange"><a href="#SomeFileOverlapsRange" class="headerlink" title="SomeFileOverlapsRange"></a>SomeFileOverlapsRange</h4><p>SomeFileOverlapsRange返回<code>files</code>中有没有在范围<code>[smallest_user_key,largest_user_key]</code>中的key，是<code>OverlapInLevel</code>的辅助函数。<br><code>disjoint_sorted_files</code>表示传入的<code>files</code>里面的key是不是不相交的，一般除了Level0，其他都是不相交的。<br><code>AfterFile</code>和<code>BeforeFile</code>都比较FileMetaData里面的<code>largest</code>/<code>smallest</code>的<code>user_key()</code>字段。他们的类型是<code>InternalKey</code>，也就是不带Sequence Number和Value Type的。<br>对于普通情况，对于一个文件<code>f</code>，如果<code>smallest_user_key</code>大于该文件中的最大值，或者<code>largest_user_key</code>小于最小值，那么认为是不重叠的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SomeFileOverlapsRange</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">bool</span> disjoint_sorted_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; files,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* smallest_user_key,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* largest_user_key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Comparator* ucmp = icmp.user_comparator();</span><br><span class="line">  <span class="keyword">if</span> (!disjoint_sorted_files) &#123;</span><br><span class="line">    <span class="comment">// Need to check against all files</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files.size(); i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> FileMetaData* f = files[i];</span><br><span class="line">      <span class="keyword">if</span> (AfterFile(ucmp, smallest_user_key, f) ||</span><br><span class="line">          BeforeFile(ucmp, largest_user_key, f)) &#123;</span><br><span class="line">        <span class="comment">// No overlap</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Overlap</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>如果是不相交的文件，就可以基于<code>FindFile</code>对<code>files</code>集合二分查找，<strong>所以我们看到，在某一个Level找SSTable的时候是可以二分的</strong>。<br>可以思考一下我们用什么做二分的key呢？答案是每个file的largest。我们要找到第一个largest大于等于<code>smallest_user_key</code>的文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Binary search over file list</span></span><br><span class="line">  <span class="keyword">uint32_t</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (smallest_user_key != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Find the earliest possible internal key for smallest_user_key</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">small_key</span><span class="params">(*smallest_user_key, kMaxSequenceNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">                          kValueTypeForSeek)</span></span>;</span><br><span class="line">    index = FindFile(icmp, files, small_key.Encode());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= files.size()) &#123;</span><br><span class="line">    <span class="comment">// beginning of range is after all files, so no overlap.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>二分法找到<strong>可能存在</strong>的文件<code>files[index]</code>后，不要忘了在判断下这个文件<strong>实际有没有overlap</strong>。这是二分法的基本规则。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">return</span> !BeforeFile(ucmp, largest_user_key, files[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span><br><span class="line">                                        <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>首先判断我们要加入的文件的<code>[smallest_user_key,largest_user_key]</code>和Level0有没有交叠。如果有交叠，就进不了这个if，直接放到第一层，等后面Major Compaction了。<br>如果没有交叠，我们尝试能否将它下放到<code>config::kMaxMemCompactLevel</code>之前的层。【Q】为什么我们要设置上限<code>kMaxMemCompactLevel</code>呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></span><br><span class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></span><br><span class="line">    <span class="function">InternalKey <span class="title">start</span><span class="params">(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek)</span></span>;</span><br><span class="line">    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; overlaps;</span><br><span class="line">    <span class="keyword">while</span> (level &lt; config::kMaxMemCompactLevel) &#123;</span><br><span class="line">      <span class="keyword">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为什么会有这个？下面讲。</span></span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">      level++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="判断level-2层情况的分支详解"><a href="#判断level-2层情况的分支详解" class="headerlink" title="判断level + 2层情况的分支详解"></a>判断level + 2层情况的分支详解</h4><p>这里需要着重讲解一下<code>level + 2 &lt; config::kNumLevels</code>这个分支的含义。</p><p>作为普通人呢，我觉得判断完<code>OverlapInLevel(level + 1,...</code>就可以直接<code>level++</code>了啊，但是大佬肯定是不平凡的。<br>大佬觉得现在我们想把文件放到level + 1层，但是要先打住，看看level + 2层是什么情况，也就对应到下面的代码。我们要计算所有重叠的文件的总大小，如果这个大小超过了阈值，那么我们就不把这个SSTable进行下放。<br>这是防止level + 1和level + 2的重叠范围太大，导致这两层进行Compaction时涉及的SSTable过多，耗时过长。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PickLevelForMemTableOutput中的片段代码</span></span><br><span class="line">...</span><br><span class="line">      <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></span><br><span class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int64_t</span> sum = TotalFileSize(overlaps);</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>于是，先要用<code>GetOverlappingInputs</code>这个函数，计算level + 2层中到底有哪些文件和<code>[smallest_user_key,largest_user_key]</code>有交叠，这些文件会放到<code>overlaps</code>里面。<br>而<code>TotalFileSize</code>这个函数就是对<code>FileMetaData::file_size</code>求和。<br>然后，我们和<code>MaxGrandParentOverlapBytes</code>返回的阈值进行比较。</p><h4 id="GetOverlappingInputs-MaxGrandParentOverlapBytes"><a href="#GetOverlappingInputs-MaxGrandParentOverlapBytes" class="headerlink" title="GetOverlappingInputs/MaxGrandParentOverlapBytes"></a>GetOverlappingInputs/MaxGrandParentOverlapBytes</h4><p><code>GetOverlappingInputs</code>的目标是找到level中和<code>[begin,end]</code>重叠的所有文件，并放到<code>inputs</code>里面。这个函数对Level0有特殊的处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Store in "*inputs" all files in "level" that overlap [begin,end]</span></span><br><span class="line"><span class="keyword">void</span> Version::GetOverlappingInputs(<span class="keyword">int</span> level, <span class="keyword">const</span> InternalKey* begin,</span><br><span class="line">                                   <span class="keyword">const</span> InternalKey* end,</span><br><span class="line">                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* inputs) &#123;</span><br></pre></td></tr></table></figure></p><p><code>user_begin</code>和<code>user_end</code>是从InternalKey中提取出的user key。如果传入nullptr，表示在比较时<code>begin</code>永远小于任何key。<br>【Q】这里为什么去找的user key而不是InternalKey呢？貌似很多地方都是找user key。在<a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">这篇文章</a>中，作者指出了一个其实我们很容易注意到的性质，就是除了Level0，每一层Level都是有序的。进一步地，由于LevelDB使用leveled策略(LCS)，即强调一个key在每一层至多只有1条记录，不存在冗余记录。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">  assert(level &lt; config::kNumLevels);</span><br><span class="line">  inputs-&gt;clear();</span><br><span class="line">  Slice user_begin, user_end;</span><br><span class="line">  <span class="keyword">if</span> (begin != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_begin = begin-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (end != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    user_end = end-&gt;user_key();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>默认，我们遍历这一层的所有的文件。前面两个if分别处理文件和range完全不重叠的情况。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size();) &#123;</span><br><span class="line">    FileMetaData* f = files_[level][i++];</span><br><span class="line">    <span class="keyword">const</span> Slice file_start = f-&gt;smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice file_limit = f-&gt;largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely before specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// "f" is completely after specified range; skip it</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>否则就是有重叠的，我们把这个文件加入到<code>inputs</code>里面作为结果返回。对于<code>PickLevelForMemTableOutput</code>的逻辑而言，这里就到此为止了。<br>但是<code>GetOverlappingInputs</code>这个函数还会在<code>CompactRange</code>、<code>SetupOtherInputs</code>这些函数中用到。此时，需要处理Level0的逻辑。<strong>【Q】且慢，我们已经逐文件遍历了啊，还会有什么问题呢？</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      inputs-&gt;push_back(f);</span><br><span class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Level-0 files may overlap each other.  So check if the newly</span></span><br><span class="line">        <span class="comment">// added file has expanded the range.  If so, restart search.</span></span><br><span class="line">        <span class="keyword">if</span> (begin != <span class="literal">nullptr</span> &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_begin = file_start;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">                   user_cmp-&gt;Compare(file_limit, user_end) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          user_end = file_limit;</span><br><span class="line">          inputs-&gt;clear();</span><br><span class="line">          i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">这篇文章</a>中，详细解释了原因。这是因为我们认为Level1的文件是比Level0要旧的，所以<strong>如果要把Level0中的某个文件<code>f</code>移动到Level1中，我们要把Level0中所有和<code>f</code>Overlap的文件都放到Level1里面</strong>。这样，实际上保证了如果我有一个Key在Level0里面，那么inputs里面会包含所有包含这个Key的文件。</p><p>进一步想，在Level0往Level1归并的时候，其实也应该看到这个过程。事实上观看<code>PickCompaction</code>的代码实现，我们也能看到在最后有个<code>if (level == 0)</code>的判断。</p><p>这个应当同样解决我们在<code>IsTrivialMove</code>的一个疑问，也就是为什么Level层有两个的时候，我们不能简单把其中一个文件移动到下层。</p><p>所以，当检查到<code>user_begin</code>在文件<code>[file_start,file_limit]</code>中后，需要将<code>user_begin</code>调整为文件的开头<code>file_start</code>。对<code>user_end</code>也是同理的。</p><h2 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h2><h3 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h3><ol><li><code>Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu)</code><br> 这个函数接受一个VersionEdit。<br> 首先，函数将VersionEdit应用在<code>current_</code>，并借助于<code>VersionSet::Builder</code>生成一个新的Version。Builder类的实现是比较巧妙的，我们会在稍后来讲解。<br> 此后，它会调用<code>Finalize</code>函数更新<code>compaction_level_</code>和<code>compaction_score_</code>。<br> 此后，更新Manifest文件。主要是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。<br> 此后，调用<code>AppendVersion</code>将新版本添加到VersionSet的双向链表中，并且设置新的<code>current_</code>。</li><li><code>std::string compact_pointer_[config::kNumLevels];</code><br> 这个字段在Major Compaction过程中被用到。表示每一层上，下一次Compaction需要开始的key的位置。它要么是一个空串，要么是一个InternalKey。<br> 【Q】在什么时候被设置呢？<br> 根据<a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">文章</a>，这个<code>compact_pointer_</code>实际上表示这一层上一次Compact时文件的largest。</li><li><code>Status Recover(bool* save_manifest);</code><br> 关于Recover机制，我们不在这篇文章中介绍。详见“LevelDB之流程概览”这篇文章。</li></ol><p>有关Sequence：</p><ol><li><code>uint64_t LastSequence() const { return last_sequence_; }</code><br> 还有个对应的<code>SetLastSequence</code>方法。<br> 返回最近的Sequence Number。这个是在写入记录的时候会使用并且更新。<br> 【Q】VersionEdit里面也有个平行的，他们之间的关系是什么呢？<br> 首先VersionSet的<code>last_sequence_</code>会随着<code>DBImpl::Write</code>操作更新。<br> 当需要进行Compact的时候，会在<code>LogAndApply</code>中赋给VersionEdit中的对应字段。而VersionEdit的目的，似乎只是持久化这个信息。</li></ol><p>有关日志：</p><ol><li><code>prev_log_number_</code>/<code>log_number_</code><br> 【Q】和VersionEdit里面同名字段的关系是什么？见VersionEdit的解释。</li></ol><p>有关文件编号：</p><ol><li><p><code>next_file_number_</code><br> 包含</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</span><br><span class="line">    next_file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这个字段用来生成系统中下个文件的编号。VersionEdit需要在LogAndApply时传入，以persist。<br> 【Q】这里的file number指的是SSTable的file number么？<a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">看起来并不是的</a>，而是<a href="https://www.wandouip.com/t5i49833/" target="_blank" rel="noopener">Manifest文件、SSTable文件啥的共用一个编号</a>，这也是为什么一开始Log文件是0，Minifest文件是1，SetNextFile是2的原因。</p></li><li><code>manifest_file_number_;</code><br> 表示Manifest文件的编号，主要在Recover时用到</li></ol><p>疑问：</p><ol><li>VersionSet和DBImpl是一一对应的么？<br> 应该是的，DBImpl持有一个<code>VersionSet*</code>。</li></ol><h3 id="VersionSet-LogAndApply"><a href="#VersionSet-LogAndApply" class="headerlink" title="VersionSet::LogAndApply"></a>VersionSet::LogAndApply</h3><p>在前面已经简单介绍过这个函数的功能了。这个函数主要在下面几个地方用到：</p><ol><li><code>DB::Open</code><br> 当DB启动的时候，可能需要从通过<code>DBImpl::Recover</code>从log中恢复一部分数据。这些数据会以VersionEdit的方式被Apply。</li><li><code>DBImpl::CompactMemTable</code><br> Minor Compaction。<br> 一般在下面的地方调用：<ul><li>BackgroundCompaction</li><li>DoCompactionWork：也就是在Major Compaction的过程中也要有限处理Minor Compaction。</li></ul></li><li><code>BackgroundCompaction</code>的非manual情况（平凡情况）<br> 这种情况只是将某个SSTable移动到别的层。</li><li><code>BackgroundCompaction</code>的manual情况（一般情况）<br> 需要归并。</li></ol><p>下面这里讲解一下源码。<br><code>__attribute__((exclusive_locks_required))</code>表示检查在调用<code>LogAndApply</code>函数之前就要持有锁<code>mu</code>。因此同时只会有一个线程执行<code>LogAndApply</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></span><br><span class="line"><span class="function">  <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span></span>;</span><br></pre></td></tr></table></figure></p><p>下面是把VersionSet的LogNumber传给VersionEdit。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) &#123;</span><br><span class="line">  <span class="keyword">if</span> (edit-&gt;has_log_number_) &#123;</span><br><span class="line">    assert(edit-&gt;log_number_ &gt;= log_number_);</span><br><span class="line">    assert(edit-&gt;log_number_ &lt; next_file_number_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    edit-&gt;SetLogNumber(log_number_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!edit-&gt;has_prev_log_number_) &#123;</span><br><span class="line">    edit-&gt;SetPrevLogNumber(prev_log_number_);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>我们要把VersionSet的<code>last_sequence_</code>传给edit，在对<code>VersionSet::Builder</code>的论述中已经推断过这里的作用了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">  edit-&gt;SetLastSequence(last_sequence_);</span><br><span class="line"></span><br><span class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</span><br><span class="line">    builder.Apply(edit);</span><br><span class="line">    builder.SaveTo(v);</span><br><span class="line">  &#125;</span><br><span class="line">  Finalize(v);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>下面的<code>descriptor_file_</code>就是一个Manifest文件。<br>如果此时<code>descriptor_log_</code>是NULL，根据注释，这个对应到首次打开数据库的状态。我们要新建一个Manifest文件，此时<code>DescriptorFileName</code>产生一个<code>&quot;/MANIFEST-%06llu&quot;</code>格式的文件名字。<br>通过<code>WriteSnapshot</code>把<code>descriptor_log_</code>写到新的Manifest文件里面，这个实际上就是Current Version的快照。<code>WriteSnapshot</code>里面也会调用<code>EncodeTo</code>和<code>AddRecord</code>。<br>【Q】为什么有这个函数？本文之前介绍了Manifest文件的构造，里面提到第一条Session Record记录了当前数据库的全量数据，我认为这里就是实现这个性质的。<br>【Q】注意，<code>VersionSet::ReuseManifest</code>也会修改这个<code>descriptor_log_</code>，有什么影响呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Initialize new descriptor log file if necessary by creating</span></span><br><span class="line">  <span class="comment">// a temporary file that contains a snapshot of the current version.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> new_manifest_file;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">if</span> (descriptor_log_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// No reason to unlock *mu here since we only hit this path in the</span></span><br><span class="line">    <span class="comment">// first call to LogAndApply (when opening the database).</span></span><br><span class="line">    assert(descriptor_file_ == <span class="literal">nullptr</span>);</span><br><span class="line">    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);</span><br><span class="line">    edit-&gt;SetNextFile(next_file_number_);</span><br><span class="line">    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      descriptor_log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(descriptor_file_);</span><br><span class="line">      s = WriteSnapshot(descriptor_log_);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>下面，是把VersionEdit中的内容<code>EncodeTo</code>到Manifest文件里面。这里不是写快照了，而是写一条Log。其实Manifest文件的格式就是Log。<br>在这里，将写文件的操作都集中在一起，期间是不要加锁的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Unlock during expensive MANIFEST log write</span></span><br><span class="line">  &#123;</span><br><span class="line">    mu-&gt;Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write new record to MANIFEST log</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> record;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>EncodeTo</code>将信息按照下面的Tag分类<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Tag &#123;</span><br><span class="line">  kComparator = <span class="number">1</span>,</span><br><span class="line">  kLogNumber = <span class="number">2</span>,</span><br><span class="line">  kNextFileNumber = <span class="number">3</span>,</span><br><span class="line">  kLastSequence = <span class="number">4</span>,</span><br><span class="line">  kCompactPointer = <span class="number">5</span>,</span><br><span class="line">  kDeletedFile = <span class="number">6</span>,</span><br><span class="line">  kNewFile = <span class="number">7</span>,</span><br><span class="line">  <span class="comment">// 8 was used for large value refs</span></span><br><span class="line">  kPrevLogNumber = <span class="number">9</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>AddRecord</code>将信息编码到文件中，对应的读取函数是<code>Reader::ReadRecord</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      edit-&gt;EncodeTo(&amp;record);</span><br><span class="line">      s = descriptor_log_-&gt;AddRecord(record);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        s = descriptor_file_-&gt;Sync();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">        Log(options_-&gt;info_log, <span class="string">"MANIFEST write: %s\n"</span>, s.ToString().c_str());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we just created a new descriptor file, install it by writing a</span></span><br><span class="line">    <span class="comment">// new CURRENT file that points to it.</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; !new_manifest_file.empty()) &#123;</span><br><span class="line">      s = SetCurrentFile(env_, dbname_, manifest_file_number_);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mu-&gt;Lock();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>我们现在得到了一个新的Version即<code>v</code>，调用<code>AppendVersion</code>将它设置为<code>current_</code>。这个函数还会将<code>v</code>添加到VersionSet里面的那个双向链表里面。<br><a href="https://zhuanlan.zhihu.com/p/35275467" target="_blank" rel="noopener">文章</a>中有疑问这里遇到多线程怎么办，但LevelDB中Compact只有一条后台线程，并且这里是持有锁的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Install the new version</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    AppendVersion(v);</span><br><span class="line">    log_number_ = edit-&gt;log_number_;</span><br><span class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">delete</span> v;</span><br><span class="line">    <span class="keyword">if</span> (!new_manifest_file.empty()) &#123;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_log_;</span><br><span class="line">      <span class="keyword">delete</span> descriptor_file_;</span><br><span class="line">      descriptor_log_ = <span class="literal">nullptr</span>;</span><br><span class="line">      descriptor_file_ = <span class="literal">nullptr</span>;</span><br><span class="line">      env_-&gt;RemoveFile(new_manifest_file);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="VersionSet-AppendVersion"><a href="#VersionSet-AppendVersion" class="headerlink" title="VersionSet::AppendVersion"></a>VersionSet::AppendVersion</h3><p>这里<code>dummy_versions_</code>是VersionSet维护的环状链表头，<code>dummy_versions_.prev_</code>就是<code>current_</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::AppendVersion(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Make "v" current</span></span><br><span class="line">  assert(v-&gt;refs_ == <span class="number">0</span>);</span><br><span class="line">  assert(v != current_);</span><br><span class="line">  <span class="keyword">if</span> (current_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    current_-&gt;Unref();</span><br><span class="line">  &#125;</span><br><span class="line">  current_ = v;</span><br><span class="line">  v-&gt;Ref();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Append to linked list</span></span><br><span class="line">  v-&gt;prev_ = dummy_versions_.prev_;</span><br><span class="line">  v-&gt;next_ = &amp;dummy_versions_;</span><br><span class="line">  v-&gt;prev_-&gt;next_ = v;</span><br><span class="line">  v-&gt;next_-&gt;prev_ = v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以通过<a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">下面的图</a>清晰看出<br><img src="/img/leveldb/compaction/versionset_link.png" alt=""></p><h3 id="VersionSet-Builder"><a href="#VersionSet-Builder" class="headerlink" title="VersionSet::Builder"></a>VersionSet::Builder</h3><ol><li><code>VersionSet* vset_;</code><br> 在构造时传入的VersionSet。</li><li><code>Version* base_;</code><br> 在构造时传入的，一般为<code>current_</code></li><li><code>LevelState levels_[config::kNumLevels];</code><br> LevelState里面记录了增加和删除的文件。</li><li><code>void Apply(VersionEdit* edit)</code><br> 将<code>edit</code>里面的变动应用到<code>current_</code>。例如要加些什么文件，写到<code>levels_[level].added_files</code>这个列表里面。但是我们不实际加，而是到<code>SaveTo</code>里面再一次性加。<br> 【Q】为什么要这样子呢？原因有2：<ol><li><code>v-&gt;files_[level]</code>这个是有序存储的。</li></ol></li><li><code>void SaveTo(Version* v)</code><br> 注意，从<code>VersionSet::Recover</code>可以看出，Applt和SaveTo并不是一对一的关系。例如我们从一个文件中多个记录里面恢复，那么每读取一个记录就要Apply一次，但最后再SaveTo。</li></ol><h4 id="VersionSet-Builder-Apply"><a href="#VersionSet-Builder-Apply" class="headerlink" title="VersionSet::Builder::Apply"></a>VersionSet::Builder::Apply</h4><p>这个函数设置诸如<code>levels_[level].added_files</code>的字段，表示我们需要做什么改变。<br>首先将VersionEdit记录的<code>compact_pointers_</code>应用到VersionSet。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Apply all of the edits in *edit to the current state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Apply</span><span class="params">(VersionEdit* edit)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Update compaction pointers</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;compact_pointers_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;compact_pointers_[i].first;</span><br><span class="line">    vset_-&gt;compact_pointer_[level] =</span><br><span class="line">        edit-&gt;compact_pointers_[i].second.Encode().ToString();</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>然后把要增加和删除的文件记录到自己的<code>levels_</code>字段里面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Delete files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; deleted_file_set_kvp : edit-&gt;deleted_files_) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = deleted_file_set_kvp.first;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> number = deleted_file_set_kvp.second;</span><br><span class="line">    levels_[level].deleted_files.insert(number);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在增加文件的时候，需要处理<code>allowed_seeks</code>字段。这里的<code>16384U</code>有点奇怪，是啥意思？<br>根据注释，我们假设：</p><ol><li>一次Seek耗时10ms</li><li>读写1MB耗时10ms，也就是我们的IO速度是100MB/s</li><li>一次Compaction，假设是1MB，需要消耗25MB的IO<ol><li>需要从这一层读取1MB</li><li>从下一层读取10-12MB的数据(boundaries may be misaligned)</li><li>写10-12MB的数据到下一层</li></ol></li></ol><p>这说明25次Seek的开销等于1MB数据的Compaction成本，也就是一次Seek大概摊还下来是40KB数据的压缩成本。我们做一些保留，让16KB对应一次Compaction，也就是允许更多的Seek次数。<br>同时，我们将<code>f-&gt;allowed_seeks</code>最小值设为100，这样也不会一直Compaction。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Add new files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; edit-&gt;new_files_.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> level = edit-&gt;new_files_[i].first;</span><br><span class="line">    FileMetaData* f = <span class="keyword">new</span> FileMetaData(edit-&gt;new_files_[i].second);</span><br><span class="line">    f-&gt;refs = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    f-&gt;allowed_seeks = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;((f-&gt;file_size / <span class="number">16384U</span>)); <span class="comment">// 16*1024</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;allowed_seeks &lt; <span class="number">100</span>) f-&gt;allowed_seeks = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    levels_[level].deleted_files.erase(f-&gt;number);</span><br><span class="line">    levels_[level].added_files-&gt;insert(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="VersionSet-Builder-SaveTo"><a href="#VersionSet-Builder-SaveTo" class="headerlink" title="VersionSet::Builder::SaveTo"></a>VersionSet::Builder::SaveTo</h4><p><code>SaveTo</code>的最终影响是<code>MaybeAddFile</code>，也就是说将文件添加到Version里面。具体是添加到<code>v-&gt;files_</code>里面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save the current state in *v.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SaveTo</span><span class="params">(Version* v)</span> </span>&#123;</span><br><span class="line">  BySmallestKey cmp;</span><br><span class="line">  cmp.internal_comparator = &amp;vset_-&gt;icmp_;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>下面的循环中，我们依次处理每一层的合并。主要内容是：</p><ol><li>将添加的文件合并到<code>files_</code></li><li>删除文件</li></ol><p>之前介绍过<code>base_</code>在构造时传入，一般为CURRENT，我们就是要对<code>base_</code>去应用这些修改。<br>所以，我们是<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base_-&gt;files_<span class="string">[level]</span> + (levels_<span class="string">[level]</span>.added_files - levels_<span class="string">[level]</span>.deleted_files) = v-&gt;files_<span class="string">[level]</span></span><br></pre></td></tr></table></figure></p><p><code>base_iter</code>用来遍历原有的文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="comment">// Merge the set of added files with the set of pre-existing files.</span></span><br><span class="line">    <span class="comment">// Drop any deleted files.  Store the result in *v.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>我们首先<strong>预留最大空间，避免到时候的频繁动态分配</strong>。但是实际上最终未必用到这个空间，因为<code>MaybeAddFile</code>不一定真的添加文件。<br>下面就是插入操作，这个有点奇怪。我们先初始化了<code>bpos</code>，但是循环中自增的却是<code>base_iter</code>，<code>for(A;B;C)</code>里面A和C的主语不一样，很奇怪。其实<code>bpos</code>标记了我们要遍历的终点。具体解释一下，这个函数其实是一个归并的过程，分两步：</p><ol><li>插入原有的<code>base_</code>里面的文件，这些文件要小于等于<code>added_file</code><br> <code>std::upper_bound</code>找到第一个大于<code>added_file</code>的位置<code>bpos</code>，也就是我们的<code>base_iter</code>往后遍历，不会超过<code>bpos</code>。<br> 我们用<code>MaybeAddFile</code>插入，因为这些文件可能已经被标记删除。</li><li>插入<code>added_file</code></li></ol><p><strong>那么这么做的好处在哪里呢？我认为是减少了比较的次数，从O(n)到了O(logn)</strong>。因为我们这里是<code>BytewiseComparator</code>，是两个Slice之间的比较，所以开销还是比较大的，这里是值得学习的一个Best Practice。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">const</span> FileSet* added_files = levels_[level].added_files;</span><br><span class="line">    v-&gt;files_[level].reserve(base_files.size() + added_files-&gt;size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; added_file : *added_files) &#123;</span><br><span class="line">      <span class="comment">// Add all smaller files listed in base_</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;::const_iterator bpos =</span><br><span class="line">               <span class="built_in">std</span>::upper_bound(base_iter, base_end, added_file, cmp);</span><br><span class="line">           base_iter != bpos; ++base_iter) &#123;</span><br><span class="line">        MaybeAddFile(v, level, *base_iter);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      MaybeAddFile(v, level, added_file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add remaining base files</span></span><br><span class="line">    <span class="keyword">for</span> (; base_iter != base_end; ++base_iter) &#123;</span><br><span class="line">      MaybeAddFile(v, level, *base_iter);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>在Debug的状态下，会去检查除Level0之外的层有没有重叠。检查方法也很简单，就是看后一个文件的smallest是不是一定<strong>严格</strong>大于前一个文件的largest。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">// Make sure there is no overlap in levels &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">1</span>; i &lt; v-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; prev_end = v-&gt;files_[level][i - <span class="number">1</span>]-&gt;largest;</span><br><span class="line">        <span class="keyword">const</span> InternalKey&amp; this_begin = v-&gt;files_[level][i]-&gt;smallest;</span><br><span class="line">        <span class="keyword">if</span> (vset_-&gt;icmp_.Compare(prev_end, this_begin) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"overlapping ranges in same level %s vs. %s\n"</span>,</span><br><span class="line">                       prev_end.DebugString().c_str(),</span><br><span class="line">                       this_begin.DebugString().c_str());</span><br><span class="line">          <span class="built_in">std</span>::<span class="built_in">abort</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="VersionSet-Builder-MaybeAddFile"><a href="#VersionSet-Builder-MaybeAddFile" class="headerlink" title="VersionSet::Builder::MaybeAddFile"></a>VersionSet::Builder::MaybeAddFile</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaybeAddFile</span><span class="params">(Version* v, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (levels_[level].deleted_files.count(f-&gt;number) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// File is deleted: do nothing</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];</span><br><span class="line">    <span class="keyword">if</span> (level &gt; <span class="number">0</span> &amp;&amp; !files-&gt;empty()) &#123;</span><br><span class="line">      <span class="comment">// Must not overlap</span></span><br><span class="line">      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size() - <span class="number">1</span>]-&gt;largest,</span><br><span class="line">                                  f-&gt;smallest) &lt; <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    f-&gt;refs++;</span><br><span class="line">    files-&gt;push_back(f);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="VersionSet-Finalize"><a href="#VersionSet-Finalize" class="headerlink" title="VersionSet::Finalize"></a>VersionSet::Finalize</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</span><br><span class="line">  <span class="comment">// Precomputed best level for next compaction</span></span><br><span class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels - <span class="number">1</span>; level++) &#123;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面是针对第0层的特殊情况。我们知道LevelDB的第0层最多存在4个文件【Q】（我觉得未必，详见<code>kL0_SlowdownWritesTrigger</code>），这就是由<code>kL0_CompactionTrigger</code>控制的。这里使用文件数量，注释里面列了两个原因：</p><ol><li>允许更大的写buffer，从而减少Level0 Compaction的数量。<br> 这里的写buffer应该是<code>options_.write_buffer_size</code>这个东西。这个阈值控制Memtable何时转换成Immutable Memtable，以及在Recover的时候何时直接dump成SSTable。<br> 佶屈聱牙，实际上的意思是，这个意思是，如果写buffer太大，如果我们用固定的size限制死了的话，可能Level0的文件数量会很少，比如就1个，这样会导致频繁的Level0 Compaction。</li><li>Level0的文件每次读取都会被Merge。我们不希望有很多个小文件(perhaps because of a small write-buffer setting, or very high compression ratios, or lots of overwrites/deletions)。<br> 如果写buffer很小，这样会导致更多的Level0文件。因为Level0的文件是overlap的，所以如果数量过多，每次查询需要Seek的文件数量就越多。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">      score = v-&gt;files_[level].size() /</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(config::kL0_CompactionTrigger); <span class="comment">// ==4</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于第1层以下的层，计算文件总大小，而不是文件数量了。<code>MaxBytesForLevel</code>的大概意思就是Level1总大小是10M，下面每一层翻10倍。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> level_bytes = TotalFileSize(v-&gt;files_[level]);</span><br><span class="line">      score =</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (score &gt; best_score) &#123;</span><br><span class="line">      best_level = level;</span><br><span class="line">      best_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  v-&gt;compaction_level_ = best_level;</span><br><span class="line">  v-&gt;compaction_score_ = best_score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="MaxBytesForLevel"><a href="#MaxBytesForLevel" class="headerlink" title="MaxBytesForLevel"></a>MaxBytesForLevel</h3><p>这个函数计算每一层的最大大小。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MaxBytesForLevel</span><span class="params">(<span class="keyword">const</span> Options* options, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Note: the result for level zero is not really used since we set</span></span><br><span class="line">  <span class="comment">// the level-0 compaction threshold based on number of files.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Result for both level-0 and level-1</span></span><br><span class="line">  <span class="keyword">double</span> result = <span class="number">10.</span> * <span class="number">1048576.0</span>;</span><br><span class="line">  <span class="keyword">while</span> (level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result *= <span class="number">10</span>;</span><br><span class="line">    level--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>将自己从链表中移除。<br>对于自己管理的所有文件，引用计数减一。【Q】这边不搞个原子操作么？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Version::~Version() &#123;</span><br><span class="line">  assert(refs_ == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove from linked list</span></span><br><span class="line">  prev_-&gt;next_ = next_;</span><br><span class="line">  next_-&gt;prev_ = prev_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Drop references to files</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = files_[level][i];</span><br><span class="line">      assert(f-&gt;refs &gt; <span class="number">0</span>);</span><br><span class="line">      f-&gt;refs--;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;refs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LevelDB对MVCC的实现总结"><a href="#LevelDB对MVCC的实现总结" class="headerlink" title="LevelDB对MVCC的实现总结"></a>LevelDB对MVCC的实现总结</h2><h4 id="版本升级"><a href="#版本升级" class="headerlink" title="版本升级"></a>版本升级</h4><p><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">文章</a>中论述了一次版本升级的过程，但我会批注一下具体实现的函数和逻辑</p><ol><li>新建一个Session Record，记录状态变更信息</li><li>讨论版本升级原因<ol><li>Minor Compaction或者日志replay<br> 在Session Record中记录新增的文件信息、最新的journal编号、数据库sequence number以及下一个可用的文件编号。</li><li>Major Compaction<br> 在Session Record中记录新增、删除的文件信息、下一个可用的文件编号即可。</li></ol></li><li>通过VersionEdit生成新版本<br> 相较于旧的版本信息，新的版本信息更改的内容为：<ol><li>每一层的文件信息：在<code>VersionSet::Builder::Apply</code>中。</li><li>每一层的计分信息：在<code>VersionSet::Finalize</code>中。</li></ol></li><li>将Session Record持久化<br> 在<code>VersionSet::Builder::SaveTo</code>中。</li><li>讨论是否是第一条Session Record<br> 在LogAndApply的Finalize调用之后的部分<ol><li>是<br> 新建一个Manifest文件，并将完整的版本信息全部记录进Session Record作为该Manifest的基础状态写入，同时更改Current文件，将其指向新建的Manifest。</li><li>不是<br> 将该条Session Record进行序列化后直接作为一条记录写入即可。</li></ol></li><li>将当前的Version设置为刚创建的Version<br> 这个会修改<code>current_</code>的指向。这个操作应该是原子的（不然最新版本岂不是会不一致么）实际上也在<code>mutex_</code>的保护下。<br> 在LogAndApply对<code>AppendVersion</code>的调用中。</li></ol><h1 id="Snapshot机制"><a href="#Snapshot机制" class="headerlink" title="Snapshot机制"></a>Snapshot机制</h1><p>我们在这里介绍Snapshot机制，主要是为了方便说明它对Compaction的影响：导致同一个user key的不同的Sequence Number版本存在多个。</p><p>Snapshot实际上就是某个特定的Sequence Number。<br>【Q】Sequence Number是全局递增的么？应该是这样的，在Put和Get的实现中，看到的都是读取的<code>VersionSet::LastSequence()</code>这个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> snapshots_.New(versions_-&gt;LastSequence());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Compaction主函数"><a href="#Compaction主函数" class="headerlink" title="Compaction主函数"></a>Compaction主函数</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="调用路径"><a href="#调用路径" class="headerlink" title="调用路径"></a>调用路径</h3><ol><li>BackgroundCompaction<ol><li>BackgroundCall<ol><li>BGWork<ol><li>MaybeScheduleCompaction<br> 会Schedule方法<code>BGWork</code>。<br> 这个函数在BackgroundCall，以及诸如Get等读写方法中都会被调用。</li></ol></li></ol></li></ol></li></ol><h3 id="Compaction条件"><a href="#Compaction条件" class="headerlink" title="Compaction条件"></a>Compaction条件</h3><ol><li>Minor Compaction<br> 在Recover过程中<code>ApproximateMemoryUsage</code>检测到<strong>Memtable</strong>超限，会直接触发对Memtable的Compaction。但这个Compaction是局部的，因为我们在恢复过程中，所以不需要诸如LogAndApply这种维护Version的工作。<br> 存在Immutable Memtable</li><li>Manual Compaction<br> CompactRange调用</li><li><code>size_compaction</code><br> 在<code>VersionSet::PickCompaction</code>中检查并启动。<br> 当Level0文件数目过多，或者某个Level的总大小过大。<br> 在函数<code>NeedsCompaction</code>中判断当前Version的<code>compaction_score_</code>(size compaction)和<code>file_to_compact_</code>(seek compaction)。</li><li><code>seek_compaction</code><br> seek次数太多。我们知道，当一个文件找不到时，就需要到高一级的Level中去查找。假如在<code>Level(n)</code>中没找到，但是在<code>Level(n+1)</code>中找到了，就认为<code>Level(n)</code>有一次未命中。容易发现如果未命中次数多了，就说明Level N和Level N+1<br> 的文件overlap很厉害，这就需要通过一次Major Compaction来解决这个问题。</li></ol><h2 id="DBImpl类"><a href="#DBImpl类" class="headerlink" title="DBImpl类"></a>DBImpl类</h2><p>LevelDB通过<code>class DB</code>对外暴露C++接口，这个<code>DB</code>的实现就是<code>DBImpl</code>。</p><h2 id="DBImpl-BackgroundCall"><a href="#DBImpl-BackgroundCall" class="headerlink" title="DBImpl::BackgroundCall"></a>DBImpl::BackgroundCall</h2><p>BackgroundCall是在后台线程中执行的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</span><br><span class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</span><br><span class="line">  assert(background_compaction_scheduled_);</span><br><span class="line">  <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// No more background work when shutting down.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// No more background work after a background error.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BackgroundCompaction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_compaction_scheduled_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></span><br><span class="line">  <span class="comment">// so reschedule another compaction if needed.</span></span><br><span class="line">  MaybeScheduleCompaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>MakeRoomForWrite</code>函数会在<code>background_work_finished_signal_</code>等待Compaction结束。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  background_work_finished_signal_.SignalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DBImpl-MaybeScheduleCompaction"><a href="#DBImpl-MaybeScheduleCompaction" class="headerlink" title="DBImpl::MaybeScheduleCompaction"></a>DBImpl::MaybeScheduleCompaction</h2><p>函数<code>MaybeScheduleCompaction</code>决定是否进行Compaction。<br>这里需要加锁，不然可能会导致开两个后台进程，而LevelDB只允许一个后台进程。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::MaybeScheduleCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">if</span> (background_compaction_scheduled_) &#123;</span><br><span class="line">    <span class="comment">// Already scheduled</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Already got an error; no more changes</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="literal">nullptr</span> &amp;&amp; manual_compaction_ == <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">             !versions_-&gt;NeedsCompaction()) &#123;</span><br><span class="line">    <span class="comment">// No work to be done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    background_compaction_scheduled_ = <span class="literal">true</span>;</span><br><span class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PosixEnv-Schedule"><a href="#PosixEnv-Schedule" class="headerlink" title="PosixEnv::Schedule"></a>PosixEnv::Schedule</h3><p>这里的<code>env_</code>的实现实际上是一个<code>PosixEnv</code>。<br>我们查看源码，原来这个后台进程只有一个<code>started_background_thread_</code>，一开始先检查它是否存在，如果不存在，就创建一个，然后detach掉。<br>接下来就是一个生产者消费者模式。不过有点奇怪，是先Signal，再入队，不应该先修改条件，再Signal么。<br>我在<a href="/2017/12/28/Concurrency-Programming-Compare/">文章</a>中提过<a href="http://www.cppblog.com/Solstice/archive/2015/10/30/203094.html" target="_blank" rel="noopener">陈硕大佬的一篇博客</a>，在CV语境中，<a href="https://gist.github.com/chenshuo/6430925" target="_blank" rel="noopener">先Signal，再设置条件flag(代码里面的Case 6)</a>也是可以的，但只限于单waiter使用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::Schedule(</span><br><span class="line">    <span class="keyword">void</span> (*background_work_function)(<span class="keyword">void</span>* background_work_arg),</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg) &#123;</span><br><span class="line">  background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start the background thread, if we haven't done so already.</span></span><br><span class="line">  <span class="keyword">if</span> (!started_background_thread_) &#123;</span><br><span class="line">    started_background_thread_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">background_thread</span><span class="params">(PosixEnv::BackgroundThreadEntryPoint, <span class="keyword">this</span>)</span></span>;</span><br><span class="line">    background_thread.detach();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the queue is empty, the background thread may be waiting for work.</span></span><br><span class="line">  <span class="keyword">if</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">    background_work_cv_.Signal();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  background_work_queue_.emplace(background_work_function, background_work_arg);</span><br><span class="line">  background_work_mutex_.Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面放一下消费者的代码<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> PosixEnv::BackgroundThreadMain() &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    background_work_mutex_.Lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until there is work to be done.</span></span><br><span class="line">    <span class="keyword">while</span> (background_work_queue_.empty()) &#123;</span><br><span class="line">      background_work_cv_.Wait();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(!background_work_queue_.empty());</span><br><span class="line">    <span class="keyword">auto</span> background_work_function = background_work_queue_.front().function;</span><br><span class="line">    <span class="keyword">void</span>* background_work_arg = background_work_queue_.front().arg;</span><br><span class="line">    background_work_queue_.pop();</span><br><span class="line"></span><br><span class="line">    background_work_mutex_.Unlock();</span><br><span class="line">    background_work_function(background_work_arg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PosixEnv::PosixEnv()</span><br><span class="line">    : background_work_cv_(&amp;background_work_mutex_),</span><br><span class="line">      started_background_thread_(<span class="literal">false</span>),</span><br><span class="line">      mmap_limiter_(MaxMmaps()),</span><br><span class="line">      fd_limiter_(MaxOpenFiles()) &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="NeedsCompaction"><a href="#NeedsCompaction" class="headerlink" title="NeedsCompaction"></a>NeedsCompaction</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  Version* v = current_;</span><br><span class="line">  <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Compaction类"><a href="#Compaction类" class="headerlink" title="Compaction类"></a>Compaction类</h2><p>定义在version_set.h文件里面。</p><h3 id="主要成员和成员函数"><a href="#主要成员和成员函数" class="headerlink" title="主要成员和成员函数"></a>主要成员和成员函数</h3><ol><li><code>std::vector&lt;FileMetaData*&gt; inputs_[2];</code><br> 表示这个Compaction涉及的两个level的文件，也就是输入。<br> 其中level层是<code>inputs_[0]</code>。level + 1层是<code>inputs_[1]</code>，称为parents。</li><li><code>std::vector&lt;FileMetaData*&gt; grandparents_;</code><br> level + 2层的文件，通常称为grandparents。</li><li><code>int level() const { return level_; }</code><br> 我们将<code>level_</code>和<code>level_+1</code>层进行压缩。</li><li><code>int num_input_files(int which) const</code></li><li><code>bool IsTrivialMove() const;</code><br> 是否可以直接移动，而不涉及merge或者split操作。</li><li><code>bool ShouldStopBefore(const Slice&amp; internal_key);</code></li><li><code>VersionEdit* edit() { return &amp;edit_; }</code>/<code>edit_</code><br> 这个应该很好理解，Compaction肯定会有文件增删，即使是移动，也是跨层的。所以这里需要一个<code>VersionEdit</code>来描述。</li></ol><h3 id="IsTrivialMove"><a href="#IsTrivialMove" class="headerlink" title="IsTrivialMove"></a>IsTrivialMove</h3><p>这个函数用来判断在Major Compaction的时候能不能直接移动老的文件到下面一层，而不归并生成新的文件，条件有三个：</p><ol><li>level层只有一个<br> 【Q】疑问：如果level层有多个，level+1层没有，那么我直接移动到下面一层也是安全的？那么禁止这么做的目的是什么？<br> 检查对<code>GetOverlappingInputs</code>的分析，发现可能是不安全的。如果说Level0的某个文件<code>f</code>和Level1的文件有Overlap，那么就必须要扫描整个Level0层的所有文件，将与<code>f</code>有Overlap的文件都要移到下一层。</li><li>level + 1层没有<br> 这个原因应该好理解，如果level+1层有，那么我们就得比较和这个文件有没有Overlap。</li><li>和level + 2层的overlap没有超过阈值(实际上是20M)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Compaction::IsTrivialMove() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> VersionSet* vset = input_version_-&gt;vset_;</span><br><span class="line">  <span class="comment">// Avoid a move if there is lots of overlapping grandparent data.</span></span><br><span class="line">  <span class="comment">// Otherwise, the move could create a parent file that will require</span></span><br><span class="line">  <span class="comment">// a very expensive merge later on.</span></span><br><span class="line">  <span class="keyword">return</span> (num_input_files(<span class="number">0</span>) == <span class="number">1</span> &amp;&amp; num_input_files(<span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">          TotalFileSize(grandparents_) &lt;=</span><br><span class="line">              MaxGrandParentOverlapBytes(vset-&gt;options_));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-BackgroundCompaction"><a href="#DBImpl-BackgroundCompaction" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>这个过程是Compaction的主过程，需要全程持锁。</p><h3 id="Minor"><a href="#Minor" class="headerlink" title="Minor"></a>Minor</h3><p>我们首先需要去<code>CompactMemTable</code>，也就是Minor Compaction。这个肯定是优先级更高的，因为我们只有两个Memtable，所以我们肯定想把Immutable Memtable快速腾空。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CompactMemTable();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="Major"><a href="#Major" class="headerlink" title="Major"></a>Major</h3><p>详见Major Compaction章节</p><h1 id="Minor-Compaction流程"><a href="#Minor-Compaction流程" class="headerlink" title="Minor Compaction流程"></a>Minor Compaction流程</h1><h2 id="CompactMemTable"><a href="#CompactMemTable" class="headerlink" title="CompactMemTable"></a>CompactMemTable</h2><p>主要流程三部分：</p><ol><li>WriteLevel0Table<ol><li>将Immutable Memtable生成SSTable文件<br> 这个文件的基本信息写到<code>FileMetaData</code>里面，并在最后写入<code>VersionEdit</code>。<br> 注意，在Recover的过程中，这里其实也可以传入Memtable。</li><li>计算添加到哪一层<br> 这个文件未必会放到Level0，可能会直接放到Level1甚至Level2，具体由<code>kMaxMemCompactLevel</code>控制。</li><li>将上面说的<code>FileMetaData</code>写入VersionEdit<br> 因此这个函数的实际返回是传入的<code>VersionEdit* edit</code>。</li></ol></li><li>LogAndApply<br> 用我们得到的<code>VersionEdit</code>，去更新数据库状态，并记录。</li><li>RemoveObsoleteFiles<br> 重置Immutable Memtable。<br> 删除无用文件。主要包括<code>kLogFile</code>/<code>kLogFile</code>/<code>kTableFile</code>等。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::CompactMemTable() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  assert(imm_ != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the memtable as a new Table</span></span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  Version* base = versions_-&gt;current();</span><br><span class="line">  base-&gt;Ref();</span><br><span class="line">  Status s = WriteLevel0Table(imm_, &amp;edit, base);</span><br><span class="line">  base-&gt;Unref();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    s = Status::IOError(<span class="string">"Deleting DB during memtable compaction"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>下面，就是要把<code>edit</code>应用到当前的VersionSet上。<br>【Q】<code>SetPrevLogNumber</code>是啥意思？为啥要设置为0呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);</span><br><span class="line">    edit.SetLogNumber(logfile_number_);  <span class="comment">// Earlier logs no longer needed</span></span><br><span class="line">    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// Commit to the new state</span></span><br><span class="line">    imm_-&gt;Unref();</span><br><span class="line">    imm_ = <span class="literal">nullptr</span>;</span><br><span class="line">    has_imm_.store(<span class="literal">false</span>, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    RemoveObsoleteFiles();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecordBackgroundError(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h2><p>在前文中，已经介绍过了<code>WriteLevel0Table</code>的作用，下面看实现。</p><p>首先，我们计算出一个<code>NewFileNumber</code>，也就是落盘时体现的文件名。关于这个函数，我们之前已经介绍过了，体现在诸如<code>MANIFEST-xxxxx</code>或者<code>yyyyy.log</code>这里的序号。</p><p><code>pending_outputs_</code>中保存了所有正在Compact的SSTable文件，这些文件不能被删除。这引发了我两个问题：</p><ol><li>什么时候会删除？<br> 在<code>RemoveObsoleteFiles</code>里面，马上就能看到了，不急不急</li><li>为什么在BuildTable之后就可以删除了？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,</span><br><span class="line">                                Version* base) &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  FileMetaData meta;</span><br><span class="line">  meta.number = versions_-&gt;NewFileNumber();</span><br><span class="line">  pending_outputs_.insert(meta.number);</span><br><span class="line">  Iterator* iter = mem-&gt;NewIterator();</span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: started"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着，<code>BuildTable</code>创建一个<code>TableBuilder</code>写入数据。值得注意的是，这里并没有加锁。我之前认为这是因为<code>BuildTable</code>里面会自带加锁，但是检查代码并没有。这可能是因为Compaction是单独的线程，诸如生成并写SSTable的过程是可以单独提出来处理的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  Status s;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Level-0 table #%llu: %lld bytes %s"</span>,</span><br><span class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.number, (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>)meta.file_size,</span><br><span class="line">      s.ToString().c_str());</span><br><span class="line">  <span class="keyword">delete</span> iter;</span><br><span class="line">  pending_outputs_.erase(meta.number);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>新生成的文件未必会放到Level0，可能会直接放到Level1。例如，如果新的SSTable文件和Level1中的文件没有重叠，那么就<strong>有可能</strong>被放到Level1，具体还需要查看Level2和新SSTable的重叠情况。因此<code>PickLevelForMemTableOutput</code>会生成一个level，表示放到哪一层。<br>下面的<code>edit-&gt;AddFile</code>就是将这个SSTable加到当前的VersionEdit中。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">// Note that if file_size is zero, the file has been deleted and</span></span><br><span class="line">  <span class="comment">// should not be added to the manifest.</span></span><br><span class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; meta.file_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice min_user_key = meta.smallest.user_key();</span><br><span class="line">    <span class="keyword">const</span> Slice max_user_key = meta.largest.user_key();</span><br><span class="line">    <span class="keyword">if</span> (base != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);</span><br><span class="line">    &#125;</span><br><span class="line">    edit-&gt;AddFile(level, meta.number, meta.file_size, meta.smallest,</span><br><span class="line">                  meta.largest);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>env_</code>实际上是封装了文件系统等操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  CompactionStats stats;</span><br><span class="line">  stats.micros = env_-&gt;NowMicros() - start_micros;</span><br><span class="line">  stats.bytes_written = meta.file_size;</span><br><span class="line">  stats_[level].Add(stats);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="RemoveObsoleteFiles"><a href="#RemoveObsoleteFiles" class="headerlink" title="RemoveObsoleteFiles"></a>RemoveObsoleteFiles</h2><p>搞清楚几个问题：</p><ol><li>清理文件的范围？看<code>env_-&gt;GetChildren</code>的实现，应该是所有这个db下的文件。</li><li>清理文件的类型？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::RemoveObsoleteFiles() &#123;</span><br><span class="line">  mutex_.AssertHeld();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!bg_error_.ok()) &#123;</span><br><span class="line">    <span class="comment">// After a background error, we don't know whether a new version may</span></span><br><span class="line">    <span class="comment">// or may not have been committed, so we cannot safely garbage collect.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a set of all of the live files</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; live = pending_outputs_;</span><br><span class="line">  versions_-&gt;AddLiveFiles(&amp;live);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</span><br><span class="line">  env_-&gt;GetChildren(dbname_, &amp;filenames);  <span class="comment">// Ignoring errors on purpose</span></span><br><span class="line">  <span class="keyword">uint64_t</span> number;</span><br><span class="line">  FileType type;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; files_to_delete;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : filenames) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ParseFileName(filename, &amp;number, &amp;type)) &#123;</span><br><span class="line">      <span class="keyword">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> kLogFile:</span><br><span class="line">          keep = ((number &gt;= versions_-&gt;LogNumber()) ||</span><br><span class="line">                  (number == versions_-&gt;PrevLogNumber()));</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kDescriptorFile:</span><br><span class="line">          <span class="comment">// Keep my manifest file, and any newer incarnations'</span></span><br><span class="line">          <span class="comment">// (in case there is a race that allows other incarnations)</span></span><br><span class="line">          keep = (number &gt;= versions_-&gt;ManifestFileNumber());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTableFile:</span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kTempFile:</span><br><span class="line">          <span class="comment">// Any temp files that are currently being written to must</span></span><br><span class="line">          <span class="comment">// be recorded in pending_outputs_, which is inserted into "live"</span></span><br><span class="line">          keep = (live.find(number) != live.end());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> kCurrentFile:</span><br><span class="line">        <span class="keyword">case</span> kDBLockFile:</span><br><span class="line">        <span class="keyword">case</span> kInfoLogFile:</span><br><span class="line">          keep = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">        files_to_delete.push_back(<span class="built_in">std</span>::move(filename));</span><br><span class="line">        <span class="keyword">if</span> (type == kTableFile) &#123;</span><br><span class="line">          table_cache_-&gt;Evict(number);</span><br><span class="line">        &#125;</span><br><span class="line">        Log(options_.info_log, <span class="string">"Delete type=%d #%lld\n"</span>, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(type),</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(number));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// While deleting all files unblock other threads. All files being deleted</span></span><br><span class="line">  <span class="comment">// have unique names which will not collide with newly created files and</span></span><br><span class="line">  <span class="comment">// are therefore safe to delete while allowing other threads to proceed.</span></span><br><span class="line">  mutex_.Unlock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; filename : files_to_delete) &#123;</span><br><span class="line">    env_-&gt;RemoveFile(dbname_ + <span class="string">"/"</span> + filename);</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_.Lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Major-Compaction流程"><a href="#Major-Compaction流程" class="headerlink" title="Major Compaction流程"></a>Major Compaction流程</h1><h2 id="【Q】思考"><a href="#【Q】思考" class="headerlink" title="【Q】思考"></a>【Q】思考</h2><p>在开始研究Major Compaction前，我们主动思考这个问题</p><ol><li>对于Level0里面的文件，是不是可以直接和Level1中的文件Merge？<br> 答案是不行的，见<code>GetOverlappingInputs</code>的论述。</li><li>如果level中的某个文件的key的range过大，它可能和level+1层的很多文件有重合，这样的compaction写放大很重，如何解决这个问题？<br> 首先，这也是为什么LevelDB要分成很多层的原因，在Merge的时候，最多和下一层中的所有文件Overlap，写放大是可控的。<br> 其次，在Compact的时候，LevelDB一直关注和level+2层的key的重叠情是否超过一定量，即<code>MaxGrandParentOverlapBytes</code>函数。<ul><li>在<code>ShouldStopBefore</code>判断是否要结束当前SSTable写入，新开文件的时候，考虑当前文件和level+2的Overlap，如果过了，就新开文件。</li><li>在<code>IsTrivialMove</code>判断是否可以直接移动文件到下层的时候，考虑要移动的文件和level+2层的Overlap，如果过了，就不能移动。</li><li>在<code>PickLevelForMemTableOutput</code>选择Minor Compaction的层时，考虑这个Immutable Memtable的Overlap，如果过了，就不能放在这一层。</li></ul></li><li>从level到level+1的Compaction会对level+2产生什么影响？</li><li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">LevelDB</a>中多个不相干的合并是可以并发进行的，这个的实现是怎样的？<br> 需要注意，Level0文件是彼此Overlap的，所以是相干的。<br> 【Q】那么当一个Major Compaction开始的时候，是如何判定是否相干，如果不相干就不Compact的呢？从LevelDB的代码来看，只有一个后台线程进行Compact操作，所以我认为虽然在设计上LSM树是允许并行Compact的，但是LevelDB并没有实现，但RocksDB肯定是实现的。</li><li>LevelDB中，每个user key在一层中是不是只会出现一次？<br> 大多数情况是的，有两个例外。<br> 首先，Level0是Overlap的，可能有多个。<br> 其次，如果使用了Snapshot，那么在下层可能也会有user key相同，但是sequence不同的。见<code>AddBoundaryInputs</code>的论述。</li><li>我们往Manifest文件里面写了什么？</li><li>LevelDB有容量限制么？<br> <a href="https://stackoverflow.com/questions/31742460/is-there-record-number-limit-in-leveldb" target="_blank" rel="noopener">应该是没有的，但是当最下面一层变得特别大之后，Compaction的开销会很大</a>。</li><li><p>LevelDB到底是限制的每一层的文件数量还是大小？<br> 【Q】如果限制的是总大小，如果保证生成的SSTable的大小是大致相同的？<br> 对于Major Compaction来说，是在<code>DoCompactionWork</code>里面通过下面的代码来判断的，也就是说当文件大小达到一定规模后，就会产生新的文件了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">   compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">    status = FinishCompactionOutputFile(compact, input);</span><br></pre></td></tr></table></figure><p> 这个调用最后会转到<code>options-&gt;max_file_size</code>上。</p></li><li><p>LevelDB每一层的文件数量有限制么？<br> 首先Level0肯定有，大家说是4个么？我觉得不是。参考下面的代码，4只是表示有4个文件就开始Level0的Compaction。当文件数达到12个，才是上限，这个时候就要停止写了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_CompactionTrigger = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// Soft limit on number of level-0 files.  We slow down writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_SlowdownWritesTrigger = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// Maximum number of level-0 files.  We stop writes at this point.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kL0_StopWritesTrigger = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>LevelDB底层SSTable中的数据永无出头之日么？<br> 怎么可能，只要数据被修改，那么就会先到Memtable里面。</p></li><li>Compaction是如何删除文件的？<br> 注意，即使遍历到有删除标记的，并且这个删除标记的序列号最大。我们也不应该尝试删除，至少要检查下面的层有没有。详见DoCompactionWork</li></ol><h2 id="DBImpl-BackgroundCompaction-1"><a href="#DBImpl-BackgroundCompaction-1" class="headerlink" title="DBImpl::BackgroundCompaction"></a>DBImpl::BackgroundCompaction</h2><p>下面是对Major Compaction的处理。</p><h3 id="计算Compaction对象"><a href="#计算Compaction对象" class="headerlink" title="计算Compaction对象"></a>计算Compaction对象</h3><p>首先，我们要处理Manual Compaction的情况。如果<code>manual_compaction_</code>不是null，就触发Manual Compaction。我没看到非测试的代码里面有设置<code>manual_compaction_</code>的，但是<code>leveldb_compact_range</code>这个api会显示调用<code>CompactRange</code>，并且<code>DB</code>这个接口中也有<code>CompactRange</code>方法，也就是说，LevelDB对外暴露这个方法。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LEVELDB_EXPORT</span> <span class="title">DB</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CompactRange</span><span class="params">(<span class="keyword">const</span> Slice* begin, <span class="keyword">const</span> Slice* end)</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>其次，我们调用<code>PickCompaction</code>处理size compaction和seek compaction的情况。<code>PickCompaction</code>会返回当前要Compact的文件，如果返回null，就啥事都不做。对于<code>PickCompaction</code>而言，如果既没有size compaction，又没有seek compaction，返回null。</p><p><strong>这个过程是持锁的</strong><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> DBImpl::BackgroundCompaction() &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 前面是对Minor Compaction的处理</span></span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">bool</span> is_manual = (manual_compaction_ != <span class="literal">nullptr</span>);</span><br><span class="line">  InternalKey manual_end;</span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);</span><br><span class="line">    m-&gt;done = (c == <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      manual_end = c-&gt;input(<span class="number">0</span>, c-&gt;num_input_files(<span class="number">0</span>) - <span class="number">1</span>)-&gt;largest;</span><br><span class="line">    &#125;</span><br><span class="line">    Log(options_.info_log,</span><br><span class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</span><br><span class="line">        m-&gt;level, (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span class="string">"(begin)"</span>),</span><br><span class="line">        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span class="string">"(end)"</span>),</span><br><span class="line">        (m-&gt;done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    c = versions_-&gt;PickCompaction();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="根据Compaction对象进行Compact操作"><a href="#根据Compaction对象进行Compact操作" class="headerlink" title="根据Compaction对象进行Compact操作"></a>根据Compaction对象进行Compact操作</h3><p>经过上面的代码，我们就得到了一个<code>Compaction* c</code>对象。<br>如果之前<code>PickCompaction</code>没给出这个<code>c</code>，那么就说明这一次不要Compact。<br>如果满足<code>IsTrivialMove</code>条件，就可以不生成新的文件，直接将原文件移动到下一层。<br>对于Trivial的情况我们直接更新<code>c-&gt;edit()</code>，不走<code>InstallCompactionResults</code>的逻辑了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Status status;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  <span class="comment">// Nothing to do</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) &#123;</span><br><span class="line">  <span class="comment">// Move file to next level</span></span><br><span class="line">  assert(c-&gt;num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</span><br><span class="line">  FileMetaData* f = c-&gt;input(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  c-&gt;edit()-&gt;RemoveFile(c-&gt;level(), f-&gt;number);</span><br><span class="line">  c-&gt;edit()-&gt;AddFile(c-&gt;level() + <span class="number">1</span>, f-&gt;number, f-&gt;file_size, f-&gt;smallest,</span><br><span class="line">                     f-&gt;largest);</span><br><span class="line">  status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;number), c-&gt;level() + <span class="number">1</span>,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>&gt;(f-&gt;file_size),</span><br><span class="line">      status.ToString().c_str(), versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p><p>如果不满足<code>IsTrivialMove</code>条件，就是一般情况，由<code>DoCompactionWork</code>处理。<br><code>DBImpl::CompactionState</code>这个类又封装了<code>Compaction</code>，这是因为要处理两个Level之间的合并，所以要加一些额外的字段。<br>然后我们要<code>CleanupCompaction</code>，这个除了清空compact对象，还需要根据<code>compact-&gt;outputs</code>，找到<code>pending_outputs_</code>里面对应的文件，并移除出<code>pending_outputs_</code>。我们知道<code>compact-&gt;outputs</code>记录了每个输出文件的元信息，而<code>pending_outputs_</code>记录了正在compact的文件，我们compact结束，就把这些文件移出去。在Major Compaction中，文件是在<code>DoCompactionWork -&gt; OpenCompactionOutputFile</code>中被加入<code>pending_outputs_</code>的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  CompactionState* compact = <span class="keyword">new</span> CompactionState(c);</span><br><span class="line">  status = DoCompactionWork(compact);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  CleanupCompaction(compact);</span><br><span class="line">  c-&gt;ReleaseInputs();</span><br><span class="line">  RemoveObsoleteFiles();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> c;</span><br></pre></td></tr></table></figure></p><h3 id="收尾"><a href="#收尾" class="headerlink" title="收尾"></a>收尾</h3><p>如果是Manual的，需要清空Manual状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    <span class="comment">// Done</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log(options_.info_log, <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_manual) &#123;</span><br><span class="line">    ManualCompaction* m = manual_compaction_;</span><br><span class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">      m-&gt;done = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;done) &#123;</span><br><span class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></span><br><span class="line">      <span class="comment">// to the range that is left to be compacted.</span></span><br><span class="line">      m-&gt;tmp_storage = manual_end;</span><br><span class="line">      m-&gt;begin = &amp;m-&gt;tmp_storage;</span><br><span class="line">    &#125;</span><br><span class="line">    manual_compaction_ = <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Version-PickCompaction"><a href="#Version-PickCompaction" class="headerlink" title="Version::PickCompaction"></a>Version::PickCompaction</h2><p>size compaction的优先级是高于seek compaction的。<br>遍历<code>current_-&gt;compaction_level_</code>这一层的所有文件，找到第一个largest大于<code>compact_pointer_[level]</code>的文件，放到<code>Compaction* c</code>的<code>inputs_[0]</code>中。<br>如果一轮循环下来没找到，说明所有的文件的largest都小于<code>compact_pointer_[level]</code>，也就是这一层所有的key都小于<code>compact_pointer_[level]</code>，那就把第一个文件放进去。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Compaction* VersionSet::PickCompaction() &#123;</span><br><span class="line">  Compaction* c;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></span><br><span class="line">  <span class="comment">// the compactions triggered by seeks.</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="keyword">if</span> (size_compaction) &#123;</span><br><span class="line">    level = current_-&gt;compaction_level_;</span><br><span class="line">    assert(level &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(level + <span class="number">1</span> &lt; config::kNumLevels);</span><br><span class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; current_-&gt;files_[level].size(); i++) &#123;</span><br><span class="line">      FileMetaData* f = current_-&gt;files_[level][i];</span><br><span class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</span><br><span class="line">          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;inputs_[<span class="number">0</span>].push_back(f);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;inputs_[<span class="number">0</span>].empty()) &#123;</span><br><span class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;files_[level][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>对于seek compaction，把要Compact的那个文件加到<code>c-&gt;inputs_[0]</code>就行，逻辑很简单。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</span><br><span class="line">  level = current_-&gt;file_to_compact_level_;</span><br><span class="line">  c = <span class="keyword">new</span> Compaction(options_, level);</span><br><span class="line">  c-&gt;inputs_[<span class="number">0</span>].push_back(current_-&gt;file_to_compact_);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于Level0，有个特别的处理，这个参考<code>GetOverlappingInputs</code>函数的说明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;input_version_ = current_;</span><br><span class="line">c-&gt;input_version_-&gt;Ref();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></span><br><span class="line"><span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line">  <span class="comment">// Note that the next call will discard the file we placed in</span></span><br><span class="line">  <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></span><br><span class="line">  <span class="comment">// which will include the picked file.</span></span><br><span class="line">  current_-&gt;GetOverlappingInputs(<span class="number">0</span>, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  assert(!c-&gt;inputs_[<span class="number">0</span>].empty());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们已经得到了<code>c-&gt;inputs_[0]</code>。<strong>除了<code>c-&gt;inputs_[0]</code>的情况，否则<code>c-&gt;inputs_[0]</code>里面都只有一个文件</strong>。<br>通过<code>SetupOtherInputs</code>可以计算<code>c-&gt;inputs_[1]</code>，也就是level+1层涉及哪些文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  SetupOtherInputs(c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Version-SetupOtherInputs"><a href="#Version-SetupOtherInputs" class="headerlink" title="Version::SetupOtherInputs"></a>Version::SetupOtherInputs</h2><p><code>SetupOtherInputs</code>计算在Compaction时，level+1层涉及哪些文件。在这个函数之后，我们就得到了正确的<code>c-&gt;inputs_</code>数组、<code>c-&gt;grandparents_</code>字段，以及<code>compact_pointer_</code>字段。在这个函数之后，<code>PickCompaction</code>就结束了，<code>BackgroundCompaction</code>会执行后面的流程，也就是<code>DoCompactionWork</code>。<br>基本的思想是：所有和level层有重叠的level+1层文件都要参与Compact。得到这些文件后，反过来看下，利用这些level+1层的文件，能不能Compact更多level层的文件？<br>这个函数被<code>CompactRange</code>和<code>PickCompaction</code>调用，也就是所有的Major Compaction逻辑都会走到这里。</p><h3 id="GetRange和GetRange2"><a href="#GetRange和GetRange2" class="headerlink" title="GetRange和GetRange2"></a>GetRange和GetRange2</h3><p>GetRange计算<code>inputs_[0]</code>/<code>inputs_[1]</code>的区间。<br>GetRange2计算<code>inputs_[0]</code>和<code>inputs_[1]</code>的区间。<br>GetRange很简单，遍历每一个文件，然后更新smallest和largest，这里注意都需要<code>icmp_.Compare</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span><br><span class="line">                          InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  assert(!inputs.empty());</span><br><span class="line">  smallest-&gt;Clear();</span><br><span class="line">  largest-&gt;Clear();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</span><br><span class="line">    FileMetaData* f = inputs[i];</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">      *smallest = f-&gt;smallest;</span><br><span class="line">      *largest = f-&gt;largest;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;smallest, *smallest) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        *smallest = f-&gt;smallest;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (icmp_.Compare(f-&gt;largest, *largest) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        *largest = f-&gt;largest;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GetRange2很简单，就直接合并<code>inputs_[0]</code>和<code>inputs_[1]</code>的内容到一个vector里面，然后调用GetRange。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::GetRange2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span><br><span class="line">                           <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</span><br><span class="line">                           InternalKey* smallest, InternalKey* largest) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; all = inputs1;</span><br><span class="line">  all.insert(all.end(), inputs2.begin(), inputs2.end());</span><br><span class="line">  GetRange(all, smallest, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="AddBoundaryInputs"><a href="#AddBoundaryInputs" class="headerlink" title="AddBoundaryInputs"></a>AddBoundaryInputs</h3><p>AddBoundaryInputs是一个很重要的函数，但只有很少的Blog能讲明白这个函数的来龙去脉。</p><p>翻译一下<code>AddBoundaryInputs</code>这个函数的注释。他提取出<code>compaction_files</code>里面最大的文件b1，在这里是<code>c-&gt;inputs_[0]</code>里面最大的文件。<br>然后在<code>level_files</code>里面找到一个b2，满足b1和b2的user key是相等的，这样的b2称为boundary file。我们需要将这个b2加入到<code>compaction_files</code>里面，并且继续找上界。<br>如果有两个块（应该就是SSTable）b1和b2，他们的范围分别是<code>(l1, u1)</code>和<code>(l2, u2)</code>，如果我们只Compact b1，不Compact b2，那么在读取的时候就会出错。因为它只会返回b2的结果，而永远不会返回b1的结果，因为b1在b2上层了。与此同时，我们需要注意到b2的结果可能还是一个较旧的数据，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddBoundaryInputs</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator&amp; icmp,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; level_files,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;* compaction_files)</span></span></span><br></pre></td></tr></table></figure><p>【Q】看起来，这个函数做的是和<code>GetOverlappingInputs</code>一样的事情，他们的区别是什么呢？首先，<code>GetOverlappingInputs</code>的初心不是扩展边界而是计算某一层和某个range重合的文件，只是对Level0要特殊处理一下。其次，<a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">这篇文章</a>中进行了解释。</p><p>如下图所示，两个sstable中，出现了user key相同（都为key2）但是Sequence Number不同的两个Internal Key。<br><img src="/img/leveldb/compaction/AddBoundaryInputsProblem.png" alt=""></p><p>所以可以看到<code>GetOverlappingInputs</code>的特殊处理关注的是Level0上某一个要Compact的文件中的所有key是否还会出现在其他的SSTable文件中。而<code>AddBoundaryInputs</code>关注的是某个Key的其他版本是否还会出现在其他的SSTable中。</p><p>【Q】这里引发了第二个疑问，为什么同一层中会出现两个相同user key的Key呢？我觉得这个可能是因为这个Key出现在两个SSTable的边界上，所以这个函数叫<code>AddBoundaryInputs</code>吧。</p><p>仔细回顾一下<code>DoCompactionWork</code>的实现，似乎是可能没处理完一个Key，就<code>ShouldStopBefore</code>了的，但即使这样，后面的文件里面也不会再写有关这个user key的内容了。那么究竟在什么情况下会发生这种情况呢？根据<a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">这篇文章</a>中指出Snapshot机制会导致“同一层中会出现两个相同user key的Key”这个问题。</p><p>【Q】这里引发了第三个疑问，出现了两个user key，会不会影响读取呢？实际上只要位于同一层就不影响，因为根据Memtable里面的介绍，Sequence Number是从新到旧来排序的。我们的查找方式允许我们每一次都找到b1里面的值。</p><p>特别值得注意的是，这个问题关系到<a href="https://github.com/google/leveldb/issues/320" target="_blank" rel="noopener">Issue 320</a>和<a href="https://github.com/google/leveldb/pull/339" target="_blank" rel="noopener">PR 339</a>。<code>AddBoundaryInputs</code>函数也是在那个时候引进的。不过值得注意的是，这个patch在2016年就提了，但是2019年才被合进去。</p><h3 id="SetupOtherInputs主体"><a href="#SetupOtherInputs主体" class="headerlink" title="SetupOtherInputs主体"></a>SetupOtherInputs主体</h3><p>首先<code>AddBoundaryInputs</code>扩充一下<code>c-&gt;inputs_[0]</code>。<br>然后获得Level N的range。<br>然后计算Level N+1和Level N重叠的SSTable文件，并放入<code>c-&gt;inputs_[1]</code>。<br>最后，计算Level N和Level N+1合并起来的range。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> VersionSet::SetupOtherInputs(Compaction* c) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> level = c-&gt;level();</span><br><span class="line">  InternalKey smallest, largest;</span><br><span class="line"></span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  GetRange(c-&gt;inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</span><br><span class="line"></span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;smallest, &amp;largest,</span><br><span class="line">                                 &amp;c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get entire range covered by compaction</span></span><br><span class="line">  InternalKey all_start, all_limit;</span><br><span class="line">  GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br></pre></td></tr></table></figure></p><p>下面的的代码，就是之前说的优化。<br>如果<code>c-&gt;inputs_[1]</code>不为空，也就是Level N+1层有需要进行Merge的文件。我们将level中和所有和<code>[all_start,all_limit]</code>重叠的文件加到expoand0里面，并调用<code>AddBoundaryInputs</code>处理边界。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See if we can grow the number of inputs in "level" without</span></span><br><span class="line"><span class="comment">// changing the number of "level+1" files we pick up.</span></span><br><span class="line"><span class="keyword">if</span> (!c-&gt;inputs_[<span class="number">1</span>].empty()) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded0;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</span><br><span class="line">  AddBoundaryInputs(icmp_, current_-&gt;files_[level], &amp;expanded0);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs0_size = TotalFileSize(c-&gt;inputs_[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> inputs1_size = TotalFileSize(c-&gt;inputs_[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int64_t</span> expanded0_size = TotalFileSize(expanded0);</span><br><span class="line">  <span class="keyword">if</span> (expanded0.size() &gt; c-&gt;inputs_[<span class="number">0</span>].size() &amp;&amp;</span><br><span class="line">      inputs1_size + expanded0_size &lt;</span><br><span class="line">          ExpandedCompactionByteSizeLimit(options_)) &#123;</span><br><span class="line">    InternalKey new_start, new_limit;</span><br><span class="line">    GetRange(expanded0, &amp;new_start, &amp;new_limit);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; expanded1;</span><br><span class="line">    current_-&gt;GetOverlappingInputs(level + <span class="number">1</span>, &amp;new_start, &amp;new_limit,</span><br><span class="line">                                   &amp;expanded1);</span><br><span class="line">    <span class="keyword">if</span> (expanded1.size() == c-&gt;inputs_[<span class="number">1</span>].size()) &#123;</span><br><span class="line">      Log(options_-&gt;info_log,</span><br><span class="line">          <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</span><br><span class="line">          level, <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">0</span>].size()), <span class="keyword">int</span>(c-&gt;inputs_[<span class="number">1</span>].size()),</span><br><span class="line">          <span class="keyword">long</span>(inputs0_size), <span class="keyword">long</span>(inputs1_size), <span class="keyword">int</span>(expanded0.size()),</span><br><span class="line">          <span class="keyword">int</span>(expanded1.size()), <span class="keyword">long</span>(expanded0_size), <span class="keyword">long</span>(inputs1_size));</span><br><span class="line">      smallest = new_start;</span><br><span class="line">      largest = new_limit;</span><br><span class="line">      c-&gt;inputs_[<span class="number">0</span>] = expanded0;</span><br><span class="line">      c-&gt;inputs_[<span class="number">1</span>] = expanded1;</span><br><span class="line">      GetRange2(c-&gt;inputs_[<span class="number">0</span>], c-&gt;inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面，设置一下<code>c-&gt;grandparents_</code>这个字段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the set of grandparent files that overlap this compaction</span></span><br><span class="line"><span class="comment">// (parent == level+1; grandparent == level+2)</span></span><br><span class="line"><span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</span><br><span class="line">  current_-&gt;GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</span><br><span class="line">                                 &amp;c-&gt;grandparents_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>记录下一轮的压缩起始文件，也就是设置<code>compact_pointer_</code>。我们在这里立即更新，而不是等到VersionEdit被Apply的时候更新，这样当Compaction失败后，我们能下次能尝试一个不同的key range。</p><ol><li>【Q】什么是压缩起始文件？<br> 查看<code>PickCompaction</code>函数，它会找到largest大于<code>compact_pointer_[level]</code>后的第一个文件。<br> 可以发现，其实每一次要Compaction的文件就是通过<code>compact_pointer_</code>指定的。</li><li>【Q】在这之后，Compaction会因为什么失败？</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></span><br><span class="line">  compact_pointer_[level] = largest.Encode().ToString();</span><br><span class="line">  c-&gt;edit_.SetCompactPointer(level, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DBImpl-CompactionState"><a href="#DBImpl-CompactionState" class="headerlink" title="DBImpl::CompactionState"></a>DBImpl::CompactionState</h2><ol><li><code>SequenceNumber smallest_snapshot;</code><br> 小于<code>smallest_snapshot</code>的Sequence Number是不重要的，因为我们不会为提供<code>smallest_snapshot</code>的snapshot。<br> 所以，如果我们看到Sequence Number小于等于<code>smallest_snapshot</code>的某个<code>S</code>，就可以丢弃小于<code>S</code>的这个key的其他版本。<br> 【Q】这里是不是在说，如果只有S这个独苗，那还是要写进去的？</li><li><code>std::vector&lt;Output&gt; outputs;</code></li><li><code>Output* current_output() { return &amp;outputs[outputs.size() - 1]; }</code><br> 保存每个输出文件的元信息。例如smallest和largest。</li><li><code>WritableFile* outfile;</code><br> Major Compaction过程中，需要输出到level+1层的文件。注意，可能有多个这样的文件，参考<code>ShouldStopBefore</code>。</li><li><code>TableBuilder* builder;</code></li><li><code>uint64_t total_bytes;</code></li></ol><h2 id="DBImpl-DoCompactionWork"><a href="#DBImpl-DoCompactionWork" class="headerlink" title="DBImpl::DoCompactionWork"></a>DBImpl::DoCompactionWork</h2><p>这个对应了一般情况下的Compact过程，来自<code>BackgroundCompaction</code>的调用。<br>那么这个函数做啥呢，不就是个归并排序么？且慢，我们如何处理同一个user key有不同Sequence Number呢？我们的目标肯定是只保留最新的。<br>其中<code>CompactionState</code>封装了<code>Compaction</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Status DBImpl::DoCompactionWork(CompactionState* compact) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> start_micros = env_-&gt;NowMicros();</span><br><span class="line">  <span class="keyword">int64_t</span> imm_micros = <span class="number">0</span>;  <span class="comment">// Micros spent doing imm_ compactions</span></span><br><span class="line"></span><br><span class="line">  Log(options_.info_log, <span class="string">"Compacting %d@%d + %d@%d files"</span>,</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">0</span>), compact-&gt;compaction-&gt;level(),</span><br><span class="line">      compact-&gt;compaction-&gt;num_input_files(<span class="number">1</span>),</span><br><span class="line">      compact-&gt;compaction-&gt;level() + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>这里要assert一下，即要压缩的Level N层是要有文件的。<br>【Q】这个Snapshot啥回事？<br>根据<a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">文章</a>，如果有Snapshot，则保留大于Snapshot SN的所有Record，以及一个小于Snapshot SN的Record中，SN最大的Record。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; <span class="number">0</span>);</span><br><span class="line">assert(compact-&gt;builder == <span class="literal">nullptr</span>);</span><br><span class="line">assert(compact-&gt;outfile == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (snapshots_.empty()) &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;sequence_number();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们执行<code>MakeInputIterator</code>，得到的迭代器可以按照key大小遍历所有冲突文件中的每个KV对。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release mutex while we're actually doing the compaction work</span></span><br><span class="line">mutex_.Unlock();</span><br><span class="line"></span><br><span class="line">input-&gt;SeekToFirst();</span><br><span class="line">Status status;</span><br><span class="line">ParsedInternalKey ikey;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> current_user_key;</span><br><span class="line"><span class="keyword">bool</span> has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">SequenceNumber last_sequence_for_key = kMaxSequenceNumber;</span><br></pre></td></tr></table></figure></p><p>下面这个while循环遍历刚才得到的迭代器<code>input</code>，进行Major Compaction。<br>但是，且慢，每一次我们都需要先检查有没有Immatable Memtable，如果有的话，就需要先执行Minor Compaction。<strong>这也说明了Minor Compaction的优先级更高</strong>。<br>【Q】我们看到了两个原子量的获取：</p><ol><li><code>shutting_down_</code>，采用了Release-Acquire内存模型，保证了一定的并行顺序。<br> 如果线程A Release Store，线程B Acquire Load，那么<a href="https://sf-zhou.github.io/leveldb/leveldb_10_details.html" target="_blank" rel="noopener">线程A中所有在Release前的(atomic或者非atomic)写</a>，对线程B都可见。</li><li><code>memory_order_relaxed</code>，采用了Relaxed内存模型。<br> 只保证读写的原子性，不保证并发时和其他变量的顺序。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  <span class="comment">// Prioritize immutable compaction work</span></span><br><span class="line">  <span class="keyword">if</span> (has_imm_.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> imm_start = env_-&gt;NowMicros();</span><br><span class="line">    mutex_.Lock();</span><br><span class="line">    <span class="keyword">if</span> (imm_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      CompactMemTable();</span><br><span class="line">      <span class="comment">// Wake up MakeRoomForWrite() if necessary.</span></span><br><span class="line">      background_work_finished_signal_.SignalAll();</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_.Unlock();</span><br><span class="line">    imm_micros += (env_-&gt;NowMicros() - imm_start);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>检查当前输出文件(应当位于level+1层)是否与level+2层文件有过多冲突，如果是就要完成当前输出文件，并产生新的输出文件。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Slice key = input-&gt;key();</span><br><span class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</span><br><span class="line">    compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面就是判断是不是能<code>drop</code>，也就是和前面计算的<code>compact-&gt;smallest_snapshot</code>比较。<br>正常情况下<code>ParseInternalKey</code>不会失败，我们跳过这个分支<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle key/value, add to state, etc.</span></span><br><span class="line"><span class="keyword">bool</span> drop = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!ParseInternalKey(key, &amp;ikey)) &#123;</span><br><span class="line">  <span class="comment">// Do not hide error keys</span></span><br><span class="line">  current_user_key.clear();</span><br><span class="line">  has_current_user_key = <span class="literal">false</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure></p><p>下面这个if，判断的是<code>current_user_key</code>第一次出现的情况，包括处理完上一个user key，到达下一个user key，或者刚开始处理第一个user key的情况。我们设置<code>last_sequence_for_key</code>为最大，那么就永远不会触发drop。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!has_current_user_key ||</span><br><span class="line">    user_comparator()-&gt;Compare(ikey.user_key, Slice(current_user_key)) !=</span><br><span class="line">        <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// First occurrence of this user key</span></span><br><span class="line">  current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());</span><br><span class="line">  has_current_user_key = <span class="literal">true</span>;</span><br><span class="line">  last_sequence_for_key = kMaxSequenceNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面我们比较Sequence Number，如果<code>last_sequence_for_key</code>都小于<code>compact-&gt;smallest_snapshot</code>了，那么我这个key肯定更小，这是因为<a href="/2021/04/09/leveldb-memtable/">Sequence Number是按照降序排列的</a>。对于这种情况，我们省点事，直接不要了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</span><br><span class="line">  <span class="comment">// Hidden by an newer entry for same user key</span></span><br><span class="line">  drop = <span class="literal">true</span>;  <span class="comment">// (A)</span></span><br></pre></td></tr></table></figure></p><p>下一个判断复杂点，表示对于特定情况下，一个删除操作也是可以丢掉的。<br><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">如果某个删除操作的版本小于快照版本，并且在更高层没有相同的user key，那么这个删除操作及其之前更早的插入操作可以同时丢弃了</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</span><br><span class="line">             ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</span><br><span class="line">             compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</span><br><span class="line">    <span class="comment">// For this user key:</span></span><br><span class="line">    <span class="comment">// (1) there is no data in higher levels</span></span><br><span class="line">    <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></span><br><span class="line">    <span class="comment">// (3) data in layers that are being compacted here and have</span></span><br><span class="line">    <span class="comment">//     smaller sequence numbers will be dropped in the next</span></span><br><span class="line">    <span class="comment">//     few iterations of this loop (by rule (A) above).</span></span><br><span class="line">    <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></span><br><span class="line">    drop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  last_sequence_for_key = ikey.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果drop条件不符合，那么就写入到<code>compact-&gt;current_output()</code>里面，同时更新largest。<br>同时我们关注文件大小，如果超限了，就FinishCompactionOutputFile。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">    <span class="comment">// Open output file if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      status = OpenCompactionOutputFile(compact);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;NumEntries() == <span class="number">0</span>) &#123;</span><br><span class="line">      compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);</span><br><span class="line">    &#125;</span><br><span class="line">    compact-&gt;current_output()-&gt;largest.DecodeFrom(key);</span><br><span class="line">    compact-&gt;builder-&gt;Add(key, input-&gt;value());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close output file if it is big enough</span></span><br><span class="line">    <span class="keyword">if</span> (compact-&gt;builder-&gt;FileSize() &gt;=</span><br><span class="line">        compact-&gt;compaction-&gt;MaxOutputFileSize()) &#123;</span><br><span class="line">      status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  input-&gt;Next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>截至现在，我们已经遍历完迭代器了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; shutting_down_.load(<span class="built_in">std</span>::memory_order_acquire)) &#123;</span><br><span class="line">  status = Status::IOError(<span class="string">"Deleting DB during compaction"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok() &amp;&amp; compact-&gt;builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  status = FinishCompactionOutputFile(compact, input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">  status = input-&gt;status();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> input;</span><br><span class="line">input = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></p><p>更新状态<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CompactionStats stats;</span><br><span class="line">stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) &#123;</span><br><span class="line">    stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; compact-&gt;outputs.size(); i++) &#123;</span><br><span class="line">  stats.bytes_written += compact-&gt;outputs[i].file_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面，我们加锁。所以其实在遍历<code>input</code>这个迭代器的时候，是没有在加锁的。<br><code>InstallCompactionResults</code>是一个关键过程，它将这次Compaction的内容加入到VersionEdit里面，并且最终调用<code>LogAndApply</code>。内容包括什么呢？增加和删除的文件：</p><ol><li><code>InstallCompactionResults</code>会调用<code>Compaction::AddInputDeletions</code>，需要删除的文件，包括<code>input_[0]</code>和<code>input_[1]</code></li><li>向<code>compact-&gt;compaction-&gt;edit()</code>中添加<code>compact-&gt;outputs</code>中的所有文件</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  mutex_.Lock();</span><br><span class="line">  stats_[compact-&gt;compaction-&gt;level() + <span class="number">1</span>].Add(stats);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">    status = InstallCompactionResults(compact);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</span><br><span class="line">    RecordBackgroundError(status);</span><br><span class="line">  &#125;</span><br><span class="line">  VersionSet::LevelSummaryStorage tmp;</span><br><span class="line">  Log(options_.info_log, <span class="string">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/34674504" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34674504</a></li><li><a href="https://blog.csdn.net/tmshasha/article/details/47703245" target="_blank" rel="noopener">https://blog.csdn.net/tmshasha/article/details/47703245</a></li><li><a href="https://zhuanlan.zhihu.com/p/51573929" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/51573929</a></li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/basic.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/basic.html</a></li><li><a href="https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/" target="_blank" rel="noopener">https://blog.lovezhy.cc/2020/08/17/LevelDB%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89-%20CURRENT%E5%92%8CManifest/</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a></li><li><a href="http://blog.jcix.top/2018-05-11/leveldb_paths/" target="_blank" rel="noopener">http://blog.jcix.top/2018-05-11/leveldb_paths/</a></li><li><a href="http://bean-li.github.io/leveldb-version/" target="_blank" rel="noopener">http://bean-li.github.io/leveldb-version/</a></li><li><a href="https://zhuanlan.zhihu.com/p/46718964" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/46718964</a></li><li><a href="http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html" target="_blank" rel="noopener">http://www.hootina.org/blog/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9019.html</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_08_complete_process.html</a><br> 这是一个DB完整执行过程的表述。</li><li><a href="https://www.ravenxrz.ink/archives/1ba074b9.html" target="_blank" rel="noopener">https://www.ravenxrz.ink/archives/1ba074b9.html</a><br> 介绍了Snapshot</li><li><a href="https://izualzhy.cn/leveldb-PickCompaction" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-PickCompaction</a><br> 解释了GetOverlappingInputs的原理</li><li><a href="https://izualzhy.cn/leveldb-version" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-version</a><br> 解释了Version的实现</li><li><a href="http://lerencao.github.io/posts/lsm-tree-compaction-strategy/" target="_blank" rel="noopener">http://lerencao.github.io/posts/lsm-tree-compaction-strategy/</a></li><li><a href="http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/" target="_blank" rel="noopener">http://www.scylladb.com/2018/01/17/compaction-series-space-amplification/</a><br> 上面两篇文章介绍STCS和LCS</li><li><a href="https://zhuanlan.zhihu.com/p/181498475" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181498475</a><br> 图解Compact过程</li><li><a href="https://github.com/facebook/rocksdb/wiki/Compaction" target="_blank" rel="noopener">https://github.com/facebook/rocksdb/wiki/Compaction</a><br> RocksDB对Compaction的讲解</li><li><a href="https://blog.csdn.net/weixin_36145588/article/details/78064777" target="_blank" rel="noopener">https://blog.csdn.net/weixin_36145588/article/details/78064777</a></li><li><a href="https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html" target="_blank" rel="noopener">https://sf-zhou.github.io/leveldb/leveldb_09_compaction.html</a><br> 这位同学解释了AddBoundaryInputs的来源</li><li><a href="http://www.petermao.com/leveldb/leveldb-8-snapshot.html" target="_blank" rel="noopener">http://www.petermao.com/leveldb/leveldb-8-snapshot.html</a><br> 介绍了snapshot机制</li><li><a href="https://zhuanlan.zhihu.com/p/60188395" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/60188395</a><br> 带Snapshot的Compaction，以及为什么会导致Issue 320的问题</li><li><a href="https://zhuanlan.zhihu.com/p/360345923" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/360345923</a><br> 也讲解了AddBoundaryInputs的来源，并且指出了快照会导致Issue 320的问题。</li><li><a href="https://zhuanlan.zhihu.com/p/35343043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35343043</a><br> 讲解VersionSet/VersionEdit里面出现的各种文件编号</li><li><a href="https://leveldb-handbook.readthedocs.io/zh/latest/version.html" target="_blank" rel="noopener">https://leveldb-handbook.readthedocs.io/zh/latest/version.html</a><br> 版本控制相关</li><li><a href="https://bean-li.github.io/leveldb-manifest/" target="_blank" rel="noopener">https://bean-li.github.io/leveldb-manifest/</a><br> 有关Manifest文件的深入讨论</li><li><a href="http://1feng.github.io/2016/08/24/mvcc-and-manifest/" target="_blank" rel="noopener">http://1feng.github.io/2016/08/24/mvcc-and-manifest/</a><br> 介绍MVCC机制，很好</li><li><a href="https://draveness.me/database-concurrency-control/" target="_blank" rel="noopener">https://draveness.me/database-concurrency-control/</a><br> 同样介绍了MVCC，包括乐观锁和悲观锁机制</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍LevelDB的SSTable之间的Compaction。Compaction分两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Minor Compaction&lt;br&gt; 对应Memtable到SSTable的过程。&lt;/li&gt;
&lt;li&gt;Major Compaction&lt;br&gt; 对应SSTable文件之间的归并。涉及到两个Level的SSTable文件。&lt;br&gt; Major Compaction中还可以细分，比如是否Manual等。对于非Manual，还有seek compaction和size compaction。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在本文中，还会介绍Version和VersionEdit概念，它们有助于理解LevelDB对MVCC的实现。&lt;/p&gt;
&lt;p&gt;同样的，文章中的【Q】表示我在阅读源码的过程中产生的疑问，有的我找到的解答，或者自己产生了思考，有的则未必清楚。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之SSTable实现</title>
    <link href="http://www.calvinneo.com/2021/04/12/leveldb-sstable/"/>
    <id>http://www.calvinneo.com/2021/04/12/leveldb-sstable/</id>
    <published>2021-04-12T15:09:06.000Z</published>
    <updated>2021-04-14T09:43:55.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍LevelDB的SSTable相关功能。<br>SSTable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。Level0的SSTable是没有经过归并的，各个Key可能互相重叠。经过Compaction达到Level1之后，就是有序的了。</p><a id="more"></a><h1 id="SSTable格式"><a href="#SSTable格式" class="headerlink" title="SSTable格式"></a>SSTable格式</h1><p>SSTable体现在后缀为.sst或者.ldb的文件。<br>其实在<a href="https://github.com/google/leveldb/blob/master/doc/table_format.md" target="_blank" rel="noopener">官方文档</a>中，对SSTable的格式已经有了介绍。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">beginning_of_file&gt;</span></span><br><span class="line"><span class="keyword">[data </span><span class="keyword">block </span><span class="number">1</span>]</span><br><span class="line">[<span class="meta">data</span> <span class="keyword">block </span><span class="number">2</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">[<span class="meta">data</span> <span class="keyword">block </span>N]</span><br><span class="line">[meta <span class="keyword">block </span><span class="number">1</span>]</span><br><span class="line"><span class="symbol">...</span></span><br><span class="line">[meta <span class="keyword">block </span>K]</span><br><span class="line">[metaindex <span class="keyword">block]</span></span><br><span class="line"><span class="keyword">[index </span><span class="keyword">block]</span></span><br><span class="line"><span class="keyword">[Footer] </span>       (fixed size<span class="comment">; starts at file_size - sizeof(Footer))</span></span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure></p><ol><li>data block<br> 放KV对，是有序的（doc里面说的）。因此在查询SSTable文件的时候，也可以二分。【待确认】<br> 关于Block的组织，我们将专门讨论。</li><li>meta block<br> 用来快速定位key是否在data block中</li><li><p>metaindex block<br> 每个metaindex block一条记录。其中K是meta block的名字，V是指向这个meta block的BlockHandle。<br> BlockHandle类似于指针，具有下面的结构。容易看到，这里面也用了VarInt结构。</p> <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">offset:</span>   varint64</span><br><span class="line"><span class="symbol">size:</span>     varint64</span><br></pre></td></tr></table></figure><p> 有两种meta block类型，filter和stats:</p><ol><li>如果在数据库启动时指定了某个<code>FilterPolicy</code>，就会创建一个filter block。</li><li>统计信息</li></ol></li><li>index block<br> 每个data block一条entry。这个index block entry的<code>.key()</code><strong>大于等于</strong>指向的data block最后一个K【性质1】，但是<strong>严格小于</strong>下一个data block的第一个K【性质2】。<br> 因此，我们可以通过和index block比较来快速定位data block。</li><li>footer<br> 包含：<ol><li>metaindex handle</li><li>index handle</li><li>padding</li><li>magic number</li></ol></li></ol><h1 id="Block实现"><a href="#Block实现" class="headerlink" title="Block实现"></a>Block实现</h1><p>SST的构建主要集中在<code>table_builder.h/cc</code>和<code>block_builder.h/cc</code>中。<br>SST的读取主要集中在<code>table.h/cc</code>和<code>block.h/cc</code>中。<br>从前面可以看到，SSTable主要有两层结构，Table(SSTable)和Block(data/index等)。<br>Table由多个Block构成，所以从Block开始分析。</p><h2 id="BlockBuilder-Block原理"><a href="#BlockBuilder-Block原理" class="headerlink" title="BlockBuilder/Block原理"></a>BlockBuilder/Block原理</h2><p>BlockBuilder负责生成诸如data block、index block等所有block。<br>Block对象负责读取这些block。</p><h3 id="共享前缀"><a href="#共享前缀" class="headerlink" title="共享前缀"></a>共享前缀</h3><p>因为BlockBuilder是有序的，所以可以使用共享前缀来节约空间，我们比较下面两种方式：</p><ol><li><p>普通</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">Hello William</span></span><br></pre></td></tr></table></figure></li><li><p>共享</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Hello World</span></span><br><span class="line"><span class="attribute">       illiam</span></span><br></pre></td></tr></table></figure></li></ol><p>Block的构造如下图所示<br><img src="/img/leveldb/sstable/suf.png" alt=""></p><p>其中：</p><ol><li>shared_bytes<br> Key的共享前缀的长度，这里的共享指的是上一个entry</li><li>key_delta/unshared_bytes<br> Key共享前缀后的剩余串和其长度</li><li>value/value_length<br> 值的串和其长度</li></ol><p>那么如何读呢？</p><ol><li><p>最坏状况，我们需要读到第一个Entry，考虑下面的Key</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">ab</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li><li><p>最好状况，我们读当前的就行</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">b</span><br></pre></td></tr></table></figure></li></ol><h3 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h3><p>可见共享前缀会给读带来困难，因此又引入restart机制，即每隔<code>block_restart_interval</code>之后会去存储一次完整的key，对应的entry的位置称为restart point。在block中，会存储下所有的restart point。<br>因为数字存储是有序的，所以我们能通过二分restart point来加速读取，具体代码在<code>Block::Iter</code>中。读取需求一般是给定target，要求找到第一个K大于等于target的entry。因此我们可以得到如下二分</p><ol><li><code>mid &lt; target</code><br> 则搜索<code>[mid, right]</code></li><li><code>mid &gt;= target</code><br> 搜索<code>[left, mid-1]</code><br>因为这是一个TTT…F/T的二分，所以我们要令<code>mid = (left + right + 1)/2</code></li></ol><h3 id="filter-block"><a href="#filter-block" class="headerlink" title="filter block"></a>filter block</h3><p>在每个data block内部，借助于二分restart可以实现$log(n)$复杂度的查询，那么能在data block之间二分么？</p><p>可以通过filter block来判断某个key是否属于该data block，实现是bloom filter。</p><h2 id="BlockBuilder实现"><a href="#BlockBuilder实现" class="headerlink" title="BlockBuilder实现"></a>BlockBuilder实现</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li><code>void Add(const Slice&amp; key, const Slice&amp; value);</code><br> 每一次Add的Key，必须是有序的，从小到大的。</li><li><code>Slice Finish();</code></li><li><code>void Reset();</code></li></ol><h3 id="BlockBuilder-Add"><a href="#BlockBuilder-Add" class="headerlink" title="BlockBuilder::Add"></a>BlockBuilder::Add</h3><p>首先是三个assert：</p><ol><li>第一个很好理解，如果<code>finished_</code>，相当于已经调用了Finish或者Abandon等方法。</li><li><code>block_restart_interval</code>表示每过多少个key就要设置一个restarts。设置完之后，<code>counter_</code>会被重置为0，所以这个不等式是成立的。</li><li>最后一个是有序性检验，要不是空的，要不新来的<code>key</code>要大于老的<code>last_key_piece</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> BlockBuilder::Add(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  <span class="function">Slice <span class="title">last_key_piece</span><span class="params">(last_key_)</span></span>;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= options_-&gt;block_restart_interval);</span><br><span class="line">  assert(buffer_.empty()  <span class="comment">// No values yet?</span></span><br><span class="line">         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li></ol><p>下面判断要不要restart：</p><ol><li>如果不要，和前一个key即<code>last_key_</code>比较，算出来能share多少长度。</li><li>如果要，就restart。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</span><br><span class="line">  <span class="comment">// See how much sharing to do with previous string</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_length = <span class="built_in">std</span>::min(last_key_piece.size(), key.size());</span><br><span class="line">  <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) &#123;</span><br><span class="line">    shared++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Restart compression</span></span><br><span class="line">  restarts_.push_back(buffer_.size());</span><br><span class="line">  counter_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</span><br></pre></td></tr></table></figure></li></ol><p>下面就是往<code>buffer_</code>里面写数据了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></span><br><span class="line">PutVarint32(&amp;buffer_, shared);</span><br><span class="line">PutVarint32(&amp;buffer_, non_shared);</span><br><span class="line">PutVarint32(&amp;buffer_, value.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add string delta to buffer_ followed by value</span></span><br><span class="line">buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">buffer_.append(value.data(), value.size());</span><br></pre></td></tr></table></figure></p><p>下面这个优化点也很有趣，首先<code>last_key_</code>保存的是一个完整的key。但是我们可以复用之前一个key的shared部分，这个是安全的。接着我们把non shared部分append上去。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Update state</span></span><br><span class="line">  last_key_.resize(shared);</span><br><span class="line">  last_key_.append(key.data() + shared, non_shared);</span><br><span class="line">  assert(Slice(last_key_) == key);</span><br><span class="line">  counter_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="BlockBuilder-Finish"><a href="#BlockBuilder-Finish" class="headerlink" title="BlockBuilder::Finish"></a>BlockBuilder::Finish</h3><p>为啥<code>restarts_</code>不用VarInt存呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Slice BlockBuilder::Finish() &#123;</span><br><span class="line">  <span class="comment">// Append restart array</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  PutFixed32(&amp;buffer_, restarts_.size());</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Slice(buffer_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Block实现-1"><a href="#Block实现-1" class="headerlink" title="Block实现"></a>Block实现</h2><ol><li><p><code>uint32_t NumRestarts() const;</code><br> 之前了解过block的结构，在Block的最后，是restart点的个数。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> Block::NumRestarts() <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(size_ &gt;= <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">  <span class="keyword">return</span> DecodeFixed32(data_ + size_ - <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>const char* data_;</code>/<code>size_t size_</code>;<br> 也就是这个Block的指针和长度。</p></li><li><p><code>uint32_t restart_offset_;</code><br> 表示restart的开始位置</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>bool owned_;</code><br> 取决于构造函数传入的<code>BlockContents</code>的<code>owned_</code>字段。</p></li></ol><h3 id="Block-Iter"><a href="#Block-Iter" class="headerlink" title="Block::Iter"></a>Block::Iter</h3><h4 id="Seek"><a href="#Seek" class="headerlink" title="Seek"></a>Seek</h4><p>这个函数是一个二分的实现。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> override </span>&#123;</span><br><span class="line">  <span class="comment">// Binary search in restart array to find the last restart point</span></span><br><span class="line">  <span class="comment">// with a key &lt; target</span></span><br><span class="line">  <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> current_key_compare = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (Valid()) &#123;</span><br><span class="line">    <span class="comment">// If we're already scanning, use the current position as a starting</span></span><br><span class="line">    <span class="comment">// point. This is beneficial if the key we're seeking to is ahead of the</span></span><br><span class="line">    <span class="comment">// current position.</span></span><br><span class="line">    current_key_compare = Compare(key_, target);</span><br><span class="line">    <span class="keyword">if</span> (current_key_compare &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// key_ is smaller than target</span></span><br><span class="line">      left = restart_index_;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current_key_compare &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      right = restart_index_;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// We're seeking to the key we're already at.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> region_offset = GetRestartPoint(mid);</span><br><span class="line">    <span class="keyword">uint32_t</span> shared, non_shared, value_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr =</span><br><span class="line">        DecodeEntry(data_ + region_offset, data_ + restarts_, &amp;shared,</span><br><span class="line">                    &amp;non_shared, &amp;value_length);</span><br><span class="line">    <span class="keyword">if</span> (key_ptr == <span class="literal">nullptr</span> || (shared != <span class="number">0</span>)) &#123;</span><br><span class="line">      CorruptionError();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (Compare(mid_key, target) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Key at "mid" is smaller than "target".  Therefore all</span></span><br><span class="line">      <span class="comment">// blocks before "mid" are uninteresting.</span></span><br><span class="line">      left = mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Key at "mid" is &gt;= "target".  Therefore all blocks at or</span></span><br><span class="line">      <span class="comment">// after "mid" are uninteresting.</span></span><br><span class="line">      right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We might be able to use our current position within the restart block.</span></span><br><span class="line">  <span class="comment">// This is true if we determined the key we desire is in the current block</span></span><br><span class="line">  <span class="comment">// and is after than the current key.</span></span><br><span class="line">  assert(current_key_compare == <span class="number">0</span> || Valid());</span><br><span class="line">  <span class="keyword">bool</span> skip_seek = left == restart_index_ &amp;&amp; current_key_compare &lt; <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!skip_seek) &#123;</span><br><span class="line">    SeekToRestartPoint(left);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ParseNextKey()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Compare(key_, target) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Table实现"><a href="#Table实现" class="headerlink" title="Table实现"></a>Table实现</h1><h2 id="TableBuilder"><a href="#TableBuilder" class="headerlink" title="TableBuilder"></a>TableBuilder</h2><p>对于Add/Flush/Finish/Abandon，此时Adandon和Finish不能已经被调用。</p><ol><li><code>Status ChangeOptions(const Options&amp; options);</code><br> 修改option，但是只有某些可以在构建之后被修改。对于那些不能修改的，会报错。</li><li><code>void Add(const Slice&amp; key, const Slice&amp; value);</code><br> 增加一个KV对。<br> key is after any previously added key according to comparator，往TableBuilder里面加KV，必须是有序的？</li><li><code>void Flush();</code><br> 刷盘，一般不直接用。主要被用来保证两个相邻的Entry不会在同一个data block中。</li><li><code>Status status() const;</code></li><li><code>Status Finish();</code><br> 结束当前表的构建。</li><li><code>void Abandon();</code><br> 表示需要丢弃当前缓存内容，并且结束表的构建。</li><li><code>uint64_t NumEntries() const;</code><br> Add了多少次，实际上返回的是<code>TableBuilder::Rep</code>里面的<code>num_entries</code></li><li><code>uint64_t FileSize() const;</code></li><li><code>void WriteBlock(BlockBuilder* block, BlockHandle* handle);</code></li><li><code>void WriteRawBlock(const Slice&amp; data, CompressionType, BlockHandle* handle);</code></li></ol><p>此外，TableBuilder持有一个Req类型的对象指针，用来隐藏相关实现。</p><h2 id="TableBuilder-Rep"><a href="#TableBuilder-Rep" class="headerlink" title="TableBuilder::Rep"></a>TableBuilder::Rep</h2><p>具有下面的：</p><ol><li><code>Options options;</code></li><li><code>Options index_block_options;</code></li><li><code>WritableFile* file;</code><br> <code>WritableFile</code>是一个接口，具体实现可以分为随机读写文件，顺序读写文件等。</li><li><code>uint64_t offset;</code></li><li><code>Status status;</code><br> 是<code>ok()</code>的返回值，表示是否发生了错误。一般，错误会在<code>file</code>里面的Append和Flush方法中出现。</li><li><code>BlockBuilder data_block;</code></li><li><code>BlockBuilder index_block;</code></li><li><code>std::string last_key;</code><br> 每一次Add会更新这个字段。因为Add是有序的，所以实际上就表示了当前最大的key。</li><li><code>int64_t num_entries;</code><br> 见<code>NumEntries</code>。</li><li><code>bool closed;</code><br> Finish和Abandon会设置为true。</li><li><code>FilterBlockBuilder* filter_block;</code></li><li><code>bool pending_index_entry;</code><br> 当写完一个data block之后，设置<code>pending_index_entry</code>，表示需要更新index block。<br> 因此这里有个不变量，当且仅当<code>data_block</code>为空的时候<code>pending_index_entry</code>才是true。也就是说当写入一个data block后（注意一个table中有多个data block），设置<code>pending_index_entry</code>为true，之后更新index block。<br> 原因是直到我们见到下一个data block的第一个key的时候才能写index。这样我们可以在写index的时候用尽可能短的key。例如我们已经知道第一个data block中最大的是”the quick brown fox”，而第二个data block中最小的是”the who”。这样通过之前提到的<code>FindShortestSeparator</code>，我们就可以用”the r”作为index block中的entry。这个entry满足条件，即大于等于第一个block中的所有key，并且小于第二个block中的所有key。<br> 因此，顺序是：<ol><li>写一个data block</li><li>接到下一个Add请求</li><li>根据<code>last_key</code>和当前传入的Key，写index</li><li>正常处理该Add请求</li></ol></li><li><code>BlockHandle pending_handle;</code><br> Handle to add to index block。不是说用这个handle来写index block，而是会把这个handle里面的值写到index block里面作为index。</li><li><code>std::string compressed_output;</code></li></ol><h3 id="TableBuilder-Add"><a href="#TableBuilder-Add" class="headerlink" title="TableBuilder::Add"></a>TableBuilder::Add</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::Add(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;num_entries &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果<code>pending_index_entry</code>是true，说明之前已经写入了一个data block。于是我们就要插入index，并且清空<code>pending_index_entry</code>标志。这一部分原理在<code>pending_index_entry</code>讲解过了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">  assert(r-&gt;data_block.empty());</span><br><span class="line">  r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">  r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">  r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">  r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是添加的逻辑，先处理filter block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  r-&gt;filter_block-&gt;AddKey(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后设置<code>last_key</code>，并向当前的data block中添加KV。<br>估算当前data block的大小，如果超过配置的阈值<code>options.block_size</code>就进行dump。这个估算实际上就是统计所有entry以及restart的总大小。相比<a href="/2019/08/06/spark-sql/">Spark里面的</a>大小估计，感觉LevelDB/Redis里面的大小估计要简单很多，感觉得益于C/C++能自己管理内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line">  r-&gt;num_entries++;</span><br><span class="line">  r-&gt;data_block.Add(key, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();</span><br><span class="line">  <span class="keyword">if</span> (estimated_block_size &gt;= r-&gt;options.block_size) &#123;</span><br><span class="line">    Flush();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TableBuilder-WriteBlock"><a href="#TableBuilder-WriteBlock" class="headerlink" title="TableBuilder::WriteBlock"></a>TableBuilder::WriteBlock</h3><h4 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h4><p>Table要写某个Block，首先Finish这个block，也就是说把所有restart都写到文件里面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) &#123;</span><br><span class="line">  assert(ok());</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Slice raw = block-&gt;Finish();</span><br></pre></td></tr></table></figure></p><p>接着，是写data block。实际写入的<code>block_contents</code>可能是被压缩了的，也可能是没有被压缩的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Slice block_contents;</span><br><span class="line">CompressionType type = r-&gt;options.compression;</span><br><span class="line"><span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></span><br><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">  <span class="keyword">case</span> kNoCompression:</span><br><span class="line">    block_contents = raw;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> kSnappyCompression: &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* compressed = &amp;r-&gt;compressed_output;</span><br><span class="line">    <span class="keyword">if</span> (port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;</span><br><span class="line">        compressed-&gt;size() &lt; raw.size() - (raw.size() / <span class="number">8u</span>)) &#123;</span><br><span class="line">      block_contents = *compressed;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></span><br><span class="line">      <span class="comment">// store uncompressed form</span></span><br><span class="line">      block_contents = raw;</span><br><span class="line">      type = kNoCompression;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">WriteRawBlock(block_contents, type, handle);</span><br><span class="line">r-&gt;compressed_output.clear();</span><br></pre></td></tr></table></figure></p><p>清空这个block里面<code>buffer_</code>、<code>restarts_</code>等状态。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  block-&gt;Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TableBuilder-WriteRawBlock"><a href="#TableBuilder-WriteRawBlock" class="headerlink" title="TableBuilder::WriteRawBlock"></a>TableBuilder::WriteRawBlock</h4><p>每一个block包含：</p><ol><li>data</li><li>type 表示有没有压缩</li><li>crc32<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::WriteRawBlock(<span class="keyword">const</span> Slice&amp; block_contents,</span><br><span class="line">                                 CompressionType type, BlockHandle* handle) &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  handle-&gt;set_offset(r-&gt;offset);</span><br><span class="line">  handle-&gt;set_size(block_contents.size());</span><br><span class="line">  r-&gt;status = r-&gt;file-&gt;Append(block_contents);</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;</span><br><span class="line">    <span class="keyword">uint32_t</span> crc = crc32c::Value(block_contents.data(), block_contents.size());</span><br><span class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, crc32c::Mask(crc));</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += block_contents.size() + kBlockTrailerSize;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="TableBuilder-Flush"><a href="#TableBuilder-Flush" class="headerlink" title="TableBuilder::Flush"></a>TableBuilder::Flush</h3><p>前面是判断一些条件。如果说data block是空的，那么就直接返回。接着断言<code>pending_index_entry</code>这个是true，这个是之前提到的不变量。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TableBuilder::Flush() &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  assert(!r-&gt;pending_index_entry);</span><br></pre></td></tr></table></figure></p><p>根据<code>pending_handle</code>的说明，它的值会被写到index block里面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">true</span>;</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Flush();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    r-&gt;filter_block-&gt;StartBlock(r-&gt;offset);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TableBuilder-Finish"><a href="#TableBuilder-Finish" class="headerlink" title="TableBuilder::Finish"></a>TableBuilder::Finish</h3><p>Finish操作用来生成一个SSTable。<br>首先先Flush，也就是把<code>data_block</code>写盘。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status TableBuilder::Finish() &#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Flush();</span><br><span class="line">  assert(!r-&gt;closed);</span><br><span class="line">  r-&gt;closed = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p><p>什么时候不ok呢？也就是发生错误的情况。<br>下面，写入filter block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</span><br><span class="line"><span class="comment">// Write filter block</span></span><br><span class="line"><span class="keyword">if</span> (ok() &amp;&amp; r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">  WriteRawBlock(r-&gt;filter_block-&gt;Finish(), kNoCompression,</span><br><span class="line">                &amp;filter_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上面的写入是成功的，接着写入meta index block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write metaindex block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="function">BlockBuilder <span class="title">meta_index_block</span><span class="params">(&amp;r-&gt;options)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;filter_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key = <span class="string">"filter."</span>;</span><br><span class="line">    key.append(r-&gt;options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    filter_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    meta_index_block.Add(key, handle_encoding);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></span><br><span class="line">  WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上面的写入是成功的，接着写入index block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write index block</span></span><br><span class="line"><span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;pending_index_entry) &#123;</span><br><span class="line">    r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));</span><br><span class="line">    r-&gt;pending_index_entry = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果上面的写入是成功的，接着写入footer。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Write footer</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    Footer footer;</span><br><span class="line">    footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">    footer.set_index_handle(index_block_handle);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">    footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;offset += footer_encoding.size();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r-&gt;status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>下面介绍Table类，它的作用是负责读取SSTable。</p><ol><li><code>static Status Open(const Options&amp; options, RandomAccessFile* file, uint64_t file_size, Table** table);</code><br> 解析传入的<code>file</code>。<br> 如果成功，返回ok，并且设置<code>*table</code>，这是一个指针，由调用方释放。<br> 如果失败，返回一个非ok，并且设置<code>*table</code>为nullptr。<br> Does not take ownership of “*source”, but the client must ensure that “source” remains live for the duration of the returned table’s lifetime.</li><li><code>Iterator* NewIterator(const ReadOptions&amp;) const;</code></li><li><code>uint64_t ApproximateOffsetOf(const Slice&amp; key) const;</code><br> 传入一个key，返回它在文件中的大概位置。对不存在的key，返回如果存在，那么大概在的位置。</li><li><code>static Iterator* BlockReader(void*, const ReadOptions&amp;, const Slice&amp;);</code><br> TwoLevelIterator需要这个函数，通过它来构建一个<code>data_iter_</code></li><li><code>Status InternalGet(const ReadOptions&amp;, const Slice&amp; key, void* arg, void (*handle_result)(void* arg, const Slice&amp; k, const Slice&amp; v));</code></li><li><code>void ReadMeta(const Footer&amp; footer);</code></li><li><code>void ReadFilter(const Slice&amp; filter_handle_value);</code></li></ol><h3 id="Table-Rep"><a href="#Table-Rep" class="headerlink" title="Table::Rep"></a>Table::Rep</h3><ol><li><code>Options options;</code></li><li><code>Status status;</code></li><li><code>RandomAccessFile* file;</code></li><li><code>uint64_t cache_id;</code></li><li><code>FilterBlockReader* filter;</code></li><li><code>const char* filter_data;</code></li><li><code>BlockHandle metaindex_handle;</code></li><li><code>Block* index_block;</code></li></ol><h3 id="Table-Open"><a href="#Table-Open" class="headerlink" title="Table::Open"></a>Table::Open</h3><p>首先解析出footer。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options, RandomAccessFile* file,</span><br><span class="line">                   <span class="keyword">uint64_t</span> size, Table** table) &#123;</span><br><span class="line">  *table = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</span><br><span class="line">  Slice footer_input;</span><br><span class="line">  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</span><br><span class="line">                        &amp;footer_input, footer_space);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">  Footer footer;</span><br><span class="line">  s = footer.DecodeFrom(&amp;footer_input);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br></pre></td></tr></table></figure></p><p>接下来，解析index block。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Read the index block</span></span><br><span class="line">BlockContents index_block_contents;</span><br><span class="line">ReadOptions opt;</span><br><span class="line"><span class="keyword">if</span> (options.paranoid_checks) &#123;</span><br><span class="line">  opt.verify_checksums = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">s = ReadBlock(file, opt, footer.index_handle(), &amp;index_block_contents);</span><br></pre></td></tr></table></figure></p><p>初始化<code>rep_</code>字段。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></span><br><span class="line">    <span class="comment">// ready to serve requests.</span></span><br><span class="line">    Block* index_block = <span class="keyword">new</span> Block(index_block_contents);</span><br><span class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</span><br><span class="line">    rep-&gt;options = options;</span><br><span class="line">    rep-&gt;file = file;</span><br><span class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</span><br><span class="line">    rep-&gt;index_block = index_block;</span><br><span class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</span><br><span class="line">    rep-&gt;filter_data = <span class="literal">nullptr</span>;</span><br><span class="line">    rep-&gt;filter = <span class="literal">nullptr</span>;</span><br><span class="line">    *table = <span class="keyword">new</span> Table(rep);</span><br><span class="line">    (*table)-&gt;ReadMeta(footer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Table-NewIterator"><a href="#Table-NewIterator" class="headerlink" title="Table::NewIterator"></a>Table::NewIterator</h2><p>实际上调用<code>NewTwoLevelIterator</code>得到一个<code>TwoLevelIterator</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Iterator* Table::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</span><br><span class="line">      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),</span><br><span class="line">      &amp;Table::BlockReader, <span class="keyword">const_cast</span>&lt;Table*&gt;(<span class="keyword">this</span>), options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Iterator* <span class="title">NewTwoLevelIterator</span><span class="params">(Iterator* index_iter,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockFunction block_function, <span class="keyword">void</span>* arg,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> ReadOptions&amp; options)</span></span>;</span><br></pre></td></tr></table></figure></p><p>方法<code>NewIterator</code>的实现如下。如果没有restart点，那么就创建一个空的迭代器，否则创建一个<code>Block::Iter</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator* Block::NewIterator(<span class="keyword">const</span> Comparator* comparator) &#123;</span><br><span class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewErrorIterator(Status::Corruption(<span class="string">"bad block contents"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = NumRestarts();</span><br><span class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NewEmptyIterator();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iter(comparator, data_, restart_offset_, num_restarts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个Level的含义是：</p><ol><li><code>IteratorWrapper index_iter_</code>负责查询index block，找到key所在的data block。<br> <code>IteratorWrapper</code>封装了<code>Iterator</code>，可以理解为一层对<code>valid()</code>和<code>key()</code>的cache。<code>Iterator</code>是个接口，实际类型应该是<code>Block::Iter</code>【待确认】。</li><li><code>IteratorWrapper data_iter_</code>负责在这个block里面查找。</li></ol><h3 id="TwoLevelIterator"><a href="#TwoLevelIterator" class="headerlink" title="TwoLevelIterator"></a>TwoLevelIterator</h3><ol><li><code>BlockFunction block_function_;</code><br> 由<code>block_function_</code>可以从一个<code>index_iter_</code>创建一个<code>data_iter_</code>。<br> 在Table的实现中，是<code>Table::BlockReader</code>这个函数。我们将在后面详细分析这个函数。</li><li><code>void* arg_;</code><br> 在Table的实现中，传入了<code>Table* this</code>。</li><li><code>const ReadOptions options_;</code></li><li><code>Status status_;</code></li><li><code>IteratorWrapper index_iter_;</code></li><li><code>IteratorWrapper data_iter_;</code></li><li><code>std::string data_block_handle_;</code><br> 如果<code>data_iter_</code>不是null，那么<code>data_block_handle_</code>持有传给<code>block_function_</code>的那个<code>index_iter_</code>的值。</li></ol><h4 id="TwoLevelIterator-Next"><a href="#TwoLevelIterator-Next" class="headerlink" title="TwoLevelIterator::Next"></a>TwoLevelIterator::Next</h4><p>存在一个问题，如果我们一直<code>data_iter_.Next()</code>，我们迟早会碰到一个Block的右边界，这样后面迭代器就Invalid了。因此需要检查如果<code>data_iter_</code>当前已经失效了，那么就递增<code>index_iter_</code>，获取下一个<code>data_iter_</code>，具体实现见下面。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::Next() &#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  data_iter_.Next();</span><br><span class="line">  SkipEmptyDataBlocksForward();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TwoLevelIterator-SkipEmptyDataBlocksForward"><a href="#TwoLevelIterator-SkipEmptyDataBlocksForward" class="headerlink" title="TwoLevelIterator::SkipEmptyDataBlocksForward"></a>TwoLevelIterator::SkipEmptyDataBlocksForward</h4><p>【Q】在上面说过这个函数的作用了，但是为啥这里实现是<code>while</code>而不是<code>if</code>呢？<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::SkipEmptyDataBlocksForward() &#123;</span><br><span class="line">  <span class="keyword">while</span> (data_iter_.iter() == <span class="literal">nullptr</span> || !data_iter_.Valid()) &#123;</span><br><span class="line">    <span class="comment">// Move to next block</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><code>SetDataIterator</code>函数接受一个迭代器作为参数，如果迭代器不是空，那么就设置为<code>data_iter_</code>，并且释放掉原来的<code>iter_</code>内存。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</span><br><span class="line">      SetDataIterator(<span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    index_iter_.Next();</span><br><span class="line">    InitDataBlock();</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>需要注意，这里需要显式将<code>data_iter_</code>移动到当前data block的开头。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span>) data_iter_.SeekToFirst();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TwoLevelIterator-InitDataBlock"><a href="#TwoLevelIterator-InitDataBlock" class="headerlink" title="TwoLevelIterator::InitDataBlock"></a>TwoLevelIterator::InitDataBlock</h4><p><code>InitDataBlock</code>作用是从<code>index_iter_</code>构建（解析）出一个data block。<br>如果<code>index_iter_</code>无效，那么设置<code>data_iter_</code>也无效。<br>如果<code>data_iter_</code>不为空，并且等于之前的<code>data_block_handle_</code>，说明<code>data_iter_</code>现在就指向的这个data block，那么就跳过。<br>否则，以<code>index_iter_</code>为参数，通过<code>block_function_</code>生成一个新的<code>data_iter_</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::InitDataBlock() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</span><br><span class="line">    SetDataIterator(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slice handle = index_iter_.value();</span><br><span class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span> &amp;&amp;</span><br><span class="line">        handle.compare(data_block_handle_) == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Iterator* iter = (*block_function_)(arg_, options_, handle);</span><br><span class="line">      data_block_handle_.assign(handle.data(), handle.size());</span><br><span class="line">      SetDataIterator(iter);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="TwoLevelIterator-Seek"><a href="#TwoLevelIterator-Seek" class="headerlink" title="TwoLevelIterator::Seek"></a>TwoLevelIterator::Seek</h4><p>首先，在index block层Seek。下面证明只要找这个<code>index_iter_</code>指向的data block就行，也就是说，target不会出现在<code>(index_iter_ - 1)</code>和<code>(index_iter_ + 1)</code>指向的data block里面。</p><ol><li>因为LevelDB中的性质，Seek得到的是第一个大于等于target的指针。此时，<code>(index_iter_ - 1)</code>中的<code>.key()</code>是<strong>严格</strong>小于target的。而根据index block的【性质1】，这个index block entry指向的data block中的所有K都<strong>小于等于</strong><code>(index_iter_ - 1).key()</code>。因此，<code>(index_iter_ - 1)</code>指向的data block里面所有的K，都小于target。</li><li>此外，<code>index_iter_.key()</code>是大于等于target的。</li><li>下面，还要证明<code>(index_iter_ + 1).key()</code>指向的data block里面的所有K都大于target。根据【性质2】我们知道<code>index_iter_.key()</code>会严格小于它指向的下一个data block中的所有K，根据我们上一条结论可以知道target严格小于下一个data block中的所有K，所以target如果存在的话，一定是当前data block上的。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> TwoLevelIterator::Seek(<span class="keyword">const</span> Slice&amp; target) &#123;</span><br><span class="line">  index_iter_.Seek(target);</span><br></pre></td></tr></table></figure></li></ol><p>接着初始化<code>data_iter_</code>。接着在data block层Seek。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  InitDataBlock();</span><br><span class="line">  <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">nullptr</span>) data_iter_.Seek(target);</span><br><span class="line">  SkipEmptyDataBlocksForward();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Table-BlockReader"><a href="#Table-BlockReader" class="headerlink" title="Table::BlockReader"></a>Table::BlockReader</h3><p>接受三个参数：</p><ol><li><code>arg</code><br> 这个类型设置就很奇怪，实际上是一个<code>Table*</code>，表示我们现在读的那个Table的上下文。</li><li><code>index_value</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></span><br><span class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></span><br><span class="line">Iterator* Table::BlockReader(<span class="keyword">void</span>* arg, <span class="keyword">const</span> ReadOptions&amp; options,</span><br><span class="line">                             <span class="keyword">const</span> Slice&amp; index_value) &#123;</span><br><span class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;Table*&gt;(arg);</span><br><span class="line">  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;</span><br><span class="line">  Block* block = <span class="literal">nullptr</span>;</span><br><span class="line">  Cache::Handle* cache_handle = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  BlockHandle handle;</span><br><span class="line">  Slice input = index_value;</span><br><span class="line">  Status s = handle.DecodeFrom(&amp;input);</span><br><span class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></span><br><span class="line">  <span class="comment">// can add more features in the future.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">    BlockContents contents;</span><br><span class="line">    <span class="keyword">if</span> (block_cache != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">char</span> cache_key_buffer[<span class="number">16</span>];</span><br><span class="line">      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id);</span><br><span class="line">      EncodeFixed64(cache_key_buffer + <span class="number">8</span>, handle.offset());</span><br><span class="line">      Slice key(cache_key_buffer, sizeof(cache_key_buffer));</span><br><span class="line">      cache_handle = block_cache-&gt;Lookup(key);</span><br><span class="line">      <span class="keyword">if</span> (cache_handle != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        block = <span class="keyword">reinterpret_cast</span>&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">        <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">          block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">          <span class="keyword">if</span> (contents.cachable &amp;&amp; options.fill_cache) &#123;</span><br><span class="line">            cache_handle = block_cache-&gt;Insert(key, block, block-&gt;size(),</span><br><span class="line">                                               &amp;DeleteCachedBlock);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;contents);</span><br><span class="line">      <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">        block = <span class="keyword">new</span> Block(contents);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  Iterator* iter;</span><br><span class="line">  <span class="keyword">if</span> (block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    iter = block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);</span><br><span class="line">    <span class="keyword">if</span> (cache_handle == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iter = NewErrorIterator(s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://izualzhy.cn/leveldb-block" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-block</a></li><li><a href="https://izualzhy.cn/leveldb-sstable" target="_blank" rel="noopener">https://izualzhy.cn/leveldb-sstable</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍LevelDB的SSTable相关功能。&lt;br&gt;SSTable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。Level0的SSTable是没有经过归并的，各个Key可能互相重叠。经过Compaction达到Level1之后，就是有序的了。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>LevelDB之Memtable实现</title>
    <link href="http://www.calvinneo.com/2021/04/09/leveldb-memtable/"/>
    <id>http://www.calvinneo.com/2021/04/09/leveldb-memtable/</id>
    <published>2021-04-09T15:09:06.000Z</published>
    <updated>2021-04-09T14:30:36.539Z</updated>
    
    <content type="html"><![CDATA[<p>作为LevelDB源码分析系列的第一篇文章，介绍Memtable的实现，以及其中涉及到的数据结构和辅助函数。</p><p>Memtable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。</p><a id="more"></a><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="VarInt"><a href="#VarInt" class="headerlink" title="VarInt"></a>VarInt</h2><p>LevelDB的VarInt机制，用一个char数组存放整数，主要目的不是支持大整数，而是压缩小整数的存储空间。例如小于128的unsigned int，只要一个字节就行，但如果数比较大，。<br>具体实现就是读char数组，如果最高位是1，那么就说明这个VarInt还没有结束，于是就接着读下一位。<br><code>GetVarint32Ptr</code>的函数签名，传入的limit表示这个VarInt数组有多长。因为VarInt最多占用5个字节，所以一般传入都是<code>p + 5</code>。我们需要注意，合法的<code>limit</code>应当始终大于<code>p</code>。<br>一开始是一个优化分支，如果只有一个char，那么直接返回了，否则调用<code>GetVarint32PtrFallback</code>。<br>这个函数返回的前进后的<code>p</code>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint32PtrFallback</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h2><p>Slice定义在include/leveldb/slice.h里面，可以理解为对<code>const char*</code>的View。</p><h1 id="Memtable类"><a href="#Memtable类" class="headerlink" title="Memtable类"></a>Memtable类</h1><p>Memtable类定义在memtable.h/cc里面。接口如下</p><ol><li><code>size_t ApproximateMemoryUsage()</code><br> 估计大小，在被修改的时候也可以调用。</li><li><code>Iterator* NewIterator()</code></li><li><code>void Add(SequenceNumber seq, ValueType type, const Slice&amp; key, const Slice&amp; value)</code><br> 负责插入记录。<ol><li>type<br> 普通插入<code>type</code>为kTypeValue。<br> 删除操作实际上是插入<code>type</code>为<code>kTypeDeletion</code>的记录。</li><li>key</li></ol></li><li><code>bool Get(const LookupKey&amp; key, std::string* value, Status* s)</code><br> 如果存在key对应的记录，返回true，并且将值存在<code>*value</code>上。<br> 如果存在key被删除的记录，返回true，并且在<code>*status</code>存入<code>NotFound()</code>。<br> 否则返回false。<br> 这里<code>LookupKey</code>的设计较为复杂，稍后讲解。</li><li><code>void Ref()</code></li><li><code>void Unref()</code></li></ol><p>Memtable还有下面一些成员：</p><ol><li><p><code>KeyComparator comparator_</code><br> 封装了个<code>InternalKeyComparator</code>，这一块后面介绍</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyComparator</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator comparator;</span><br><span class="line">  explicit KeyComparator(const InternalKeyComparator&amp; c) : comparator(c) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* a, <span class="keyword">const</span> <span class="keyword">char</span>* b)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><code>int refs_</code></p></li><li><code>Arena arena_</code></li><li><code>Table table_</code><br> 实际上是个跳表。 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SkipList&lt;<span class="keyword">const</span> <span class="keyword">char</span>*, KeyComparator&gt; Table;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p>Memtable在跳表中索引的Key中存放三个数据：</p><ol><li>User Key<br> 用户实际传入的key。</li><li><p>Sequence Number</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint64_t</span> SequenceNumber;</span><br></pre></td></tr></table></figure></li><li><p>Value Type<br> 表示是不是删除。<br> 对于C而言，enum的大小取决于里面定义的范围。对于C++，可以显式指定实际使用的类型。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ValueType &#123; kTypeDeletion = <span class="number">0x0</span>, kTypeValue = <span class="number">0x1</span> &#125;;</span><br></pre></td></tr></table></figure></li></ol><p>这些数据是按顺序编码的，这样方便比较。</p><p><code>InternalKey</code>把这些打包到一个<code>std::string</code>里面。<br><code>ParseInternalKey</code>把<code>InternalKey</code>转成<code>ParsedInternalKey</code>，后者可以直接读取上面三个字段。<br><code>AppendInternalKey</code>可以从<code>ParsedInternalKey</code>构建<code>InternalKey</code>。</p><p>为了方便查找，还将User Key和Sequence Number合并，组成LookupKey。</p><ol><li><p><code>start_</code><br> 指向klength，klength表示userkey长度。注意，这里userkey也可以存放InternalKey，所以<code>LookupKey</code>可以表示一个Memtable Key。</p> <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">klength  varint32               &lt;<span class="comment">-- start_</span></span><br><span class="line">userkey  <span class="keyword">char</span>[klength]          &lt;<span class="comment">-- kstart_</span></span><br><span class="line">tag      uint64</span><br><span class="line">                                &lt;<span class="comment">-- end_</span></span><br></pre></td></tr></table></figure></li><li><p><code>kstart_</code></p></li><li><code>end_</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookupKey</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></span><br><span class="line">  <span class="comment">// the specified sequence number.</span></span><br><span class="line">  LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</span><br><span class="line"></span><br><span class="line">  LookupKey(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  LookupKey&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> LookupKey&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~LookupKey();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></span><br><span class="line">  <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></span><br><span class="line">  <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return the user key</span></span><br><span class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结一下，一个Key中的信息包括：</p><ol><li>klength</li><li>User Key</li><li>Tag<ol><li>Sequence Number</li><li>Value Type</li></ol></li></ol><p><img src="/img/leveldb/memtable/memtable.png" alt=""></p><p>其中：</p><ol><li>Memtable Key<br> 1+2+3</li><li>Internal Key<br> 2+3</li><li>User Key<br> 2</li></ol><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>我们合成了一个包含三个部分的Internal Key，如果仅仅是这样，直接比较也许还是可行的，毕竟User Key、Seq、Value Type啥的都是有层级的。但是，这些东西是用VarInt存储的，这就不好直接bitwise比较了。</p><p><code>Comparator</code>接口定义在include/leveldb/comparator.h里面。包含下面一些成员</p><ol><li><code>int Compare(const Slice&amp; a, const Slice&amp; b) const</code><br> 比较函数</li><li><code>void FindShortestSeparator(std::string* start, const Slice&amp; limit)</code><br> 目的是节约空间。如果<code>*start</code>这个字符串小于<code>limit</code>字符串，那么就修改<code>*start</code>，变成大小在<code>*start</code>和<code>limit</code>之间，<a href="https://zhuanlan.zhihu.com/p/79362747" target="_blank" rel="noopener">但是长度最短的字符串</a>。<br> 其方法基于公共前缀，如果<code>*start</code>是<code>helloWorld</code>，<code>limit</code>是<code>helloZookeeper</code>，那么旧改<code>*start</code>为<code>helloX</code>，也就是后面的<code>World</code>不要了。<br> 【Q】这个功能会用到哪里呢？我觉得在插入是用不上的，因为会涉及修改Key的值。</li><li><code>void FindShortSuccessor(std::string* key)</code></li></ol><p><code>data</code>在开头存了对应字符串的长度。所以<code>GetLengthPrefixedSlice</code>会先读取长度到<code>len</code>里面，这个时候<code>p</code>前进指向了实际的字符串，然后创建一个Slice。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Slice <span class="title">GetLengthPrefixedSlice</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = data;</span><br><span class="line">  p = GetVarint32Ptr(p, p + <span class="number">5</span>, &amp;len);  <span class="comment">// +5: we assume "p" is not corrupted</span></span><br><span class="line">  <span class="keyword">return</span> Slice(p, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>MemTable::KeyComparator</code>就是获取对应的字符串，然后调用<code>InternalKeyComparator</code>比较。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MemTable::KeyComparator::<span class="keyword">operator</span>()(<span class="keyword">const</span> <span class="keyword">char</span>* aptr,</span><br><span class="line">                                        <span class="keyword">const</span> <span class="keyword">char</span>* bptr) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="comment">// Internal keys are encoded as length-prefixed strings.</span></span><br><span class="line">  Slice a = GetLengthPrefixedSlice(aptr);</span><br><span class="line">  Slice b = GetLengthPrefixedSlice(bptr);</span><br><span class="line">  <span class="keyword">return</span> comparator.Compare(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比较的顺序是:</p><ol><li>User Key升序</li><li>Sequence Number降序<br> 这样，会倾向于找新的</li><li>ValueType降序<br> 但考虑到Sequence Number，大概率用不到。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> InternalKeyComparator::Compare(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey) <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</span><br><span class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</span><br><span class="line">      r = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</span><br><span class="line">      r = +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，在<code>InternalKeyComparator</code>里面，还会调用<code>user_comparator_-&gt;Compare</code>去比较User Key。它默认是<code>BytewiseComparator</code>类型的。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>现在我们有一个KV对<code>key</code>和<code>value</code>，都用Slice运载的。我们要把它放到跳表中。<br>有点类似于Spark将K和V连续放在两个slot上，LevelDB直接将K和V编码到一起存放。因此，我们可以看到总长度<code>encoded_len</code>需要计算下面几部分：</p><ol><li>K的长度，用VarInt存<br> 这里<code>internal_key_size</code>为啥要加上8呢？这是因为Sequence Number和Type分别占用了7个byte和1个byte。所以从User Key生成Internal Key的时候要加上这两部分。<br> 这就是Memtable Key，相对于Internal Key多存储的一块数据。</li><li>K本身<br> 也就是Internal Key。</li><li>V的长度</li><li>V本身<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MemTable::Add(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</span><br><span class="line">                   <span class="keyword">const</span> Slice&amp; value) &#123;</span><br><span class="line">  <span class="comment">// Format of an entry is concatenation of:</span></span><br><span class="line">  <span class="comment">//  key_size     : varint32 of internal_key.size()</span></span><br><span class="line">  <span class="comment">//  key bytes    : char[internal_key.size()]</span></span><br><span class="line">  <span class="comment">//  value_size   : varint32 of value.size()</span></span><br><span class="line">  <span class="comment">//  value bytes  : char[value.size()]</span></span><br><span class="line">  <span class="keyword">size_t</span> key_size = key.size();</span><br><span class="line">  <span class="keyword">size_t</span> val_size = value.size();</span><br><span class="line">  <span class="keyword">size_t</span> internal_key_size = key_size + <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> encoded_len = VarintLength(internal_key_size) +</span><br><span class="line">                             internal_key_size + VarintLength(val_size) +</span><br><span class="line">                             val_size;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ol><p>下面，就是从Memtable里面的Arena中分配一块内存<code>buf</code>，然后把上面说的四个字段填进去，最后把<code>buf</code>添加到跳表<code>table_</code>里面。跳表插入只需要实现比较操作，这个之前已经定义过了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">char</span>* buf = arena_.Allocate(encoded_len);</span><br><span class="line">  <span class="keyword">char</span>* p = EncodeVarint32(buf, internal_key_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, key.data(), key_size);</span><br><span class="line">  p += key_size;</span><br><span class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | type);</span><br><span class="line">  p += <span class="number">8</span>;</span><br><span class="line">  p = EncodeVarint32(p, val_size);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">memcpy</span>(p, value.data(), val_size);</span><br><span class="line">  assert(p + val_size == buf + encoded_len);</span><br><span class="line">  table_.Insert(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>首先，从LookupKey中取得<code>memtable_key</code>，这个是包含了4个部分的。接着获得跳表的迭代器<code>iter</code>，定位到第一个大于等于<code>memkey</code>的位置。<br>我们得到<code>key_ptr</code>指向Internal Key，<code>key_length</code>为Internal Key的长度。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> MemTable::Get(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s) &#123;</span><br><span class="line">  Slice memkey = key.memtable_key();</span><br><span class="line">  Table::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</span><br><span class="line">  iter.Seek(memkey.data());</span><br><span class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</span><br><span class="line">    <span class="comment">// entry format is:</span></span><br><span class="line">    <span class="comment">//    klength  varint32</span></span><br><span class="line">    <span class="comment">//    userkey  char[klength]</span></span><br><span class="line">    <span class="comment">//    tag      uint64</span></span><br><span class="line">    <span class="comment">//    vlength  varint32</span></span><br><span class="line">    <span class="comment">//    value    char[vlength]</span></span><br><span class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></span><br><span class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></span><br><span class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</span><br><span class="line">    <span class="keyword">uint32_t</span> key_length;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry + <span class="number">5</span>, &amp;key_length);</span><br></pre></td></tr></table></figure></p><p>接着我们比较Value Type，它在tag的最后一个字节。注意tag的组装方式是<code>(seq &lt;&lt; 8) | type</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</span><br><span class="line">            Slice(key_ptr, key_length - <span class="number">8</span>), key.user_key()) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// Correct user key</span></span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</span><br><span class="line">        <span class="keyword">case</span> kTypeValue: &#123;</span><br><span class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</span><br><span class="line">          value-&gt;assign(v.data(), v.size());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> kTypeDeletion:</span><br><span class="line">          *s = Status::NotFound(Slice());</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://izualzhy.cn/memtable-leveldb" target="_blank" rel="noopener">https://izualzhy.cn/memtable-leveldb</a></li><li><a href="https://github.com/yingshin/leveldb_more_annotation/blob/master/db/memtable.h" target="_blank" rel="noopener">https://github.com/yingshin/leveldb_more_annotation/blob/master/db/memtable.h</a></li><li><a href="https://zhuanlan.zhihu.com/p/79362747" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/79362747</a></li><li><a href="https://github.com/balloonwj/CppGuide/blob/master/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904.md" target="_blank" rel="noopener">https://github.com/balloonwj/CppGuide/blob/master/articles/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/leveldb%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904.md</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;作为LevelDB源码分析系列的第一篇文章，介绍Memtable的实现，以及其中涉及到的数据结构和辅助函数。&lt;/p&gt;
&lt;p&gt;Memtable是LevelDB的内存数据结构。当一个Memtable满之后，会被变成Immutable Memtable，并写入SSTable Level0。&lt;/p&gt;</summary>
    
    
    
    
    <category term="leveldb" scheme="http://www.calvinneo.com/tags/leveldb/"/>
    
  </entry>
  
  <entry>
    <title>Redis事务的实现</title>
    <link href="http://www.calvinneo.com/2021/03/23/redis-transaction/"/>
    <id>http://www.calvinneo.com/2021/03/23/redis-transaction/</id>
    <published>2021-03-22T17:20:33.000Z</published>
    <updated>2021-05-06T14:44:43.947Z</updated>
    
    <content type="html"><![CDATA[<p>本文详细介绍Redis事务的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。<br>这是Redis源码分析的系列文章的第四篇，前三篇分别是</p><ol><li><a href="/2018/07/23/redis_learn_object/">Redis底层对象实现原理分析</a></li><li><a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a></li><li><a href="/2021/03/13/redis-persist/">Redis持久化机制实现</a></li></ol><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>事务在执行期间<a href="https://redisbook.readthedocs.io/en/latest/feature/transaction.html" target="_blank" rel="noopener">不会主动中断</a>，也就是说服务器在执行完事务中的所有命令之后，才会继续处理其他客户端的其他命令。<br>需要注意的是，Redis并<strong>没有原子性</strong>。原因之一是Redis不支持事务回滚。有人说Redis不是有DISCARD的么？但这个DISCARD只是在命令入队的阶段，等到真正执行事务的时候，Redis并不支持执行到一般就退出。</p><h2 id="multi"><a href="#multi" class="headerlink" title="multi"></a>multi</h2><p>总的来说，就是multi开始事务，最后exec提交事务或者discard放弃事务。在发送完multi后，后面发送的命令都不会被立即执行，而是返回QUEUED状态。当收到exec后，事务会将这个队列中的命令按照fifo的顺序执行。并发结果放入一个回复队列中返回给客户端。</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>在multi前监控一些key，如果这些key被修改，则事务回滚。</p><h1 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h1><h2 id="multiState"><a href="#multiState" class="headerlink" title="multiState"></a>multiState</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span> &#123;</span></span><br><span class="line">    multiCmd *commands;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">int</span> cmd_flags;          <span class="comment">/* The accumulated command flags OR-ed together.</span></span><br><span class="line"><span class="comment">                               So if at least a command has a given flag, it</span></span><br><span class="line"><span class="comment">                               will be set in this field. */</span></span><br><span class="line">    <span class="keyword">int</span> cmd_inv_flags;      <span class="comment">/* Same as cmd_flags, OR-ing the ~flags. so that it</span></span><br><span class="line"><span class="comment">                               is possible to know if all the commands have a</span></span><br><span class="line"><span class="comment">                               certain flag. */</span></span><br><span class="line">    <span class="keyword">int</span> minreplicas;        <span class="comment">/* MINREPLICAS for synchronous replication */</span></span><br><span class="line">    <span class="keyword">time_t</span> minreplicas_timeout; <span class="comment">/* MINREPLICAS timeout as unixtime. */</span></span><br><span class="line">&#125; multiState;</span><br></pre></td></tr></table></figure><p>主要涉及下面一些字段：</p><ol><li><code>commands</code><br> 这个是<code>multiCmd</code>数组，表示事务中的FIFO的队列。</li><li><code>count</code><br> multi命令的数量，表示commands的长度？</li><li><code>cmd_flags</code></li></ol><h2 id="multiCmd"><a href="#multiCmd" class="headerlink" title="multiCmd"></a>multiCmd</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiCmd</span> &#123;</span></span><br><span class="line">    robj **argv;</span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line">&#125; multiCmd;</span><br></pre></td></tr></table></figure><h1 id="redisCmd"><a href="#redisCmd" class="headerlink" title="redisCmd"></a>redisCmd</h1><h1 id="事务开始和结束的实现"><a href="#事务开始和结束的实现" class="headerlink" title="事务开始和结束的实现"></a>事务开始和结束的实现</h1><h2 id="普通命令"><a href="#普通命令" class="headerlink" title="普通命令"></a>普通命令</h2><p>可以看到，在<code>processCommand</code>中，如果被设置了MULTI，那么就不会调用<code>call</code>，而是调用<code>queueMultiCommand</code>将指令入队。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != execCommand &amp;&amp; c-&gt;cmd-&gt;proc != discardCommand &amp;&amp;</span><br><span class="line">        c-&gt;cmd-&gt;proc != multiCommand &amp;&amp; c-&gt;cmd-&gt;proc != watchCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        queueMultiCommand(c);</span><br><span class="line">        addReply(c,shared.queued);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        call(c,CMD_CALL_FULL);</span><br><span class="line">        c-&gt;woff = server.master_repl_offset;</span><br><span class="line">        <span class="keyword">if</span> (listLength(server.ready_keys))</span><br><span class="line">            handleClientsBlockedOnKeys();</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>multi指令，会给客户端打上<code>CLIENT_MULTI</code>这个flag。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MULTI) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"MULTI calls can not be nested"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c-&gt;flags |= CLIENT_MULTI;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="discard"><a href="#discard" class="headerlink" title="discard"></a>discard</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"DISCARD without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="discardTransaction"><a href="#discardTransaction" class="headerlink" title="discardTransaction"></a>discardTransaction</h3><p>先调用<code>discardTransaction</code>清空<code>multiCmd</code>数组。<br>再调用<code>initClientMultiState</code>清除<code>multiState</code>里面的其他内容。<br>再取消所有事务相关的flag。这边的flag都是什么意思？</p><ol><li><code>CLIENT_MULTI</code> </li><li><code>CLIENT_DIRTY_CAS</code><br> 表示被watch的字段发生了修改。</li><li><code>CLIENT_DIRTY_EXEC</code><br> 由<code>flagTransaction</code>产生，表示在先前操作中，出现了错误，所以不能exec。包含下面情况：<ol><li>rejectCommand<br> 在下面的场景下被调用：<ol><li>shared.noautherr</li><li>shared.oomerr</li><li>shared.bgsaveerr</li><li>等等</li></ol></li><li>rejectCommandFormat</li><li>processCommand中，涉及Redis Cluster相关。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discardTransaction</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    c-&gt;flags &amp;= ~(CLIENT_MULTI|CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC);</span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    robj **orig_argv;</span><br><span class="line">    <span class="keyword">int</span> orig_argc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">orig_cmd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> must_propagate = <span class="number">0</span>; <span class="comment">/* Need to propagate MULTI/EXEC to AOF / slaves? */</span></span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MULTI)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"EXEC without MULTI"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>检查flags，discard掉有问题的事务：</p><ol><li>对于<code>CLIENT_DIRTY_CAS</code>返回空数组<br> 因为这个不能算作是错误，只能作为一种特殊的表现。</li><li>对于<code>CLIENT_DIRTY_EXEC</code>返回EXECABORT<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * A failed EXEC in the first case returns a multi bulk nil object</span></span><br><span class="line"><span class="comment"> * (technically it is not an error but a special behavior), while</span></span><br><span class="line"><span class="comment"> * in the second an EXECABORT error is returned. */</span></span><br><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_DIRTY_CAS|CLIENT_DIRTY_EXEC)) &#123;</span><br><span class="line">    addReply(c, c-&gt;flags &amp; CLIENT_DIRTY_EXEC ? shared.execaborterr :</span><br><span class="line">                                               shared.nullarray[c-&gt;resp]);</span><br><span class="line">    discardTransaction(c);</span><br><span class="line">    <span class="keyword">goto</span> handle_monitor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>因为已经检查了，取消客户端对所有键的监视。<br>因为事务中的命令在执行时可能会修改命令和命令的参数，所以为了正确地传播命令，需要备份这些命令和参数。<br>下面开始处理<code>multiState</code>下面所有的<code>multiCmd</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Exec all the queued commands */</span></span><br><span class="line">unwatchAllKeys(c); <span class="comment">/* Unwatch ASAP otherwise we'll waste CPU cycles */</span></span><br><span class="line">orig_argv = c-&gt;argv;</span><br><span class="line">orig_argc = c-&gt;argc;</span><br><span class="line">orig_cmd = c-&gt;cmd;</span><br><span class="line">addReplyArrayLen(c,c-&gt;mstate.count);</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; c-&gt;mstate.count; j++) &#123;</span><br><span class="line">    c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">    c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">    c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br></pre></td></tr></table></figure></p><p>当我们遇到第一个不是<code>CMD_READONLY</code>或者<code>CMD_ADMIN</code>的请求时，传播multi指令。【Q】这里readonly又出现了，为啥这么特殊呢？我觉得readonly指令一般指的是get之类的不涉及修改的指令。而一旦涉及修改或者增加等的指令，我们一定要把这个变动propagate出去。<br>这样，我们可以将<code>MULTI/..../EXEC</code>打包成一整个，并且AOF和Slave都具有相同的一致性和原子性的要求。为啥呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!must_propagate &amp;&amp;</span><br><span class="line">    !server.loading &amp;&amp;</span><br><span class="line">    !(c-&gt;cmd-&gt;flags &amp; (CMD_READONLY|CMD_ADMIN)))</span><br><span class="line">&#123;</span><br><span class="line">    execCommandPropagateMulti(c);</span><br><span class="line">    must_propagate = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>ACLCheckCommandPerm</code>主要检查权限，包含：</p><ol><li>执行命令的权限</li><li>对某个key的权限</li></ol><p>如果检查通过，我们就用call来执行命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> acl_keypos;</span><br><span class="line"><span class="keyword">int</span> acl_retval = ACLCheckCommandPerm(c,&amp;acl_keypos);</span><br><span class="line"><span class="keyword">if</span> (acl_retval != ACL_OK) &#123;</span><br><span class="line">    addACLLogEntry(c,acl_retval,acl_keypos,<span class="literal">NULL</span>);</span><br><span class="line">    addReplyErrorFormat(c,</span><br><span class="line">        <span class="string">"-NOPERM ACLs rules changed between the moment the "</span></span><br><span class="line">        <span class="string">"transaction was accumulated and the EXEC call. "</span></span><br><span class="line">        <span class="string">"This command is no longer allowed for the "</span></span><br><span class="line">        <span class="string">"following reason: %s"</span>,</span><br><span class="line">        (acl_retval == ACL_DENIED_CMD) ?</span><br><span class="line">        <span class="string">"no permission to execute the command or subcommand"</span> :</span><br><span class="line">        <span class="string">"no permission to touch the specified keys"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    call(c,server.loading ? CMD_CALL_NONE : CMD_CALL_FULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为执行后命令、命令参数可能会被改变，比如<code>SPOP</code>会被改写为<code>SREM</code>，所以这里需要更新事务队列中的命令和参数，确保Slave和AOF的数据一致性。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Commands may alter argc/argv, restore mstate. */</span></span><br><span class="line">    c-&gt;mstate.commands[j].argc = c-&gt;argc;</span><br><span class="line">    c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">    c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个循环结束之后，事务执行完了，我们还原命令，并且清空事务状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c-&gt;argv = orig_argv;</span><br><span class="line">c-&gt;argc = orig_argc;</span><br><span class="line">c-&gt;cmd = orig_cmd;</span><br><span class="line">discardTransaction(c);</span><br></pre></td></tr></table></figure></p><p>下面，如果我们需要propagate的话，就增加<code>dirty</code>。先前我们知道，在call结束之后，如果有dirty，会去触发检测是否propagate的逻辑。而call也是可以嵌套调用的。<br>这里有一个特殊情况需要考虑。就是在multi/exec块中，这个实例突然从Master切换成了Slave（可能是来自Sentinel的<code>SLAVEOF</code>指令）。此时，原来Master收到的multi指令已经被传播到了replication backlog里面，但是后面的可能还没来得及传。对于这种情况，我们需要保证至少通过exec来结束这个backlog。【Q】为啥不用discard呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Make sure the EXEC command will be propagated as well if MULTI</span></span><br><span class="line"><span class="comment">     * was already propagated. */</span></span><br><span class="line">    <span class="keyword">if</span> (must_propagate) &#123;</span><br><span class="line">        <span class="keyword">int</span> is_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line">        server.dirty++;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog &amp;&amp; was_master &amp;&amp; !is_master) &#123;</span><br><span class="line">            <span class="keyword">char</span> *execcmd = <span class="string">"*1\r\n$4\r\nEXEC\r\n"</span>;</span><br><span class="line">            feedReplicationBacklog(execcmd,<span class="built_in">strlen</span>(execcmd));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">handle_monitor:</span><br><span class="line">    <span class="comment">/* Send EXEC to clients waiting data from MONITOR. We do it here</span></span><br><span class="line"><span class="comment">     * since the natural order of commands execution is actually:</span></span><br><span class="line"><span class="comment">     * MUTLI, EXEC, ... commands inside transaction ...</span></span><br><span class="line"><span class="comment">     * Instead EXEC is flagged as CMD_SKIP_MONITOR in the command</span></span><br><span class="line"><span class="comment">     * table, and we do it here with correct ordering. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.monitors) &amp;&amp; !server.loading)</span><br><span class="line">        replicationFeedMonitors(c,server.monitors,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文详细介绍Redis事务的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。&lt;br&gt;这是Redis源码分析的系列文章的第四篇，前三篇分别是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;Redis底层对象实现原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2021/03/13/redis-persist/&quot;&gt;Redis持久化机制实现&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询</title>
    <link href="http://www.calvinneo.com/2021/03/15/mysql-query/"/>
    <id>http://www.calvinneo.com/2021/03/15/mysql-query/</id>
    <published>2021-03-14T16:01:30.000Z</published>
    <updated>2021-03-14T16:20:55.279Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍MySQL InnoDB下索引、查询的实现以及优化。</p><a id="more"></a><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><h2 id="回表查询和覆盖索引"><a href="#回表查询和覆盖索引" class="headerlink" title="回表查询和覆盖索引"></a>回表查询和覆盖索引</h2><p>什么是回表查询？InnoDB中的主键(Primary Key, PK)使用了聚簇索引，即主键索引的叶子节点存放的是行数据<strong>本身</strong>。因此通过主键进行SELECT是很快的。<br>但是对于其他的索引，它们的叶子节点存放的是主键ID。这个是显然的，不然我每创建一个索引就得重新建立一个表结构了。在这种情况下访问行数据，就得通过主键ID去聚簇索引中再查一次，这个也就是所谓的回表查询。</p><p>看到这里不禁有一个想法，我们能不能把主键的索引做成哈希的，这样的话它的复杂度是<code>O(1)</code>，能减小回表开销，主要有下面的考虑：</p><ol><li>自增主键往往规律可循，能够设计出很好的哈希函数。</li><li>因为自增索引不像银行卡号码或者手机号码那样具有实际的意义，所以B+树提供的一些范围查询的性能未必常用。</li><li>B+树毕竟是<code>O(log n)</code>的复杂度，如果使用哈希索引，能够提高回表查询的效率。</li><li>哈希索引更好做分区。</li></ol><p>那有没有其他办法减少回表查询的开销呢？一个方案是通过覆盖索引(Covering Index)。</p><p>为了介绍覆盖索引，首先介绍联合索引。对于下面的语句生成的索引，可以用来加速<code>c1</code>、<code>c1,c2</code>、<code>c1,c2,c3</code>这三个查询。这个也是好理解的，例如我们在查询字典的时候，可以先查询第一个字母，然后再查询第二个字母；反之，没办法直接查第二个字母和第三个字母，即用不了<code>c2,c3</code>这样的索引。这启示我们，在设计联合索引的时候，应当把最常用或者最宽泛的条件放到最左边。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c1_c2_c3 <span class="keyword">on</span> table1(c1,c2,c3);</span><br></pre></td></tr></table></figure></p><p>通过覆盖索引，通过非聚簇索引查询数据也不需要再回表了，这得益于联合索引。例如<code>index_c1_c2_c3</code>就包含了<code>c1</code>、<code>c2</code>、<code>c3</code>这三个字段的值，那么如果我们只需要查询这些值的话，就不需要回表了。</p><h2 id="Extra总结"><a href="#Extra总结" class="headerlink" title="Extra总结"></a>Extra总结</h2><h3 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h3><p>需要创建临时表。</p><h3 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h3><p>文件排序，通常出现在不能使用索引排序的情况。<br>一个通常的情况是使用查询索引之外的Key去做<code>ORDER BY</code>时。<br>文件排序一般有几种实现方式，令被排序的键是<code>S</code>，主键是<code>ref</code>，需要返回的列是<code>addon1</code>、<code>addon2</code>、<code>addon3</code>，则有</p><ol><li><code>(S,ref)</code>，即original filesort algorithm，回表排序<br> 这种方式占用空间较小，但需要在排序后根据<code>ref</code>回表查询，从而产生很多随机IO。</li><li><code>(S,addon1,addon2,addon3)</code>，即modified filesort algorithm，不回表排序<br> 这种方案不需要回表，但是对排序空间要求高。当然，对于诸如varchar类型的addon字段，是可以压缩(pack)一下的，但是对于搜索排序键是不行的。</li></ol><p>具体选择哪种方案，主要是看<code>S</code>和所有addon字段的长度总和是否超过一定的阈值。</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>使用覆盖索引获取所需要的数据。</p><h3 id="Using-Index-Condition"><a href="#Using-Index-Condition" class="headerlink" title="Using Index Condition"></a>Using Index Condition</h3><p>这个实际上运用了索引下推(Index Condition Pushdown)技术。这个技术是MySQL 5.7之后的一个优化，涉及了服务器层和存储引擎层。<br>首先来先看下没有这个优化的select where过程：</p><ol><li>首先读取下一行的index tuple，然后用index tuple去定位并读取整个行。</li><li>检查所有的WHERE条件，如果该条件属于这张表，就进行检测是否符合条件。<br>在有了这个优化之后，新的过程是：</li><li>首先读取下一行的index tuple，但不需要再去读取整个行。</li><li>检查所有的WHERE条件，如果该条件属于这张表，并且能够根据当前使用的索引就能检测，就直接检测了。如果条件不满足，直接看下一行。</li><li>如果条件满足，用index tuple去定位并读取整个行。</li><li>使用刚才剩下来没有被用到的WHERE条件，检测是否符合条件。</li></ol><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>表示MySQL需要在收到存储引擎返回的结果后，对这个结果进行后过滤(Post filter)。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>首先构造样例，在db1中创建表<code>table1_noindex</code>、<code>table1</code>、<code>table2_noindex</code>。对表table1创建联合索引<code>index_c1_c2_c3</code>和索引<code>index_c5</code>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">DATABASE</span> db1;</span><br><span class="line"><span class="keyword">use</span> db1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1_noindex;</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> table1_noindex(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    c1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c2 <span class="built_in">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c3 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    c5 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">TABLE</span> table2_noindex(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    c5 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">UNIQUE</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table1 <span class="keyword">LIKE</span> table1_noindex;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table1 <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table1_noindex;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c1_c2_c3 <span class="keyword">on</span> table1(c1,c2,c3);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c5 <span class="keyword">on</span> table1(c5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="literal">NULL</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="keyword">NOW</span>(), <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1_noindex <span class="keyword">values</span> (<span class="literal">NULL</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="keyword">NOW</span>(), <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure></p><p>查看索引<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show keys from table1;</span><br></pre></td></tr></table></figure></p><ol><li><p>使用主键或者UNIQUE键</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from table1 where id=1\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p> 需要注意的是，使用UNIQUE键，同样会是const类型而不是eq_ref</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c5 from table1 where c5=5\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: const</span><br><span class="line">possible_keys: c5</span><br><span class="line">          key: c5</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure></li><li><p>使用索引<br> Extra中的Using index表示单纯用索引即可获得所有数据，不需要回表查询，这也就是之前提到的覆盖索引。下面我们介绍覆盖索引</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br></pre></td></tr></table></figure><p> 但是，如果我们加上c4，就必须要回表了</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c4 from table1 where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: const,const</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br></pre></td></tr></table></figure><p> 此外，如果我们对索引列进行计算或者应用函数，也会导致不能使用索引</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c1*2=2 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 99</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure></li><li><p>使用索引下推<br> 为了规避掉覆盖索引直接返回，我们这次用了<code>select *</code>。当然，也可以select索引之外的列，比如<code>c4</code>。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from table1 where c1=1 and c2 like "a*"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: range</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 96</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index condition</span><br></pre></td></tr></table></figure></li><li><p>不使用索引<br> 可以发现，type是个ALL，表示发生了全表扫描。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1_noindex where c1=1 and c2="a"\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1_noindex</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where</span><br></pre></td></tr></table></figure></li><li><p>破坏了最左匹配原则<br> 这一次，type是index，这表示仍然需要进行全表扫描。但不同的是扫描是按照索引的顺序，也就是说不需要对结果排序了。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,c2,c3 from table1 where c3=DATE('2012-12-21 00:00:00')\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: table1</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: index_c1_c2_c3</span><br><span class="line">          key: index_c1_c2_c3</span><br><span class="line">      key_len: 99</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 1</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using where; Using index</span><br></pre></td></tr></table></figure><p> 当然如果我们执行一下下面的语句，type又会变成ref</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_c3 <span class="keyword">on</span> table1(c3);</span><br></pre></td></tr></table></figure></li><li><p>多表查询</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select table2_noindex.c5 from table1,table2_noindex where table1.c5=table2_noindex.c5;</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table          | partitions | type   | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | table1         | NULL       | index  | c5            | c5   | 4       | NULL          |    1 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | table2_noindex | NULL       | eq_ref | c5            | c5   | 4       | db1.table1.c5 |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select c1,table2_noindex.c5 from table1,table2_noindex where table1.c5=table2_noindex.c5;</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table          | partitions | type   | possible_keys | key  | key_len | ref           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | table1         | NULL       | ALL    | c5            | NULL | NULL    | NULL          |    1 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | table2_noindex | NULL       | eq_ref | c5            | c5   | 4       | db1.table1.c5 |    1 |   100.00 | Using index |</span><br><span class="line">+<span class="comment">----+-------------+----------------+------------+--------+---------------+------+---------+---------------+------+----------+-------------+</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍MySQL InnoDB下索引、查询的实现以及优化。&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁</title>
    <link href="http://www.calvinneo.com/2021/03/14/mysql-lock/"/>
    <id>http://www.calvinneo.com/2021/03/14/mysql-lock/</id>
    <published>2021-03-13T16:01:30.000Z</published>
    <updated>2021-03-22T16:08:31.617Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍MySQL InnoDB下锁的实现以及优化。</p><p>【未完待续】</p><a id="more"></a><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>InnoDB在RR级别下，通过Next Key Lock(Record Lock+Gap Lock)提供了等价于Serializable的能力。Serializable被用在分布式事务上，即<a href="https://www.zhihu.com/question/58308824" target="_blank" rel="noopener">对于分布式事务，MySQL要求Serializable隔离级别</a>。</p><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>实验修改自<a href="https://www.cnblogs.com/zhoujinyi/p/3435982.html" target="_blank" rel="noopener">文章</a>。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table1;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table1(</span><br><span class="line">    c1 <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">key</span> index_c1(c1)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="number">1</span>),(<span class="number">3</span>),(<span class="number">5</span>),(<span class="number">8</span>),(<span class="number">11</span>);</span><br></pre></td></tr></table></figure></p><p>Session1，使用for update会强制加行锁（如果存在）或者间隙锁<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1 <span class="keyword">where</span> c1 = <span class="number">8</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure></p><p>Session2<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> table1;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">values</span> (<span class="number">6</span>);</span><br></pre></td></tr></table></figure></p><p>Session2会被Session1阻塞。如果没有间隙锁，那么只会锁住c1为8的这一行。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍MySQL InnoDB下锁的实现以及优化。&lt;/p&gt;
&lt;p&gt;【未完待续】&lt;/p&gt;</summary>
    
    
    
    
    <category term="数据库" scheme="http://www.calvinneo.com/tags/数据库/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化机制实现</title>
    <link href="http://www.calvinneo.com/2021/03/13/redis-persist/"/>
    <id>http://www.calvinneo.com/2021/03/13/redis-persist/</id>
    <published>2021-03-13T11:20:33.000Z</published>
    <updated>2021-05-06T14:31:30.757Z</updated>
    
    <content type="html"><![CDATA[<p>Redis持久化机制包括AOF和RDB两种：</p><ol><li>RDB保存二进制形式的数据库快照。</li><li>AOF以协议文本的方式，记录数据库写入的指令。</li></ol><p>本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。<br>作为Redis源码分析的系列文章，本文使用的版本和<a href="/2018/07/23/redis_learn_object/">Redis底层对象实现原理分析</a>、<a href="/2020/10/18/redis-sentinel/">Redis Sentinel实现原理分析</a>等文章是相同的。</p><a id="more"></a><h1 id="RIO"><a href="#RIO" class="headerlink" title="RIO"></a>RIO</h1><p><code>rioInitWithFile</code>从<code>FILE</code>创建一个<code>rio</code>对象。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rioInitWithFile</span><span class="params">(rio *r, FILE *fp)</span> </span>&#123;</span><br><span class="line">    *r = rioFileIO;</span><br><span class="line">    r-&gt;io.file.fp = fp;</span><br><span class="line">    r-&gt;io.file.buffered = <span class="number">0</span>;</span><br><span class="line">    r-&gt;io.file.autosync = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解释一下剩下来的两个参数：</p><ol><li><code>autosync</code><br> 表示在写入<code>autosync</code>个字节之后，就进行<code>fsync</code>。<br> 可以通过<code>rioSetAutoSync</code>函数进行设置。</li></ol><h1 id="bio"><a href="#bio" class="headerlink" title="bio"></a>bio</h1><p>Redis将耗时的io操作放到后台的线程来执行。因此叫做background io。</p><h2 id="创建一个io任务"><a href="#创建一个io任务" class="headerlink" title="创建一个io任务"></a>创建一个io任务</h2><p>可以将下列的任务给bio做</p><ol><li><code>BIO_CLOSE_FILE</code><br> 等于延迟了的<code>close(2)</code></li><li><code>BIO_AOF_FSYNC</code><br> 等于延迟了的AOF fsync</li><li><code>BIO_LAZY_FREE</code><br> 等于延迟了的内存释放<br>对于每一种类型，维护一个任务队列<code>bio_jobs[type]</code>，一个互斥量<code>bio_jobs[type]</code>和一个条件变量<code>bio_newjob_cond[type])</code>。<br>创建io任务很简单，首先获得对应任务类型的锁，然后将任务<code>job</code>加到对应列表<code>bio_jobs[type]</code>的尾部，然后通知条件变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bioCreateBackgroundJob</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *arg1, <span class="keyword">void</span> *arg2, <span class="keyword">void</span> *arg3)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span> = <span class="title">zmalloc</span>(<span class="title">sizeof</span>(*<span class="title">job</span>));</span></span><br><span class="line"></span><br><span class="line">    job-&gt;time = time(<span class="literal">NULL</span>);</span><br><span class="line">    job-&gt;arg1 = arg1;</span><br><span class="line">    job-&gt;arg2 = arg2;</span><br><span class="line">    job-&gt;arg3 = arg3;</span><br><span class="line">    pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">    listAddNodeTail(bio_jobs[type],job);</span><br><span class="line">    bio_pending[type]++;</span><br><span class="line">    pthread_cond_signal(&amp;bio_newjob_cond[type]);</span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h2><p>从<code>bioInit</code>里面可以看到，这个<code>void *arg</code>，实际上传入的是int类型的<code>type</code>。Redis会为每一种任务创建一个线程专门来处理。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">bioProcessBackgroundJobs</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bio_job</span> *<span class="title">job</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> type = (<span class="keyword">unsigned</span> <span class="keyword">long</span>) arg;</span><br><span class="line">    <span class="keyword">sigset_t</span> sigset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the type is within the right interval. */</span></span><br><span class="line">    <span class="keyword">if</span> (type &gt;= BIO_NUM_OPS) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Warning: bio thread started with wrong type %lu"</span>,type);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BIO_CLOSE_FILE:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_close_file"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_AOF_FSYNC:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_aof_fsync"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BIO_LAZY_FREE:</span><br><span class="line">        redis_set_thread_title(<span class="string">"bio_lazy_free"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个函数接受一个字符串，类似”0,2,3”, “0,2-3”, “0-20:2”这样。表示设置对某些CPU的亲和性。<br>此外，还需要让线程可以异步终止。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redisSetCpuAffinity(server.bio_cpulist);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Make the thread killable at any time, so that bioKillThreads()</span></span><br><span class="line"><span class="comment"> * can work reliably. */</span></span><br><span class="line">pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, <span class="literal">NULL</span>);</span><br><span class="line">pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></p><p>下面是处理信号机制，在这里面需要对<code>bio_mutex[type]</code>加锁的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line"><span class="comment">/* Block SIGALRM so we are sure that only the main thread will</span></span><br><span class="line"><span class="comment"> * receive the watchdog signal. */</span></span><br><span class="line">sigemptyset(&amp;sigset);</span><br><span class="line">sigaddset(&amp;sigset, SIGALRM);</span><br><span class="line"><span class="keyword">if</span> (pthread_sigmask(SIG_BLOCK, &amp;sigset, <span class="literal">NULL</span>))</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">        <span class="string">"Warning: can't mask SIGALRM in bio.c thread: %s"</span>, strerror(errno));</span><br></pre></td></tr></table></figure></p><p>下面的循环是一个经典的生产者消费者模型，我们这个函数是消费者。因此，如果我们检查到自己的队列是空的，那么就在条件变量<code>bio_newjob_cond[type]</code>上面等待，我们还需要同时传入<code>bio_mutex[type]</code>，因为条件变量的实现需要对这个mutex加锁或者解锁。如果说队列不是空的，就<strong>读取</strong>队头，<strong>但是不实际pop</strong>，并且解锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The loop always starts with the lock hold. */</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(bio_jobs[type]) == <span class="number">0</span>) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;bio_newjob_cond[type],&amp;bio_mutex[type]);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Pop the job from the queue. */</span></span><br><span class="line">    ln = listFirst(bio_jobs[type]);</span><br><span class="line">    job = ln-&gt;value;</span><br><span class="line">    <span class="comment">/* It is now possible to unlock the background system as we know have</span></span><br><span class="line"><span class="comment">     * a stand alone job structure to process.*/</span></span><br><span class="line">    pthread_mutex_unlock(&amp;bio_mutex[type]);</span><br></pre></td></tr></table></figure></p><p>下面就是根据任务类型，去做相应的工作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process the job accordingly to its type. */</span></span><br><span class="line"><span class="keyword">if</span> (type == BIO_CLOSE_FILE) &#123;</span><br><span class="line">    close((<span class="keyword">long</span>)job-&gt;arg1);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_AOF_FSYNC) &#123;</span><br><span class="line">    redis_fsync((<span class="keyword">long</span>)job-&gt;arg1);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == BIO_LAZY_FREE) &#123;</span><br><span class="line">    <span class="comment">/* What we free changes depending on what arguments are set:</span></span><br><span class="line"><span class="comment">     * arg1 -&gt; free the object at pointer.</span></span><br><span class="line"><span class="comment">     * arg2 &amp; arg3 -&gt; free two dictionaries (a Redis DB).</span></span><br><span class="line"><span class="comment">     * only arg3 -&gt; free the skiplist. */</span></span><br><span class="line">    <span class="keyword">if</span> (job-&gt;arg1)</span><br><span class="line">        lazyfreeFreeObjectFromBioThread(job-&gt;arg1);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg2 &amp;&amp; job-&gt;arg3)</span><br><span class="line">        lazyfreeFreeDatabaseFromBioThread(job-&gt;arg2,job-&gt;arg3);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (job-&gt;arg3)</span><br><span class="line">        lazyfreeFreeSlotsMapFromBioThread(job-&gt;arg3);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    serverPanic(<span class="string">"Wrong job type in bioProcessBackgroundJobs()."</span>);</span><br><span class="line">&#125;</span><br><span class="line">zfree(job);</span><br></pre></td></tr></table></figure></p><p>等我们处理完了，再把对应的节点pop出来。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/* Lock again before reiterating the loop, if there are no longer</span></span><br><span class="line"><span class="comment">         * jobs to process we'll block again in pthread_cond_wait(). */</span></span><br><span class="line">        pthread_mutex_lock(&amp;bio_mutex[type]);</span><br><span class="line">        listDelNode(bio_jobs[type],ln);</span><br><span class="line">        bio_pending[type]--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unblock threads blocked on bioWaitStepOfType() if any. */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;bio_step_cond[type]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h1><p>RDB机制的调用链（从下到上）如下所示：</p><ol><li><code>startSaving</code><ol><li><code>rdbSave</code><ol><li><code>flushAllDataAndResetRDB</code><ol><li><code>flushallCommand</code><br> <code>FLUSHALL</code>指令</li></ol></li><li><code>saveCommand</code><br> <code>SAVE</code>指令</li><li><code>rdbSaveBackground</code><ol><li><code>bgsaveCommand</code><br> <code>BGSAVE</code>指令</li></ol></li></ol></li></ol></li></ol><h2 id="rdbSave"><a href="#rdbSave" class="headerlink" title="rdbSave"></a>rdbSave</h2><p>观察函数签名，将一个结构<code>rsi</code>存到文件<code>filename</code>里面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSave</span><span class="params">(<span class="keyword">char</span> *filename, rdbSaveInfo *rsi)</span></span></span><br></pre></td></tr></table></figure></p><p>首先是尝试创建临时的rdb文件，这里先创建临时文件，可能是为了防止RDB过程执行到一半宕掉了，导致写的RDB文件不全或者有问题。这样等到确定成功再改名会好一点？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-%d.rdb"</span>, (<span class="keyword">int</span>) getpid());</span><br></pre></td></tr></table></figure></p><p>如果文件创建失败，会产生错误日志<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverLog(LL_WARNING,</span><br><span class="line">    <span class="string">"Failed opening the RDB file %s (in server root dir %s) "</span></span><br><span class="line">    <span class="string">"for saving: %s"</span>,</span><br><span class="line">    filename,</span><br><span class="line">    cwdp ? cwdp : <span class="string">"unknown"</span>,</span><br><span class="line">    strerror(errno));</span><br></pre></td></tr></table></figure></p><p>下面就是真正的dump过程。首先创建一个rio对象rdb，并且调用函数<code>startSaving</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">startSaving(RDBFLAGS_NONE);</span><br></pre></td></tr></table></figure></p><p>这个函数根据传入的<code>rdbflags</code>，向Redis发送事件。有关事件模块的内容，我们不在这里进行论述。需要注意，函数中额外检查了pid，从而确定是同步RDB还是异步RDB。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSaving</span><span class="params">(<span class="keyword">int</span> rdbflags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Fire the persistence modules end event. */</span></span><br><span class="line">    <span class="keyword">int</span> subevent;</span><br><span class="line">    <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE)</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_AOF_START;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (getpid()!=server.pid)</span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_RDB_START;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        subevent = REDISMODULE_SUBEVENT_PERSISTENCE_SYNC_RDB_START;</span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_PERSISTENCE,subevent,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的<code>rdbflags</code>有下面的取值</p><ol><li><code>RDBFLAGS_NONE</code><br> 在<code>rdbSave</code>中调用</li><li><code>RDBFLAGS_AOF_PREAMBLE</code><br> 是否用于AOF机制</li><li><code>RDBFLAGS_REPLICATION</code><br> 是否用于主从复制</li><li><code>RDBFLAGS_ALLOW_DUP</code><br> 这是一个选项</li></ol><p>如果开启了<code>rdb_save_incremental_fsync</code>增量写盘，就设置一下rio的autosync字段，<code>REDIS_AUTOSYNC_BYTES</code>默认是32MB。容易看出，写32MB才刷盘，如果此时系统宕机，Redis的持久性是得不到保障的，这个在我们对InnoDB的介绍中也出现过。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.rdb_save_incremental_fsync)</span><br><span class="line">    rioSetAutoSync(&amp;rdb,REDIS_AUTOSYNC_BYTES);</span><br></pre></td></tr></table></figure></p><p>下面是核心逻辑<code>rdbSaveRio</code>，我们在后面专门讨论<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rdbSaveRio(&amp;rdb,&amp;error,RDBFLAGS_NONE,rsi) == C_ERR) &#123;</span><br><span class="line">    errno = error;</span><br><span class="line">    <span class="keyword">goto</span> werr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面执行fflush，将C库缓冲区写到内核缓冲区，再调用fsync强制落盘。由于RDB类似于写checkpoint而不是写日志，所以这边写完直接刷盘，不需要统计autosync。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure data will not remain on the OS's output buffers */</span></span><br><span class="line"><span class="keyword">if</span> (fflush(fp) == EOF) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (fsync(fileno(fp)) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (fclose(fp) == EOF) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure></p><p>下面调用<code>rename</code>转换成正式的名字，调用<code>stopSaving(1)</code>发送成功事件。如果rename失败，就发送失败事件，并且调用<code>unlink</code>删除临时文件。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* Use RENAME to make sure the DB file is changed atomically only</span></span><br><span class="line"><span class="comment">     * if the generate DB file is ok. */</span></span><br><span class="line">    <span class="keyword">if</span> (rename(tmpfile,filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> *cwdp = getcwd(cwd,MAXPATHLEN);</span><br><span class="line">        serverLog(...);</span><br><span class="line">        unlink(tmpfile);</span><br><span class="line">        stopSaving(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"DB saved on disk"</span>);</span><br><span class="line">    server.dirty = <span class="number">0</span>;</span><br><span class="line">    server.lastsave = time(<span class="literal">NULL</span>);</span><br><span class="line">    server.lastbgsave_status = C_OK;</span><br><span class="line">    stopSaving(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Write error saving DB on disk: %s"</span>, strerror(errno));</span><br><span class="line">    fclose(fp);</span><br><span class="line">    unlink(tmpfile);</span><br><span class="line">    stopSaving(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br></pre></td></tr></table></figure></p><h2 id="rdbSaveRio"><a href="#rdbSaveRio" class="headerlink" title="rdbSaveRio"></a>rdbSaveRio</h2><p>首先看一下<code>dump.rdb</code>的内容，他通常位于redis的安装目录下。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">REDIS0006</span>þ^@^@^<span class="keyword">Ac</span>À^<span class="keyword">B</span>^@^<span class="keyword">Ab</span>À^<span class="keyword">A</span>^@^<span class="keyword">Aa</span>À^@ÿ&lt;<span class="keyword">92</span>&gt;?<span class="keyword">6</span>Ä<span class="keyword">x</span>^<span class="keyword">B</span>±Ä</span><br></pre></td></tr></table></figure></p><p>照例查看函数声明。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> rdbflags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>首先写入magic，和全局以及所有模块的辅助信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">    rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line"><span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,RDB_VERSION);</span><br><span class="line"><span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,rdbflags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_BEFORE_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure></p><p>下面对于每一个数据库<code>j</code>，进行dump写入<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">    redisDb *db = server.db+j;</span><br><span class="line">    dict *d = db-&gt;dict;</span><br><span class="line">    <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p><p>这里获得一个<a href="/2018/07/23/redis_learn_object/">安全迭代器</a>，也就是说在这个迭代器存在的时候是停止Rehash的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">di = dictGetSafeIterator(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the SELECT DB opcode */</span></span><br></pre></td></tr></table></figure></p><p>写入<code>RDB_OPCODE_SELECTDB</code>这个op，并保存一些元数据：</p><ol><li>当前db的编号</li><li>当前db的size</li><li>当前db的expires链表的size</li></ol><p>这些元数据会通过提前写入的<code>RDB_OPCODE_</code>进行区分。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Write the RESIZE DB opcode. */</span></span><br><span class="line"><span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">db_size = dictSize(db-&gt;dict);</span><br><span class="line">expires_size = dictSize(db-&gt;expires);</span><br><span class="line"><span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure></p><p>下面，遍历迭代器，以存储实际的数据。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line"><span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    sds keystr = dictGetKey(de);</span><br><span class="line">    robj key, *o = dictGetVal(de);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">    initStaticStringObject(key,keystr);</span><br></pre></td></tr></table></figure></p><p>函数<code>getExpire</code>是用来获取key的过期时间的，我们需要同时将过期时间也写到RDB里面。而过期时间是单独存放在<code>db-&gt;expires</code>里面的，所以这里需要额外取出来，再存进去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">        expire = getExpire(db,&amp;key);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">         * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">         * order to have a smaller final write. */</span></span><br><span class="line">        <span class="keyword">if</span> (rdbflags &amp; RDBFLAGS_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">            rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">        &#123;</span><br><span class="line">            processed = rdb-&gt;processed_bytes;</span><br><span class="line">            aofReadDiffFromParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面这些代码不太清楚是什么<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment"> * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment"> * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment"> * master will send us. */</span></span><br><span class="line"><span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">    di = dictGetIterator(server.lua_scripts);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *body = dictGetVal(de);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">"lua"</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">goto</span> werr;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rdbSaveModulesAux(rdb, REDISMODULE_AUX_AFTER_RDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br></pre></td></tr></table></figure></p><p>最后，存入一个EOF和CRC64校验码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="flushAllDataAndResetRDB"><a href="#flushAllDataAndResetRDB" class="headerlink" title="flushAllDataAndResetRDB"></a>flushAllDataAndResetRDB</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAllDataAndResetRDB</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    server.dirty += emptyDb(<span class="number">-1</span>,flags,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) killRDBChild();</span><br><span class="line">    <span class="keyword">if</span> (server.saveparamslen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Normally rdbSave() will reset dirty, but we don't want this here</span></span><br><span class="line"><span class="comment">         * as otherwise FLUSHALL will not be replicated nor put into the AOF. */</span></span><br><span class="line">        <span class="keyword">int</span> saved_dirty = server.dirty;</span><br><span class="line">        rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">        rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">        rdbSave(server.rdb_filename,rsiptr);</span><br><span class="line">        server.dirty = saved_dirty;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(USE_JEMALLOC)</span></span><br><span class="line">    <span class="comment">/* jemalloc 5 doesn't release pages back to the OS when there's no traffic.</span></span><br><span class="line"><span class="comment">     * for large databases, flushdb blocks for long anyway, so a bit more won't</span></span><br><span class="line"><span class="comment">     * harm and this way the flush and purge will be synchroneus. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; EMPTYDB_ASYNC))</span><br><span class="line">        jemalloc_purge();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h1><p>AOF机制的调用链（从下到上）如下所示：</p><ol><li><code>feedAppendOnlyFile</code><ol><li><code>propagate</code><br> 通常在各个模块中被带有<code>PROPAGATE_AOF|PROPAGATE_REPL</code>参数地调用</li></ol></li></ol><p><a href="/2018/07/23/redis_learn_object/">在key过期时，<code>propagateExpire</code>会被调用，从而发送过期消息给AOF</a>。</p><h2 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h2><h3 id="feedAppendOnlyFile"><a href="#feedAppendOnlyFile" class="headerlink" title="feedAppendOnlyFile"></a>feedAppendOnlyFile</h3><p>首先看参数，<code>dictid</code>实际上表示当前redis数据库的id<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>下面的这些<code>cat...Command</code>方法，实际上都是根据操作去重新组装回命令。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">sds buf = sdsempty();</span><br><span class="line">robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The DB this command was targeting is not the same as the last command</span></span><br><span class="line"><span class="comment"> * we appended. To issue a SELECT command is needed. */</span></span><br><span class="line"><span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">    <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</span><br><span class="line">    buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">    server.aof_selected_db = dictid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">    cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">    <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">    buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">    <span class="comment">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exarg || pxarg) &#123;</span><br><span class="line">        <span class="comment">/* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* All the other commands don't need translation or need the</span></span><br><span class="line"><span class="comment">     * same translation already operated in the command vector</span></span><br><span class="line"><span class="comment">     * for the replication itself. */</span></span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数<code>sdscatlen</code>将<code>buf</code>追加到<code>server.aof_buf</code>末尾，类似于concat，但这个取名有点迷惑，让人觉得是category的简写。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></span><br><span class="line"><span class="comment"> * of re-entering the event loop, so before the client will get a</span></span><br><span class="line"><span class="comment"> * positive reply about the operation performed. */</span></span><br><span class="line"><span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">    server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br></pre></td></tr></table></figure></p><p>如果<code>BGREWRITEAOF</code>正在进行，还需要将命令追加到重写缓存中，记录当前正在重写的AOF文件和数据库当前状态的差异。这个命令用于异步执行一个AOF文件重写操作，重写会创建一个当前AOF文件的体积优化版本。即使<code>BGREWRITEAOF</code>执行失败，也不会有任何数据丢失，因为旧的AOF在<code>BGREWRITEAOF</code>成功之前不会被修改。<br>为什么要支持AOF重写呢？考虑下面的情形：对一个计数器调用了100次<code>INCR</code>，AOF文件需要使用100个条目来记录。但实际上只使用一条<code>SET</code>保存最后的值就行了。所以<code>BGREWRITEAOF</code>可以在不打断服务客户端的情况下，重建AOF文件，这个文件包含重建当前数据集所需的最少命令。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aofRewriteBufferAppend"><a href="#aofRewriteBufferAppend" class="headerlink" title="aofRewriteBufferAppend"></a>aofRewriteBufferAppend</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Append data to the AOF rewrite buffer, allocating new blocks if needed. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aofRewriteBufferAppend</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">long</span> len)</span> </span>&#123;</span><br><span class="line">    listNode *ln = listLast(server.aof_rewrite_buf_blocks);</span><br><span class="line">    aofrwblock *block = ln ? ln-&gt;value : <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        <span class="comment">/* If we already got at least an allocated block, try appending</span></span><br><span class="line"><span class="comment">         * at least some piece into it. */</span></span><br><span class="line">        <span class="keyword">if</span> (block) &#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">long</span> thislen = (block-&gt;<span class="built_in">free</span> &lt; len) ? block-&gt;<span class="built_in">free</span> : len;</span><br><span class="line">            <span class="keyword">if</span> (thislen) &#123;  <span class="comment">/* The current block is not already full. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(block-&gt;buf+block-&gt;used, s, thislen);</span><br><span class="line">                block-&gt;used += thislen;</span><br><span class="line">                block-&gt;<span class="built_in">free</span> -= thislen;</span><br><span class="line">                s += thislen;</span><br><span class="line">                len -= thislen;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len) &#123; <span class="comment">/* First block to allocate, or need another block. */</span></span><br><span class="line">            <span class="keyword">int</span> numblocks;</span><br><span class="line"></span><br><span class="line">            block = zmalloc(<span class="keyword">sizeof</span>(*block));</span><br><span class="line">            block-&gt;<span class="built_in">free</span> = AOF_RW_BUF_BLOCK_SIZE;</span><br><span class="line">            block-&gt;used = <span class="number">0</span>;</span><br><span class="line">            listAddNodeTail(server.aof_rewrite_buf_blocks,block);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Log every time we cross more 10 or 100 blocks, respectively</span></span><br><span class="line"><span class="comment">             * as a notice or warning. */</span></span><br><span class="line">            numblocks = listLength(server.aof_rewrite_buf_blocks);</span><br><span class="line">            <span class="keyword">if</span> (((numblocks+<span class="number">1</span>) % <span class="number">10</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> level = ((numblocks+<span class="number">1</span>) % <span class="number">100</span>) == <span class="number">0</span> ? LL_WARNING :</span><br><span class="line">                                                         LL_NOTICE;</span><br><span class="line">                serverLog(level,<span class="string">"Background AOF buffer size: %lu MB"</span>,</span><br><span class="line">                    aofRewriteBufferSize()/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Install a file event to send data to the rewrite child if there is</span></span><br><span class="line"><span class="comment">     * not one already. */</span></span><br><span class="line">    <span class="keyword">if</span> (aeGetFileEvents(server.el,server.aof_pipe_write_data_to_child) == <span class="number">0</span>) &#123;</span><br><span class="line">        aeCreateFileEvent(server.el, server.aof_pipe_write_data_to_child,</span><br><span class="line">            AE_WRITABLE, aofChildWriteDiffData, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="catAppendOnlyExpireAtCommand"><a href="#catAppendOnlyExpireAtCommand" class="headerlink" title="catAppendOnlyExpireAtCommand"></a>catAppendOnlyExpireAtCommand</h3><p>我们抽取一个<code>cat...Command</code>进行分析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">catAppendOnlyExpireAtCommand</span><span class="params">(sds buf, struct redisCommand *cmd, robj *key, robj *seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> when;</span><br><span class="line">    robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure we can use strtoll */</span></span><br><span class="line">    seconds = getDecodedObject(seconds);</span><br><span class="line">    when = strtoll(seconds-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* Convert argument into milliseconds for EXPIRE, SETEX, EXPIREAT */</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == setexCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Convert into absolute time for EXPIRE, PEXPIRE, SETEX, PSETEX */</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand)</span><br><span class="line">    &#123;</span><br><span class="line">        when += mstime();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Redis中的引用计数规则，让人觉得有点难懂，原因是有的对象是由被调用者而不是调用者释放的，但在这里的代码基本都是由调用者释放（调用<code>decrRefCount</code>）的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    decrRefCount(seconds);</span><br><span class="line">    argv[<span class="number">0</span>] = createStringObject(<span class="string">"PEXPIREAT"</span>,<span class="number">9</span>);</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line">    argv[<span class="number">2</span>] = createStringObjectFromLongLong(when);</span><br><span class="line">    buf = catAppendOnlyGenericCommand(buf, <span class="number">3</span>, argv);</span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="刷盘"><a href="#刷盘" class="headerlink" title="刷盘"></a>刷盘</h2><h3 id="flushAppendOnlyFile"><a href="#flushAppendOnlyFile" class="headerlink" title="flushAppendOnlyFile"></a>flushAppendOnlyFile</h3><p>服务器先写AOF，再返回给客户端。因为客户端进行写操作的机会是在event loop中，我们需要将所有的AOF写先缓存起来，并且在重新进入event loop前进行刷盘。<br>目前AOF刷盘有几种策略：</p><ol><li>每个命令刷盘一次<br> 这也是最安全和最慢的</li><li>每秒刷盘一次(everysec)</li><li>从不刷盘</li></ol><p>当采用everysec方式的时候，如果后台线程有在fsync，那么会延迟这次fsync，这是因为Linux上，<code>write(2)</code>调用也会被后台的fsync阻塞。当这种情况发生时，说明要尽快刷AOF缓存。所以会尝试在<code>serverCron()</code>里面刷。但是如果force是1，那么无论是否fsync，都强行写入。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AOF_WRITE_LOG_ERROR_RATE 30 <span class="comment">/* Seconds between errors logging. */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Check if we need to do fsync even the aof buffer is empty,</span></span><br><span class="line"><span class="comment">         * because previously in AOF_FSYNC_EVERYSEC mode, fsync is</span></span><br><span class="line"><span class="comment">         * called only when aof buffer is not empty, so if users</span></span><br><span class="line"><span class="comment">         * stop write commands before fsync called in one second,</span></span><br><span class="line"><span class="comment">         * the data in page cache cannot be flushed in time. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">            server.aof_fsync_offset != server.aof_current_size &amp;&amp;</span><br><span class="line">            server.unixtime &gt; server.aof_last_fsync &amp;&amp;</span><br><span class="line">            !(sync_in_progress = aofFsyncInProgress())) &#123;</span><br><span class="line">            <span class="keyword">goto</span> try_fsync;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        sync_in_progress = aofFsyncInProgress();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></span><br><span class="line"><span class="comment">         * If the fsync is still in progress we can try to delay</span></span><br><span class="line"><span class="comment">         * the write for a couple of seconds. */</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No previous write postponing, remember that we are</span></span><br><span class="line"><span class="comment">                 * postponing the flush and return. */</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></span><br><span class="line"><span class="comment">                 * than two seconds this is still ok. Postpone again. */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></span><br><span class="line"><span class="comment">             * over two seconds. */</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></span><br><span class="line"><span class="comment">     * at least if the filesystem we are writing is a real physical one.</span></span><br><span class="line"><span class="comment">     * While this will save us against the server being killed I don't think</span></span><br><span class="line"><span class="comment">     * there is much to do about the whole server stopping for power problems</span></span><br><span class="line"><span class="comment">     * or alike */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_sleep &amp;&amp; sdslen(server.aof_buf)) &#123;</span><br><span class="line">        usleep(server.aof_flush_sleep);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line">    <span class="comment">/* We want to capture different events for delayed writes:</span></span><br><span class="line"><span class="comment">     * when the delay happens with a pending fsync, or with a saving child</span></span><br><span class="line"><span class="comment">     * active, and when the above two conditions are missing.</span></span><br><span class="line"><span class="comment">     * We also use an additional event name to save all samples which is</span></span><br><span class="line"><span class="comment">     * useful for graphing / monitoring purposes. */</span></span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-pending-fsync"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasActiveChildProcess()) &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-active-child"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-alone"</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"aof-write"</span>,latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We performed the write so reset the postponed flush sentinel to zero. */</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Log the AOF write error and record the error code. */</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Short write while writing to "</span></span><br><span class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></span><br><span class="line">                                       <span class="string">"expected=%lld)"</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">"Could not remove short write "</span></span><br><span class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></span><br><span class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></span><br><span class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If the ftruncate() succeeded we can set nwritten to</span></span><br><span class="line"><span class="comment">                 * -1 since there is no longer partial data into the AOF. */</span></span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle the AOF write error. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></span><br><span class="line"><span class="comment">             * reply for the client is already in the output buffers, and we</span></span><br><span class="line"><span class="comment">             * have the contract with the user that on acknowledged write data</span></span><br><span class="line"><span class="comment">             * is synced on disk. */</span></span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></span><br><span class="line"><span class="comment">             * set an error to stop accepting writes as long as the error</span></span><br><span class="line"><span class="comment">             * condition is not cleared. */</span></span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></span><br><span class="line"><span class="comment">             * was no way to undo it with ftruncate(2). */</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">         * OK state and log the event. */</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></span><br><span class="line"><span class="comment">     * arena size of 4k minus some overhead (but is otherwise arbitrary). */</span></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">try_fsync:</span><br><span class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></span><br><span class="line"><span class="comment">     * children doing I/O in the background. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp; hasActiveChildProcess())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform the fsync if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">/* redis_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        redis_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</span><br><span class="line">        server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) &#123;</span><br><span class="line">            aof_background_fsync(server.aof_fd);</span><br><span class="line">            server.aof_fsync_offset = server.aof_current_size;</span><br><span class="line">        &#125;</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis持久化机制包括AOF和RDB两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RDB保存二进制形式的数据库快照。&lt;/li&gt;
&lt;li&gt;AOF以协议文本的方式，记录数据库写入的指令。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文详细介绍这两种方式的实现，以及涉及到主从复制的情况。由于持久化涉及Redis文件系统RIO，所以也会对RIO进行介绍。&lt;br&gt;作为Redis源码分析的系列文章，本文使用的版本和&lt;a href=&quot;/2018/07/23/redis_learn_object/&quot;&gt;Redis底层对象实现原理分析&lt;/a&gt;、&lt;a href=&quot;/2020/10/18/redis-sentinel/&quot;&gt;Redis Sentinel实现原理分析&lt;/a&gt;等文章是相同的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="redis" scheme="http://www.calvinneo.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>长沙攻略</title>
    <link href="http://www.calvinneo.com/2021/01/12/meet-in-changsha/"/>
    <id>http://www.calvinneo.com/2021/01/12/meet-in-changsha/</id>
    <published>2021-01-12T15:20:33.000Z</published>
    <updated>2021-01-14T04:25:48.861Z</updated>
    
    <content type="html"><![CDATA[<p>长沙游记<br><a id="more"></a></p><h1 id="D0"><a href="#D0" class="headerlink" title="D0"></a>D0</h1><p>29号一早就收到Z的消息，说天鹅湖啥的地方有疫情了。</p><p>中午纠结了很久，考虑到下午两点之后退订民宿就要扣钱了，所以我先退了。下午研究了一下，定了一个全季。在携程上定很坑，要么就选择到付，这样的话我担心不一定有房，并且因为我们航班晚，所以还要交保证金。或者就选择立即付款，这样的话过了30号晚上六点钟取消的话就会扣掉所有的钱。想了想，到了明天六点钟肯定知道去不去了，所以先定了全季。<br>晚上发现我ld周末还去了趟成都（那时候成都应该还有中风险吧）也没事，胆子大了起来。临走前，又和ld确认了一下，确实不需要备案，所以就走了。</p><p>30号早上一起来就看无锡的疫情，果然和深圳一样，没有变成中风险，但是据说无锡的部分街道已经不让公职人员走了。于是我们等Z下午的会议，看有没有不让走，如果有不让走我们就不走。<br>开完会发现没有不让走，我咨询了一下我ld要不要报备，说如果所在城市没有中风险区就行。这样我们胆子就大了，不仅把全季退掉了，还用高于原来大概100块的价格把那个民宿又定回来了。</p><p>因为是周三健康日，所以我六点钟就走了，去上海站搭乘到无锡新区的火车。这班车感觉还是相当友好的，因为新区到机场很方便。</p><p>到了新区站发现难受了，这个三号线貌似八到十分钟一班，这也太坑了。到了机场更是坑，出口出来是1号口国际出发，被封闭了。一直往前走了半天，才到唯一的入口6号口。中途还有两个小姐姐貌似要赶九点十分的飞机，急得要死。不过进了机场发现机场好小，我们把三明治和饭团都吃掉了，酸牛奶喝掉了好几个。无锡机场安检贼严，我们的酸奶都不让带进去。</p><p>登机的时候去长沙的队伍真的是浩浩汤汤，一点不逊于旁边的深圳队伍，果然是网红城市。</p><h1 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h1><p>后来想想，31号的人相比后面并不是很多了。<br>我们从民宿出来一直往西走就能到黄兴广场了，中间还能路过化龙池文和友。后来到博物馆我才知道化龙池是个地名，我当时以为是把龙虾消化掉的意思。<br>到了黄兴广场步行街，中间是一个辣条博物馆，当时没咋要排队，但我们急着喝茶颜悦色就没去。晚上的时候已经排了老长的队了，站在门口看了下，原来是辣条王子的营销店。</p><p>往左拐，往前走了一点，看到第一家茶颜悦色居然还没开门（后来发现我们家门口的那家盟重旁边的茶颜要到下午三点钟才开），再往前走一点，是一家开了门的，居然已经排起队了，这还没到11点呢。<br>茶颜右边是一家罗记臭豆腐，旁边是一家黑色经典臭豆腐。黑色经典很大，是一家零售的点，不过角落里也挖了一块卖现炸的臭豆腐和大香肠的。茶颜悦色里面的广告一直在推荐旁边的黑色经典臭豆腐，但是那家店外面排队的人却稀稀拉拉。</p><p>茶颜悦色的点餐规则比较奇怪，首先你先要排队点单，点完之后会给你一个叫号器和小票，然后你可以四处闲逛等到叫号器叫号。叫号器叫到你之后，实际上你的奶茶才开始做，所以这样就保证了最新鲜的口感。我们前面的人都是疯子一样五六杯地点，所以我们要等好久。过了会，我觉得无聊，就去排旁边的黑色经典臭豆腐了。</p><p>吃完了黑色经典，我们端着奶茶继续打卡。步行街上人很杂，有个人给了个充电宝，要我去做网店测评，我以为写一个手机号就行了，但是又要做调查，我就先走了。</p><p>走到步行街的终点往右拐，开始走到小巷子里面，这边有我们要打卡的第一家店，金记糖油粑粑。到的时候这家店队已经很长了，但是因为他是直接和糖葫芦一样串起来卖，所以实际还是挺快的。吃起来也不是特别惊艳，很油，比较甜，感觉像有点酥的麻球。</p><p>接着，我们就再往前走，去杨爹甜酒。不得不说，长沙的小巷子里面还真的蛮好看的。在杨爹甜酒点了大众点评的前三。这家店似乎也是上过天天向上的（感觉天天向上真的喜欢捧长沙小吃）。招牌甜酒点了小份的，感觉就和酒酿差不多的味道。比较好吃的是酒酿梅子冻，虽然很冷，但梅子的酸味和酒的略微的刺激使得口感非常清爽。相比之下甜酒汤圆冲蛋就比较一般了，它是热的，感觉就是把蛋放到甜酒汤圆里面，和我们家里一个味道。</p><p>吃完了，感觉时候不早了，于是打算启程去长沙博物馆。幽兰拿铁喝完还有好多奶油，讲道理还是蛮好吃的，我刮了点吃掉，才扔到路边垃圾桶里面。然后就进地铁站，一样望下去，还是三四家茶颜，还有一家茶颜的外卖镖局，说是只卖外卖。Z觉得茶颜的外卖并不好（店里面的职员也是这么说的），因为奶油要新鲜啥的吧。当然，后来我们点了他家的外卖，其实还好，奶油是分开装的，非常豪华。</p><p>长沙地铁是要专门下一个APP的，然后还要交10块钱的保证金。一号线要等6分钟，差评。我们做到了北辰三角洲，居然还有折扣，这可是在深圳和上海都没有的待遇啊。</p><p>北辰三角洲出站，发现一家奈雪，好惨不提了，在走几步是一家茶颜，似乎外面没人排队，正准备感叹，远离五一广场就不要排队了，定睛一看，发现里面好多人。这边感觉是比较新的地方，建了很多长沙开头的公共设施，感觉是富人区一样，查了一下北辰奥园房价一万七，好便宜。</p><p>我们在下面走了好久，还是停车场，最后我觉得一定要上去。所以我在一个写着“食堂正常开放”的墙的台阶那边坚持爬上去，豁然开朗，眼前是一个大的广场，串联起了音乐厅、博物馆等建筑。</p><p>长沙博物馆进去实际上不要预约，查健康码就行，不过Z信号很不好，还是我帮她查的。然后就换衣服上厕所，期间我看了一下长沙博物馆的留言簿，各种逗比。查了一下，据说他们家的食堂不错（神奇），不过问博物馆说只有个咖啡厅。</p><p>长沙博物馆一共两层，我们照例走错了，从第二层开始看的。</p><p>长沙博物馆接近两个小时就逛完了，里面基本没啥人，然后Z就说应该今天去湖南博物馆的，因为明天人肯定很多。然后我就说要不我们今天先去看一部分湖南博物馆吧，结果打开一看，约满了。看了看外面的太阳，还不错，干脆去橘子洲逛逛吧。</p><p>我们骑车回到北辰三角洲，准备去之前看到的那家店买，刚进店就被告知有人点了30杯，要等一个多小时……</p><p>于是我们直接坐地铁去了橘子洲。</p><p>考虑到时间也不早了，并且看了一下，海关站上车环岛线基本上没啥位置，所以我们坐地铁回去了。</p><p>从橘子洲回来，我们直接下了五一广场，进了新世界百货。又去排茶颜悦色了，它在下面一层，我看到有一个滑梯可以滑下去。茶颜悦色照例也是要排队的，说是50分钟，实际上最后排了半个小时。我在旁边又买了个聚美合的臭豆腐和香肠。他家的香肠还可以，但是臭豆腐太辣了。这次我们点了凤栖绿桂和抹茶菩提，都蛮好喝的。五一广场往南走就是黄兴路步行街，路的西侧有一个巨大的兰蔻的广告。这个时候路上人已经很多了，但是比后面两天人山人海比肩接踵的场景还是要好很多的。</p><p>我们的第一个目的地是邵师傅梅菜扣肉饼，这个一定要是吃黄兴路步行街的那一家，太平古街的那个感觉手艺不行，炸得焦了不少。此外还要注意，不是邵福记。口感是真的香，边边还是甜的，非常好吃，爆赞。</p><p>接着，我们去排武爹臭豆腐（虽然其实前面就两个人）。这老板感觉很闲鱼，一边炸豆腐一边刷手机。武爹臭豆腐非常非常脆，相比之下，黑色经典以多汁取胜。综合看来，黑色经典大于武爹大于聚美合，难怪只有黑色经典被大众点评推荐。</p><p>七点多在微信上面随便取了一个盟重的号，排接近300号，想着肯定是吃不到了吧。</p><p>晚上在鸽优群里闲聊，才发现大师明天也来长沙，这必定是要聚一波的了。</p><h1 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h1><p>今天早上（划掉，中午）的任务是去逛湖南博物馆，看千年干尸。湖南博物馆需要提前三天预约，我们29号的时候没有落下，但其实如果没约上的话可以去买特展票，最后湖南博物馆的两个特展都蛮有趣的，我们也都买票进去看了。</p><p>来了长沙就一定要嗦粉，搜一搜长沙推荐的粉店，有刘聋子、公交新村和周记粉店。其中周记粉店就在家门口，盟重的那条巷子里面，我们居然之前没有发现，看起来我们住的民宿真的是宝藏，我真的是天才。我们去的时候周记粉店正好迎来一波小高潮，队伍一直排到门外。他家点单是在门口，也就是说，你顺着队伍迈进门口之后就能点单了，点完会给你个单子，然后你拿着它继续排队，一直排到店最里面的厨房门口取餐，去完餐就可以坐在店里吃了。一般等排到还有四五个人的时候，就可以去占一个座位了。周记粉店的粉很好吃，但是最好吃的还是他家的肉饼蛋，感觉加了茴香或者啥香料，非常好吃。</p><p>为了节约肚子，我们指点了一碗粉，所以吃完周记我们还有肚子，于是就继续吃旁边的德天顺盖码饭。所谓盖码饭感觉就是盖浇饭，但是德天顺自称是盖码饭里面的爱马仕。这话倒也说得没错，进门的时候就感觉这家店是富丽堂皇，感觉有点全聚德的感觉，旁边还给你树两对联。进去上二楼才是店面，非常宽敞明亮。我们照例指点了一碗孜然牛肉，三十几块，还是蛮贵的。端上来发现料还可以，但多的是蒜苗，肉其实也不多。口感上不是很辣，其实还是非常下饭的，适合我们干饭人，如果你没有不小心吃到尖头椒的话。</p><p>吃完饭，得赶快去湖南博物馆了，那里没地铁，我们打了辆车，不过他刚在橘子洲大桥那边送客人，所以还要十来分钟才来，于是我们顺路又逛了逛附近的巷子，发现走着走着就到了盟重烧烤，颇有点之前在曾厝垵的感觉。车来了，我们在一个十字路口等了快三个红灯，终于到了湖南博物馆了。</p><p>湖南博物馆的寄存还是比较坑的，如果把衣服寄存到寄存柜的话，就还需要再额外走一段没有空调的地方。并且出门的时候你不能直接从大厅出门，而应该在大厅里面下楼。</p><p>从刘聋子出来，Z说有一个叫果呀呀的奶茶也蛮火的，但是自己一直没看到，于是我搜了下，IFS下面就有一个啊。于是我们往黄兴步行街方向走，准备去找果呀呀。在那个能看到我爱CS的路口，Z终于买了自己想要吃的荸荠（我觉得都是别人用手剥的，真的很脏，一个都没有吃）。</p><p>人是真的多。</p><p>这个果呀呀真难找，我们走到了那个宇宙中心交叉口才发现走过了，果呀呀似乎在商场里面，于是又走回去进商场（又是一堆人堵在门口找行程码）。进入商场找了一圈没找到，我脚很酸，就坐在优衣库里面等，过了一会，Z找到了并点好了，回来接我过去。又要穿过一道查健康码的门，真的是神奇。我们在果呀呀旁边的一家Switch体验店呆了会，不得不说，自从腾讯代理Switch以来，这些Switch体验店是雨后春笋一样啊。</p><p>Z想吃紫苏桃子姜，搜了一下，发现伍厚德堂是Top的，并且我们发现伍厚德堂是一家饭店而不是小吃店，还有其他一些不错的吃的，也打算尝试一下。伍厚德堂有两家，九龙仓的那一家网上说一般，所以我们去的是坡子街的那一家。穿过那个宇宙中心十字路口，我们发现自己又看到了梅干菜扣肉饼，果断又去排了下。这时候的队和前几天已经不一样了，前面大概有十几号人。因为人比较多，所以Z一直不让我喝果呀呀，但是我是忍不住了，就开下来喝了，确实非常好喝。看到队比较长，我就先去伍厚德堂拿号。到了伍厚德堂才发现，他家火爆到暂停线下取号了。</p><p>只好回来，此时饼也买好了。我们之前买的是他推荐的12块钱的瘦肉饼，这次还买了个10块钱的扣肉饼。扣肉饼感觉会肥一些，但是一点不腻，非常好吃。因为我脚头很累，我们就开始往回走，路上看到了么子烤肉，在化龙池旁边，所以进去取了个号，我们应该是七点十分取的，要排305桌，幸亏离得比较近，我们打算先回家。到家门口的茶颜悦色又排了两杯奶茶，把取号器拿到住的宾馆里面。因为我脚很累了，所以是Z在排，我在研究么子烤肉能不能线上看进度，但扫那个二维码看不到，并且他家的线上取号也停了。我们歇了大概二十分钟就又出发去取茶颜了，然后又去么子烤肉看了下情况。店员解释说原来我没有关注那个公众号，所以它没办法给我推送，然后他说我们还好等大约两个多小时，建议我们还剩五十桌的时候过来登记健康码啥的。考虑到么子烤肉的号过得并不是很快，我们又回家瘫着歇了会。到了十点的样子，我们看还有大概90桌的样子，就又出来了，到店里发现还有七八十桌，玩了会iPad，我想要不我再去看看黑色经典吧。跑到那边发现队伍还是贼长（你们不睡觉的么），于是又回来，路上买了个荸荠。又歇了会，发现队伍还是动得非常快了，终于在十点四十的时候我们吃上了。</p><p>不过么子烤肉确实很好吃，特别是他家的蜂蜜芥末酱很棒。可惜Z去调酱料的时候已经没有了，问服务员去加货，服务员说断货了（我估计是太晚了，不想再拆一包出来）。我跑去看了看，确实罐罐都空了，只好先刮一点出来。后来想到，不妨到楼下试试运气，发现楼下的罐罐里面还有很多，我就舀了好几勺。我们照着大众点评点的，感觉都很赞。大片牛油会附上海椒干碟，沾着不算很辣，但却很有风味。五花肉是腌制好的，非常好吃，有点之前在厦门吃的高烤的感觉。超嫩黑椒牛肉粒和虾滑的量很足。桂花年糕是最后吃得，小哥会帮你浇上自带的桂花糖浆，很好吃。</p><h1 id="D3"><a href="#D3" class="headerlink" title="D3"></a>D3</h1><p>正好大师他们住的宾馆距离伍厚德堂比较近，正好他们也没做攻略，于是他们就先去排。他们大概十点四十五到的，那边他们说只要等四个，并且11点才开门，于是我们赶快收拾收拾出发。不得不说，伍厚德堂的装修还是非常好看的，是类似民国的那种装潢，又有点欧式的风情，外面有个小喷泉台，里面还有小天井。我们进到二楼，大师已经在那边了，LP听了我的建议去买了邵师傅梅干菜扣肉饼。于是我们照着大众点评撸下去点了一些菜，然后服务员说季节原因，紫苏桃子姜不卖了。</p><p>不得不说，长沙的这些饭店是非常良心的。首先我们四个人总共才吃了200+，并且已经很饱了（可能是因为我们茶颜悦色喝多了）。其次，我们吃到一半发现桌上有个牌子说大众点评收藏送东西，有点类似于我们点的两个桃胶牛奶。于是就在上菜的时候问服务员，是不是桃胶牛奶，服务员说是的，然后我们就有点沮丧。然后结账的时候服务员真的就帮我们免掉了两个桃胶牛奶的钱，所以感觉他们还是很棒的。</p><p>吃完了我们就出发去橘子洲，一路上我们谈昨天的行程。原来大师他们昨天已经来过一趟橘子洲了，但是可能来的时候比较晚，所以沿途就有卖游览车票的人说这是最后一趟车去MZD雕塑了，于是就把他们忽悠上车了。然后到了雕塑就把他们丢下来，最后他们自己走回来了。当时天已经黑了，所以他们中途在沁园春长沙的石碑旁边拍了张很阴间的照片。</p><h1 id="D4"><a href="#D4" class="headerlink" title="D4"></a>D4</h1><p>今天是回程的日子，早上醒来，问了问大师他们的计划，原来是刚起，也没打算去省博了。问中午要不要约饭，推荐了一家剁椒鱼头。我感觉剁椒鱼头很辣，并且也有点远，我们退房行李不好拿，所以就没有想去。我说打算去吃夏记粉店，他们也OK。<br>到了夏记粉店，又是队伍排成长龙，比周记粉店还多。我和Z排了会，Z感觉还有很久，就先跑到几百米开外去点茶颜了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;长沙游记&lt;br&gt;</summary>
    
    
    
    
    <category term="游记" scheme="http://www.calvinneo.com/tags/游记/"/>
    
  </entry>
  
  <entry>
    <title>Bash介绍</title>
    <link href="http://www.calvinneo.com/2021/01/06/bash/"/>
    <id>http://www.calvinneo.com/2021/01/06/bash/</id>
    <published>2021-01-06T11:20:33.000Z</published>
    <updated>2021-01-06T13:36:31.800Z</updated>
    
    <content type="html"><![CDATA[<p>介绍Bash</p><a id="more"></a><h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">s</span>=abcdefghijk</span><br></pre></td></tr></table></figure><p>长度<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;#s&#125;</span></span></span><br><span class="line">11</span><br></pre></td></tr></table></figure></p><p>slice<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;s:1:3&#125;</span></span></span><br><span class="line">bcd</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;s:1:-1&#125;</span></span></span><br><span class="line">bcdefghij</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;s:-1:-1&#125;</span></span></span><br><span class="line">abcdefghijk</span><br><span class="line"><span class="meta">#</span><span class="bash"> t=aaabbbccc</span></span><br></pre></td></tr></table></figure></p><p>从头部的最长匹配，删除matching部分<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;t##a*b&#125;</span></span></span><br><span class="line">ccc</span><br></pre></td></tr></table></figure></p><p>从头部最短匹配<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;t#a*b&#125;</span></span></span><br><span class="line">bbccc</span><br></pre></td></tr></table></figure></p><p>失配<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;t#m*m&#125;</span></span></span><br><span class="line">aaabbbccc</span><br></pre></td></tr></table></figure></p><p>尾部匹配改成%</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li><code>$?</code><br> 上一个指令退出码</li><li><code>$$</code><br> 进程ID，等于BASHPID</li><li><code>$_</code><br> 上一个命令的最后一个参数</li><li><code>$!</code><br> 最近一个后台执行的异步命令（也就是后面加&amp;的）的进程 ID</li><li><code>$0</code><br> shell的名称，或者运行的shell脚本的名称，大于等于10的用${10}等</li><li><code>$#</code><br> 参数个数</li><li><p><code>$@</code><br> 空格分割的全部参数<br> 可以循环 $@</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p><code>$*</code><br> $IFS分割的全部参数，貌似要<code>echo &quot;$*&quot;</code>才行。IFS是Internal Field Separator<br> 注意<code>#@</code>和<code>$*</code>的行为在加引号之后不一样，<code>&quot;$*&quot;</code>会作为一个整体</p></li></ol><p>注意区分makefile的参数<code>$@</code>扩展成当前规则的目的文件名，<code>$&lt;</code>扩展成依赖列表中的第一个依赖文件，而`$^扩展成整个依靠的列表（除掉了里面所有重复的文件名）。</p><p>下面是一个供展示的bash脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$0</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> $-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"SHARP"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"AT"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"><span class="built_in">export</span> IFS=M</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"STAR"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"$*"</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"For AT \""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"For AT"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$@</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"For STAR \""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">"$*"</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"For STAR"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p><code>source</code>在当前sh执行脚本，而sh会创建一个新的</p><h1 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h1><p><code>if</code>后面可以跟任意数量的命令。这时，所有命令都会执行，但是判断真伪只看最后一个命令，即使前面所有命令都失败，只要最后一个命令返回<strong>0</strong>，就会执行then的部分。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">if</span> <span class="literal">false</span>; <span class="literal">true</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">'hello world'</span>; <span class="keyword">fi</span></span></span><br><span class="line">hello world</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">if</span> <span class="literal">true</span>; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">'hello world'</span>; <span class="keyword">fi</span></span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure></p><p>if结构的判断条件，一般使用test命令，有三种形式。第三种形式还支持正则判断，前两种不支持。expression 为真，test命令执行成功（返回值为0）；expression为伪，test命令执行失败（返回值为1）。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># type -a [[</span></span><br><span class="line">[[ is a <span class="keyword">shell</span><span class="bash"> keyword</span></span><br><span class="line"><span class="bash"><span class="comment"># type -a [ </span></span></span><br><span class="line"><span class="bash">[ is a shell <span class="built_in">builtin</span></span></span><br><span class="line"><span class="bash">[ is /usr/bin/[</span></span><br></pre></td></tr></table></figure></p><ol><li><p>写法一</p> <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test </span>expression</span><br></pre></td></tr></table></figure></li><li><p>写法二<br> 注意，因为中括号实际上是一个命令，所以左右都要有空格</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ expression ]</span><br></pre></td></tr></table></figure></li><li><p>写法三</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[ expression ]]</span></span><br></pre></td></tr></table></figure><p> 这种写法还支持正则表达式正则表达式<code>[[ expr =~ regex ]]</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MIN_VAL=1</span><br><span class="line">MAX_VAL=100</span><br><span class="line"></span><br><span class="line">INT=50</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$INT</span>"</span> =~ ^-?[0-9]+$ ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="variable">$INT</span> -ge <span class="variable">$MIN_VAL</span> &amp;&amp; <span class="variable">$INT</span> -le <span class="variable">$MAX_VAL</span> ]]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$INT</span> is within <span class="variable">$MIN_VAL</span> to <span class="variable">$MAX_VAL</span>."</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$INT</span> is out of range."</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"INT is not an integer."</span> &gt;&amp;2</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><p>还可以使用bash自己的<code>&amp;&amp;</code>，这个遵循短路原则<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ condition ] &amp;&amp; [ condition ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>等同样例<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[ -d "$dir_name" ]]</span> &amp;&amp; cd <span class="string">"$dir_name"</span> &amp;&amp; rm *</span><br></pre></td></tr></table></figure></p><p>等同于<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ ! -d <span class="string">"$dir_name"</span> ]]; then</span><br><span class="line">  echo <span class="string">"No such directory: '$dir_name'"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">  <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> ! cd <span class="string">"$dir_name"</span>; then</span><br><span class="line">  echo <span class="string">"Cannot cd to '$dir_name'"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">  <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br><span class="line"><span class="keyword">if</span> ! rm *; then</span><br><span class="line">  echo <span class="string">"File deletion failed. Check results"</span> &gt;&amp;<span class="number">2</span></span><br><span class="line">  <span class="keyword">exit</span> <span class="number">1</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数优于脚本，低于别名<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">  echo <span class="string">"Hello $1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数与变量相关的<code>$@</code>、<code>$0</code>等，与脚本一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍Bash&lt;/p&gt;</summary>
    
    
    
    
    <category term="Bash" scheme="http://www.calvinneo.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>Paxos算法</title>
    <link href="http://www.calvinneo.com/2021/01/06/paxos/"/>
    <id>http://www.calvinneo.com/2021/01/06/paxos/</id>
    <published>2021-01-06T11:20:33.000Z</published>
    <updated>2021-06-02T10:52:54.744Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。</p><a id="more"></a><h1 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h1><p>Paxos允许消息被任意延迟、丢包、重复，但不允许消息被损坏。<br>Basic Paxos弱化了Leader的概念，而使用了Proposer的概念。<br>Basic Paxos只对一个Value决议。这个Value实际上<a href="https://stackoverflow.com/questions/65175880/how-can-i-understand-value-in-bacis-paxos" target="_blank" rel="noopener">类似于Raft里面的一个Log Entry</a>，即<code>x=1</code>或者<code>y=42</code>之类的。根据原版论文<em>The part-time parliament</em>，这里的Value即法令，类似于禁止画画或者允许自由艺术等。<br>注意，一个Value被决定是chosen而不是accepted，即决议的过程是<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">propose<span class="function"><span class="params">(issue)</span> -&gt;</span> Accept<span class="function"> -&gt;</span> chosen</span><br></pre></td></tr></table></figure></p><h2 id="论证1"><a href="#论证1" class="headerlink" title="论证1"></a>论证1</h2><p>在论证1的部分，我们从原始要求倒推出我们需要维护的不变量P2b</p><h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><p>我们考虑没有丢包和机器故障，并且我们假设只有一个proposer。对于这样的一个平凡情况，我们可以得到下面的要求：<br>一个acceptor必须接受它收到的第一个proposal。</p><p>显然这个方案存在一个问题，不同的proposer可能提出不同的value，这会导致每个acceptor收到了不同的value，但其中没有一个value是占majority的。<br>这个问题导致我们需要让acceptor去accept多于一个proposal。为了区分这些proposal，就要引入proposal number。<br>一个Value被chosen，当具有这个Value的proposal已经被大部分的acceptor accept了。</p><h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><p>经过上面的论证，我们允许choose多个proposal，但我们必须保证所有被chosen的proposal都有相同的Value，因此我们提出下面的要求：<br>如果具有Value <code>v</code>的proposal被<strong>chosen</strong>了，那么对于任意更高的number的proposal，如果它被<strong>chosen</strong>，那么它就一定有Value <code>v</code>。</p><h3 id="P2a"><a href="#P2a" class="headerlink" title="P2a"></a>P2a</h3><p>我们就P2进一步推导，因为被chosen的前提是这个proposal要至少被一个acceptor Accept，所以我们可以通过满足下面这个更强的条件来满足P2：<br>如果具有Value <code>v</code>的proposal被<strong>chosen</strong>了，那么对于任意更高的number的proposal，如果它被任意的accpetor <strong>Accept</strong>，那么它就一定有Value <code>v</code>。</p><h3 id="P2b"><a href="#P2b" class="headerlink" title="P2b"></a>P2b</h3><p>注意，我们仍然需要满足要求P1，这样我们可以保证我们一定能接受一些proposal。<br>考虑下面的情况：</p><ol><li>一个新的proposer提交了一个更高的number的proposal，但是具有不同的Value；</li><li>一个之前从来没有收到过任何proposal的acceptor收到了这个proposal；</li><li>根据要求P1，这个acceptor需要accept这个proposal；</li><li>根据要求P2a，这个acceptor不能accept这个proposal；</li></ol><p>我们发现这里产生了矛盾，因此我们还需要继续强化要求P2a：<br>如果具有Value <code>v</code>的proposal被<strong>chosen</strong>了，那么对于任意更高的number的proposal，在它被任意proposer发出时，就一定有Value <code>v</code>。</p><h2 id="论证2"><a href="#论证2" class="headerlink" title="论证2"></a>论证2</h2><p>论证2紧接着论证1，讲述如何维护P2b性质。</p><h3 id="P2c"><a href="#P2c" class="headerlink" title="P2c"></a>P2c</h3><p>为了方便表示，规定<code>proposal(m,v)</code>表示具有number <code>n</code>和Value <code>v</code>的proposal。下面我们查看P2b是如何保证自己一直成立的。</p><p>我们考虑<code>proposal(m,v)</code>被chosen，那么我们要证明任何number大于<code>m</code>的<code>n</code>的proposal也有Value <code>v</code>。证明如下：<br>如果<code>m</code>被chosen，那么一定有大多数acceptor accept了这个proposal，这些acceptor属于集合<code>C</code>。再结合P2b，可以推出<code>C</code>中所有的acceptor都accept了从<code>m</code>到<code>n-1</code>的proposal，并且这些被accept的proposal都具有Value <code>v</code>。</p><p>对于任意包含大多数acceptor的集合<code>S</code>必须包含<code>C</code>中的至少一个成员，因此我们可以得出我们需要满足下面的要求P2c。</p><p>考虑一个proposer发出了<code>proposal(v,n)</code>，那么存在一个上述<code>S</code>，满足要求P2c：</p><ol><li>要么<code>S</code>中的成员都没有accept过低于<code>n</code>的proposal；</li><li>要么accept的最大的小于<code>n</code>的proposal的Value是<code>v</code>。</li></ol><h2 id="论证3"><a href="#论证3" class="headerlink" title="论证3"></a>论证3</h2><p>为了维护P2c，我们发现一个proposer在发出<code>n</code>这个proposal之前，需要检查最大的小于<code>n</code>的proposal，看它是否<strong>已经</strong>或者<strong>将要</strong>被某些acceptor Accept。前者是容易的，但是后者要做一个预测，并不是那么容易。</p><p>为了简化这个预测的流程，我们引入了一个提前的阶段，也就是proposer要求acceptor保证不会再去accept任何低于<code>n</code>的proposal了。</p><p>为此，我们得到下面的算法。</p><h3 id="Proposer-算法-Step1"><a href="#Proposer-算法-Step1" class="headerlink" title="Proposer 算法 Step1"></a>Proposer 算法 Step1</h3><p>proposer选择一个新的number <code>n</code>，发送请求<code>Prepare(n)</code>给某个集合中的所有acceptor。此时acceptor应该返回：</p><ol><li>保证不再接受<strong>小于</strong><code>n</code>的proposal；</li><li>目前最大的小于<code>n</code>的accept的proposal。</li></ol><h3 id="Proposer-算法-Step2"><a href="#Proposer-算法-Step2" class="headerlink" title="Proposer 算法 Step2"></a>Proposer 算法 Step2</h3><p>如果这个proposer收到了majority的acceptor的回复，那么就可以发送一个<code>Accept(n,v)</code>的请求。其中<code>n</code>是Prepare时候的<code>n</code>，<code>v</code>的选择则遵循下面的规则：</p><ol><li>如果没有人对<code>v</code>的值有proposal，那么这个proposer就可以任选<code>v</code>的值。这实际上对应了通常情况。</li><li>否则，就返回最大的小于<code>n</code>的proposal给出的<code>v</code>值。</li></ol><p>文章特别强调，Prepare请求和accept请求可以发送给不同的acceptor。</p><h3 id="Acceptor-算法-P1a"><a href="#Acceptor-算法-P1a" class="headerlink" title="Acceptor 算法 P1a"></a>Acceptor 算法 P1a</h3><p>一个acceptor可以安全地忽略任何的请求。</p><p>acceptor可以回应Prepare请求。</p><p>acceptor可以回应accept请求，去accept某个proposal，当且仅当它没有保证不接受这个请求，即：<br>当且仅当一个acceptor没有回应<strong>大于</strong><code>n</code>的Prepare请求，它可以接受一个<code>n</code>编号的accept请求。可以看出，P1是P1a的特例。</p><p>也就是说，如果回应了<code>n+1</code>的Prepare请求，那么：</p><ol><li>可以accept编号是<code>n+1</code>的accept请求；</li><li>不能accept编号是<code>n</code>的accept请求；</li><li>能不能promise编号是<code>n</code>的Prepare请求？<br> 文章中指出，没有理由去回应这样的请求。因为根据上一点，连编号为<code>n</code>的accept请求都不会被响应了，更何况Prepare请求呢？<br> 同理，如果一个请求已经被accept了，那么我们也不会再去回应对应的Prepare请求了。<br> 当然，这些只是优化点而已。</li></ol><h3 id="持久化要求"><a href="#持久化要求" class="headerlink" title="持久化要求"></a>持久化要求</h3><p>为了维护P2c这个不变量，一个acceptor需要持久化：</p><ol><li>自己accept的最大的proposal number；</li><li>自己回复的最大的Prepare请求的number。</li></ol><p>此外，一个proposer可以忘记或者放弃自己的proposal，只要它不会具有相同number的另一个请求。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="Phase-1"><a href="#Phase-1" class="headerlink" title="Phase 1"></a>Phase 1</h3><ol><li>Proposer<br> 选择<code>n</code>，发送<code>Prepare(n)</code>到majority个acceptor上。</li><li>Acceptor<br> 对于<code>Prepare(n)</code>，如果<code>n</code>高于已经响应过的其他<code>Prepare</code>请求，则：<ol><li>promise不会在accept任何<strong>小于</strong><code>n</code>的请求；</li><li>发送最大的小于<code>n</code>的accept的proposal。</li></ol></li></ol><h3 id="Phase-2"><a href="#Phase-2" class="headerlink" title="Phase 2"></a>Phase 2</h3><ol><li>Proposer<br> 如果收到了majority的acceptor对自己<code>Prepare(n)</code>的响应，则发送<code>Accept(n,v)</code>请求给所有这些acceptor。这里的<code>v</code>的选择参见<em>Proposer 算法 Step2</em>一节。</li><li>Acceptor<br> 除非自己已经回复了<code>Prepare(n+1)</code>或者更高的，否则acceptor需要accept请求<code>Accept(n,v)</code>。</li></ol><h2 id="Learner"><a href="#Learner" class="headerlink" title="Learner"></a>Learner</h2><p>容易发现，因为没有Leader，所以从单一的acceptor角度，并不能很方便地去发现某个proposal是否已经被chosen了。<br>一个平凡的方法就是每进行一次accept，就告知learner一次，不过这样的方法有很大的通信开销。考虑到learner也不会出现拜占庭错误，所以learner间可以相互通信以得到被accept的值，因此可以让每个acceptor只响应某一些learner。如果考虑到这一些learner可能失败，导致丢失acceptor信息，问题还会更复杂。此时，一个值被chosen了，但是没有learner发现。虽然learner可以再逐个询问acceptor，但只要有一个acceptor宕掉，就可能导致learner无法了解某个proposal是否得到多数同意。在这种情况下，只有当一个新的proposal被chosen的时候，learner才会再次发现。</p><p>对此，可以提出一个问题，对于<code>n&gt;m</code>，如果<code>n</code>被chosen，那么<code>m</code>是不是一定被chosen呢？</p><h2 id="活锁问题"><a href="#活锁问题" class="headerlink" title="活锁问题"></a>活锁问题</h2><p>上述的Basic Paxos算法存在活锁问题。考虑</p><ol><li><code>p</code>发送<code>Prepare(n1)</code>；</li><li><code>q</code>发送<code>Prepare(n2)</code>，其中<code>n2&gt;n1</code>；</li><li>此时<code>p</code>不能成功地<code>Accept(n1)</code>了，因为acceptor保证了不会accept低于<code>n2</code>的请求；</li><li>于是<code>p</code>继续发送一个<code>Prepare(n3)</code>，其中<code>n3&gt;n2</code>；</li><li>由此开始循环往复。</li></ol><p>因此，我们必须选出一个<strong>proposer</strong>，这个proposer起到Leader的作用，只有它可以发送proposal。在论文后面提到，这个Leader实际上还起到首要的Learner的作用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>acceptor的回复需要带上对应的proposal number。acceptor先持久化自己的回复，再发送给对方。<br>下面讨论如何保证没有两个proposal的number是相同的。方法很简单，不同的proposer从不同的不相交集中取这些序号即可。每个proposer持久化自己所选取的最大的proposal number。</p><h2 id="实现状态机"><a href="#实现状态机" class="headerlink" title="实现状态机"></a>实现状态机</h2><p>使用多个服务器组成集群，每个服务器构成一个单独的状态机。因为状态机都是确定的，所以每个服务器对应的状态机的状态和输出始终是一致的。<br>为了保证每个状态机都能执行相同的状态机命令，实现了</p><h1 id="Basic-Paxos-Ongaro"><a href="#Basic-Paxos-Ongaro" class="headerlink" title="Basic Paxos(Ongaro)"></a>Basic Paxos(Ongaro)</h1><p>在Ongaro等的视频里面，进一步理清了Basic Paxos的相关概念。<br>首先是Basic Paxos Instance、Server、Proposer和Acceptor的关系。一个Instance指的是Basic Paxos决定一个Value的过程。因此Basic Paxos被称为是Single decree的，因为它只决定一个值。一般一个Server同时是一个Proposer和Acceptor，Acceptor是完全被动地，处理来自Proposer的请求。一个Acceptor可能Accept不同的Value，也就是可能变票。<br>接着，Ongaro提出一种实现Proposal Number的方案，也就是高位的Round Number和低位的Server ID。这些Round Number需要被持久化到磁盘上，以保证proposal number不会被重复使用。</p><p>下面的图表示了Basic Paxos的消息通信过程<br><img src="/img/paxos/12.png" alt=""></p><p>需要注意的是，只有提出某个proposal的proposer才能知道是否已经被chosen；对于其他的proposer，必须用自己的proposal执行一遍basic paxos才行。</p><h2 id="三种Prepare顺序讨论"><a href="#三种Prepare顺序讨论" class="headerlink" title="三种Prepare顺序讨论"></a>三种Prepare顺序讨论</h2><p>下面讨论Paxos中三种常见的Prepare顺序，和对应的结果。<br>框框中的<code>P 3.1</code>表示<strong>收到</strong>来自Server1的Round Number为3的proposal，<code>A 3.1 X</code>表示<strong>收到</strong>（而不是接受）这个proposal，它的值为<code>X</code>。<br>有两个proposer试图propose，分别是S1要propose值X，且S5要propose值Y。</p><h3 id="1-当值X已经被chosen"><a href="#1-当值X已经被chosen" class="headerlink" title="1. 当值X已经被chosen"></a>1. 当值X已经被chosen</h3><p>如下图所示，当<code>P 4.5</code>到来时，值<code>X</code>已经被chosen了。<br><img src="/img/paxos/13.png" alt=""></p><h3 id="2-当值X没有被chosen，但新的proposer能够看到"><a href="#2-当值X没有被chosen，但新的proposer能够看到" class="headerlink" title="2. 当值X没有被chosen，但新的proposer能够看到"></a>2. 当值X没有被chosen，但新的proposer能够看到</h3><p>我们注意S3上的<code>A 3.1 X</code>请求已经被Accept了，所以当S5发出<code>P 4.5</code>后，它会知道值已经被Accept为<code>X</code>了，所以它不再坚持自己要Accept的值<code>Y</code>，而是转而Accept值<code>X</code>。<br><img src="/img/paxos/14.png" alt=""></p><h3 id="3-当值X没有被chosen，新的proposer也看不到"><a href="#3-当值X没有被chosen，新的proposer也看不到" class="headerlink" title="3. 当值X没有被chosen，新的proposer也看不到"></a>3. 当值X没有被chosen，新的proposer也看不到</h3><p>注意此时S3上的<code>A 3.1 X</code>请求实际上不会被Accept，因为<code>Prepare 4.5</code>已经捷足先登了。<br><img src="/img/paxos/15.png" alt=""></p><h1 id="Multi-Paxos-Ongaro"><a href="#Multi-Paxos-Ongaro" class="headerlink" title="Multi Paxos(Ongaro)"></a>Multi Paxos(Ongaro)</h1><p>主要讲了几件事情：</p><ol><li>如何维护一个Log（一系列Entry）而不是某一个Entry。</li><li>性能优化，包括两方面，但主要是借助于Leader：<ol><li>去掉proposer之间存在的活锁<br> 如果在任何一个时刻，保证只有一个proposer发请求的话，那么就不会存在活锁。</li><li>去掉冗余的Prepare请求<br> 即对每个log而不是每个entry进行一次Prepare，这样话大部分entry可以在一轮RPC中被chosen，即执行一轮accept。</li></ol></li><li>如何实现所谓的Fully Replication，即让大家都知道某个Entry已经被chosen了。</li><li>客户端协议以及状态机相关。</li></ol><h2 id="维护一个Log"><a href="#维护一个Log" class="headerlink" title="维护一个Log"></a>维护一个Log</h2><p>首先我们考察，当一个proposer准备新增一个entry到log时，如下图所示，当client发送一个jmp给S1时，S1选择哪一个entry呢？这可能涉及一下的情况：</p><ol><li>在Entry1和2中，mov和add被复制到了所有机器上，并且S1已经知道被chosen了。如下图所示，用粗框子框出来了。</li><li>在Entry3中，cmp实际上已经被chosen了，但是S1并不知道。这个可能是因为S3被分区了。</li></ol><p>下面我们就考虑S3被分区的情况：</p><ol><li>找到第一个没有被S1知道已经chosen的entry，即<code>firstUnchosenIndex</code>。也就是Entry3。</li><li>根据Basic Paxos算法，对这个entry去propose一个Value为jmp的proposal。显然，这个Value是不能被accept的，因为已经有一个Acceptor接受了cmp这个值了。所以这一个Basic Paxos Instance跑完，实际上会导致cmp在Entry3中被chosen。</li><li>接着，我们回到第1步，检查下一个尚未被发现已经chosen的entry，即Entry4，并尝试propose。显然，这次jmp还是不能被accept，因为sub已经被S2上的acceptor接受了。</li></ol><p><img src="/img/paxos/20.png" alt=""></p><p>通过这种方式，Server可以并发处理多条来自client的请求。演讲者提到，例如第一个请求用到了Entry3，那么下一个请求可能会尝试Entry4或者Entry5等等。在这一点上我还有点疑惑，就是我们能保证client的请求在Paxos log层面是in order的么？</p><p>但是最后这些命令需要按照log中的顺序来放到复制自动机中执行。</p><h2 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h2><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>需要注意的是，Paxos在有多个Leader的时候依旧能够正常运作，只是效率会受到影响；但是Raft等就必须要求有唯一的Leader。<br>Lamport提出一种简单的办法，就是令具有最大的Server ID的proposer为Leader。接着所有的Server互相向其他Server以间隔<code>T</code>发送心跳包，心跳包中包含自己的Server ID。如果一个Server在<code>2T</code>的时间内没有收到一个具有更高的Server ID的心跳包，那么它就以Leader的方式行动，即开始处理来自client的请求，且同时执行proposer和acceptor的角色。相对应地，如果一个Server不是Leader，那么它不处理client的请求，并且只执行acceptor的角色。</p><p>演讲者后来指出，一般来说，并不会用这种方案。</p><h3 id="减少Prepare"><a href="#减少Prepare" class="headerlink" title="减少Prepare"></a>减少Prepare</h3><p>下面讨论如何减少Prepare请求。首先，为什么要有Prepare请求呢？</p><ol><li>阻止具有旧的number的proposal</li><li>发现可能存在的已经被chosen的Entry</li></ol><p>下面我们对这两点目的进行改进：</p><ol><li>阻止具有旧的number的proposal<br> 我们可以让proposal number和整个log关联，而不是和某个entry关联。</li><li>发现可能存在的已经被chosen的Entry<br> acceptor不仅要返回对于当前entry的最大的proposal number，还需要检查所有当前entry之后的所有entry，如果其中没有任何proposal被accept，那么就返回<code>noMoreAccepted</code>。</li></ol><p>如果一个acceptor返回了<code>noMoreAccepted</code>，那么后续就不再发送Prepare请求，直到某个Accept请求被拒绝。<br>如果一个Leader从多数的acceptor处都收到了<code>noMoreAccepted</code>，它就不再需要发送Prepare请求了。这个状态可能会被另一个当选的Leader打破，此时旧Leader会收到被拒绝的Accept请求。</p><h2 id="Fully-Replication"><a href="#Fully-Replication" class="headerlink" title="Fully Replication"></a>Fully Replication</h2><p>因为最终所有的Log Entry都需要过RSM，所以我们需要保证最终每个Server上的Log都是全的，并且他们知道哪些已经被chosen了。这通常包括两个目标：</p><ol><li>保证Entry最终在所有的机器上被复制，但目前我们只保证了majority。</li><li>保证所有的Server都能知道某个Entry是否被chosen，目前只有对应的proposer知道。</li></ol><p>下面是解决方案，一共有四个措施，但其实大部分措施都是为了处理就Leader宕机的情况。</p><ol><li>Proposer需要不断地重复Accept请求（可以在后台完成），直到所有的acceptor都回复<br> 但这个策略是不充分的，原因是考虑当Proposer宕掉时，他未必能够将所有的Entry都进行复制。</li><li>跟踪所有被chosen的Entry<br> 每个Server对所有已经被chosen的Entry设置<code>acceptedProposal[i]=INF</code>，INF也是能够无缝适配协议的，因为不可能存在一个更大的proposal number了。<br> 每个Server维护一个<code>firstUnchosenIndex</code>（已经在前面介绍过了）。</li><li><p>Proposer将自己的<code>firstUnchosenIndex</code>附加在Accept请求中发送<br> 这样，一个Accept请求会类似下面</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request = Accept(<span class="attribute">proposal</span>=3.4, <span class="attribute">index</span>=8, <span class="attribute">value</span>=v, <span class="attribute">firstUnchosenIndex</span>=7)</span><br></pre></td></tr></table></figure><p> 而acceptor会对每个<code>Entry[i]</code>进行如下的检查，如果下面两个条件被满足，那么就将<code>Entry[i]</code>标记为chosen。</p><ul><li><code>i &lt; request.firstUnchosenIndex</code></li><li><p><code>acceptedProposal[i] == request.proposal</code></p><p>为了解释这种情况，我们查看下面的这个例子。下图中，每个格子里面的数字指的是proposal number。容易看到，在这个acceptor处理Accept请求前，这台Server上的Entry 1/2/3/5已经被chosen了。<br><img src="/img/paxos/26.a.png" alt=""><br>现在，来自Leader Proposer的一个Accept请求告知<code>firstUnchosenIndex=7</code>，这也就意味着在这个Proposer上，Entry 1到6都被chosen了。此时，我们就可以将Entry 6标记为chosen。<br><img src="/img/paxos/26.b.png" alt=""><br>然后我们有几个疑问：</p></li><li>Entry 6为什么可以被标记为chosen？<br>  这是因为首先这个acceptor知道Entry 6也是来自于发送这个Accept的Proposer，并且它在这个Proposer上已经被chosen了。<br>  但这还不够，有没有可能这个Proposer后面发送了关于Entry 6的具有另外一个值的Accept请求呢？我想这样的话，proposal number一定会变得更大。但既然在<code>3.4</code>的时候，我们就知道Entry 6已经被chosen了，那么被chosen的这个值一定就是acceptor日志里面的这个值。</li><li>Entry 4为什么不能被标记为chosen？<br>  因为Entry 4的值来自于另外Round的另外一个Proposer，因此我们没办法像Entry 6一样确定这个不是一个陈旧的数据。也就是说，这个accpetor知道Entry 4被chosen了，但是并不知道这个被chosen的Value是不是自己Log里面的那个Value。因为很可能这个值又被改了。</li><li>Entry 7是怎么回事？</li></ul></li><li>Success RPC<br> acceptor会在对Accept消息的返回中附带上自己的<code>firstUnchosenIndex</code>，当Proposer收到该acceptor返回后会将该值和自己的<code>firstUnchosenIndex</code>进行比较。如果acceptor的<code>firstUnchosenIndex</code>小于自己的，说明这个acceptor落后了，此时需要在后台发送Success RPC。<br> 这个RPC需要包含index以告知是那个Entry被chosen了，并且附带上一个<code>v</code>表示被chosen的值。当Acceptor收到这个消息后，将：<ol><li><code>acceptedValue[index]=v</code></li><li><code>acceptedProposal[index]=INF</code></li><li>返回新的<code>firstUnchosenIndex</code>给Proposer，Proposer会根据这个值判断是否需要再次发送Success RPC</li></ol></li></ol><h3 id="Leader缺少日志问题"><a href="#Leader缺少日志问题" class="headerlink" title="Leader缺少日志问题"></a>Leader缺少日志问题</h3><h2 id="Client协议"><a href="#Client协议" class="headerlink" title="Client协议"></a>Client协议</h2><p>这一部分和Raft一样，非Leader的Server会把请求转发给Leader。同样的，Leader也会在Client提交的命令被chosen以及被RSM执行之后，才会返回。<br>如果请求超时，例如Leader宕机了，那么Client会将命令发送给其他Server，在最终发现新Leader后，重试命令。</p><h3 id="如何保证Exact-once语义"><a href="#如何保证Exact-once语义" class="headerlink" title="如何保证Exact once语义"></a>如何保证Exact once语义</h3><p>这个问题通常发生在当老Leader在执行完自己的状态机后、返回给Client前宕机。根据上面的论述，Client实际上会通过另一个Leader重试，在这种情况下，可能同样的命令就会被执行两次。</p><p>其实这种情况在我实现Raft协议的时候也遇到过。对此，演讲者建议Client对每个命令设置一个唯一的ID。每个Server上的RSM都会自己记录一下自己执行过的最新的ID。那么当RSM在执行每个命令的时候，会首先检查这个命令是否被执行过，如果被执行过了，就忽略，并且返回当时的结果。这种策略的要求是Client不挂，因为ID是由Client设置的。</p><h2 id="配置切换"><a href="#配置切换" class="headerlink" title="配置切换"></a>配置切换</h2><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><h2 id="官方习题"><a href="#官方习题" class="headerlink" title="官方习题"></a>官方习题</h2><p>来自于Raft作者的博客。</p><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>下面哪些日志是可能存在的？<br><img src="/img/paxos/q1.png" alt=""></p><ol><li>这个应该是个标准情况，肯定是可以的。</li><li>也是可以的</li><li>也是可以的，Paxos容许日志缺失</li><li>也是可以的</li></ol><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>在Basic Paxos中，考虑在一个5节点的集群中，有三个acceptor接受了<code>proposal(5.1, X)</code>，在此之后，是否可能有某些机器去accept另一个Value Y呢？</p><p>这个问题并没有在问，如果在一个时间节点中存在majority都接受了一个proposal，是不是可以立刻认为这个proposal被chosen？因为accept另一个Value的机器只会在小分区中。</p><p>注意，这里的proposal number由<code>round_number.server_id</code>这样的方式构成。</p><p>我们知道，只要一个acceptor回复了<code>Prepare(5.1)</code>，那么他就不可能去<code>Accept(3.4,Y)</code>或者<code>Prepare(3.4,Y)</code>了。所以如果这个可能发生，那么<code>Prepare(3.4)</code>一定要在<code>Prepare(5.1)</code>之前。<br>于是，我们尝试下面的顺序：</p><ol><li>P4: <code>Prepare(3.4)</code><br> 发送到S1/S2/S3/S4/S5</li><li>S4/S5/S1和S2/S3发生分区</li><li>P1: <code>Prepare(5.1)</code><br> 发送到S4/S5/S1<br> 因为5.1更大，所以S4/S5/S1会保证不会再accept小于5.1的请求。因为目前S4/S5/S1没有accept任何proposal，所以返回的“最大的小于<code>n</code>”的proposal为空。</li><li>P2: <code>Accept(5.1,X)</code><br> 发送到S4/S5/S1</li><li>P1: <code>Accept(3.4,Y)</code><br> 发送到S2/S3<br> 由于分区，所以S2/S3没有回复<code>Prepare(5.1)</code>，更别说<code>Accept(5.1,X)</code>了。所以它能够接受请求<code>Accept(3.4,Y)</code>。</li></ol><p>不过如果S2/S3从分区中恢复后，会将自己的值改成5.1对应的值么？</p><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>在MultiPaxos中，如果一个Server刚变成Leader，并且此时没有其他Server是Leader。进一步地，假设这个Server继续是Leader一段时间，其中chosen了一系列Entry，并且在这段时间中没有其他Server成为Leader。</p><ol><li>这个Server最少需要发送几轮Prepare？<br> 我觉得最少只要一轮，在这一轮中大家都Accept了，并且返回<code>noMoreAccepted</code>。</li><li>这个Server最多需要发送几轮Prepare？<br> 这个我没啥idea，答案说统计Leader上面所有满足下面条件的Entry，那么就需要一条Prepare<ol><li>还没有被Leader标记为chosen；</li><li>曾经被某个acceptor接受。<br>这个过程通常是这样的，Leader向该这个Entry发送一个Prepare，然后发现这个Entry已经被某个acceptor接受了，因此它去促使这个Entry最终被chosen，并且在这之后去尝试去Prepare下一个Entry。这个也对应了不断递增<code>firstUnchosenIndex</code>，找到合适的可添加Entry的slote的过程。</li></ol></li></ol><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>如果一个acceptor通过来自proposer的<code>firstUnchosenIndex</code>知道了某个Entry被chosen了，它必须先比较自己Entry里面的proposal number是不是和这个proposer匹配。说明这个比较是不是必要的，并解释。</p><p>这个肯定是必要的，原因在“Entry 4为什么不能被标记为chosen”里面解释过了。</p><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>考虑proposal number的两个部分被对调了，即现在变成<code>server_id.round_number</code>，那么：</p><ol><li>是否会影响算法的Safety<br> 我觉得是有影响的，每个proposer会维护单独的<code>server_id</code>，那么对于1号机器，它的proposal number始终是小于2号机器的，无论它如何自增id。<br> 但答案是说没有影响的，因为在MultiPaxos中只要求proposal number是唯一的，这时候因为<code>server_id</code>是唯一的而<code>round_number</code>是自增的，所以proposal number是唯一的。</li><li>是否会影响算法的Liveness<br> 看答案，是会的。例如具有较大<code>server_id</code>的proposer会发送一个Prepare请求给每个acceptor，然后永远地宕机了。此时其他的proposer就无法再行动了，因为acceptor上的<code>minProposal</code>值对这些proposer来说太高了。</li></ol><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>假定一个proposer打算执行<code>Accept(n,v1)</code>，但在某个时间点宕掉了，如果这个proposer重启并且打算执行<code>Accept(n,v2)</code>，这个是否安全呢？</p><p>这个在<em>Paxos made simple</em>中就明确指出是不可以的。</p><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>在一个成功的Accept请求中，acceptor设置<code>minProposal</code>为<code>n</code>（即Accept请求中的proposal number）。描述一种场景，此时这个行为确实改变了<code>minProposal</code>的值，例如在这之前<code>minProposal</code>并不是<code>n</code>。描述如果没有这个操作，系统会出现问题的一个场景。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>Paxos Made Simple</li><li>Paxos Summary</li><li>The part-time parliament</li><li><a href="https://zhuanlan.zhihu.com/p/278054304" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/278054304</a></li><li><a href="https://www.bilibili.com/video/BV1WW411a77S/?spm_id_from=333.788.videocard.13" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1WW411a77S/?spm_id_from=333.788.videocard.13</a></li><li><a href="http://oceanbase.org.cn/?p=90" target="_blank" rel="noopener">http://oceanbase.org.cn/?p=90</a><br> yubai大佬的日志，描述了如何基于Basic Paxos去维护多个Log Entry</li><li><a href="http://oceanbase.org.cn/?p=111" target="_blank" rel="noopener">http://oceanbase.org.cn/?p=111</a><br> yubai大佬的日志，描述了Multi Paxos</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍Paxos算法，包含Basic Paxos，以及Raft作者提出的一个Multi Paxos的工程化实现方案。此外，我们还就Raft作者给出的Paxos习题进行探讨。&lt;/p&gt;</summary>
    
    
    
    
    <category term="分布式" scheme="http://www.calvinneo.com/tags/分布式/"/>
    
    <category term="raft" scheme="http://www.calvinneo.com/tags/raft/"/>
    
    <category term="paxos" scheme="http://www.calvinneo.com/tags/paxos/"/>
    
  </entry>
  
  <entry>
    <title>GCC和GLIBC编译</title>
    <link href="http://www.calvinneo.com/2020/12/13/gcc-glibc-compile/"/>
    <id>http://www.calvinneo.com/2020/12/13/gcc-glibc-compile/</id>
    <published>2020-12-12T16:45:42.000Z</published>
    <updated>2020-12-15T14:40:51.827Z</updated>
    
    <content type="html"><![CDATA[<p>GCC是C和C++的编译器，GLIBC是C库，两个是不同的Repo。编译顺序是先GCC在GLIBC，这是因为编译GLIBC时对GCC的版本有要求。</p><a id="more"></a><h1 id="编译GCC"><a href="#编译GCC" class="headerlink" title="编译GCC"></a>编译GCC</h1><p>源码在Git上可以拉下来，然后checkout到自己想要的版本<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://gcc.gnu.org/git/gcc.git</span><br></pre></td></tr></table></figure></p><p>需要先安装依赖，其顺序为：gmp mpfr mpc。可以通过运行下面的命令来下载这些依赖<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="regexp">/contrib/</span>download_prerequisites</span><br></pre></td></tr></table></figure></p><p>我的机器上的gmp的版本是够的，所以我只编译了后面两个，最终编译GCC的命令是<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir b</span><br><span class="line">cd b</span><br><span class="line"><span class="built_in">..</span>/configure <span class="attribute">--enable-languages</span>=c,c++  <span class="attribute">--with-mpc</span>=/data/gcc-comp/mpc-1.0.3/out/ <span class="attribute">--with-mpfr</span>=/data/gcc-comp/mpfr-3.1.4/out/ <span class="attribute">--prefix</span>=<span class="string">"<span class="variable">$(pwd)</span>/out"</span></span><br><span class="line">make -j5</span><br></pre></td></tr></table></figure></p><p>这个编译过程有点慢，但是GCC不支持distcc的分布式编译。</p><h1 id="编译GLIBC"><a href="#编译GLIBC" class="headerlink" title="编译GLIBC"></a>编译GLIBC</h1><p>可以通过下面的命令来检查GLIBC的版本。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">locate libc.a</span><br><span class="line">strings /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">libc</span>.<span class="title">so</span>.6 | <span class="title">grep</span> <span class="title">GLIBC_</span></span></span><br></pre></td></tr></table></figure></p><p>我编译的是2.30版本，源码同样是在Git上拉下来<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">git</span>://sourceware.org/git/glibc.git</span><br><span class="line">git checkout release/<span class="number">2.30</span>/<span class="literal">master</span></span><br></pre></td></tr></table></figure></p><p>GLIBC有一系列的依赖，在configure的时候能够看出来，这里列出我手动编译的，需要在编译好后，设置对应的环境变量：</p><ol><li><p>make</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">MAKE</span>=/data/gcc-comp/make-4.1/b/out/bin/make</span><br></pre></td></tr></table></figure></li><li><p>GCC</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">CC</span>=/data/gcc-comp/gcc-9.3.0/b/out/bin/gcc</span><br></pre></td></tr></table></figure></li><li><p>AS/LD<br> 这个都是binutil里面的组件，所以稍微不同地，是使用configure with参数的方式设置</p></li><li><p>BISON</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">BISON</span>=/data/gcc-comp/bison-2.7/b/out/bin/bison</span><br></pre></td></tr></table></figure></li><li><p>Python<br> 虽然configure中提到Python2也是可以的，但我试了下还是有问题，所以不如直接编译一个Python3</p> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">PYTHON_PROG</span>=/data/gcc-comp/cpython/b/out/bin/python3</span><br></pre></td></tr></table></figure></li></ol><p>最终configure如下<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..<span class="regexp">/configure --prefix=/</span>data<span class="regexp">/gcc-comp/g</span>libc<span class="regexp">/b/</span>out --with-binutils=<span class="regexp">/data/g</span>cc-comp<span class="regexp">/binutils-2.32/</span>b<span class="regexp">/out/</span>bin</span><br></pre></td></tr></table></figure></p><p>注意，在这些依赖之后，GLIBC对Linux系统本身也有依赖，例如下面的错误来自于Linux kernel header版本的问题。<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">checking</span></span> installed Linux kernel header <span class="keyword">files</span>... missing <span class="keyword">or</span> too old!</span><br></pre></td></tr></table></figure></p><p>检查<code>/usr/include/linux/version.h</code>，将<code>LINUX_VERSION_CODE</code>转成16进制，然后按照两位两位分成三段，从左到右就是这个Lineux Header的Major/Minor/Patch版本号。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GCC是C和C++的编译器，GLIBC是C库，两个是不同的Repo。编译顺序是先GCC在GLIBC，这是因为编译GLIBC时对GCC的版本有要求。&lt;/p&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
    <category term="GCC" scheme="http://www.calvinneo.com/tags/GCC/"/>
    
    <category term="GLIBC" scheme="http://www.calvinneo.com/tags/GLIBC/"/>
    
  </entry>
  
  <entry>
    <title>pthread_rwlock库的实现</title>
    <link href="http://www.calvinneo.com/2020/12/11/pthread_rwlock-impl/"/>
    <id>http://www.calvinneo.com/2020/12/11/pthread_rwlock-impl/</id>
    <published>2020-12-10T17:20:13.000Z</published>
    <updated>2020-12-14T14:51:28.878Z</updated>
    
    <content type="html"><![CDATA[<p>pthread_rwlock系列函数是pthread库的读写锁函数。随着版本的不同，它的实现也不同。<br>本篇的组织是：</p><ol><li>前置知识<ol><li>GCC的扩展内联汇编</li><li>Futex</li></ol></li><li>两个版本的lowlevellock的实现</li><li>两个版本的pthread_rwlock的实现</li></ol><a id="more"></a><h1 id="扩展形式的GCC汇编介绍"><a href="#扩展形式的GCC汇编介绍" class="headerlink" title="扩展形式的GCC汇编介绍"></a>扩展形式的GCC汇编介绍</h1><p>在扩展形式的GCC汇编中，可以访问C语言中定义的变量，或者跳转到C语言定义的标签处。此外，GCC扩展汇编中可以用<code>:</code>去delimit各个operand parameter。<br>对于要访问的寄存器，并不一定要要显式指明，也可以留给GCC自己去选择，这可能让GCC更好去优化代码。<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html" target="_blank" rel="noopener">GCC扩展内联汇编</a>格式如下:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">asm</span> <span class="selector-tag">asm-qualifiers</span> ( AssemblerTemplate </span><br><span class="line">                      : OutputOperands</span><br><span class="line">                      : InputOperands</span><br><span class="line">                      : Clobbers</span><br><span class="line">                      : GotoLabels)</span><br></pre></td></tr></table></figure></p><p>OutputOperands、InputOperands等列表里面的项目会从0开始标号，并且可以使用<code>%0</code>、<code>%1</code>的方法去表示，例如对下面的代码而言，<code>%0</code>是<code>old</code>，<code>%1</code>是<code>*Base</code>，<code>%2</code>是<code>Offset</code>。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> old;</span><br><span class="line"></span><br><span class="line">__asm__ (<span class="string">"btsl %2,%1\n\t"</span> <span class="comment">// Turn on zero-based bit #Offset in Base.</span></span><br><span class="line">         <span class="string">"sbb %0,%0"</span>      <span class="comment">// Use the CF to calculate old.</span></span><br><span class="line">   : <span class="string">"=r"</span> (old), <span class="string">"+rm"</span> (*Base)</span><br><span class="line">   : <span class="string">"Ir"</span> (Offset)</span><br><span class="line">   : <span class="string">"cc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> old;</span><br></pre></td></tr></table></figure></p><p>我们看看这个语法中的几个组成部分：</p><ol><li>AssemblerTemplate<br> 是ASM代码的模板。</li><li><a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#OutputOperands" target="_blank" rel="noopener">OutputOperands</a><br> 一个逗号分隔的列表，表示所有被这段代码修改的变量。<br> 其中<code>+rm</code>、<code>=r</code>等表示<a href="https://gcc.gnu.org/onlinedocs/gcc/Constraints.html" target="_blank" rel="noopener">Constraints</a>，将在稍后介绍。<br> 在括号中的应该是一个C语言左值。</li><li>InputOperands<br> 表示所有被这段代码访问的表达式。</li><li>Clobbers<br> 除了OutputOperands之外，还被这段代码修改的内容，例如<ol><li><code>cc</code>：eflags寄存器</li><li><code>memory</code>：内存<br> 例如我们常见的<code>asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;)</code>用法。</li></ol></li><li>GotoLabels<br> 这段代码可能跳转到的C语言的标签。</li></ol><h2 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h2><h3 id="Simple-Constraints"><a href="#Simple-Constraints" class="headerlink" title="Simple Constraints"></a>Simple Constraints</h3><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Simple-Constraints.html#Simple-Constraints" target="_blank" rel="noopener">Simple Constraints</a>都是字母或数字，表示允许其中的某一种类的操作。</p><ol><li><code>r</code>表示允许寄存器操作；<code>m</code>表示允许内存操作。这两个是很泛化的内存和寄存器操作。</li><li><code>a</code>表示地址寄存器，<code>f</code>表示浮点寄存器，<code>d</code>表示数据寄存器。这些都对特定的处理器适用。</li><li>数字表示matching constraint</li></ol><h3 id="Modifiers"><a href="#Modifiers" class="headerlink" title="Modifiers"></a>Modifiers</h3><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Modifiers.html#Modifiers" target="_blank" rel="noopener">Modifiers</a>用来描述operands的读写性。</p><ol><li><code>+</code><br> 表示这个值在操作中会被<strong>读写</strong>。</li><li><code>=</code><br> 表示这个值只会被写。</li><li><code>&amp;</code></li><li><code>%</code></li></ol><h1 id="Futex介绍"><a href="#Futex介绍" class="headerlink" title="Futex介绍"></a>Futex介绍</h1><p>Futex是一个<a href="https://man7.org/linux/man-pages/man2/futex.2.html" target="_blank" rel="noopener">系统调用</a>。在使用Futex时，大部分的工作是在用户态完成的，只有当程序很有可能阻塞较长时间时，才会真的去使用这个系统调用。<br>Futex值的加载、Futex值和传入的expected value的比较以及实际的阻塞都是原子的。并且，不同线程对同一个Futex值的并发操作是Total order的。</p><p>Futex调用如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">futex</span><span class="params">(<span class="keyword">uint32_t</span> *uaddr, <span class="keyword">int</span> futex_op, <span class="keyword">uint32_t</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> struct timespec *timeout,   <span class="comment">/* or: uint32_t val2 */</span></span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">uint32_t</span> *uaddr2, <span class="keyword">uint32_t</span> val3)</span></span>;</span><br></pre></td></tr></table></figure></p><p>它的实现类似下面<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">futex(<span class="keyword">uint32_t</span> *uaddr, <span class="keyword">int</span> futex_op, <span class="keyword">uint32_t</span> val,</span><br><span class="line">     <span class="keyword">const</span> struct timespec *timeout, <span class="keyword">uint32_t</span> *uaddr2, <span class="keyword">uint32_t</span> val3)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> syscall(SYS_futex, uaddr, futex_op, val,</span><br><span class="line">                  timeout, uaddr2, val3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>uaddr</code>指向一个Futex值，它在32位或者64位系统上都是一个32位的值。<br><code>futex_op</code>包含两部分，要执行的操作(operation)，以及操作的option。<br>option包含下面几个常量：</p><ol><li><p><code>FUTEX_PRIVATE_FLAG</code>：128<br> 【Since 2.6.22】<br> 这个option表示这个Futex是否是被跨进程共享的。指定这个flag能够允许内核做一系列优化。<br> 对于所有要执行的操作，提供了带<code>_PRIVATE</code>版本后缀的宏，其作用相当于or上了这个<code>FUTEX_PRIVATE_FLAG</code>。<br> 因为这个宏在22版本之后才有，所以我们看到nptl的一些实现上会使用<code>__ASSUME_PRIVATE_FUTEX</code>判定Linux是否支持Private Futex这个功能。我们可以认为在22版本之后的Linux下<a href="https://patches-gcc.linaro.org/patch/4760/#7887" target="_blank" rel="noopener">这个宏始终是1</a>。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel-features.h</span></span><br><span class="line"><span class="comment">/* Support for private futexes was added in 2.6.22.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LINUX_KERNEL_VERSION &gt;= 0x020616</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __ASSUME_PRIVATE_FUTEX 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>FUTEX_CLOCK_REALTIME</code>：256<br> 【Since 2.6.28】<br> 这个option指定timeout的计算方式</p></li></ol><p>操作部分包含下面几个常量：</p><ol><li><code>FUTEX_WAIT</code>：0<br> 这个操作检查<code>uaddr</code>指向的值是否等于<code>val</code>。<br> 如果是，那么就会睡在这个Futex上面，直到另一个<code>FUTEXT_WAKE</code>被调用。这个读取、比较和开始睡眠的过程是原子的。<br> 如果不是，那么就会立即返回<code>EAGAIN</code>。<br> 之所以要在这个操作里面再比较一次<code>val</code>，而不是直接加锁，其原因是为了防止丢失wake up事件。例如，如果在本线程准备阻塞之后，另一个线程修改了Futex的值，并且遵循了下面的时序：<ol><li>对方线程先修改Futex值</li><li>对方线程执行<code>FUTEX_WAKE</code></li><li>本线程执行<code>FUTEX_WAIT</code><br>那么在执行<code>FUTEX_WAIT</code>时同步检查<code>val</code>的方案就能发现Futex值变化了，并且不进入睡眠。</li></ol></li><li><code>FUTEX_WAKE</code>：1<br> 这个操作唤醒最多<code>val</code>个睡在这个Futex上面的线程。指定<code>INT_MAX</code>表示唤起所有线程。</li><li><code>FUTEX_FD</code>：2<br> 【已被移除】<br> 表示为当前Futex创建一个fd，当这个Futex发生<code>FUTEX_WAKE</code>调用时，这个fd被select、poll和epoll等可读。</li><li><code>FUTEX_REQUEUE</code>：3<br> 是<code>FUTEX_CMP_REQUEUE</code>的不带check的简化版。</li><li><code>FUTEX_CMP_REQUEUE</code>：4<br> TODO</li><li><code>FUTEX_WAKE_OP</code>：5<br> 这个操作用来支持<strong>在用户态</strong>中对多个Futex同时操作的情形。例如<code>pthread_cond_signal</code>的实现中需要用到两个Futex，一个用来实现Mutex，一个用来管理和CV相连的Wait queue。通过这个操作可以避免一些contention或者上下文切换。<br> 这个op的主要过程是：<ol><li>保存uaddr2的旧值到oldval，并且对uaddr2执行操作。这个操作是原子的。</li><li>唤醒uaddr上的val个线程。</li><li>如果oldval的值满足一定条件，则唤起val2个线程。</li></ol></li><li><code>FUTEX_LOCK_PI</code>：6<br> 这里的PI表示”priority inheritance”，用来处理所谓的<a href="/2017/12/28/Concurrency-Programming-Compare/">优先级倒置</a>问题。<br> 它的解决方案是，当一个高优先级的任务被一个低优先级任务持有的锁阻塞时，会暂时提高这个低优先级任务的优先级为高优先级，这样它就不会被对方抢占。<br> 注意，这个”priority inheritance”的实现也必须是可传递的。也就是当这个低优先级任务在等待另一个中等优先级任务的锁的时候，所有的任务都要被提升为高优先级。</li><li><code>FUTEX_UNLOCK_PI</code>：7</li><li><code>FUTEX_TRYLOCK_PI</code>：8</li><li><code>FUTEX_WAIT_BITSET</code>：9</li><li><code>FUTEX_WAKE_BITSET</code>：10</li><li><code>FUTEX_WAIT_REQUEUE_PI</code>：11</li><li><code>FUTEX_CMP_REQUEUE_PI</code>：12</li></ol><p>下面我们讨论futex调用的返回值。首先如果发生错误，就按照通常规矩，返回-1，并且设置errno。对于成功的情况，需要根据op讨论：</p><ol><li><code>FUTEX_WAIT</code><br> 返回0表示caller被唤醒了。需要注意的是，这个0有可能是spurious wake-up，所以在这之后，仍然需要根据Futex值的具体值去判断是否继续block。我认为这也是为什么<code>__lll_lock_wait_private</code>的实现中有一个while循环的原因。</li><li><code>FUTEX_WAKE</code><br> 返回唤醒了多少个waiter。</li></ol><h1 id="lll的GLIBC2-17版本"><a href="#lll的GLIBC2-17版本" class="headerlink" title="lll的GLIBC2.17版本"></a>lll的GLIBC2.17版本</h1><p>在这个版本中，lll的实现是FUTEX。<br>我们只看PRIVATE的部分<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nptl/sysdeps/unix/sysv/linux/x86_64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_lock(futex, private) \</span></span><br><span class="line">  (<span class="keyword">void</span>)                      \</span><br><span class="line">    (&#123; <span class="keyword">int</span> ignore1, ignore2, ignore3;               \</span><br><span class="line">       <span class="keyword">if</span> (__builtin_constant_p (<span class="keyword">private</span>) &amp;&amp; (<span class="keyword">private</span>) == LLL_PRIVATE)        \</span><br><span class="line">   __asm __volatile (__lll_lock_asm_start             \</span><br><span class="line">         <span class="string">".subsection 1\n\t"</span>              \</span><br><span class="line">         <span class="string">".type _L_lock_%=, @function\n"</span>          \</span><br><span class="line">         <span class="string">"_L_lock_%=:\n"</span>              \</span><br><span class="line">         <span class="string">"1:\tlea %2, %%"</span> RDI_LP <span class="string">"\n"</span>           \</span><br><span class="line">         <span class="string">"2:\tsub $128, %%"</span> RSP_LP <span class="string">"\n"</span>         \</span><br><span class="line">         <span class="string">"3:\tcallq __lll_lock_wait_private\n"</span>        \</span><br><span class="line">         <span class="string">"4:\tadd $128, %%"</span> RSP_LP <span class="string">"\n"</span>         \</span><br><span class="line">         <span class="string">"5:\tjmp 24f\n"</span>              \</span><br><span class="line">         <span class="string">"6:\t.size _L_lock_%=, 6b-1b\n\t"</span>          \</span><br><span class="line">         <span class="string">".previous\n"</span>              \</span><br><span class="line">         LLL_STUB_UNWIND_INFO_5           \</span><br><span class="line">         <span class="string">"24:"</span>                \</span><br><span class="line">         : <span class="string">"=S"</span> (ignore1), <span class="string">"=&amp;D"</span> (ignore2), <span class="string">"=m"</span> (futex),   \</span><br><span class="line">           <span class="string">"=a"</span> (ignore3)             \</span><br><span class="line">         : <span class="string">"0"</span> (<span class="number">1</span>), <span class="string">"m"</span> (futex), <span class="string">"3"</span> (<span class="number">0</span>)          \</span><br><span class="line">         : <span class="string">"cx"</span>, <span class="string">"r11"</span>, <span class="string">"cc"</span>, <span class="string">"memory"</span>);          \</span><br><span class="line">       <span class="keyword">else</span>                     \</span><br><span class="line">...</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>查看<code>__lll_lock_wait_private</code>函数的调用。下面两个<code>lll_futex_wait</code>的含义是如果<code>futex</code>的值是2，那么就会进行等待。<br>那么为什么要写成两个呢？如果我们已经观察到<code>futex</code>是2，即已经被加锁了，那么我们就直接去wait了，否则我们可以尝试加锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__lll_lock_wait_private (<span class="keyword">int</span> *futex)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (*futex == <span class="number">2</span>)</span><br><span class="line">    lll_futex_wait (futex, <span class="number">2</span>, LLL_PRIVATE);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>但是加锁的过程也未必成功，可能有两个线程同时过了上面的检验，因此我们还需要进行一次判断。加锁操作是由<code>atomic_exchange_acq</code>调用，它会尝试将futex设置为2，并且返回原值。在while循环中，我们会判断返回的原值是否为0，如果不是0，那么说明这个锁已经被另一个线程加了，所以我们直接wait到这个锁被释放，然后在重新while一次尝试加锁。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="keyword">while</span> (atomic_exchange_acq (futex, <span class="number">2</span>) != <span class="number">0</span>)</span><br><span class="line">    lll_futex_wait (futex, <span class="number">2</span>, LLL_PRIVATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="辅助函数解释"><a href="#辅助函数解释" class="headerlink" title="辅助函数解释"></a>辅助函数解释</h2><h3 id="lll-futex-wait"><a href="#lll-futex-wait" class="headerlink" title="lll_futex_wait"></a>lll_futex_wait</h3><p>查看<code>lll_futex_wait</code>函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_futex_wait(futex, val, private) \</span></span><br><span class="line">  lll_futex_timed_wait(futex, val, <span class="literal">NULL</span>, <span class="keyword">private</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_futex_timed_wait(futex, val, timeout, private) \</span></span><br><span class="line">  (&#123;                        \</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">const</span> struct timespec *__to __asm (<span class="string">"r10"</span>) = timeout;       \</span><br><span class="line">    <span class="keyword">int</span> __status;                   \</span><br><span class="line">    <span class="keyword">register</span> __typeof (val) _val __asm (<span class="string">"edx"</span>) = (val);           \</span><br></pre></td></tr></table></figure></p><p>解释一下：</p><ol><li><code>__status</code>这个变量在一个地址寄存器上，是这个汇编段的Output。</li><li><code>SYS_futex</code> TODO</li><li><code>futex</code></li><li><p><code>__lll_private_flag</code>根据传入的两个参数决定是否产生private的futex。需要注意libc和libdl中的所有的futex都应该是private的。<br> 检查这个函数的实现，有一句很神奇的代码。这个代码的结果是，如果<code>private</code>设置了<code>FUTEX_PRIVATE_FLAG</code>位，那么就将这个位清空。要解释清楚这个问题，需要结合后面rwlock的初始化过程来看。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> __lll_private_flag(fl, private) \</span></span><br><span class="line">  (((fl) | FUTEX_PRIVATE_FLAG) ^ (<span class="keyword">private</span>))</span><br></pre></td></tr></table></figure></li><li><p><code>cc</code>表示eflags寄存器也会被修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  __asm __volatile (<span class="string">"syscall"</span>                 \</span><br><span class="line">        : <span class="string">"=a"</span> (__status)               \</span><br><span class="line">        : <span class="string">"0"</span> (SYS_futex), <span class="string">"D"</span> (futex),           \</span><br><span class="line">    <span class="string">"S"</span> (__lll_private_flag (FUTEX_WAIT, <span class="keyword">private</span>)),       \</span><br><span class="line">    <span class="string">"d"</span> (_val), <span class="string">"r"</span> (__to)              \</span><br><span class="line">        : <span class="string">"memory"</span>, <span class="string">"cc"</span>, <span class="string">"r11"</span>, <span class="string">"cx"</span>);           \</span><br><span class="line">  __status;                     \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="atomic-exchange-acq"><a href="#atomic-exchange-acq" class="headerlink" title="atomic_exchange_acq"></a>atomic_exchange_acq</h3><h1 id="lll的GLIBC2-30版本"><a href="#lll的GLIBC2-30版本" class="headerlink" title="lll的GLIBC2.30版本"></a>lll的GLIBC2.30版本</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lowlevellock.h</span></span><br><span class="line"><span class="comment">/* This is an expression rather than a statement even though its value is</span></span><br><span class="line"><span class="comment">   void, so that it can be used in a comma expression or as an expression</span></span><br><span class="line"><span class="comment">   that's cast to void.  */</span></span><br><span class="line"><span class="comment">/* The inner conditional compiles to a call to __lll_lock_wait_private if</span></span><br><span class="line"><span class="comment">   private is known at compile time to be LLL_PRIVATE, and to a call to</span></span><br><span class="line"><span class="comment">   __lll_lock_wait otherwise.  */</span></span><br><span class="line"><span class="comment">/* If FUTEX is 0 (not acquired), set to 1 (acquired with no waiters) and</span></span><br><span class="line"><span class="comment">   return.  Otherwise, ensure that it is &gt;1 (acquired, possibly with waiters)</span></span><br><span class="line"><span class="comment">   and then block until we acquire the lock, at which point FUTEX will still be</span></span><br><span class="line"><span class="comment">   &gt;1.  The lock is always acquired on return.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __lll_lock(futex, private)                                      \</span></span><br><span class="line">  ((<span class="keyword">void</span>)                                                               \</span><br><span class="line">   (&#123;                                                                   \</span><br><span class="line">     <span class="keyword">int</span> *__futex = (futex);                                            \</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely                                               \</span><br><span class="line">         (atomic_compare_and_exchange_bool_acq (__futex, <span class="number">1</span>, <span class="number">0</span>)))        \</span><br><span class="line">       &#123;                                                                \</span><br><span class="line">         <span class="keyword">if</span> (__builtin_constant_p (<span class="keyword">private</span>) &amp;&amp; (<span class="keyword">private</span>) == LLL_PRIVATE) \</span><br><span class="line">           __lll_lock_wait_private (__futex);                           \</span><br><span class="line">         <span class="keyword">else</span>                                                           \</span><br><span class="line">           __lll_lock_wait (__futex, <span class="keyword">private</span>);                          \</span><br><span class="line">       &#125;                                                                \</span><br><span class="line">   &#125;))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lll_lock(futex, private)  \</span></span><br><span class="line">  __lll_lock (&amp;(futex), <span class="keyword">private</span>)</span><br></pre></td></tr></table></figure><h1 id="rwlock的GLIBC2-17实现"><a href="#rwlock的GLIBC2-17实现" class="headerlink" title="rwlock的GLIBC2.17实现"></a>rwlock的GLIBC2.17实现</h1><h2 id="INIT"><a href="#INIT" class="headerlink" title="INIT"></a>INIT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_rwlock_init.c</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_rwlock_init (rwlock, attr)</span><br><span class="line">     <span class="keyword">pthread_rwlock_t</span> *rwlock;</span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_rwlockattr</span> *<span class="title">iattr</span>;</span></span><br><span class="line"></span><br><span class="line">  iattr = ((<span class="keyword">const</span> struct pthread_rwlockattr *) attr) ?: &amp;default_attr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (rwlock, <span class="string">'\0'</span>, <span class="keyword">sizeof</span> (*rwlock));</span><br><span class="line"></span><br><span class="line">  rwlock-&gt;__data.__flags</span><br><span class="line">    = iattr-&gt;lockkind == PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP;</span><br><span class="line">    </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>__ASSUME_PRIVATE_FUTEX</code>这个宏表示是否支持Private Futex，在2.6.22之前是不支持的，因此我们看到在对应分支没有使用<code>FUTEX_PRIVATE_FLAG</code>这个宏，而是借助了<code>THREAD_GETMEM</code>的实现。<br><code>FUTEX_PRIVATE_FLAG</code>的值表示这个Futex是否是Private的，在之前已经介绍过。</p><p><code>__SHARED</code>这个字段我觉得有点奇怪了，我不是很明白为啥Futex用Private，而pthread用Shared，正好这两个值是相反的。源码在注释里面给了下面这个转换表，容易看出来在不支持<code>FUTEX_PRIVATE_FLAG</code>的时候就都是0。</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">            |<span class="string">     pshared     </span>|<span class="string">     result</span></span><br><span class="line"><span class="string">            </span>|<span class="string"> shared  private </span>|<span class="string"> shared  private </span>|</span><br><span class="line">------------+-----------------+-----------------+</span><br><span class="line">!avail 0    |<span class="string">     0       0   </span>|<span class="string">     0       0   </span>|</span><br><span class="line"> avail 0x80 |<span class="string">  0x80       0   </span>|<span class="string">     0    0x80   </span>|</span><br></pre></td></tr></table></figure><p>不管怎样吧，下面我们设置<code>_shared</code>的值，正好和Private相反。也就是如果我们希望我们的rwlock是Private的，那么我们就清空<code>FUTEX_PRIVATE_FLAG</code>位；如果我们希望它是Shared，那么就设置<code>FUTEX_PRIVATE_FLAG</code>。这样我们xor一下就能得到Private的实际值，这实际上对应了我们先前在<code>lll_futex_timed_wait</code>这个函数上的困惑。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __ASSUME_PRIVATE_FUTEX</span></span><br><span class="line">  rwlock-&gt;__data.__shared = (iattr-&gt;pshared == PTHREAD_PROCESS_PRIVATE</span><br><span class="line">                 ? <span class="number">0</span> : FUTEX_PRIVATE_FLAG);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>由于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  rwlock-&gt;__data.__shared = (iattr-&gt;pshared == PTHREAD_PROCESS_PRIVATE</span><br><span class="line">                 ? <span class="number">0</span></span><br><span class="line">                 : THREAD_GETMEM (THREAD_SELF,</span><br><span class="line">                          header.private_futex));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">strong_alias (__pthread_rwlock_init, pthread_rwlock_init)</span><br></pre></td></tr></table></figure></p><h2 id="LOCK"><a href="#LOCK" class="headerlink" title="LOCK"></a>LOCK</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_rwlock_wrlock.c</span></span><br><span class="line"><span class="comment">/* Acquire write lock for RWLOCK.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_rwlock_wrlock (rwlock)</span><br><span class="line">     <span class="keyword">pthread_rwlock_t</span> *rwlock;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>这个<code>LIBC_PROBE</code>定义在<code>include/stap-probe.h</code>里面，实际上是一个systemtap静态检查点的功能。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  LIBC_PROBE (wrlock_entry, <span class="number">1</span>, rwlock);</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>下面调用<code>lll_lock</code>去加lowlevellock锁<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">  <span class="comment">/* Make sure we are alone.  */</span></span><br><span class="line">  lll_lock (rwlock-&gt;__data.__lock, rwlock-&gt;__data.__shared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Get the rwlock if there is no writer and no reader.  */</span></span><br><span class="line">      <span class="keyword">if</span> (rwlock-&gt;__data.__writer == <span class="number">0</span> &amp;&amp; rwlock-&gt;__data.__nr_readers == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Mark self as writer.  */</span></span><br><span class="line">      rwlock-&gt;__data.__writer = THREAD_GETMEM (THREAD_SELF, tid);</span><br><span class="line"></span><br><span class="line">      LIBC_PROBE (wrlock_acquire_write, <span class="number">1</span>, rwlock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Make sure we are not holding the rwlock as a writer.  This is</span></span><br><span class="line"><span class="comment">     a deadlock situation we recognize and report.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (rwlock-&gt;__data.__writer</span><br><span class="line">                == THREAD_GETMEM (THREAD_SELF, tid), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      result = EDEADLK;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Remember that we are a writer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (++rwlock-&gt;__data.__nr_writers_queued == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Overflow on number of queued writers.  */</span></span><br><span class="line">      --rwlock-&gt;__data.__nr_writers_queued;</span><br><span class="line">      result = EAGAIN;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> waitval = rwlock-&gt;__data.__writer_wakeup;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Free the lock.  */</span></span><br><span class="line">      lll_unlock (rwlock-&gt;__data.__lock, rwlock-&gt;__data.__shared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Wait for the writer or reader(s) to finish.  */</span></span><br><span class="line">      lll_futex_wait (&amp;rwlock-&gt;__data.__writer_wakeup, waitval,</span><br><span class="line">              rwlock-&gt;__data.__shared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Get the lock.  */</span></span><br><span class="line">      lll_lock (rwlock-&gt;__data.__lock, rwlock-&gt;__data.__shared);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* To start over again, remove the thread from the writer list.  */</span></span><br><span class="line">      --rwlock-&gt;__data.__nr_writers_queued;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* We are done, free the lock.  */</span></span><br><span class="line">  lll_unlock (rwlock-&gt;__data.__lock, rwlock-&gt;__data.__shared);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">weak_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)</span><br><span class="line">hidden_def (__pthread_rwlock_wrlock)</span><br></pre></td></tr></table></figure></p><h2 id="辅助函数详解"><a href="#辅助函数详解" class="headerlink" title="辅助函数详解"></a>辅助函数详解</h2><h3 id="THREAD-GETMEM"><a href="#THREAD-GETMEM" class="headerlink" title="THREAD_GETMEM"></a>THREAD_GETMEM</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Read member of the thread descriptor directly.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> THREAD_GETMEM(descr, member) \</span></span><br><span class="line">  (&#123; __typeof (descr-&gt;member) __value;                \</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) == <span class="number">1</span>)                 \</span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">"movb %%fs:%P2,%b0"</span>              \</span><br><span class="line">         : <span class="string">"=q"</span> (__value)               \</span><br><span class="line">         : <span class="string">"0"</span> (<span class="number">0</span>), <span class="string">"i"</span> (offsetof (struct pthread, member)));     \</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) == <span class="number">4</span>)                \</span><br><span class="line">       <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">"movl %%fs:%P1,%0"</span>               \</span><br><span class="line">         : <span class="string">"=r"</span> (__value)               \</span><br><span class="line">         : <span class="string">"i"</span> (offsetof (struct pthread, member)));        \</span><br><span class="line">     <span class="keyword">else</span>                     \</span><br><span class="line">       &#123;                      \</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">sizeof</span> (__value) != <span class="number">8</span>)               \</span><br><span class="line">     <span class="comment">/* There should not be any value with a size other than 1,       \</span></span><br><span class="line"><span class="comment">        4 or 8.  */</span>                 \</span><br><span class="line">     <span class="built_in">abort</span> ();                    \</span><br><span class="line">                        \</span><br><span class="line">   <span class="keyword">asm</span> <span class="keyword">volatile</span> (<span class="string">"movq %%fs:%P1,%q0"</span>              \</span><br><span class="line">           : <span class="string">"=r"</span> (__value)               \</span><br><span class="line">           : <span class="string">"i"</span> (offsetof (struct pthread, member)));        \</span><br><span class="line">       &#125;                      \</span><br><span class="line">     __value; &#125;)</span><br></pre></td></tr></table></figure><h1 id="rwlock的GLIBC2-30实现"><a href="#rwlock的GLIBC2-30实现" class="headerlink" title="rwlock的GLIBC2.30实现"></a>rwlock的GLIBC2.30实现</h1><h2 id="INIT-1"><a href="#INIT-1" class="headerlink" title="INIT"></a>INIT</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_rwlock_init.c</span></span><br><span class="line"><span class="comment">/* See pthread_rwlock_common.c.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_rwlock_init (<span class="keyword">pthread_rwlock_t</span> *rwlock,</span><br><span class="line">               <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *attr)</span><br><span class="line">&#123;</span><br><span class="line">  ASSERT_TYPE_SIZE (<span class="keyword">pthread_rwlock_t</span>, __SIZEOF_PTHREAD_RWLOCK_T);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pthread_rwlockattr</span> *<span class="title">iattr</span>;</span></span><br><span class="line"></span><br><span class="line">  iattr = ((<span class="keyword">const</span> struct pthread_rwlockattr *) attr) ?: &amp;default_rwlockattr;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span> (rwlock, <span class="string">'\0'</span>, <span class="keyword">sizeof</span> (*rwlock));</span><br><span class="line"></span><br><span class="line">  rwlock-&gt;__data.__flags = iattr-&gt;lockkind;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The value of __SHARED in a private rwlock must be zero.  */</span></span><br><span class="line">  rwlock-&gt;__data.__shared = (iattr-&gt;pshared != PTHREAD_PROCESS_PRIVATE);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strong_alias</code>是C的一个别名机制，定义<code>pthread_rwlock_init</code>是<code>__pthread_rwlock_init</code>的别名。别名包括strong和weak的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strong_alias (__pthread_rwlock_init, pthread_rwlock_init)</span><br></pre></td></tr></table></figure></p><p>它的实现在<code>libc-symbols.h</code>中。其中，<code>__typeof (name) aliasname</code>定义了一个<code>aliasname</code>，它的类型是<code>name</code>的类型。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Define ALIASNAME as a strong alias for NAME.  */</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> strong_alias(name, aliasname) _strong_alias(name, aliasname)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> _strong_alias(name, aliasname) \</span></span><br><span class="line">  <span class="keyword">extern</span> __typeof (name) aliasname __attribute__ ((alias (#name))) \</span><br><span class="line">    __attribute_copy__ (name);</span><br></pre></td></tr></table></figure></p><h2 id="LOCK-1"><a href="#LOCK-1" class="headerlink" title="LOCK"></a>LOCK</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_rwlock_wrlock.c</span></span><br><span class="line"><span class="comment">/* See pthread_rwlock_common.c.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">__pthread_rwlock_wrlock (<span class="keyword">pthread_rwlock_t</span> *rwlock)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (wrlock_entry, <span class="number">1</span>, rwlock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = __pthread_rwlock_wrlock_full (rwlock, CLOCK_REALTIME, <span class="literal">NULL</span>);</span><br><span class="line">  LIBC_PROBE (wrlock_acquire_write, <span class="number">1</span>, rwlock);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">weak_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock)</span><br><span class="line">hidden_def (__pthread_rwlock_wrlock)</span><br></pre></td></tr></table></figure><p><code>__pthread_rwlock_wrlock_full</code>使用原子操作实现的<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pthread_rwlock_common.c</span></span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol><li><a href="https://man7.org/linux/man-pages/man2/futex.2.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man2/futex.2.html</a><br> 附注一下，Linux的man page后面的数字序号有下面的含义：<ol><li>普通命令</li><li>系统调用</li><li>库函数</li><li>特殊文件,也就是/dev下的各种设备文件</li><li>文件的格式</li><li>游戏留的</li><li>附件，或者一些全局变量</li><li>是root专用的命令</li></ol></li><li><a href="https://man7.org/linux/man-pages/man7/futex.7.html" target="_blank" rel="noopener">https://man7.org/linux/man-pages/man7/futex.7.html</a></li><li><a href="https://www.cnblogs.com/pslydff/p/7041444.html" target="_blank" rel="noopener">https://www.cnblogs.com/pslydff/p/7041444.html</a></li><li><a href="https://gohalo.me/post/program-c-gdb-deadlock-analyze-introduce.html" target="_blank" rel="noopener">https://gohalo.me/post/program-c-gdb-deadlock-analyze-introduce.html</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;pthread_rwlock系列函数是pthread库的读写锁函数。随着版本的不同，它的实现也不同。&lt;br&gt;本篇的组织是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;前置知识&lt;ol&gt;
&lt;li&gt;GCC的扩展内联汇编&lt;/li&gt;
&lt;li&gt;Futex&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;两个版本的lowlevellock的实现&lt;/li&gt;
&lt;li&gt;两个版本的pthread_rwlock的实现&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Linux" scheme="http://www.calvinneo.com/tags/Linux/"/>
    
    <category term="pthread" scheme="http://www.calvinneo.com/tags/pthread/"/>
    
  </entry>
  
  <entry>
    <title>V8引擎编译</title>
    <link href="http://www.calvinneo.com/2020/11/21/v8-compile/"/>
    <id>http://www.calvinneo.com/2020/11/21/v8-compile/</id>
    <published>2020-11-20T16:45:42.000Z</published>
    <updated>2021-04-20T15:50:27.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在一个较老的环境下编译V8引擎，并全静态地链接到既有的游戏服务上。原因是我们必需一个很新的JS引擎，从而能支持WebAssembly。经过调研，我们认为使用V8是最好的。<br>我们的游戏服务使用GCC4.4.6，这是一个非常老的版本，甚至不能完整支持C++11标准，而即使是很老版本的V8都需要完整的C++11支持(GCC 4.8+)；进一步地最新版本的V8需要C++14标准的支持，这不仅体现在v8.h中出现了诸如<code>std::remove_cv_t</code>的C++14的标准库函数，还体现在C++14标准编译出来的库也没办法直接和原游戏的目标文件进行链接。因此我们的方案是将游戏中对V8强依赖的模块升级成C++14标准，主要步骤如下：</p><ol><li>从源码构建GCC和GLIBC</li><li>从源码构建V8静态库v8_monolith.a</li><li>将V8静态库、libc++、GLIBC和游戏模块全静态链接</li></ol><a id="more"></a><h1 id="编译GCC和GLIBC"><a href="#编译GCC和GLIBC" class="headerlink" title="编译GCC和GLIBC"></a>编译GCC和GLIBC</h1><p>见<a href="/2020/12/13/gcc-glibc-compile/">文章</a></p><h1 id="代码拉取"><a href="#代码拉取" class="headerlink" title="代码拉取"></a>代码拉取</h1><p>代码拉取值得单独开一节，因为虽然V8代码使用Git来管理的，但它却并不是传统的git clone的路数，而是需要借助gclient这个工具。<br>gclient，包括gn等工具都在<code>depot_tools</code>这个包里面，我们可以通过下面的链接得到这个包<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br></pre></td></tr></table></figure></p><p>在得到这个包后，我们还需要将它加到环境路径里面以方便访问<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=`<span class="built_in">pwd</span>`/depot_tools:<span class="string">"<span class="variable">$PATH</span>"</span></span><br></pre></td></tr></table></figure></p><p>然后，使用下面的命令拉取<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fetch</span> <span class="built_in">v8</span></span><br><span class="line"><span class="symbol">glient</span> sync</span><br></pre></td></tr></table></figure></p><p>如果出现gclient拉取问题，可以尝试修改.gclient文件如下所示<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">solutions = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"managed"</span>: False,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"src"</span>,</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://chromium.googlesource.com/v8/v8.git"</span>,</span><br><span class="line">    <span class="string">"custom_deps"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"deps_file"</span>: <span class="string">".DEPS.git"</span>,</span><br><span class="line">    <span class="string">"safesync_url"</span>: <span class="string">""</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>此外，url还可以尝试取github上的地址<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/chromium/</span>chromium.git</span><br></pre></td></tr></table></figure></p><h1 id="编译V8"><a href="#编译V8" class="headerlink" title="编译V8"></a>编译V8</h1><p>目前V8默认是使用Clang编译的，确实比GCC快很多，但由于我们最后还要和游戏进行链接，所以需要把工具链换成GCC。在<a href="https://chromium.googlesource.com/external/github.com/v8/v8.wiki/+/8c0be5e888bda68437f15e2ea9e317fd6229a5e3/Building-with-GN.md" target="_blank" rel="noopener">这篇wiki</a>中给出了从简单到复杂的不同的编译的流程。我试验下来直接用<code>gn</code>是最为方便的。</p><h2 id="修改编译器"><a href="#修改编译器" class="headerlink" title="修改编译器"></a>修改编译器</h2><p>V8默认的编译工具链是clang，我们要将它变成GCC。首先我们需要设置<code>use_custom_libcxx</code>，这个项目如果为true，就会走v8自带的编译工具，这样编译出来如果是d8还好，但我们需要静态库，这样肯定不行。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">use_custom_libcxx</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>然后我们需要修改<code>gn args</code>，添加下面的项目，目的是禁用clang相关的宏。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">is_clang</span> = <span class="literal">false</span></span><br><span class="line"><span class="attr">use_sysroot</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>为了防止<code>ld.gold</code>报错，还需要开启下面的选项。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">fatal_linker_warnings</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><p>但这么做还不够，需要在入口<code>build/config/BUILDCONFIG.gn</code>中，修改Linux下，<code>is_clang</code>为true的情况下，<code>toolchain</code>为GCC。否则，还是有一些代码会把<code>is_clang</code>的值变回true。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">_default_toolchain</span> = <span class="string">"//build/toolchain/linux:$target_cpu"</span></span><br></pre></td></tr></table></figure></p><p>紧接着，我们就要修改原来的gcc toolchain，将里面的配置替换成我们刚编译得到的GCC9，具体涉及下面的修改</p><ol><li><code>toolchain\gcc_toolchain.gni</code><br> 这是一个模板文件，我们需要修改GCC的<code>cc</code>、<code>cxx</code>、<code>alink</code>和<code>link_command</code>这几个项目。具体说来，包括：<ol><li>设置<code>cc</code>、<code>cxx</code>和<code>ld</code>到GCC9的bin目录下的对应程序；<br> 这里，ld就指定为g++即可</li><li>修改<code>extra_cppflags</code>添加GCC对应的include文件夹的路径；</li><li>对于<code>cc</code>和<code>cxx</code>两个tool，需要在最后加上<code>-static</code>；</li><li>对于<code>alink</code>和<code>link_command</code>，需要加上<code>libstdc++.a</code>。</li></ol></li><li><code>config\c++\BUILD.gn</code><br> 参照<code>toolchain\gcc_toolchain.gni</code>修改<code>cflags_cc</code>和<code>ldflags</code>。</li></ol><h2 id="去掉snapshot"><a href="#去掉snapshot" class="headerlink" title="去掉snapshot"></a>去掉snapshot</h2><p>snapshot技术是V8为了提高Context的加载速度引入的优化，将V8启动后的内存布局和JS函数预编译好的二进制对象写到专门的文件<code>shapshot_blob.bin</code>和<code>natives_blob.bin</code>中，并在每一次初始化的时候直接加载，以减少重复编译消耗。<br>修改<code>gn args</code>，添加<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">v8_use_external_startup_data</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure></p><h2 id="生成v8静态库"><a href="#生成v8静态库" class="headerlink" title="生成v8静态库"></a>生成v8静态库</h2><p>首先生成ninja构建文件<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gn gen <span class="keyword">out</span>.gn/x64.<span class="keyword">debug</span>/</span><br></pre></td></tr></table></figure></p><p>修改<code>gn args</code>，添加<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">v8_monolithic</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>然后使用下面的命令生成静态库，注意后面的<code>-j</code>不能加得太大，因为在编译比如torque的时候GCC会占用比较大的内存，如果并行度很高，可能就编不出来<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ninja -C <span class="keyword">out</span>.gn/x64.<span class="keyword">debug</span>/ v8_monolith -j2</span><br></pre></td></tr></table></figure></p><h1 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h1><p>通过下面的命令可以静态链接V8的Hello world程序。<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(</span>GCC_ROOT)/bin/g++ samples/bench.cpp -o bench -isystem<span class="variable">$(</span>GLIBC_ROOT)/<span class="keyword">include</span>/ -I. -Iinclude -isystem<span class="variable">$(</span>GLIBC) -nodefaultlibs  -DV8_COMPRESS_POINTERS -static <span class="variable">$(</span>V8_OBJ)/libv8_monolith.a -Wl,--start-group <span class="variable">$(</span>GCC_ROOT)/lib64/libstdc++.a  <span class="variable">$(</span>GLIBC_ROOT)/lib/libpthread.a <span class="variable">$(</span>GLIBC_ROOT)/lib/libdl.a <span class="variable">$(</span>GLIBC_ROOT)/lib/libm.a <span class="variable">$(</span>GLIBC_ROOT)/lib/librt.a <span class="variable">$(</span>GCC_GCC)/libgcc.a <span class="variable">$(</span>GCC_GCC)/libgcc_eh.a <span class="variable">$(</span>GCC_GCC)/libcommon.a <span class="variable">$(</span>GLIBC_ROOT)/lib/libc.a -Wl,--<span class="keyword">end</span>-group</span><br></pre></td></tr></table></figure></p><h1 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h1><h2 id="2558版本"><a href="#2558版本" class="headerlink" title="2558版本"></a>2558版本</h2><p>2558版本是一个较老的版本，它是使用Make和GYP来构建的。由于它同样需要移动语义，所以也要C++11的支持。主要涉及下面的修改</p><ol><li><code>build/standalone.gypi</code><br> 设置<code>$(snapshot)</code>为<code>off</code>。<br> 设置<code>clang%</code>为1。</li><li>Hello world链接过程 <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -pthread -fuse-ld=gold -fuse-ld=gold -m64 -m64 -rdynamic -rdynamic -Wl,<span class="comment">--threads -Wl,--thread-count=4 -Wl,--threads -Wl,--thread-count=4 -o hello -Wl,--start-group hello-world.o out_libs/libv8_libplatform.a out_libs/libicui18n.a out_libs/libicuuc.a out_libs/libv8_base.a out_libs/libv8_libbase.a out_libs/libicudata.a out_libs/libv8_nosnapshot.a -Wl,--end-group -ldl -lrt</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍在一个较老的环境下编译V8引擎，并全静态地链接到既有的游戏服务上。原因是我们必需一个很新的JS引擎，从而能支持WebAssembly。经过调研，我们认为使用V8是最好的。&lt;br&gt;我们的游戏服务使用GCC4.4.6，这是一个非常老的版本，甚至不能完整支持C++11标准，而即使是很老版本的V8都需要完整的C++11支持(GCC 4.8+)；进一步地最新版本的V8需要C++14标准的支持，这不仅体现在v8.h中出现了诸如&lt;code&gt;std::remove_cv_t&lt;/code&gt;的C++14的标准库函数，还体现在C++14标准编译出来的库也没办法直接和原游戏的目标文件进行链接。因此我们的方案是将游戏中对V8强依赖的模块升级成C++14标准，主要步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从源码构建GCC和GLIBC&lt;/li&gt;
&lt;li&gt;从源码构建V8静态库v8_monolith.a&lt;/li&gt;
&lt;li&gt;将V8静态库、libc++、GLIBC和游戏模块全静态链接&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="C++" scheme="http://www.calvinneo.com/tags/C/"/>
    
    <category term="V8" scheme="http://www.calvinneo.com/tags/V8/"/>
    
  </entry>
  
</feed>
