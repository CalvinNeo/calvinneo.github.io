<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ACM,字符串," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta name="keywords" content="ACM,字符串">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode解题报告">
<meta property="og:url" content="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://www.calvinneo.com/img/leetcode/3sum_tle.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leetcode/mergek_tle.png">
<meta property="og:updated_time" content="2020-08-09T16:01:59.812Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode解题报告">
<meta name="twitter:description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta name="twitter:image" content="http://www.calvinneo.com/img/leetcode/3sum_tle.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/"/>





  <title>Leetcode解题报告 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Leetcode解题报告
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T00:01:30+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在<a href="https://github.com/CalvinNeo/LeetCode" target="_blank" rel="noopener">GitHub上</a>，有些被坑的题目会专门写一篇post。<br>必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）<br>Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相等(Problem 14)，<code>std::map</code>查找元素(Problem 1)的复杂度为1，感觉这并不是很严谨的，后来在Google Codejam/Kickstart的官方题解上也看到类似的算法，只能说这是一种计算方式吧。<br>在刷Leetcode的时候，取得Accepted通常是容易的，但是如果能够翻翻Submissions里面速度靠前的答案，看看人家是怎么在同复杂度下进行常数优化也是很有必要的。</p>
<a id="more"></a>
<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>K-Sum经典题目，给定一串序列，找到a+b等于给定的n。<br>$O(n^2)$要T的，正解对任意的<code>i</code>，判断<code>target - i</code>是否在集合<code>s</code>中，如果不在，把<code>i</code>加到集合<code>s</code>中。注意因为Python中<code>dict</code>用散列表实现，所以查询复杂是$O(1)$的，这和C++中的<code>std::map</code>（RBT实现）不一样。<br>另外考虑如果给定数列是<strong>有序</strong>的，还可以使用二指针来做，这个在下面的3Sum等中非常常用了，因为sort的复杂度是$O(nlogn)$，可以直接忽略不计了。测试了一下，如果对这道题先sort一下，居然速度要快十倍。</p>
<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>链表比较麻烦，注意在两个链表全部遍历完毕后检查是否还有进位</p>
<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>计算最长不重复子串<br>从头开始遍历字符串<code>S</code>，记录字符<code>S[i]</code>出现位置到<code>ex</code>中。若<code>ex[S[i]]</code>已存在，即字符<code>S[i]</code>在<code>ex[S[i]]</code>（前出现）和<code>i</code>（后出现）出现过，这时候我们的最长长度便不能继续增长了，尝试用字符串<code>S[start, i - 1]</code>来更新最长字符串，并令<code>start = ex[S[i]] + 1</code>，即从<code>S[i]</code>前出现的下一个位置开始重新计算最长长度。这时相当于把字符<code>S[i]</code>从前出现移到了后出现，因此<code>ex[S[i]]</code>需要被更新到当前的<code>i</code>。<br>有个注意点，在更新<code>start</code>的过程中，我们实际上重复利用了<code>[ex[S[i]] + 1, i]</code>这段肯定不重复的序列，包括它们的<code>ex</code>值，但同时我们也舍弃了<code>[start(原), ex[S[i]]]</code>这区间，因此在下面的遍历过程中如果字符<code>ch</code>对应的<code>ex[ch]</code>值出现在这段区间中，那实际上应该等同于它未出现处理。</p>
<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h1><p>见<a href="/2017/02/04/Leetcode4_Median_of_Two_Sorted_Arrays/">文章</a></p>
<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h1><p><a href="/2017/08/11/Manacher算法/">马拉车算法模板题</a></p>
<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><p>对模<code>numRows * 2 - 2</code>讨论</p>
<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><p>python转成string在转回int强行干</p>
<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><p>看图说话题</p>
<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><p>通过整除和取余算出倒过来的数，比较和原来的数是否相等</p>
<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><p>编译原理复习题，撸个DFA。这里注意一下对<code>.</code>规则的处理，虽然NFA比DFA多了ε规则，但是NFA对于一个某个输入符号的下一个状态是确定的。而对于<code>.*c</code>这样的规则，如果读取到c，那么可以仍然在本状态，也可以通过c到下一个状态，因此是冲突的，要向前看一个字符。在本题中因为字母表就在<code>[a-z]</code>上，于是添加26条规则就可以了。<br>实际上可以DP搞</p>
<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><p>WA了n次，原来是和<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener">HDU1506直方图中最大的矩形面积</a>搞混掉了，这个不要求连续。<br>不会O(n)算法，看了答案发现也是DP。主要原理是对于令<code>i, j</code>分别为数组的左右边界，显然这样的容器最宽。把<code>i, j</code>相对移动，要想还比它容积大，就要比它高。于是对于任意的<code>ii, jj</code>，如果<code>height[ii] &lt;= height[i]</code>或<code>height[jj] &lt;= height[j]</code>那就不行了。注意不是<code>height[i + 1] &lt; height[i]</code>，这样遇到两个都不满足的情况就死循环了。</p>
<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h1><p>看名字想到后缀数组，然而并不是。直接O(nm)暴力就可以了，也可以用二分，还不如直接暴力</p>
<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><p>乍一看以为是01背包，然而并不是，看题目应该是和第一条类似，暴力就行了。于是照搬第一条撸了个$O(n^2)$的交上去，居然T了，看了一下T在倒数第二个点，卧槽还卡常啊。<br>查看题解，把对<code>j</code>的循环和仿照2Sum的使用<code>dict</code>查<code>k</code>去掉改成双指针夹逼法。这个方法在于遍历每个<code>i</code>，然后对剩下的两个数<code>j</code>和<code>k</code>从<code>j = i + 1</code>，<code>k = n - 1</code>开始相向搜索。<br>不过这次还是还是超时，根据<a href="https://leetcode.com/problems/3sum/?tab=Solutions" target="_blank" rel="noopener">这里的解释：But according to my submissions, this way will cause you double your time consuming almostly.</a>，可能是我取unique拖慢了（然而排序后求unique是O(n)的啊）<br>放一张图<br><img src="/img/leetcode/3sum_tle.png" alt=""></p>
<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h1><p>这k-Sum的题目没完没了了。这道题也是先排序，然后双指针相向移动，同时用<code>update</code>函数维护一个<code>best</code>表示最优解。</p>
<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p>问手机九宫格键盘上的若干数字总共能构成哪些字母，直接暴力模</p>
<h1 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h1><p>先放这儿吧。。</p>
<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>链表的基本操作，维护<code>[before, begin, end]</code>三个指针即可，注意head被删除的情况。</p>
<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><p>开一个栈维护就行了，注意pop的时候要先判断是不是空栈</p>
<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><p>归并两个数列，手残忘了<code>cur = cur.next</code>，然后又RE了，原来是<a href="https://www.douban.com/note/578832769/" target="_blank" rel="noopener">注释的预定义部分自己不要附上去</a></p>
<h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><p>卡塔兰数<code>C(n)</code>也表示所有在<code>n*n</code>格点中不越过对角线的单调路径的个数，所以直接递归搜索就全部能列出来。</p>
<h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>一开始是硬上21条的解法，结果T了。假设n个列表中总共有p个元素，那么外层的<code>while</code>循环一次添加一个元素，共<code>O(p)</code>次，内层的<code>for</code>循环是一趟n次。这种算法复杂度上限是<code>O(p*n)</code>。<br>Leetcode上的<a href="https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector/2" target="_blank" rel="noopener">top解法</a>是(C++)调用<code>n-1</code>次的<code>MergeTwoList</code>，归并一次的复杂度是两个列表长度之和，所以这种复杂度上限依然是<code>O(p*n)</code>。以上两种做法Python全被卡常卡掉了（而且卡在最有一个样例，那你告诉我为啥你不也把C++卡掉）。<br><img src="/img/leetcode/mergek_tle.png" alt=""><br>正解是二分分治对这<code>k</code>个<code>List</code>归并，这样可以优化到<code>O(p*logn)</code>的复杂度。<br>另外也有大佬直接上堆排了，我也是服</p>
<h1 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h1><p>又是链表题，直接记录<code>[before, begin, end]</code>交换就行了。标算是递归，我用的迭代，迭代在更新<code>end</code>时要注意<code>begin</code>为<code>None</code>的情况</p>
<h1 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h1><p>链表逆置问题</p>
<h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h1><p>两个指针，<code>i</code>用来遍历，<code>j</code>用来维护插入位置即可，注意到<code>i</code>始终是要比<code>j</code>快的，所以不会产生覆盖的问题</p>
<h1 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h1><p>同26</p>
<h1 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h1><p>不使用乘除和模实现整数除法，这里也不使用加减法</p>
<h2 id="使用位运算实现整数加减法"><a href="#使用位运算实现整数加减法" class="headerlink" title="使用位运算实现整数加减法"></a>使用位运算实现整数加减法</h2><p>两个比特$x (b)$和$y (b)$相加，结果需要两个比特来盛放，可能为$00 (b)$、$01 (b)$、$10 (b)$。注意到高位的比特值为$x \, and \, y$的结果，而低位的比特值为$x \, xor \, y$的结果，于是整个结果是$(x \, xor \, y) \, or \, (x \, and \, y)$</p>
<p>减去一个数等于加上这个数的补码</p>
<h2 id="使用加减运算实现整数除法"><a href="#使用加减运算实现整数除法" class="headerlink" title="使用加减运算实现整数除法"></a>使用加减运算实现整数除法</h2><p>这里需要使用快速幂的思想，减去小于被减数$a$的尽可能大的$b \times 2^n$。这里注意的是Python中的<code>Integer</code>是没有范围的，所以不能使用补码等运算，对于溢出的情况也要专门判断。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return min(<span class="name">max</span>(<span class="name">-2147483648</span>, res), <span class="number">2147483647</span>)</span><br></pre></td></tr></table></figure>
<h1 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30. Substring with Concatenation of All Words"></a>30. Substring with Concatenation of All Words</h1><p>题目中一个不和谐的点是字典中的所有的字都是一样长的。这个条件有点强啊。<br>写了一发暴力搜，也就是从<code>i</code>开始查看能否得到合法的子串。WA了一发发现字典中可能存在重复的字，这就说明要在提出的<code>s</code>的子串中出现两次。果断T了。<br>后面就是利用这个一样长的条件，这意味着我们可以不要从所有的<code>i</code>开始搜。我们令所有词的长度都是<code>l</code>。那么我们只需要从<code>[0..i)</code>位置开始按词搜索就行了。我们用<code>st</code>维护我们搜索的起点，用<code>used</code>维护目前已经找到的词。那么如果我们在<code>j</code>处成功，那么就执行<code>j += l</code>，将<code>j</code>指向下一个词（因为后面仍然可能有符合要求的）；如果我们在<code>j</code>处失败，也就是出现了不在字典<code>d</code>或者多于字典<code>d</code>中的词时，就执行<code>st += l</code>右移一个词，并且从<code>used</code>中移除原先<code>st</code>对应的词。特别地，我们要维护<code>st</code>不能超过<code>j</code>。</p>
<h1 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h1><p>在我的某篇文章里讲过直接求<a href="/2016/11/07/POJ1037/">nth perm</a>的做法<br>这道题目首先是找规律，还是挺有意思的。我们从倒数第二个数开始倒序取<code>i</code>，不断尝试把<code>nums[i]</code>与其后面满足<code>nums[j] &gt; nums[i]</code>的最小的<code>nums[j]</code>交换。实际上我们要一个在尾部的最长的下降序列<code>[i-1, end)</code>。我们应当从尾到头找，因为<code>i</code>位置后数列一定是降序的，否则<code>i + 1</code>位置时算法就应当结束了。交换完后，我们将<code>i</code>位置后的序列片段按升序排列好（这时候该片段是最小的）便得到了最终答案。如果没有的话我们令<code>i--</code>继续循环。</p>
<p>此外，Python2里面的list切片是返回的一个新list而不是引用，写代码的时候被坑了次。</p>
<h1 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h1><p>好像17年哪个公司的笔试题里面出现过这一条的。<br>简单的思考了下，这条是DP。我们令<code>dp[i]</code>表示字符串在<code>i</code>位置最长括号串的左边界，初始化为<code>dp = range(i)</code>。因此对于每一个<code>s[i] = &#39;)&#39;</code>，我们从<code>j = i - 1</code>开始根据<code>dp[j]</code>往前跳转，直到<code>dp[j] == j</code>，此时我们看<code>s[j]</code>是否为<code>&#39;(&#39;</code>即可。注意最后还要根据<code>dp</code>算一个<code>ans</code>，否则<code>()()</code>这种情况就是2而不是4了。<br>写的时候很粗心，WA了n次。</p>
<h1 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h1><p>先二分一次找到第一个比<code>arr[0]</code>小的点，也就是唯一一个下降点，以此点将串一分为二，对两边数组分别进行二分</p>
<h1 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h1><p>同样是二分两次，第一次找到最左边边界，第二次找到最右边边界</p>
<h1 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h1><p>简单的二分</p>
<h1 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h1><p>使用回朔法求解，<a href="https://github.com/CalvinNeo/sudoku_solver" target="_blank" rel="noopener">代码修改自我的github</a><br>在修改代码时类<code>back_solver</code>方法和里面的<code>solve_iter</code>在返回结果<code>res</code>时出现了为None的问题，后通过改为<code>self.res</code>解决。</p>
<h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><p>dfs即可</p>
<h1 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h1><p>解法类似，这次每个数只能使用若干次</p>
<h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h1><p>在一个无序列表中找第一个没有出现的正整数。<br>这是一个很有意思的桶排序的题目。遍历数组，使用$h(x) = x - 1$将值为$x$($0 &lt; x &lt; length$)的数与$x - 1$位置上的数进行交换，这样经过$O(n)$后数组便会变成有序的。</p>
<h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><p>看上去类似于第11题。<br>首先先想naive的$n^2$解法，对于每一个位置<code>i</code>，分别寻找其左右侧最高的柱子<code>l[i]</code>和<code>r[i]</code>，那么<code>i</code>处水柱的“海拔”是<code>min(l[i], r[i])</code>。显然我们发现寻找左右侧最高的柱子这个过程可以DP。<br>下面使用<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener">HDU1506直方图中最大的矩形面积</a>的方法进行dp优化。其原理是如果<code>j+1</code>处水柱比<code>j</code>处的高，那么它肯定比<code>r[j+1]</code>处水柱高。</p>
<h1 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43. Multiply Strings"></a>43. Multiply Strings</h1><p>大数相乘，瞎搞一下就行</p>
<h1 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h1><p>类似第10题，可以通过DFA来做。这里使用DP来做</p>
<h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><p>青蛙跳，给定数组<code>nums</code>，<code>nums[i]</code>表示在<code>i</code>位置能跳的最远距离，求达到最后坐标跳的最小次数。不禁想起悲惨的LCM Walk推公式题。<br>记到<code>i</code>点的最少步数是<code>l[i]</code>，这条naive的方法自然是对于每一个<code>i</code>，用它来尝试更新自己的跳跃距离范围<code>[i, i + nums[i]]</code>内的所有的<code>l[j]</code>，这样是个$O(n^2)$的复杂度，会超时。<br>查看题解，实际上这是一个贪心问题，我们使用<code>l</code>记录跳<code>s</code>步达到的最远距离，这说明数组<strong>整个</strong><code>[0..l]</code>片段<strong>至多<code>s</code>步</strong>便能到达。使用<code>r</code>记录跳<code>s + 1</code>步达到的最远距离，显然<code>r &gt; l</code>。<br>下面我们对于每一个<code>i</code>，查看它需要用几步才能到达，期间需要同步更新<code>l</code>和<code>r</code>：</p>
<ol>
<li><p>正常情况<br>如果说<code>i</code>小于等于<code>l</code>，这说明<code>i</code>肯定是能够在<code>s</code>步内达到的。<br>下面我们要尝试更新<code>r</code>。<code>i</code>位置能够达到的最远范围是<code>nums[i] + i</code>，这说明如果我们在<code>s + 1</code>选择在<code>i</code>位置跳，那么能够<strong>覆盖<code>[i, i + nums[i]]</code></strong>这段距离。因为<code>i &lt; l</code>，所以在<code>i</code>位置跳能够覆盖<code>[0, i + nums[i]]</code>这段距离，我们用它和<code>r</code>取大值来更新<code>r</code>，如果需要记录起跳点<code>p[s + 1]</code>，这时候也应当同时使用<code>i</code>比较更新。</p>
</li>
<li><p>额外情况<br>如果<code>i</code>大于<code>l</code>，即跳<code>s</code>步<strong>肯定</strong>不能达到了，就必须多跳一步了，此时总步数变为<code>s + 1</code>。<br>这种情况是可能发生的，虽然我们遍历<code>i</code>是一次一格，跳是一次若干格，但遍历到<code>i</code>时可能已跳次数<code>s</code>远少于<code>i</code>。<br>我们来看看跳完这<code>s + 1</code>步后能够达到的最远距离是什么呢？答案是<code>i - 1</code>位置时的范围<code>[0, r]</code>，起跳点<code>p[s + 1]</code>在小于等于<code>i - 1</code>的某处。如果<code>r &lt; i</code>的话，那么终点便是不可达的，但题目中保证了终点可达。所以我们用<code>r</code>来更新<code>l</code>。<br>接下来，<code>i</code>小于等于<code>l</code>，我们按照正常情况继续处理。</p>
</li>
</ol>
<h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><h1 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h1><p>我这里使用了字典来维护重复的数，在Leetcode里面我看到了一个较为巧妙的处理重复的方法<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">length</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="comment">// 在同一个循环里面，如果i位置的值和i-1位置的值相同，而i-1位置的数没有被使用，那么i位置肯定也不会被使用</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; !used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h1><p>这让人联想到$O(1)$空间转置矩阵的题目，但本题是顺时针旋转而不是转置。<br>由旋转公式得$ \begin{bmatrix} x \\ y \end{bmatrix} $变成$ \begin{bmatrix} y \\ -x \end{bmatrix} $。如果把这个变换看成两个变换的组合，第一个是关于次对角线的对折，第二个是关于横轴的对折，那么代码会更容易写，因为不要想inplace矩阵转置一样需要考虑一个链的问题了。<br>这里注意一下python的列表生成器可以使用两个循环变量，如<code>[(x, y) for x in xrange(m) for y in xrange(m - x)]</code>，但注意<code>x</code>一定要在使用前有定义。<br>本题也可以使用矩阵转置的方法来做。以3行3列的矩阵为例，将其按行展开为一维数组。得到三条变换链：0-2-8-6-0、1-5-7-3-1、4-4。容易发现对于每个链，我们用前一个位置的值给后一个位置赋值即可，如2号位的新值为0号位的旧值。不过我们还要防止重复遍历链，例如我们首先以0号位为链头遍历完第一条链，以1号位为链头遍历完第二条链，但是位置2已经在第一条链中遍历过了。为了解决这个问题，我们在位置<code>i</code>处要确定是否要以这个位置作为新链的链头，例如我们以2位链头开始遍历，发现在2-8-6-0-2的序列中出现了位置0是小于2的，这种情况是不可能的。容易发现每条链的链头都是这条链中位置号最小的元素，这是因为我们是从0开始按顺序以每个位置作为链头的。</p>
<h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h1><p>Anagrams指的是将原单词或短语字母打乱顺序，形成新的单词或短语，如“Tom Marvolo Riddle”变成“I am Lord Voldemort”<br>这道题将单词的每个字母sort作为key，然后用dict记录每个key拥有的所有单词，最后遍历输出即可。</p>
<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h1><p>快速幂模板题</p>
<h1 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h1><p>在<a href="http://paste.ubuntu.com/25416005/" target="_blank" rel="noopener">Submission</a>里面看到有人用位运算（因为Python里面int无限大所以都不需要bitset）来搞的</p>
<h1 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h1><p>受上题影响这次用位运算搞一波<br>首先同样是按行搜索，每一行尝试放一枚棋子，递归深度$O(n)$。</p>
<h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h1><p>这是一个经典的动态规划问题。由于在每一点<code>i</code>都可以选择继续延伸之前的串（其和为<code>acc</code>）或者打断重新开始。明显当<code>acc + nums[i] &gt;= 0</code>时保留之前的串是有增益的，否则就打断重来。使用<code>m</code>维护历史上最长的串的长度。</p>
<h1 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h1><p>这条题目我思路不够清晰，主要是找规律发现数列<code>+(n-1), +(m-1), -(n-1), -(m-2), +(n-2), -(m-3), -(n-3), ...</code>，对第0项特别处理，然后<code>x</code>、<code>y</code>往下递推即可。<br>查看题解发现思路更便捷一点，它的想法是依次循环将最上、最右、最下、最左的行/列添加入<code>ans</code>数组中，每次添加完后更新指针。终止条件是上下界或者左右界溢出。<br>在discuss里面还看到一个骚气的Python解法，这个感觉就像我们把梨子拿在手上一边转一边削梨子一样。其中<code>zip(*matrix)</code>实际上转置了矩阵，如<code>[[1,2,3], [4,5,6]]</code>变成<code>[(1, 4), (2, 5), (3, 6)]</code>。而<code>zip(*matrix)[::-1]</code>实际上逆时针旋转了矩阵。<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(<span class="keyword">self</span>, matrix)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">return</span> matrix <span class="keyword">and</span> list(matrix.pop(<span class="number">0</span>)) + <span class="keyword">self</span>.spiralOrder(zip(*matrix)[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>这里似乎在Python二维数组切片上遇到了坑，对二维数组<code>a</code>进行数组切片<code>a[1:2][0]</code>返回的是一个二维数组，而不是一维数组。<br><strong>由此我们看出，在写题时要是能做到先动脑，再动手，那么是事半功倍的</strong></p>
<h1 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h1><p>同45，这次只要输出能否到达。</p>
<h1 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h1><p>首先是区间合并的原理，假设两个区间$(l, r)$和$(l2, r2)$，令$l2 \ge l$，则当$r \ge l2 \ge e$时区间能够合并。<br>因此，首先对<code>intervals</code>数组按照左边界大小排序，然后从头开始遍历该数组，每次试图运用上面的规则合并区间。如果不满足上面的规则，那么先前已合并了的区间就是最大的区间了，将其添加入结果数组中，并对下面的数组重新开始运用该规则。</p>
<h1 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h1><p>这道题一开始想用二分，不过写砸了，因为可能原先的区间也要合并一部分。后来直接<code>O(N^2)</code>解决了。</p>
<h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h1><p>简单题，注意要strip下</p>
<h1 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h1><p>这条是简单的模拟，分为4个方向，长度从<code>l - 1</code>到<code>0</code>，注意<code>0</code>是一个合法状态。</p>
<h1 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h1><p>类似<code>next_permulation</code>函数，见<a href="/2016/11/07/POJ1037/">POJ 1037这篇文章</a></p>
<h1 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h1><p>链表题，看图说话</p>
<h1 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h1><p><code>m - 1</code>个向右和<code>n - 1</code>个向下自由排列共有$\frac{(m + n - 2)!}{(m - 1)! (n - 1)!} $中方案</p>
<h1 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h1><p>二维dp模板题<br>注意初始化二维数组时不要犯<code>[[0] * 5] * 3</code>的常见错误，最好用列表生成器</p>
<h1 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h1><p>处理一下进位即可</p>
<h1 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h1><p>见29</p>
<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h1><p>二分即可，注意取整</p>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h1><p>第<code>i</code>级可以从第<code>i - 1</code>级过来，也可以从第<code>i - 2</code>级过来</p>
<h1 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h1><p>DP是肯定的，定义数组<code>dp[m][n]</code>，<code>dp[i][j]</code>表示<code>word1[1..i]</code>和<code>word2[1..j]</code>的编辑距离，从1开始方便后面边界。<br>首先要先确定添加、删除和替换三个操作对应到状态转移上，这容易想到对于<code>word1</code>来说，删除<code>i</code>位置意味着忽略<code>i</code>位置对结果的<code>dp[i][j]</code>的影响，所以是 <code>dp[i-1][j] + 1</code>，其中<code>+ 1</code>是删除的成本。其他两个操作可依次得出。<strong>当<code>word1[i-1] == word2[j-1]</code>时<code>dp[i][j] = dp[i-1][j-1]</code>不能漏掉</strong>。<br>然后还要确定递归边界，不只是<code>dp[0][0] = 0</code>了，也要设定<code>dp[i][0]</code>和<code>dp[0][j]</code></p>
<h1 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. Set Matrix Zeroes</h1><p>根据Follow up的要求，一个使用$O(mn)$的方法是遍历一遍<code>matrix</code>，然后将0的格子全部填好，最后and下<br>一个使用$O(m+n)$空间的方法是遍历一遍<code>matrix</code>，然后对每个0格子，标记其行号和列号，最后把所有的被标记行列全部置零<br>最好的是$O(1)$方法，把这$O(m+n)$的空间移到<code>matrix</code>的第0行和第0列上。注意整个过程不是迭代的，如果一个格子被设为0，它不可以再将自己所在行列设为0。特别是第0行列的清空工作一定要在最后完成。</p>
<h1 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a>74. Search a 2D Matrix</h1><p>按行二分</p>
<h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h1><p>根据Follow up要求，需要一趟遍历搞定。解法如26题，这里使用三个指针，<code>i</code>负责遍历，<code>l</code>维护0值区间$[0,l)$，<code>r</code>维护2值区间$(r, length-1]$，注意到整个过程中$i \gt l$且$r \ge l$。使用多指针维护插入位置是一个常用的方法，在三向快速排序中也有用到。<br>题解给出了<a href="http://paste.ubuntu.com/25422191/" target="_blank" rel="noopener">四种方法</a></p>
<h1 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h1><p>感觉有点像3，不过这道题需要考虑每个字符的数量，如<code>minWindow(&quot;a&quot;, &quot;aa&quot;)</code>结果是<code>&quot;&quot;</code>不是<code>&quot;a&quot;</code><br>这一条的思路是先找到<code>T</code>的匹配，然后试图移动窗口的左边界，使得匹配最小<br>当<code>d[ch] == cd[ch]</code>而不是<code>d[ch] &gt;= cd[ch]</code>时自增计数器，这样能够保证每个不同字符在达到规定数量时刻只会被统计一次（由于先保证有匹配，再保证匹配最小，所以每个字符数量一旦达到规定数量后就会一直保持在规定数量之上）。</p>
<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><p>这条递归容易写T，不能新建list，题解使用了里面数组生成器，涉及到它的一些的性质。</p>
<h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><p>此题有非递归解法<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="string">[[]]</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">    res.extend(<span class="string">[[i]+x for x in res])</span></span><br></pre></td></tr></table></figure></p>
<p>此外对于C++可以借助于位运算的性质来做<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int i=u; i; i=(i-1)&amp;u)&#123;</span><br><span class="line">    // bit map i to array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="81-Search-in-Rotated-Sorted-Array-II"><a href="#81-Search-in-Rotated-Sorted-Array-II" class="headerlink" title="81. Search in Rotated Sorted Array II"></a>81. Search in Rotated Sorted Array II</h1><p>要求在一个旋转了的有序序列中查找是否存在某项。相比之前那一题，现在允许重复了。<br>同样，我们要去寻找序列里面存在唯一一个下降点。我们讨论一下新的二分情况</p>
<ol>
<li><code>arr[l] &lt; arr[r]</code><br> 则下降点只可能位于<code>[r, ]</code>，类似<code>[5,6,7,5]</code>中r为7</li>
<li><code>arr[l] == arr[r]</code><br> 则下降点位于内部，类似<code>5,6,7,5</code>中r为5。<br> 有个特例是当<code>l==r</code>时，两个必然相等的。</li>
<li><code>arr[l] &gt; arr[r]</code><br> 下降点只可能出现在<code>[l, r]</code>区间内部，如<code>[6,7,1,2]</code></li>
</ol>
<p>注意，这一条有个corner case就是<code>[1,1]</code>，很难找到splitter。特判一下这种情况，返回0就行。    </p>
<h1 id="82-Remove-Duplicates-from-Sorted-List-II"><a href="#82-Remove-Duplicates-from-Sorted-List-II" class="headerlink" title="82. Remove Duplicates from Sorted List II"></a>82. Remove Duplicates from Sorted List II</h1><p>简单题</p>
<h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="noopener">HDU1506老题新做</a></p>
<h1 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85. Maximal Rectangle"></a>85. Maximal Rectangle</h1><p>这似乎是我做过的NUAA-HHU的一条赛题啊，典型的二维DP，不过实际上细节还是比较多的。<br>思路就是从左、右、左上角三个位置DP，其中左右是最优化最长的宽为1的“条”，左上角向下拓宽是要同时考虑<code>dp[i-1][j-1]</code>形成的矩形的左边界以及<code>i</code>行的左边界取大值，向右拓宽同理。<br>题解是借助于Largest Rectangle in Histogram的思路做的，可以参考</p>
<h1 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h1><p>简单题</p>
<h1 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87. Scramble String"></a>87. Scramble String</h1><p>一开始觉得这道题可以形成所有的排列，于是统计字符数量1WA。后来重新理解了题意，原来是树只能建一次，然后可以不停调换。<br>显而易见这种变换有一个性质，如果我们选择一个分割点，我们便能够将其分为左右儿子，之后的调换顺序只会改变左右，不会影响分组，于是我们想到递归地枚举所有的分割点，这样可以先递归判断子树是否是Scramble的。将原问题分解为子问题（子树）的时候需要考虑两种情况，即如果我们对<code>s1</code>枚举到分割点为<code>i</code>时，那么对应到<code>s2</code>可以在<code>i</code>和<code>len - i</code>处分割。<br>这条击败的不多，常数优化有待完善。</p>
<h1 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h1><p>格雷码，公式忘了，可以用三位找规律，注意格雷码是不唯一的</p>
<h1 id="90-Subsets-II"><a href="#90-Subsets-II" class="headerlink" title="90. Subsets II"></a>90. Subsets II</h1><p>这一条就是加上了去重，也没啥花头，毕竟要全部列出来嘛，那我还不如直接借助于set来判定了。<br>不过似乎go不能够使用list作为key。那就用str并编码一下咯。。。。<br>另外一种方法是排序，然后统计相同值的有多少数，例如有<code>l</code>个，那么对于每个现在已有的结果，都分别加上1到<code>l</code>个这个数。这种思路常常出现在有重复项的题目中。<br><strong>在写代码的时候发现，似乎不能指望<code>append</code>不会改变顺序</strong>， 现象是使用<code>[]int{0,3,5,7,9}</code>作为测试集时，下面的代码在最后一个循环中<code>ret[a]</code>的值会有变化。TODO<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">nr :<span class="type"></span>= len(ret)</span><br><span class="line">fmt.Printf(<span class="string">"=== %v %v %v\n"</span>, i, j, ret)</span><br><span class="line"><span class="keyword">new</span><span class="type">_ret</span> :<span class="type"></span>= make([][]int, nr)</span><br><span class="line">copy(<span class="keyword">new</span><span class="type">_ret</span>, ret)</span><br><span class="line"><span class="keyword">for</span> a :<span class="type"></span>= <span class="number">0</span>; a &lt; nr; a++&#123;</span><br><span class="line">    <span class="comment">// 对于每一个已有的lst，分别添加0-l个当前的数</span></span><br><span class="line">    <span class="keyword">for</span> k :<span class="type"></span>= i + <span class="number">1</span>; k &lt;= j; k++&#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%v/%v %v %v"</span>, a, nr, ret[a], nums[i:<span class="type">k</span>])</span><br><span class="line">        <span class="keyword">new</span><span class="type">_slice</span> :<span class="type"></span>= append(ret[a], nums[i:<span class="type">k</span>]...)</span><br><span class="line">        fmt.Printf(<span class="string">"%v\n"</span>, <span class="keyword">new</span><span class="type">_slice</span>)</span><br><span class="line">        <span class="keyword">new</span><span class="type">_ret</span> = append(<span class="keyword">new</span><span class="type">_ret</span>, <span class="keyword">new</span><span class="type">_slice</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改成下面这样就行了，看起来是<code>append</code>会改变第一个参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums[i:k]))</span><br><span class="line"><span class="built_in">copy</span>(r, nums[i:k])</span><br><span class="line">l := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(ret[a]))</span><br><span class="line"><span class="built_in">copy</span>(l, ret[a])</span><br><span class="line">new_slice := <span class="built_in">append</span>(l, r...)</span><br></pre></td></tr></table></figure></p>
<p>这条题目涉及下面的知识点：</p>
<ol>
<li>copy</li>
<li>slice</li>
</ol>
<h1 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h1><p>觉得很好的一题，建议先写一下练习一下搜索。Corner case是特别特别地多。<br>这道题的正解是DP。</p>
<h1 id="96-Unique-Binary-Search-Trees"><a href="#96-Unique-Binary-Search-Trees" class="headerlink" title="96. Unique Binary Search Trees"></a>96. Unique Binary Search Trees</h1><p>想想二叉排序树的性质，再从对称的观点看看样例，就解决了。</p>
<h1 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h1><p>暴力复杂度是$2^{min(len_1, len_2)}$，为了减到多项式复杂度，通常就是上DP，和LIS啥的一样，也是二维DP。<br>首先看最优子结构，显然在每一步，我们要么选择<code>s1</code>（从<code>dp[i-1][j]</code>过来），要么选择<code>s2</code>（从<code>dp[i][j-1]</code>过来）。然后还要与<code>s3</code>建立联系，于是我们定义<code>dp[i][j]</code>为最远可以达到的<code>s3</code>边界<br>交了一发，只击败了10%。。。这常数可以的，看了看题解，还有用dfs做的</p>
<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><p>从这题开始有一堆二叉树的题目<br>验证一个二叉树是否是二叉搜索树，注意二叉树需要左子树上所有的节点都小于根节点，所以这条也是递归地。</p>
<h1 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h1><p>困难的地方是需要保持二叉树的原先结构</p>
<h1 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h1><p>递归比较<code>l.left</code>和<code>r.right</code>以及<code>l.right</code>和<code>r.left</code>。</p>
<h1 id="102-Binary-Tree-Level-Order-Traversal"><a href="#102-Binary-Tree-Level-Order-Traversal" class="headerlink" title="102. Binary Tree Level Order Traversal"></a>102. Binary Tree Level Order Traversal</h1><p>层次遍历，就是把指针形式的二叉树转成数组形式</p>
<h1 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104. Maximum Depth of Binary Tree"></a>104. Maximum Depth of Binary Tree</h1><p>简单题</p>
<h1 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h1><p>构造树是一个递归的过程。对于前序来说，我们很容易找到root，剩下来的工作是把剩余的列表分给两个儿子。对于中序来说，我们找到root，它左边的点和右边的列表就分别是左儿子和右儿子。这道题要注意一下split的情况。<br>另外递归方法简单，但非递归方法。。。</p>
<h1 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal"></a>106. Construct Binary Tree from Inorder and Postorder Traversal</h1><p>由后序和中序生成树。</p>
<h1 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. Binary Tree Level Order Traversal II</h1><p>简单题</p>
<h1 id="109-Convert-Sorted-List-to-Binary-Search-Tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree" class="headerlink" title="109. Convert Sorted List to Binary Search Tree"></a>109. Convert Sorted List to Binary Search Tree</h1><p>将一个有序链表转成平衡二叉搜索树。这道题应该就是不停找中点。</p>
<h1 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. Balanced Binary Tree</h1><p>平衡二叉树高度差不能大于1。于是就是判断每个子树的高度差，注意还要检查子树是否递归地满足平衡性质</p>
<h1 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h1><p>BFS</p>
<h1 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h1><p>一个基本的遍历</p>
<h1 id="114-Flatten-Binary-Tree-to-Linked-List"><a href="#114-Flatten-Binary-Tree-to-Linked-List" class="headerlink" title="114. Flatten Binary Tree to Linked List"></a>114. Flatten Binary Tree to Linked List</h1><p>看上去就是把这个树preorder到链表上，但要求原地修改树。看起来，我们把每一个节点左子树遍历完的最后一个节点缓存下来，并且连接到右子树上面</p>
<h1 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115. Distinct Subsequences"></a>115. Distinct Subsequences</h1><p>注意边界条件是<code>dp[0][1..j] = 0</code>和<code>dp[1..i][j] = 1</code>，不能全为0。</p>
<h1 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h1><p>简单题</p>
<h1 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h1><p>动态规划模板题</p>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><p>在扫描时维护一个当前的最小值和当前的最大利润即可（一开始还想复杂了，是Easy提醒了我）。这种方法比较常用，在求最大权子矩阵中也会用到。</p>
<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h1><p>相比上面的题，我们可以进行任何次数的交易，但是不能engage in multiple transactions。只要知道<code>(b-a)+(c-b)=(c-a)</code>这道题目就很简单了，能赚就卖，不能赚就进</p>
<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h1><p>由于不能engage in multiple transactions，首先想到的是枚举断点，将本题转成两个Best Time to Buy and Sell Stock问题。不过显然$O(n^2)$是超时的，得DP下。<br>所以仿照前面直方图的思路，维护一个$[0,i]$的解和一个$[i,length-1]$的解。然后再一遍扫描。<br>这条也常数也比较大，只击败了20%左右</p>
<h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><p>说实话Leetcode的链表题和二叉树题我都不喜欢做，它的表示方法让人感觉很蛋疼，因此我写了两个辅助调试的函数，详见Github上的代码。<br>这道题就是两次dfs，第一个dfs是求出从某个节点往叶子方向权最长的一条链，类似于求和最大的子串一样。第二次dfs连接一个节点的两个儿子，看是否能得到一个更长的链。写的时候粗心得一腿，各种漏考虑条件。<br>有很大的常数优化空间，可以优化成一个dfs</p>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h1><p>这个题目挺没意思的，这里Python有个方法<code>.isalnum()</code></p>
<h1 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title="126. Word Ladder II"></a>126. Word Ladder II</h1><p>这道题，一看就是个bfs搜索。不过它一定要输出全部结果的全部路径，这就很麻烦。一开始写了个程序不仅T了还会M。<br>此外“Note that beginWord is not a transformed word”并不意味着<code>beginWord</code>不会在<code>wordList</code>里面出现。<br>最后还是T了，这条有点麻烦。</p>
<h1 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h1><p>在接受了上一条T的教训后这次改用了双向BFS搜索，虽然还是T，但是点从Case22变成了Case29。后来用C++重写了一遍才过。<br>这里先说明一下这条双向BFS写法上注意点，首先介绍一个很好的<a href="https://www.jianshu.com/p/ea5ca82e6bc6" target="_blank" rel="noopener">双向BFS的模板</a>。我们首先对模板进行改进，首先如果点<code>c</code>被正向bfs所发现，则将<code>vis[c]</code>标记为1，若是反向bfs，则标记为-1。然后我们定义一个<code>bfs(q, flag)</code>函数，<code>flag</code>表示我们现在是搜正向队列还是反向队列。那么在搜索过程中，一旦我们遇到一个<code>vis[mat[c][i]] == flag</code>，这就说明了我们的双向bfs相遇了，于是就返回。下面的问题就是如何记录搜索深度，一开始我的想法在两个队列<code>q1</code>和<code>q2</code>中记录当前节点<code>c</code>的访问深度，例如正向搜索首次发现了<code>c</code>节点连通的子节点<code>mat[c][i]</code>，那么就向正向搜索队列<code>q1</code>中增加<code>(mat[c][i], d + flag)</code>，其中<code>d</code>是<code>c</code>节点的搜索深度，容易得到起始节点的搜索深度是1，紧接着的正向队列的深度依次取2、3、4等。终点的搜索深度是-1，紧接着的反向队列的深度依次取-2、-3、-4等。与此同时使用<code>deep1</code>和<code>deep2</code>来分别维护正向和反向bfs达到的最大深度。但是在提交时发现这是不对的，例如当反向队列与正向队列相遇时，相遇点不一定是正向队列最深的点。例如从<code>cat</code>到<code>fin</code>可以有下面的搜索路径，我们看到走<code>cat -&gt; can &lt;- fan &lt;- fin</code>是最优解，但是如果按照维护的最大值的话，我们会算上<code>pat -&gt; paw</code>这没用的一步。</p>
<pre><code>q1 1: cat -&gt; pat
q1 1: cat -&gt; can
=================
q2 -1: fin -&gt; fan
=================
q1 2: pat -&gt; paw
=================
q2 -2: fan -&gt; can
</code></pre><p>所以我们将<code>deep1</code>和<code>deep2</code>去掉，而借助于<code>vis[c]</code>数组记录访问到<code>c</code>节点时的深度，这样我们就可以精确地知道相遇节点被正反向队列所访问的时间了。</p>
<h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h1><p>这条我是用反查字典+并查集实现的，不过其实可以直接用反查字典。</p>
<h1 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129. Sum Root to Leaf Numbers"></a>129. Sum Root to Leaf Numbers</h1><p>水题</p>
<h1 id="130-Surrounded-Regions"><a href="#130-Surrounded-Regions" class="headerlink" title="130. Surrounded Regions"></a>130. Surrounded Regions</h1><p>一个DFS了，比较取巧的是可以从边界先把能保留的O筛出来，然后将剩下的O清空。</p>
<h1 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131. Palindrome Partitioning"></a>131. Palindrome Partitioning</h1><p>这道题很无聊，就是要你列出所有回文串的分隔可能性，有趣的是下面一条</p>
<h1 id="132-Palindrome-Partitioning-II"><a href="#132-Palindrome-Partitioning-II" class="headerlink" title="132. Palindrome Partitioning II"></a>132. Palindrome Partitioning II</h1><p>这道题不太会，看了题解，原来就是首先找出来所有的回文数，然后套Word Break的模板。<br>T了一发，这是因为我是找出了所有的回文串<strong>文本</strong>，但实际上我们应当用<code>dp[i][j]</code>记录<code>[i,j]</code>是否是回文串。这个记搜一波即可</p>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>首先只要gas和cost的sum至少相等就可以实现，可以用归纳法证明。<br>其次，发现题意要求一个从唯一解起始节点<code>i</code>起经过所有节点的油量都大于零的性质，我们要找这个起始节点。进而可以发现从哪个节点开始找是无所谓的，因为每个节点总要经过一次。所以我们可以从例如0节点开始，在满足性质的情况下将序列向左右扩展，直到遍历玩所有的节点。一个具体的方法为首先尽可能往右移动左边界l，当l不能移动时则往左移动右边界r，直到l可以再次往右移动</p>
<h1 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a>135. Candy</h1><p>一上来就理解错误，只有当严格大于的时候才要求糖数多，例如<code>5 5 5 5</code>这种，每个人可以分糖<code>2 1 1 2</code>（当然最优解是<code>1 1 1 1</code>啦）<br>然后就是硬写，首先将原数组分成上升段、平行段和下降段，如<code>1 2 3 | 3 3 | 4 5 | 4 3</code>。标记每一段的长度为<code>segs[i]</code>，每一段最后一个人的糖果为<code>last_candy[i]</code>个。<br>上升段一定是从<code>last_candy[i-1]+1</code>开始以1为公差的等差数列。<br>下降段末项一定是1，为了尽可能小，所以是以<code>seg[i]</code>为首项，-1位公差的等差数列。但如果<code>last_candy[i-1]</code>小于等于<code>seg[i]</code>，那整个下降数列放不下，所以此时要提升<code>last_candy[i-1]</code>到<code>seg[i]+1</code>（注意只要改前一个数列的末项哦）</p>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>老题新做</p>
<h1 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137. Single Number II"></a>137. Single Number II</h1><p>这道题同样可以用异或来解决（当然也可以借助于set）。在上一题中，我们通过异或的性质，实现了值相同的数两两相消。在这一题中，我们希望出现三个相同的数才相消。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ones</span> = <span class="number">0</span></span><br><span class="line">twos = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x in nums:</span><br><span class="line">    <span class="built_in">ones</span> = (<span class="built_in">ones</span> ^ x) &amp; ~twos</span><br><span class="line">    twos = (twos ^ x) &amp; ~<span class="built_in">ones</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ones</span></span><br></pre></td></tr></table></figure>
<p>考虑一个比特位的情况。观察上面的代码，对于序列<code>1 1 1</code>能够得到<code>(ones, twos)</code>的值分别是<code>(0, 0), (1, 0), (0, 1), (0, 0)</code>。这里的<code>&amp; ~twos</code>用来表示进位，当<code>twos = 1</code>时说明目前已经出现了两次，于是我们归零<code>ones</code>。</p>
<h1 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138. Copy List with Random Pointer"></a>138. Copy List with Random Pointer</h1><p>一个单向链表，有一个<code>random_index</code>可以指向随机的节点，或者null，要求深复制这个链表。<br>一个很Naive的办法就是先构建next指针，再构建random指针。不过也可以一趟构建完。</p>
<h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>要根据字典进行分词。看起来是一个Trie的题目，题目也没规定大小写怎么说，而且也没说是否存在唯一表示。<br>花了很久尝试用AC自动机做，不过失败了。<br>其实这道题根本就不是AC自动机，直接<code>DP[pos]</code>维护一下从<code>pos</code>往后的子问题的答案就行了。</p>
<h1 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a>140. Word Break II</h1><p>类似139。</p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>这种链表题一般都要考虑快慢指针的解法。<br>首先只可能有一个环，所以直接搞。</p>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><p>比上面的一题要求找到环的起始点的位置。可以发现若第一次快慢指针交于点X，则环的长度$c$等于下次快指针追上慢指针时慢指针走过的距离。<br>设链表头到环起点距离$s$，环起点到交点X距离$a$，交点X到环起点距离$b$，有$a + b = c$。且$2(s + k_1 \, c + a) = s + k_2 \, c + a$，有$s + a = k \, c$，即$s = kc + b$。则将两个指针分别置于链表头和交点X，其交点就是环的起始点。</p>
<h1 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144. Binary Tree Preorder Traversal"></a>144. Binary Tree Preorder Traversal</h1><p>前序遍历，xjb写了个非递归版本</p>
<h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h1><p>经典的二叉树后序遍历问题，xjb写了个非递归版本</p>
<h1 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h1><p>在$O(1)$复杂度下，免不了Hash。但是为了能够方便进行排序，我们又要采用一个双向链表组成队列。于是就用一个dict来定位链表里面的各个Node。</p>
<h1 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h1><p>链表的插入排序，一开始写砸了，后来发现其实分成两个链表，从未排序的free list不停往排好序的sorted list插入元素。这道题Python居然T了、、、我也是服气。</p>
<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>写了几个辅助函数用来调试。这条就是按照CLRS上的思路写的快排，可参照第215条。居然T了<br>后来换成归并排序过了。</p>
<h1 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149. Max Points on a Line"></a>149. Max Points on a Line</h1><p>这是一条神经病题目，两个相同位置的点居然算不同点。所以我是不知道它怎么解释$[[1,1],[1,1],[1,1]]$输出3，$[[84,250],[0,0],[1,0],[0,-70],[0,-70],[1,-1],[21,10],[42,90],[-42,-230]]$输出6的？所以说这些相等的点互相组成直线，但是和任何其他直线都不共线是吧、、、那你告诉我为什么TestCase31输出25而不是56。。。我最后HardCode了$[[1,1],[1,1],[1,1]]$才AC的。</p>
<h1 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a>151. Reverse Words in a String</h1><p>这题有一点无理取闹的地方是要先将连续的空格合并成一个，然后就是一条经典的题目。原地解法是翻转每一个单词，再翻转整个字符串，代码只有很骚的一行<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="string">' '</span>.<span class="built_in">join</span>(<span class="built_in">map</span>(lambda x: x[::<span class="number">-1</span>], <span class="built_in">filter</span>(lambda x: x, s.<span class="built_in">split</span>(<span class="string">' '</span>))))[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h1><p>注意这条是子串而不是子序列。这个不同于最大和，可以维护一个全局最大和当前最大来做。<br>Bruteforce的做法是$O(n^3)$的，遍历所有可能的数组，并累乘。一个动态规划的思路是维护$dp[i]$作为一个累乘序列，这样的话是复杂度是$O(n^2)$。注意遇到0之后可能认为当前数组结束了，0后面的作为一个新数组处理。<br>不过正解是$O(n)$的，相比先前的最大和，它的转移方程考虑三个分支，分别是使用前一个dp的最大值、最小值（因为存在负数翻转的现象），或不使用。</p>
<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h1><p>旋转数组求最小元素，这是一道经典的二分搜索题目。</p>
<h1 id="154-Find-Minimum-in-Rotated-Sorted-Array-II"><a href="#154-Find-Minimum-in-Rotated-Sorted-Array-II" class="headerlink" title="154. Find Minimum in Rotated Sorted Array II"></a>154. Find Minimum in Rotated Sorted Array II</h1><p>一个恶心的题目，要是能一遍做对就很厉害了。这题告诉我二分法在查找更新的时候不能激进地<code>r = mid + 1</code>，也要考虑下<code>r = mid</code>这样。一般能确定<code>mid</code>肯定不对，那就用前者。<br>由此严格地来做，我们可以将二分分为两种类型，F/T…TTT和TTT…F/T型，由于我们始终是要找第一个T。对于前者，如果我们fail了<code>mid</code>，那么我们就要更新<code>l</code>到<code>mid + 1</code>，否则更新<code>r</code>到<code>mid</code>，注意我们不能激进地更新到<code>mid - 1</code>，因为<code>mid</code>可能是第一个T。对于后者我们就要更新<code>r</code>到<code>mid - 1</code>，否则更新<code>l</code>到<code>mid</code>。下面我们考虑<code>mid</code>的求法时需要做到极限情况下不陷入死循环，以区间<code>[3,4]</code>为例。假设<code>mid = (l + r) / 2</code>，即<code>mid = 3</code>。对于前一种情况，我们OK之后会更新到<code>[3,3]</code>，这时候<code>l == r</code>，我们可以成功返回结果。对于后一种情况，我们OK之后会更新到<code>[3,4]</code>，这时候死循环发生了。由此我们对于后者应该做<code>mid = (l + r + 1) / 2</code>的更新。<br>特别地，如果对于668题这种暂时无法确定是F/T…TTT和TTT…F/T型的，我们可以直接判断它是<code>r</code>到<code>mid - 1</code>型的还是<code>l</code>到<code>mid + 1</code>的，如果是<code>r</code>到<code>mid - 1</code>的算<code>mid</code>就要<code>+1</code>。默认<code>while (l &lt; r)</code>。</p>
<h1 id="155-Min-Stack"><a href="#155-Min-Stack" class="headerlink" title="155. Min Stack"></a>155. Min Stack</h1><p>设计一个最小栈，要求能够满足三个原语之外，还支持<code>getMin</code>操作，要求常数代价。这个和单调栈还不一样。<br>解法很神奇，就是每次入栈的时候多入一个当前元素的最小值。。。真贱。。。</p>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>找到两个链表的交点。注意一下链表的相交，在没有环的情况下一定是Y型而不是X型的，在有环的情况下那么两个链表一定最后进入同一个环。<br>本题是没有环的情况，容易发现将<code>headB</code>的链表头接到<code>headA</code>的尾巴后面，那么就能把本题化为第142题。<br>下面讨论有环的情况，首先判是否相交，根据上面的性质，我们只要找到A环上的一点，判断在不在另一个链表的环上就行了。<br>链表相交常被用在求普通二叉树的最近公共祖先上。</p>
<h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h1><p>裸二分吧</p>
<h1 id="164-Maximum-Gap"><a href="#164-Maximum-Gap" class="headerlink" title="164. Maximum Gap"></a>164. Maximum Gap</h1><p>这题是求一个未排序数列的有序形式相邻两个数的最大差，要求线性复杂度。不会，Related topic显示还是sort，难道是考桶排序？xjb写了个，然后面向OJ二分桶大小就过了、、、但是这条还是需要改一下的，自己做法其实很慢，只击败了2%的人。<br>看了一下题解，首先他根据鸽笼原理求出最大差值的<strong>下界</strong>，即$(mx - mi) / (n - 1)$，我们把它作为桶的大小，这样的好处是我们的最优解肯定不在某个桶内求得，而一定在桶间。</p>
<h1 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165. Compare Version Numbers"></a>165. Compare Version Numbers</h1><p>简单题，注意补零</p>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h1><p>一个很有趣的Brain teasing，要求找到出现超过<code>floor(n / 2)</code>次的元素</p>
<h1 id="174-Dungeon-Game"><a href="#174-Dungeon-Game" class="headerlink" title="174. Dungeon Game"></a>174. Dungeon Game</h1><p>这一条是倒推的动态规划，我们将原数组改为从1开始的数组，用<code>need[i][j]</code>表示从<code>(i, j)</code>到达公主所需要的最少HP，那么<code>need[n][m]</code>显然为1，我们要求<code>need[0][0]</code>。容易看出递推式为<code>need[i][j] = min(need[i][j + 1] - mat[i][j + 1], need[i + 1][j] - mat[i + 1][j])</code>。当<code>need[i][j] &lt;= 0</code>时，也就是说从<code>need[i][j]</code>往下走还会盈余HP，但是我们不能结算给<code>(i, j)</code>前的位置，这是由于在过程中的任何时候HP都不能小于等于0，因此不能先欠再还。实际上我们的<code>need[i][j]</code>必须始终大于等于1。</p>
<h1 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h1><p>在贪心时我们需要考虑一个问题，即类似<code>[76, 7621]</code>和<code>[76, 7698]</code>的情况，这两种情况下最优解分别为<code>76 7621</code>和<code>7698 76</code>，但是考虑<code>[7676, 76, 98]</code>和<code>[7676, 76, 54]</code>的情况就难以处理了。但其实这种情况不会存在，因为98一定会在7676前面被去掉。<br>写了一份提交，发现死在了219Case上，简化一下发现<code>[2, 213, 2281]</code>这个样例，原因是2281还是比2大的。这个判断太麻烦了！后来发现还不如在两个字符串不相等时把两个字符串两种组合<code>s1 + s2</code>和<code>s2 + s1</code>都试一下看哪个大呢。<br>在第321条中我们发现了类似的归并的问题。</p>
<h1 id="182-Duplicate-Emails"><a href="#182-Duplicate-Emails" class="headerlink" title="182. Duplicate Emails"></a>182. Duplicate Emails</h1><p>写了半天子查询，似乎不行。主要原因是必须要用到<code>GROUP BY</code><br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT Email <span class="keyword">FROM</span> Person</span><br><span class="line">GROUP BY Email</span><br><span class="line">HAVING COUNT(Email)&gt;1</span><br><span class="line"></span><br><span class="line">SELECT Email <span class="keyword">FROM</span>(</span><br><span class="line">    SELECT Email, COUNT(1) as Num </span><br><span class="line">    <span class="keyword">FROM</span> Person</span><br><span class="line">   <span class="built_in"> GROUP </span>BY Email</span><br><span class="line">) as e</span><br><span class="line">where Num &gt; 1</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT a.Email <span class="keyword">from</span> </span><br><span class="line">(SELECT p.Email, COUNT(p.Email) as cnt <span class="keyword">from</span> Person as p</span><br><span class="line">GROUP BY p.Email) as a</span><br><span class="line">where a.cnt &gt; 1</span><br></pre></td></tr></table></figure></p>
<h1 id="187-Repeated-DNA-Sequences"><a href="#187-Repeated-DNA-Sequences" class="headerlink" title="187. Repeated DNA Sequences"></a>187. Repeated DNA Sequences</h1><p>暴力dict一波？</p>
<h1 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188. Best Time to Buy and Sell Stock IV"></a>188. Best Time to Buy and Sell Stock IV</h1><p>相比III，现在我们最多可以执行k次而不是两次交易。首先想了一个xjb搞的算法，将所有的连续上升串找出来，然后排序并尝试提取出差最大的k个，这里注意如果不足k个的话也不影响，因为性质<code>(a - b) + (b - c) = a - c</code>。但是发现WA在了<code>2, [1,2,4,2,5,7,2,4,9,0]</code>，因此当我们的串的个数大于k时，我们需要尽量把这些区间合成到k个。<br>上面的想法想了半天不知道怎么搞，于是从Best Time to Buy and Sell Stock With Cooldown那条下手，用两个数组<code>sell</code>和<code>buy</code>分别表示第<code>i</code>天（从1开始）做至多<code>j</code>个任务的最大收益。写了一个<code>O(nk)</code>的算法，TLE了。<code>most_trans</code>表示第<code>i</code>天最多能做<code>(i + 1) / 2</code>个交易。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in xrange(1, n + 1): # at day i</span><br><span class="line">    most_trans = min((i + 1) / 2, k)</span><br><span class="line">    for j in xrange(1, most_trans + 1): # this <span class="keyword">is</span> j-th transaction</span><br><span class="line">        buy<span class="comment">[i]</span><span class="comment">[j]</span> = max( buy<span class="comment">[i - 1]</span><span class="comment">[j]</span>, sell<span class="comment">[i - 1]</span><span class="comment">[j - 1]</span> - prices<span class="comment">[i - 1]</span> )</span><br><span class="line"></span><br><span class="line">    for j in xrange(1, most_trans + 1): # this <span class="keyword">is</span> j-th transaction</span><br><span class="line">        sell<span class="comment">[i]</span><span class="comment">[j]</span> = max( sell<span class="comment">[i - 1]</span><span class="comment">[j]</span>, buy<span class="comment">[i - 1]</span><span class="comment">[j]</span> + prices<span class="comment">[i - 1]</span> )</span><br></pre></td></tr></table></figure></p>
<p>用C++改写了一下，发现<code>k</code>可能非常大，虽然后来将<code>buy</code>和<code>sell</code>优化成滚动数组，但还是开不了这么大的数组。于是发现当<code>k &gt; n</code>时这道题实际上退化为Best Time to Buy and Sell Stock II，于是可以$O(n)$时间，常数空间解决。<br>题解里面用最大堆的那个没有看懂。</p>
<h1 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189. Rotate Array"></a>189. Rotate Array</h1><p>简单题，rev两次</p>
<h1 id="190-Reverse-Bits"><a href="#190-Reverse-Bits" class="headerlink" title="190. Reverse Bits"></a>190. Reverse Bits</h1><p>这个很简单，直接不停<code>n &amp; 1</code>然后<code>n /= 2</code>即可</p>
<h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a>191. Number of 1 Bits</h1><p>这里使用<code>n &amp; (n - 1)</code>去掉末尾的0，或者使用<code>x &amp; -x</code>取到末尾的0</p>
<h1 id="195-Tenth-Line"><a href="#195-Tenth-Line" class="headerlink" title="195. Tenth Line"></a>195. Tenth Line</h1><p>Linux命令，，简单题</p>
<h1 id="198-House-Robber"><a href="#198-House-Robber" class="headerlink" title="198. House Robber"></a>198. House Robber</h1><p>简单的动态规划</p>
<h1 id="199-Binary-Tree-Right-Side-View"><a href="#199-Binary-Tree-Right-Side-View" class="headerlink" title="199. Binary Tree Right Side View"></a>199. Binary Tree Right Side View</h1><p>简单题</p>
<h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><p>一看应该就是条DFS裸题，转念一想像这种可以用搜索解决的集合分划问题也能用并查集搞。</p>
<h1 id="201-Bitwise-AND-of-Numbers-Range"><a href="#201-Bitwise-AND-of-Numbers-Range" class="headerlink" title="201. Bitwise AND of Numbers Range"></a>201. Bitwise AND of Numbers Range</h1><p>只要高位有进位，后面就肯定有0。只要有0，那一位AND的结果肯定为0。</p>
<h1 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204. Count Primes"></a>204. Count Primes</h1><p>求小于<code>n</code>的质数的数量，经过实测，<code>n</code>有至少499979的规模。因此打表的话就wa了。</p>
<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205. Isomorphic Strings"></a>205. Isomorphic Strings</h1><p>同构，很范畴论了。现在要判断两个字符串是不是同构的。<br>办法很简单，我们用第一个字符串构建一个查询字典，如果出现冲突就不同构。<br><strong>但是要正过来比一次，再反过来比一次</strong></p>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>特别经典的链表反转问题，迭代方法借助<code>prev</code>和<code>cur</code>指针。<br>题目还要求使用递归方法。</p>
<h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><p>判断一个有向图中是否存在环，拓扑排序。<a href="/2016/11/07/拓扑排序/">有关拓扑排序的内容，具体可见我的一篇博客</a>。<br>这边额外说一下有向图和无向图判环的方法。首先补充一下DFS的相关知识，一个无环的有向图当且仅当DFS中没有后向边，关于这个推论可以查看<a href="/2016/08/21/tarjan/">我的一篇博客</a>，因此我们只要做一次DFS搜索（使用黑白灰标记），并观察是否出现后向边即可。<br>相对于有向图，无向图还有一些额外的判环方法。首先是并查集。</p>
<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><p>我先研究了Word Break那条，写了个AC自动机，没过，于是先把这条给水掉</p>
<h1 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209. Minimum Size Subarray Sum"></a>209. Minimum Size Subarray Sum</h1><p>双指针经典题，一定要会！<br>我好久不写了，WA了好久</p>
<h1 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a>210. Course Schedule II</h1><p>看起来是个拓扑排序</p>
<h1 id="213-House-Robber-II"><a href="#213-House-Robber-II" class="headerlink" title="213. House Robber II"></a>213. House Robber II</h1><p>相比前一条，现在要求在环上DP了。当时觉着能够化为前一条来做，不过没怎么搞明白。其实给一个Hint就是第一个和最后一个房子不能同时被抢，所以问题就分解了。</p>
<h1 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214. Shortest Palindrome"></a>214. Shortest Palindrome</h1><p>这道题对我来说蛮难的，首先KMP比较难想，然后我KMP还写错了。</p>
<h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><p>快排模板题，居然卡了（天哪噜，原来是两种常见写法混起来用了），既然如此就来介绍一下快速排序的<a href="http://blog.csdn.net/a641324093/article/details/78307004" target="_blank" rel="noopener">两种常见方法</a>吧。<br>快速排序的一种经典写法<strong>挖坑法</strong>是先取<code>p = arr[fr]</code>为支点元素，然后我们一定要先从<code>arr[to]</code>开始遍历，这么做的目的是将第一个不符合的<code>arr[j]</code><strong>直接赋值给</strong><code>arr[fr]</code>（注意不需要交换了）。<br>注意一些错误的算法的实现总是不能有效地将<code>arr[fr]</code>移动到中间位置，所以我们必须得先把<code>arr[fr]</code>的槽空出来。建议在写快排时每次递归始终是在<code>[fr, pos - 1]</code>和<code>[pos + 1, to]</code>递归，并且<code>arr[pos]</code>放支点元素。我们还要考虑把等于的放到哪边，一般来说，如果我们取<code>arr[fr]</code>为支点，那么我们就要把等于支点的放到右边，这样才能够先把<code>arr[fr]</code>空出来，在下面的一个算法中，我们看到它使用<code>fr, l, r, to</code>将数列分为了四个部分，从而能在最后找到<code>arr[fr]</code>所放置的位置。但是对于上面的挖坑法来说，这是不必要考虑的，因为它保证了将第一个换掉<code>arr[fr]</code>。此外，在手写快排时写完一定要查一下当第一个元素是最小时是否成立，一般算法错就错在这里。<br>另一种方法，也是算法导论中介绍的，是仿照三路快排来做的。这种方法的主要特点是不再在数列两端来维护了，而是根据CLRS P96的那张图来维护，并且在最后唯一一次移动<code>arr[fr]</code>到准确位置。<br>注意如果说要找出<strong>前</strong>K个的话，可以使用$O(n)$建一个最小堆，然后做$k$次$O(lg \, n)$的弹出。<br>此外对这一题我还实现了一个堆排序，堆排序要稍微简单一点，我们主要注意在pushDown交换的时候，我们应当选择两个son最大的那个进行交换</p>
<h1 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a>218. The Skyline Problem</h1><p>这题实际上就是插线问点的问题，首先就是想到用离散化+线段树/树状数组来做。</p>
<h1 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a>221. Maximal Square</h1><p>这条比之前的第85条多了是正方形的条件，我们当时应该是做的这条，比矩形要简单很多</p>
<h1 id="222-Count-Complete-Tree-Nodes"><a href="#222-Count-Complete-Tree-Nodes" class="headerlink" title="222. Count Complete Tree Nodes"></a>222. Count Complete Tree Nodes</h1><p>经典题，计算完全二叉树的最后一个节点。这道题其实就是比较左右子树深度。</p>
<h1 id="223-Rectangle-Area"><a href="#223-Rectangle-Area" class="headerlink" title="223. Rectangle Area"></a>223. Rectangle Area</h1><p>这道题蛮巧妙的，计算方法是容斥原理，找intersect蛮难的。因此我们要找到上/下/左/右除去边框的次级值。</p>
<h1 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228. Summary Ranges"></a>228. Summary Ranges</h1><p>题目给定一组已经排序好的整数，要求将连续的部分克兵成一个区间表示<br>这个我是维护每一个<code>[fr, to]</code>的区间，然后对每一个<code>x</code>二分出<code>index</code>表示<code>x</code>应该在<code>index</code>前面，接着查看能否将<code>x</code>贴到<code>index - 1</code>或者<code>index</code>上。最后查看能否合并<code>index - 1</code>和<code>index</code>。这里二分偷懒用了<code>bisect_left</code>，这里可以看出来。<br>不过其实这道题很简单，因为是排好序的，所以直接xjb跑一下就完了。</p>
<h1 id="229-Majority-Element-II"><a href="#229-Majority-Element-II" class="headerlink" title="229. Majority Element II"></a>229. Majority Element II</h1><p>这次是<code>[x / 3]</code>的。我们这次依然使用打擂法，也就是Boyer-Moore投票算法。不过这次我们需要维护一个大小为3的集合（即最多容纳三种不同值的数字），例如<code>1 1 1 2 2 2 3</code>表示成<code>[(1, 3), (2, 3), (3, 1)]</code>，当随后出现一个4时，集合的容量不够了，那么这一个4就会和集合中的所有元素进行一次湮灭，例如现在的即可变成了<code>[(1, 2), (2, 2)]</code>，其中3的数量不够了，就从集合中被去除。</p>
<h1 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230. Kth Smallest Element in a BST"></a>230. Kth Smallest Element in a BST</h1><p>随便写了一下，常数应该比较大，居然还击败了66%。用一个函数<code>index</code>求一个节点下的count。接着用函数<code>dfs</code>递归，首先看左儿子的节点数是否满足<code>k &lt;= cntl</code>，注意<code>k == cntl</code>时答案不是左儿子，而是左子树中的最大值。<br>看到一个很简洁的答案，其思路就是不停地递归左儿子，并在<code>k</code>上减掉已经遍历过的数量<code>n</code>，并返回<code>n</code>处的值<code>x</code>。容易看到当<code>k == 0</code>时，要求的值在左子树上，<code>k == 1</code>时要求的值是根，否则递归右子树。<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> kthSmallest(TreeNode* root, <span class="keyword">int</span>&amp; k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = kthSmallest(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">return</span> !k ? x : !--k ? root-&gt;val : kthSmallest(root-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> kthSmallest(TreeNode* root, <span class="keyword">int</span>&amp; k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = kthSmallest(root-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">            k --;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            k --;</span><br><span class="line">            <span class="keyword">return</span> kthSmallest(root.right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="233-Number-of-Digit-One"><a href="#233-Number-of-Digit-One" class="headerlink" title="233. Number of Digit One"></a>233. Number of Digit One</h1><p>可以用数位DP硬刚，设置状态<code>status</code>为高位上1的数量（之前以为不需要设的）。<br>当然这道题也有神奇的解法，具体还没研究<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>)</span><br><span class="line">        ones += (n/m + <span class="number">8</span>) / <span class="number">10</span> * m + (n/m % <span class="number">10</span> == <span class="number">1</span>) * (n%m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ones;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><p>经典的求LCA的题目。一个straightforward的做法是计算得到两个链然后求交。<br>一个通常意义的解法是离线的tarjan。Python的Hash啊，简直蛋疼，又不能自定义数据结构，解决不了并查集的问题。<br>用C++写了发终于过了，这里提醒一下，Leetcode的全局变量一定每次计算时要清空。</p>
<h1 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238. Product of Array Except Self"></a>238. Product of Array Except Self</h1><p>这道题蛮有意思的，维护一个<code>left</code>和<code>right</code>累计积，然后对于<code>i</code>，就是它的左边乘以它的右边。</p>
<h1 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h1><p>如果说需要查任意区间的最大值那么线段树是比较好的办法，不过这道题要求是用$O(n)$时间解决。<br>这道题做完之后我看题解上是用了啥deque，但我自己做的时候直接维护了窗口两端的指针，然后分类讨论。居然击败了96%</p>
<h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h1><p>二分，<code>upper_bound</code>行，然后<code>lower_bound</code>列。</p>
<h1 id="241-Different-Ways-to-Add-Parentheses"><a href="#241-Different-Ways-to-Add-Parentheses" class="headerlink" title="241. Different Ways to Add Parentheses"></a>241. Different Ways to Add Parentheses</h1><p>问怎么可以通过加括号，让一个包含<code>+-*</code>表达式，要求输出加括号能得到的所有值。<br>对于每一个op，我们可以在两边加括号，从而进行分治。<br>于是这种题的思路是确定的，就是我们遍历每一个op，并且用一个字典记忆左右两边能得到的所有值。<br>然后WA了，原来不能用set输出。。。</p>
<h1 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258. Add Digits"></a>258. Add Digits</h1><p>求数<code>x0</code>的数位和得到<code>x1</code>，重复上一过程直到得到个位数。要求$O(1)$复杂度。打表发现规律<code>1 + (num - 1) % 9</code>，然后发现其实可以用数学归纳法证明这个规律的。</p>
<h1 id="260-Single-Number-III"><a href="#260-Single-Number-III" class="headerlink" title="260. Single Number III"></a>260. Single Number III</h1><p>老题新做</p>
<h1 id="263-Ugly-Number"><a href="#263-Ugly-Number" class="headerlink" title="263. Ugly Number"></a>263. Ugly Number</h1><p>没啥好说的</p>
<h1 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a>264. Ugly Number II</h1><p>定义Ugly Number是所有包含2/3/5为因子的正整数，求第n个。<br>想一开始用筛法预处理打个表，然而TLE了。也没发现能够从各因数的幂上发现子结构。解决方案还是从$O(n^2)$的筛法上下手，原筛法是对第$i$个丑数，看看能从先前的丑数中进行更新得到的最小值。容易发现这个过程存在很多冗余计算。例如在计算$ugly[i]$时，我们需要知道满足$x * 2 &gt; ugly[i - 1]$的最小的$x$，显然我们不需要在所有$ugly[1..(i-1)]$遍历$x$。不过我们发现每次使用$* 2$规则生成新丑数时，我们的$x$是<strong>严格递增</strong>的。递增很简单，因为新丑数比就丑数大，所以$x$要大。严格是因为所有的丑数都是偏序的。</p>
<h1 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274. H-Index"></a>274. H-Index</h1><p>桶排序，注意要是<code>min(tot, i)</code></p>
<h1 id="275-H-Index-II"><a href="#275-H-Index-II" class="headerlink" title="275. H-Index II"></a>275. H-Index II</h1><p>这道题就是二分答案$[0, citations[-1]]$啊。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public <span class="keyword">int</span> hIndex(<span class="keyword">int</span>[] citations) &#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">len</span> = citations.length;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">len</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (citations[i] &gt;= <span class="built_in">len</span> - i) <span class="keyword">return</span> <span class="built_in">len</span> - i;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (citations[i] &gt; h &amp;&amp; citations[i] &lt; <span class="built_in">len</span> - <span class="number">1</span>) h++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实之前是考虑不二分答案而是<strong>二分index</strong>，我们试图找到最靠左的位置<code>l</code>使得<code>[l, n)</code>里面的数都大于<code>citation[l]</code>，这是一个TTT..T/F型的，不过我们应该返回什么呢。返回<code>citation[l]</code>吗？答案不一定出现在<code>citation</code>数组里面，例如<code>[0,0,4,4]</code>，在位置<code>1</code>的右边有2个数大于2，这个答案是2。返回<code>n - l</code>吗？还考虑<code>[0,0,4,4]</code>，二分下来<code>l</code>是1，<code>n - l</code>等于3了。这里是因为虽然1位置的0满足了二分的条件，也就是说这是二分的边界情况，但这个边界情况<strong>不一定成立</strong>，我们得验证<code>citation[l]</code>要足够大，不然我们就要从<code>l + 1</code>位置开始算。<br>这个答案击败了100%，此外还有一个二分也值得一看，看起来我完全可以把二分的条件写得更严格一点，我当时是怕写出来不满足二分的性质了。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span>, <span class="keyword">end</span> = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">start</span> &lt;= <span class="keyword">end</span>:</span><br><span class="line">    <span class="keyword">mid</span> = <span class="keyword">start</span> + (<span class="keyword">end</span>-<span class="keyword">start</span>)/<span class="number">2</span></span><br><span class="line">    <span class="keyword">acc</span> = n - <span class="keyword">mid</span></span><br><span class="line">    cite = citations[<span class="keyword">mid</span>]</span><br><span class="line">    <span class="keyword">if</span> cite == <span class="keyword">acc</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">acc</span></span><br><span class="line">    elif cite &gt; <span class="keyword">acc</span>:</span><br><span class="line">        <span class="keyword">end</span> = <span class="keyword">mid</span><span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">start</span> = <span class="keyword">mid</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">return</span> n-<span class="keyword">start</span></span><br></pre></td></tr></table></figure></p>
<h1 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h1><p>点开Playground看一下它附加的后台代码，发现我们打表不能打在<code>Solution</code>对象的<code>__init__</code>上，而应该打在全局。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">line</span> = lines.next()</span><br><span class="line"><span class="attr">n</span> = stringToInt(line)</span><br><span class="line"><span class="attr">ret</span> = Solution().numSquares(n)</span><br><span class="line"><span class="attr">out</span> = intToString(ret)</span><br></pre></td></tr></table></figure></p>
<p>注意，本题还可以使用四平方和定理进行优化。</p>
<h1 id="282-Expression-Add-Operators"><a href="#282-Expression-Add-Operators" class="headerlink" title="282. Expression Add Operators"></a>282. Expression Add Operators</h1><p>一开始打算二分，砸了。<br>后来打算dfs，这道题的话我们可以将算式看为若干个乘积式的加和</p>
<h1 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283. Move Zeroes"></a>283. Move Zeroes</h1><p>这道题直接统计0的数目然后覆盖移动就行了，前面有类似的题目</p>
<h1 id="284-Peeking-Iterator"><a href="#284-Peeking-Iterator" class="headerlink" title="284. Peeking Iterator"></a>284. Peeking Iterator</h1><p>简单题</p>
<h1 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287. Find the Duplicate Number"></a>287. Find the Duplicate Number</h1><p>这道题目很有意思，有<code>n + 1</code>个数，他们的值域为<code>[1, n]</code>，里面只有一个数会出现<code>&gt; 1</code>次（不一定只出现两次），要求找出来。这道题要求在$O(n log n)$时间，$O(1)$空间解决。那就是二分答案啊，然后我一开始想歪了，想通过和来比较，但其实是通过小于/大于<code>mid</code>的数的数量进行二分的。</p>
<h1 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h1><h1 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299. Bulls and Cows"></a>299. Bulls and Cows</h1><p>很有趣的xAyB的猜数字游戏，一道小模拟。注意有易错点<code>11</code>和<code>10</code>是<code>1A0B</code>而不是<code>1A1B</code>，因此要用dict来统计一下overlap的个数</p>
<h1 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h1><p>最长上升子序列模板题</p>
<h1 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301. Remove Invalid Parentheses"></a>301. Remove Invalid Parentheses</h1><p>这道题要输出所有结果，那考虑考虑暴力咯。仔细查看样例，我们发现不能简单地消除能够匹配的括号。<br>看了题解，这道题和之前的某道题一样，就是挨个从原字符串中去掉1、2、3个字符，直到形成一个合法串，然后把相同长度的都列出来。注意为了加速使用一个set来做记忆搜索。</p>
<h1 id="304-Range-Sum-Query-2D-Immutable"><a href="#304-Range-Sum-Query-2D-Immutable" class="headerlink" title="304. Range Sum Query 2D - Immutable"></a>304. Range Sum Query 2D - Immutable</h1><p>求一个<strong>不变</strong>的矩阵的某个子矩阵的和。由于不变，所以我们不需要用到线段树。<br>这一条要做到常数的查询复杂度，其实很简单。我们维护<code>dp[i][j]</code>表示<code>(0,0)-(i-1,j-1)</code>张成的矩阵的大小即可。<br>特别地，如果求最大权子矩阵的解法是$O(n^3)$的，详见红宝书。</p>
<h1 id="307-Range-Sum-Query-Mutable"><a href="#307-Range-Sum-Query-Mutable" class="headerlink" title="307. Range Sum Query - Mutable"></a>307. Range Sum Query - Mutable</h1><p>线段树模板题</p>
<h1 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h1><p>首先要思考的是如何维护DP的状态，我觉得可以直接用一个二维数组来表示，因为每一天有三种行为，买、卖和不买不卖，分别导致三种状态，因此我们可以设置数组<code>dp[n][3]</code>，紧接着在推导公式时我们发现一个问题，我们计算不买不卖这个状态很有难度。看答案才知道其实是想复杂了。首先它只设两个变量<code>buy[i]</code>表示第<code>i</code>天<strong>买彩票</strong>能获得的最大利润，<code>sell[i]</code>表示在第<code>i</code>天<strong>卖彩票</strong>获得的最大利润。下面我们考虑计算<code>sell[i]</code>，最容易想到的是如果第<code>i - 1</code>天买了，那么利润就是<code>buy[i-1]+prices[i]</code>，但是如果我第<code>i - 1</code>天不买不卖呢？那我们就直接使用第<code>i - 1</code>天的结果<code>sell[i - 1]</code>。计算</p>
<h1 id="310-Minimum-Height-Trees"><a href="#310-Minimum-Height-Trees" class="headerlink" title="310. Minimum Height Trees"></a>310. Minimum Height Trees</h1><p>Floyd一波T了。。。因为是无权的嘛，所以BFS咯、、、$O(n^2)$的BFS也T了，看来是$O(n)$的了，这让我想到834这道题。<br>细究下来这道题还蛮有意思的，首先需要明白MHT的数量只可能为1或者2。知道这一点，我们就不停地把叶子剥掉，这个过程有点类似于拓扑排序。</p>
<h1 id="312-Burst-Balloons"><a href="#312-Burst-Balloons" class="headerlink" title="312. Burst Balloons"></a>312. Burst Balloons</h1><p>一条蛮久之前就准备做的题目了。这道题的话首先是DP如何维护状态，一般来说有用bitset维护的，或者我们去跟踪某个点<code>i</code>的状态，一个<code>i</code>就是一维，抑或我们去跟踪ANY/NONE/ALL这样的状态，抑或我们进行二分然后合并左右两个区间的结果，这样我们只需要考虑相邻节点的状态。<br>于是我首先推出方程，使用<code>dp[L][R]</code>维护打爆<code>[L, R]</code>处所有气球的最大值<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for burst in <span class="string">[L, R]</span>:</span><br><span class="line">    dp<span class="string">[L]</span><span class="string">[R]</span> = dp<span class="string">[L]</span><span class="string">[burst-1]</span> + dp<span class="string">[burst+1]</span><span class="string">[R]</span> + nums<span class="string">[burst-1]</span>*nums<span class="string">[burst]</span>*nums<span class="string">[burst+1]</span></span><br></pre></td></tr></table></figure></p>
<p>但我突然意识到我们是仅仅消掉<code>burst</code>，所以两边的<code>burst-1</code>和<code>burst+1</code>不能分治，那怎么办呢，且慢，好像有哪里不对劲。<br>反省一下上面的<code>dp</code>，我们犯的最大的错误是认为消掉<code>burst</code>和<code>burst-1</code>和<code>burst+1</code>有关，实际上这是不可能有关的，因为在这种假设下此时这两个气球应该是已经爆掉的，于是我们恍然大悟，应该和<code>L</code>和<code>R</code>有关啊。于是此时burst就是我们最后打爆的气球。<br>然后这一条如果DP的话因为是从<code>[l, burst-1]</code>和<code>[burst+1, r]</code>更新的，所以不能for l for r这样，比较好的是for l for len或者直接记搜。</p>
<h1 id="313-Super-Ugly-Number"><a href="#313-Super-Ugly-Number" class="headerlink" title="313. Super Ugly Number"></a>313. Super Ugly Number</h1><p>要求找到第<code>n</code>个Super Ugly Number。这个数的定义它的所有的因数来自给定一组素数<code>prime</code>，其中1是第一个。其中<code>n</code>是<code>10**6</code>的规模。这条和第264条有点像。<br>看上去我们可以维护一个最小堆，对于每一个新来的数，就依次乘上prime的每一个数，再放到这个堆里面。<br>这一条是用go写的，需要用到<code>container/heap</code>去维护一个优先队列，它实际上是一个最小堆。</p>
<h1 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a>315. Count of Smaller Numbers After Self</h1><p>我是从逆序对的经典问题出发找到这条题目的，这一条朴素解法是$O(n^2)$的，但似乎不太好套逆序对的模板，因为需要求每个位置的结果，而中途的sort会改变位置。一个straightforward的做法是线段树/树状数组神器（其实逆序对也可以用树状数组做），不过常数是比较大的。<br>但是还有一种思路，我们可以理解成从最后一个元素开始构造一个新的数列，对于每一个元素<code>bisect_left</code>查找它的插入位置，这就是解，搞了一发T了。<br>通过查看Related topics我发现了二叉搜索树(BST)其实就是用来做这个的，它能够进行动态插入。这里注意一下，不要用数组来实现二叉树，容易爆内存，而且要在每个节点上维护count，否则会爆内存</p>
<h1 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316. Remove Duplicate Letters"></a>316. Remove Duplicate Letters</h1><p>一开始想的是怼每一个字符维护一个<code>harm</code>和<code>benefit</code>表示为了减少害处或者增加益处需要<strong>保留</strong>下来的index。不过这个在样例阶段出现了错误，因为我们还需要考虑各个保留下来的字符之间的相对位置。其实这道题实际上是个贪心，我们试图将<code>s</code>逐一append到<code>ans</code>上，然后如果当前的<code>x</code>比<code>ans[-1]</code>要小，那我们肯定是倾向于用<code>x</code>替换<code>ans[-1]</code>的，只需要<code>ans[-1]</code>在后面还有备胎。</p>
<h1 id="319-Bulb-Switcher"><a href="#319-Bulb-Switcher" class="headerlink" title="319. Bulb Switcher"></a>319. Bulb Switcher</h1><p>【这道题直接打表解决了】<br>解释一下题意，灯有1表示开、0表示关两个状态。一开始都是1，之后选择%2=1的所有灯切换状态，之后是所有%3=2的灯，一直到%n=n-1的灯。问到最后有多少盏灯是亮的。<br>写了一个<code>O(n^2)</code>的T了，那应该是推一个很容斥原理一样的公式了吧？然后我打了个表。。。发现答案是3个1、5个2、7个3、、、原来是个等差数列，求和公式也忘了，直接打表和表然后二分AC</p>
<h1 id="321-Create-Maximum-Number"><a href="#321-Create-Maximum-Number" class="headerlink" title="321. Create Maximum Number"></a>321. Create Maximum Number</h1><p>【这一条目前还是T的状态，加个剪枝就过了。。。C++还写WA了一发】<br>题目要求是在<code>nums1</code>和<code>nums2</code>中总共取<code>k</code>个数，然后进行归并，要求组成的数最大。这道题目一开始的思路就是枚举<code>k</code>，然后分别对<code>nums1</code>和<code>nums2</code>生成最大的数，最后进行归并。</p>
<ol>
<li>从<code>nums</code>数组中取出按顺序的<code>req</code>个数使得组成的数最大。<br> 一个错误的思路是首先取<code>ans = nums[0..req-1]</code>，然后对于从<code>req</code>开始的每个数，我们找到它能替换<code>ans</code>的最小index位置和最大长度，例如<code>[8,5,3,6,7]</code>中<code>[6,7]</code>能够替换<code>[5,3]</code>。不过这个思路是错的，例如<code>[9,7,9,1]</code>，显然<code>[9,1]</code>不能替换<code>[9,7]</code>，但是第2个9可以替换第一个7。此外也不能从<code>req</code>位置开始，而应该从1位置开始。<br> 实际上我们可以维护一个大小为<code>req</code>的栈，来表示这个最大可能的数。我们遍历数组<code>A</code>，对于每一个<code>nums[i]</code>，我们试图用它来替换最靠栈底的数，除非剩下来的数不够填满栈了。</li>
<li>归并<br>我们要注意当<code>nums[i]</code>和<code>nums[j]</code>相等时需要继续向后比较，如果当其中一个数列耗尽还没比较出来大小，那就选择另外的数列为大，因为另一个数列可能下面的元素就大了。例如<code>[0]</code>和<code>[0, 6]</code>。</li>
</ol>
<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><p>这是一道完全背包的问题。完全背包朴素的状态转移是<code>f[i][j]=max(f[i−1][j−k∗w[i]]+k∗v[i])∣0&lt;=k∗w[i]&lt;=j</code>，但实际上可以做到<code>O(VN)</code>。<br><code>dp[i][j]</code>表示只使用前<code>i</code>个物品，总价值在<code>j</code>时的最小数目。完全背包不一样的地方是对j的循环策略<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(amount + <span class="number">1</span>):</span><br><span class="line">        dp[i][j] = min(dp[i][j - coins[<span class="selector-tag">i</span> - <span class="number">1</span>]] + <span class="number">1</span>, dp[<span class="selector-tag">i</span> - <span class="number">1</span>][j])</span><br></pre></td></tr></table></figure></p>
<p>而01背包是<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> xrange(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(amount + <span class="number">1</span>):</span><br><span class="line">            dp[i][j] = min(dp[<span class="selector-tag">i</span> - <span class="number">1</span>][j - coins[<span class="selector-tag">i</span> - <span class="number">1</span>]] + <span class="number">1</span>, dp[<span class="selector-tag">i</span> - <span class="number">1</span>][j])</span><br></pre></td></tr></table></figure></p>
<p>对于01背包而言，要保证<code>f[i]</code>全部是从<code>f[i - 1]</code>更新的，而完全背包需要复用一部分<code>dp[i]</code>的结果</p>
<h1 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324. Wiggle Sort II"></a>324. Wiggle Sort II</h1><p>【这一条蛮难的】<br><!-- https://paste.ubuntu.com/26506141/ https://paste.ubuntu.com/26511493/ 是有问题的 --><br>这道题比前面的Wiggle Sort去掉了可以相等的条件。平凡解法依旧是$O(n log \, n)$的，使用排序之后一头一尾接着取，也能AC。题目要求的$O(n)$时间复杂度和$O(1)$空间复杂度就有难度了，首先DP肯定不行了。一个初步的策略是首先算出中位数，这个有一个$O(n)$的第k大数的算法<code>std::nth_element</code>，然后将大于中位数的放在奇数位，小于等于的放在偶数位。注意当数列为奇数个时，中位数放在偶数位作为一头一尾。因此我们必须新开一个数组，造成$O(n)$的空间开销。<br>题解用了一个很巧妙的思路，首先将原数列映射成<code>[1, 3, 5, ... , 0, 2, 4, ...]</code>的形式，然后考虑这个“新数列”。它的前半部分都大于中位数，后半部分都小于中位数。这又回到了之前的快速选择的问题上。不过<a href="https://paste.ubuntu.com/26511612/" target="_blank" rel="noopener">这个做法</a>还是有问题，例如<code>[1, 3, 2, 2, 3, 1]</code>的结果是<code>[1, 3, 2, 2, 3, 1]</code>。正确答案需要三向快排来处理相同值的情况。与二向划分不同的是，三向划分虽然拥有<code>l</code>、<code>r</code>、<code>eq</code>三个指针表示小于等于大于三个边界。但它只使用一个循环，即用<code>eq</code>指针从前到后遍历数组，而不是使用两个指针相向移动。当遇到大于pivot的数的时候，就把它扔到<code>r</code>指针位置，并更新<code>r</code>。当遇到小于pivot数的时候就把它和<code>l</code>指针互换，保证<code>l</code>左边都是小于pivot的数</p>
<h1 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h1><p>一道很有趣的题，要求不使用循环和递归来判断一个数是否是3的整数幂。我能想到是log，还有一个蹩脚的二分搜索。一个应该是最优解使用int范围内最大的3的幂<code>1162261467</code>来模这个数看是否能整除。这里解法就和Power of Four啥的不一样的<br>这里用log+python的<code>is_integer</code>写了一发，发现<code>math.log(243, 3).is_integer()</code>返回<code>False</code>，所以还是要自己用eps判定下。</p>
<h1 id="327-Count-of-Range-Sum"><a href="#327-Count-of-Range-Sum" class="headerlink" title="327. Count of Range Sum"></a>327. Count of Range Sum</h1><p>同样类似560，注意LL</p>
<h1 id="328-Odd-Even-Linked-List"><a href="#328-Odd-Even-Linked-List" class="headerlink" title="328. Odd Even Linked List"></a>328. Odd Even Linked List</h1><p>这道题很简单，实际上是一个无状态迭代的过程，可以想象为不断地<code>take 2 lst</code>。注意判断<code>None</code>。我们实现一个函数<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(odd, even)</span></span></span><br><span class="line">    <span class="keyword">return</span> nxt_odd, nxt_even</span><br></pre></td></tr></table></figure></p>
<h1 id="329-Longest-Increasing-Path-in-a-Matrix"><a href="#329-Longest-Increasing-Path-in-a-Matrix" class="headerlink" title="329. Longest Increasing Path in a Matrix"></a>329. Longest Increasing Path in a Matrix</h1><p>这道题挺有意思，Topic有拓扑排序、DFS和记忆化搜索在里面。这道题同信封那条一样是天生偏序的，所以我们不需要<code>vis</code>数组，所以可以通过非常基础的DFS解决。题解中还提到了可以借助于拓扑排序来做，原理也很简单，因为矩阵中相邻节点的偏序关系可以类比成有向边，因此拓扑序一定存在。</p>
<h1 id="330-Patching-Array"><a href="#330-Patching-Array" class="headerlink" title="330. Patching Array"></a>330. Patching Array</h1><p>【这道题很有趣】<br>首先我们计算<code>nums</code>中的数能够组成多少个和，我们对于每一个<code>nums[i]</code>，尝试加到集合中。<br>这道题没有思路，后来接受了一个Hint，也就是考虑<code>miss</code>为<code>[0, n]</code>中间第一个不能表示的数。然后是一个key observation，当我们能表示<code>[0, miss)</code>时，如果引入一个新的<code>x</code>，那么我们能够表示<code>[0, x + miss)</code>的数了。那么我们希望这个<code>x</code>等于<code>miss</code>，这样能够最大化利用率。</p>
<h1 id="332-Reconstruct-Itinerary"><a href="#332-Reconstruct-Itinerary" class="headerlink" title="332. Reconstruct Itinerary"></a>332. Reconstruct Itinerary</h1><p>这道题之前好像在哪个微博上看到的，我还评论了一种可能的拓扑排序的做法。不过这道题目并不能这么做，因为我们可能重复到达某个机场（例如case2），因此并不存在一个特定的拓扑排序。<br>那这道题就是一个简单的DFS么？也不是，虽然我们要求出发机场相同时按字符串大小选择目的机场，但这一切要建立在整个行程单存在的情况下！例如<code>[[&quot;JFK&quot;,&quot;KUL&quot;],[&quot;JFK&quot;,&quot;NRT&quot;],[&quot;NRT&quot;,&quot;JFK&quot;]]</code>就应该选择先去<code>NRT</code>而不是<code>KUL</code>。</p>
<h1 id="335-Self-Crossing"><a href="#335-Self-Crossing" class="headerlink" title="335. Self Crossing"></a>335. Self Crossing</h1><p>给定一个长度为<code>n</code>的数组，表示分别向北、西、南、东走了多少铬，要求用一趟遍历和<code>O(1)</code>的空间去判断线路是否发生自交。<br>这一道题我完全不会，为啥复杂度能做到这么低呢？其实这是有限制条件的，因为我们每一步一定是有方向转换的，我们没必要考虑全局。而这个实际上只有三种情况。分别对应于和-3、-4、-5相交。<br>能不能和-1、-2相交呢？不可以，因为两个不在一个方向上。如果和-6相交（实际上是重合的情况），那么必然要和-5相交，同理，对-7也是这样。因此我们只要追溯到-5即可。具体地，我们是要追溯0和-3， 0和-4，0和-5的相交情况。<br>用了<a href="https://zhuanlan.zhihu.com/p/37360022" target="_blank" rel="noopener">这个模板算cross</a>，其原理也就是跨立实验。即以一条线段为标准，另一条线段的两端点一定在这条线段的两边。但互相跨立并不能解决共线问题，所以还需要继续快速排斥实验。</p>
<h1 id="336-Palindrome-Pairs"><a href="#336-Palindrome-Pairs" class="headerlink" title="336. Palindrome Pairs"></a>336. Palindrome Pairs</h1><p>拿到题，想的是反向建Trie，然后对每一个终止状态判剩下的是不是回文串。然后我们对每个串遍历树，讨论到底是树短还是串短。对于树短，我们判断串多余的部分是否是回文；对于串短，我们dfs那个trie树，找到所有的合法路径。</p>
<h1 id="337-House-Robber-III"><a href="#337-House-Robber-III" class="headerlink" title="337. House Robber III/"></a>337. House Robber III/</h1><p>这贼真是辛苦啊，这次是带权二叉树，同样不能相邻。感觉是树形DP模板题吧，一搜POJ2342。我们使用<code>dp[i][0/1]</code>表示是否抢劫第<code>i</code>个节点的情况，那么可以得到</p>
<pre><code>dp[i][0] = max(dp[lson(i)][0], dp[lson(i)][1]) + max(dp[rson(i)][0], dp[rson(i)][1])
dp[i][1] = value[i] + dp[lson(i)][0] + dp[rson(i)][0]
</code></pre><p>容易看到这个DP可以用一次DFS求得</p>
<h1 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h1><p>这条虽然可以按191的思路做，不过更好的方法是DP，以<code>0011b</code>为例，它中1的数目<code>ans[0011b] = ans[0011b &gt;&gt; 1] + (0011b &amp; 1)</code></p>
<h1 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341. Flatten Nested List Iterator"></a>341. Flatten Nested List Iterator</h1><p>用个栈维护一下</p>
<h1 id="342-Power-of-Four"><a href="#342-Power-of-Four" class="headerlink" title="342. Power of Four"></a>342. Power of Four</h1><p>注意这一题是求是否是4的幂，而不是是否是4的倍数。这个很简单了，4的幂都是<code>1(00)*</code>这样的形式的</p>
<h1 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a>343. Integer Break</h1><p>经典的整数划分问题。这道题我记得看过推导是分成$N/e$个数为妙，不过我最后还是做了下记忆化搜索解决的。注意因为题目要求至少分两块，所以我们要存两个dp，一个是必须要分的，一个是可以不分的。<br>这里额外说一下几个常见的整数划分问题：</p>
<ol>
<li><p>将n划分为若干整数之和<br> 这里设置一个k是为了去重</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里k表示不超过k的整数</span><br><span class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k</span>] + dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将n划分为若干不同整数之和</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这里k表示不超过k的整数</span><br><span class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k - 1</span>] + dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将n划分为k个整数之和</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 其中第一项为划分中不包含1的情况，第二项为划分中包含1的情况，注意不是dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</span><br><span class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k</span>] + dp[<span class="string">n - 1</span>][<span class="symbol">k - 1</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将n分为k个整数的积，要求积最大，这也是最大分解问题</p>
 <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dp</span>[n] = <span class="built_in">max</span>(<span class="keyword">dp</span>[:<span class="keyword">k</span>-<span class="number">1</span>] * <span class="keyword">dp</span>[<span class="keyword">k</span>:])</span><br></pre></td></tr></table></figure>
<p> 但是这一条有<a href="https://blog.csdn.net/nameofcsdn/article/details/53334497" target="_blank" rel="noopener">数学方法</a>，主要可以考虑下面的性质：</p>
<ol>
<li><code>n</code>的最大分解中不可能出现大于4的数<br> 反证法，如果出现了<code>m</code>大于4，那么可以用<code>(m-2)</code>和<code>2</code>替换<code>m</code>，得到的积是<code>2m-4&gt;m</code>，矛盾</li>
<li>存在不含4的<code>n</code>的最大分解<br> 这是因为我们可以把任意的4变成<code>2*2</code>，而不影响结果</li>
<li>最大分解中，一定不会出现1</li>
<li>综合上面三点，最大分解中一定只含有2和3，并且2的数量只能为0/1/2<br> 这是因为<code>3*3*3</code>大于<code>2*2</code></li>
</ol>
</li>
</ol>
<h1 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347. Top K Frequent Elements"></a>347. Top K Frequent Elements</h1><p>找到k个最频繁的数。我直接map+sort搞了。</p>
<h1 id="352-Data-Stream-as-Disjoint-Intervals"><a href="#352-Data-Stream-as-Disjoint-Intervals" class="headerlink" title="352. Data Stream as Disjoint Intervals"></a>352. Data Stream as Disjoint Intervals</h1><p>从一个流持续读取非负整数，要求随时输出当前所有整数构成的区间。这个有点类似于第228的Summary Ranges，但要求支持在线查询。<br>此外，还有一个Follow Up，问如果合并次数非常多，不相交区间的数目很少，应当如何优化？<br>应该是用一种树的数据结构来进行维护。我直接看题解了，原来使用红黑树进行维护。接着我们用类似于228的思想，查看是否需要合并左右区间。<br>此外，似乎也可以用并查集来做，我们使用并查集来维护每一个节点属于哪一个集合。剩下来的就是我们需要知道这个节点是否存在，这个可以借助于一个map来实现。<br>本题我是参照着题解用go实现的，主要涉及以下知识：</p>
<ol>
<li>自定义struct</li>
<li>基于Node而不是数组实现的并查集，因为这条题目没有办法知道总的数据规模</li>
<li>在并查集Merge的时候同时更新状态</li>
<li>使用map，和用struct做结构的map</li>
<li>go里面的“指针”</li>
</ol>
<h1 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a>354. Russian Doll Envelopes</h1><p>这题很好用记忆化搜索做，因为信封之间是偏序的，即如果信封A能dfs到信封B，则信封B肯定不能dfs到信封A，因此dfs的时候不需要维护状态。不过撸了个Python版本的，超时了。后来发现要$O(nlogn)$才能保证过，不过C++又没卡住$O(n^2)$的复杂度。<br>后来发现这道题可以转化为LIS来做，把w看成横坐标，h看成纵坐标，我们实际上是要找h的最长的上升子序列。注意为了处理横坐标相等的情况，需要在此时将纵坐标从大到小排列，以便<code>bisect_left</code>能够定位到准确位置。</p>
<h1 id="357-Count-Numbers-with-Unique-Digits"><a href="#357-Count-Numbers-with-Unique-Digits" class="headerlink" title="357. Count Numbers with Unique Digits"></a>357. Count Numbers with Unique Digits</h1><p>又到了我喜欢的数位DP时间。<br>又被算公式的大佬虐了，由于这条的区间很整，所以算公式反而简单。</p>
<h1 id="363-Max-Sum-of-Rectangle-No-Larger-Than-K"><a href="#363-Max-Sum-of-Rectangle-No-Larger-Than-K" class="headerlink" title="363. Max Sum of Rectangle No Larger Than K"></a>363. Max Sum of Rectangle No Larger Than K</h1><p>这道题到现在还是T的状态。<br>这道题和前面的Maximal Rectangle有点像，这次我们来看一个不一样的DP方法，也就是将其转化为一维DP问题来做。这条的复杂度应该是$O(X^2 \times Y \, logY)$，其中$X, Y$分别为矩阵的长和宽之间的较小/大值。前面的<code>O(X^2)</code>很简单，可以仿照红书上的最大权自矩形来做。假设这个矩阵列数很多，我们维护一个列的累加和<code>sum</code></p>
<pre><code>1 1 1          1 1 1 
1 1 1    =&gt;    2 2 2
1 1 1          3 3 3
</code></pre><p>然后我们枚举所有的<code>(up, down)</code>，例如当枚举到<code>(1, 2)</code>时，我们计算一个<code>sub</code>表示所有上底为第1行下底为第2行的“棍状数列”的和。接下来我们采取同样的办法计算<code>sub</code>的累加和<code>arr</code></p>
<pre><code>sub = (3-2) (3-2) (3-2)
    =   1     1     1
arr =   1     2     3
</code></pre><p>于是我们的任务就变成了在<code>arr</code>中找到$l &lt; r$，使得$arr[r] - arr[l]$是满足小于$k$最大的数。因此我们可以从<code>i</code>开始遍历<code>arr</code>，然后在一个数据结构内花$O(log n)$查询最接近$arr[i] - k$的值，然后再花$O(log n)$将$arr[i]$放到这个数据结构里面。显然我们可以用一个二叉树来维护，但是我T了，不知道为啥<br>这里说明一下题解上有人用<code>bisect.insort()</code>，注意这个复杂度是$O(n)$的，我之前写的代码效率不高，所以被卡常了。倒是C++里面的<code>set</code>和<code>map</code>啥的有<code>lower_bound</code>。使用二叉树之后反而更垃圾了。</p>
<h1 id="368-Largest-Divisible-Subset"><a href="#368-Largest-Divisible-Subset" class="headerlink" title="368. Largest Divisible Subset"></a>368. Largest Divisible Subset</h1><p>第一眼看到，觉得是一个LIS的题目。结果也确实就是这么简单，$O(n^2)$直接过了</p>
<h1 id="371-Sum-of-Two-Integers"><a href="#371-Sum-of-Two-Integers" class="headerlink" title="371. Sum of Two Integers"></a>371. Sum of Two Integers</h1><p>用位实现加法，我可是刷过CSAPP的人啊。</p>
<h1 id="372-Super-Pow"><a href="#372-Super-Pow" class="headerlink" title="372. Super Pow"></a>372. Super Pow</h1><p>请移步<a href="/2017/11/05/Kickstart2017G/">Kickstart2017G</a>题目A</p>
<h1 id="373-Find-K-Pairs-with-Smallest-Sums"><a href="#373-Find-K-Pairs-with-Smallest-Sums" class="headerlink" title="373. Find K Pairs with Smallest Sums"></a>373. Find K Pairs with Smallest Sums</h1><p>这道题就是在<code>[i+1,j]</code>和<code>[i,j+1]</code>里面选一个</p>
<h1 id="375-Guess-Number-Higher-or-Lower-II"><a href="#375-Guess-Number-Higher-or-Lower-II" class="headerlink" title="375. Guess Number Higher or Lower II"></a>375. Guess Number Higher or Lower II</h1><p>简单写了个dfs结果T了，加了个二维的记忆化搜索就AC了。。。注意数组要开到1000。</p>
<h1 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376. Wiggle Subsequence"></a>376. Wiggle Subsequence</h1><p>一开始的想法是仿照直方图那一条，对于每一个位置<code>i</code>，找到它前面的<code>up</code>和<code>down</code>位置，然后统计<code>lenup</code>和<code>lendown</code>，但这个思路是错的，因为我们不一定会从前一个位置开始。<br>现在我们考虑能不能将这道题转化为最长上升子序列LIS来做。用<code>up[i]</code>表示长度为<code>i</code>的最后为上升序列的末尾元素的值，而<code>down[i]</code>为最后为下降序列的末尾元素的值。不过后来发现这个不能做到是有序的，所以没办法二分。因此实际上我们只要从尾部开始遍历即可。<br>然后发现题目要求是$O(n)$的，看了题解，这道题有一种很妙的贪心方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wiggleMaxLength</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :type nums: List[int]</span></span><br><span class="line"><span class="string">    :rtype: int</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    p = <span class="number">1</span></span><br><span class="line">    q = <span class="number">1</span></span><br><span class="line">    n = len(nums)</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &gt; nums[i - <span class="number">1</span>]:</span><br><span class="line">            p = q + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[i] &lt; nums[i - <span class="number">1</span>]:</span><br><span class="line">            q = p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> min(n, max(p, q))</span><br></pre></td></tr></table></figure></p>
<h1 id="377-Combination-Sum-IV"><a href="#377-Combination-Sum-IV" class="headerlink" title="377. Combination Sum IV"></a>377. Combination Sum IV</h1><p>看起来这道题目要求一个完全背包有多少组解。不过后来发现，我们要求的是排列数而不是组合数。<br>这反而简单了，事实上这类似之前的整数划分问题。我们用<code>dp[i]</code>维护和为<code>i</code>有多少种方案，则我们对于所有<code>i</code>，尝试对所有的<code>nums[j]</code>，更新<code>dp[i + nums[j]] += dp[i]</code>。这类似于之前算平方数的解法。</p>
<h1 id="378-Kth-Smallest-Element-in-a-Sorted-Matrix"><a href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix" class="headerlink" title="378. Kth Smallest Element in a Sorted Matrix"></a>378. Kth Smallest Element in a Sorted Matrix</h1><p>这道题很简单，直接模拟归并排序就行了，我用了堆来简化。二分答案应该也可以做，没有试。</p>
<h1 id="381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><a href="#381-Insert-Delete-GetRandom-O-1-Duplicates-allowed" class="headerlink" title="381. Insert Delete GetRandom O(1) - Duplicates allowed"></a>381. Insert Delete GetRandom O(1) - Duplicates allowed</h1><p>用<code>O(1)</code>的复杂度实现<code>insert()</code>、<code>remove()</code>和<code>getRandom()</code>。其中<code>getRandom()</code>要根据每个数字的出现次数来平均分配。<br>首先，既然需要随机，那么我们肯定要维护一个向量表，然后随机它的索引。既然如此，我们如何去对这个向量表进行动态增删呢？<br>主要问题就是删，这里可以借助于C++里面的库函数<code>pop_heap</code>的类似做法来实现，也就是说将要删除的元素和列表末尾的某个元素交换，然后再把列表末尾的元素给pop掉。为了实现这一点，我们就需要为这个向量表建立一个索引表<br>这个题目的<code>insert</code>和<code>remove</code>的返回值的要求很奇怪，WA了半天</p>
<h1 id="382-Linked-List-Random-Node"><a href="#382-Linked-List-Random-Node" class="headerlink" title="382. Linked List Random Node"></a>382. Linked List Random Node</h1><p>从长度未知的链表中随机取出一个节点。这一道题是非常著名的水塘抽样算法。<br>我们首先清楚一个事实，n件物品让n个人选，那么先拿的人和后拿的人获取物品x的概率是一样的。第一个人的概率是$\frac{1}{n}$，第二个人的概率是$\frac{n-1}{n} \times \frac{1}{n-1} = \frac{1}{n}$。<br>这道题也是一样，我们对于第$i$个数，按照$\frac{1}{i}$的概率替换掉已有的数。</p>
<h1 id="386-Lexicographical-Numbers"><a href="#386-Lexicographical-Numbers" class="headerlink" title="386. Lexicographical Numbers"></a>386. Lexicographical Numbers</h1><p>又是和数位DP类似的题目，各种WA。总结一下</p>
<ol>
<li>如果<code>pos &lt; ll - 1</code>，那么从0一直dfs到9</li>
<li>如果<code>pos == ll - 1</code>，此时我们在处理最末位。我们考虑目前的前缀<code>prev</code><ol>
<li>如果是一个不合法的前缀。我们更新<code>prev</code>考虑两种情况，第一个是原<code>prev</code>不合法，那么新<code>prev</code>也不合法；第二个是<code>prev</code>虽然合法，但是是满的，而当前的位超过了<code>nums</code>。对于不合法的前缀，我们不能往下dfs。</li>
<li>如果是一个合法的前缀。我们dfs到<code>nums</code></li>
</ol>
</li>
</ol>
<h1 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387. First Unique Character in a String"></a>387. First Unique Character in a String</h1><p>一开始做了个字典，居然T了。得手动维护一个vis数组</p>
<h1 id="390-Elimination-Game"><a href="#390-Elimination-Game" class="headerlink" title="390. Elimination Game"></a>390. Elimination Game</h1><p>这道题和经典的约瑟夫和问题看起来有点像。当时觉得每次的起始值难算，所以就简单模拟了下，T了。继而我们发现对于任意偶数<code>n</code>，<code>n + 1</code>的答案和<code>n</code>肯定是相等的。看来需要$O(logn)$的复杂度了。于是觉得确实可以把每次扫描数列作为一个子问题，但是我们现在对某个子问题不生成新数组，而是在原数组上进行操作。于是我们维护了<code>s</code>和<code>e</code>，表示我们的起始点和期望的结束点（也就是现在子数列的最末端），设置<code>step</code>为当前的公差。如对<code>1 2 3 4</code>而言，<code>s</code>为1、<code>e</code>为<strong><code>4</code></strong>（不是3），而<code>step</code>为2。容易发现由于我们是偶数项，所以我们只能遍历<code>delta = 2</code>项，并没能遍历到<code>4</code>。我们发现规律，我们每次遍历，要不能遍历到<code>e</code>要不我们能遍历到<code>actual_e</code>，并且<code>actual_e</code>和<code>e</code>相差<code>step / 2</code>。于是我们能够得到新的起点的位置<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> actual_e != e:<span class="type"></span></span><br><span class="line"><span class="type">    news </span>= e <span class="comment">// Or</span></span><br><span class="line">    <span class="keyword">new</span><span class="type">s</span> = actual_e + step / <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:<span class="type"></span></span><br><span class="line"><span class="type">    news </span>= e - step / <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<h1 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392. Is Subsequence"></a>392. Is Subsequence</h1><p>求串<code>s</code>是否是串<code>t</code>的子序列，<code>s</code>范围到500000。<br>朴素做法就是贪一下，$O(n^2)$。<br>【这道题还有Follow Up】</p>
<h1 id="396-Rotate-Function"><a href="#396-Rotate-Function" class="headerlink" title="396. Rotate Function"></a>396. Rotate Function</h1><p>一看这道题想到的第一就是排序不等式，不过这道题只能rotate而不是任意shuffle，所以不能直接套排序不等式。<br>一个直截了当的办法，根据Topic中Math的提示，我们需要推一个公式。首先我们设首项$X_0 = \sum^{n - 1}_{0}{i \times a[i]}$，则$X_k = \sum^{n - 1}_{0}{((i + k) \% n) \times a[i]}$，发现减不了。<br>不过如果直接找规律的话，我们发现$X_i$就是将第$(-i) % n$项置为0，然后其他项都自己加上自己下。因此递推公式很好求了$X = X - (n - 1) * A[(-i \% n)] + s - A[(-i \% n)]$</p>
<h1 id="397-Integer-Replacement"><a href="#397-Integer-Replacement" class="headerlink" title="397. Integer Replacement"></a>397. Integer Replacement</h1><p>一开始我的想法是能<code>/2</code>就<code>/2</code>，因为除法始终能减少一位，而减法只有在2的整数次幂的时候才会减少一位。下面要考虑的就是当低位为k个0的时候我们如何选择是+还是-。显然如果低位只有一个连续的1，那么肯定选择-，如果低位只有两个连续的1，我们分别计算，如果选择+，那么最快的转化是<code>0b11 -&gt; 0b100 -&gt; 0b10 -&gt; 0b1</code>，如果选择-，则最快的转化是<code>0b11 -&gt; 0b10 -&gt; 0b1</code>，因此选择-。同理我们发现当7时两者相等。<br>不过这种解法WA在了1234，我的答案是17，而标准答案是14。后来发现把<code>if n &amp; x == x</code>写成了<code>if n &amp; x</code>，不过10000WA成了17。于是对拍了一下，发现59（<code>0b111011</code>）这个点WA了，正确答案应该是8，应该首先变为<code>0b111100</code>，这样前面就变成了4个1了。这是因为末三位<code>011</code>的策略被选为了-，而正确的策略应该是+。因此我们发现先前的最优策略建立在不考虑高位的情况下，而这对于3来说是不适用的。现在我们综合考虑高位有1的情况，如<code>1011</code>/<code>10011</code>等，我们发现这种情况下应当选择+。<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// AC</span><br><span class="line">elif (<span class="built_in">n</span> &amp; <span class="number">3</span> == <span class="number">3</span>) <span class="built_in">and</span> (<span class="built_in">n</span> != <span class="number">3</span>)<span class="symbol">:</span></span><br><span class="line">    <span class="built_in">n</span> += <span class="number">1</span></span><br><span class="line">el<span class="symbol">se:</span></span><br><span class="line">    <span class="built_in">n</span> -= <span class="number">1</span></span><br><span class="line">// WA</span><br><span class="line">elif <span class="built_in">n</span> &amp; <span class="number">7</span> == <span class="symbol">7:</span></span><br><span class="line">    <span class="built_in">n</span> += <span class="number">1</span></span><br><span class="line">el<span class="symbol">se:</span></span><br><span class="line">    <span class="built_in">n</span> -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="400-Nth-Digit"><a href="#400-Nth-Digit" class="headerlink" title="400. Nth Digit"></a>400. Nth Digit</h1><p>居然打败了100%，这道题WA得好苦，其实细心一点就行</p>
<h1 id="403-Frog-Jump"><a href="#403-Frog-Jump" class="headerlink" title="403. Frog Jump"></a>403. Frog Jump</h1><p>有<code>n</code>个石头，坐标给定。青蛙在第一个石头上，希望能到最后一个石头上。青蛙第一次只能跳一格，假设第<code>i</code>次跳了<code>k</code>格，那么青蛙第<code>i + 1</code>次能跳<code>[k - 1, k, k + 1]</code>格，注意青蛙只能往前跳。问青蛙能否做到。<br>记搜一波呗，T在Case 34，后来加了个剪枝，A了，不过只打败了3.9%。<br>题解给出了一种更好的办法，也就是用<code>int key = pos | k &lt;&lt; 11;</code>做<code>key</code>，然后hash，而不是用二维数组。</p>
<h1 id="406-Queue-Reconstruction-by-Height"><a href="#406-Queue-Reconstruction-by-Height" class="headerlink" title="406. Queue Reconstruction by Height"></a>406. Queue Reconstruction by Height</h1><p>这道题让我想起了315的那个树状数组的题目，其实这道题为了不T，还真的要树状一下。注意当有多个<code>k</code>符合条件的时候我们要选择<code>h</code>最小的。卧槽不仅要树状还要离散化。。。然后还是T了。<br>其实这道题应该是$O(n^2)$的，是一个类似插入排序的思路。</p>
<h1 id="407-Trapping-Rain-Water-II"><a href="#407-Trapping-Rain-Water-II" class="headerlink" title="407. Trapping Rain Water II"></a>407. Trapping Rain Water II</h1><p>这次是二维的问题了，然后我们要注意边缘没有“墙”，也就是四周无法盛水。一开始想的是假设从点$(x, y)$往下倒水，那么水最多能流到哪里，后来发现不好操作，因为每一点的水位高度取决于其周围的方块高度，而这个是递归的。后来发现我们不考虑灌水而考虑漏水，可以将场景看成亚特兰蒂斯，然后水从边缘逐渐退去。我们用<code>level[x][y]</code>表示点$(x, y)$处的水位，我们查看从$(x, y)$能不能放跑其周围方块$(nx, ny)$中的水，这体现在$(x, y)$处的水位<code>level[x][y]</code>低于$(nx, ny)$的水位。我们注意要保证$(nx, ny)$的水位是至少<code>heightMap[nx][ny]</code>的，这样就相当于没有存水。但是我们却不能一开始就设置<code>level[nx][ny] = heightMap[nx][ny]</code>，这样我们就无水可漏，倒是在边缘的<code>level</code>要这么设，因为他们一定不能存水。<br>然后发现其实一开始的思路也可做，不过我们首先需要按高度从低到高选取方块。为了实现这个顺序，我们需要进行优先队列+BFS。每次我们从优先队列中取出水位<code>level</code>（注意不是<code>heightMap</code>）最低的方块，然后查看它是否可以存放更多的水。这里有两种情况，第一种是该方块的四个邻居严格高于自己，这样我们可以补齐该方块的水位。第二种是出现了水位相同的邻居，这时候我们需要用一个dfs来搜一下。</p>
<h1 id="410-Split-Array-Largest-Sum"><a href="#410-Split-Array-Largest-Sum" class="headerlink" title="410. Split Array Largest Sum"></a>410. Split Array Largest Sum</h1><p>将长度为<code>n</code>的串分为<code>m</code>块，要求最小化最大的块的和。能贪么？想了想<code>[2, 5, 6]</code>分两块，贪的话就<code>[2]</code>、<code>[5, 6]</code>了。用DP做，发现我们要求的是min-max在<code>i</code>位置在第<code>j</code>块的和。<br>这道题的DP做法我们同样是维护<code>dp[i][j]</code>为前<code>i</code>个数字分成<code>j</code>组的最小的子数组最大和。计算<code>dp[i][j]</code>时我们可以考虑将它放到前一块中去，或者新开一个块，因此递推方程是<code>dp[i][j] = min(max(dp[i - 1][j - 1], nums[i]), dp[i - 1][j] + nums[i])</code>。但这个递推式是错的，连题目给的样例都通不过。这是因为我们不能断定在<code>i - 1</code>时就是最优子结构，因此我们需要遍历所有的<code>dp[0..(i-1)][j - 1]</code>才行。<br>题解还说原来这条可以二分答案。。。。因为是非负整数。。。。唉，果然二分答案和记搜是拯救DP苦手的神器啊！</p>
<h1 id="413-Arithmetic-Slices"><a href="#413-Arithmetic-Slices" class="headerlink" title="413. Arithmetic Slices"></a>413. Arithmetic Slices</h1><p>给定一个序列，问有多少个子串是等差的。感觉很简单啊，因为是子串而不是子序列嘛，直接统计一下完事了。</p>
<h1 id="414-Third-Maximum-Number"><a href="#414-Third-Maximum-Number" class="headerlink" title="414. Third Maximum Number"></a>414. Third Maximum Number</h1><p>水题，用个优先队列</p>
<h1 id="416-Partition-Equal-Subset-Sum"><a href="#416-Partition-Equal-Subset-Sum" class="headerlink" title="416. Partition Equal Subset Sum"></a>416. Partition Equal Subset Sum</h1><p>背包问题不解释</p>
<h1 id="417-Pacific-Atlantic-Water-Flow"><a href="#417-Pacific-Atlantic-Water-Flow" class="headerlink" title="417. Pacific Atlantic Water Flow"></a>417. Pacific Atlantic Water Flow</h1><p>据说是Google北美的面试题。所以你家你家现在输出又是<code>[]</code>不是[[]]`了，真的搞不懂。。。<br>这道题就是dfs两次啊，matrix需要预先包裹处理一下。注意填充的初始值是-1而不是0，因为有0的cell。</p>
<h1 id="421-Maximum-XOR-of-Two-Numbers-in-an-Array"><a href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array" class="headerlink" title="421. Maximum XOR of Two Numbers in an Array"></a>421. Maximum XOR of Two Numbers in an Array</h1><p>要求在线性时间内找到数组中两个元素的异或的最大值。看看相关Topic，居然是Trie？想了想确实有道理，整个过程类似于在Trie树上递归，对于Trie树的某个节点有0个或1个孩子的情况都很好处理。但当某个节点具有两个孩子时就比较麻烦，我们需要跨两个树进行比较，看来我们不应该在树上递归。<br>这道题目挺难的，我直接看题解了。首先我们尽可能地希望高位是1，然后对后面的位我们迭代解一个子问题，迭代次数是和字长相关的常数。因此在第<code>i</code>次迭代中我们希望能够用少于$O(n^2)$的时间来判定当前<code>i - 1</code>位是最优的情况下，第<code>i</code>高位是否能取到1。以样例<code>3, 10, 5, 8</code>为例，其二进制<code>[0011, 1010, 0101, 1000]</code>。首先查看这四个数的最高位<code>[0, 1, 0, 1]</code>，我们需要检测是否有两个数满足$a \hat{} b = 1$，这同样是个$O(n^2)$得到过程。为了能够减少复杂度，我们可以运用异或的性质$a \hat{} b = x \Rightarrow a \hat{} x = b$，将问题转变为是否存在$a, b$满足$1 \hat{} a = b$，因此我们只要维护一个Map或者Dict对于任意的$a$，寻找Map或者Dict是否存在$1 \hat{} a$，总复杂度可以降为$O(n)$或者$O(n \ lgn)$。在实现的时候，我没有用Map或者Dict，而是用了Trie，这样做前缀比较方便。<br>【这道题还有其他的解法】</p>
<h1 id="424-Longest-Repeating-Character-Replacement"><a href="#424-Longest-Repeating-Character-Replacement" class="headerlink" title="424. Longest Repeating Character Replacement"></a>424. Longest Repeating Character Replacement</h1><p>允许替换X次，求最长的Repeat子串。这道题我们要注意必须向两边搜，例如<code>BAAAB</code>，不能以开头的<code>B</code>为主元。因此朴素是$O(n^{2k})$的，我们需要枚举向两边搜的长度。<br>然后我想到能否二分答案，对于每一个可能的长度<code>length</code>，我们找到所有的<code>s[i:i+length]</code>，来验证它们是否可行。这样的验证是平凡的，我们只需要找到数量最多的元素，看看它的数量加上<code>k</code>能不能大于等于<code>length</code>即可。这个方法是$O(n^2 lgn)$的，T了，这是因为<code>check</code>函数是$O(n^2)$的，我们可以优化掉一个$n$，但这仍然是T的。<br>后来我发现其实完全没有必要二分答案啊，我们将<code>k</code>移到不等号的右边。</p>
<h1 id="427-Construct-Quad-Tree"><a href="#427-Construct-Quad-Tree" class="headerlink" title="427. Construct Quad Tree"></a>427. Construct Quad Tree</h1><p>给定一个<code>N*N</code>的矩阵，N是的幂，要求构造一个四叉树。递归搞一下就行了</p>
<h1 id="434-Number-of-Segments-in-a-String"><a href="#434-Number-of-Segments-in-a-String" class="headerlink" title="434. Number of Segments in a String"></a>434. Number of Segments in a String</h1><p>简单题</p>
<h1 id="435-Non-overlapping-Intervals"><a href="#435-Non-overlapping-Intervals" class="headerlink" title="435. Non-overlapping Intervals"></a>435. Non-overlapping Intervals</h1><p>TODO<br>给定一些区间，问至少移除多少区间，才能让它们彼此都不重叠。<br>这道题看起来就是一个贪心。我尝试以每条线段和其他线段的overlap的次数做参考，每一次选择次数最多的线段删掉。但是这样会WA在<code>\[\]\[\]int\{\{0,2\},\{1,3\},\{1,3\},\{2,4\},\{3,5\},\{3,5\},\{4,6\}\}</code>这个case上面。<br>猜想是重复的问题，于是我尝试去重，结果倒在倒数第二个case上面。那个case真大，希望后面能找到一个简洁的反例。。。。<br>最后解决方案是按照右边界排序，然后贪心过一遍就行。<br>其实我觉得这一类区间Interval相关的问题，一般都会涉及按照左端点或者右端点进行排序。</p>
<h1 id="437-Path-Sum-III"><a href="#437-Path-Sum-III" class="headerlink" title="437. Path Sum III"></a>437. Path Sum III</h1><p>建一棵和树<code>st</code>，然后dfs这个树，并且按照类似560的办法维护一个哈希集。<br>WA了蛮多次，都是粗心，比如说要有<code>d[need] &gt; 0</code>的判断，和<code>+= d[need]</code>而不是<code>+=1</code></p>
<h1 id="440-K-th-Smallest-in-Lexicographical-Order"><a href="#440-K-th-Smallest-in-Lexicographical-Order" class="headerlink" title="440. K-th Smallest in Lexicographical Order"></a>440. K-th Smallest in Lexicographical Order</h1><p>这道题其实就是对一个十叉树进行先根遍历，不过普通的搜会T。所以要做到<code>log</code>的复杂度，不过我WA了好多发。<br>一开始我希望能够仿照数位DP，计算长度为<code>len</code>的以<code>i</code>开头的数字有多少个。不过这道题这么做并不讨巧，因为我们只限定了长度<code>len</code>，而没有限定位置<code>pos</code>，而在不同的<code>pos</code>，由<code>n</code>给定的<code>end</code>是不同的。而我使用了三维数组之后发现这次记搜根本不会被Hit了。<br>这道题的正解，可以分为两步，第一步是求一个节点包含自己的所有子孙的节点总数；第二步是找出第k个节点。</p>
<h1 id="442-Find-All-Duplicates-in-an-Array"><a href="#442-Find-All-Duplicates-in-an-Array" class="headerlink" title="442. Find All Duplicates in an Array"></a>442. Find All Duplicates in an Array</h1><p>【这一条有多种解法，值得一看】<br>这是第287条的升级版，我们记得上一条是用的二分答案，但这一条不行了吧。但是我们发现Range是<code>[1..n]</code>，我们可以从这上面下功夫。这个有点类似于第41条的思路，我们希望通过交换将<code>nums[i] = x</code>移到<code>x - 1</code>的位置上去。如果此时<code>x - 1</code>位置上的值<code>nums[x - 1]</code><strong>也</strong>是<code>x</code>，那么我们就可以知道<code>x</code>是重复的了；如果是<code>y</code>，那么我们就将<code>x</code>与<code>y</code>交换，这样<code>x</code>就回到了正确的位置上，而我们下面继续将<code>nums[i] = y</code>归位，这个循环一直执行到<code>nums[i] = i + 1</code>，然后我们处理下一个位置<code>i + 1</code>。这道题击败了99.93%。。。</p>
<h1 id="446-Arithmetic-Slices-II-Subsequence"><a href="#446-Arithmetic-Slices-II-Subsequence" class="headerlink" title="446. Arithmetic Slices II - Subsequence"></a>446. Arithmetic Slices II - Subsequence</h1><p>首先来一波暴力的dfs，果断T了。看看能不能改成记搜，这里的麻烦之处是状态很难解决，因为公差和末项可能很大，难以存储。然后我想到$N$只有1000，所以可以离散化公差是一个思路，不过好像还是会超空间。通过题解，发现可用数列的末两项（用首两项也行）来离散化首项+公差，不过这次T在了69/101，比之前的39/101稍有进步。后来给<code>l == 1</code>也加上记搜，发现就WA了，后来想想居然也不知道为啥<code>l == 2</code>情况记搜就能过，先放这儿把。<span style="display:none">不过发现都不能记搜<code>l == 1的情况，否则结果都会被置为0（如果先搜不选的情况的话）。以末两项</code>[2, 4, 6]<code>为例，考虑我们2不取，这时末两项为</code>(4, 6)<code>且</code>l == 2<code>，不能构成等差数列，那么搜索会记</code>dp[1][2] = 0<code>，仔细考虑这种情况，是因为我们没有将</code>l`纳入考虑。再考虑首两项的情况也类似。</span></p>
<p>这道题之前一直尝试记忆搜索，不过一直没搞定，后来发现直接DP反而更简单。<br>不过后来发现<code>O(n^3)</code>会T在78/101。后来看了题解知道由于可能的差是很少的，所以我们可以维护一个反查的<code>dict</code>。</p>
<h1 id="448-Find-All-Numbers-Disappeared-in-an-Array"><a href="#448-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="448. Find All Numbers Disappeared in an Array"></a>448. Find All Numbers Disappeared in an Array</h1><p>简单题，类似于442题</p>
<h1 id="449-Serialize-and-Deserialize-BST"><a href="#449-Serialize-and-Deserialize-BST" class="headerlink" title="449. Serialize and Deserialize BST"></a>449. Serialize and Deserialize BST</h1><p>由于是BST，所以根据中序遍历就行了，但是这道题我用Python写在最后一个点MLE了。。。</p>
<h1 id="451-Sort-Characters-By-Frequency"><a href="#451-Sort-Characters-By-Frequency" class="headerlink" title="451. Sort Characters By Frequency"></a>451. Sort Characters By Frequency</h1><p>简单题。</p>
<h1 id="452-Minimum-Number-of-Arrows-to-Burst-Balloons"><a href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons" class="headerlink" title="452. Minimum Number of Arrows to Burst Balloons"></a>452. Minimum Number of Arrows to Burst Balloons</h1><p>有若干起点和终点的horizontal线段，问最少用多少条vertical直线才能全部与它们相交。这道题并不是问若干直线最多能经过多少条线段，而是需要<strong>全部</strong>相交，那么方法就很明显了，按照起点排序然后贪心。</p>
<h1 id="453-Minimum-Moves-to-Equal-Array-Elements"><a href="#453-Minimum-Moves-to-Equal-Array-Elements" class="headerlink" title="453. Minimum Moves to Equal Array Elements"></a>453. Minimum Moves to Equal Array Elements</h1><p>操作只能是对<code>n-1</code>个元素进行自增。我们注意到对<code>n-1</code>个元素自增相当于对唯一一个元素自减。</p>
<h1 id="456-132-Pattern"><a href="#456-132-Pattern" class="headerlink" title="456. 132 Pattern"></a>456. 132 Pattern</h1><p>这道题非常好，我只想出了$O(n^2)$的方法，但正解要$O(n)$。具体做法看我源码里面的注释。</p>
<h1 id="459-Repeated-Substring-Pattern"><a href="#459-Repeated-Substring-Pattern" class="headerlink" title="459. Repeated Substring Pattern"></a>459. Repeated Substring Pattern</h1><p>很好地简单题，细节蛮多的</p>
<h1 id="462-Minimum-Moves-to-Equal-Array-Elements-II"><a href="#462-Minimum-Moves-to-Equal-Array-Elements-II" class="headerlink" title="462. Minimum Moves to Equal Array Elements II"></a>462. Minimum Moves to Equal Array Elements II</h1><p>相比上一题，这道题允许选择任意元素+1或者-1。一开始我觉得是尽量往平均数靠拢，但Case<code>[1,0,0,8,6]</code>会WA。其实这道题是求绝对值距离最小，通过Google，这其实是最小一乘法的一个结论，应当选取中位数。<br>Leetcode上还提供了一个类似贪心的解法，也就是先排序，然后每次选取一个最高分一个最低分，让他们相等，然后去掉。</p>
<h1 id="463-Island-Perimeter"><a href="#463-Island-Perimeter" class="headerlink" title="463. Island Perimeter"></a>463. Island Perimeter</h1><p>这条不需要DFS哦</p>
<h1 id="464-Can-I-Win"><a href="#464-Can-I-Win" class="headerlink" title="464. Can I Win"></a>464. Can I Win</h1><p>Alice和Bob轮流从<code>[1..maxChoosableInteger]</code>中取数字加到一个总和上，不能重复取，最先达到或者超过<code>desiredTotal</code>的就胜利。问先手能不能胜利，<code>maxChoosableInteger</code>小于20，<code>desiredTotal</code>小于300。<br>先来个AlphaBeta剪枝（原理见486），WA了，<code>10 40</code>的样例我输出<code>true</code>。去掉剪枝，连dfs都是错的，反省一下自己的思路，我是直接dfs，然后当和大于<code>desiredTotal</code>，就更新<code>self.best</code>，这是错误的，因为没有考虑对手的optimal选择。<br>其实来一波记搜就好了。<br>注意记搜不要和AlphaBeta剪枝一起使用。</p>
<h1 id="467-Unique-Substrings-in-Wraparound-String"><a href="#467-Unique-Substrings-in-Wraparound-String" class="headerlink" title="467. Unique Substrings in Wraparound String"></a>467. Unique Substrings in Wraparound String</h1><p>这道是DP，由于要考虑重复的问题所以不能直接算。蛮要想的，原理是<code>dp[x]</code>表示以<code>x</code>结尾的连续串的最长长度。这样最末位的元素不同就能保证了。然后注意不是<code>dp[p[i]] = dp[p[i - 1]] + 1</code>啊，因为<code>dp[p[i - 1]]</code>的最大值不一定在这里取到。</p>
<h1 id="473-Matchsticks-to-Square"><a href="#473-Matchsticks-to-Square" class="headerlink" title="473. Matchsticks to Square"></a>473. Matchsticks to Square</h1><p>由于火柴棒长度很长，所以不能背包（超大背包啥的也算了）。<br>这道题就是老老实实DFS，然而我怎么样都TLE。记忆化+bitmask居然更慢。有人说先DFS分成两个，再分成四个，不过很慢。<br>网上看到一个题解，使用了一个非常好的DFS方法，它每一个dfs枚举火柴<code>i</code>放在第<code>j</code>个边上。这样相比我们每一个dfs试图把剩余的某个火柴加到现在的和里要快些。</p>
<h1 id="474-Ones-and-Zeroes"><a href="#474-Ones-and-Zeroes" class="headerlink" title="474. Ones and Zeroes"></a>474. Ones and Zeroes</h1><p>二维费用背包模板题</p>
<h1 id="475-Heaters"><a href="#475-Heaters" class="headerlink" title="475. Heaters"></a>475. Heaters</h1><h1 id="476-Number-Complement"><a href="#476-Number-Complement" class="headerlink" title="476. Number Complement"></a>476. Number Complement</h1><p>还是得<code>while x &gt;&gt;= 1</code>一下的。。。</p>
<h1 id="477-Total-Hamming-Distance"><a href="#477-Total-Hamming-Distance" class="headerlink" title="477. Total Hamming Distance"></a>477. Total Hamming Distance</h1><p>这条直接按位统计0和1的数量，然后计算乘积的和就可以了</p>
<h1 id="478-Generate-Random-Point-in-a-Circle"><a href="#478-Generate-Random-Point-in-a-Circle" class="headerlink" title="478. Generate Random Point in a Circle"></a>478. Generate Random Point in a Circle</h1><p>如果去sample一个圆周，很简单，那么如何sample一个圆呢？<br>最简单的方法是所谓的rejection method，我们去sample圆的一个外接正方形是容易的，然后我们while掉在圆外面的点即可。<br>但其实我们可以通过修改sample圆周的方法来解决这个问题，令随机量为$u$，我们也就是将$r = R * u$改为$r = R * \sqrt{u}$即可。为什么其sqrt，其原因很简单。因为对面积均匀划分，我们实际上要$\pi r^2 * u$是要得到这样的一个均匀的统计量。化简一下就能得到一个根号了。</p>
<h1 id="480-Sliding-Window-Median"><a href="#480-Sliding-Window-Median" class="headerlink" title="480. Sliding Window Median"></a>480. Sliding Window Median</h1><p>这个得用C++做，其原理是利用<code>multiset</code>的动态排序功能</p>
<h1 id="481-Magical-String"><a href="#481-Magical-String" class="headerlink" title="481. Magical String"></a>481. Magical String</h1><p>一个很有趣的问题。给定序列<code>1 22 11 2 1 22 1 22 11 2 11 22</code>，我们统计连续数字的长度，得到如下的序列<code>1 2 2 1 1 2 1 2 2 1 2 2</code>。发现这两个序列是同构的。现在要问前N(<code>N&lt;100000</code>)里面有几个1。这个可以顺着推出来，类似DNA转录那样，我们双指针维护一个转录列表指针和读取指针即可。</p>
<h1 id="483-Smallest-Good-Base"><a href="#483-Smallest-Good-Base" class="headerlink" title="483. Smallest Good Base"></a>483. Smallest Good Base</h1><p>这个妹(ti)妹(mu)我是见过的，其实就是算满足$x^0 + x^1 + … + x^{k-1} == n$的最小$x$。要解这个方程，不会怎么办，考虑到<code>n</code>才到<code>10 ** 18</code>，令<code>x == 2</code>的话<code>k</code>也才到<code>61</code>，这里就枚举<code>k</code>咯，然后<code>x</code>直接二分即可，下界注意是2不是3，我在这里WA了一次，上界的话我不会解那个不等式，直接令到<code>10 ** 18</code>居然也过了</p>
<h1 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a>486. Predict the Winner</h1><p>【本题是AlphaBeta剪枝暴力掉的，但可以DP】<br>两个人轮流从数组两端取数字，和最大的胜利。数组最长为20。本题可以用AlphaBeta剪枝来做，Python会被卡掉，<a href="https://paste.ubuntu.com/p/CYjCV8rqRV/" target="_blank" rel="noopener">但是C++能过</a>。<br>AlphaBeta剪枝的主体仍然是一个dfs，并且我们需要一个评价函数来评估目前的局势。Alpha指的是在自己的回合（MAX节点），自己能<strong>确保</strong>的最利于自己的值。Beta指的是在对手的回合（MIN节点），对手能<strong>确保</strong>的最不利自己的值。MINMAX博弈假设对手拥有完全信息，总是能做出完美决策，所以对手要最小化评价函数的增益。容易发现初始情况下取Alpha/Beta为-Inf/+Inf，由于我们还没进入游戏，所以这是可能的最高/低分。容易发现我们的目标是尽可能提高Alpha值。<br>现在考虑DFS的过程，我们首先以一个MAX节点作为根往下遍历，我们首先递归地计算其第一个MIN子节点的Beta值（MIN节点的计算将在下面论述），这时候根节点取该Beta值为自己的Alpha值。从目前看，结果不会比它更坏，但是我们不能就此停住，而是要接着遍历，看看有没有更好的结果，即我们取所有的Beta值里面最高的作为我们MAX节点的Alpha值。在计算完第一个节点后，我们递归计算第二个MIN节点，在计算开始时，我们要<strong>通知这个MIN节点当前的Alpha值</strong>。下面我们来跟踪这个MIN节点计算自己的Beta值的过程，MIN节点的子节点是MAX节点，所以这个MIN节点需要取自己所有子节点的最小的Alpha值作为最终的Beta值。ALphaBeta剪枝认为此时不需要遍历所有的节点，因为一旦我们发现当前的Beta值低于父MAX节点所通告的Alpha值，那么我们在父MAX节点肯定不会选择我们当前的MIN节点了，于是可以剪枝，即我们不需要算完这个MIN节点了。<br>同理，以某个MIN节点为根向下遍历，也是先选取第一个子MAX节点的Beta值，然后通告给第二个子MAX节点。由于根节点MIN要选择尽可能小的，所以如果子MAX节点的Alpha值大于通告的Beta值，也进行剪枝。<br>对于本题，剩下的工作就是选取一个适合的评价函数，这里选取两者和的差即可。</p>
<h1 id="491-Increasing-Subsequences"><a href="#491-Increasing-Subsequences" class="headerlink" title="491. Increasing Subsequences"></a>491. Increasing Subsequences</h1><p>【不使用set如何做呢？Leetcode上似乎有一个Discuss】<br>用一个set来维护已有的上升序列，对于<code>i</code>位置的考虑能否扩展set中的序列。注意需要去重，这里用了一个很投机取巧的办法，虽然Python不能序列化list，但是可以序列化str或者tuple，所以。。。<br>不过下面我们来考虑普通的DFS的方法，我们如何来去重？一开始我想的是根据长度和最后一个元素来去重，认为以某个元素结尾的固定长度的递增序列是固定的。</p>
<h1 id="493-Reverse-Pairs"><a href="#493-Reverse-Pairs" class="headerlink" title="493. Reverse Pairs"></a>493. Reverse Pairs</h1><p>这是一个变种的逆序对，即现在逆序对不仅是<code>nums[i] &gt; nums[j]</code>，而要满足<code>nums[i] &gt; 2*nums[j]</code>。一般逆序对可以借助于树状数组和分治法来做。树状数组的做法基于它能够在$O(log n)$的时间内求出$A[1..n]$的和。这里的<code>A</code>其实是一个01数组，<code>A[x]</code>表示数字<code>x</code>是否存在。因此我们小于<code>x</code>的元素的数量是<code>A[1..x-1]</code>的和，可以通过树状数组快速求出。现在我们遍历<code>nums</code>中的每个数字<code>x</code>，并修改<code>A[x] = 1</code>，那么包含<code>x</code>的逆序对的数量就是目前树状数组中值大于$x$的元素的数量，因为这些本来应该在<code>x</code>遍历到之后再被遍历的。<br>这条如果用树状数组来做的话，<code>A</code>需要离散化。在离散化的同时需要处理好找不到的两种情况。</p>
<h1 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a>494. Target Sum</h1><p>这是一条变种的01背包，我们需要求一个和为<code>(S + sum(nums))/2</code>的子集。</p>
<h1 id="495-Teemo-Attacking"><a href="#495-Teemo-Attacking" class="headerlink" title="495. Teemo Attacking"></a>495. Teemo Attacking</h1><p>这道题就是说在技能冷却的时候放技能不能重复统计技能有效时间，数组是有序的，因此我们直接维护一个边界<code>r</code>，每次根据起始时间是否与<code>r</code>重叠讨论，最后更新<code>r</code>即可。</p>
<h1 id="498-Diagonal-Traverse"><a href="#498-Diagonal-Traverse" class="headerlink" title="498. Diagonal Traverse"></a>498. Diagonal Traverse</h1><p>对角遍历矩阵。<br>这道题其实不难了，遍历就两个方向交替，主要就是越界时改变方向需要想几个样例找规律即可。总结下来就是一般出格时只需要将导致出格的那个速度分量保持不动，另外一个坐标直接+1。不过还有一个特殊情况就是在矩阵四角，两个速度分量都会导致出格。</p>
<h1 id="502-IPO"><a href="#502-IPO" class="headerlink" title="502. IPO"></a>502. IPO</h1><p>一开始有<code>W</code>的钱，用它在<code>n</code>个项目里面选<code>k</code>个来做，项目<code>i</code>需要<code>C[i]</code>的启动资金，带来<code>P[i]</code>的纯利润，问最后能够达到的最大的资本是多少。<br>用两个PQ维护一下就行了。</p>
<h1 id="503-Next-Greater-Element-II"><a href="#503-Next-Greater-Element-II" class="headerlink" title="503. Next Greater Element II"></a>503. Next Greater Element II</h1><p>数组复制一遍，然后对于每一个元素如果比栈顶小就入栈，否则就出栈</p>
<h1 id="504-Base-7"><a href="#504-Base-7" class="headerlink" title="504. Base 7"></a>504. Base 7</h1><p>简单题</p>
<h1 id="513-Find-Bottom-Left-Tree-Value"><a href="#513-Find-Bottom-Left-Tree-Value" class="headerlink" title="513. Find Bottom Left Tree Value"></a>513. Find Bottom Left Tree Value</h1><p>BFS即可</p>
<h1 id="514-Freedom-Trail"><a href="#514-Freedom-Trail" class="headerlink" title="514. Freedom Trail"></a>514. Freedom Trail</h1><p>很明显是DP，用<code>dp</code>维护准备填入<code>i</code>字符时轮盘指向<code>j</code>的最少步数，那么对于每一个<code>(i, j)</code>，我们查看所有的<code>k</code>到<code>j</code>的最短距离。这里要注意一下最短距离是<code>min((j - k) % m, (k - j) % m)</code>，而不是<code>abs(j - k) % m</code>。</p>
<h1 id="515-Find-Largest-Value-in-Each-Tree-Row"><a href="#515-Find-Largest-Value-in-Each-Tree-Row" class="headerlink" title="515. Find Largest Value in Each Tree Row"></a>515. Find Largest Value in Each Tree Row</h1><p>二叉树层次遍历，么得意思</p>
<h1 id="516-Longest-Palindromic-Subsequence"><a href="#516-Longest-Palindromic-Subsequence" class="headerlink" title="516. Longest Palindromic Subsequence"></a>516. Longest Palindromic Subsequence</h1><p>最长回文序列（不是串了）。这道题又是$O(n^2)$然后Python的T，C++的AC的题目。。。<br>我们用<code>dp[i][j]</code>维护<code>[0,i]</code>和<code>[j,n-1]</code>这两个区间上对称字符串的长度。例如<code>bbbab</code>中<code>[0,1]</code>区间上是<code>bb</code>，<code>[4,4]</code>区间上是<code>b</code>，左边的一个<code>b</code>能和右边的一个<code>b</code>对应，因此<code>dp[1][4]</code>是2。而我们最长的回文序列的长度有两种情况。第一种是<code>[0,i] [i+1,n-1]</code>这样，那么结果是<code>dp[i][i+1]</code>；第二种是<code>[0,i] [i+2,n-1]</code>这样的，也就是说长度是奇数，中间夹了个<code>i+1</code>位置的，这种结果是<code>dp[i][i+2] + 1</code>。<br>注意初始化的时候应该首先将<code>dp</code>设为0（而不是1），然后预先计算<code>dp[0][j]</code>和<code>dp[i][n-1]</code></p>
<h1 id="517-Super-Washing-Machines"><a href="#517-Super-Washing-Machines" class="headerlink" title="517. Super Washing Machines"></a>517. Super Washing Machines</h1><p>emmmm，洗衣机，让我想到某次区域赛的赛题。题意是有<code>n</code>个洗衣机，里面衣服的数量用一个数组<code>machines</code>表示。每一次行动时，需要选择任意的<code>m</code>个洗衣机，同时将每个洗衣机中间的一件衣服移到相邻的洗衣机中。要求输出使得每个洗衣机中衣服数量相等的最少的移动次数。每个洗衣机里面最多有1e5件衣服，最多有10000个洗衣机。从数据规模上来看，我们无法维护每一个洗衣机的状态。<br>其实，我们可以算出最终一个洗衣机里面要放多少衣服，因为衣服是要逐个洗衣机进行移动的，所以我们可以统计每一个洗衣机左边和右边分别有多少衣服，就能知道这个洗衣机要执行多少次移动操作了。问题是，但是这里面有多少移动操作是可以并行执行的呢？<br>我们可以算得<code>lb[i]</code>表示洗衣机<code>i</code>左边还需要多少衣服，<code>rb[i]</code>表示右边还需要多少衣服，<code>m[i]</code>表示<code>i</code>当前有几件衣服。如果<code>m[i] &gt; 0 &amp;&amp; lb[i] &gt; 0</code>，那么则可以进行一次向左移动，<code>m[i] &gt; 0 &amp;&amp; rb[i] &gt; 0</code>则可以进行一次向右移动。那么，只要能整除，就一定能达到最后的解。这个解法T在第105/120个TestCase</p>
<p>题解是<code>O(n)</code>的，很神奇。我们从左到右遍历数组，维护一个<code>balance</code>是累计和，表示到现在为止，需要向右边拿/然后，我们还要考虑每个洗衣机都要送多少衣服，这个也要最大值。我们不考虑每个洗衣机要拿多少衣服，因为它可能从不同的洗衣机拿衣服，例如我们取<code>Abs</code>，就会WA在<code>[9,1,8,8,9]</code>这个case上面。上面两个检验是必要的，但为什么是充分的呢？TODO</p>
<h1 id="518-Coin-Change-2"><a href="#518-Coin-Change-2" class="headerlink" title="518. Coin Change 2"></a>518. Coin Change 2</h1><p>见343</p>
<h1 id="523-Continuous-Subarray-Sum"><a href="#523-Continuous-Subarray-Sum" class="headerlink" title="523. Continuous Subarray Sum"></a>523. Continuous Subarray Sum</h1><p>【有趣而且坑多】<br>这道题很有趣，我虽然过了，但是$O(kn)$而不是最优解$O(n)$。题目要求<strong>判断</strong>是否存在一个长度大于等于2的子数组，它的和是<code>k</code>的倍数。那么我们维护到<code>i</code>为止所有以<code>nums[i - 1]</code>为结尾的后缀和到一个集合<code>s</code>中，对于<code>i</code>，我们检查<code>(k - nums[i]) % k</code>是否存在于set中即可。我们注意要在检查完之后更新集合<code>s</code>，也就是将集合中的所有数（同余地）加上<code>nums[i]</code>，并且在集合中加上<code>nums[i]</code>。<br>枚举一下这道题一不小心会遇到的坑：<code>k</code>为0（数组中含有/不含有/连续/不连续的0），<code>k</code>为1（这个一定成立），<code>k</code>为负数。<br>下面是这道题的$O(n)$解法，如果当前的累加和除以<code>k</code>得到的余数在set中已经存在了，那么说明之前必定有一段子数组和可以整除<code>k</code>。</p>
<h1 id="524-Longest-Word-in-Dictionary-through-Deleting"><a href="#524-Longest-Word-in-Dictionary-through-Deleting" class="headerlink" title="524. Longest Word in Dictionary through Deleting"></a>524. Longest Word in Dictionary through Deleting</h1><p>这道题先排个序，然后对<code>d</code>中每一个<code>x</code>用$O(n)$的时间来计算一下能否通过删除<code>s</code>中的某几个字符得到。</p>
<h1 id="525-Contiguous-Array"><a href="#525-Contiguous-Array" class="headerlink" title="525. Contiguous Array"></a>525. Contiguous Array</h1><p>用C++做，本题可以规约到560这种形式</p>
<h1 id="526-Beautiful-Arrangement"><a href="#526-Beautiful-Arrangement" class="headerlink" title="526. Beautiful Arrangement"></a>526. Beautiful Arrangement</h1><p>记搜</p>
<h1 id="528-Random-Pick-with-Weight"><a href="#528-Random-Pick-with-Weight" class="headerlink" title="528. Random Pick with Weight"></a>528. Random Pick with Weight</h1><p>让我想起了382的那个水塘抽样算法。这道题实际上是有放回的，所以很简单。直接二分累积和，找最小的大于<code>ran</code>的<code>self.r[i]</code>。其中<code>ran = random.randint(1, self.r[-1])</code>，注意不是1，因为至少要取一个。</p>
<h1 id="540-Single-Element-in-a-Sorted-Array"><a href="#540-Single-Element-in-a-Sorted-Array" class="headerlink" title="540. Single Element in a Sorted Array"></a>540. Single Element in a Sorted Array</h1><p>异或的基本性质</p>
<h1 id="546-Remove-Boxes"><a href="#546-Remove-Boxes" class="headerlink" title="546. Remove Boxes"></a>546. Remove Boxes</h1><p>有点像312那条打气球的题目和488的Zuma球。这条裸DFS显然会T，如果使用普通的记搜，下层递归如何处理由于上层递归中的某个Box被移除导致两边颜色相同的Box连起来的情况呢？我们如果记录一下哪些Box被移除了，那我们status的长度最多是100位，这肯定是要爆的，所以我们得想想用其他的东西来描述状态。<br>在另一方面，根据经验，使用<code>dp[l][r]</code>维护一段区间内的最优解是容易想到的。进而我们想到<code>dp[l][r]</code>的最优解一定是盒子被全部移除之后的（否则我们总可以再移除一个盒子以得到更优解），而在<code>dfs(l, r)</code>前这段区间里面的Box都是存在的。于是我们实际上就可以特判一下<code>L[take-1][0]</code>和<code>L[take+1][0]</code>是否相等然后做个合并就行了。但这样是错误的，因为我们是二分的区间，只切一刀，这样无法得到下面这种情况的最优解。</p>
<pre><code>(1,1) | best_solution | (1,1)
</code></pre><p>因为无论我们这一刀切在哪里，中间的<code>best_solution</code>都会错误地和后面的<code>(1,1)</code>做合并。于是我们</p>
<pre><code>(1,1) | not_best_solution
</code></pre><p>于是我们的应对之策就是在枚举一下第一刀切在哪里，不过这个做法也不行，我们看下面的样例，正解应该是14。但是我们切两刀也是不行的，于是乎发现这道题似乎不能靠切。。。</p>
<pre><code>1, 2, 2, 1, 3, 1
</code></pre><p>所以最终结果是这一条我不会。。。看题解，<code>dp[l][r][k]</code>表示有<code>k</code>个后缀和<code>nums[r]</code>一样的情况下<code>l</code>到<code>r</code>得分最大。于是我们有两种case，将<code>L[r]</code>和后面的<code>k</code>个合并，或者将<code>L[r]</code>和某个<code>l &lt;= pos &lt;= r</code>合并。<br><a href="https://leetcode.com/problems/remove-boxes/discuss/101314/C++-29ms-dp-solution" target="_blank" rel="noopener">https://leetcode.com/problems/remove-boxes/discuss/101314/C++-29ms-dp-solution</a>!</p>
<h1 id="547-Friend-Circles"><a href="#547-Friend-Circles" class="headerlink" title="547. Friend Circles"></a>547. Friend Circles</h1><p>统计连通分量了，和之前一条海岛的题目挺像的，直接DFS。</p>
<h1 id="552-Student-Attendance-Record-II"><a href="#552-Student-Attendance-Record-II" class="headerlink" title="552. Student Attendance Record II"></a>552. Student Attendance Record II</h1><p>这道题当时想直接推个公式，但是好像比较难。然后我决定分两部分来考虑，首先不考虑缺席A的情况。那么问题变成计算不能超过连续两个迟到L的方案数。这是一个简单的DP。我们分别用<code>P[i]</code>和<code>L[i]</code>表示第<code>i</code>天选择出勤和迟到的方案数，则递推关系如下。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 第i天出勤则第i<span class="number">-1</span>天可以出勤或者不出勤</span><br><span class="line"><span class="symbol">P</span>[i] = (<span class="symbol">L</span>[i - <span class="number">1</span>] + <span class="symbol">P</span>[i - <span class="number">1</span>]) <span class="comment">% M</span></span><br><span class="line"># 第i天不出勤，要么第i<span class="number">-1</span>天出勤，要么第i<span class="number">-2</span>天出勤，不能两天都不出勤</span><br><span class="line"><span class="symbol">L</span>[i] = (<span class="symbol">P</span>[i - <span class="number">2</span>] + <span class="symbol">P</span>[i - <span class="number">1</span>]) <span class="comment">% M</span></span><br></pre></td></tr></table></figure></p>
<p>下面我们考虑缺席A就很简单了，假设一次不缺席，问题退化成上面的解答。假如缺席一次，我们就枚举缺席的那一天，然后题目变为了两个上面的情况。</p>
<h1 id="553-Optimal-Division"><a href="#553-Optimal-Division" class="headerlink" title="553. Optimal Division"></a>553. Optimal Division</h1><p>这条随便写一下居然击败了99.4%的人，感觉写的常数很大啊。<br><code>mx</code>和<code>mi</code>维护了区间<code>[i,j]</code>上的最大值，计算这个枚举分割点<code>k</code>就可以了。WA了一次是因为可能不分割，例如<code>[6,2,3,4,5]</code>应当是<code>6/(2/3/4/5)</code>，后面的<code>2,3,4,5</code>不需要分隔。<br>我们还要返回一个具体的括号方案，这个就使用<code>pmx</code>和<code>pmi</code>来维护两边的字符串，注意当只有一个数字的时候不要加括号。</p>
<h1 id="554-Brick-Wall"><a href="#554-Brick-Wall" class="headerlink" title="554. Brick Wall"></a>554. Brick Wall</h1><h1 id="556-Next-Greater-Element-III"><a href="#556-Next-Greater-Element-III" class="headerlink" title="556. Next Greater Element III"></a>556. Next Greater Element III</h1><p>这个类似Next Permutation那条，直接找到第一个上升型，然后用它之后的大于它的最小数来交换。注意要判断爆int的情况，WA了好几次。</p>
<h1 id="560-Subarray-Sum-Equals-K"><a href="#560-Subarray-Sum-Equals-K" class="headerlink" title="560. Subarray Sum Equals K"></a>560. Subarray Sum Equals K</h1><p>这是类似Two sum一类的Hash经典题，我们要求是否存在<code>j</code>使得<code>sum[i]-sum[j]==k</code>也就是求对于任意的<code>i</code>，是否存在<code>sum[j]==sum[i]-k</code></p>
<h1 id="561-Array-Partition-I"><a href="#561-Array-Partition-I" class="headerlink" title="561. Array Partition I"></a>561. Array Partition I</h1><p>排序一下，然后就是结果。。。</p>
<h1 id="576-Out-of-Boundary-Paths"><a href="#576-Out-of-Boundary-Paths" class="headerlink" title="576. Out of Boundary Paths"></a>576. Out of Boundary Paths</h1><p>哎，和之前那个骑马的概率DP蛮像的，这边其实也能正过来推的哦。</p>
<h1 id="583-Delete-Operation-for-Two-Strings"><a href="#583-Delete-Operation-for-Two-Strings" class="headerlink" title="583. Delete Operation for Two Strings"></a>583. Delete Operation for Two Strings</h1><p>最短编辑距离模板题</p>
<h1 id="594-Longest-Harmonious-Subsequence"><a href="#594-Longest-Harmonious-Subsequence" class="headerlink" title="594. Longest Harmonious Subsequence"></a>594. Longest Harmonious Subsequence</h1><p>找最长的子序列，要求序列中的值的差为1。简单题</p>
<h1 id="600-Non-negative-Integers-without-Consecutive-Ones"><a href="#600-Non-negative-Integers-without-Consecutive-Ones" class="headerlink" title="600. Non-negative Integers without Consecutive Ones"></a>600. Non-negative Integers without Consecutive Ones</h1><p>无脑数位DP</p>
<h1 id="605-Can-Place-Flowers"><a href="#605-Can-Place-Flowers" class="headerlink" title="605. Can Place Flowers"></a>605. Can Place Flowers</h1><p>简单题，注意边界情况</p>
<h1 id="611-Valid-Triangle-Number"><a href="#611-Valid-Triangle-Number" class="headerlink" title="611. Valid Triangle Number"></a>611. Valid Triangle Number</h1><p>首先sort一下是肯定的。枚举<code>i</code>、<code>j</code>二分最后一个长度，T在了219/220。那应该是$O(n^2)$了。我们考虑每个数的范围最多直到1000，因此考虑统计<code>le_n[x]</code>为小于等于<code>x</code>的数的数量。那么我们考虑<code>a[i] &lt; a[j] &lt; a[k]</code>，我们从0开始遍历<code>j</code>（为什么是<code>j</code>不是<code>k</code>稍后说明），此时我们的<code>le_n</code>更新到<code>nums[j]</code>了。我们考虑，要满足<code>a[i] + a[j] &lt; a[k]</code>，我们不妨考虑反例，也就是<code>a[i] &lt;= a[k] - a[j]</code>。那么我们从<code>j + 1</code>开始遍历<code>k</code>，我们就可以得到满足以上条件的<code>a[i]</code>的上界。因此我们可以<code>le_n</code>来确定有多少个这样的<code>x &lt;= a[i]</code>。注意一下这里<code>a[k] - a[j]</code>是可能大于<code>a[j]</code>的，这样就不满足<code>a[i] &lt; a[j] &lt; a[k]</code>，因此我们查表的时候应当是取<code>min(a[k] - a[j], a[j])</code>的，否则会重复计算。</p>
<h1 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h1><p>简单题</p>
<h1 id="621-Task-Scheduler"><a href="#621-Task-Scheduler" class="headerlink" title="621. Task Scheduler"></a>621. Task Scheduler</h1><p>假设在<code>i</code>时刻执行了任务A，那么任务A下一次至少在<code>i + n + 1</code>时刻才能执行，问全部执行完的时间。<br>由于最多26个任务，我们统计一下对应的<code>Nd(task_name, count)</code>，然后每一次选取能够执行的、并且数量最多的任务来执行，否则这个时间就闲置。<br>有一个WA的点是要考虑到比较<code>Nd</code>涉及到与当前时间相关的全局变量<code>global_t</code>，所以每一次时间戳更新之后堆里面的排序都要重新调整。考虑到最多26个项目，所以我直接用了一个list，然后每次sort一下。然后开始疯狂T，这里我的<code>d = {i:tasks.count(i) for i in tasks}</code>写法又贡献了一点功劳，但修改之后还是只能过35/62个样例。<br>其实题解根本就不要考虑<code>global_t</code>，而是直接算。这和之前做过的一条有点像，就是就着数量最多的来。我们考虑假设有<code>most_cnt</code>个数量最多的任务，例如这里<code>most_cnt为2，设这两个任务为</code>A<code>和</code>B<code>，各有</code>most<code>个。那么根据上面的结论最优解是</code>ABXXXABXXXABXXXAB<code>，其中</code>X`首先用其他的字母填，不行了就得补空。</p>
<h1 id="662-Maximum-Width-of-Binary-Tree"><a href="#662-Maximum-Width-of-Binary-Tree" class="headerlink" title="662. Maximum Width of Binary Tree"></a>662. Maximum Width of Binary Tree</h1><p>BFS</p>
<h1 id="630-Course-Schedule-III"><a href="#630-Course-Schedule-III" class="headerlink" title="630. Course Schedule III"></a>630. Course Schedule III</h1><p>首先想到的是区间段问题，首先是不停地贪最早的结束时间，果断WA了一波。后来我意识到这个问题结束时间是由起始时间来动态调整的，我们不妨反方向，从结束时间开始贪，每次希望找开始时间最晚的课程。然后又WA了一波，Case是<code>[[9,14],[7,12],[1,11],[4,7]]</code>，我第一步贪的是<code>[1,11]</code>，但实际上<code>[9, 14]</code>更好。这个原因不在于区间段的问题的解法是错的，而是我们不能认为每个课程从结束时间就是最优的，对于<code>[1,11]</code>这样的课程，它的性能非常好，它固然能用来替换<code>[9,14]</code>以最右化右边界，但是更好的去处是到最前面。<br>这道题还和最长上升子序列有点像，不过最长上升子序列有个固定的取用顺序，但是这道题没有。<br>题解借助了优先队列。每一次我们的课程<code>X</code>不能满足deadline时，我们取出长度最长的课程<code>Y</code>，并用<code>X</code>替换<code>Y</code>。容易看出这一道题其实和开始时间无关，我们应该上完一门之后立即上下一门。</p>
<h1 id="632-Smallest-Range"><a href="#632-Smallest-Range" class="headerlink" title="632. Smallest Range"></a>632. Smallest Range</h1><h1 id="638-Shopping-Offers"><a href="#638-Shopping-Offers" class="headerlink" title="638. Shopping Offers"></a>638. Shopping Offers</h1><p>这个就<code>7**6</code>个状态，很好做hash，所以直接记搜。</p>
<h1 id="646-Maximum-Length-of-Pair-Chain"><a href="#646-Maximum-Length-of-Pair-Chain" class="headerlink" title="646. Maximum Length of Pair Chain"></a>646. Maximum Length of Pair Chain</h1><p>魔改LIS即可，可参考<a href="/2016/10/04/LISLCS/">我的文章</a>，我们把右端点放入<code>dp</code>里面，然后bisect找左端点。注意是<code>bisect.bisect_right(dp, s - 1)</code>不是<code>bisect.bisect_right(dp, s)</code>，这里WA了一发。</p>
<h1 id="647-Palindromic-Substrings"><a href="#647-Palindromic-Substrings" class="headerlink" title="647. Palindromic Substrings"></a>647. Palindromic Substrings</h1><p>计算一个字符串中有多少个回文串（看位置而不是值来区分异同）。这道题不复杂，因为$O(n^2)$就能解决了。就是按照Manacher那样扩充一下，然后枚举每一个中心<code>i</code>，向两边扩展直至找到对应最长的回文串，然后枚举下一个中心<code>i + 1</code>，容易看出这样的结果是依照对称中心而不会重复的。</p>
<h1 id="649-Dota2-Senate"><a href="#649-Dota2-Senate" class="headerlink" title="649. Dota2 Senate"></a>649. Dota2 Senate</h1><p>这道题就是模拟啊，只要前面健在的R的数量大于0，那么当前的D就滚蛋。注意可能会转好几圈，所以要mod一下。</p>
<h1 id="650-2-Keys-Keyboard"><a href="#650-2-Keys-Keyboard" class="headerlink" title="650. 2 Keys Keyboard"></a>650. 2 Keys Keyboard</h1><p>首先我们考虑一下最优策略，肯定是能复制就复制，因为这两种情况<code>A -&gt; AA</code>和<code>AA -&gt; AAAA</code>复不复制次数是相等的。<br>然后我们要注意到我们每次复制必须复制全部，所以这道题不是说我尽量减去2的$k$次方这种。事实上我们将<code>n</code>做因式分解，然后从小到大得进行复制黏贴即可。例如<code>30</code>可分为<code>[2, 3, 5]</code>，那么最优的算法就是先复制黏贴成两个<code>A</code>，然后变成3个<code>AA</code>，最后变成5个<code>AAAAAA</code>，对于因数<code>i</code>，一次这样的翻倍耗费<code>1 + (i - 1) = i</code>个操作。特别地，我们可以验证有多重因数的情况，例如<code>8</code>，也应该分成<code>2*2*2</code></p>
<h1 id="652-Find-Duplicate-Subtrees"><a href="#652-Find-Duplicate-Subtrees" class="headerlink" title="652. Find Duplicate Subtrees"></a>652. Find Duplicate Subtrees</h1><p>简单题，Hash一下子树即可</p>
<h1 id="654-Maximum-Binary-Tree"><a href="#654-Maximum-Binary-Tree" class="headerlink" title="654. Maximum Binary Tree"></a>654. Maximum Binary Tree</h1><p>这也太简单了吧，，，我还以为会有重复的元素然后两种树有个大小的比较呢</p>
<h1 id="657-Judge-Route-Circle"><a href="#657-Judge-Route-Circle" class="headerlink" title="657. Judge Route Circle"></a>657. Judge Route Circle</h1><p>弱智题</p>
<h1 id="658-Find-K-Closest-Elements"><a href="#658-Find-K-Closest-Elements" class="headerlink" title="658. Find K Closest Elements"></a>658. Find K Closest Elements</h1><p>给定一个<strong>有序数组</strong>，要求找到第<code>k</code>接近<code>x</code>的数，其中<code>x</code>不一定出现在数组里面。<br>初步想法是先二分搜索，然后分能够找到（一个或多个）<code>x</code>和不能找到<code>x</code>两种情况进行讨论。</p>
<h1 id="659-Split-Array-into-Consecutive-Subsequences"><a href="#659-Split-Array-into-Consecutive-Subsequences" class="headerlink" title="659. Split Array into Consecutive Subsequences"></a>659. Split Array into Consecutive Subsequences</h1><p>这道题我一开始就是用<code>tail[i]</code>维护所有以<code>i</code>结尾的序列。<code>tail[i]</code>是一个优先队列，里面存放着所有序列的长度，每一次我们遇到值<code>x</code>时就<code>tail[x] = tail[x-1].get()+1</code>，也就是增长<code>tail[x-1]</code>中最短的一项，结果T了。<br>用C++写就能AC。。。</p>
<h1 id="664-Strange-Printer"><a href="#664-Strange-Printer" class="headerlink" title="664. Strange Printer"></a>664. Strange Printer</h1><p>【这题Python目前还是T】<br>这道题蛮有意思的，我用Python的$O(n^3)$T了，但是C++的过了。首先不难想的是用<code>dp[fr][to]</code>来记录从<code>fr</code>到<code>to</code>的次数，然后我们从2开始枚举<code>step</code>，然后对每个位置的<code>fr</code>对应的<code>to = fr + step</code>计算<code>dp[fr][to]</code>。我们也容易知道<code>dp[i][i] = 1</code>，<code>dp[i][i + 1] = s[i] == s[i + 1] ? 1 : 2</code>。不过下面的递推方程就蛮考验的。我们考虑情况<code>a***a</code>其中<code>***</code>表示任意的字符，为了生成它，第一种方案是<code>a -&gt; a*** -&gt; a***a</code>，第二种方案是<code>aa...a -&gt; a***a</code>，其中<code>aa...a</code>表示与<code>***</code>长度相等的<code>a</code>，我们于是发现，只要两端相等，那么使用第二种方案总是最优的。</p>
<h1 id="668-Kth-Smallest-Number-in-Multiplication-Table"><a href="#668-Kth-Smallest-Number-in-Multiplication-Table" class="headerlink" title="668. Kth Smallest Number in Multiplication Table"></a>668. Kth Smallest Number in Multiplication Table</h1><p>这道题其实就是摆明了的一个二分答案。</p>
<h1 id="673-Number-of-Longest-Increasing-Subsequence"><a href="#673-Number-of-Longest-Increasing-Subsequence" class="headerlink" title="673. Number of Longest Increasing Subsequence"></a>673. Number of Longest Increasing Subsequence</h1><p>令<code>dp[i][j]</code>为以<code>i</code>结尾的长度为<code>j</code>的自增序列的个数，则<br>$$<br>dp[i][j] = sum(dp[k][j - 1]) for k in [0, i) if nums[k] &lt; nums[i]<br>$$<br>朴素的DP是$O(n^3)$的会T。<br>然后我们可以想到一个优化方案，也就是去掉<code>j</code>这个维度，这样可以做到$O(n^2)$，因为我们发现我们不会从<code>j - 2</code>去更新<code>j</code>。</p>
<h1 id="674-Longest-Continuous-Increasing-Subsequence"><a href="#674-Longest-Continuous-Increasing-Subsequence" class="headerlink" title="674. Longest Continuous Increasing Subsequence"></a>674. Longest Continuous Increasing Subsequence</h1><p>简单题</p>
<h1 id="684-Redundant-Connection"><a href="#684-Redundant-Connection" class="headerlink" title="684. Redundant Connection"></a>684. Redundant Connection</h1><p>无向图删除连通图上唯一多余的一条边，这个很简单，并查集维护一下即可。<br>注意我一开始想使用DFS三色法来解决，但实际上这个是不行的，因为我们要输出最后出现的边</p>
<h1 id="685-Redundant-Connection-II"><a href="#685-Redundant-Connection-II" class="headerlink" title="685. Redundant Connection II"></a>685. Redundant Connection II</h1><p>从无向图改成有向图就难了很多，这道题我们要根据是否成环（至多一个环）和是否有点入度为2来讨论。</p>
<h1 id="687-Longest-Univalue-Path"><a href="#687-Longest-Univalue-Path" class="headerlink" title="687. Longest Univalue Path"></a>687. Longest Univalue Path</h1><p>DFS一下咯</p>
<h1 id="688-Knight-Probability-in-Chessboard"><a href="#688-Knight-Probability-in-Chessboard" class="headerlink" title="688. Knight Probability in Chessboard"></a>688. Knight Probability in Chessboard</h1><p>感觉就是一个概率DP啊。求概率正推，求期望逆推。因此这道题我们可以正推，我们设<code>dp[k][i][j]</code>为第<code>k</code>步走到<code>(i, j)</code>的概率即可，特别地，<code>dp[0][r][c] = 1.0</code>。</p>
<h1 id="670-Maximum-Swap"><a href="#670-Maximum-Swap" class="headerlink" title="670. Maximum Swap"></a>670. Maximum Swap</h1><p>逆序排一下，然后贪心交换就行</p>
<h1 id="678-Valid-Parenthesis-String"><a href="#678-Valid-Parenthesis-String" class="headerlink" title="678. Valid Parenthesis String"></a>678. Valid Parenthesis String</h1><p>首先觉得就统计star的数量，然后当左括号不够的时候就用star补，最后看多下来的左括号能不能用star搞掉。结果WA在<code>*((*</code>。仔细分析，如果左括号不够，确实可以用star补，但并不是所有多出来的左括号都能用star补，如上面的错误，我们不能用左边的star去补。因此对于每一个剩下来的左括号我们都需要知道它右边有多少个star。于是我们可以维护一个<code>SL</code>数组表示<code>[0,i]</code>之间有多少个star（注意要减掉补左括号的），然后算出<code>dp</code>表示<code>[i,n-1]</code>有多少个star，然后把每一个还在栈里面的左括号弹出来，看看它的右边还有没有star可以当右括号用了。</p>
<h1 id="696-Count-Binary-Substrings"><a href="#696-Count-Binary-Substrings" class="headerlink" title="696. Count Binary Substrings"></a>696. Count Binary Substrings</h1><p>简单题</p>
<h1 id="698-Partition-to-K-Equal-Sum-Subsets"><a href="#698-Partition-to-K-Equal-Sum-Subsets" class="headerlink" title="698. Partition to K Equal Sum Subsets"></a>698. Partition to K Equal Sum Subsets</h1><p>状压DP了一波，从过3到了过7，并无卵用。后来发现是写挫了，剪枝应当在dfs递归调用前就做。</p>
<h1 id="699-Falling-Squares"><a href="#699-Falling-Squares" class="headerlink" title="699. Falling Squares"></a>699. Falling Squares</h1><p>离散化+线段树，和218很像。可以直接套218的模板，顺便还发现218里面Query有个地方写错了，幸亏那个是改线查点，所以没有WA。这道题需要注意的是Case 2那样两个正方形共边的情况，我们可以对于正方形<code>[l,r]</code>查看<code>[l+1,r-1]</code>的最大值，但是对于<code>l &gt;= r - 1</code>的情况，我们需要特殊处理下，看它能不能放在<code>[l-1,r+1]</code>上。这道题居然击败了96%。</p>
<h1 id="712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><a href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings" class="headerlink" title="712. Minimum ASCII Delete Sum for Two Strings"></a>712. Minimum ASCII Delete Sum for Two Strings</h1><p>字符串编辑距离的魔改版，挺简单的。注意<code>dp[i][0]</code>和<code>dp[0][j]</code>要作为边缘条件提前算好。</p>
<h1 id="713-Subarray-Product-Less-Than-K"><a href="#713-Subarray-Product-Less-Than-K" class="headerlink" title="713. Subarray Product Less Than K"></a>713. Subarray Product Less Than K</h1><p>很基本的双指针了，注意我们动态维护<code>prod</code>而不是预先计算，否则会T，而且你做那么多乘法再除也是等着溢出吧</p>
<h1 id="714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><a href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee" class="headerlink" title="714. Best Time to Buy and Sell Stock with Transaction Fee"></a>714. Best Time to Buy and Sell Stock with Transaction Fee</h1><p>现在买卖股票需要缴手续费了。相比Best Time to Buy and Sell Stock II，我们需要知道并不是交易越多越好了，例如<code>[1,3,7,5,10,3], 3</code>。一开始我打算生搬硬套Best Time to Buy and Sell Stock IV的办法，然后T了。<br>然后发现这道题和交易次数没关系，所以将内层循环去掉了，就过了。</p>
<h1 id="718-Maximum-Length-of-Repeated-Subarray"><a href="#718-Maximum-Length-of-Repeated-Subarray" class="headerlink" title="718. Maximum Length of Repeated Subarray"></a>718. Maximum Length of Repeated Subarray</h1><p>一道类似于最长公共子串的题，不过更新规则略有不一样，只有<code>A[i - 1] == B[j - 1]</code>时才去做更新。居然WA了两次，sad。</p>
<h1 id="719-Find-K-th-Smallest-Pair-Distance"><a href="#719-Find-K-th-Smallest-Pair-Distance" class="headerlink" title="719. Find K-th Smallest Pair Distance"></a>719. Find K-th Smallest Pair Distance</h1><p>这个并不是最近点对，因为它是一维的。这道题解法挺多的，我建议最后都看一下题解。主要思路是二分答案<code>gap</code>，然后有两种方法来算有多少个点的距离小于等于<code>gap</code>。<br>第一种方法我们维护<code>lt_cnt[v]</code>表示小于等于<code>v</code>的点的数量，那么我们就可以用<code>lt_cnt[nums[i] + gap] - lt_cnt[nums[i]]</code>来计算对于点<code>i</code>有多少个点<code>j</code>和自己的距离小于等于<code>gap</code>的。然而这是错的！因为我们还要考虑到<code>i</code>重复值的情况。因此我们需要用<code>strk[i]</code>来维护下连续的<code>i</code>的个数。我们注意下这种方法彻底避免了其他的办法陷入重复统计的困扰，因为它值使用一个指针<code>i</code>。<br>第二种方法是使用滑动窗口来直接算，这个方法需要小心避免重复计算的情况。</p>
<h1 id="730-Count-Different-Palindromic-Subsequences"><a href="#730-Count-Different-Palindromic-Subsequences" class="headerlink" title="730. Count Different Palindromic Subsequences"></a>730. Count Different Palindromic Subsequences</h1><p>一开始想到516题，但这道题需要去重，如样例1所示。</p>
<h1 id="729-My-Calendar-I"><a href="#729-My-Calendar-I" class="headerlink" title="729. My Calendar I"></a>729. My Calendar I</h1><p>首先是看到732，然后回来看得这一条。这一条一看就是个线段树，但是这条比较蛋疼的是要离散化，而且是在线的。这里借鉴了732 Discuss里面的做法，用指针来维护，这样就不要<code>4N</code>的开销了。<br>这里注意在query时如果没有子节点需要返回root节点的值，我们可以查看样例<code>\{\{6,14},{0,7\}\}</code>，因为在update的时候，如果一个节点下面的结果是一致的（类似决策树里面，是“纯节点”），那么我们会剪枝掉下面的子树，<strong>我们需要将这种情况和因为update时没有覆盖到对应区间所以直接没有这个子树的情况区分开来</strong>。<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(!root-&gt;</span><span class="function"><span class="title">left</span> &amp;&amp; !root-&gt;</span>right)&#123;</span><br><span class="line">    <span class="comment">// IMPORTANT</span></span><br><span class="line">    <span class="function"><span class="title">ans</span> = root-&gt;</span><span class="keyword">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="732-My-Calendar-III"><a href="#732-My-Calendar-III" class="headerlink" title="732. My Calendar III"></a>732. My Calendar III</h1><p>这一题是对一段区间的值<code>+1</code>，然后查看一个区间中的最大值。这属于查线改线的，所以需要lazy。不过根据样例，上面的思路还是有问题的，如下图所示，简单得求最大值的算法，我们得到的结果是2，而这个区间实际上和两个独立区间重合，所以结果应该是3，这种错误的解法在<strong>leetcode.732.1.cpp</strong>。</p>
<pre><code>|-------|         |--------|
      |--------------|
</code></pre><h1 id="735-Asteroid-Collision"><a href="#735-Asteroid-Collision" class="headerlink" title="735. Asteroid Collision"></a>735. Asteroid Collision</h1><p>从后往前扫一遍即可</p>
<h1 id="738-Monotone-Increasing-Digits"><a href="#738-Monotone-Increasing-Digits" class="headerlink" title="738. Monotone Increasing Digits"></a>738. Monotone Increasing Digits</h1><p>找到小于等于n的单调递增数（不一定要是严格地）。这一条就是贪，一直按着上界来，直到遇到下降走不下去，例如<code>1332</code>会死在最后一个2上。这时候我们开始回退到<code>132-&gt;122</code>，最后在后面补全9。</p>
<h1 id="739-Daily-Temperatures"><a href="#739-Daily-Temperatures" class="headerlink" title="739. Daily Temperatures"></a>739. Daily Temperatures</h1><p>直方图那条吧，水题</p>
<h1 id="740-Delete-and-Earn"><a href="#740-Delete-and-Earn" class="headerlink" title="740. Delete and Earn"></a>740. Delete and Earn</h1><p>简单DP</p>
<h1 id="743-Network-Delay-Time"><a href="#743-Network-Delay-Time" class="headerlink" title="743. Network Delay Time"></a>743. Network Delay Time</h1><p>看题目就猜到了这题是干什么的。裸dijkstra，注意是有向图。。。</p>
<h1 id="747-Largest-Number-At-Least-Twice-of-Others"><a href="#747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="747. Largest Number At Least Twice of Others"></a>747. Largest Number At Least Twice of Others</h1><p>简单题</p>
<h1 id="753-Cracking-the-Safe"><a href="#753-Cracking-the-Safe" class="headerlink" title="753. Cracking the Safe"></a>753. Cracking the Safe</h1><p>保险柜的密码是由<code>k</code>个字母组成的长度为<code>n</code>的串。问密码多长能覆盖所有情况。<br>其实这道题是欧拉回路。我们首先乐观地想是不是可以每一次复用前面的<code>n - 1</code>的长度，我们将证明这是可行的。将<code>k ** n</code>的每一种情况视为图上的一个节点，而每一次添加的字母看做一条边，那么我们实际上就是要找一条欧拉回路。例如</p>
<pre><code>00 -&gt; 01 -&gt; 11 -&gt; 10 -&gt; 00
       |    |
       &lt;----&gt;
</code></pre><p>我们知道有向图欧拉回路的存在条件是所有节点出度等于入度，但是我们如何找到这个回路呢？我们这里使用套圈法，其基础是一个DFS<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(prev_state)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> xrange(k - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>)<span class="symbol">:</span></span><br><span class="line">        next_state = ...</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (next_state <span class="keyword">in</span> <span class="keyword">self</span>.visp) <span class="keyword">and</span> <span class="keyword">not</span> next_state == <span class="symbol">prev_state:</span></span><br><span class="line">            <span class="keyword">self</span>.visp <span class="params">|= set([next_state])</span></span><br><span class="line"><span class="params">            check_end()</span></span><br><span class="line"><span class="params">            update_path(next_state)</span></span><br><span class="line"><span class="params">            dfs(next_state)</span></span><br><span class="line"><span class="params">            check_end()</span></span><br><span class="line"><span class="params">            </span></span><br><span class="line"><span class="params"><span class="keyword">self</span>.visp = set([start_state])</span></span><br><span class="line"><span class="params">ans = dfs(start_state)</span></span><br></pre></td></tr></table></figure></p>
<p>我们注意到，DFS中首先会找一个环，但这个环不一定就通过所有的节点，这时候我们就从上一次分叉的地方继续遍历出一个环，然后我们可以连接这两个环组成一个更大的环，如此循环往复即可。DFS的栈式递归优雅地实现了这一点。我们应当注意的是遍历欧拉回路中的<strong>点是可以访问多次的</strong>（等于度数），但<strong>边</strong>只能访问一次。不过在上面的模板代码里面，我们却用<code>visp</code>数组来维护点（其实在我的上一次提交中额外使用了<code>vis</code>数组来为边，但后来发现这是没必要的），因为我们每个点虽然有很多出度和入度，但在DFS搜索序列中他们只会出现一次，我们用<code>for</code>循环来枚举节点<code>p</code>所有未访问的出边，然后这些出边会各自形成环回到节点<code>p</code>。</p>
<h1 id="757-Set-Intersection-Size-At-Least-Two"><a href="#757-Set-Intersection-Size-At-Least-Two" class="headerlink" title="757. Set Intersection Size At Least Two"></a>757. Set Intersection Size At Least Two</h1><p>首先我们可以用函数<code>inter</code>求出两个interval的交集。如果这两个区间的交集容量等于1或2，那么这个交集一定出现在答案里面。如果交集容量等于0，那么这两个区间就需要和别的区间试试运气，直到最后将自己全部加进去。容易看出，上两种情况是确定性的。但是考虑容量大于2的情况，交集的<strong>一部分</strong>一定算在答案里面，问题是哪一部分呢？<br>这个问题困扰了我一会，后来通过查看题解发现我们可以考虑不相交和交一个的情况，而不是容量大于2的情况。对区间排序，然后对于不相交的情况就贪心，取最大的两个加入集合，这样加入集合的两个元素最可能能够被后面的覆盖到，从而不浪费。注意我们sort的时候要按照右端点sort，这是显然的，因为我们的贪心策略是希望尽可能覆盖到右边。<br>下面我们从左到右遍历，设置<code>already</code>数组表示目前已经得到的集合。对于新的区间<code>[s, e]</code>，我们尝试将其与<code>already</code>中的所有项匹配。注意这里不能默认匹配<code>already[-1]</code>，因为可能出现<code>[5, 9]</code>匹配<code>[[6,6], [8,8]]</code>的情况。我们使用<code>flag</code>记录<code>[s, e]</code>中总共有多少个数字已经被覆盖到了，显然当<code>flag</code>大于等于2时我们就可以直接结束。每一次计算<code>[s, e]</code>和<code>already</code>中元素相交<code>[s1, e2]</code>的时候，我们根据交集<code>part</code>大小更新<code>flag</code>。特别地，当交集大小是1时，我们需要记录下<code>[s1, e1]</code>，我们不能在这里立即处理，原因同样是上面的这种情况。<br>下面当我们遍历完后，检查<code>flag</code>，对于等于0和大于等于2的情况很简单。对于等于1的情况需要特别考虑。我们需要看两种特殊情况<code>match [2,6] in [[0,1], [4,4]]</code>和<code>match [16,18] in [[18,18]]</code>。我们注意对于后一种情况我们不能向右扩展右边界，而只能扩展左边界。</p>
<h1 id="761-Special-Binary-String"><a href="#761-Special-Binary-String" class="headerlink" title="761. Special Binary String"></a>761. Special Binary String</h1><p>【WA】<br>这题真恶心，建议不要做。</p>
<h1 id="763-Partition-Labels"><a href="#763-Partition-Labels" class="headerlink" title="763. Partition Labels"></a>763. Partition Labels</h1><p>这道题很简单，我们就不停地扩大右边界，直到我们目前的集合实现distinct。</p>
<h1 id="765-Couples-Holding-Hands"><a href="#765-Couples-Holding-Hands" class="headerlink" title="765. Couples Holding Hands"></a>765. Couples Holding Hands</h1><p>这道题其实可以贪，还有一些并查集的做法，是一道好题目</p>
<h1 id="766-Toeplitz-Matrix"><a href="#766-Toeplitz-Matrix" class="headerlink" title="766. Toeplitz Matrix"></a>766. Toeplitz Matrix</h1><p>简单题，Pick One太差劲了。。。</p>
<h1 id="767-Reorganize-String"><a href="#767-Reorganize-String" class="headerlink" title="767. Reorganize String"></a>767. Reorganize String</h1><p>一开始觉得直接按item出现次数sort然后双指针头尾就行了，后来发现我们应当先尽量用item个数多的。然后就用一个方向的双指针还是不行，这是因为可能前面item的用掉一些次数之后就不是最多的了，所以我们应该用优先队列来动态维护。</p>
<h1 id="768-Max-Chunks-To-Make-Sorted-II"><a href="#768-Max-Chunks-To-Make-Sorted-II" class="headerlink" title="768. Max Chunks To Make Sorted II"></a>768. Max Chunks To Make Sorted II</h1><p>题目是将一个int数组切成若干块，并且对每个块进行排序，我们将排序好的块再次按顺序连接起来，应该能够得到一个有序的数组。那么我们最多能切成几块呢？这种序列的题目，我们往往能够联想到直方图问题和逆序对问题。<br>这道题比769要复杂一些，首先<code>arr[i]</code>的值域变到了<code>10**8</code>，我们不太方便用树状数组（当然我们可以离散化）来做了。其次，增加了一条限制是可能出现重复项。<br>我一开始的想法是sort一下数组变成<code>lst</code>，这时候<code>lst[i]</code>实际上就是<code>lst[0..i]</code>上的最大值，那么当<code>lst[i]</code>和<code>arr[i]</code>相等时可以认为<code>i</code>前面可以通过一次sort来变得有序了。但这个假设实际上是错的，我们考虑<code>[1,1,0,0,1]</code>这种情况，由于重复元素的出现，我们<strong>无法通过这个条件</strong>来判断<code>arr[i]</code>应当位于已排序数组的哪一个位置。即使我们维护一个<code>mx</code>表示<code>arr[0..i]</code>的最大值，然后要求<code>arr[i] == mx == lst[i]</code>也不行，可以考虑<code>[0,3,0,3,2]</code>的情况，下面错误的代码会输出3而不是正确答案2，这同样是重复元素的锅。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxChunksToSortedWA</span><span class="params">(self, arr)</span>:</span></span><br><span class="line">    n = len(arr)</span><br><span class="line">    inf = <span class="number">5555555555</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    lst = sorted(arr)</span><br><span class="line"></span><br><span class="line">    mx = -inf</span><br><span class="line">    <span class="keyword">for</span> i, x <span class="keyword">in</span> enumerate(arr):</span><br><span class="line">        mx = max(x, mx)</span><br><span class="line">        y = lst[i]</span><br><span class="line">        <span class="keyword">if</span> mx == x:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>然后这道题解法出奇的简单，我们维护<code>lst</code>和<code>arr</code>的前缀和，然后统计他们在对应位置相等的数量即可。<br>【后面还有线性解法】我们维护<code>i</code>位置遍历到的最大值<code>left[i]</code>和未遍历的最小值<code>right[i]</code>。我们知道有序数列<code>lst[i]</code>的左边肯定没有比他大的数，右边没有比他小的数（但可以相等），也就是<code>right[i] &gt;= lst[i] &gt;= left[i]</code>。对于乱序数组<code>arr[i]</code>，我们希望将到<code>i</code>的部分割出来进行排序，这样肯定是安全的，因为<code>i</code>右边不存在比<code>left[i]</code>要大的数了。也就是需要<code>max(left[i], arr[i]) &lt;= right[i]</code>，注意我们这里不需要<code>right[i] &gt;= arr[i] &gt;= left[i]</code>这么强的条件，因为可以通过对<code>(?, i]</code>区间的sort来满足<code>arr[i] &gt;= left[i]</code>这个条件。<br>【此外还有一种单调栈的解法】<a href="https://www.cnblogs.com/grandyang/p/8887985.html" target="_blank" rel="noopener">单调栈</a>具有线性复杂度，并且一趟遍历，也就是每个元素只会一次进栈。通过单调递增栈可以找到左起第一个比当前元素小的元素，也就是当前栈顶。如果当前元素比当前栈顶小，我们就一直进行出栈操作。那么我们现在维护一个单调递增栈，他其中的元素数目表示遍历到当前数字前，可以拆分成块的数目。因为一旦出现一个数使得这个栈不单调了，我们必然要进行一次排序。</p>
<p>注，<a href="https://www.cnblogs.com/grandyang/p/8850299.html" target="_blank" rel="noopener">文章</a>中列出了这道题的四种解法，还是很有趣的一条题目。</p>
<h1 id="769-Max-Chunks-To-Make-Sorted"><a href="#769-Max-Chunks-To-Make-Sorted" class="headerlink" title="769. Max Chunks To Make Sorted"></a>769. Max Chunks To Make Sorted</h1><p>首先题意理解一下，不是reverse而是sort。这道题就是逆序对。对于位置<code>i</code>，查看它之前出现了多少个大于等于<code>i</code>的数字，只要有那么这个数字就不能分割。<br>注意使用树状数组的时候必须从1开始，所以要对<code>arr</code>的值统一右移一位。</p>
<h1 id="732-My-Calendar-III-1"><a href="#732-My-Calendar-III-1" class="headerlink" title="732. My Calendar III"></a>732. My Calendar III</h1><h1 id="733-Flood-Fill"><a href="#733-Flood-Fill" class="headerlink" title="733. Flood Fill"></a>733. Flood Fill</h1><p>简单题</p>
<h1 id="775-Global-and-Local-Inversions"><a href="#775-Global-and-Local-Inversions" class="headerlink" title="775. Global and Local Inversions"></a>775. Global and Local Inversions</h1><p>这道题就是数学题，要求<code>A[i] &lt; A[j] forall j &gt; i + 1</code>，我们可以反过来计算<code>A[i] &gt;= A[j] forall j &gt; i + 1</code>即是否存在<code>A[i] &gt;= A[j] forall i &lt; j - 1</code>即可。</p>
<h1 id="777-Swap-Adjacent-in-LR-String"><a href="#777-Swap-Adjacent-in-LR-String" class="headerlink" title="777. Swap Adjacent in LR String"></a>777. Swap Adjacent in LR String</h1><p>任意次数反转某个区间，问能够得到目标串。</p>
<h1 id="778-Swim-in-Rising-Water"><a href="#778-Swim-in-Rising-Water" class="headerlink" title="778. Swim in Rising Water"></a>778. Swim in Rising Water</h1><p>其实就是要求从<code>(0, 0)</code>到<code>(n - 1, n - 1)</code>路径上的最大值的最小值<br>其实这道题又是可以二分答案糊弄过去的，但我们是体面人。。。所以研究一下搜索的解法。<br>这道题我从前一直尝试用记搜来做，但一直失败。后来从题解上看到一个简化思路，为了尽快游泳，我们肯定尽量从高度低的地方走，因为水会尽快漫过去，所以我们这次做BFS，然后维护一个当前路径上的最大值即可。</p>
<h1 id="779-K-th-Symbol-in-Grammar"><a href="#779-K-th-Symbol-in-Grammar" class="headerlink" title="779. K-th Symbol in Grammar"></a>779. K-th Symbol in Grammar</h1><p>一开始以为是个DP，后来发现这样不就直接生成答案了吗，而且这个依赖状态也有限，所以直接DFS了。这道题就是想第<code>n</code>行怎么从第<code>n-1</code>行过来，然后就很简单了。</p>
<h1 id="780-Reaching-Points"><a href="#780-Reaching-Points" class="headerlink" title="780. Reaching Points"></a>780. Reaching Points</h1><p>按照<code>(x, x+y)</code>或<code>(x+y, y)</code>的规则走路，问是否能够从<code>(sx, sy)</code>走到<code>(tx, ty)</code>。这道题挺有意思的，让我想到LCM Walk这道题。LCM这道题是按照<code>LCM(x,y)</code>来更新的，实际上是一道数论题。这道题更简单，肯定也是用数学做，当然你爱用矩阵搞事情也行、、、<br>这一道题的简单之处在于我们不需要证明从终点往起点走的唯一性，因为数都是大于0的。这里注意一个细节，为了不t，我们会批量减，但是我们要注意减去的<code>tx</code>和<code>ty</code>最少要是1个，最多不能使得到的差小于<code>sx</code>和<code>sy</code>，否则会丢失结果。</p>
<h1 id="781-Rabbits-in-Forest"><a href="#781-Rabbits-in-Forest" class="headerlink" title="781. Rabbits in Forest"></a>781. Rabbits in Forest</h1><p>排序的话要<code>O(nlgn)</code>，但是可以由于值域不大（1000），所以可以直接用桶。我们知道如果有<code>dp[i]</code>个人说和自己相同颜色的还有<code>i</code>个人，那说明有<code>i + 1</code>人有相同的颜色。当<code>dp[i]</code>大于<code>i</code>时，那么就说明有这<code>dp[i]</code>个人至少有$\lceil dp[i]/i \rceil$组不同的颜色。</p>
<h1 id="785-Is-Graph-Bipartite"><a href="#785-Is-Graph-Bipartite" class="headerlink" title="785. Is Graph Bipartite?"></a>785. Is Graph Bipartite?</h1><p>判断是否是二分图。我们可以联想到匈牙利方法是怎么找增广路径的。因此我们直接一个DFS，然后在<code>vis</code>数组上进行标记，对于节点<code>pos</code>，设其<code>vis</code>为<code>1</code>，表示在二分图的一边，那么它能访问到的所有<code>nxt</code>的<code>vis</code>一定是<code>-1</code>，表示在二分图的另一边。那么一旦我们找到一条边其<code>vis</code>与<code>nxt</code>相同，那么就不可能是二分图了。<br>注意二分图可以是不连通的，所以我们应当DFS完毕。在这里WA了次。</p>
<h1 id="786-K-th-Smallest-Prime-Fraction"><a href="#786-K-th-Smallest-Prime-Fraction" class="headerlink" title="786. K-th Smallest Prime Fraction"></a>786. K-th Smallest Prime Fraction</h1><p>【本题Python TLE了】<br>这道题其实蛮好的，主要有用堆和二分答案。其中用堆的我Python是TLE，C++倒是能过。不过用了vis数组，其实可以不用vis数组，只添加<code>(p, q - 1)</code>。我们考虑一下<code>[1, 2, 3, 4]</code>的情况，我们首先添加<code>(1,4), (2,4), (3,4)</code>，然后我们出<code>(1,4)</code>，只添加<code>(1,3)</code>，那么<code>(2,3)</code>在哪里添加呢？因为<code>(2,3)</code>肯定在<code>(2,4)</code>后面，因为<code>2/3</code>比<code>2/4</code>大。</p>
<h1 id="790-Domino-and-Tromino-Tiling"><a href="#790-Domino-and-Tromino-Tiling" class="headerlink" title="790. Domino and Tromino Tiling"></a>790. Domino and Tromino Tiling</h1><p>问用2x1和短L型方块铺满2xN的板子有几种方案。这道题是一个有趣的动态规划，我们可以设<code>dp[i][0]</code>为刚好填满第<code>i</code>个槽的方案数，设<code>dp[i][1]</code>为填满第<code>i</code>个槽但是在第<code>i + 1</code>个槽鼓出来的方案数。我们可以对五种情况进行讨论，具体可以见我代码里面的注释。在写的时候WA了几次，都是方案没有考虑周全。</p>
<h1 id="795-Number-of-Subarrays-with-Bounded-Maximum"><a href="#795-Number-of-Subarrays-with-Bounded-Maximum" class="headerlink" title="795. Number of Subarrays with Bounded Maximum"></a>795. Number of Subarrays with Bounded Maximum</h1><p>这道题蛮有意思的，我们还是用了在题目【】中防止重复统计区间的办法，也就是对于<code>i</code>，我们统计以<code>i</code>为结尾的合法区间数。接下来分三种情况讨论即可，我WA了很多次，都是因为没有考虑周全所致。</p>
<h1 id="796-Rotate-String"><a href="#796-Rotate-String" class="headerlink" title="796. Rotate String"></a>796. Rotate String</h1><p>复制一份即可，简单题</p>
<h1 id="797-All-Paths-From-Source-to-Target"><a href="#797-All-Paths-From-Source-to-Target" class="headerlink" title="797. All Paths From Source to Target"></a>797. All Paths From Source to Target</h1><p>简单的dfs</p>
<h1 id="799-Champagne-Tower"><a href="#799-Champagne-Tower" class="headerlink" title="799. Champagne Tower"></a>799. Champagne Tower</h1><p>这个倒酒的题目我是在哪次ICPC热身赛上做过的，当时好像直接大模拟了。<br>这道题其实也是模拟，我们第一步是对每一层，将每一个酒杯应得的酒（由上一层计算而来）冻成棍子全部塞进去，然后我们让棍子融化，让多出来的酒流到下面的1/2个杯子里面。</p>
<h1 id="801-Minimum-Swaps-To-Make-Sequences-Increasing"><a href="#801-Minimum-Swaps-To-Make-Sequences-Increasing" class="headerlink" title="801. Minimum Swaps To Make Sequences Increasing"></a>801. Minimum Swaps To Make Sequences Increasing</h1><p>咋一看因为是逆序对。不过这个是在两个数列对应位置之间进行交换。这个直接xjb动态规划了，按照套路设<code>S</code>和<code>NS</code>两个数组表示是否交换<code>i</code>位置，然后根据是否交换<code>i - 1</code>地推即可。</p>
<h1 id="802-Find-Eventual-Safe-States"><a href="#802-Find-Eventual-Safe-States" class="headerlink" title="802. Find Eventual Safe States"></a>802. Find Eventual Safe States</h1><p>这道题就是DFS，黑白灰染色法，根据前向边后向边和横边讨论。这道题WA了两次，第一次是将横边和后向边一起处理了，第二次是忘了<code>flag |=</code>，写成了<code>flag =</code></p>
<h1 id="803-Bricks-Falling-When-Hit"><a href="#803-Bricks-Falling-When-Hit" class="headerlink" title="803. Bricks Falling When Hit"></a>803. Bricks Falling When Hit</h1><p>很有趣的问题，<code>n</code>行<code>m</code>列的墙上有砖头靠四边和天花板连在一起。现在有Q次查询，要求输出敲掉<code>(i,j)</code>之后会掉落多少块砖头。<br>首先莽了一个DFS的，也就是直接模拟，对于每一个格点，DFS它能不能到天花板。T了之后优化了一下，从每个天花板DFS看能不能到达，然后check所有不能到达的节点，还是T。<br>后来想到可以反过来考虑这个过程。<br>是机械的时候WA翻了。首先我们敲掉的那个砖块不算掉落的，但是我们在处理的时候是将<code>(hx, hy)</code>周围的所有点进行merge的，我们在一些时候不能直接进行<code>d -= 1</code>，例如当<code>(hx, hy)</code>在天花板上，或者已经连到了天花板上，那我们merge的时候实际上就没有算上<code>(hx, hy)</code>，自然也没有必要减掉了。锤子可以空敲，所以我们不能凭空往上面加东西。WA了一次是因为DFS时候没有初始化<code>fa</code>。WA了一次是因为并查集<code>merge</code>的时候，没有判断<code>pfa == qfa</code>的情况。最后一次WA是在第15个点上，调试了半天，把<code>hits</code>简化到了<code>[[1,4],[1,6],[0,2],[0,5],[1,5]]</code>。原来错误是我们要考虑天花板上的砖块被敲掉的情况，例如<code>[[1,0,1],[1,1,1]], [[0,0],[0,2],[1,1]]</code>这个Case，如果不经过处理就会WA。我当时是选择在添加这个天花板上的<code>(hx, hy)</code>时DFS一下，构建以<code>(hx, hy)</code>为基元的并查集。但在这第15个点上就发现这个方案不行。因为这个Case中我们先添加了<code>(1,5)</code>，然后添加了<code>(0,5)</code>，这时候DFS一下就会直接将<code>(1,5)</code>添加到<code>(0,5)</code>的集合中了。</p>
<h1 id="805-Split-Array-With-Same-Average"><a href="#805-Split-Array-With-Same-Average" class="headerlink" title="805. Split Array With Same Average"></a>805. Split Array With Same Average</h1><p>如果是和相等而不是平均数相等，那就是一道背包问题，因此我们的思路一是能不能转化为<code>len(A) / 2</code>个背包问题来做。于是我们的问题变为是否存在有<strong>恰好</strong><code>m</code>个数的和加起来为<code>need</code>。这个实际上就是01背包，然后在dp数组上dfs找是否有一条到<code>(0, 0)</code>长度为<code>m</code>的路径，可参考<a href="https://algorithms.tutorialhorizon.com/dynamic-programming-subset-sum-problem/" target="_blank" rel="noopener">这篇文章的track方法</a>。</p>
<p>此外，本题还有其他解法，如<a href="https://xingxingpark.com/Leetcode-805-Split-Array-With-Same-Average/" target="_blank" rel="noopener">https://xingxingpark.com/Leetcode-805-Split-Array-With-Same-Average/</a></p>
<h1 id="807-Max-Increase-to-Keep-City-Skyline"><a href="#807-Max-Increase-to-Keep-City-Skyline" class="headerlink" title="807. Max Increase to Keep City Skyline"></a>807. Max Increase to Keep City Skyline</h1><p>这个很简单，维护一下行列的最大值</p>
<h1 id="808-Soup-Servings"><a href="#808-Soup-Servings" class="headerlink" title="808. Soup Servings"></a>808. Soup Servings</h1><p>记搜呗，概率正推，期望逆推。注意虽然我们数组开不了那么大，但是我们可以默认在N很大时概率趋于1。这道题需要按照25离散化一下，不然会MLE</p>
<h1 id="810-Chalkboard-XOR-Game"><a href="#810-Chalkboard-XOR-Game" class="headerlink" title="810. Chalkboard XOR Game"></a>810. Chalkboard XOR Game</h1><p>组合博弈咯。。。我们知道必败态P的下一步一定是非必败态，而非必败态存在下一步是必败态N。我们研究最简单的必败态<code>1</code>，非必败态<code>1,1</code>，因此先手者只要保证自己手里的数字都是成对的就行了。当然如果果然这样那么先手者直接赢了，因为XOR下来就是0。当然肯定有成单的，我们只要保证成单的也是偶数个就行了。<br>然后发现这道题还要特判一下<code>[1,2,3]</code>这种一开始XOR下来就是0的。因为我们要考虑<strong>成单的数异或起来是不是为0</strong>，因为我们担心像前面多个数异或起来为0的情况，例如<code>1^2^3==0</code>这样会不会影响结果。我们先考虑成单的是偶数，但是Alice先手会输，也就是说当Alice取了数<code>x</code>之后，剩下的XOR起来为0了，例如<code>[1,2,3,4]</code>，取了4，剩下的为0，因此我们肯定不能取这个4，而应该取那XOR起来为0的奇数个数中的一个数，我们可以将这奇数个数的异或等价为两个相同的数<code>a ^ a == 0</code>，因此我们取走任意一个<code>a != x</code>，就会给对手留下奇数个成单的数，并且XOR的值非0这样的情况，这肯定是对方的一个必败态。<br>下面我们需要注意在成单的是奇数个的情况下我们是可能赢的，当XOR起来为0的情况，这个只可能发生在一开始，因为往后我们不可能给对方留下这个状态，除非我们自己是必输的。</p>
<h1 id="813-Largest-Sum-of-Averages"><a href="#813-Largest-Sum-of-Averages" class="headerlink" title="813. Largest Sum of Averages"></a>813. Largest Sum of Averages</h1><p>这道题一开始是想的一个淳朴的$O(n^2)$的DP，即设<code>dp[i][k]</code>表示到第<code>i</code>个数split了<code>k</code>次的最大值。那么我们在<code>i</code>处有两个策略，一个是跟之前的队，另一个是在这里split下来自立门户。由此写出一个WA的算法，对<code>[2561,9087,398,8137,7838,7669,8731,2460,1166,619], 3</code>会WA。<br>正解是需要$O(n^3)$，我们需要额外的一个<code>j</code>表示我们的区间是<code>[j+1, i]</code>。这是因为我们虽然跟之前的队，但是此时之前最优的队不一定到这里就是最优的了，这题实际上有点类似于410这条。</p>
<h1 id="814-Binary-Tree-Pruning"><a href="#814-Binary-Tree-Pruning" class="headerlink" title="814. Binary Tree Pruning"></a>814. Binary Tree Pruning</h1><p>在微软的面试题，注意要去掉没有儿子的节点</p>
<h1 id="815-Bus-Routes"><a href="#815-Bus-Routes" class="headerlink" title="815. Bus Routes"></a>815. Bus Routes</h1><p>这道题的关键在于要对Stop和Routine同时建立vis数组维护。</p>
<h1 id="818-Race-Car"><a href="#818-Race-Car" class="headerlink" title="818. Race Car"></a>818. Race Car</h1><p>首先我们的翻转方向一定要尽可能在前面，因为$2^i - 2^{i+1}$是小于0的，而$2^i - 2^{i+1} + 2^{i+2}$是超过$2^{i+1}$的，因此如果我们追求在$2^i$和$2^{i+1}$之间的值那么我们递归的深度是有限的。然后看清题目我发现R会重置速度绝对值为1，这道题就有点类似于650这种题目了，但我们同样要知道最多加速的次数是有着固定的上界，也就是我们最多走到$S = 1 + 2 + … + 2^i \ge target$，不会再往后面加速了。现在我们得到DP的思路，也即是我们在这个$2^0$到$2^i$的加速区间内我们可以在任何时候选择R然后重新来过。一开始我分为两种情况，第一种我们先走过<code>target</code>，然后R回来变成子问题。另一种我们在中间任意的时刻连R两次，将速度减少为1，我们稍后看到第二种情况是不全面的，因为我们可以以退为进一段，而不需要连R。<br>一个难点是<code>target=5</code>的情况，它的结果并不是我之前算的8而是7，也就是<code>AARARAA</code>，究其原因是因为我们从<code>3</code>到<code>5</code>时不能直接套用<code>dp[2]</code>，因为我们在3处的前进方向不同了。</p>
<h1 id="823-Binary-Trees-With-Factors"><a href="#823-Binary-Trees-With-Factors" class="headerlink" title="823. Binary Trees With Factors"></a>823. Binary Trees With Factors</h1><p>这道题要求用数组<code>A</code>中的数组成二叉树，要求二叉树的父亲等于两个儿子的乘积，问有几种方案。这题显然就是dp了，我们首先sort一下，然后用<code>dp[i]</code>表示第<code>i</code>个节点为根的二叉树有多少种排布方案。我们只需要枚举<code>[0, i)</code>区域内节点作为lson，然后查看是否存在rson即可。</p>
<h1 id="826-Most-Profit-Assigning-Work"><a href="#826-Most-Profit-Assigning-Work" class="headerlink" title="826. Most Profit Assigning Work"></a>826. Most Profit Assigning Work</h1><p>这道题就是贪，因为任务可以重复完成，所以每个人做能力范围内利润最高的工作</p>
<h1 id="827-Making-A-Large-Island"><a href="#827-Making-A-Large-Island" class="headerlink" title="827. Making A Large Island"></a>827. Making A Large Island</h1><p>用0和1表示的矩阵，1是岛屿，问最多将一个0改成1，能形成的最大的岛屿的面积是多少。<br>这道题就是先找出所有的连通分量并染色，记录每个连通分量的大小。然后对于所有的0，尝试改为1，并且查看这次变动能否合并上/下/左/右四个方向中的两个<strong>或多个</strong>（WA了一次是因为漏掉了这个）连通分量。此外我们还要判断这两个连通分量是否已经是连通的，例如下面的情况，括号处的0实际上并没连接上下两个连通分量，因为他们本来就是一体的。<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>  <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>  (<span class="number">0</span>)</span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<h1 id="828-Unique-Letter-String"><a href="#828-Unique-Letter-String" class="headerlink" title="828. Unique Letter String"></a>828. Unique Letter String</h1><p>看起来是个双指针维护，然后我们同样是按照<code>r</code>坐标来计数以防止错漏。我们知道一个显然的性质，如果在<code>[l, r]</code>区间中没有任何重复的元素，那么这个区间的输出是<code>(l + r) * (r - l + 1) / 2</code>。如果我们考虑在<code>[l, r]</code>中存在一个<code>old_i</code>使得<code>S[old_i] == S[r]</code>（我们可以使用一个哈希表来维护这个性质），那么我们可以将区间分为<code>[old_i+1, r]</code>和<code>[l, old_i]</code>来计算。现在的问题是，如果这个区间中出现了不止一个的重复元素怎么办？<br>我们注意到在任意的区间中如果字符<code>x</code>出现重复，那么它对<strong>整个结果</strong>都没有贡献，因此我们可以围绕每个字符来做，也就是求每个字符contribute多少次自己。</p>
<h1 id="829-Consecutive-Numbers-Sum"><a href="#829-Consecutive-Numbers-Sum" class="headerlink" title="829. Consecutive Numbers Sum"></a>829. Consecutive Numbers Sum</h1><p>不等式限制一下<code>k</code>的范围就行了。有点类似483题。</p>
<h1 id="834-Sum-of-Distances-in-Tree"><a href="#834-Sum-of-Distances-in-Tree" class="headerlink" title="834. Sum of Distances in Tree"></a>834. Sum of Distances in Tree</h1><p>求一棵树上每个端点到其他端点所有距离的和。一个朴素的肯定会T的方法是维护一个数组<code>dist[N][N]</code>表示从点X到Y的距离，那么就可以对每一个点X来DFS一下，是平方的复杂度。优化的方案来自一个观察，也就是两个节点之间的最短路径是唯一的，并且一定会经过两个节点的LCA。因此可以引入第二个观察，也就是说给定一个遍历顺序，例如从X到Y，或者从Y到X，那么子树的数量是固定的。那么其实我们只需要两次DFS就行了。<br>下面就很简单了，比如我们从X遍历到Y，那么从X到Y的所有孩子的距离等于从Y到它所有孩子的距离（这是一个子问题），再加上孩子的个数。</p>
<h1 id="835-Image-Overlap"><a href="#835-Image-Overlap" class="headerlink" title="835. Image Overlap"></a>835. Image Overlap</h1><h1 id="837-New-21-Game"><a href="#837-New-21-Game" class="headerlink" title="837. New 21 Game"></a>837. New 21 Game</h1><p>我们注意到分数是只增不减的，所以这道题很好递推，写了个$O(WK)$的结果T了。后来发现其实<code>dp[i]</code>可以由<code>sum(dp[i-W..i])/W</code>求得，于是动态维护一个和<code>tot</code>就行了。这里我们要注意一下，当<code>i - 1 &gt;= K</code>时就不能加到<code>tot</code>上了，因为这时候游戏已经结束了。</p>
<h1 id="838-Push-Dominoes"><a href="#838-Push-Dominoes" class="headerlink" title="838. Push Dominoes"></a>838. Push Dominoes</h1><p>这道题首先要注意的是样例2的情况，不是<code>RRRL</code>或者<code>RRRR</code>哦……然后我们的主要关注<code>.</code>，比如<code>R...</code>这样就会引发骨牌效应变成<code>RRRR</code>，也就是多个<code>L</code>或者<code>R</code>的力量是不能叠加的，因此一开始推的骨牌的命运是注定的。于是第一个想法是维护<code>l[]</code>和<code>r[]</code>表示每个<code>L</code>或<code>R</code>向两边传播的“力”的大小，例如<code>R...</code>就表示成<code>[1, 2, 3, 4]</code>，不过这没卵用。后来发现我们可以通过简单的判断每一个<code>.</code>到两边的<code>L</code>和<code>R</code>的距离来判定这个<code>.</code>究竟倒向谁。然后我们要讨论几个特殊情况，因为有的时候骨牌不能往左或者往右倒。我们考虑<code>i</code>能否向左倒：</p>
<ol>
<li>假设最近的<code>r</code>从<code>i</code>右边往左倒，从而往左撞倒<code>i</code>。我们应当注意到<code>r</code>可能不存在，也就是<code>r == inf</code>的情况</li>
<li>假设<code>r</code>向左撞倒<code>i</code>前碰到了向右倒的<code>rb</code>，即出现<code>i(.) rb(-&gt;) r(&lt;-)</code>的情况，这时候<code>i</code>也是倒不了的</li>
</ol>
<p>对于以上的两种情况，我们要先预先处理，然后再进行左右的力量较量</p>
<h1 id="840-Magic-Squares-In-Grid"><a href="#840-Magic-Squares-In-Grid" class="headerlink" title="840. Magic Squares In Grid"></a>840. Magic Squares In Grid</h1><p>我特么看成行列对角线和相等了，，，还有个distinct的条件要考虑</p>
<h1 id="841-Keys-and-Rooms"><a href="#841-Keys-and-Rooms" class="headerlink" title="841. Keys and Rooms"></a>841. Keys and Rooms</h1><p>判断一个图是否是连通图</p>
<h1 id="842-Split-Array-into-Fibonacci-Sequence"><a href="#842-Split-Array-into-Fibonacci-Sequence" class="headerlink" title="842. Split Array into Fibonacci Sequence"></a>842. Split Array into Fibonacci Sequence</h1><p>这个就暴力枚举下fst和snd，然后check就行了。注意范围是int，并且fst和snd的大小没有要求。</p>
<h1 id="846-Hand-of-Straights"><a href="#846-Hand-of-Straights" class="headerlink" title="846. Hand of Straights"></a>846. Hand of Straights</h1><p>用一个dict来维护每个元素的个数，然后从小到大依次check还在的元素。</p>
<h1 id="847-Shortest-Path-Visiting-All-Nodes"><a href="#847-Shortest-Path-Visiting-All-Nodes" class="headerlink" title="847. Shortest Path Visiting All Nodes"></a>847. Shortest Path Visiting All Nodes</h1><p>要求最短的汉密尔顿通路，但不要求只访问一次。此外网上有解法是Floyd+松弛，对<code>S*V</code>的这个状态空间进行遍历并松弛。要注意这里不能再Floyd之后直接记搜，除非在Floyd要维护一下mask的情况。</p>
<h1 id="848-Shifting-Letters"><a href="#848-Shifting-Letters" class="headerlink" title="848. Shifting Letters"></a>848. Shifting Letters</h1><p>简单题</p>
<h1 id="849-Maximize-Distance-to-Closest-Person"><a href="#849-Maximize-Distance-to-Closest-Person" class="headerlink" title="849. Maximize Distance to Closest Person"></a>849. Maximize Distance to Closest Person</h1><p>简单题</p>
<h1 id="851-Loud-and-Rich"><a href="#851-Loud-and-Rich" class="headerlink" title="851. Loud and Rich"></a>851. Loud and Rich</h1><p>给定一个偏序关系<code>richer[i] = [x, y]</code>表示人<code>x</code>比人<code>y</code>要富裕。给定每个人一个<code>quiet[x]</code>值。对于每一个人，找到所有钱大于等于<code>x</code>的人中<code>quiet</code>值最小的人。所有人的<code>quiet</code>是不同的。<br>如果我们反向建立一个有向图，那么答案就是每个点的所有子树中<code>quite</code>最小的点。</p>
<h1 id="852-Peak-Index-in-a-Mountain-Array"><a href="#852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. Peak Index in a Mountain Array"></a>852. Peak Index in a Mountain Array</h1><p>最基础的二分查找</p>
<h1 id="853-Car-Fleet"><a href="#853-Car-Fleet" class="headerlink" title="853. Car Fleet"></a>853. Car Fleet</h1><ol>
<li>车子相撞后的速度是多少？被撞的车的速度</li>
<li>Car fleet彼此相撞吗？根据1，我们可以认为后面的车撞上前面的车之后就消失了。。。因此我们可以统计最后剩的车的数量即可。</li>
</ol>
<p>所以我们计算出每辆车在到达终点时能不能超过自己前面的车辆，这道题一个WA点是不能简单比较一辆车能够超过前面的车。比如下面的这个case，即<code>10, [0,4,2], [2,1,3]</code>，车位置<code>A B C</code>，其中C最慢，B最快，于是B和A先后粘住C，但<strong>A却没有超过B</strong>。所以这一题的思路应该是对于每一辆车，我们统计后面有多少车的时间比自己短，然后把它们去掉。<br>这个朴素算法是$O(n^2)$的，但实际也能过。我们可以优化成$O(n)$的，此时我们只要维护一个<code>ctime</code>来表示当前最慢时间，然后我们从后往前遍历，如果有比这个时间还要慢的，那么这辆车一定不能粘在前面的车子上。</p>
<h1 id="854-K-Similar-Strings"><a href="#854-K-Similar-Strings" class="headerlink" title="854. K-Similar Strings"></a>854. K-Similar Strings</h1><p>如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。<br>给定两个字母异位词A和B，返回A和B的相似度K的最小值。A和B只包含集合<code>{&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;}</code>中的小写字母。<br>这道题让我想起来之前<code>O(1)</code>空间矩阵转置的问题，我们实际上知道始态和终态，现在问如何通过两两交换来达到。<br>假设我们需要把a移动到b的位置，那么我们建立一条从a到b的有向边，可以看出如果从b到a也有一条有向边，那么我们就可以消去这两条边。那么剩下来还有的就是长度大于2的环。对于长度为n的环，需要n-1次操作进行消除。所以问题变成了我们需要去迭代地把图里面的环去掉。<br>写了一个DFS找后向边的方案，WA在了<code>A = &quot;aabbccddee&quot;, B = &quot;cdacbeebad&quot;</code>这个case上面，发现是<code>a&lt;-b&lt;-c&lt;-a</code>和<code>a&lt;-e&lt;-d&lt;-a</code>和<code>b&lt;-d&lt;-e&lt;-c&lt;-b</code>这三个环，而不是之前的小环<code>b c</code>和<code>e d</code>。TODO 我们如何修改这个方案呢？一般来说，找最小环，就是给定一条边<code>(i, j)</code>，找<code>(j, i)</code>的最短路，这个可以借助于dij来做，不过看起来开销有点大。。。<br>直接看题解，首先是一个类似DP的<code>seen</code>，用来记录到<code>seen[S]</code>至少要经过多少步，然后用一个BFS去计算这个<code>seen</code>数组。现在就是我们如何找到所有能从<code>S</code>一步到达的<code>T</code>。</p>
<h1 id="855-Exam-Room"><a href="#855-Exam-Room" class="headerlink" title="855. Exam Room"></a>855. Exam Room</h1><p>贪心即可，注意特别处理<code>0</code>和<code>n - 1</code>的情况。注意两点，<code>max_dis()</code>相等时根据<code>l</code>来判断，合并区间时需要注意单独一个<code>p</code>的情况。</p>
<h1 id="856-Score-of-Parentheses"><a href="#856-Score-of-Parentheses" class="headerlink" title="856. Score of Parentheses"></a>856. Score of Parentheses</h1><p>一看就是和栈有关，不过具体思路还是蛮麻烦的。首先我们知道维护一个计数器，当一个右括号出现的时候我们就将计数器乘2，那么我们什么时候重置这个计数器呢？这一题我们可以借鉴逆波兰式这样的思路，使用一个栈去维护我们的中间结果，每一次右括号会double掉栈顶到最近的左括号的所有值的和。</p>
<h1 id="857-Minimum-Cost-to-Hire-K-Workers"><a href="#857-Minimum-Cost-to-Hire-K-Workers" class="headerlink" title="857. Minimum Cost to Hire K Workers"></a>857. Minimum Cost to Hire K Workers</h1><p>有<code>N</code>个工人，具有<code>quality[i]</code>和<code>wage[i]</code>两个属性。现在需要雇佣<code>K</code>个工人，要求每个工人按照他们的<code>quality[i]</code>的占比给付工资，每一个工人必须给到<code>wage[i]</code>的工资，求最小需要的钱。其中<code>1 &lt;= K &lt;= N &lt;= 10000</code>。<br>首先，我们不能按照<code>wage[i]</code>来贪心，不然，如果出现一个人他的性价比<code>quality[i]/wage[i]</code>超级低，那么即使<code>wage[i]</code>很低，也会把总工资搞得很高。我们也不能按照性价比<code>quality[i]/wage[i]</code>来贪心，因为考虑极端情况，我们只需要一个人，那么我们肯定选工资最低的，而不是性价比最高的。二分答案是不可行的，因为似乎答案不一定是整数。DP的话，我们需要假设<code>DP[K]</code>能从<code>DP[K-1]</code>中推出，但这也不行，我们可以考虑<code>quality = [1,5,5], wage = [10,11,11]</code>的情况，那么<code>DP[1]</code>选<code>0</code>，而<code>DP[2]</code>选<code>1,2</code>。那么我们能够<code>DP[N]</code>么？也就是我们先随便放<code>K</code>个人进队伍里面去，然后我们从第<code>K+1</code>个人开始尝试能不能用他把队伍里面最坏的一个人换掉，从而减少工资总额。我认为已经被淘汰的人不会在后面的轮次中被再次添加上去，因为至少我们已经有<code>K</code>个比他好的结果了。它的复杂度是<code>O(N(尝试替换的人)*K(与K个人比较)*K(计算总工资))</code>。计算总工资的流程是把所有人的<code>quality[i]</code>加起来得到<code>Q</code>，然后求<code>max(wage[i]/(quality[i]/Q)))</code>，这个复杂度看上去就是要T的。。。不过我先写一遍，万一过了呢？并且这种方案如何处理换不换工资总额一样的情况呢？<br>跑了一下，WA了。算了，直接看题解了。题解同样指出我们实际上是要维护两个指标，一个是性价比，一个是工资。总的思路是，我们首先按照性价比对员工进行排序入堆，按照能力值出堆，优先出能力值最大的员工。在这个方案来自于一个观察，即<code>max(wage[i]/(quality[i]/Q)))</code>是由性价比最低的人决定的，因此这个就类似一个滑动窗口问题，我们移出堆里面要吃最高工资比例的人，这是有利于减少总工资的，但现在就少了一个人了，所以只能入一个对总工资增加影响最少的人。</p>
<h1 id="859-Buddy-Strings"><a href="#859-Buddy-Strings" class="headerlink" title="859. Buddy Strings"></a>859. Buddy Strings</h1><p>简单题</p>
<h1 id="860-Lemonade-Change"><a href="#860-Lemonade-Change" class="headerlink" title="860. Lemonade Change"></a>860. Lemonade Change</h1><p>没啥好说的，就是贪</p>
<h1 id="861-Score-After-Flipping-Matrix"><a href="#861-Score-After-Flipping-Matrix" class="headerlink" title="861. Score After Flipping Matrix"></a>861. Score After Flipping Matrix</h1><p>首先我们希望能够将高位尽可能变成1，我一开始的思路就是通过行变换一定能够让最高位变为1的，然后我们进行列变换，使得每一列上的1也是最多（过半数）的。WA了一次之后发现我们还需要考虑先对第一列进行一次列变换，继续WA，原来是犯了个低级错误，行和列搞混了。</p>
<h1 id="862-Shortest-Subarray-with-Sum-at-Least-K"><a href="#862-Shortest-Subarray-with-Sum-at-Least-K" class="headerlink" title="862. Shortest Subarray with Sum at Least K"></a>862. Shortest Subarray with Sum at Least K</h1><p>同样要考虑为负数的情况。这道题如果直接做是$O(n^2)$的，类似560这道题，但实际我们可以做到$O(n)$。我们还需要注意Google的Kickstart2018 Round D的第一条也是这种类型的，不过使用了一个set。<br>因为题目要求找最小的<code>i &gt; j</code>满足<code>B[i] - B[j] &gt;= K</code>，其中<code>B</code>是前缀和，我们使用一个deque来维护所有可能成为<code>j</code>的数。这是一个很奇怪的话，难道有的数不可能成为<code>j</code>么？我们需要考虑两种情况。</p>
<ol>
<li>出现一个更好的结果<br> 例如<code>A = [1,2,7]; K = 3</code>，我们实际遍历序列<code>B = [0, 1, 3, 10]</code>，当我们遍历到10时，<code>q = [1, 2]</code>（稍后我们能够自己得到这个结果），现在我们读取到<code>10</code>，然后从左边尝试出队。也就是说当<code>x - B[q[0]] &gt;= K</code>，我们会得到一个可行解，用它来更新<code>ans</code>。容易看出只要后面的数是合法的，那么前面的数肯定是没用的。</li>
<li>出现一个更差的结果<br> 这个对应于负数的情况，例如<code>A = [1,-2,7]; K = 3</code>，对应的<code>B = [0, 1, -1, 6]</code>，我们发现当遍历到<code>-1</code>时它都小于前面入队的<code>1</code>了。那么这个<code>1</code>肯定是不会被取的了，因为我的<code>-1</code>不仅比你小，还比你靠后，肯定是<strong>不可能成为<code>j</code></strong>的，因此我们从队列中删除这个<code>-1</code>。</li>
</ol>
<h1 id="863-All-Nodes-Distance-K-in-Binary-Tree"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree" class="headerlink" title="863. All Nodes Distance K in Binary Tree"></a>863. All Nodes Distance K in Binary Tree</h1><p>给定一个二叉树<code>root</code>，返回到目标结点<code>target</code>距离为<code>K</code>的所有结点。<br>先转成一个图，然后在图上面bfs</p>
<h1 id="864-Shortest-Path-to-Get-All-Keys"><a href="#864-Shortest-Path-to-Get-All-Keys" class="headerlink" title="864. Shortest Path to Get All Keys"></a>864. Shortest Path to Get All Keys</h1><p>从此往后的四题发生了题号的更改，原先是从865开始的。<br>【Contest 92.4 没做】</p>
<h1 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes"></a>865. Smallest Subtree with all the Deepest Nodes</h1><p>【Contest 92.2 1A】<br>二叉树上多个节点的LCA，拉出链表来搞一波</p>
<h1 id="866-Prime-Palindrome"><a href="#866-Prime-Palindrome" class="headerlink" title="866. Prime Palindrome"></a>866. Prime Palindrome</h1><p>【Contest 92.3 1A】<br>老哥你才<code>10**8</code>，还回文数+质数，我直接打一个表然后bisect完事。。。</p>
<h1 id="867-Transpose-Matrix"><a href="#867-Transpose-Matrix" class="headerlink" title="867. Transpose Matrix"></a>867. Transpose Matrix</h1><p>【Contest 92.1 1A】<br>矩阵转置，没啥好说的</p>
<h1 id="868-Binary-Gap"><a href="#868-Binary-Gap" class="headerlink" title="868. Binary Gap"></a>868. Binary Gap</h1><p>【Contest 93.3 1A】<br>简单题</p>
<h1 id="869-Reordered-Power-of-2"><a href="#869-Reordered-Power-of-2" class="headerlink" title="869. Reordered Power of 2"></a>869. Reordered Power of 2</h1><p>【Contest 93.3 2A】<br>Python居然T，C++就过。。。这题感觉只能暴力啊</p>
<h1 id="870-Advantage-Shuffle"><a href="#870-Advantage-Shuffle" class="headerlink" title="870. Advantage Shuffle"></a>870. Advantage Shuffle</h1><p>【Contest 93.3 1A】<br>这个就是田忌赛马嘛，排序贪心就行，用了<code>del A[i]</code>都能过</p>
<h1 id="871-Minimum-Number-of-Refueling-Stops"><a href="#871-Minimum-Number-of-Refueling-Stops" class="headerlink" title="871. Minimum Number of Refueling Stops"></a>871. Minimum Number of Refueling Stops</h1><p>这道题很难过了，本来以为可以贪的，导致上一条看都没看。当时想法首先是维护<code>have</code>数组表示从<code>i</code>往后所有加油站的存油量，然后贪心的情况就是看当前油量能不能到下一点，以及将来的总油量能不能到终点。后来发现<code>100,25,[[25,25],[50,25],[75,25]]</code>会WA，便使用<code>max_need</code>维护从<code>i</code>往后从<code>j</code>到<code>j + 1</code>需要的油量的最小值，这个思路也是错的，因为我们前面可以存油。也就是说<code>[1..j]</code>的最优解不一定是<code>[1..i]</code>的最优解。<br>所以这道题还是要老老实实DP。一开始我想到类似于第45条一样，维护到<code>i</code>点的最小加油站数<code>l[i]</code>，不过这道题<code>i</code>很大。我们实际上使用<code>dp[i][j]</code>维护到第<code>i</code>个加油站时候总共在<code>j</code>个加油站加油的最大剩油量。然后这条题目相同的代码一发T一发AC，我也是醉了。。。</p>
<h1 id="873-Length-of-Longest-Fibonacci-Subsequence"><a href="#873-Length-of-Longest-Fibonacci-Subsequence" class="headerlink" title="873. Length of Longest Fibonacci Subsequence"></a>873. Length of Longest Fibonacci Subsequence</h1><p>维护<code>dp[i][j]</code>为满足<code>A[i] + A[j] = A[k]</code>的<code>k</code>。我们逆序遍历<code>i &lt; j</code>，然后使用一个集合<code>s</code>维护，我们在这个<code>s</code>里面找有没有<code>A[k]</code>。<br>T了，原来我们要在预处理阶段就算出最长的长度，改一下过了。</p>
<h1 id="875-Koko-Eating-Bananas"><a href="#875-Koko-Eating-Bananas" class="headerlink" title="875. Koko Eating Bananas"></a>875. Koko Eating Bananas</h1><p>有<code>N</code>组香蕉，每一组有<code>piles[i]</code>个。猴子每小时选择一组，然后吃掉这一组中的<code>K</code>个香蕉。问在<code>H</code>小时内全部吃完的最小<code>K</code>是多少。<br>这条应该是一个裸的二分答案。K最大值是一次吃完一组香蕉，所以是<code>max(piles)/N</code>，最小值是一次吃<code>sum(piles)/H</code>个香蕉，少了肯定不行。<br>注意写的时候要<code>max(1, s / H)</code>，不然可能为0。然后<code>X/Y</code>向上取整是<code>(X+Y-1)/Y</code></p>
<h1 id="877-Stone-Game"><a href="#877-Stone-Game" class="headerlink" title="877. Stone Game"></a>877. Stone Game</h1><p>记搜</p>
<h1 id="880-Decoded-String-at-Index"><a href="#880-Decoded-String-at-Index" class="headerlink" title="880. Decoded String at Index"></a>880. Decoded String at Index</h1><p>这个很蛋疼，要求多个层次重复的字符串中的第<code>K</code>个是什么。这种问按照一定规律生成的串中的第N个元素是什么的题目一直困扰着我，因为每次都没有总结出一个比较优雅的解法。<br>本题我们首先不停地扩展我们的字符串，直到超过了需要的长度<code>K</code>。</p>
<h1 id="881-Boats-to-Save-People"><a href="#881-Boats-to-Save-People" class="headerlink" title="881. Boats to Save People"></a>881. Boats to Save People</h1><p>经典的装箱问题，贪一下咯。用C++写，<code>std::multiset</code>很方便。取个负数方便用<code>lower_bound</code>找最大的小于X的数。</p>
<h1 id="887-Super-Egg-Drop"><a href="#887-Super-Egg-Drop" class="headerlink" title="887. Super Egg Drop"></a>887. Super Egg Drop</h1><p>【强烈建议看官方的Solution学习】<br>这一条注意没碎的鸡蛋仍然可以用来二分，所以我们最坏的情况应该按照碎的来算，所以我们不能裸算二分的次数加上最后线性搜的次数。<br>算了我还是记搜吧。。。TLE。。。看题解，实际上我们可以二分这个<code>drop</code>，因为我们取的是<code>max(if_break, not_break)</code>，所以实际上我们希望它们尽可能接近。<br>还可以<a href="https://blog.csdn.net/hizcard/article/details/81808674" target="_blank" rel="noopener">根据鸡蛋数和行动数DP</a>。</p>
<h1 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal"></a>889. Construct Binary Tree from Preorder and Postorder Traversal</h1><p>从前序遍历和后序遍历构建二叉树。</p>
<h1 id="896-Monotonic-Array"><a href="#896-Monotonic-Array" class="headerlink" title="896. Monotonic Array"></a>896. Monotonic Array</h1><p>简单题</p>
<h1 id="897-Increasing-Order-Search-Tree"><a href="#897-Increasing-Order-Search-Tree" class="headerlink" title="897. Increasing Order Search Tree"></a>897. Increasing Order Search Tree</h1><p>简单题</p>
<h1 id="898-Bitwise-ORs-of-Subarrays"><a href="#898-Bitwise-ORs-of-Subarrays" class="headerlink" title="898. Bitwise ORs of Subarrays"></a>898. Bitwise ORs of Subarrays</h1><p>$O(n^2)$的解法是TLE的，我又XJB搞了半天，想用201的那个做法。其实我们不需要将<code>A[i]</code>去or上<code>s</code>中<code>[0..i-1]</code>的所有结果，我们只要or上<code>s</code>中<code>i-1</code>对应的结果就行了，因为<code>i-1</code>之前有的，or到<code>i-1</code>肯定也有。<br>此外还有的$O(logn)$的解法。这道题蛮好的。</p>
<h1 id="899-Orderly-Queue"><a href="#899-Orderly-Queue" class="headerlink" title="899. Orderly Queue"></a>899. Orderly Queue</h1><p>有意思的脑筋急转弯，当<code>K&gt;1</code>时始终可以得到最小字符串。这是因为我们首先可以将已排序部分调整到串的尾部，然后我们可以利用字符串顶部的2个空间来维护出剩余字符串中的最小值。</p>
<h1 id="901-Online-Stock-Span"><a href="#901-Online-Stock-Span" class="headerlink" title="901. Online Stock Span"></a>901. Online Stock Span</h1><p>找到<code>i</code>位置之前的最长的值比<code>prices[i]</code>小的连续序列的长度。这是直方图那条的模板题，例如11题。</p>
<h1 id="903-Valid-Permutations-for-DI-Sequence"><a href="#903-Valid-Permutations-for-DI-Sequence" class="headerlink" title="903. Valid Permutations for DI Sequence"></a>903. Valid Permutations for DI Sequence</h1><p>从0到n的数字组成排列，对于任意的<code>i</code>，要求第<code>i</code>位和<code>i+1</code>位满足一定的大小关系，求所有排列的数量。<br>从排列本身查看局部特征是并不明显的，例如<code>DI</code>的<code>D</code>实际上不禁止<code>01</code>的排列，但<code>I</code>会禁止<code>01</code>排列。<br>显然，dp思路是设<code>dp[i][j]</code>是满足长度为<code>i</code>的序列的末维<code>a[i]==j</code>的排列的数量。不放假设<code>S[i] == D</code>，那么它等于<code>sum dp[i+1][k∈[0..j-1]]</code>。又考虑计算<code>dp[i+1][k]</code>，假设<code>S[i+1]=I</code>，那么在计算时需要<code>sum dp[i+2][l∈k..n-1]</code>，那么<code>a[i+2]</code>可能和<code>a[i]</code>去到同样的数。<br>因此，我们不妨加一个约束，也就是<code>dp[i][j]</code>是<strong>使用数字[0..i-1]</strong>的排列，那数字就不可能重复了。</p>
<h1 id="905-Sort-Array-By-Parity"><a href="#905-Sort-Array-By-Parity" class="headerlink" title="905. Sort Array By Parity"></a>905. Sort Array By Parity</h1><p>双指针简单题</p>
<h1 id="931-Minimum-Falling-Path-Sum"><a href="#931-Minimum-Falling-Path-Sum" class="headerlink" title="931. Minimum Falling Path Sum"></a>931. Minimum Falling Path Sum</h1><p>从棋盘<code>A</code>的左上角到右下角，输出和最小的路径，注意<code>A[i][j]</code>可能为负数。<br>啊 题目理解错了，是一行一行往下找，例如<code>(i,j)</code>的下面是<code>[(i+1,j-1), (i+1,j), (i+1,j+1)]</code><br>这个应该是一个裸DP。</p>
<h1 id="950-Reveal-Cards-In-Increasing-Order"><a href="#950-Reveal-Cards-In-Increasing-Order" class="headerlink" title="950. Reveal Cards In Increasing Order"></a>950. Reveal Cards In Increasing Order</h1><p>定义一种操作，每一次取牌顶的一张牌，如果还有牌，将现在牌顶的牌放到最下面，如果还有牌，重复前面一个步骤。已知输出序列是升序的，求输入序列。<br>第一眼想到的就是倒推。</p>
<h1 id="962-Maximum-Width-Ramp"><a href="#962-Maximum-Width-Ramp" class="headerlink" title="962. Maximum Width Ramp"></a>962. Maximum Width Ramp</h1><p>一个ramp满足<code>i &lt; j</code>且<code>A[i] &lt;= A[j]</code>，定义宽度是<code>j - i</code>，求一个数组里面宽度最大的<code>A</code>。<br>显然我们可以有一个<code>O(n^2)</code>的Naive的办法解决这个问题，那么我们现在显然是希望找一个复杂度较低的办法。看起来有点类似直方图的那条题目？也许我们可以使用类似逆序对的方法，二分解决问题？<br>解法有点类似第768，用的单调栈。维护一个单调递减的栈，然后我们二分查找栈里面第一个小于等于当前数的位置。这是一个F/T…TTT形式的二分。</p>
<h1 id="1011-Capacity-To-Ship-Packages-Within-D-Days"><a href="#1011-Capacity-To-Ship-Packages-Within-D-Days" class="headerlink" title="1011. Capacity To Ship Packages Within D Days"></a>1011. Capacity To Ship Packages Within D Days</h1><p>用传送带往船上运东西，要求<code>D</code>天内运完，船不能超重。求满足要求的最小的船的载重。<br>因为验证很容易，并且上下确界是已知的，所以可以二分答案。</p>
<h1 id="1012-Numbers-With-Repeated-Digits"><a href="#1012-Numbers-With-Repeated-Digits" class="headerlink" title="1012. Numbers With Repeated Digits"></a>1012. Numbers With Repeated Digits</h1><p>给定正整数<code>N</code>，返回小于等于<code>N</code>且具有至少<code>1</code>位重复数字的正整数。<br>感觉这是一个数位DP啊，写了一下，很多报错。原因是要处理高位为0的情况。<br>TODO<br>看了一下题解，发现还需要存当前出现过哪些数字，这一点是我没想到的。题解还保存了flag维，但实际上不需要，加上反而更耗时间</p>
<h1 id="1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><a href="#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum" class="headerlink" title="1013. Partition Array Into Three Parts With Equal Sum"></a>1013. Partition Array Into Three Parts With Equal Sum</h1><p>有N个数组成的序列，可能为负数，问能不能分成和相等的三份。注意，我们不是随机存序列中挑，而是直接往序列中切两刀。因此这个就很简单的，我们扫一遍求和就行</p>
<h1 id="1014-Best-Sightseeing-Pair"><a href="#1014-Best-Sightseeing-Pair" class="headerlink" title="1014. Best Sightseeing Pair"></a>1014. Best Sightseeing Pair</h1><p>给定正整数数组<code>A</code>，<code>A[i]</code>表示第<code>i</code>个观光景点的评分，并且两个景点<code>i</code>和<code>j</code>之间的距离为<code>j - i</code>。一对景点<code>i &lt; j</code>组成的观光组合的得分为<code>A[i] + A[j] + i - j</code>，返回一对观光景点能取得的最高分。<br>朴素做法是平方复杂度，这个肯定是想办法线性了。对于每个<code>A[j]</code>，我们希望找它前面尽可能近的<code>A[i]</code>。也许我们可以把<code>A[i] + i</code>整体放入一个单调栈里面，对于每一个<code>A[j] - j</code>，我们尝试找一个最大的<code>A[i] + i</code>，不过等等。。。我们直接维护就行了啊，不需要单调栈。</p>
<h1 id="1027-Longest-Arithmetic-Sequence"><a href="#1027-Longest-Arithmetic-Sequence" class="headerlink" title="1027. Longest Arithmetic Sequence"></a>1027. Longest Arithmetic Sequence</h1><p>给定一个整数数组<code>A</code>，返回<code>A</code>中最长等差子序列的长度。这题目有点似曾相识啊。。。<br>数列长度是2000，值是10000，不过这个应该没有二分的性质。首先想到的是确定一个等差数列需要两项，那么选择前两项还是末两项呢？从之前的做题经验来看，选择后两项的比较方便DP。那么我们用<code>dp[i][j]</code>表示末项为<code>i</code>，公差<code>j</code>的等差数列的最长长度，那么它的值等于<code>dp[i - j][j] + 1</code>。因此，我们想到一个方案就是对于每一个<code>i</code>，我们先检查它能否和之前的某个数组成新的序列，然后我们再查看，它是否能拓宽已有数列的长度。这个也很容易做到，我们遍历前面所有的数<code>j</code>，然后得到一个公差<code>d</code>，我们尝试能不能更新<code>dp[j][d]</code>即可。dp可以用map来维护。<br>不过上面这个逻辑有点问题，实际上我直接查看能否从<code>dp[j][d]</code>更新<code>dp[i][d]</code>即可，不要什么两次遍历了。不过WA了。原因是要用<code>dp[i][j]</code>表示末项为<code>A[i]</code>，公差<code>j</code>的等差数列，而不是<code>i</code>。</p>
<h1 id="1036-Escape-a-Large-Maze"><a href="#1036-Escape-a-Large-Maze" class="headerlink" title="1036. Escape a Large Maze"></a>1036. Escape a Large Maze</h1><p>一个100万乘以100万的迷宫，有一些格子是被blocked的，问两点间是否存在通路<br>感觉直接对这个图进行搜索就行，但进行搜索需要维护一个vis数组，而显然我们开不了这么大的数组。于是我们注意到最多有200个区块被阻拦。所以我们完全可以对源和汇单独进行一下一个有限宽度的BFS。<br>我一开始觉得遍历半径为200应该，只要能走到100开外就够了，因为事实上一个200×200的正方形上面的对角线也是200长度的，因此我们至少要走到200步开外才行，这样BFS会T。<br>后来看题解才发现，其实我们只需要不停的BFS，直到走到第19900个格子还能走，那么就肯定在外面了。</p>
<h1 id="1049-Last-Stone-Weight-II"><a href="#1049-Last-Stone-Weight-II" class="headerlink" title="1049. Last Stone Weight II"></a>1049. Last Stone Weight II</h1><p>有<code>n</code>个数，我们随便取两个数<code>x</code>和<code>y</code>进行下面的变换，如果<code>x == y</code>，则得到新的数0，否则得到<code>max(x, y) - min(x, y)</code>。问如此循环下去，得到的最小的数是什么。最多有30个数，每个数最大是100。如果采用记搜的方案，复杂度是<code>C(30,2)*C(29*2)*...</code>这样的规模，看起来不能够承受。这个有点辗转相除的味道，但其实不是，因为每一次会少一个数，所以实际上可以看做用加减和括号将这几个数连接起来，考虑到括号可以脱掉，所以实际上就是在这些数前面加上加号和减号，从而得到去最小值，而这个是一个很简单的DP问题。<br>一开始我希望尝试<code>dp[i][j]</code>表示用到<code>i</code>个数能够达到的最接近<code>j</code>的数。后来发现两个问题，首先，也许可以估算到整个过程中最大的合法的<code>j</code>大概是30*100/2，但是我们如何处理在dp更新的过程中发生的上下溢出的问题呢？其次，比如我们要求的<code>j</code>是2，我们通过加法和减法能够分别得到<code>0</code>和<code>4</code>，那么其中哪个更好呢？<br>因此后来直接可以维护用到<code>i</code>个数能够得到的所有的数字了。</p>
<h1 id="1054-Distant-Barcodes"><a href="#1054-Distant-Barcodes" class="headerlink" title="1054. Distant Barcodes"></a>1054. Distant Barcodes</h1><p>一个有重复数的列表，要求去重新排序它，使得没有重复元素相邻。<br>如果我们仅仅去sort的话，那么显然相邻的元素会靠在一起，但是如果我们给值相等的元素编号，并且再sort，应该就是成了。<br>但其实不成，比如第二个case<code>[1,1,1,1,2,2,3,3]</code>。解决方案就是用一个pq维护每个数的个数，然后拿最多的出来填。但是要注意可能填完一个A之后发现A还是最多的，这时候需要将a放到一个<code>no_use</code>里面冷却一下。</p>
<h1 id="1079-Letter-Tile-Possibilities"><a href="#1079-Letter-Tile-Possibilities" class="headerlink" title="1079. Letter Tile Possibilities"></a>1079. Letter Tile Possibilities</h1><p>看起来是给定一些字母，问用这些字母能够组成多少单词。<br>看起来是可以推一个公式的，但是有点困难。<br>先尝试用最简单的方法做，我们从长度为1开始维护一个集合，然后依次尝试往这个集合中添加一个合法的元素。它的复杂度是<code>O(l^3)</code>的，令<code>l</code>是给定tiles的长度。这个是会T的。<br>然后还是推推公式吧，其实还是比较容易的，我们把每个元素的个数标成一个排列。例如<code>aaabbc</code>可以表示成<code>3 2 1</code>，那么其能组合出的数量就是<code>(3+2+1)!/(3!2!1!)</code>，然后我们去计算它的所有子集就行了。考虑到最长为7，所以可以用字符串编码进行记搜。不过这样似乎在<code>1</code>这个情况下会被重复统计。<br>看了题解，这道题的其实不需要<code>O(l^3)</code>这样遍历，直接按字母种类按照顺序往下填就行。</p>
<h1 id="1092-Shortest-Common-Supersequence"><a href="#1092-Shortest-Common-Supersequence" class="headerlink" title="1092. Shortest Common Supersequence"></a>1092. Shortest Common Supersequence</h1><p>先求一个LCS，然后往上面补数字即可。类似于gcd和lcm。</p>
<h1 id="1103-Distribute-Candies-to-People"><a href="#1103-Distribute-Candies-to-People" class="headerlink" title="1103. Distribute Candies to People"></a>1103. Distribute Candies to People</h1><p>简单题</p>
<h1 id="1115-Print-FooBar-Alternately"><a href="#1115-Print-FooBar-Alternately" class="headerlink" title="1115. Print FooBar Alternately"></a>1115. Print FooBar Alternately</h1><p>并行算法问题，Python依然始终T。。。</p>
<h1 id="1116-Print-Zero-Even-Odd"><a href="#1116-Print-Zero-Even-Odd" class="headerlink" title="1116. Print Zero Even Odd"></a>1116. Print Zero Even Odd</h1><p>并行算法问题，Python始终T。。。</p>
<h1 id="1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><a href="#1123-Lowest-Common-Ancestor-of-Deepest-Leaves" class="headerlink" title="1123. Lowest Common Ancestor of Deepest Leaves"></a>1123. Lowest Common Ancestor of Deepest Leaves</h1><p>在二叉树上LCA，老题新做，得到两个List，然后zip比较即可</p>
<h1 id="1124-Longest-Well-Performing-Interval"><a href="#1124-Longest-Well-Performing-Interval" class="headerlink" title="1124. Longest Well-Performing Interval"></a>1124. Longest Well-Performing Interval</h1><p>一条讽刺996的题目。数组<code>hours</code>的一个子数组中大于8的数字的个数严格大于小于等于8数字的个数，那么这个数组是好的，问最长的好数组是多长。<br>朴素做法是<code>O(n^3)</code>的，包含一个<code>O(n^2)</code>的循环用来遍历所有区间，然后用一个循环来检查区间是否合法。<br>我们能用双指针来去掉一个循环么？考虑一下双指针的适用场景。比如分别从左和从右相向移动的双指针，这种方案是我们能够保证当指针已经移到<code>(i, j)</code>时，不会产生一个情况<code>(i-1, j)</code>这样的最优解。<br>其实我发现可以用<code>O(1)</code>来判断是否是好的，就用+1或者-1维护一个累积和<code>acc</code>就行了，得到一个<code>O(n^2)</code>的方案，但是T了。<br>看了题解，其实最佳解法是<code>O(n)</code>的，使用单调栈去处理累积和<code>acc</code>。单调栈适合解决对<code>i, j</code>和<code>arr[i], arr[j]</code>同时有要求的题目。例如这条题目，我们就是要求一个最大的跨度<code>(i, j)</code>，满足<code>acc[j] &gt; acc[i]</code>，这样我们保证这段区间内1是比-1要多的。<br>到这里可以发现，本题类似于第962题。不过令人遗憾的是我似乎没有学会962的方法。。。照搬一下，发现会WA在<code>[6,9,6]</code>这个case上，错误地输出2。<br>比了一下逻辑，发现其实和数组<code>acc[0]</code>应该设置为0，从而得到一个WA3。<br>最后终于过了，原因是首先要在二分完之后看一下<code>l</code>是否合法，可能<code>l</code>也不合法，然后要在<code>acc</code>前面加一项<code>0</code>，不然第一项为1的情况可能不被计算，因为我们是算得<code>(i, stk[l]]</code>。<br>TODO</p>
<h1 id="1125-Smallest-Sufficient-Team"><a href="#1125-Smallest-Sufficient-Team" class="headerlink" title="1125. Smallest Sufficient Team"></a>1125. Smallest Sufficient Team</h1><p>一个项目要选几个人来完成，<code>req_skills</code>表示完成这个项目需要哪些技能，<code>people</code>表示每个人的技能。现在要求找到最小的人的集合。<br>这道题的Naive解法是幂的复杂度，二分答案的话验证也不好做，所以应该是一个DP或者记搜，并且是要压缩状态的。我们定义<code>dp[s]</code>表示要达到状态<code>s</code>需要哪些人的参与。<br>不过这样的记搜面临一个问题，也就是说例如我们最终需要1245，现在有一个1需要一个2，我们有123和124的选项，那么选哪个好呢？反而是用DP的方式推要容易一点</p>
<h1 id="1130-Minimum-Cost-Tree-From-Leaf-Values"><a href="#1130-Minimum-Cost-Tree-From-Leaf-Values" class="headerlink" title="1130. Minimum Cost Tree From Leaf Values"></a>1130. Minimum Cost Tree From Leaf Values</h1><p>给定所有的叶子节点，构造一个二叉树。每一个非叶子节点的值等于左子树最大值和右子树最大值的乘积。问所有非叶子节点和最小是多少。<br>先扯一点别的，给定<code>N</code>个点，能形成多少个二叉排序树？这个是Leetcode96。那么给定<code>N</code>个点，能形成多少个二叉树？可以看<a href="https://gatecse.in/number-of-binary-trees-possible-with-n-nodes/" target="_blank" rel="noopener">这篇文章</a><br>回到这一题，看起来有点线段树的构造啊。于是令<code>dp[i][j]</code>表示<code>[i..j]</code>区间上的非叶子节点的值的和。<br>不过WA在了<code>[15,13,5,3,15]</code>上，原因是我是fori、forj，但实际上应该先短后长。</p>
<h1 id="1143-Longest-Common-Subsequence"><a href="#1143-Longest-Common-Subsequence" class="headerlink" title="1143. Longest Common Subsequence"></a>1143. Longest Common Subsequence</h1><p>LCS老题老做</p>
<h1 id="1155-Number-of-Dice-Rolls-With-Target-Sum"><a href="#1155-Number-of-Dice-Rolls-With-Target-Sum" class="headerlink" title="1155. Number of Dice Rolls With Target Sum"></a>1155. Number of Dice Rolls With Target Sum</h1><p>有d个骰子，每个有f面，问这些骰子朝上面总和是targe时有多少种情况，要求模<code>10^9 + 7</code>。每个骰子是独立计算的。<br>看起来是一条数学题，继续看下数据范围<code>1 &lt;= d, f &lt;= 30</code>，<code>1 &lt;= target &lt;= 1000</code>，似乎可以DP。一个容易的想法是<code>dp[i][t]</code>表示用前<code>i</code>个骰子达到<code>target</code>有多少种方法。那么<code>dp[0][1..f]</code>的取指肯定都是1。对于<code>dp[i][t]</code>，那么其方案总数就是for 1..f尝试去更新一下。</p>
<h1 id="1222-Queens-That-Can-Attack-the-King"><a href="#1222-Queens-That-Can-Attack-the-King" class="headerlink" title="1222. Queens That Can Attack the King"></a>1222. Queens That Can Attack the King</h1><p>从king处按照八个方向找到第一个Queen即可。</p>
<h1 id="1227-Airplane-Seat-Assignment-Probability"><a href="#1227-Airplane-Seat-Assignment-Probability" class="headerlink" title="1227. Airplane Seat Assignment Probability"></a>1227. Airplane Seat Assignment Probability</h1><p><code>n</code>个人坐座位，第一个人没带票随机坐，有<code>1/n</code>的概率坐到自己对应的座位上。后面的人座位没被占的就坐自己的，不然就随机坐。问第<code>n</code>个人坐到自己座位上的概率是多少？<br>一个直截了当的做法就是算<code>dp[i][j]</code>表示第<code>i</code>个人坐到第<code>j</code>个座位上的概率。然后T了，看Hints，似乎可以打表找规律。结果发现从1之后都是0.5。。。这个题目很有意思，应该可以用数学归纳法证明一下<code>P[i]==P[i+1]</code></p>
<h1 id="1232-Check-If-It-Is-a-Straight-Line"><a href="#1232-Check-If-It-Is-a-Straight-Line" class="headerlink" title="1232. Check If It Is a Straight Line"></a>1232. Check If It Is a Straight Line</h1><p>检测一条线是不是直线</p>
<h1 id="1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><a href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters" class="headerlink" title="1239. Maximum Length of a Concatenated String with Unique Characters"></a>1239. Maximum Length of a Concatenated String with Unique Characters</h1><p>给定一个字符串数组<code>arr</code>，选择其中一些串组合起来，要求组合之后的串没有重复字符，问能组成的最长的串的长度是多少？其中<code>1 &lt;= arr.length &lt;= 16</code>，<code>1 &lt;= arr[i].length &lt;= 26</code>。<br>这个题目感觉很熟悉。。。类似于我们要选择价值最大的几个元素，但是要满足一些规定，例如元素A和元素B不能同时存在。<br>没思路，直接看了题解。。。结果居然是回溯法，直接枚举也行。。。反正复杂度是<code>2^16</code>。<br>回溯法相对来说比较容易，我们用一个26bit的int来压缩每个字符出现的次数。<br>这一题要注意<code>[yyy]</code>这种特殊情况，字符串本身有重复，也是不可以的。</p>
<h1 id="1262-Greatest-Sum-Divisible-by-Three"><a href="#1262-Greatest-Sum-Divisible-by-Three" class="headerlink" title="1262. Greatest Sum Divisible by Three"></a>1262. Greatest Sum Divisible by Three</h1><p>给定一个<code>nums</code>数组，要求找到和最大的一个子集，要求这个和能被3整除。这个题目很简单，直接按照模分成三个数组，然后把模1和模2的数组从大到小对应相加就行。但WA了，因为两个模可以组成一个模2，这种情形要考虑进去。<br>然后我们可以联想到是否可以通过背包问题来做。发现没有必要。我们可以设<code>dp[n][mod]</code>，然后查看能否用<code>nums[i]</code>更新<code>dp[i - 1][0..2]</code>。</p>
<h1 id="1291-Sequential-Digits"><a href="#1291-Sequential-Digits" class="headerlink" title="1291. Sequential Digits"></a>1291. Sequential Digits</h1><p>一个有趣的观察是通过首位和长度，就可以唯一确定一个序列，剩下来的就是如何通过<code>low</code>和<code>high</code>去截断序列。</p>
<h1 id="1298-Maximum-Candies-You-Can-Get-from-Boxes"><a href="#1298-Maximum-Candies-You-Can-Get-from-Boxes" class="headerlink" title="1298. Maximum Candies You Can Get from Boxes"></a>1298. Maximum Candies You Can Get from Boxes</h1><p>【TODO】<br><code>status[i]</code>表示箱子有没有打开，<code>candies[i]</code>表示箱子里面有多少糖，<code>keys[i]</code>是箱子里面的所有钥匙，<code>containedBoxes[i]</code>是<code>box[i]</code>里面包含的箱子，没搞懂最后一句什么意思。</p>
<h1 id="1314-Matrix-Block-Sum"><a href="#1314-Matrix-Block-Sum" class="headerlink" title="1314. Matrix Block Sum"></a>1314. Matrix Block Sum</h1><p>给定K，和一个二维数组。要计算<code>i - K &lt;= r &lt;= i + K, j - K &lt;= c &lt;= j + K</code>范围内的所有的数的和。<br>可以在<code>O(n*m)</code>复杂度完成</p>
<h1 id="1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><a href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance" class="headerlink" title="1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance"></a>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</h1><p>emmmmm，这题目很长啊。。。翻译过来就是一个带权无向图，我们筛选出从每个城市能够在<code>distanceThreshold</code>距离内到达的所有城市，我们需要返回的是能够到达最少城市的城市。当有多个答案时，返回index最大的。<br>其实就是Floyd模板题</p>
<h1 id="1338-Reduce-Array-Size-to-The-Half"><a href="#1338-Reduce-Array-Size-to-The-Half" class="headerlink" title="1338. Reduce Array Size to The Half"></a>1338. Reduce Array Size to The Half</h1><p>一个整数数组<code>arr</code>。选出一个整数集合，并删除这些整数在数组中的每次出现。返回至少能删除数组中的一半整数的整数集合的最小大小。<br>看起来就是说有n个东西，每个东西有价值v，总价值V，问如何选择最少的东西使得总价值至少大于V，贪心就行了</p>
<h1 id="1354-Construct-Target-Array-With-Multiple-Sums"><a href="#1354-Construct-Target-Array-With-Multiple-Sums" class="headerlink" title="1354. Construct Target Array With Multiple Sums"></a>1354. Construct Target Array With Multiple Sums</h1><p>给你一个整数数组<code>target</code>。你有一个数组<code>A</code>，它的所有元素均为1，重复该过程任意次以下操作，问能否得到<code>target</code>。</p>
<ol>
<li>令<code>x</code>为你数组里所有元素的和</li>
<li>选择数组里面的任意元素，并将其变为<code>x</code></li>
</ol>
<p>观察一下，因为原数组都是1，所以每进行一次操作，总和<code>x</code>就会变大。我们不妨考虑两个的情况，令<code>[a, b]</code>，其中<code>a &gt; b</code>，那么它肯定是从<code>[b, a - b]</code>得到的，我们依次重复这样的操作，看看最后能不能得到一个全是1的数组即可。<br>所以我们模拟一下就行，不过这个方案T了。下面就能够很自然想到用优先队列优化，但是我们要同时自己维护一下当前<code>target</code>的和。<br>此外还有特定优化一下<code>[1,1000000000]</code>的情况，特判一下只有一个元素的情况。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ACM/" rel="tag"># ACM</a>
          
            <a href="/tags/字符串/" rel="tag"># 字符串</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/08/去除Reimage恶意广告软件/" rel="next" title="去除reimage repair恶意广告软件">
                <i class="fa fa-chevron-left"></i> 去除reimage repair恶意广告软件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/11/C++-rvalue/" rel="prev" title="C++右值">
                C++右值 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">145</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">151</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Add-Two-Numbers"><span class="nav-number">2.</span> <span class="nav-text">2. Add Two Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">3.</span> <span class="nav-text">3. Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Median-of-Two-Sorted-Arrays"><span class="nav-number">4.</span> <span class="nav-text">4. Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Longest-Palindromic-Substring"><span class="nav-number">5.</span> <span class="nav-text">5. Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-ZigZag-Conversion"><span class="nav-number">6.</span> <span class="nav-text">6. ZigZag Conversion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Reverse-Integer"><span class="nav-number">7.</span> <span class="nav-text">7. Reverse Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-String-to-Integer-atoi"><span class="nav-number">8.</span> <span class="nav-text">8. String to Integer (atoi)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Palindrome-Number"><span class="nav-number">9.</span> <span class="nav-text">9. Palindrome Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Regular-Expression-Matching"><span class="nav-number">10.</span> <span class="nav-text">10. Regular Expression Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">11.</span> <span class="nav-text">11. Container With Most Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Longest-Common-Prefix"><span class="nav-number">12.</span> <span class="nav-text">14. Longest Common Prefix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-3Sum"><span class="nav-number">13.</span> <span class="nav-text">15. 3Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-3Sum-Closest"><span class="nav-number">14.</span> <span class="nav-text">16. 3Sum Closest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="nav-number">15.</span> <span class="nav-text">17. Letter Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-4Sum"><span class="nav-number">16.</span> <span class="nav-text">18. 4Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">17.</span> <span class="nav-text">19. Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-Valid-Parentheses"><span class="nav-number">18.</span> <span class="nav-text">20. Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists"><span class="nav-number">19.</span> <span class="nav-text">21. Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Generate-Parentheses"><span class="nav-number">20.</span> <span class="nav-text">22. Generate Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Merge-k-Sorted-Lists"><span class="nav-number">21.</span> <span class="nav-text">23. Merge k Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-Swap-Nodes-in-Pairs"><span class="nav-number">22.</span> <span class="nav-text">24. Swap Nodes in Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-Reverse-Nodes-in-k-Group"><span class="nav-number">23.</span> <span class="nav-text">25. Reverse Nodes in k-Group</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">24.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">25.</span> <span class="nav-text">27. Remove Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-Divide-Two-Integers"><span class="nav-number">26.</span> <span class="nav-text">29. Divide Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用位运算实现整数加减法"><span class="nav-number">26.1.</span> <span class="nav-text">使用位运算实现整数加减法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用加减运算实现整数除法"><span class="nav-number">26.2.</span> <span class="nav-text">使用加减运算实现整数除法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#30-Substring-with-Concatenation-of-All-Words"><span class="nav-number">27.</span> <span class="nav-text">30. Substring with Concatenation of All Words</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-Next-Permutation"><span class="nav-number">28.</span> <span class="nav-text">31. Next Permutation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-Longest-Valid-Parentheses"><span class="nav-number">29.</span> <span class="nav-text">32. Longest Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="nav-number">30.</span> <span class="nav-text">33. Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-Search-for-a-Range"><span class="nav-number">31.</span> <span class="nav-text">34. Search for a Range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-Search-Insert-Position"><span class="nav-number">32.</span> <span class="nav-text">35. Search Insert Position</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-Sudoku-Solver"><span class="nav-number">33.</span> <span class="nav-text">37. Sudoku Solver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-Combination-Sum"><span class="nav-number">34.</span> <span class="nav-text">39. Combination Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-Combination-Sum-II"><span class="nav-number">35.</span> <span class="nav-text">40. Combination Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">36.</span> <span class="nav-text">41. First Missing Positive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-Trapping-Rain-Water"><span class="nav-number">37.</span> <span class="nav-text">42. Trapping Rain Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#43-Multiply-Strings"><span class="nav-number">38.</span> <span class="nav-text">43. Multiply Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-Wildcard-Matching"><span class="nav-number">39.</span> <span class="nav-text">44. Wildcard Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-Jump-Game-II"><span class="nav-number">40.</span> <span class="nav-text">45. Jump Game II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-Permutations"><span class="nav-number">41.</span> <span class="nav-text">46. Permutations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-Permutations-II"><span class="nav-number">42.</span> <span class="nav-text">47. Permutations II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-Rotate-Image"><span class="nav-number">43.</span> <span class="nav-text">48. Rotate Image</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-Group-Anagrams"><span class="nav-number">44.</span> <span class="nav-text">49. Group Anagrams</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">45.</span> <span class="nav-text">50. Pow(x, n)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-N-Queens"><span class="nav-number">46.</span> <span class="nav-text">51. N-Queens</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-N-Queens-II"><span class="nav-number">47.</span> <span class="nav-text">52. N-Queens II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">48.</span> <span class="nav-text">53. Maximum Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">49.</span> <span class="nav-text">54. Spiral Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-Jump-Game"><span class="nav-number">50.</span> <span class="nav-text">55. Jump Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-Merge-Intervals"><span class="nav-number">51.</span> <span class="nav-text">56. Merge Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-Insert-Interval"><span class="nav-number">52.</span> <span class="nav-text">57. Insert Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-Length-of-Last-Word"><span class="nav-number">53.</span> <span class="nav-text">58. Length of Last Word</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-Spiral-Matrix-II"><span class="nav-number">54.</span> <span class="nav-text">59. Spiral Matrix II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60-Permutation-Sequence"><span class="nav-number">55.</span> <span class="nav-text">60. Permutation Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-Rotate-List"><span class="nav-number">56.</span> <span class="nav-text">61. Rotate List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">57.</span> <span class="nav-text">62. Unique Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63-Unique-Paths-II"><span class="nav-number">58.</span> <span class="nav-text">63. Unique Paths II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-Plus-One"><span class="nav-number">59.</span> <span class="nav-text">66. Plus One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67-Add-Binary"><span class="nav-number">60.</span> <span class="nav-text">67. Add Binary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-Sqrt-x"><span class="nav-number">61.</span> <span class="nav-text">69. Sqrt(x)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-Climbing-Stairs"><span class="nav-number">62.</span> <span class="nav-text">70. Climbing Stairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">63.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#73-Set-Matrix-Zeroes"><span class="nav-number">64.</span> <span class="nav-text">73. Set Matrix Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#74-Search-a-2D-Matrix"><span class="nav-number">65.</span> <span class="nav-text">74. Search a 2D Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-Sort-Colors"><span class="nav-number">66.</span> <span class="nav-text">75. Sort Colors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#76-Minimum-Window-Substring"><span class="nav-number">67.</span> <span class="nav-text">76. Minimum Window Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-Combinations"><span class="nav-number">68.</span> <span class="nav-text">77. Combinations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-Subsets"><span class="nav-number">69.</span> <span class="nav-text">78. Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#81-Search-in-Rotated-Sorted-Array-II"><span class="nav-number">70.</span> <span class="nav-text">81. Search in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#82-Remove-Duplicates-from-Sorted-List-II"><span class="nav-number">71.</span> <span class="nav-text">82. Remove Duplicates from Sorted List II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#84-Largest-Rectangle-in-Histogram"><span class="nav-number">72.</span> <span class="nav-text">84. Largest Rectangle in Histogram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#85-Maximal-Rectangle"><span class="nav-number">73.</span> <span class="nav-text">85. Maximal Rectangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-Partition-List"><span class="nav-number">74.</span> <span class="nav-text">86. Partition List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#87-Scramble-String"><span class="nav-number">75.</span> <span class="nav-text">87. Scramble String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#89-Gray-Code"><span class="nav-number">76.</span> <span class="nav-text">89. Gray Code</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#90-Subsets-II"><span class="nav-number">77.</span> <span class="nav-text">90. Subsets II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#91-Decode-Ways"><span class="nav-number">78.</span> <span class="nav-text">91. Decode Ways</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#96-Unique-Binary-Search-Trees"><span class="nav-number">79.</span> <span class="nav-text">96. Unique Binary Search Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#97-Interleaving-String"><span class="nav-number">80.</span> <span class="nav-text">97. Interleaving String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#98-Validate-Binary-Search-Tree"><span class="nav-number">81.</span> <span class="nav-text">98. Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#99-Recover-Binary-Search-Tree"><span class="nav-number">82.</span> <span class="nav-text">99. Recover Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#101-Symmetric-Tree"><span class="nav-number">83.</span> <span class="nav-text">101. Symmetric Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal"><span class="nav-number">84.</span> <span class="nav-text">102. Binary Tree Level Order Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree"><span class="nav-number">85.</span> <span class="nav-text">104. Maximum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><span class="nav-number">86.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal"><span class="nav-number">87.</span> <span class="nav-text">106. Construct Binary Tree from Inorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II"><span class="nav-number">88.</span> <span class="nav-text">107. Binary Tree Level Order Traversal II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#109-Convert-Sorted-List-to-Binary-Search-Tree"><span class="nav-number">89.</span> <span class="nav-text">109. Convert Sorted List to Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#110-Balanced-Binary-Tree"><span class="nav-number">90.</span> <span class="nav-text">110. Balanced Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="nav-number">91.</span> <span class="nav-text">111. Minimum Depth of Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#113-Path-Sum-II"><span class="nav-number">92.</span> <span class="nav-text">113. Path Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List"><span class="nav-number">93.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#115-Distinct-Subsequences"><span class="nav-number">94.</span> <span class="nav-text">115. Distinct Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="nav-number">95.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#120-Triangle"><span class="nav-number">96.</span> <span class="nav-text">120. Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">97.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">98.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">99.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-number">100.</span> <span class="nav-text">124. Binary Tree Maximum Path Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-number">101.</span> <span class="nav-text">125. Valid Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#126-Word-Ladder-II"><span class="nav-number">102.</span> <span class="nav-text">126. Word Ladder II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-number">103.</span> <span class="nav-text">127. Word Ladder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-number">104.</span> <span class="nav-text">128. Longest Consecutive Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#129-Sum-Root-to-Leaf-Numbers"><span class="nav-number">105.</span> <span class="nav-text">129. Sum Root to Leaf Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#130-Surrounded-Regions"><span class="nav-number">106.</span> <span class="nav-text">130. Surrounded Regions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#131-Palindrome-Partitioning"><span class="nav-number">107.</span> <span class="nav-text">131. Palindrome Partitioning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#132-Palindrome-Partitioning-II"><span class="nav-number">108.</span> <span class="nav-text">132. Palindrome Partitioning II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-number">109.</span> <span class="nav-text">134. Gas Station</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#135-Candy"><span class="nav-number">110.</span> <span class="nav-text">135. Candy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">111.</span> <span class="nav-text">136. Single Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#137-Single-Number-II"><span class="nav-number">112.</span> <span class="nav-text">137. Single Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#138-Copy-List-with-Random-Pointer"><span class="nav-number">113.</span> <span class="nav-text">138. Copy List with Random Pointer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-Word-Break"><span class="nav-number">114.</span> <span class="nav-text">139. Word Break</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#140-Word-Break-II"><span class="nav-number">115.</span> <span class="nav-text">140. Word Break II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-number">116.</span> <span class="nav-text">141. Linked List Cycle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-number">117.</span> <span class="nav-text">142. Linked List Cycle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal"><span class="nav-number">118.</span> <span class="nav-text">144. Binary Tree Preorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="nav-number">119.</span> <span class="nav-text">145. Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-number">120.</span> <span class="nav-text">146. LRU Cache</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#147-Insertion-Sort-List"><span class="nav-number">121.</span> <span class="nav-text">147. Insertion Sort List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-Sort-List"><span class="nav-number">122.</span> <span class="nav-text">148. Sort List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#149-Max-Points-on-a-Line"><span class="nav-number">123.</span> <span class="nav-text">149. Max Points on a Line</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#151-Reverse-Words-in-a-String"><span class="nav-number">124.</span> <span class="nav-text">151. Reverse Words in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">125.</span> <span class="nav-text">152. Maximum Product Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">126.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#154-Find-Minimum-in-Rotated-Sorted-Array-II"><span class="nav-number">127.</span> <span class="nav-text">154. Find Minimum in Rotated Sorted Array II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#155-Min-Stack"><span class="nav-number">128.</span> <span class="nav-text">155. Min Stack</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-number">129.</span> <span class="nav-text">160. Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-number">130.</span> <span class="nav-text">162. Find Peak Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#164-Maximum-Gap"><span class="nav-number">131.</span> <span class="nav-text">164. Maximum Gap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#165-Compare-Version-Numbers"><span class="nav-number">132.</span> <span class="nav-text">165. Compare Version Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">133.</span> <span class="nav-text">169. Majority Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#174-Dungeon-Game"><span class="nav-number">134.</span> <span class="nav-text">174. Dungeon Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-Largest-Number"><span class="nav-number">135.</span> <span class="nav-text">179. Largest Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#182-Duplicate-Emails"><span class="nav-number">136.</span> <span class="nav-text">182. Duplicate Emails</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#187-Repeated-DNA-Sequences"><span class="nav-number">137.</span> <span class="nav-text">187. Repeated DNA Sequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#188-Best-Time-to-Buy-and-Sell-Stock-IV"><span class="nav-number">138.</span> <span class="nav-text">188. Best Time to Buy and Sell Stock IV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#189-Rotate-Array"><span class="nav-number">139.</span> <span class="nav-text">189. Rotate Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#190-Reverse-Bits"><span class="nav-number">140.</span> <span class="nav-text">190. Reverse Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-number">141.</span> <span class="nav-text">191. Number of 1 Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#195-Tenth-Line"><span class="nav-number">142.</span> <span class="nav-text">195. Tenth Line</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#198-House-Robber"><span class="nav-number">143.</span> <span class="nav-text">198. House Robber</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#199-Binary-Tree-Right-Side-View"><span class="nav-number">144.</span> <span class="nav-text">199. Binary Tree Right Side View</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-number">145.</span> <span class="nav-text">200. Number of Islands</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#201-Bitwise-AND-of-Numbers-Range"><span class="nav-number">146.</span> <span class="nav-text">201. Bitwise AND of Numbers Range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#204-Count-Primes"><span class="nav-number">147.</span> <span class="nav-text">204. Count Primes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#205-Isomorphic-Strings"><span class="nav-number">148.</span> <span class="nav-text">205. Isomorphic Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-number">149.</span> <span class="nav-text">206. Reverse Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-number">150.</span> <span class="nav-text">207. Course Schedule</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-number">151.</span> <span class="nav-text">208. Implement Trie (Prefix Tree)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#209-Minimum-Size-Subarray-Sum"><span class="nav-number">152.</span> <span class="nav-text">209. Minimum Size Subarray Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-number">153.</span> <span class="nav-text">210. Course Schedule II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#213-House-Robber-II"><span class="nav-number">154.</span> <span class="nav-text">213. House Robber II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#214-Shortest-Palindrome"><span class="nav-number">155.</span> <span class="nav-text">214. Shortest Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="nav-number">156.</span> <span class="nav-text">215. Kth Largest Element in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#218-The-Skyline-Problem"><span class="nav-number">157.</span> <span class="nav-text">218. The Skyline Problem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-Maximal-Square"><span class="nav-number">158.</span> <span class="nav-text">221. Maximal Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#222-Count-Complete-Tree-Nodes"><span class="nav-number">159.</span> <span class="nav-text">222. Count Complete Tree Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#223-Rectangle-Area"><span class="nav-number">160.</span> <span class="nav-text">223. Rectangle Area</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#228-Summary-Ranges"><span class="nav-number">161.</span> <span class="nav-text">228. Summary Ranges</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#229-Majority-Element-II"><span class="nav-number">162.</span> <span class="nav-text">229. Majority Element II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST"><span class="nav-number">163.</span> <span class="nav-text">230. Kth Smallest Element in a BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#233-Number-of-Digit-One"><span class="nav-number">164.</span> <span class="nav-text">233. Number of Digit One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">165.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#238-Product-of-Array-Except-Self"><span class="nav-number">166.</span> <span class="nav-text">238. Product of Array Except Self</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">167.</span> <span class="nav-text">239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#240-Search-a-2D-Matrix-II"><span class="nav-number">168.</span> <span class="nav-text">240. Search a 2D Matrix II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#241-Different-Ways-to-Add-Parentheses"><span class="nav-number">169.</span> <span class="nav-text">241. Different Ways to Add Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#258-Add-Digits"><span class="nav-number">170.</span> <span class="nav-text">258. Add Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#260-Single-Number-III"><span class="nav-number">171.</span> <span class="nav-text">260. Single Number III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#263-Ugly-Number"><span class="nav-number">172.</span> <span class="nav-text">263. Ugly Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#264-Ugly-Number-II"><span class="nav-number">173.</span> <span class="nav-text">264. Ugly Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#274-H-Index"><span class="nav-number">174.</span> <span class="nav-text">274. H-Index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#275-H-Index-II"><span class="nav-number">175.</span> <span class="nav-text">275. H-Index II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-number">176.</span> <span class="nav-text">279. Perfect Squares</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#282-Expression-Add-Operators"><span class="nav-number">177.</span> <span class="nav-text">282. Expression Add Operators</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#283-Move-Zeroes"><span class="nav-number">178.</span> <span class="nav-text">283. Move Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#284-Peeking-Iterator"><span class="nav-number">179.</span> <span class="nav-text">284. Peeking Iterator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#287-Find-the-Duplicate-Number"><span class="nav-number">180.</span> <span class="nav-text">287. Find the Duplicate Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#295-Find-Median-from-Data-Stream"><span class="nav-number">181.</span> <span class="nav-text">295. Find Median from Data Stream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#299-Bulls-and-Cows"><span class="nav-number">182.</span> <span class="nav-text">299. Bulls and Cows</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-number">183.</span> <span class="nav-text">300. Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#301-Remove-Invalid-Parentheses"><span class="nav-number">184.</span> <span class="nav-text">301. Remove Invalid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#304-Range-Sum-Query-2D-Immutable"><span class="nav-number">185.</span> <span class="nav-text">304. Range Sum Query 2D - Immutable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#307-Range-Sum-Query-Mutable"><span class="nav-number">186.</span> <span class="nav-text">307. Range Sum Query - Mutable</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">187.</span> <span class="nav-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#310-Minimum-Height-Trees"><span class="nav-number">188.</span> <span class="nav-text">310. Minimum Height Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#312-Burst-Balloons"><span class="nav-number">189.</span> <span class="nav-text">312. Burst Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#313-Super-Ugly-Number"><span class="nav-number">190.</span> <span class="nav-text">313. Super Ugly Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-number">191.</span> <span class="nav-text">315. Count of Smaller Numbers After Self</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#316-Remove-Duplicate-Letters"><span class="nav-number">192.</span> <span class="nav-text">316. Remove Duplicate Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#319-Bulb-Switcher"><span class="nav-number">193.</span> <span class="nav-text">319. Bulb Switcher</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#321-Create-Maximum-Number"><span class="nav-number">194.</span> <span class="nav-text">321. Create Maximum Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#322-Coin-Change"><span class="nav-number">195.</span> <span class="nav-text">322. Coin Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#324-Wiggle-Sort-II"><span class="nav-number">196.</span> <span class="nav-text">324. Wiggle Sort II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-number">197.</span> <span class="nav-text">326. Power of Three</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#327-Count-of-Range-Sum"><span class="nav-number">198.</span> <span class="nav-text">327. Count of Range Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#328-Odd-Even-Linked-List"><span class="nav-number">199.</span> <span class="nav-text">328. Odd Even Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#329-Longest-Increasing-Path-in-a-Matrix"><span class="nav-number">200.</span> <span class="nav-text">329. Longest Increasing Path in a Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#330-Patching-Array"><span class="nav-number">201.</span> <span class="nav-text">330. Patching Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#332-Reconstruct-Itinerary"><span class="nav-number">202.</span> <span class="nav-text">332. Reconstruct Itinerary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#335-Self-Crossing"><span class="nav-number">203.</span> <span class="nav-text">335. Self Crossing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#336-Palindrome-Pairs"><span class="nav-number">204.</span> <span class="nav-text">336. Palindrome Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#337-House-Robber-III"><span class="nav-number">205.</span> <span class="nav-text">337. House Robber III/</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#338-Counting-Bits"><span class="nav-number">206.</span> <span class="nav-text">338. Counting Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#341-Flatten-Nested-List-Iterator"><span class="nav-number">207.</span> <span class="nav-text">341. Flatten Nested List Iterator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#342-Power-of-Four"><span class="nav-number">208.</span> <span class="nav-text">342. Power of Four</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#343-Integer-Break"><span class="nav-number">209.</span> <span class="nav-text">343. Integer Break</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#347-Top-K-Frequent-Elements"><span class="nav-number">210.</span> <span class="nav-text">347. Top K Frequent Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#352-Data-Stream-as-Disjoint-Intervals"><span class="nav-number">211.</span> <span class="nav-text">352. Data Stream as Disjoint Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#354-Russian-Doll-Envelopes"><span class="nav-number">212.</span> <span class="nav-text">354. Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#357-Count-Numbers-with-Unique-Digits"><span class="nav-number">213.</span> <span class="nav-text">357. Count Numbers with Unique Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#363-Max-Sum-of-Rectangle-No-Larger-Than-K"><span class="nav-number">214.</span> <span class="nav-text">363. Max Sum of Rectangle No Larger Than K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#368-Largest-Divisible-Subset"><span class="nav-number">215.</span> <span class="nav-text">368. Largest Divisible Subset</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#371-Sum-of-Two-Integers"><span class="nav-number">216.</span> <span class="nav-text">371. Sum of Two Integers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#372-Super-Pow"><span class="nav-number">217.</span> <span class="nav-text">372. Super Pow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#373-Find-K-Pairs-with-Smallest-Sums"><span class="nav-number">218.</span> <span class="nav-text">373. Find K Pairs with Smallest Sums</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#375-Guess-Number-Higher-or-Lower-II"><span class="nav-number">219.</span> <span class="nav-text">375. Guess Number Higher or Lower II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#376-Wiggle-Subsequence"><span class="nav-number">220.</span> <span class="nav-text">376. Wiggle Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#377-Combination-Sum-IV"><span class="nav-number">221.</span> <span class="nav-text">377. Combination Sum IV</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#378-Kth-Smallest-Element-in-a-Sorted-Matrix"><span class="nav-number">222.</span> <span class="nav-text">378. Kth Smallest Element in a Sorted Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#381-Insert-Delete-GetRandom-O-1-Duplicates-allowed"><span class="nav-number">223.</span> <span class="nav-text">381. Insert Delete GetRandom O(1) - Duplicates allowed</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#382-Linked-List-Random-Node"><span class="nav-number">224.</span> <span class="nav-text">382. Linked List Random Node</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#386-Lexicographical-Numbers"><span class="nav-number">225.</span> <span class="nav-text">386. Lexicographical Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#387-First-Unique-Character-in-a-String"><span class="nav-number">226.</span> <span class="nav-text">387. First Unique Character in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#390-Elimination-Game"><span class="nav-number">227.</span> <span class="nav-text">390. Elimination Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#392-Is-Subsequence"><span class="nav-number">228.</span> <span class="nav-text">392. Is Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#396-Rotate-Function"><span class="nav-number">229.</span> <span class="nav-text">396. Rotate Function</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#397-Integer-Replacement"><span class="nav-number">230.</span> <span class="nav-text">397. Integer Replacement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#400-Nth-Digit"><span class="nav-number">231.</span> <span class="nav-text">400. Nth Digit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#403-Frog-Jump"><span class="nav-number">232.</span> <span class="nav-text">403. Frog Jump</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#406-Queue-Reconstruction-by-Height"><span class="nav-number">233.</span> <span class="nav-text">406. Queue Reconstruction by Height</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#407-Trapping-Rain-Water-II"><span class="nav-number">234.</span> <span class="nav-text">407. Trapping Rain Water II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#410-Split-Array-Largest-Sum"><span class="nav-number">235.</span> <span class="nav-text">410. Split Array Largest Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#413-Arithmetic-Slices"><span class="nav-number">236.</span> <span class="nav-text">413. Arithmetic Slices</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#414-Third-Maximum-Number"><span class="nav-number">237.</span> <span class="nav-text">414. Third Maximum Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum"><span class="nav-number">238.</span> <span class="nav-text">416. Partition Equal Subset Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow"><span class="nav-number">239.</span> <span class="nav-text">417. Pacific Atlantic Water Flow</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#421-Maximum-XOR-of-Two-Numbers-in-an-Array"><span class="nav-number">240.</span> <span class="nav-text">421. Maximum XOR of Two Numbers in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#424-Longest-Repeating-Character-Replacement"><span class="nav-number">241.</span> <span class="nav-text">424. Longest Repeating Character Replacement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#427-Construct-Quad-Tree"><span class="nav-number">242.</span> <span class="nav-text">427. Construct Quad Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#434-Number-of-Segments-in-a-String"><span class="nav-number">243.</span> <span class="nav-text">434. Number of Segments in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#435-Non-overlapping-Intervals"><span class="nav-number">244.</span> <span class="nav-text">435. Non-overlapping Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#437-Path-Sum-III"><span class="nav-number">245.</span> <span class="nav-text">437. Path Sum III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#440-K-th-Smallest-in-Lexicographical-Order"><span class="nav-number">246.</span> <span class="nav-text">440. K-th Smallest in Lexicographical Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array"><span class="nav-number">247.</span> <span class="nav-text">442. Find All Duplicates in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#446-Arithmetic-Slices-II-Subsequence"><span class="nav-number">248.</span> <span class="nav-text">446. Arithmetic Slices II - Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#448-Find-All-Numbers-Disappeared-in-an-Array"><span class="nav-number">249.</span> <span class="nav-text">448. Find All Numbers Disappeared in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#449-Serialize-and-Deserialize-BST"><span class="nav-number">250.</span> <span class="nav-text">449. Serialize and Deserialize BST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#451-Sort-Characters-By-Frequency"><span class="nav-number">251.</span> <span class="nav-text">451. Sort Characters By Frequency</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#452-Minimum-Number-of-Arrows-to-Burst-Balloons"><span class="nav-number">252.</span> <span class="nav-text">452. Minimum Number of Arrows to Burst Balloons</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#453-Minimum-Moves-to-Equal-Array-Elements"><span class="nav-number">253.</span> <span class="nav-text">453. Minimum Moves to Equal Array Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#456-132-Pattern"><span class="nav-number">254.</span> <span class="nav-text">456. 132 Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#459-Repeated-Substring-Pattern"><span class="nav-number">255.</span> <span class="nav-text">459. Repeated Substring Pattern</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#462-Minimum-Moves-to-Equal-Array-Elements-II"><span class="nav-number">256.</span> <span class="nav-text">462. Minimum Moves to Equal Array Elements II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#463-Island-Perimeter"><span class="nav-number">257.</span> <span class="nav-text">463. Island Perimeter</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#464-Can-I-Win"><span class="nav-number">258.</span> <span class="nav-text">464. Can I Win</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#467-Unique-Substrings-in-Wraparound-String"><span class="nav-number">259.</span> <span class="nav-text">467. Unique Substrings in Wraparound String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#473-Matchsticks-to-Square"><span class="nav-number">260.</span> <span class="nav-text">473. Matchsticks to Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#474-Ones-and-Zeroes"><span class="nav-number">261.</span> <span class="nav-text">474. Ones and Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#475-Heaters"><span class="nav-number">262.</span> <span class="nav-text">475. Heaters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#476-Number-Complement"><span class="nav-number">263.</span> <span class="nav-text">476. Number Complement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#477-Total-Hamming-Distance"><span class="nav-number">264.</span> <span class="nav-text">477. Total Hamming Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#478-Generate-Random-Point-in-a-Circle"><span class="nav-number">265.</span> <span class="nav-text">478. Generate Random Point in a Circle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#480-Sliding-Window-Median"><span class="nav-number">266.</span> <span class="nav-text">480. Sliding Window Median</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#481-Magical-String"><span class="nav-number">267.</span> <span class="nav-text">481. Magical String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#483-Smallest-Good-Base"><span class="nav-number">268.</span> <span class="nav-text">483. Smallest Good Base</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#486-Predict-the-Winner"><span class="nav-number">269.</span> <span class="nav-text">486. Predict the Winner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#491-Increasing-Subsequences"><span class="nav-number">270.</span> <span class="nav-text">491. Increasing Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#493-Reverse-Pairs"><span class="nav-number">271.</span> <span class="nav-text">493. Reverse Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">272.</span> <span class="nav-text">494. Target Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#495-Teemo-Attacking"><span class="nav-number">273.</span> <span class="nav-text">495. Teemo Attacking</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#498-Diagonal-Traverse"><span class="nav-number">274.</span> <span class="nav-text">498. Diagonal Traverse</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#502-IPO"><span class="nav-number">275.</span> <span class="nav-text">502. IPO</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#503-Next-Greater-Element-II"><span class="nav-number">276.</span> <span class="nav-text">503. Next Greater Element II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#504-Base-7"><span class="nav-number">277.</span> <span class="nav-text">504. Base 7</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#513-Find-Bottom-Left-Tree-Value"><span class="nav-number">278.</span> <span class="nav-text">513. Find Bottom Left Tree Value</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#514-Freedom-Trail"><span class="nav-number">279.</span> <span class="nav-text">514. Freedom Trail</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#515-Find-Largest-Value-in-Each-Tree-Row"><span class="nav-number">280.</span> <span class="nav-text">515. Find Largest Value in Each Tree Row</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#516-Longest-Palindromic-Subsequence"><span class="nav-number">281.</span> <span class="nav-text">516. Longest Palindromic Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#517-Super-Washing-Machines"><span class="nav-number">282.</span> <span class="nav-text">517. Super Washing Machines</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#518-Coin-Change-2"><span class="nav-number">283.</span> <span class="nav-text">518. Coin Change 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#523-Continuous-Subarray-Sum"><span class="nav-number">284.</span> <span class="nav-text">523. Continuous Subarray Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#524-Longest-Word-in-Dictionary-through-Deleting"><span class="nav-number">285.</span> <span class="nav-text">524. Longest Word in Dictionary through Deleting</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#525-Contiguous-Array"><span class="nav-number">286.</span> <span class="nav-text">525. Contiguous Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#526-Beautiful-Arrangement"><span class="nav-number">287.</span> <span class="nav-text">526. Beautiful Arrangement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#528-Random-Pick-with-Weight"><span class="nav-number">288.</span> <span class="nav-text">528. Random Pick with Weight</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#540-Single-Element-in-a-Sorted-Array"><span class="nav-number">289.</span> <span class="nav-text">540. Single Element in a Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#546-Remove-Boxes"><span class="nav-number">290.</span> <span class="nav-text">546. Remove Boxes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#547-Friend-Circles"><span class="nav-number">291.</span> <span class="nav-text">547. Friend Circles</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#552-Student-Attendance-Record-II"><span class="nav-number">292.</span> <span class="nav-text">552. Student Attendance Record II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#553-Optimal-Division"><span class="nav-number">293.</span> <span class="nav-text">553. Optimal Division</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#554-Brick-Wall"><span class="nav-number">294.</span> <span class="nav-text">554. Brick Wall</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#556-Next-Greater-Element-III"><span class="nav-number">295.</span> <span class="nav-text">556. Next Greater Element III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#560-Subarray-Sum-Equals-K"><span class="nav-number">296.</span> <span class="nav-text">560. Subarray Sum Equals K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#561-Array-Partition-I"><span class="nav-number">297.</span> <span class="nav-text">561. Array Partition I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#576-Out-of-Boundary-Paths"><span class="nav-number">298.</span> <span class="nav-text">576. Out of Boundary Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#583-Delete-Operation-for-Two-Strings"><span class="nav-number">299.</span> <span class="nav-text">583. Delete Operation for Two Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#594-Longest-Harmonious-Subsequence"><span class="nav-number">300.</span> <span class="nav-text">594. Longest Harmonious Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#600-Non-negative-Integers-without-Consecutive-Ones"><span class="nav-number">301.</span> <span class="nav-text">600. Non-negative Integers without Consecutive Ones</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#605-Can-Place-Flowers"><span class="nav-number">302.</span> <span class="nav-text">605. Can Place Flowers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#611-Valid-Triangle-Number"><span class="nav-number">303.</span> <span class="nav-text">611. Valid Triangle Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#617-Merge-Two-Binary-Trees"><span class="nav-number">304.</span> <span class="nav-text">617. Merge Two Binary Trees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#621-Task-Scheduler"><span class="nav-number">305.</span> <span class="nav-text">621. Task Scheduler</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#662-Maximum-Width-of-Binary-Tree"><span class="nav-number">306.</span> <span class="nav-text">662. Maximum Width of Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#630-Course-Schedule-III"><span class="nav-number">307.</span> <span class="nav-text">630. Course Schedule III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#632-Smallest-Range"><span class="nav-number">308.</span> <span class="nav-text">632. Smallest Range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#638-Shopping-Offers"><span class="nav-number">309.</span> <span class="nav-text">638. Shopping Offers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#646-Maximum-Length-of-Pair-Chain"><span class="nav-number">310.</span> <span class="nav-text">646. Maximum Length of Pair Chain</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#647-Palindromic-Substrings"><span class="nav-number">311.</span> <span class="nav-text">647. Palindromic Substrings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#649-Dota2-Senate"><span class="nav-number">312.</span> <span class="nav-text">649. Dota2 Senate</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#650-2-Keys-Keyboard"><span class="nav-number">313.</span> <span class="nav-text">650. 2 Keys Keyboard</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#652-Find-Duplicate-Subtrees"><span class="nav-number">314.</span> <span class="nav-text">652. Find Duplicate Subtrees</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#654-Maximum-Binary-Tree"><span class="nav-number">315.</span> <span class="nav-text">654. Maximum Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#657-Judge-Route-Circle"><span class="nav-number">316.</span> <span class="nav-text">657. Judge Route Circle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#658-Find-K-Closest-Elements"><span class="nav-number">317.</span> <span class="nav-text">658. Find K Closest Elements</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#659-Split-Array-into-Consecutive-Subsequences"><span class="nav-number">318.</span> <span class="nav-text">659. Split Array into Consecutive Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#664-Strange-Printer"><span class="nav-number">319.</span> <span class="nav-text">664. Strange Printer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#668-Kth-Smallest-Number-in-Multiplication-Table"><span class="nav-number">320.</span> <span class="nav-text">668. Kth Smallest Number in Multiplication Table</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#673-Number-of-Longest-Increasing-Subsequence"><span class="nav-number">321.</span> <span class="nav-text">673. Number of Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#674-Longest-Continuous-Increasing-Subsequence"><span class="nav-number">322.</span> <span class="nav-text">674. Longest Continuous Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#684-Redundant-Connection"><span class="nav-number">323.</span> <span class="nav-text">684. Redundant Connection</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#685-Redundant-Connection-II"><span class="nav-number">324.</span> <span class="nav-text">685. Redundant Connection II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#687-Longest-Univalue-Path"><span class="nav-number">325.</span> <span class="nav-text">687. Longest Univalue Path</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#688-Knight-Probability-in-Chessboard"><span class="nav-number">326.</span> <span class="nav-text">688. Knight Probability in Chessboard</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#670-Maximum-Swap"><span class="nav-number">327.</span> <span class="nav-text">670. Maximum Swap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#678-Valid-Parenthesis-String"><span class="nav-number">328.</span> <span class="nav-text">678. Valid Parenthesis String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#696-Count-Binary-Substrings"><span class="nav-number">329.</span> <span class="nav-text">696. Count Binary Substrings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#698-Partition-to-K-Equal-Sum-Subsets"><span class="nav-number">330.</span> <span class="nav-text">698. Partition to K Equal Sum Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#699-Falling-Squares"><span class="nav-number">331.</span> <span class="nav-text">699. Falling Squares</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#712-Minimum-ASCII-Delete-Sum-for-Two-Strings"><span class="nav-number">332.</span> <span class="nav-text">712. Minimum ASCII Delete Sum for Two Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#713-Subarray-Product-Less-Than-K"><span class="nav-number">333.</span> <span class="nav-text">713. Subarray Product Less Than K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#714-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee"><span class="nav-number">334.</span> <span class="nav-text">714. Best Time to Buy and Sell Stock with Transaction Fee</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#718-Maximum-Length-of-Repeated-Subarray"><span class="nav-number">335.</span> <span class="nav-text">718. Maximum Length of Repeated Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#719-Find-K-th-Smallest-Pair-Distance"><span class="nav-number">336.</span> <span class="nav-text">719. Find K-th Smallest Pair Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#730-Count-Different-Palindromic-Subsequences"><span class="nav-number">337.</span> <span class="nav-text">730. Count Different Palindromic Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#729-My-Calendar-I"><span class="nav-number">338.</span> <span class="nav-text">729. My Calendar I</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#732-My-Calendar-III"><span class="nav-number">339.</span> <span class="nav-text">732. My Calendar III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#735-Asteroid-Collision"><span class="nav-number">340.</span> <span class="nav-text">735. Asteroid Collision</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#738-Monotone-Increasing-Digits"><span class="nav-number">341.</span> <span class="nav-text">738. Monotone Increasing Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#739-Daily-Temperatures"><span class="nav-number">342.</span> <span class="nav-text">739. Daily Temperatures</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#740-Delete-and-Earn"><span class="nav-number">343.</span> <span class="nav-text">740. Delete and Earn</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#743-Network-Delay-Time"><span class="nav-number">344.</span> <span class="nav-text">743. Network Delay Time</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#747-Largest-Number-At-Least-Twice-of-Others"><span class="nav-number">345.</span> <span class="nav-text">747. Largest Number At Least Twice of Others</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#753-Cracking-the-Safe"><span class="nav-number">346.</span> <span class="nav-text">753. Cracking the Safe</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#757-Set-Intersection-Size-At-Least-Two"><span class="nav-number">347.</span> <span class="nav-text">757. Set Intersection Size At Least Two</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#761-Special-Binary-String"><span class="nav-number">348.</span> <span class="nav-text">761. Special Binary String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#763-Partition-Labels"><span class="nav-number">349.</span> <span class="nav-text">763. Partition Labels</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#765-Couples-Holding-Hands"><span class="nav-number">350.</span> <span class="nav-text">765. Couples Holding Hands</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#766-Toeplitz-Matrix"><span class="nav-number">351.</span> <span class="nav-text">766. Toeplitz Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#767-Reorganize-String"><span class="nav-number">352.</span> <span class="nav-text">767. Reorganize String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#768-Max-Chunks-To-Make-Sorted-II"><span class="nav-number">353.</span> <span class="nav-text">768. Max Chunks To Make Sorted II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#769-Max-Chunks-To-Make-Sorted"><span class="nav-number">354.</span> <span class="nav-text">769. Max Chunks To Make Sorted</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#732-My-Calendar-III-1"><span class="nav-number">355.</span> <span class="nav-text">732. My Calendar III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#733-Flood-Fill"><span class="nav-number">356.</span> <span class="nav-text">733. Flood Fill</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#775-Global-and-Local-Inversions"><span class="nav-number">357.</span> <span class="nav-text">775. Global and Local Inversions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#777-Swap-Adjacent-in-LR-String"><span class="nav-number">358.</span> <span class="nav-text">777. Swap Adjacent in LR String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#778-Swim-in-Rising-Water"><span class="nav-number">359.</span> <span class="nav-text">778. Swim in Rising Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#779-K-th-Symbol-in-Grammar"><span class="nav-number">360.</span> <span class="nav-text">779. K-th Symbol in Grammar</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#780-Reaching-Points"><span class="nav-number">361.</span> <span class="nav-text">780. Reaching Points</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#781-Rabbits-in-Forest"><span class="nav-number">362.</span> <span class="nav-text">781. Rabbits in Forest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#785-Is-Graph-Bipartite"><span class="nav-number">363.</span> <span class="nav-text">785. Is Graph Bipartite?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#786-K-th-Smallest-Prime-Fraction"><span class="nav-number">364.</span> <span class="nav-text">786. K-th Smallest Prime Fraction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#790-Domino-and-Tromino-Tiling"><span class="nav-number">365.</span> <span class="nav-text">790. Domino and Tromino Tiling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#795-Number-of-Subarrays-with-Bounded-Maximum"><span class="nav-number">366.</span> <span class="nav-text">795. Number of Subarrays with Bounded Maximum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#796-Rotate-String"><span class="nav-number">367.</span> <span class="nav-text">796. Rotate String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#797-All-Paths-From-Source-to-Target"><span class="nav-number">368.</span> <span class="nav-text">797. All Paths From Source to Target</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#799-Champagne-Tower"><span class="nav-number">369.</span> <span class="nav-text">799. Champagne Tower</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#801-Minimum-Swaps-To-Make-Sequences-Increasing"><span class="nav-number">370.</span> <span class="nav-text">801. Minimum Swaps To Make Sequences Increasing</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#802-Find-Eventual-Safe-States"><span class="nav-number">371.</span> <span class="nav-text">802. Find Eventual Safe States</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#803-Bricks-Falling-When-Hit"><span class="nav-number">372.</span> <span class="nav-text">803. Bricks Falling When Hit</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#805-Split-Array-With-Same-Average"><span class="nav-number">373.</span> <span class="nav-text">805. Split Array With Same Average</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#807-Max-Increase-to-Keep-City-Skyline"><span class="nav-number">374.</span> <span class="nav-text">807. Max Increase to Keep City Skyline</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#808-Soup-Servings"><span class="nav-number">375.</span> <span class="nav-text">808. Soup Servings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#810-Chalkboard-XOR-Game"><span class="nav-number">376.</span> <span class="nav-text">810. Chalkboard XOR Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#813-Largest-Sum-of-Averages"><span class="nav-number">377.</span> <span class="nav-text">813. Largest Sum of Averages</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#814-Binary-Tree-Pruning"><span class="nav-number">378.</span> <span class="nav-text">814. Binary Tree Pruning</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#815-Bus-Routes"><span class="nav-number">379.</span> <span class="nav-text">815. Bus Routes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#818-Race-Car"><span class="nav-number">380.</span> <span class="nav-text">818. Race Car</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#823-Binary-Trees-With-Factors"><span class="nav-number">381.</span> <span class="nav-text">823. Binary Trees With Factors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#826-Most-Profit-Assigning-Work"><span class="nav-number">382.</span> <span class="nav-text">826. Most Profit Assigning Work</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#827-Making-A-Large-Island"><span class="nav-number">383.</span> <span class="nav-text">827. Making A Large Island</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#828-Unique-Letter-String"><span class="nav-number">384.</span> <span class="nav-text">828. Unique Letter String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#829-Consecutive-Numbers-Sum"><span class="nav-number">385.</span> <span class="nav-text">829. Consecutive Numbers Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#834-Sum-of-Distances-in-Tree"><span class="nav-number">386.</span> <span class="nav-text">834. Sum of Distances in Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#835-Image-Overlap"><span class="nav-number">387.</span> <span class="nav-text">835. Image Overlap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#837-New-21-Game"><span class="nav-number">388.</span> <span class="nav-text">837. New 21 Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#838-Push-Dominoes"><span class="nav-number">389.</span> <span class="nav-text">838. Push Dominoes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#840-Magic-Squares-In-Grid"><span class="nav-number">390.</span> <span class="nav-text">840. Magic Squares In Grid</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#841-Keys-and-Rooms"><span class="nav-number">391.</span> <span class="nav-text">841. Keys and Rooms</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#842-Split-Array-into-Fibonacci-Sequence"><span class="nav-number">392.</span> <span class="nav-text">842. Split Array into Fibonacci Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#846-Hand-of-Straights"><span class="nav-number">393.</span> <span class="nav-text">846. Hand of Straights</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#847-Shortest-Path-Visiting-All-Nodes"><span class="nav-number">394.</span> <span class="nav-text">847. Shortest Path Visiting All Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#848-Shifting-Letters"><span class="nav-number">395.</span> <span class="nav-text">848. Shifting Letters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#849-Maximize-Distance-to-Closest-Person"><span class="nav-number">396.</span> <span class="nav-text">849. Maximize Distance to Closest Person</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#851-Loud-and-Rich"><span class="nav-number">397.</span> <span class="nav-text">851. Loud and Rich</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">398.</span> <span class="nav-text">852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#853-Car-Fleet"><span class="nav-number">399.</span> <span class="nav-text">853. Car Fleet</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#854-K-Similar-Strings"><span class="nav-number">400.</span> <span class="nav-text">854. K-Similar Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#855-Exam-Room"><span class="nav-number">401.</span> <span class="nav-text">855. Exam Room</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#856-Score-of-Parentheses"><span class="nav-number">402.</span> <span class="nav-text">856. Score of Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#857-Minimum-Cost-to-Hire-K-Workers"><span class="nav-number">403.</span> <span class="nav-text">857. Minimum Cost to Hire K Workers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#859-Buddy-Strings"><span class="nav-number">404.</span> <span class="nav-text">859. Buddy Strings</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#860-Lemonade-Change"><span class="nav-number">405.</span> <span class="nav-text">860. Lemonade Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#861-Score-After-Flipping-Matrix"><span class="nav-number">406.</span> <span class="nav-text">861. Score After Flipping Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#862-Shortest-Subarray-with-Sum-at-Least-K"><span class="nav-number">407.</span> <span class="nav-text">862. Shortest Subarray with Sum at Least K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#863-All-Nodes-Distance-K-in-Binary-Tree"><span class="nav-number">408.</span> <span class="nav-text">863. All Nodes Distance K in Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#864-Shortest-Path-to-Get-All-Keys"><span class="nav-number">409.</span> <span class="nav-text">864. Shortest Path to Get All Keys</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes"><span class="nav-number">410.</span> <span class="nav-text">865. Smallest Subtree with all the Deepest Nodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#866-Prime-Palindrome"><span class="nav-number">411.</span> <span class="nav-text">866. Prime Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#867-Transpose-Matrix"><span class="nav-number">412.</span> <span class="nav-text">867. Transpose Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#868-Binary-Gap"><span class="nav-number">413.</span> <span class="nav-text">868. Binary Gap</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#869-Reordered-Power-of-2"><span class="nav-number">414.</span> <span class="nav-text">869. Reordered Power of 2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#870-Advantage-Shuffle"><span class="nav-number">415.</span> <span class="nav-text">870. Advantage Shuffle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#871-Minimum-Number-of-Refueling-Stops"><span class="nav-number">416.</span> <span class="nav-text">871. Minimum Number of Refueling Stops</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#873-Length-of-Longest-Fibonacci-Subsequence"><span class="nav-number">417.</span> <span class="nav-text">873. Length of Longest Fibonacci Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#875-Koko-Eating-Bananas"><span class="nav-number">418.</span> <span class="nav-text">875. Koko Eating Bananas</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#877-Stone-Game"><span class="nav-number">419.</span> <span class="nav-text">877. Stone Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#880-Decoded-String-at-Index"><span class="nav-number">420.</span> <span class="nav-text">880. Decoded String at Index</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#881-Boats-to-Save-People"><span class="nav-number">421.</span> <span class="nav-text">881. Boats to Save People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#887-Super-Egg-Drop"><span class="nav-number">422.</span> <span class="nav-text">887. Super Egg Drop</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal"><span class="nav-number">423.</span> <span class="nav-text">889. Construct Binary Tree from Preorder and Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#896-Monotonic-Array"><span class="nav-number">424.</span> <span class="nav-text">896. Monotonic Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#897-Increasing-Order-Search-Tree"><span class="nav-number">425.</span> <span class="nav-text">897. Increasing Order Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#898-Bitwise-ORs-of-Subarrays"><span class="nav-number">426.</span> <span class="nav-text">898. Bitwise ORs of Subarrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#899-Orderly-Queue"><span class="nav-number">427.</span> <span class="nav-text">899. Orderly Queue</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#901-Online-Stock-Span"><span class="nav-number">428.</span> <span class="nav-text">901. Online Stock Span</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#903-Valid-Permutations-for-DI-Sequence"><span class="nav-number">429.</span> <span class="nav-text">903. Valid Permutations for DI Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#905-Sort-Array-By-Parity"><span class="nav-number">430.</span> <span class="nav-text">905. Sort Array By Parity</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#931-Minimum-Falling-Path-Sum"><span class="nav-number">431.</span> <span class="nav-text">931. Minimum Falling Path Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#950-Reveal-Cards-In-Increasing-Order"><span class="nav-number">432.</span> <span class="nav-text">950. Reveal Cards In Increasing Order</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#962-Maximum-Width-Ramp"><span class="nav-number">433.</span> <span class="nav-text">962. Maximum Width Ramp</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1011-Capacity-To-Ship-Packages-Within-D-Days"><span class="nav-number">434.</span> <span class="nav-text">1011. Capacity To Ship Packages Within D Days</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1012-Numbers-With-Repeated-Digits"><span class="nav-number">435.</span> <span class="nav-text">1012. Numbers With Repeated Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1013-Partition-Array-Into-Three-Parts-With-Equal-Sum"><span class="nav-number">436.</span> <span class="nav-text">1013. Partition Array Into Three Parts With Equal Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1014-Best-Sightseeing-Pair"><span class="nav-number">437.</span> <span class="nav-text">1014. Best Sightseeing Pair</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1027-Longest-Arithmetic-Sequence"><span class="nav-number">438.</span> <span class="nav-text">1027. Longest Arithmetic Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1036-Escape-a-Large-Maze"><span class="nav-number">439.</span> <span class="nav-text">1036. Escape a Large Maze</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1049-Last-Stone-Weight-II"><span class="nav-number">440.</span> <span class="nav-text">1049. Last Stone Weight II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1054-Distant-Barcodes"><span class="nav-number">441.</span> <span class="nav-text">1054. Distant Barcodes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1079-Letter-Tile-Possibilities"><span class="nav-number">442.</span> <span class="nav-text">1079. Letter Tile Possibilities</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1092-Shortest-Common-Supersequence"><span class="nav-number">443.</span> <span class="nav-text">1092. Shortest Common Supersequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1103-Distribute-Candies-to-People"><span class="nav-number">444.</span> <span class="nav-text">1103. Distribute Candies to People</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1115-Print-FooBar-Alternately"><span class="nav-number">445.</span> <span class="nav-text">1115. Print FooBar Alternately</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1116-Print-Zero-Even-Odd"><span class="nav-number">446.</span> <span class="nav-text">1116. Print Zero Even Odd</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1123-Lowest-Common-Ancestor-of-Deepest-Leaves"><span class="nav-number">447.</span> <span class="nav-text">1123. Lowest Common Ancestor of Deepest Leaves</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1124-Longest-Well-Performing-Interval"><span class="nav-number">448.</span> <span class="nav-text">1124. Longest Well-Performing Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1125-Smallest-Sufficient-Team"><span class="nav-number">449.</span> <span class="nav-text">1125. Smallest Sufficient Team</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1130-Minimum-Cost-Tree-From-Leaf-Values"><span class="nav-number">450.</span> <span class="nav-text">1130. Minimum Cost Tree From Leaf Values</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1143-Longest-Common-Subsequence"><span class="nav-number">451.</span> <span class="nav-text">1143. Longest Common Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1155-Number-of-Dice-Rolls-With-Target-Sum"><span class="nav-number">452.</span> <span class="nav-text">1155. Number of Dice Rolls With Target Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1222-Queens-That-Can-Attack-the-King"><span class="nav-number">453.</span> <span class="nav-text">1222. Queens That Can Attack the King</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1227-Airplane-Seat-Assignment-Probability"><span class="nav-number">454.</span> <span class="nav-text">1227. Airplane Seat Assignment Probability</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1232-Check-If-It-Is-a-Straight-Line"><span class="nav-number">455.</span> <span class="nav-text">1232. Check If It Is a Straight Line</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1239-Maximum-Length-of-a-Concatenated-String-with-Unique-Characters"><span class="nav-number">456.</span> <span class="nav-text">1239. Maximum Length of a Concatenated String with Unique Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1262-Greatest-Sum-Divisible-by-Three"><span class="nav-number">457.</span> <span class="nav-text">1262. Greatest Sum Divisible by Three</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1291-Sequential-Digits"><span class="nav-number">458.</span> <span class="nav-text">1291. Sequential Digits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1298-Maximum-Candies-You-Can-Get-from-Boxes"><span class="nav-number">459.</span> <span class="nav-text">1298. Maximum Candies You Can Get from Boxes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1314-Matrix-Block-Sum"><span class="nav-number">460.</span> <span class="nav-text">1314. Matrix Block Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1334-Find-the-City-With-the-Smallest-Number-of-Neighbors-at-a-Threshold-Distance"><span class="nav-number">461.</span> <span class="nav-text">1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1338-Reduce-Array-Size-to-The-Half"><span class="nav-number">462.</span> <span class="nav-text">1338. Reduce Array Size to The Half</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1354-Construct-Target-Array-With-Multiple-Sums"><span class="nav-number">463.</span> <span class="nav-text">1354. Construct Target Array With Multiple Sums</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2017/02/09/LeetCode解题报告/';
          this.page.identifier = '2017/02/09/LeetCode解题报告/';
          this.page.title = 'Leetcode解题报告';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
