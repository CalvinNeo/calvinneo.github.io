<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="ACM,字符串," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode解题报告">
<meta property="og:url" content="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/index.html">
<meta property="og:site_name" content="Calvin's Marbles">
<meta property="og:description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta property="og:image" content="http://www.calvinneo.com/img/leetcode/3sum_tle.png">
<meta property="og:image" content="http://www.calvinneo.com/img/leetcode/mergek_tle.png">
<meta property="og:updated_time" content="2018-03-17T11:01:21.712Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leetcode解题报告">
<meta name="twitter:description" content="寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在GitHub上，有些被坑的题目会专门写一篇post。必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相">
<meta name="twitter:image" content="http://www.calvinneo.com/img/leetcode/3sum_tle.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/"/>





  <title>Leetcode解题报告 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2017/02/09/LeetCode解题报告/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Leetcode解题报告
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T00:01:30+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/09/LeetCode解题报告/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/02/09/LeetCode解题报告/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>寒假没事情，在家里刷Leetcode。这里放的是LeetCode解题报告【更新中】，代码在<a href="https://github.com/CalvinNeo/LeetCode" target="_blank" rel="external">GitHub上</a>，有些被坑的题目会专门写一篇post。<br>必须先对Leetcode吐个槽，这复杂度卡的真是魔幻，同样的复杂度C++能过，Python就不能过，而且都是卡在最后两三个样例上（不会就最后两三个大数据吧？）<br>Leetcode上面有题解，不过有时候很奇怪他们算复杂度的时候会强行令某些操作，比如判断字符串是否相等(Problem 14)，<code>std::map</code>查找元素(Problem 1)的复杂度为1，感觉这并不是很严谨的，后来在Google Codejam/Kickstart的官方题解上也看到类似的算法，只能说这是一种计算方式吧。<br>在刷Leetcode的时候，取得Accepted通常是容易的，但是如果能够翻翻Submissions里面速度靠前的答案，看看人家是怎么在同复杂度下进行常数优化也是很有必要的。</p>
<a id="more"></a>
<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><p>$O(n^2)$要T的，正解对任意的<code>i</code>，判断<code>target - i</code>是否在集合<code>s</code>中，如果不在，把<code>i</code>加到集合<code>s</code>中。注意因为Python中<code>dict</code>用散列表实现，所以查询复杂是$O(1)$的，这和C++中的<code>std::map</code>（RBT实现）不一样。<br>另外考虑如果给定数列是<strong>有序</strong>的，还可以使用二指针来做。测试了一下，如果对这道题先sort一下，居然速度要快十倍。</p>
<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2. Add Two Numbers"></a>2. Add Two Numbers</h1><p>链表比较麻烦，注意在两个链表全部遍历完毕后检查是否还有进位</p>
<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3. Longest Substring Without Repeating Characters"></a>3. Longest Substring Without Repeating Characters</h1><p>计算最长不重复子串<br>从头开始遍历字符串<code>S</code>，记录字符<code>S[i]</code>出现位置到<code>ex</code>中。若<code>ex[S[i]]</code>已存在，即字符<code>S[i]</code>在<code>ex[S[i]]</code>（前出现）和<code>i</code>（后出现）出现过，这时候我们的最长长度便不能继续增长了，尝试用字符串<code>S[start, i - 1]</code>来更新最长字符串，并令<code>start = ex[S[i]] + 1</code>，即从<code>S[i]</code>前出现的下一个位置开始重新计算最长长度。这时相当于把字符<code>S[i]</code>从前出现移到了后出现，因此<code>ex[S[i]]</code>需要被更新到当前的<code>i</code>。<br>有个注意点，在更新<code>start</code>的过程中，我们实际上重复利用了<code>[ex[S[i]] + 1, i]</code>这段肯定不重复的序列，包括它们的<code>ex</code>值，但同时我们也舍弃了<code>[start(原), ex[S[i]]]</code>这区间，因此在下面的遍历过程中如果字符<code>ch</code>对应的<code>ex[ch]</code>值出现在这段区间中，那实际上应该等同于它未出现处理。</p>
<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4. Median of Two Sorted Arrays"></a>4. Median of Two Sorted Arrays</h1><p>见<a href="/2017/02/04/Leetcode4_Median_of_Two_Sorted_Arrays/">文章</a></p>
<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5. Longest Palindromic Substring"></a>5. Longest Palindromic Substring</h1><p><a href="/2017/08/11/Manacher算法/">马拉车算法模板题</a></p>
<h1 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6. ZigZag Conversion"></a>6. ZigZag Conversion</h1><p>对模<code>numRows * 2 - 2</code>讨论</p>
<h1 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7. Reverse Integer"></a>7. Reverse Integer</h1><p>python转成string在转回int强行干</p>
<h1 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8. String to Integer (atoi)"></a>8. String to Integer (atoi)</h1><p>看图说话题</p>
<h1 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9. Palindrome Number"></a>9. Palindrome Number</h1><p>通过整除和取余算出倒过来的数，比较和原来的数是否相等</p>
<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><p>编译原理复习题，撸个DFA。这里注意一下对<code>.</code>规则的处理，虽然NFA比DFA多了ε规则，但是NFA对于一个某个输入符号的下一个状态是确定的。而对于<code>.*c</code>这样的规则，如果读取到c，那么可以仍然在本状态，也可以通过c到下一个状态，因此是冲突的，要向前看一个字符。在本题中因为字母表就在<code>[a-z]</code>上，于是添加26条规则就可以了。<br>实际上可以DP搞</p>
<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><p>WA了n次，原来是和<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="external">HDU1506直方图中最大的矩形面积</a>搞混掉了，这个不要求连续。<br>不会O(n)算法，看了答案发现也是DP。主要原理是对于令<code>i, j</code>分别为数组的左右边界，显然这样的容器最宽。把<code>i, j</code>相对移动，要想还比它容积大，就要比它高。于是对于任意的<code>ii, jj</code>，如果<code>height[ii] &lt;= height[i]</code>或<code>height[jj] &lt;= height[j]</code>那就不行了。注意不是<code>height[i + 1] &lt; height[i]</code>，这样遇到两个都不满足的情况就死循环了。</p>
<h1 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14. Longest Common Prefix"></a>14. Longest Common Prefix</h1><p>看名字想到后缀数组，然而并不是。直接O(nm)暴力就可以了，也可以用二分，还不如直接暴力</p>
<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><p>乍一看以为是01背包，然而并不是，看题目应该是和第一条类似，暴力就行了。于是照搬第一条撸了个$O(n^2)$的交上去，居然T了，看了一下T在倒数第二个点，卧槽还卡常啊。<br>查看题解，把对<code>j</code>的循环和仿照2Sum的使用<code>dict</code>查<code>k</code>去掉改成双指针夹逼法。这个方法在于遍历每个<code>i</code>，然后对剩下的两个数<code>j</code>和<code>k</code>从<code>j = i + 1</code>，<code>k = n - 1</code>开始相向搜索。<br>不过这次还是还是超时，根据<a href="https://leetcode.com/problems/3sum/?tab=Solutions" target="_blank" rel="external">这里的解释：But according to my submissions, this way will cause you double your time consuming almostly.</a>，可能是我取unique拖慢了（然而排序后求unique是O(n)的啊）<br>放一张图<br><img src="/img/leetcode/3sum_tle.png" alt=""></p>
<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16. 3Sum Closest"></a>16. 3Sum Closest</h1><p>这k-Sum的题目没完没了了。这道题也是先排序，然后双指针，同时维护一个<code>best</code>表示最优解</p>
<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><p>直接暴力模</p>
<h1 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h1><p>先放这儿吧。。</p>
<h1 id="19-Remove-Nth-Node-From-End-of-List"><a href="#19-Remove-Nth-Node-From-End-of-List" class="headerlink" title="19. Remove Nth Node From End of List"></a>19. Remove Nth Node From End of List</h1><p>链表的基本操作，维护<code>[before, begin, end]</code>三个指针即可，注意head被删除的情况。</p>
<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><p>开一个栈维护就行了，注意pop的时候要先判断是不是空栈</p>
<h1 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21. Merge Two Sorted Lists"></a>21. Merge Two Sorted Lists</h1><p>归并两个数列，手残忘了<code>cur = cur.next</code>，然后又RE了，原来是<a href="https://www.douban.com/note/578832769/" target="_blank" rel="external">注释的预定义部分自己不要附上去</a></p>
<h1 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22. Generate Parentheses"></a>22. Generate Parentheses</h1><p>卡塔兰数<code>C(n)</code>也表示所有在<code>n*n</code>格点中不越过对角线的单调路径的个数，所以直接递归搜索就全部能列出来。</p>
<h1 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23. Merge k Sorted Lists"></a>23. Merge k Sorted Lists</h1><p>一开始是硬上21条的解法，结果T了。假设n个列表中总共有p个元素，那么外层的<code>while</code>循环一次添加一个元素，共<code>O(p)</code>次，内层的<code>for</code>循环是一趟n次。这种算法复杂度上限是<code>O(p*n)</code>。<br>Leetcode上的<a href="https://discuss.leetcode.com/topic/6882/sharing-my-straightforward-c-solution-without-data-structure-other-than-vector/2" target="_blank" rel="external">top解法</a>是(C++)调用<code>n-1</code>次的<code>MergeTwoList</code>，归并一次的复杂度是两个列表长度之和，所以这种复杂度上限依然是<code>O(p*n)</code>。以上两种做法Python全被卡常卡掉了（而且卡在最有一个样例，那你告诉我为啥你不也把C++卡掉）。<br><img src="/img/leetcode/mergek_tle.png" alt=""><br>正解是二分分治对这<code>k</code>个<code>List</code>归并，这样可以优化到<code>O(p*logn)</code>的复杂度。<br>另外也有大佬直接上堆排了，我也是服</p>
<h1 id="24-Swap-Nodes-in-Pairs"><a href="#24-Swap-Nodes-in-Pairs" class="headerlink" title="24. Swap Nodes in Pairs"></a>24. Swap Nodes in Pairs</h1><p>又是链表题，直接记录<code>[before, begin, end]</code>交换就行了。标算是递归，我用的迭代，迭代在更新<code>end</code>时要注意<code>begin</code>为<code>None</code>的情况</p>
<h1 id="25-Reverse-Nodes-in-k-Group"><a href="#25-Reverse-Nodes-in-k-Group" class="headerlink" title="25. Reverse Nodes in k-Group"></a>25. Reverse Nodes in k-Group</h1><p>链表逆置问题</p>
<h1 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h1><p>两个指针，<code>i</code>用来遍历，<code>j</code>用来维护插入位置即可，注意到<code>i</code>始终是要比<code>j</code>快的，所以不会产生覆盖的问题</p>
<h1 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h1><p>同26</p>
<h1 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29. Divide Two Integers"></a>29. Divide Two Integers</h1><p>不使用乘除和模实现整数除法，这里也不使用加减法</p>
<h2 id="使用位运算实现整数加减法"><a href="#使用位运算实现整数加减法" class="headerlink" title="使用位运算实现整数加减法"></a>使用位运算实现整数加减法</h2><p>两个比特$x (b)$和$y (b)$相加，结果需要两个比特来盛放，可能为$00 (b)$、$01 (b)$、$10 (b)$。注意到高位的比特值为$x \, and \, y$的结果，而低位的比特值为$x \, xor \, y$的结果，于是整个结果是$(x \, xor \, y) \, or \, (x \, and \, y)$</p>
<p>减去一个数等于加上这个数的补码</p>
<h2 id="使用加减运算实现整数除法"><a href="#使用加减运算实现整数除法" class="headerlink" title="使用加减运算实现整数除法"></a>使用加减运算实现整数除法</h2><p>这里需要使用快速幂的思想，减去小于被减数$a$的尽可能大的$b \times 2^n$。这里注意的是Python中的<code>Integer</code>是没有范围的，所以不能使用补码等运算，对于溢出的情况也要专门判断。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return min(<span class="name">max</span>(<span class="name">-2147483648</span>, res), <span class="number">2147483647</span>)</div></pre></td></tr></table></figure>
<h1 id="31-Next-Permutation"><a href="#31-Next-Permutation" class="headerlink" title="31. Next Permutation"></a>31. Next Permutation</h1><p>在我的某篇文章里讲过直接求<a href="/2016/11/07/POJ1037/">nth perm</a>的做法<br>这道题目首先是找规律，还是挺有意思的。我们从倒数第二个数开始倒序取<code>i</code>，不断尝试把<code>nums[i]</code>与其后面满足<code>nums[j] &gt; nums[i]</code>的最小的<code>nums[j]</code>交换。实际上我们要一个在尾部的最长的下降序列<code>[i-1, end)</code>。我们应当从尾到头找，因为<code>i</code>位置后数列一定是降序的，否则<code>i + 1</code>位置时算法就应当结束了。交换完后，我们将<code>i</code>位置后的序列片段按升序排列好（这时候该片段是最小的）便得到了最终答案。如果没有的话我们令<code>i--</code>继续循环。</p>
<p>此外，Python2里面的list切片是返回的一个新list而不是引用，写代码的时候被坑了次。</p>
<h1 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32. Longest Valid Parentheses"></a>32. Longest Valid Parentheses</h1><p>好像17年哪个公司的笔试题里面出现过这一条的。<br>简单的思考了下，这条是DP。我们令<code>dp[i]</code>表示字符串在<code>i</code>位置最长括号串的左边界，初始化为<code>dp = range(i)</code>。因此对于每一个<code>s[i] = &#39;)&#39;</code>，我们从<code>j = i - 1</code>开始根据<code>dp[j]</code>往前跳转，直到<code>dp[j] == j</code>，此时我们看<code>s[j]</code>是否为<code>&#39;(&#39;</code>即可。注意最后还要根据<code>dp</code>算一个<code>ans</code>，否则<code>()()</code>这种情况就是2而不是4了。<br>写的时候很粗心，WA了n次。</p>
<h1 id="33-Search-in-Rotated-Sorted-Array"><a href="#33-Search-in-Rotated-Sorted-Array" class="headerlink" title="33. Search in Rotated Sorted Array"></a>33. Search in Rotated Sorted Array</h1><p>先二分一次找到第一个比<code>arr[0]</code>小的点，也就是唯一一个下降点，以此点将串一分为二，对两边数组分别进行二分</p>
<h1 id="34-Search-for-a-Range"><a href="#34-Search-for-a-Range" class="headerlink" title="34. Search for a Range"></a>34. Search for a Range</h1><p>同样是二分两次，第一次找到最左边边界，第二次找到最右边边界</p>
<h1 id="35-Search-Insert-Position"><a href="#35-Search-Insert-Position" class="headerlink" title="35. Search Insert Position"></a>35. Search Insert Position</h1><p>简单的二分</p>
<h1 id="37-Sudoku-Solver"><a href="#37-Sudoku-Solver" class="headerlink" title="37. Sudoku Solver"></a>37. Sudoku Solver</h1><p>使用回朔法求解，<a href="https://github.com/CalvinNeo/sudoku_solver" target="_blank" rel="external">代码修改自我的github</a><br>在修改代码时类<code>back_solver</code>方法和里面的<code>solve_iter</code>在返回结果<code>res</code>时出现了为None的问题，后通过改为<code>self.res</code>解决。</p>
<h1 id="39-Combination-Sum"><a href="#39-Combination-Sum" class="headerlink" title="39. Combination Sum"></a>39. Combination Sum</h1><p>dfs即可</p>
<h1 id="40-Combination-Sum-II"><a href="#40-Combination-Sum-II" class="headerlink" title="40. Combination Sum II"></a>40. Combination Sum II</h1><p>解法类似，这次每个数只能使用若干次</p>
<h1 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41. First Missing Positive"></a>41. First Missing Positive</h1><p>在一个无序列表中找第一个没有出现的正整数。<br>这是一个很有意思的桶排序的题目。遍历数组，使用$h(x) = x - 1$将值为$x$($0 &lt; x &lt; length$)的数与$x - 1$位置上的数进行交换，这样经过$O(n)$后数组便会变成有序的。</p>
<h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><p>看上去类似于第11题。<br>首先先想naive的$n^2$解法，对于每一个位置<code>i</code>，分别寻找其左右侧最高的柱子<code>l[i]</code>和<code>r[i]</code>，那么<code>i</code>处水柱的“海拔”是<code>min(l[i], r[i])</code>。显然我们发现寻找左右侧最高的柱子这个过程可以DP。<br>下面使用<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="external">HDU1506直方图中最大的矩形面积</a>的方法进行dp优化。其原理是如果<code>j+1</code>处水柱比<code>j</code>处的高，那么它肯定比<code>r[j+1]</code>处水柱高。</p>
<h1 id="44-Wildcard-Matching"><a href="#44-Wildcard-Matching" class="headerlink" title="44. Wildcard Matching"></a>44. Wildcard Matching</h1><p>类似第10题，可以通过DFA来做。这里使用DP来做</p>
<h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><p>青蛙跳，不禁想起悲惨的LCM Walk推公式题。<br>记到<code>i</code>点的最少步数是<code>l[i]</code>，这条naive的方法自然是对于每一个<code>i</code>，用它来尝试更新自己的跳跃距离范围<code>[i, i + nums[i]]</code>内的所有的<code>l[j]</code>，但这样会超时。<br>查看题解，实际上这是一个贪心问题，我们使用<code>l</code>记录跳<code>s</code>步达到的最远距离，这说明数组<strong>整个</strong><code>[0..l]</code>片段<strong>至多<code>s</code>步</strong>便能到达。使用<code>r</code>记录跳<code>s + 1</code>步达到的最远距离，显然<code>r &gt; l</code>。<br>下面我们对于每一个<code>i</code>，查看它需要用几步才能到达，期间需要同步更新<code>l</code>和<code>r</code>：</p>
<ol>
<li><p>正常情况<br>如果说<code>i</code>小于等于<code>l</code>，这说明<code>i</code>肯定是能够在<code>s</code>步内达到的。<br>下面我们要尝试更新<code>r</code>。<code>i</code>位置能够达到的最远范围是<code>nums[i] + i</code>，这说明如果我们在<code>s + 1</code>选择在<code>i</code>位置跳，那么能够<strong>覆盖<code>[i, i + nums[i]]</code></strong>这段距离。因为<code>i &lt; l</code>，所以在<code>i</code>位置跳能够覆盖<code>[0, i + nums[i]]</code>这段距离，我们用它和<code>r</code>取大值来更新<code>r</code>，如果需要记录起跳点<code>p[s + 1]</code>，这时候也应当同时使用<code>i</code>比较更新。</p>
</li>
<li><p>额外情况<br>如果<code>i</code>大于<code>l</code>，即跳<code>s</code>步<strong>肯定</strong>不能达到了，就必须多跳一步了，此时总步数变为<code>s + 1</code>。<br>这种情况是可能发生的，虽然我们遍历<code>i</code>是一次一格，跳是一次若干格，但遍历到<code>i</code>时可能已跳次数<code>s</code>远少于<code>i</code>。<br>我们来看看跳完这<code>s + 1</code>步后能够达到的最远距离是什么呢？答案是<code>i - 1</code>位置时的范围<code>[0, r]</code>，起跳点<code>p[s + 1]</code>在小于等于<code>i - 1</code>的某处。如果<code>r &lt; i</code>的话，那么终点便是不可达的，但题目中保证了终点可达。所以我们用<code>r</code>来更新<code>l</code>。<br>接下来，<code>i</code>小于等于<code>l</code>，我们按照正常情况继续处理。</p>
</li>
</ol>
<h1 id="46-Permutations"><a href="#46-Permutations" class="headerlink" title="46. Permutations"></a>46. Permutations</h1><h1 id="47-Permutations-II"><a href="#47-Permutations-II" class="headerlink" title="47. Permutations II"></a>47. Permutations II</h1><p>我这里使用了字典来维护重复的数，在Leetcode里面我看到了一个较为巧妙的处理重复的方法<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">length</span>;i++)&#123;</div><div class="line">	<span class="keyword">if</span>(used[i]) <span class="keyword">continue</span>;</div><div class="line">	<span class="comment">// 在同一个循环里面，如果i位置的值和i-1位置的值相同，而i-1位置的数没有被使用，那么i位置肯定也不会被使用</span></div><div class="line">	<span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>]==nums[i] &amp;&amp; !used[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</div></pre></td></tr></table></figure></p>
<h1 id="48-Rotate-Image"><a href="#48-Rotate-Image" class="headerlink" title="48. Rotate Image"></a>48. Rotate Image</h1><p>这让人联想到$O(1)$空间转置矩阵的题目，但本题是顺时针旋转而不是转置。<br>由旋转公式得$ \begin{bmatrix} x \\ y \end{bmatrix} $变成$ \begin{bmatrix} y \\ -x \end{bmatrix} $。如果把这个变换看成两个变换的组合，第一个是关于次对角线的对折，第二个是关于横轴的对折，那么代码会更容易写，因为不要想inplace矩阵转置一样需要考虑一个链的问题了。<br>这里注意一下python的列表生成器可以使用两个循环变量，如<code>[(x, y) for x in xrange(m) for y in xrange(m - x)]</code>，但注意<code>x</code>一定要在使用前有定义。<br>本题也可以使用矩阵转置的方法来做。以3行3列的矩阵为例，将其按行展开为一维数组。得到三条变换链：0-2-8-6-0、1-5-7-3-1、4-4。容易发现对于每个链，我们用前一个位置的值给后一个位置赋值即可，如2号位的新值为0号位的旧值。不过我们还要防止重复遍历链，例如我们首先以0号位为链头遍历完第一条链，以1号位为链头遍历完第二条链，但是位置2已经在第一条链中遍历过了。为了解决这个问题，我们在位置<code>i</code>处要确定是否要以这个位置作为新链的链头，例如我们以2位链头开始遍历，发现在2-8-6-0-2的序列中出现了位置0是小于2的，这种情况是不可能的。容易发现每条链的链头都是这条链中位置号最小的元素，这是因为我们是从0开始按顺序以每个位置作为链头的。</p>
<h1 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49. Group Anagrams"></a>49. Group Anagrams</h1><p>Anagrams指的是将原单词或短语字母打乱顺序，形成新的单词或短语，如“Tom Marvolo Riddle”变成“I am Lord Voldemort”<br>这道题将单词的每个字母sort作为key，然后用dict记录每个key拥有的所有单词，最后遍历输出即可。</p>
<h1 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a>50. Pow(x, n)</h1><p>快速幂模板题</p>
<h1 id="51-N-Queens"><a href="#51-N-Queens" class="headerlink" title="51. N-Queens"></a>51. N-Queens</h1><p>在<a href="http://paste.ubuntu.com/25416005/" target="_blank" rel="external">Submission</a>里面看到有人用位运算（因为Python里面int无限大所以都不需要bitset）来搞的</p>
<h1 id="52-N-Queens-II"><a href="#52-N-Queens-II" class="headerlink" title="52. N-Queens II"></a>52. N-Queens II</h1><p>受上题影响这次用位运算搞一波<br>首先同样是按行搜索，每一行尝试放一枚棋子，递归深度$O(n)$。</p>
<h1 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53. Maximum Subarray"></a>53. Maximum Subarray</h1><p>这是一个经典的动态规划问题。由于在每一点<code>i</code>都可以选择继续延伸之前的串（其和为<code>acc</code>）或者打断重新开始。明显当<code>acc + nums[i] &gt;= 0</code>时保留之前的串是有增益的，否则就打断重来。使用<code>m</code>维护历史上最长的串的长度。</p>
<h1 id="54-Spiral-Matrix"><a href="#54-Spiral-Matrix" class="headerlink" title="54. Spiral Matrix"></a>54. Spiral Matrix</h1><p>这条题目我思路不够清晰，主要是找规律发现数列<code>+(n-1), +(m-1), -(n-1), -(m-2), +(n-2), -(m-3), -(n-3), ...</code>，对第0项特别处理，然后<code>x</code>、<code>y</code>往下递推即可。<br>查看题解发现思路更便捷一点，它的想法是依次循环将最上、最右、最下、最左的行/列添加入<code>ans</code>数组中，每次添加完后更新指针。终止条件是上下界或者左右界溢出。<br>在discuss里面还看到一个骚气的Python解法，这个感觉就像我们把梨子拿在手上一边转一边削梨子一样<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(<span class="keyword">self</span>, matrix)</span></span>:</div><div class="line">    <span class="keyword">return</span> matrix <span class="keyword">and</span> list(matrix.pop(<span class="number">0</span>)) + <span class="keyword">self</span>.spiralOrder(zip(*matrix)[<span class="symbol">:</span><span class="symbol">:-</span><span class="number">1</span>])</div></pre></td></tr></table></figure></p>
<p>这里似乎在Python二维数组切片上遇到了坑，对二维数组<code>a</code>进行数组切片<code>a[1:2][0]</code>返回的是一个二维数组，而不是一维数组。</p>
<h1 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55. Jump Game"></a>55. Jump Game</h1><p>同45</p>
<h1 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56. Merge Intervals"></a>56. Merge Intervals</h1><p>首先是区间合并的原理，假设两个区间$(l, r)$和$(l2, r2)$，令$l2 \ge l$，则当$r \ge l2 \ge e$时区间能够合并。<br>因此，首先对<code>intervals</code>数组按照左边界大小排序，然后从头开始遍历该数组，每次试图运用上面的规则合并区间。如果不满足上面的规则，那么先前已合并了的区间就是最大的区间了，将其添加入结果数组中，并对下面的数组重新开始运用该规则。</p>
<h1 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57. Insert Interval"></a>57. Insert Interval</h1><h1 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58. Length of Last Word"></a>58. Length of Last Word</h1><p>简单题，注意要strip下</p>
<h1 id="59-Spiral-Matrix-II"><a href="#59-Spiral-Matrix-II" class="headerlink" title="59. Spiral Matrix II"></a>59. Spiral Matrix II</h1><h1 id="60-Permutation-Sequence"><a href="#60-Permutation-Sequence" class="headerlink" title="60. Permutation Sequence"></a>60. Permutation Sequence</h1><p>类似<code>next_permulation</code>函数，见<a href="/2016/11/07/POJ1037/">POJ 1037这篇文章</a></p>
<h1 id="61-Rotate-List"><a href="#61-Rotate-List" class="headerlink" title="61. Rotate List"></a>61. Rotate List</h1><p>链表题，看图说话</p>
<h1 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62. Unique Paths"></a>62. Unique Paths</h1><p><code>m - 1</code>个向右和<code>n - 1</code>个向下自由排列共有$\frac{(m + n - 2)!}{(m - 1)! (n - 1)!} $中方案</p>
<h1 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63. Unique Paths II"></a>63. Unique Paths II</h1><p>二维dp模板题<br>注意初始化二维数组时不要犯<code>[[0] * 5] * 3</code>的常见错误，最好用列表生成器</p>
<h1 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66. Plus One"></a>66. Plus One</h1><p>处理一下进位即可</p>
<h1 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67. Add Binary"></a>67. Add Binary</h1><p>见29</p>
<h1 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69. Sqrt(x)"></a>69. Sqrt(x)</h1><p>二分即可，注意取整</p>
<h1 id="70-Climbing-Stairs"><a href="#70-Climbing-Stairs" class="headerlink" title="70. Climbing Stairs"></a>70. Climbing Stairs</h1><p>第<code>i</code>级可以从第<code>i - 1</code>级过来，也可以从第<code>i - 2</code>级过来</p>
<h1 id="72-Edit-Distance"><a href="#72-Edit-Distance" class="headerlink" title="72. Edit Distance"></a>72. Edit Distance</h1><p>DP是肯定的，定义数组<code>dp[m][n]</code>，<code>dp[i][j]</code>表示<code>word1[1..i]</code>和<code>word2[1..j]</code>的编辑距离，从1开始方便后面边界。<br>首先要先确定添加、删除和替换三个操作对应到状态转移上，这容易想到对于<code>word1</code>来说，删除<code>i</code>位置意味着忽略<code>i</code>位置对结果的<code>dp[i][j]</code>的影响，所以是 <code>dp[i-1][j] + 1</code>，其中<code>+ 1</code>是删除的成本。其他两个操作可依次得出。<strong>当<code>word1[i-1] == word2[j-1]</code>时<code>dp[i][j] = dp[i-1][j-1]</code>不能漏掉</strong>。<br>然后还要确定递归边界，不只是<code>dp[0][0] = 0</code>了，也要设定<code>dp[i][0]</code>和<code>dp[0][j]</code></p>
<h1 id="73-Set-Matrix-Zeroes"><a href="#73-Set-Matrix-Zeroes" class="headerlink" title="73. Set Matrix Zeroes"></a>73. Set Matrix Zeroes</h1><p>根据Follow up的要求，一个使用$O(mn)$的方法是遍历一遍<code>matrix</code>，然后将0的格子全部填好，最后and下<br>一个使用$O(m+n)$空间的方法是遍历一遍<code>matrix</code>，然后对每个0格子，标记其行号和列号，最后把所有的被标记行列全部置零<br>最好的是$O(1)$方法，把这$O(m+n)$的空间移到<code>matrix</code>的第0行和第0列上。注意整个过程不是迭代的，如果一个格子被设为0，它不可以再将自己所在行列设为0。特别是第0行列的清空工作一定要在最后完成。</p>
<h1 id="74-Search-a-2D-Matrix"><a href="#74-Search-a-2D-Matrix" class="headerlink" title="74. Search a 2D Matrix"></a>74. Search a 2D Matrix</h1><p>按行二分</p>
<h1 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75. Sort Colors"></a>75. Sort Colors</h1><p>根据Follow up要求，需要一趟遍历搞定。解法如26题，这里使用三个指针，<code>i</code>负责遍历，<code>l</code>维护0值区间$[0,l)$，<code>r</code>维护2值区间$(r, length-1]$，注意到整个过程中$i \gt l$且$r \ge l$。使用多指针维护插入位置是一个常用的方法，在三向快速排序中也有用到。<br>题解给出了<a href="http://paste.ubuntu.com/25422191/" target="_blank" rel="external">四种方法</a></p>
<h1 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76. Minimum Window Substring"></a>76. Minimum Window Substring</h1><p>感觉有点像3，不过这道题需要考虑每个字符的数量，如<code>minWindow(&quot;a&quot;, &quot;aa&quot;)</code>结果是<code>&quot;&quot;</code>不是<code>&quot;a&quot;</code><br>这一条的思路是先找到<code>T</code>的匹配，然后试图移动窗口的左边界，使得匹配最小<br>当<code>d[ch] == cd[ch]</code>而不是<code>d[ch] &gt;= cd[ch]</code>时自增计数器，这样能够保证每个不同字符在达到规定数量时刻只会被统计一次（由于先保证有匹配，再保证匹配最小，所以每个字符数量一旦达到规定数量后就会一直保持在规定数量之上）。</p>
<h1 id="77-Combinations"><a href="#77-Combinations" class="headerlink" title="77. Combinations"></a>77. Combinations</h1><p>这条递归容易写T，不能新建list，题解使用了里面数组生成器，涉及到它的一些的性质。</p>
<h1 id="78-Subsets"><a href="#78-Subsets" class="headerlink" title="78. Subsets"></a>78. Subsets</h1><p>此题有非递归解法<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">res = <span class="string">[[]]</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> nums:</div><div class="line">	res.extend(<span class="string">[[i]+x for x in res])</span></div></pre></td></tr></table></figure></p>
<p>此外对于C++可以借助于位运算的性质来做<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(int i=u; i; i=(i-1)&amp;u)&#123;</div><div class="line">	// bit map i to<span class="built_in"> array</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1506" target="_blank" rel="external">HDU1506老题新做</a></p>
<h1 id="85-Maximal-Rectangle"><a href="#85-Maximal-Rectangle" class="headerlink" title="85. Maximal Rectangle"></a>85. Maximal Rectangle</h1><p>这似乎是我做过的NUAA-HHU的一条赛题啊，典型的二维DP，不过实际上细节还是比较多的。<br>思路就是从左、右、左上角三个位置DP，其中左右是最优化最长的宽为1的“条”，左上角向下拓宽是要同时考虑<code>dp[i-1][j-1]</code>形成的矩形的左边界以及<code>i</code>行的左边界取大值，向右拓宽同理。<br>题解是借助于Largest Rectangle in Histogram的思路做的，可以参考</p>
<h1 id="86-Partition-List"><a href="#86-Partition-List" class="headerlink" title="86. Partition List"></a>86. Partition List</h1><p>简单题</p>
<h1 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87. Scramble String"></a>87. Scramble String</h1><p>题意是树只能建一次，然后任意换，因此统计字符数量1WA<br>显而易见这种变换有一个性质，如果我们选择一个分割点，我们便能够将其分为左右儿子，之后的调换顺序只会改变左右，不会影响分组，于是我们想到递归地枚举所有的分割点。<br>在编码过程中，还要意识到如果我们对<code>s1</code>枚举分割点<code>i</code>，那么对应到<code>s2</code>可以在<code>i</code>和<code>len - i</code>处分割。<br>这条击败的不多，常数优化有待完善。</p>
<h1 id="89-Gray-Code"><a href="#89-Gray-Code" class="headerlink" title="89. Gray Code"></a>89. Gray Code</h1><p>格雷码，公式忘了，可以用三位找规律，注意格雷码是不唯一的</p>
<h1 id="91-Decode-Ways"><a href="#91-Decode-Ways" class="headerlink" title="91. Decode Ways"></a>91. Decode Ways</h1><p>觉得很好的一题，建议先写一下练习一下搜索。Corner case是特别特别地多。<br>这道题的正解是DP。</p>
<h1 id="97-Interleaving-String"><a href="#97-Interleaving-String" class="headerlink" title="97. Interleaving String"></a>97. Interleaving String</h1><p>暴力复杂度是$2^{min(len_1, len_2)}$，为了减到多项式复杂度，通常就是上DP，和LIS啥的一样，也是二维DP。<br>首先看最优子结构，显然在每一步，我们要么选择<code>s1</code>（从<code>dp[i-1][j]</code>过来），要么选择<code>s2</code>（从<code>dp[i][j-1]</code>过来）。然后还要与<code>s3</code>建立联系，于是我们定义<code>dp[i][j]</code>为最远可以达到的<code>s3</code>边界<br>交了一发，只击败了10%。。。这常数可以的，看了看题解，还有用dfs做的</p>
<h1 id="98-Validate-Binary-Search-Tree"><a href="#98-Validate-Binary-Search-Tree" class="headerlink" title="98. Validate Binary Search Tree"></a>98. Validate Binary Search Tree</h1><p>从这题开始有一堆二叉树的题目<br>验证一个二叉树是否是二叉搜索树，注意二叉树需要左子树上所有的节点都小于根节点。</p>
<h1 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h1><p>困难的地方是需要保持二叉树的原先结构</p>
<h1 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113. Path Sum II"></a>113. Path Sum II</h1><p>一个基本的遍历</p>
<h1 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115. Distinct Subsequences"></a>115. Distinct Subsequences</h1><p>注意边界条件是<code>dp[0][1..j] = 0</code>和<code>dp[1..i][j] = 1</code>，不能全为0。</p>
<h1 id="120-Triangle"><a href="#120-Triangle" class="headerlink" title="120. Triangle"></a>120. Triangle</h1><p>动态规划模板题</p>
<h1 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121. Best Time to Buy and Sell Stock"></a>121. Best Time to Buy and Sell Stock</h1><p>在扫描时维护一个当前的最小值和当前的最大利润即可（一开始还想复杂了，是Easy提醒了我）。这种方法比较常用，在求最大权子矩阵中也会用到。</p>
<h1 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122. Best Time to Buy and Sell Stock II"></a>122. Best Time to Buy and Sell Stock II</h1><p>相比上面的题，我们可以进行任何次数的交易，但是不能engage in multiple transactions。只要知道<code>(b-a)+(c-b)=(c-a)</code>这道题目就很简单了，能赚就卖，不能赚就进</p>
<h1 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123. Best Time to Buy and Sell Stock III"></a>123. Best Time to Buy and Sell Stock III</h1><p>由于不能engage in multiple transactions，首先想到的是枚举断点，将本题转成两个Best Time to Buy and Sell Stock问题。不过显然$O(n^2)$是超时的，得DP下。<br>所以仿照前面直方图的思路，维护一个$[0,i]$的解和一个$[i,length-1]$的解。<br>这条也常数也比较大，只击败了20%左右</p>
<h1 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124. Binary Tree Maximum Path Sum"></a>124. Binary Tree Maximum Path Sum</h1><p>说实话Leetcode的链表题和二叉树题我都不喜欢做，它的表示方法让人感觉很蛋疼，因此我写了两个辅助调试的函数，详见Github上的代码。<br>这道题就是两次dfs，第一个dfs是求出从某个节点往叶子方向权最长的一条链，类似于求和最大的子串一样。第二次dfs连接一个节点的两个儿子，看是否能得到一个更长的链。写的时候粗心得一腿，各种漏考虑条件。<br>有很大的常数优化空间，可以优化成一个dfs</p>
<h1 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125. Valid Palindrome"></a>125. Valid Palindrome</h1><p>这个题目挺没意思的，这里Python有个方法<code>.isalnum()</code></p>
<h1 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title="126. Word Ladder II"></a>126. Word Ladder II</h1><p>这道题，一看就是个bfs搜索。不过它一定要输出全部结果的全部路径，这就很麻烦。一开始写了个程序不仅T了还会M。<br>此外“Note that beginWord is not a transformed word”并不意味着<code>beginWord</code>不会在<code>wordList</code>里面出现。<br>最后还是T了，这条有点麻烦。</p>
<h1 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127. Word Ladder"></a>127. Word Ladder</h1><h1 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128. Longest Consecutive Sequence"></a>128. Longest Consecutive Sequence</h1><p>这条我是用反查字典+并查集实现的，不过其实可以直接用反查字典。</p>
<h1 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134. Gas Station"></a>134. Gas Station</h1><p>首先只要gas和cost的sum至少相等就可以实现，可以用归纳法证明。<br>其次，发现题意要求一个从唯一解起始节点<code>i</code>起经过所有节点的油量都大于零的性质，我们要找这个起始节点。进而可以发现从哪个节点开始找是无所谓的，因为每个节点总要经过一次。所以我们可以从例如0节点开始，在满足性质的情况下将序列向左右扩展，直到遍历玩所有的节点。一个具体的方法为首先尽可能往右移动左边界l，当l不能移动时则往左移动右边界r，直到l可以再次往右移动</p>
<h1 id="135-Candy"><a href="#135-Candy" class="headerlink" title="135. Candy"></a>135. Candy</h1><p>一上来就理解错误，只有当严格大于的时候才要求糖数多，例如<code>5 5 5 5</code>这种，每个人可以分糖<code>2 1 1 2</code>（当然最优解是<code>1 1 1 1</code>啦）<br>然后就是硬写，首先将原数组分成上升段、平行段和下降段，如<code>1 2 3 | 3 3 | 4 5 | 4 3</code>。标记每一段的长度为<code>segs[i]</code>，每一段最后一个人的糖果为<code>last_candy[i]</code>个。<br>上升段一定是从<code>last_candy[i-1]+1</code>开始以1为公差的等差数列。<br>下降段末项一定是1，为了尽可能小，所以是以<code>seg[i]</code>为首项，-1位公差的等差数列。但如果<code>last_candy[i-1]</code>小于等于<code>seg[i]</code>，那整个下降数列放不下，所以此时要提升<code>last_candy[i-1]</code>到<code>seg[i]+1</code>（注意只要改前一个数列的末项哦）</p>
<h1 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h1><p>老题新做</p>
<h1 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137. Single Number II"></a>137. Single Number II</h1><p>这道题同样可以用异或来解决（当然也可以借助于set）。在上一题中，我们通过异或的性质，实现了值相同的数两两相消。在这一题中，我们希望出现三个相同的数才相消。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ones</span> = <span class="number">0</span></div><div class="line">twos = <span class="number">0</span></div><div class="line"><span class="keyword">for</span> x in nums:</div><div class="line">	<span class="built_in">ones</span> = (<span class="built_in">ones</span> ^ x) &amp; ~twos</div><div class="line">	twos = (twos ^ x) &amp; ~<span class="built_in">ones</span></div><div class="line"><span class="keyword">return</span> <span class="built_in">ones</span></div></pre></td></tr></table></figure>
<p>考虑一个比特位的情况。观察上面的代码，对于序列<code>1 1 1</code>能够得到<code>(ones, twos)</code>的值分别是<code>(0, 0), (1, 0), (0, 1), (0, 0)</code>。这里的<code>&amp; ~twos</code>用来表示进位，当<code>twos = 1</code>时说明目前已经出现了两次，于是我们归零<code>ones</code>。</p>
<h1 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139. Word Break"></a>139. Word Break</h1><p>要根据字典进行分词。看起来是一个Trie的题目，题目也没规定大小写怎么说，而且也没说是否存在唯一表示。<br>花了很久尝试用AC自动机做，不过失败了。</p>
<h1 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. Linked List Cycle</h1><p>这种链表题一般都要考虑快慢指针的解法。<br>首先只可能有一个环，所以直接搞。</p>
<h1 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h1><p>比上面的一题要求找到环的起始点的位置。可以发现若第一次快慢指针交于点X，则环的长度$c$等于下次快指针追上慢指针时慢指针走过的距离。<br>设链表头到环起点距离$s$，环起点到交点X距离$a$，交点X到环起点距离$b$，有$a + b = c$。且$2(s + k_1 \, c + a) = s + k_2 \, c + a$，有$s + a = k \, c$，即$s = kc + b$。则将两个指针分别置于链表头和交点X，其交点就是环的起始点。</p>
<h1 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h1><p>经典的二叉树后序遍历问题</p>
<h1 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146. LRU Cache"></a>146. LRU Cache</h1><p>在$O(1)$复杂度下，免不了Hash。<br>【未完待续】</p>
<h1 id="148-Sort-List"><a href="#148-Sort-List" class="headerlink" title="148. Sort List"></a>148. Sort List</h1><p>写了几个辅助函数用来调试。这条就是按照CLRS上的思路写的快排，可参照第215条。居然T了</p>
<h1 id="149-Max-Points-on-a-Line"><a href="#149-Max-Points-on-a-Line" class="headerlink" title="149. Max Points on a Line"></a>149. Max Points on a Line</h1><p>这是一条神经病题目，两个相同位置的点居然算不同点。所以我是不知道它怎么解释$[[1,1],[1,1],[1,1]]$输出3，$[[84,250],[0,0],[1,0],[0,-70],[0,-70],[1,-1],[21,10],[42,90],[-42,-230]]$输出6的？所以说这些相等的点互相组成直线，但是和任何其他直线都不共线是吧、、、那你告诉我为什么TestCase31输出25而不是56。。。我最后HardCode了$[[1,1],[1,1],[1,1]]$才AC的。</p>
<h1 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151. Reverse Words in a String"></a>151. Reverse Words in a String</h1><p>这题有一点无理取闹的地方是要先将连续的空格合并成一个，然后就是一条经典的题目。原地解法是翻转每一个单词，再翻转整个字符串，代码只有很骚的一行<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> <span class="string">' '</span>.<span class="built_in">join</span>(<span class="built_in">map</span>(lambda x: x[::<span class="number">-1</span>], <span class="built_in">filter</span>(lambda x: x, s.<span class="built_in">split</span>(<span class="string">' '</span>))))[::<span class="number">-1</span>]</div></pre></td></tr></table></figure></p>
<h1 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152. Maximum Product Subarray"></a>152. Maximum Product Subarray</h1><p>注意这条是子串而不是子序列。这个不同于最大和，可以维护一个全局最大和当前最大来做。<br>Bruteforce的做法是$O(n^3)$的，遍历所有可能的数组，并累乘。一个动态规划的思路是维护$dp[i]$作为一个累乘序列，这样的话是复杂度是$O(n^2)$。注意遇到0之后可能认为当前数组结束了，0后面的作为一个新数组处理。<br>不过正解是$O(n)$的，相比先前的最大和，它的转移方程考虑三个分支，分别是使用前一个dp的最大值、最小值（因为存在负数翻转的现象），或不使用。</p>
<h1 id="153-Find-Minimum-in-Rotated-Sorted-Array"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="153. Find Minimum in Rotated Sorted Array"></a>153. Find Minimum in Rotated Sorted Array</h1><p>旋转数组求最小元素，这是一道经典的二分搜索题目。</p>
<h1 id="160-Intersection-of-Two-Linked-Lists"><a href="#160-Intersection-of-Two-Linked-Lists" class="headerlink" title="160. Intersection of Two Linked Lists"></a>160. Intersection of Two Linked Lists</h1><p>找到两个链表的交点。注意一下链表的相交，在没有环的情况下一定是Y型而不是X型的，在有环的情况下那么两个链表一定最后进入同一个环。<br>本题是没有环的情况，容易发现将<code>headB</code>的链表头接到<code>headA</code>的尾巴后面，那么就能把本题化为第142题。<br>下面讨论有环的情况，首先判是否相交，根据上面的性质，我们只要找到A环上的一点，判断在不在另一个链表的环上就行了。<br>链表相交常被用在求普通二叉树的最近公共祖先上。</p>
<h1 id="162-Find-Peak-Element"><a href="#162-Find-Peak-Element" class="headerlink" title="162. Find Peak Element"></a>162. Find Peak Element</h1><p>裸二分吧</p>
<h1 id="169-Majority-Element"><a href="#169-Majority-Element" class="headerlink" title="169. Majority Element"></a>169. Majority Element</h1><p>一个很有趣的Brain teasing，要求找到出现超过<code>floor(n / 2)</code>次的元素</p>
<h1 id="179-Largest-Number"><a href="#179-Largest-Number" class="headerlink" title="179. Largest Number"></a>179. Largest Number</h1><p>在贪心时我们需要考虑一个问题，即类似<code>[76, 7621]</code>和<code>[76, 7698]</code>的情况，这两种情况下最优解分别为<code>76 7621</code>和<code>7698 76</code>，但是考虑<code>[7676, 76, 98]</code>和<code>[7676, 76, 54]</code>的情况就难以处理了。但其实这种情况不会存在，因为98一定会在7676前面被去掉。<br>写了一份提交，发现死在了219Case上，简化一下发现<code>[2, 213, 2281]</code>这个样例，原因是2281还是比2大的。这个判断太麻烦了！后来发现还不如在两个字符串不相等时把两个字符串两种组合<code>s1 + s2</code>和<code>s2 + s1</code>都试一下看哪个大呢。<br>在第321条中我们发现了类似的归并的问题。</p>
<h1 id="191-Number-of-1-Bits"><a href="#191-Number-of-1-Bits" class="headerlink" title="191. Number of 1 Bits"></a>191. Number of 1 Bits</h1><p>这里使用<code>n &amp; (n - 1)</code>去掉末尾的0，或者使用<code>x &amp; -x</code>取到末尾的0</p>
<h1 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200. Number of Islands"></a>200. Number of Islands</h1><p>一看应该就是条DFS裸题，转念一想像这种可以用搜索解决的集合分划问题也能用并查集搞。</p>
<h1 id="206-Reverse-Linked-List"><a href="#206-Reverse-Linked-List" class="headerlink" title="206. Reverse Linked List"></a>206. Reverse Linked List</h1><p>特别经典的链表反转问题，迭代方法借助<code>prev</code>和<code>cur</code>指针。<br>题目还要求使用递归方法。</p>
<h1 id="207-Course-Schedule"><a href="#207-Course-Schedule" class="headerlink" title="207. Course Schedule"></a>207. Course Schedule</h1><p>判断一个有向图中是否存在环，拓扑排序。<a href="/2016/11/07/拓扑排序/">有关拓扑排序的内容，具体可见我的一篇博客</a>。<br>这边额外说一下有向图和无向图判环的方法。首先补充一下DFS的相关知识，一个无环的有向图当且仅当DFS中没有后向边，关于这个推论可以查看<a href="/2016/08/21/tarjan/">我的一篇博客</a>，因此我们只要做一次DFS搜索（使用黑白灰标记），并观察是否出现后向边即可。<br>相对于有向图，无向图还有一些额外的判环方法。首先是并查集。</p>
<h1 id="208-Implement-Trie-Prefix-Tree"><a href="#208-Implement-Trie-Prefix-Tree" class="headerlink" title="208. Implement Trie (Prefix Tree)"></a>208. Implement Trie (Prefix Tree)</h1><p>我先研究了Word Break那条，写了个AC自动机，没过，于是先把这条给水掉</p>
<h1 id="210-Course-Schedule-II"><a href="#210-Course-Schedule-II" class="headerlink" title="210. Course Schedule II"></a>210. Course Schedule II</h1><p>看起来是个拓扑排序</p>
<h1 id="215-Kth-Largest-Element-in-an-Array"><a href="#215-Kth-Largest-Element-in-an-Array" class="headerlink" title="215. Kth Largest Element in an Array"></a>215. Kth Largest Element in an Array</h1><p>快排模板题，居然卡了（天哪噜，原来是两种常见写法混起来用了），既然如此就来介绍一下快速排序的<a href="http://blog.csdn.net/a641324093/article/details/78307004" target="_blank" rel="external">两种常见方法</a>吧。<br>快速排序的一种经典写法<strong>挖坑法</strong>是先取<code>p = arr[fr]</code>为支点元素，然后我们一定要先从<code>arr[to]</code>开始遍历，这么做的目的是将第一个不符合的<code>arr[j]</code><strong>直接赋值给</strong><code>arr[fr]</code>（注意不需要交换了）。<br>注意一些错误的算法的实现总是不能有效地将<code>arr[fr]</code>移动到中间位置，所以我们必须得先把<code>arr[fr]</code>的槽空出来。建议在写快排时每次递归始终是在<code>[fr, pos - 1]</code>和<code>[pos + 1, to]</code>递归，并且<code>arr[pos]</code>放支点元素。我们还要考虑把等于的放到哪边，一般来说，如果我们取<code>arr[fr]</code>为支点，那么我们就要把等于支点的放到右边，这样才能够先把<code>arr[fr]</code>空出来，在下面的一个算法中，我们看到它使用<code>fr, l, r, to</code>将数列分为了四个部分，从而能在最后找到<code>arr[fr]</code>所放置的位置。但是对于上面的挖坑法来说，这是不必要考虑的，因为它保证了将第一个换掉<code>arr[fr]</code>。此外，在手写快排时写完一定要查一下当第一个元素是最小时是否成立，一般算法错就错在这里。<br>另一种方法，也是算法导论中介绍的，是仿照三路快排来做的。这种方法的主要特点是不再在数列两端来维护了，而是根据CLRS P96的那张图来维护，并且在最后唯一一次移动<code>arr[fr]</code>到准确位置。<br>注意如果说要找出<strong>前</strong>K个的话，可以使用$O(n)$建一个最小堆，然后做$k$次$O(lg \, n)$的弹出。<br>此外对这一题我还实现了一个堆排序，堆排序要稍微简单一点，我们主要注意在pushDown交换的时候，我们应当选择两个son最大的那个进行交换</p>
<h1 id="218-The-Skyline-Problem"><a href="#218-The-Skyline-Problem" class="headerlink" title="218. The Skyline Problem"></a>218. The Skyline Problem</h1><p>这题实际上就是插线问点的问题，首先就是想到用离散化+线段树/树状数组来做。</p>
<h1 id="221-Maximal-Square"><a href="#221-Maximal-Square" class="headerlink" title="221. Maximal Square"></a>221. Maximal Square</h1><p>这条比之前的第85条多了是正方形的条件，我们当时应该是做的这条，比矩形要简单很多</p>
<h1 id="233-Number-of-Digit-One"><a href="#233-Number-of-Digit-One" class="headerlink" title="233. Number of Digit One"></a>233. Number of Digit One</h1><p>可以用数位DP硬刚，设置状态<code>status</code>为高位上1的数量（之前以为不需要设的）。<br>当然这道题也有神奇的解法，具体还没研究<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countDigitOne</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ones = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> m = <span class="number">1</span>; m &lt;= n; m *= <span class="number">10</span>)</div><div class="line">        ones += (n/m + <span class="number">8</span>) / <span class="number">10</span> * m + (n/m % <span class="number">10</span> == <span class="number">1</span>) * (n%m + <span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> ones;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree"></a>236. Lowest Common Ancestor of a Binary Tree</h1><p>经典的求LCA的题目。一个straightforward的做法是计算得到两个链然后求交。<br>一个通常意义的解法是离线的tarjan。Python的Hash啊，简直蛋疼，又不能自定义数据结构，解决不了并查集的问题。<br>用C++写了发终于过了，这里提醒一下，Leetcode的全局变量一定每次计算时要清空。</p>
<h1 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239. Sliding Window Maximum"></a>239. Sliding Window Maximum</h1><p>如果说需要查任意区间的最大值那么线段树是比较好的办法，不过这道题要求是用$O(n)$时间解决。<br>这道题做完之后我看题解上是用了啥deque，但我自己做的时候直接维护了窗口两端的指针，然后分类讨论。居然击败了96%</p>
<h1 id="260-Single-Number-III"><a href="#260-Single-Number-III" class="headerlink" title="260. Single Number III"></a>260. Single Number III</h1><p>老题新做</p>
<h1 id="263-Ugly-Number"><a href="#263-Ugly-Number" class="headerlink" title="263. Ugly Number"></a>263. Ugly Number</h1><p>没啥好说的</p>
<h1 id="264-Ugly-Number-II"><a href="#264-Ugly-Number-II" class="headerlink" title="264. Ugly Number II"></a>264. Ugly Number II</h1><p>想一开始用筛法预处理打个表，然而TLE了。也没发现能够从各因数的幂上发现子结构。解决方案还是从$O(n^2)$的筛法上下手，原筛法是对第$i$个丑数，看看能从先前的丑数中进行更新得到的最小值。容易发现这个过程存在很多冗余计算。例如在计算$ugly[i]$时，我们需要知道满足$x * 2 &gt; ugly[i - 1]$的最小的$x$，显然我们不需要在所有$ugly[1..(i-1)]$遍历$x$。不过我们发现每次使用$* 2$规则生成新丑数时，我们的$x$是<strong>严格递增</strong>的。递增很简单，因为新丑数比就丑数大，所以$x$要大。严格是因为所有的丑数都是偏序的。</p>
<h1 id="279-Perfect-Squares"><a href="#279-Perfect-Squares" class="headerlink" title="279. Perfect Squares"></a>279. Perfect Squares</h1><p>点开Playground看一下它附加的后台代码，发现我们打表不能打在<code>Solution</code>对象的<code>__init__</code>上，而应该打在全局。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">line</span> = lines.next()</div><div class="line"><span class="attr">n</span> = stringToInt(line)</div><div class="line"><span class="attr">ret</span> = Solution().numSquares(n)</div><div class="line"><span class="attr">out</span> = intToString(ret)</div></pre></td></tr></table></figure></p>
<h1 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295. Find Median from Data Stream"></a>295. Find Median from Data Stream</h1><h1 id="300-Longest-Increasing-Subsequence"><a href="#300-Longest-Increasing-Subsequence" class="headerlink" title="300. Longest Increasing Subsequence"></a>300. Longest Increasing Subsequence</h1><p>最长上升子序列模板题</p>
<h1 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309. Best Time to Buy and Sell Stock with Cooldown"></a>309. Best Time to Buy and Sell Stock with Cooldown</h1><p>首先要思考的是如何维护DP的状态，我觉得可以直接用一个二维数组来表示，因为每一天有三种行为，买、卖和不买不卖，分别导致三种状态，因此我们可以设置数组<code>dp[n][3]</code>，紧接着在推导公式时我们发现一个问题，我们计算不买不卖这个状态很有难度。看答案才知道其实是想复杂了。首先它只设两个变量<code>buy[i]</code>表示第<code>i</code>天<strong>买彩票</strong>能获得的最大利润，<code>sell[i]</code>表示在第<code>i</code>天<strong>卖彩票</strong>获得的最大利润。下面我们考虑计算<code>sell[i]</code>，最容易想到的是如果第<code>i - 1</code>天买了，那么利润就是<code>buy[i-1]+prices[i]</code>，但是如果我第<code>i - 1</code>天不买不卖呢？那我们就直接使用第<code>i - 1</code>天的结果<code>sell[i - 1]</code>。计算</p>
<h1 id="315-Count-of-Smaller-Numbers-After-Self"><a href="#315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="315. Count of Smaller Numbers After Self"></a>315. Count of Smaller Numbers After Self</h1><p>我是从逆序对的经典问题出发找到这条题目的，这一条朴素解法是$O(n^2)$的，但似乎不太好套逆序对的模板，因为需要求每个位置的结果，而中途的sort会改变位置。一个straightforward的做法是线段树/树状数组神器，不过常数是比较大的。<br>但是还有一种思路，我们可以理解成从最后一个元素开始构造一个新的数列，对于每一个元素<code>bisect_left</code>查找它的插入位置，这就是解，搞了一发T了。<br>通过查看Related topics我发现了二叉搜索树(BST)其实就是用来做这个的，它能够进行动态插入。这里注意一下，不要用数组来实现二叉树，容易爆内存，而且要在每个节点上维护count，否则会爆内存</p>
<h1 id="321-Create-Maximum-Number"><a href="#321-Create-Maximum-Number" class="headerlink" title="321. Create Maximum Number"></a>321. Create Maximum Number</h1><p>这一条目前还是T的状态<br>这道题目一开始的思路就是枚举$k$，然后分别对<code>nums1</code>和<code>nums2</code>生成最大的数，最后进行归并。<br>下面我们考虑子问题，从<code>nums</code>数组中取出按顺序的<code>req</code>个数使得组成的数最大。写了一个错误的思路是首先取<code>ans = nums[0..req-1]</code>，然后对于从<code>req</code>开始的每个数，我们找到它能替换<code>ans</code>的最小index位置和最大长度，例如<code>[8,5,3,6,7]</code>中<code>[6,7]</code>能够替换<code>[5,3]</code>。不过这个思路是错的，例如<code>[9,7,9,1]</code>，显然<code>[9,1]</code>不能替换<code>[9,7]</code>，但是第2个9可以替换第一个7。此外也不能从<code>req</code>位置开始，而应该从1位置开始。<br>在归并时，我们要注意当<code>nums[i]</code>和<code>nums[j]</code>相等时需要向下比较，如果当其中一个数列耗尽还没比较出来大小，那就选择另外的数列为大，因为另一个数列可能下面的元素就大了。例如<code>[0]</code>和<code>[0, 6]</code>。</p>
<h1 id="322-Coin-Change"><a href="#322-Coin-Change" class="headerlink" title="322. Coin Change"></a>322. Coin Change</h1><p>这是一道完全背包的问题。</p>
<h1 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324. Wiggle Sort II"></a>324. Wiggle Sort II</h1><!-- https://paste.ubuntu.com/26506141/ https://paste.ubuntu.com/26511493/ 是有问题的 -->
<p>这道题比前面的Wiggle Sort去掉了可以相等的条件。平凡解法依旧是$O(n log \, n)$的，使用排序之后一头一尾接着取，也能AC。题目要求的$O(n)$时间复杂度和$O(1)$空间复杂度就有难度了，首先DP肯定不行了。一个初步的策略是首先算出中位数，这个有一个$O(n)$的第k大数的算法<code>std::nth_element</code>，然后将大于中位数的放在奇数位，小于等于的放在偶数位。注意当数列为奇数个时，中位数放在偶数位作为一头一尾。因此我们必须新开一个数组，造成$O(n)$的空间开销。<br>题解用了一个很巧妙的思路，首先将原数列映射成<code>[1, 3, 5, ... , 0, 2, 4, ...]</code>的形式，然后考虑这个“新数列”。它的前半部分都大于中位数，后半部分都小于中位数。这又回到了之前的快速选择的问题上。不过<a href="https://paste.ubuntu.com/26511612/" target="_blank" rel="external">这个做法</a>还是有问题，例如<code>[1, 3, 2, 2, 3, 1]</code>的结果是<code>[1, 3, 2, 2, 3, 1]</code>。正确答案需要三向快排来处理相同值的情况。与二向划分不同的是，三向划分虽然拥有<code>l</code>、<code>r</code>、<code>eq</code>三个指针表示小于等于大于三个边界。但它只使用一个循环，即用<code>eq</code>指针从前到后遍历数组，而不是使用两个指针相向移动。当遇到大于pivot的数的时候，就把它扔到<code>r</code>指针位置，并更新<code>r</code>。当遇到小于pivot数的时候就把它和<code>l</code>指针互换，保证<code>l</code>左边都是小于pivot的数</p>
<h1 id="326-Power-of-Three"><a href="#326-Power-of-Three" class="headerlink" title="326. Power of Three"></a>326. Power of Three</h1><p>一道很有趣的题，要求不使用循环和递归来判断一个数是否是3的整数幂。我能想到是log，还有一个蹩脚的二分搜索。一个应该是最优解使用int范围内最大的3的幂<code>1162261467</code>来模这个数看是否能整除。<br>这里用log+python的<code>is_integer</code>写了一发，发现<code>math.log(243, 3).is_integer()</code>返回<code>False</code>，所以还是要自己用eps判定下。</p>
<h1 id="338-Counting-Bits"><a href="#338-Counting-Bits" class="headerlink" title="338. Counting Bits"></a>338. Counting Bits</h1><p>这条虽然可以按191的思路做，不过更好的方法是DP，以<code>0011b</code>为例，它中1的数目<code>ans[0011b] = ans[0011b &gt;&gt; 1] + (0011b &amp; 1)</code></p>
<h1 id="343-Integer-Break"><a href="#343-Integer-Break" class="headerlink" title="343. Integer Break"></a>343. Integer Break</h1><p>经典的整数划分问题。这道题我记得看过推导是分成$N/e$个数为妙，不过我最后还是做了下记忆化搜索解决的。注意因为题目要求至少分两块，所以我们要存两个dp，一个是必须要分的，一个是可以不分的。<br>这里额外说一下几个常见的整数划分问题：</p>
<ol>
<li><p>将n划分为若干整数之和</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这里k表示不超过k的整数</div><div class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k</span>] + dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>将n划分为若干不同整数之和</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这里k表示不超过k的整数</div><div class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k - 1</span>] + dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</div></pre></td></tr></table></figure>
</li>
<li><p>将n划分为k个整数之和</p>
 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 其中第一项为划分中不包含1的情况，第二项为划分中包含1的情况，注意不是dp[<span class="string">n</span>][<span class="symbol">k - 1</span>]</div><div class="line">dp[<span class="string">n</span>][<span class="symbol">k</span>] = dp[<span class="string">n - k</span>][<span class="symbol">k</span>] + dp[<span class="string">n - 1</span>][<span class="symbol">k - 1</span>]</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="354-Russian-Doll-Envelopes"><a href="#354-Russian-Doll-Envelopes" class="headerlink" title="354. Russian Doll Envelopes"></a>354. Russian Doll Envelopes</h1><p>这题很好用记忆化搜索做，因为信封之间是偏序的，即如果信封A能dfs到信封B，则信封B肯定不能dfs到信封A，因此dfs的时候不需要维护状态。不过撸了个Python版本的，超时了。后来发现要$O(nlogn)$才能保证过，不过C++又没卡住$O(n^2)$的复杂度。<br>后来发现这道题可以转化为LIS来做，把w看成横坐标，h看成纵坐标，我们实际上是要找h的最长的上升子序列。注意为了处理横坐标相等的情况，需要在此时将纵坐标从大到小排列，以便<code>bisect_left</code>能够定位到准确位置。</p>
<h1 id="363-Max-Sum-of-Rectangle-No-Larger-Than-K"><a href="#363-Max-Sum-of-Rectangle-No-Larger-Than-K" class="headerlink" title="363. Max Sum of Rectangle No Larger Than K"></a>363. Max Sum of Rectangle No Larger Than K</h1><p>这道题到现在还是T的状态。<br>这道题和前面的Maximal Rectangle有点像，这次我们来看一个不一样的DP方法，也就是将其转化为一维DP问题来做。这条的复杂度应该是$O(X^2 \times Y \, logY)$，其中$X, Y$分别为矩阵的长和宽之间的较小/大值。前面的<code>O(X^2)</code>很简单，可以仿照红书上的最大权自矩形来做。假设这个矩阵列数很多，我们维护一个列的累加和<code>sum</code></p>
<pre><code>1 1 1          1 1 1 
1 1 1    =&gt;    2 2 2
1 1 1          3 3 3
</code></pre><p>然后我们枚举所有的<code>(up, down)</code>，例如当枚举到<code>(1, 2)</code>时，我们计算一个<code>sub</code>表示所有上底为第1行下底为第2行的“棍状数列”的和。接下来我们采取同样的办法计算<code>sub</code>的累加和<code>arr</code></p>
<pre><code>sub = (3-2) (3-2) (3-2)
    =   1     1     1
arr =   1     2     3
</code></pre><p>于是我们的任务就变成了在<code>arr</code>中找到$l &lt; r$，使得$arr[r] - arr[l]$是满足小于$k$最大的数。因此我们可以从<code>i</code>开始遍历<code>arr</code>，然后在一个数据结构内花$O(log n)$查询最接近$arr[i] - k$的值，然后再花$O(log n)$将$arr[i]$放到这个数据结构里面。显然我们可以用一个二叉树来维护，但是我T了，不知道为啥<br>这里说明一下题解上有人用<code>bisect.insort()</code>，注意这个复杂度是$O(n)$的，我之前写的代码效率不高，所以被卡常了。倒是C++里面的<code>set</code>和<code>map</code>啥的有<code>lower_bound</code>。使用二叉树之后反而更垃圾了。</p>
<h1 id="390-Elimination-Game"><a href="#390-Elimination-Game" class="headerlink" title="390. Elimination Game"></a>390. Elimination Game</h1><p>这道题和经典的约瑟夫和问题看起来有点像。当时觉得每次的起始值难算，所以就简单模拟了下，T了。继而我们发现对于任意偶数<code>n</code>，<code>n + 1</code>的答案和<code>n</code>肯定是相等的。看来需要$O(logn)$的复杂度了。于是觉得确实可以把每次扫描数列作为一个子问题，但是我们现在对某个子问题不生成新数组，而是在原数组上进行操作。于是我们维护了<code>s</code>和<code>e</code>，表示我们的起始点和期望的结束点（也就是现在子数列的最末端），设置<code>step</code>为当前的公差。如对<code>1 2 3 4</code>而言，<code>s</code>为1、<code>e</code>为<strong><code>4</code></strong>（不是3），而<code>step</code>为2。容易发现由于我们是偶数项，所以我们只能遍历<code>delta = 2</code>项，并没能遍历到<code>4</code>。我们发现规律，我们每次遍历，要不能遍历到<code>e</code>要不我们能遍历到<code>actual_e</code>，并且<code>actual_e</code>和<code>e</code>相差<code>step / 2</code>。于是我们能够得到新的起点的位置<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> actual_e != e:<span class="type"></span></div><div class="line">	<span class="keyword">new</span><span class="type">s</span> = e <span class="comment">// Or</span></div><div class="line">	<span class="keyword">new</span><span class="type">s</span> = actual_e + step / <span class="number">2</span></div><div class="line"><span class="keyword">else</span>:<span class="type"></span></div><div class="line">	<span class="keyword">new</span><span class="type">s</span> = e - step / <span class="number">2</span></div></pre></td></tr></table></figure></p>
<h1 id="486-Predict-the-Winner"><a href="#486-Predict-the-Winner" class="headerlink" title="486. Predict the Winner"></a>486. Predict the Winner</h1><p>两个人轮流从数组两端取数字，和最大的胜利。数组最长为20。本题可以用AlphaBeta剪枝来做，Python会被卡掉，<a href="https://paste.ubuntu.com/p/CYjCV8rqRV/" target="_blank" rel="external">但是C++能过</a>。<br>Alpha指的是在自己的回合（MAX节点），自己能<strong>确保</strong>的最利于自己的值。Beta指的是在对手的回合（MIN节点），对手能<strong>确保</strong>的最不利自己的值。MINMAX博弈假设对手拥有完全信息，总是能做出完美决策，所以对手要最小化评价函数的增益。容易发现初始情况下取Alpha/Beta为-Inf/+Inf，由于我们还没进入游戏，所以这是可能的最高/低分。<br>容易发现我们需要尽可能提高Alpha值，考虑以一个MAX节点作为根往下遍历，我们首先计算其第一个MIN子节点，MIN子节点总是能够求出自己的Beta值，这时候根节点取该Beta值为自己的Alpha值，从目前看，结果不会比它更坏。但是我们不能就此停住，而是要接着遍历，看看有没有更好的结果。接着我们开始看第二个MIN节点，在计算开始时，我们要<strong>通知根节点当前的Alpha值</strong>。这个MIN节点肯定也要计算自己的Beta值，因此它要根据自己所有子节点的结果来计算自己尽可能小的Beta值。ALphaBeta剪枝认为此时不需要遍历所有的节点，因为一旦我们发现当前的Beta值低于我们通告的Alpha值，那么我们在根节点肯定不会选择这个MIN节点了，于是可以剪枝。<br>同理，以某个MIN节点为根向下遍历，也是先选取第一个子MAX节点的Beta值，然后通告给第二个子MAX节点。由于根节点MIN要选择尽可能小的，所以如果子MAX节点的Alpha值大于通告的Beta值，也进行剪枝。</p>
<h1 id="494-Target-Sum"><a href="#494-Target-Sum" class="headerlink" title="494. Target Sum"></a>494. Target Sum</h1><p>这是一条变种的01背包，我们需要求一个和为<code>(S + sum(nums))/2</code>的子集。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/ACM/" rel="tag"># ACM</a>
          
            <a href="/tags/字符串/" rel="tag"># 字符串</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/08/去除Reimage恶意广告软件/" rel="next" title="去除reimage repair恶意广告软件">
                <i class="fa fa-chevron-left"></i> 去除reimage repair恶意广告软件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/11/C++右值/" rel="prev" title="C++右值">
                C++右值 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">100</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">115</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Two-Sum"><span class="nav-number">1.</span> <span class="nav-text">1. Two Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Add-Two-Numbers"><span class="nav-number">2.</span> <span class="nav-text">2. Add Two Numbers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-Longest-Substring-Without-Repeating-Characters"><span class="nav-number">3.</span> <span class="nav-text">3. Longest Substring Without Repeating Characters</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-Median-of-Two-Sorted-Arrays"><span class="nav-number">4.</span> <span class="nav-text">4. Median of Two Sorted Arrays</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-Longest-Palindromic-Substring"><span class="nav-number">5.</span> <span class="nav-text">5. Longest Palindromic Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-ZigZag-Conversion"><span class="nav-number">6.</span> <span class="nav-text">6. ZigZag Conversion</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-Reverse-Integer"><span class="nav-number">7.</span> <span class="nav-text">7. Reverse Integer</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-String-to-Integer-atoi"><span class="nav-number">8.</span> <span class="nav-text">8. String to Integer (atoi)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-Palindrome-Number"><span class="nav-number">9.</span> <span class="nav-text">9. Palindrome Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-Regular-Expression-Matching"><span class="nav-number">10.</span> <span class="nav-text">10. Regular Expression Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-Container-With-Most-Water"><span class="nav-number">11.</span> <span class="nav-text">11. Container With Most Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-Longest-Common-Prefix"><span class="nav-number">12.</span> <span class="nav-text">14. Longest Common Prefix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-3Sum"><span class="nav-number">13.</span> <span class="nav-text">15. 3Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-3Sum-Closest"><span class="nav-number">14.</span> <span class="nav-text">16. 3Sum Closest</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number"><span class="nav-number">15.</span> <span class="nav-text">17. Letter Combinations of a Phone Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#18-4Sum"><span class="nav-number">16.</span> <span class="nav-text">18. 4Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List"><span class="nav-number">17.</span> <span class="nav-text">19. Remove Nth Node From End of List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#20-Valid-Parentheses"><span class="nav-number">18.</span> <span class="nav-text">20. Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists"><span class="nav-number">19.</span> <span class="nav-text">21. Merge Two Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#22-Generate-Parentheses"><span class="nav-number">20.</span> <span class="nav-text">22. Generate Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#23-Merge-k-Sorted-Lists"><span class="nav-number">21.</span> <span class="nav-text">23. Merge k Sorted Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#24-Swap-Nodes-in-Pairs"><span class="nav-number">22.</span> <span class="nav-text">24. Swap Nodes in Pairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#25-Reverse-Nodes-in-k-Group"><span class="nav-number">23.</span> <span class="nav-text">25. Reverse Nodes in k-Group</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="nav-number">24.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">25.</span> <span class="nav-text">27. Remove Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#29-Divide-Two-Integers"><span class="nav-number">26.</span> <span class="nav-text">29. Divide Two Integers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用位运算实现整数加减法"><span class="nav-number">26.1.</span> <span class="nav-text">使用位运算实现整数加减法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用加减运算实现整数除法"><span class="nav-number">26.2.</span> <span class="nav-text">使用加减运算实现整数除法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#31-Next-Permutation"><span class="nav-number">27.</span> <span class="nav-text">31. Next Permutation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-Longest-Valid-Parentheses"><span class="nav-number">28.</span> <span class="nav-text">32. Longest Valid Parentheses</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array"><span class="nav-number">29.</span> <span class="nav-text">33. Search in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-Search-for-a-Range"><span class="nav-number">30.</span> <span class="nav-text">34. Search for a Range</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#35-Search-Insert-Position"><span class="nav-number">31.</span> <span class="nav-text">35. Search Insert Position</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#37-Sudoku-Solver"><span class="nav-number">32.</span> <span class="nav-text">37. Sudoku Solver</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#39-Combination-Sum"><span class="nav-number">33.</span> <span class="nav-text">39. Combination Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#40-Combination-Sum-II"><span class="nav-number">34.</span> <span class="nav-text">40. Combination Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#41-First-Missing-Positive"><span class="nav-number">35.</span> <span class="nav-text">41. First Missing Positive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#42-Trapping-Rain-Water"><span class="nav-number">36.</span> <span class="nav-text">42. Trapping Rain Water</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#44-Wildcard-Matching"><span class="nav-number">37.</span> <span class="nav-text">44. Wildcard Matching</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#45-Jump-Game-II"><span class="nav-number">38.</span> <span class="nav-text">45. Jump Game II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#46-Permutations"><span class="nav-number">39.</span> <span class="nav-text">46. Permutations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#47-Permutations-II"><span class="nav-number">40.</span> <span class="nav-text">47. Permutations II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#48-Rotate-Image"><span class="nav-number">41.</span> <span class="nav-text">48. Rotate Image</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#49-Group-Anagrams"><span class="nav-number">42.</span> <span class="nav-text">49. Group Anagrams</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#50-Pow-x-n"><span class="nav-number">43.</span> <span class="nav-text">50. Pow(x, n)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#51-N-Queens"><span class="nav-number">44.</span> <span class="nav-text">51. N-Queens</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#52-N-Queens-II"><span class="nav-number">45.</span> <span class="nav-text">52. N-Queens II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#53-Maximum-Subarray"><span class="nav-number">46.</span> <span class="nav-text">53. Maximum Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#54-Spiral-Matrix"><span class="nav-number">47.</span> <span class="nav-text">54. Spiral Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-Jump-Game"><span class="nav-number">48.</span> <span class="nav-text">55. Jump Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-Merge-Intervals"><span class="nav-number">49.</span> <span class="nav-text">56. Merge Intervals</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-Insert-Interval"><span class="nav-number">50.</span> <span class="nav-text">57. Insert Interval</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-Length-of-Last-Word"><span class="nav-number">51.</span> <span class="nav-text">58. Length of Last Word</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-Spiral-Matrix-II"><span class="nav-number">52.</span> <span class="nav-text">59. Spiral Matrix II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#60-Permutation-Sequence"><span class="nav-number">53.</span> <span class="nav-text">60. Permutation Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#61-Rotate-List"><span class="nav-number">54.</span> <span class="nav-text">61. Rotate List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#62-Unique-Paths"><span class="nav-number">55.</span> <span class="nav-text">62. Unique Paths</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#63-Unique-Paths-II"><span class="nav-number">56.</span> <span class="nav-text">63. Unique Paths II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#66-Plus-One"><span class="nav-number">57.</span> <span class="nav-text">66. Plus One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#67-Add-Binary"><span class="nav-number">58.</span> <span class="nav-text">67. Add Binary</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#69-Sqrt-x"><span class="nav-number">59.</span> <span class="nav-text">69. Sqrt(x)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#70-Climbing-Stairs"><span class="nav-number">60.</span> <span class="nav-text">70. Climbing Stairs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#72-Edit-Distance"><span class="nav-number">61.</span> <span class="nav-text">72. Edit Distance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#73-Set-Matrix-Zeroes"><span class="nav-number">62.</span> <span class="nav-text">73. Set Matrix Zeroes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#74-Search-a-2D-Matrix"><span class="nav-number">63.</span> <span class="nav-text">74. Search a 2D Matrix</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#75-Sort-Colors"><span class="nav-number">64.</span> <span class="nav-text">75. Sort Colors</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#76-Minimum-Window-Substring"><span class="nav-number">65.</span> <span class="nav-text">76. Minimum Window Substring</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#77-Combinations"><span class="nav-number">66.</span> <span class="nav-text">77. Combinations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#78-Subsets"><span class="nav-number">67.</span> <span class="nav-text">78. Subsets</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#84-Largest-Rectangle-in-Histogram"><span class="nav-number">68.</span> <span class="nav-text">84. Largest Rectangle in Histogram</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#85-Maximal-Rectangle"><span class="nav-number">69.</span> <span class="nav-text">85. Maximal Rectangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#86-Partition-List"><span class="nav-number">70.</span> <span class="nav-text">86. Partition List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#87-Scramble-String"><span class="nav-number">71.</span> <span class="nav-text">87. Scramble String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#89-Gray-Code"><span class="nav-number">72.</span> <span class="nav-text">89. Gray Code</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#91-Decode-Ways"><span class="nav-number">73.</span> <span class="nav-text">91. Decode Ways</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#97-Interleaving-String"><span class="nav-number">74.</span> <span class="nav-text">97. Interleaving String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#98-Validate-Binary-Search-Tree"><span class="nav-number">75.</span> <span class="nav-text">98. Validate Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#99-Recover-Binary-Search-Tree"><span class="nav-number">76.</span> <span class="nav-text">99. Recover Binary Search Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#113-Path-Sum-II"><span class="nav-number">77.</span> <span class="nav-text">113. Path Sum II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#115-Distinct-Subsequences"><span class="nav-number">78.</span> <span class="nav-text">115. Distinct Subsequences</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#120-Triangle"><span class="nav-number">79.</span> <span class="nav-text">120. Triangle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock"><span class="nav-number">80.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II"><span class="nav-number">81.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III"><span class="nav-number">82.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#124-Binary-Tree-Maximum-Path-Sum"><span class="nav-number">83.</span> <span class="nav-text">124. Binary Tree Maximum Path Sum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#125-Valid-Palindrome"><span class="nav-number">84.</span> <span class="nav-text">125. Valid Palindrome</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#126-Word-Ladder-II"><span class="nav-number">85.</span> <span class="nav-text">126. Word Ladder II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#127-Word-Ladder"><span class="nav-number">86.</span> <span class="nav-text">127. Word Ladder</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#128-Longest-Consecutive-Sequence"><span class="nav-number">87.</span> <span class="nav-text">128. Longest Consecutive Sequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#134-Gas-Station"><span class="nav-number">88.</span> <span class="nav-text">134. Gas Station</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#135-Candy"><span class="nav-number">89.</span> <span class="nav-text">135. Candy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#136-Single-Number"><span class="nav-number">90.</span> <span class="nav-text">136. Single Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#137-Single-Number-II"><span class="nav-number">91.</span> <span class="nav-text">137. Single Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#139-Word-Break"><span class="nav-number">92.</span> <span class="nav-text">139. Word Break</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#141-Linked-List-Cycle"><span class="nav-number">93.</span> <span class="nav-text">141. Linked List Cycle</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#142-Linked-List-Cycle-II"><span class="nav-number">94.</span> <span class="nav-text">142. Linked List Cycle II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="nav-number">95.</span> <span class="nav-text">145. Binary Tree Postorder Traversal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#146-LRU-Cache"><span class="nav-number">96.</span> <span class="nav-text">146. LRU Cache</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#148-Sort-List"><span class="nav-number">97.</span> <span class="nav-text">148. Sort List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#149-Max-Points-on-a-Line"><span class="nav-number">98.</span> <span class="nav-text">149. Max Points on a Line</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#151-Reverse-Words-in-a-String"><span class="nav-number">99.</span> <span class="nav-text">151. Reverse Words in a String</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#152-Maximum-Product-Subarray"><span class="nav-number">100.</span> <span class="nav-text">152. Maximum Product Subarray</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array"><span class="nav-number">101.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists"><span class="nav-number">102.</span> <span class="nav-text">160. Intersection of Two Linked Lists</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#162-Find-Peak-Element"><span class="nav-number">103.</span> <span class="nav-text">162. Find Peak Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#169-Majority-Element"><span class="nav-number">104.</span> <span class="nav-text">169. Majority Element</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#179-Largest-Number"><span class="nav-number">105.</span> <span class="nav-text">179. Largest Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#191-Number-of-1-Bits"><span class="nav-number">106.</span> <span class="nav-text">191. Number of 1 Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#200-Number-of-Islands"><span class="nav-number">107.</span> <span class="nav-text">200. Number of Islands</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#206-Reverse-Linked-List"><span class="nav-number">108.</span> <span class="nav-text">206. Reverse Linked List</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#207-Course-Schedule"><span class="nav-number">109.</span> <span class="nav-text">207. Course Schedule</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree"><span class="nav-number">110.</span> <span class="nav-text">208. Implement Trie (Prefix Tree)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#210-Course-Schedule-II"><span class="nav-number">111.</span> <span class="nav-text">210. Course Schedule II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array"><span class="nav-number">112.</span> <span class="nav-text">215. Kth Largest Element in an Array</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#218-The-Skyline-Problem"><span class="nav-number">113.</span> <span class="nav-text">218. The Skyline Problem</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#221-Maximal-Square"><span class="nav-number">114.</span> <span class="nav-text">221. Maximal Square</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#233-Number-of-Digit-One"><span class="nav-number">115.</span> <span class="nav-text">233. Number of Digit One</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree"><span class="nav-number">116.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#239-Sliding-Window-Maximum"><span class="nav-number">117.</span> <span class="nav-text">239. Sliding Window Maximum</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#260-Single-Number-III"><span class="nav-number">118.</span> <span class="nav-text">260. Single Number III</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#263-Ugly-Number"><span class="nav-number">119.</span> <span class="nav-text">263. Ugly Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#264-Ugly-Number-II"><span class="nav-number">120.</span> <span class="nav-text">264. Ugly Number II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#279-Perfect-Squares"><span class="nav-number">121.</span> <span class="nav-text">279. Perfect Squares</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#295-Find-Median-from-Data-Stream"><span class="nav-number">122.</span> <span class="nav-text">295. Find Median from Data Stream</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#300-Longest-Increasing-Subsequence"><span class="nav-number">123.</span> <span class="nav-text">300. Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><span class="nav-number">124.</span> <span class="nav-text">309. Best Time to Buy and Sell Stock with Cooldown</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#315-Count-of-Smaller-Numbers-After-Self"><span class="nav-number">125.</span> <span class="nav-text">315. Count of Smaller Numbers After Self</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#321-Create-Maximum-Number"><span class="nav-number">126.</span> <span class="nav-text">321. Create Maximum Number</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#322-Coin-Change"><span class="nav-number">127.</span> <span class="nav-text">322. Coin Change</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#324-Wiggle-Sort-II"><span class="nav-number">128.</span> <span class="nav-text">324. Wiggle Sort II</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#326-Power-of-Three"><span class="nav-number">129.</span> <span class="nav-text">326. Power of Three</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#338-Counting-Bits"><span class="nav-number">130.</span> <span class="nav-text">338. Counting Bits</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#343-Integer-Break"><span class="nav-number">131.</span> <span class="nav-text">343. Integer Break</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#354-Russian-Doll-Envelopes"><span class="nav-number">132.</span> <span class="nav-text">354. Russian Doll Envelopes</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#363-Max-Sum-of-Rectangle-No-Larger-Than-K"><span class="nav-number">133.</span> <span class="nav-text">363. Max Sum of Rectangle No Larger Than K</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#390-Elimination-Game"><span class="nav-number">134.</span> <span class="nav-text">390. Elimination Game</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#486-Predict-the-Winner"><span class="nav-number">135.</span> <span class="nav-text">486. Predict the Winner</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#494-Target-Sum"><span class="nav-number">136.</span> <span class="nav-text">494. Target Sum</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://calvinneo.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2017/02/09/LeetCode解题报告/';
          this.page.identifier = '2017/02/09/LeetCode解题报告/';
          this.page.title = 'Leetcode解题报告';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
