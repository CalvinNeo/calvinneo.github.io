<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Haskell,函数式," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="Channel 9上有个非常好的介绍Haskell和函数式编程的视频，这个视频是根据Programming in Haskell这本书讲述的。Slides和Codes可以在http://www.cs.nott.ac.uk/~pszgmh/上下载，不过后面几章会和实际的课程内容有出入。此外Learn You a Haskell上的教程，以及Wikipedia上有关Haskell的词条也是非常有用的。">
<meta name="keywords" content="Haskell,函数式">
<meta property="og:type" content="article">
<meta property="og:title" content="Haskell学习笔记">
<meta property="og:url" content="http://www.calvinneo.com/2017/02/28/haskell学习笔记/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="Channel 9上有个非常好的介绍Haskell和函数式编程的视频，这个视频是根据Programming in Haskell这本书讲述的。Slides和Codes可以在http://www.cs.nott.ac.uk/~pszgmh/上下载，不过后面几章会和实际的课程内容有出入。此外Learn You a Haskell上的教程，以及Wikipedia上有关Haskell的词条也是非常有用的。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-12-22T07:27:46.630Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Haskell学习笔记">
<meta name="twitter:description" content="Channel 9上有个非常好的介绍Haskell和函数式编程的视频，这个视频是根据Programming in Haskell这本书讲述的。Slides和Codes可以在http://www.cs.nott.ac.uk/~pszgmh/上下载，不过后面几章会和实际的课程内容有出入。此外Learn You a Haskell上的教程，以及Wikipedia上有关Haskell的词条也是非常有用的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2017/02/28/haskell学习笔记/"/>





  <title>Haskell学习笔记 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2017/02/28/haskell学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Haskell学习笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-28T14:31:17+08:00">
                2017-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Channel 9上有个非常好的介绍Haskell和函数式编程的视频，这个视频是根据Programming in Haskell这本书讲述的。Slides和Codes可以在<a href="http://www.cs.nott.ac.uk/~pszgmh/" target="_blank" rel="noopener">http://www.cs.nott.ac.uk/~pszgmh/</a>上下载，不过后面几章会和实际的课程内容有出入。此外<a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell</a>上的教程，以及Wikipedia上有关Haskell的词条也是非常有用的。<br>相对于其他的一些Haskell的教程，通过这本书/视频进行学习能够了解Haskell的好处以及设计原理</p>
<a id="more"></a>
<h1 id="Ch0"><a href="#Ch0" class="headerlink" title="Ch0"></a>Ch0</h1><p>先吐槽一下教授的口音。。。</p>
<h2 id="配置Haskell环境"><a href="#配置Haskell环境" class="headerlink" title="配置Haskell环境"></a>配置Haskell环境</h2><p>使用sublime text 2，可能会出现一些问题</p>
<ol>
<li>Decode error - output not utf-8<br> 在Haskell.sublime-build里面把encoding改为cp936（也就是GBK）即可</li>
<li><pre><code> Not in scope: main
 Perhaps you meant min (imported from Prelude)
</code></pre>
 这是因为编译命令行默认调用runhaskell，它会自动调用main程序，所以把命令行改为ghci即可<br>现在可以愉快地写Haskell啦</li>
<li>end of file<pre><code> &lt;stdin&gt;: hGetLine: end of file
</code></pre>
 这是Haskell的一个bug，参考<a href="http://stackoverflow.com/questions/42188671/haskell-does-not-return-from-getline" target="_blank" rel="noopener">StackOverflow</a>上这篇回答</li>
</ol>
<h1 id="Ch1-Introduction"><a href="#Ch1-Introduction" class="headerlink" title="Ch1 Introduction"></a>Ch1 Introduction</h1><p>Haskell大法好！函数式大法好！</p>
<ol>
<li>现代软件危机：<ol>
<li>如何处理现代程序大小和复杂度问题</li>
<li>如何减少程序开发的时间和代价</li>
<li>如何提高程序可靠性</li>
</ol>
</li>
<li>解决方案：<ol>
<li>更清楚、简明、高度抽象的代码</li>
<li>可重用的组件</li>
<li>形式证明(formal verification)的使用</li>
<li>rapid prototyping</li>
</ol>
</li>
<li>函数式编程(functional language)<br> 是一种把函数应用到参数(application of function to arguments)作为基本运算的编程风格</li>
<li>Alonzo Church：lambda演算</li>
<li>John McCarthy：Lisp</li>
<li>John Backus：FP，high-order functions and reasoning about program，类似于Linq</li>
<li>Robin Milner：ML，type inference and polymorphic types</li>
<li>Peter Landin：ISWIM，没有赋值的纯函数式编程语言</li>
<li>David Turner：lazy evaluation</li>
<li>SKI组合子演算(Haskell Curry等人提出)</li>
<li>一个非原地的快速排序，类似于Linq(<code>where</code>语句)或派通(Python，神奇的口音)一行版本的写法。</li>
</ol>
<h1 id="Ch2-First-Steps"><a href="#Ch2-First-Steps" class="headerlink" title="Ch2 First Steps"></a>Ch2 First Steps</h1><p>首先是讲了一堆Prelude大法好</p>
<h2 id="列表处理"><a href="#列表处理" class="headerlink" title="列表处理"></a>列表处理</h2><p>在Ch4中会看到部分函数，例如<code>head</code>、<code>tail</code>是如何实现的</p>
<ol>
<li><p>获取列表片段<br> 返回移除列表首元素的新列表，类似car</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; head [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p> 返回移除列表首元素的新列表，类似cdr</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; tail [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p> 返回移除列表前n个元素的新列表</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; drop <span class="number">3</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p> 返回前n个元素组成的新列表</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; take <span class="number">3</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>返回列表第n个元素</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] !! <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li>
<li><p>连接两个列表</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>,<span class="number">2</span>] ++ [<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>列表属性<br> 获得列表长度</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; length [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p> 获得列表和/积</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; sum/product [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="number">15</span>/<span class="number">120</span></span><br></pre></td></tr></table></figure>

<p> 翻转列表</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; reverse [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>生成列表<br> 注意生成的是中括号区间</p>
 <figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1.</span><span class="number">.5</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p> 而</p>
 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> [1..]</span></span><br></pre></td></tr></table></figure>

<p> 生成一个无尽的列表，类似python中的生成器<code>count</code>，不同于python，Haskell的实现是因为它是lazy evaluation的</p>
</li>
<li><p>判断元素属于列表 </p>
 <figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">1</span> `elem` [<span class="number">1</span>..<span class="number">5</span>]</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三种编程语言的比较"><a href="#三种编程语言的比较" class="headerlink" title="三种编程语言的比较"></a>三种编程语言的比较</h2><ul>
<li><p>C#(OOP)   </p>
<pre><code>  [1,2,3].drop(3)         
  receiver.method(arguments)
</code></pre>
<p>  这里<code>receiver</code>和<code>arguments</code>不是等价的参数，一切围绕<code>receiver</code>对象为基础</p>
</li>
<li><p>Haskell   </p>
<pre><code>  drop 3 [1,2,3]
  method receiver arguments
</code></pre>
<p>  这里<code>receiver</code>和<code>arguments</code>是等价的参数，可以更方便地match每个参数的特定值</p>
</li>
<li><p>F#    </p>
<pre><code>  [1,2,3] -&gt; drop 3
</code></pre>
</li>
</ul>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><ol>
<li>使用空格而不是括号+逗号来分离函数名以及参数</li>
<li>函数调用比其他运算符，如<code>+</code>具有<strong>更高的</strong>优先级（毕竟你连括号都没有），因此比较好的书写习惯是，如果都是函数调用，需要把内层参数括起来<pre><code> Mathematics : f(g(x))
 Haskell     : f (g x)           
 Mathematics : f(x, g(y))
 Haskell     : f x (g y) 
 Mathematics : f(x + 1, y - 1)
 Haskell     : f (x + 1) (y - 1)
</code></pre>
 这样写有最少的语法噪音</li>
<li><code>$</code>运算符<br> <code>$</code>运算符实际上表示“应用”的意思。常常可以用来改变运算顺序，从而省略括号，它可以看做<code>id</code>函数对函数的特化<pre><code> id :: a -&gt; a
 id x = x
 
 ($) :: (a -&gt; b) -&gt; a -&gt; b -- -&gt;是右结合的
 ($) :: (a -&gt; b) -&gt; (a -&gt; b)
 ($) = id
</code></pre>
 <code>f $ g x</code>，即<code>($) f (g x)</code>，等价于<code>f (g x)</code><br> 如果不加上<code>$</code>，那么<code>g</code>和<code>x</code>都会被当成一个二元<code>f</code>的两个参数，可以参照下面的例子理解：<pre><code> Prelude&gt; (+) 1 (+2) 1
 error
 
 Prelude&gt; (+) 1 $ (+2) 1
 4
</code></pre>
</li>
</ol>
<h2 id="type-class"><a href="#type-class" class="headerlink" title="type class"></a>type class</h2><p>这里的<code>a</code>称为类型参数，注意这里面的类型参数是<strong>静态</strong>的而不是动态的，编译器/解释器会自动进行类型推导<code>a</code>是什么的。如对于<code>double</code>函数</p>
<pre><code>double :: Num a =&gt; a -&gt; a
</code></pre>
<p>这里出现在<code>=&gt;</code>符号前的<code>Num a</code>作用是给类型参数<code>a</code>加上类型约束，称为类型类，或type class、type/class constraint、context(?)。当有多个类型约束时，用小括号括起所有的类型约束。<br>虽然type class和type都是大写字母开头的，但两者是<strong>不一样</strong>的，type class通过<code>class</code>等语句定义，type根据<code>type</code>、<code>data</code>等语句定义。<br>type class类似于C#中的接口interface，在功能上也有点类似于C++中的concept</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">T</span> quadruple&lt;<span class="literal">T</span>&gt; (<span class="literal">T</span> x) where <span class="literal">T</span>:INumeric&lt;<span class="literal">T</span>&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> double(double(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类型类通常通过<code>class</code>语句来定义，下面是一个最简单的示例</p>
<pre><code>class BasicEq a where
    isEqual :: a -&gt; a -&gt; Bool
    isNotEqual :: a -&gt; a -&gt; Bool
</code></pre>
<p>有关类型类的更多细节会在Ch10探讨。</p>
<h3 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h3><p>然后我们可以用<code>instance</code>语句来创造这个类型类的实例类型(instance type)，也就是<code>a</code>。<br>首先我们需要区分几个类似的用法：<br>第一个是上面见到的函数定义中的<code>Num a</code>，这是type constraint，说明函数中的类型变量<code>a</code>应当满足给出的type class。<br>第二个是马上要见到的<code>foldr</code>中的<code>t a</code>，这是由一个type constructor产生的concrete type（简称type）。<br>下面的语句定义了一个<code>Bool</code>的类型，它实现了<code>BasicEq</code>的constraint或者说type class。</p>
<pre><code>instance BasicEq Bool where
    isEqual True  True  = True
    isEqual False False = True
    isEqual _     _     = False
    isNotEqual True  True  = False
    isNotEqual False False = False
    isNotEqual _     _     = True
</code></pre>
<p>不过我们发现同时定义两个明显互补的函数是浪费而不美观的。Haskell中允许我们通过定义默认实现的方式来避免这个</p>
<pre><code>class BasicEq a where
    isEqual :: a -&gt; a -&gt; Bool
    isEqual x y = not (isNotEqual x y)

    isNotEqual :: a -&gt; a -&gt; Bool
    isNotEqual x y = not (isEqual x y)
</code></pre>
<h2 id="composition"><a href="#composition" class="headerlink" title="composition"></a>composition</h2><p>我们可以通过<code>double</code>来定义一个四倍函数</p>
<pre><code>quadruple x = double (double x)
double x = x + x    
</code></pre>
<p>更Haskell一点的方法，使用composition(fusion, pipe to)</p>
<pre><code>quadruple = double . double
(f . g) x = f (g x)     
</code></pre>
<p>这里的<code>.</code>类似于数学里面的复合函数，可以写出它的签名</p>
<pre><code>&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</code></pre>
<p>例如</p>
<pre><code>length = sum . map (\_ -&gt; 1)
</code></pre>
<p>由于Haskell是lazy的，所以看到map时，并不立即计算map</p>
<h3 id="运算符和-运算符的比较"><a href="#运算符和-运算符的比较" class="headerlink" title=".运算符和$运算符的比较"></a>.运算符和$运算符的比较</h3><p><code>.</code>运算符的作用是</p>
<pre><code>(f . g) x
:: f (g x)
</code></pre>
<p><code>$</code>运算符的作用是</p>
<pre><code>f $ g x
:: f (g x)
</code></pre>
<p>看起来他们具有相同的作用，<a href="https://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign" target="_blank" rel="noopener">但实际上两者具有差别</a>。<br><code>.</code>的作用实际上是生成一个新的函数，比如<code>f . g</code>是合法的，但是<code>f $ g</code>就不合法了。<br><code>$</code>的作用实际上是消除一些括号，于是haskell不会像lisp一样骚。</p>
<h2 id="将函数作为操作符"><a href="#将函数作为操作符" class="headerlink" title="将函数作为操作符"></a>将函数作为操作符</h2><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">factorial <span class="built_in">n</span> = <span class="built_in">product</span> [<span class="number">1</span>..<span class="built_in">n</span>]</span><br><span class="line"><span class="built_in">average</span> ns = <span class="built_in">sum</span> ns `div` length ns</span><br><span class="line">main = print (<span class="built_in">average</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>这里的<code>div</code>实际上是一个函数，加上<code>`</code>后变成了一个运算符，这称为gave accent或backquote，有点类似于fortran中的<code>.op.</code>运算符。相反地，可以在运算符两边加上小括号<code>(op)</code>将其作为柯里函数使用，称为prefix notation或者operator section，这将在后面讲到</p>
<h2 id="reload"><a href="#reload" class="headerlink" title=":reload"></a>:reload</h2><p>Haskell使用<code>:reload</code>命令通知GHC重新加载hs文件</p>
<h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ol>
<li><p>Haskell的函数或者参数名字<strong>必须</strong>以小写字母开头</p>
</li>
<li><p>类型名<strong>必须</strong>以大写字母开头</p>
</li>
<li><p>通常列表以<code>s</code>结尾</p>
</li>
<li><p>layout rule<br> 为了省略大括号，Haskell并列语句不能随意缩进（对的游标卡尺），并且缩进只能用空格，而不能够用tab</p>
<pre><code> a = b + c
     where
         b = 1
         c = 2
 d = a * 2
</code></pre>
<p> 的大括号(explicit grouping)形式是</p>
<pre><code> a = b + c
     where
         {b = 1;
         c = 2}
 d = a * 2
</code></pre>
<p> 再次说明Haskell消除了不必要的冗余语法</p>
</li>
<li><p>对Haskell缩进规则的补充<br> 如果写过Python，一定知道冒号后面要缩进，tab缩进和空格缩进是不同的，并且每个缩进的长度一定是与层级有关的，但是Haskell并不是。<br> 主要原因是Haskell不强制在“冒号”后面换行。例如在<code>do</code>语句中，如果按照Python的语言习惯，<code>do</code>后面就该直接换行了。但是Haskell可以将<code>do</code>结构里面的第一个语句写到<code>do</code>的同一行，这时候下一行的语句应当和第一个语句是并排的，例如</p>
<pre><code> putStrLn&#39; xs = do    putStr xs
                      putChar &#39;\n&#39;
</code></pre>
<p> 注意<code>putStr</code>的<code>p</code>和<code>putChar</code>的<code>p</code>是并排的，又比如</p>
<pre><code> f x = case x of 0 -&gt; 18
                 1 -&gt; 15
</code></pre>
<p> 这里面的<code>0</code>和<code>1</code>也是要对齐的<br> 但是如果我们偏偏在关键字处换行呢？那至少要缩进一个空格，例如</p>
<pre><code> putStrLn&#39; xs = do
  putStr xs 
  putChar &#39;\n&#39;
</code></pre>
<p> 和</p>
<pre><code> f x = case x of
  0 -&gt; 18
  1 -&gt; 15
</code></pre>
</li>
</ol>
<h1 id="Ch3-Types-and-Classes"><a href="#Ch3-Types-and-Classes" class="headerlink" title="Ch3 Types and Classes"></a>Ch3 Types and Classes</h1><h2 id="表达式的类型"><a href="#表达式的类型" class="headerlink" title="表达式的类型"></a>表达式的类型</h2><p>如果一个表达式<code>e</code>的计算得到类型是<code>t</code>的结果，那么称为<code>e</code>具有类型(has type)<code>t</code>，写作</p>
<pre><code>e :: t      
</code></pre>
<p>由于Haskell是静态类型的(static typed)，所以编译器能够通过类型推导(type inference)得到所有表达式的类型</p>
<h2 id="t或-type"><a href="#t或-type" class="headerlink" title=":t或:type"></a>:t或:type</h2><p>使用<code>:t</code>或<code>:type</code>可以获得参数的类型</p>
<h2 id="Haskell的基本类型"><a href="#Haskell的基本类型" class="headerlink" title="Haskell的基本类型"></a>Haskell的基本类型</h2><pre><code> Bool          | 布尔                                                   
 Char          | 字符，字符直接量用单引号括起                           
 String        | 字符串，字符串直接量用单引号括起，也可以看做Char的List 
 Int           | 固定精度整数
 Integer       | 任意精度整数
 Float         | 浮点数
 [t]           | 类型t的列表
 (t1, ..., tn) | 元组
</code></pre>
<p>特别地，使用中括号括起数据生成列表时，中括号起到data constructor作用，括起类型生成列表类型时，中括号起到type constructor作用</p>
<h2 id="函数的类型"><a href="#函数的类型" class="headerlink" title="函数的类型"></a>函数的类型</h2><p>函数也就是映射，Haskell中使用<code>t1 -&gt; t2</code>表示函数将<code>t1</code>类型映射到<code>t2</code>类型<br>我们可以用type form去“声明”函数，这就是先前看到的<code>e :: t</code>这样的语法。<br>我们也可以使用value form直接来“定义”函数，我们还可以使用lambda表达式来定义一个函数，做法是在最前面加一个反斜杠，<code>\x -&gt; y</code>。<br>特别地，lambda表达式也可以拥有多个参数，可以写成<code>\x y -&gt; x + y</code><br>由此看出，由于Haskell的类型推导机制，函数的type form在具备value form是并不是强制的（但并不总是可以省略），这和C++等强制性声明函数类型(function type)是不一样的。当然在C++模板编程中可以推导部分参数的类型/返回值，但在编译器层面，每个重载/特化版本的函数签名也是确定的。<br>在实际书写Haskell程序时，先写一遍type form来限定来限定参数的类型、规定函数的签名写出来是一个非常好的习惯，这被称为类型驱动开发（Type Driven Development）。</p>
<h2 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h2><p><code>()</code>称为unit，类似于<code>void</code>，会在monad中用到</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>对于一个多元函数，例如<code>div</code>，设想它的类型是这样的</p>
<pre><code>add :: (Int, Int) -&gt; Int
add = \(x, y) -&gt; x + y
</code></pre>
<p>但实际上它的类型是这样的</p>
<pre><code>&gt; :t div
div :: Integral a =&gt; a -&gt; a -&gt; a
</code></pre>
<p>事实上这是因为<code>add x y</code>实际上接受一个参数<code>a</code>，并返回一个<strong>一元函数</strong>（闭包），这个函数的类型是<code>a -&gt; a</code>。这个一元函数的作用是将自己的参数<code>b</code>和<code>add</code>的参数<code>a</code>相加，这样的函数称为柯里函数<br>因此实际上<code>div</code>的类型是</p>
<pre><code>div :: Integral a =&gt; a -&gt; (a -&gt; a)
</code></pre>
<p>注意到Haskell中的<code>-&gt;</code>符号是<strong>右结合</strong>的，因为柯里化是从左边开始的，所以可以省略括号写成<code>a -&gt; a -&gt; a</code><br>使用lambda可以写为</p>
<pre><code>add = \x -&gt; (\y -&gt; x + y)
add x = \y -&gt; x + y
</code></pre>
<h2 id="多态函数"><a href="#多态函数" class="headerlink" title="多态函数"></a>多态函数</h2><p>关于这一部分，在文末有专题讨论。<br>Haskell中的函数默认可以接受任意类型的参数，这称为Haskell的类型多态。但有时需要限定类型，例如<code>sum</code>函数，去接受一个<code>Bool</code>类型是没有意义的。因此我们需要引入另一种多态即Ad-hoc多态。Ad-hoc多态的实现是基于typeclass和class instance的。</p>
<h3 id="typeclass"><a href="#typeclass" class="headerlink" title="typeclass"></a>typeclass</h3><p>下面的语句为<code>a</code>提供typeclass为<code>Num</code>的类型约束</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br></pre></td></tr></table></figure>

<p>如前面Ch2.5提到过的那样，typeclass类似于C#中interface而非class。不过相比interface，我们看到typeclass中可以<a href="https://www.jianshu.com/p/b641cf2908cf" target="_blank" rel="noopener">定义具有ad-hoc多态类型的值</a>的。此外我们也注意到其实Haskell中，值也可以看成一种特殊的函数：</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> TypeClassWithValue t <span class="keyword">where</span> </span><br><span class="line">    plainValue :: t </span><br><span class="line">    functionValue :: t -&gt; t</span><br></pre></td></tr></table></figure>

<p>在typeclass中定义的函数<a href="https://wiki.haskell.org/Polymorphism" target="_blank" rel="noopener">也可以是</a>类型多态或Ad-hoc多态的，例如典型的<code>Monad</code></p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monad</span> <span class="title">m</span> <span class="title">where</span></span></span><br><span class="line">    <span class="function"><span class="params">(&gt;&gt;=)</span> :: <span class="title">m</span> <span class="title">a</span> -&gt;</span> <span class="function"><span class="params">(a -&gt; m b)</span> -&gt;</span> m b</span><br></pre></td></tr></table></figure>

<p>这里的<code>Monad</code>是一个typeclass，<code>m</code>将来是可以用<code>instance</code>产生的实例(instance)类型，也是一个type constructor，类似C++中的模板，可以用来构造类型。而<code>m a</code>则是由type constructor产生的具体类型(concrete type)——这里概念有点乱的话是正常的，可先查看<code>instance</code>与<code>type</code>的相关章节——我们注意到实例<code>m</code>受到Ad-hoc多态的typeclass <code>Monad</code>的约束，但它自己确是类型多态的，因为它可以是任意的类型<code>a</code>。</p>
<p>常用的typeclasse有</p>
<ul>
<li><code>Eq</code>：表示能判断相等的类型<ul>
<li><code>Num</code>：表示数字，不继承<code>Ord</code>。<code>Num</code>没有<code>(/)</code><ul>
<li><code>Real</code>：实数，继承了<code>Ord</code><ul>
<li><code>Integeral</code>：整型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>Ord</code>：表示能比较大小的类型<br>  特别注意，<code>Ordering</code>是一个类型，包含<code>GT</code>、<code>LT</code>、<code>EQ</code>三个constructor</li>
<li><code>Show</code>：可以被转成字符串的类型，Haskell中除了函数都能被表示成字符串</li>
<li><code>Read</code>：可以从字符串被读取的类型</li>
<li><code>Enum</code>：能被枚举的类型</li>
<li><code>Bounded</code>：有界的类型</li>
<li><code>Fractional</code>：具有除法的数字类型类<code>(/)</code><ul>
<li><code>Floating</code>：浮点</li>
</ul>
</li>
</ul>
<h3 id="Existential-Quantification"><a href="#Existential-Quantification" class="headerlink" title="Existential Quantification"></a>Existential Quantification</h3><p>作为拓展，必须介绍Existential Quantification这个Haskell类型系统中的重要概念，Haskell借助于此实现类似OOP中的多态。</p>
<h1 id="Ch4-Defining-Functions"><a href="#Ch4-Defining-Functions" class="headerlink" title="Ch4 Defining Functions"></a>Ch4 Defining Functions</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>Haskell中的<code>if</code>语句和其他语言的并无二致</p>
<pre><code>if cond then exp1 else exp2
</code></pre>
<p>但是<code>else</code>分支是<strong>必须</strong>的，毕竟是强类型语言</p>
<h2 id="guarded-equations"><a href="#guarded-equations" class="headerlink" title="guarded equations"></a>guarded equations</h2><p>这个名字还挺熟悉的，原来是在《程序设计语言原理？这本书上看到过，当时翻译成守卫。这里的guard指的是<code>|</code>符号，注意<code>|</code>在list comprehension另有用途。guarded equations是Haskell比较独特的一种表示条件分支的办法，有点类似于数学公式里面的条件，或者说其他语言中的<code>select case</code>的用法</p>
<pre><code>abs n | n &gt;= 0 = n
      | otherwise = -n
</code></pre>
<h3 id="偏函数应用与部分函数"><a href="#偏函数应用与部分函数" class="headerlink" title="偏函数应用与部分函数"></a>偏函数应用与部分函数</h3><p>不同于Scala，Haskell中的部分函数，相对于全函数(total function)是不被鼓励的。部分函数类似于<code>div</code>、<code>(!!)</code>，它并不是对于指定类型的所有值都有定义。以<code>head</code>为例，它的参数是所有的列表，可是对于一个空列表应用<code>head</code>会抛出一个异常。</p>
<pre><code>Prelude&gt; head []
*** Exception: Prelude.head: empty list
</code></pre>
<p>在Haskell中，偏函数应用<a href="https://en.wikipedia.org/wiki/Partial_application" target="_blank" rel="noopener"></a>(partial application)和<a href="https://wiki.haskell.org/Partial_functions" target="_blank" rel="noopener">部分函数</a>(partial function)是两个不同的概念。偏应用在随后会有介绍。</p>
<h2 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h2><p>这里补充一下<code>where</code>，这是一个类似占位符placeholder的语句，让我们的代码更漂亮一点，同时能够在guard、do这样的结构中复用一些结果。</p>
<pre><code>f x
  | cond1 x   = a
  | cond2 x   = g a
  | otherwise = f (h x a)
  where
    a = w x
</code></pre>
<p>可以看出来<code>where</code>的缩进应当与其所在的结构下属的语句相同，而不是与所在的结构平齐。并且where作为一个结构，其下属语句也需要缩进。<br><code>where</code>也可以通过模式匹配来定义函数</p>
<pre><code>fib = (map fib&#39; [0 ..] !!)
    where
      fib&#39; 0 = 0
      fib&#39; 1 = 1
      fib&#39; n = fib (n - 1) + fib (n - 2)
</code></pre>
<p>此外<code>go</code>惯用法里面也常用到<code>where</code></p>
<h3 id="where的作用域"><a href="#where的作用域" class="headerlink" title="where的作用域"></a>where的作用域</h3><p>根据<a href="https://stackoverflow.com/questions/8274650/in-haskell-when-do-we-use-in-with-let" target="_blank" rel="noopener">stackoverflow</a>上的这篇回答<br>对于下面的这个式子</p>
<pre><code>someFunc x y | guard1 = blah1
             | guard2 = blah2
  where {assignments}
</code></pre>
<p><code>{assignments}</code>域中只能够访问<code>x</code>和<code>y</code>，但<code>guard1</code>、<code>guard2</code>、<code>blah1</code>、<code>blah2</code>都能访问<code>{assignments}</code>。</p>
<h3 id="where存在的问题"><a href="#where存在的问题" class="headerlink" title="where存在的问题"></a>where存在的问题</h3><p><a href="https://wiki.haskell.org/Let_vs._Where" target="_blank" rel="noopener">一个不恰当的<code>where</code>语句会导致性能的降低</a>，比较一下下面的两段代码</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- <span class="number">1</span></span><br><span class="line">fib = (map fib' [<span class="number">0</span> ..] !!)</span><br><span class="line">    where</span><br><span class="line">      fib' <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">      fib' <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">      fib' n = fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">-- <span class="number">2</span></span><br><span class="line">fib x = map fib' [<span class="number">0</span> ..] !! x</span><br><span class="line">    where</span><br><span class="line">      fib' <span class="number">0</span> = <span class="number">0</span></span><br><span class="line">      fib' <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">      fib' n = fib (n - <span class="number">1</span>) + fib (n - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>这两种写法互为eta-conversion(η-conversion)。eta-conversion是lambda演算中的一种变换，指<code>\x -&gt; f x</code>和<code>f</code>这两种写法在语义上是等价的。<br>但实际上第一段代码要比第二段代码要快，这是因为第一段代码满足了Constant applicative form(CAF)，因此编译器默认会进行优化，而对于第二段代码由于<code>x</code>不确定，所以对于每个<code>x</code>，编译器都要重新计算一遍<code>fib&#39;</code>函数。<br>使用GHC的float-in/float-out能够进行优化。</p>
<h3 id="where、let-in与let的区别"><a href="#where、let-in与let的区别" class="headerlink" title="where、let in与let的区别"></a>where、let in与let的区别</h3><p>首先let和前两者是非常不同的。</p>
<p><code>let..in..</code>含义是在let和in之间可以包含多个表达式作为定义，辅助in后面的一个表达式，而in后面的表达式是整个<code>let..in..</code>的值。例如</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g <span class="attr">x</span> = <span class="keyword">let</span> &#123;<span class="attr">y</span> = x + <span class="number">1</span>; <span class="attr">z</span> = y + <span class="number">1</span>&#125; <span class="keyword">in</span> z</span><br></pre></td></tr></table></figure>

<p>则<code>g 1</code>等于3。</p>
<h2 id="pattern-matching"><a href="#pattern-matching" class="headerlink" title="pattern matching"></a>pattern matching</h2><p>模式匹配(pattern matching)可以用来进行解构绑定(deconstruction binding)<br>借助于Haskell的模式匹配还可以实现下面的写法。</p>
<pre><code>not :: Bool -&gt; Bool
not True = False
not False = True
</code></pre>
<p>这可以借助OOP中的虚函数(dynamic dispatch)实现，例如下面的C#伪代码</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">Bool</span> Not();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">True</span> : <span class="title">Bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">Bool</span> Not()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">False</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">False</span> : <span class="title">Bool</span></span>&#123;</span><br><span class="line">    <span class="keyword">Bool</span> Not()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">True</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别地，下划线<code>_</code>表示可以匹配任何参数，称为wildcard。例如</p>
<pre><code>True &amp;&amp; b = b
False &amp;&amp; _ = False
</code></pre>
<h2 id="lazy-evaluation"><a href="#lazy-evaluation" class="headerlink" title="lazy evaluation"></a>lazy evaluation</h2><p>lazy evaluation相对于eager evaluation有相当的好处，<strong>阐明这点将贯穿整个课程</strong>，这里讲了一个比较具体的例子</p>
<pre><code>f x = 4711
</code></pre>
<p>于是可以有下面的求值方案，这里<code>X</code>是某个任意值</p>
<pre><code>f(True &amp;&amp; X)
= f(X)
= 4711
</code></pre>
<p>这样的好处是避免了对<code>X</code>的求值（注意这里<code>X</code>没有被逻辑与短路），因为<code>X</code>可能是不可计算的：假如定义并求值<code>X = X</code>或者<code>X = head []</code>，那程序是不能终止(non-terminating)的，在Haskell中是通常的一种错误(Error)形式。但是<code>f(X)</code>是可以计算的。采用eager evaluation的大多数其他语言会在<code>True &amp;&amp; X</code>表达式时就对X求值，而这时会造成问题的。<br>此外，lazy evaluation无论对于什么样的求值顺序结果都是不变的，这是由于Haskell语言本身（除了Monad）不会造成副作用。例如对于上面的例子可以直接根据<code>f x = 4711</code>归约</p>
<pre><code>f(True &amp;&amp; X) = 4711
    
</code></pre>
<h2 id="pattern具有优先级"><a href="#pattern具有优先级" class="headerlink" title="pattern具有优先级"></a>pattern具有优先级</h2><p>对于这个例子中，值永远是<code>False</code>，因为第一个规则的优先级更高</p>
<pre><code>_ &amp;&amp; _ = False
True &amp;&amp; True = True
</code></pre>
<p>所以我们在写规则的时候，会把<strong>更特化</strong>的规则写在<strong>前</strong>面，这是非常需要重视的一点。</p>
<h2 id="重复的名字不能出现在pattern中"><a href="#重复的名字不能出现在pattern中" class="headerlink" title="重复的名字不能出现在pattern中"></a>重复的名字不能出现在pattern中</h2><p>此外还需要注意重复的名字(patterns may not repeat variables)，例如下面的代码是错误的</p>
<pre><code>b &amp;&amp; b = True
</code></pre>
<p>会输出错误</p>
<pre><code>? Conflicting definitions for ‘b’
Bound at: F:\Codes\Haskell\3.hs:2:1
        F:\Codes\Haskell\3.hs:2:6
? In an equation for ‘Main.&amp;&amp;’
</code></pre>
<p>这是为什么呢？<br>其实这样的东西称为nonlinear pattern。理想情况下，我们希望通过使用同一个字符<code>b</code>来限定<code>&amp;&amp;</code>的左操作数和右操作数是相等的。但是这是不可能实现的，因为当左右操作数出现lambda时，是没有一个统一标准判断lambda是否相等的</p>
<h2 id="list-pattern和"><a href="#list-pattern和" class="headerlink" title="list pattern和:"></a>list pattern和<code>:</code></h2><p>运算符<code>:</code>(cons)可以构造列表，下面的第一行代码称为list constructor，我们常喜欢用的第二行可以看做第一行的语法糖。</p>
<pre><code>1:(2:(3:[]))
[1,2,3]
</code></pre>
<p>然而它还可以用在pattern matching中，例如实现<code>head</code>和<code>tail</code></p>
<pre><code>head :: [a] -&gt; a
head (x:_) = x
tail :: [a] -&gt; [a]
tail (_:xs) = xs
</code></pre>
<p>注意点：</p>
<ol>
<li>用<code>x:xs</code>去pattern matching空list是未定义行为  </li>
<li><code>x:xs</code>一定要用括号括起来，因为函数调用(application)的优先级比<code>:</code>的优先级要高</li>
<li>注意区分<code>**(x:y)**</code>和<code>**[x:y]**</code><br> <code>[x:y]</code>匹配具有<strong>一个</strong>参数的list，这个参数满足匹配<code>x:y</code><br> <code>(x:y)</code>匹配具有<code>x</code>作为head和<code>y</code>作为tail的list<br> 总之，<code>[]</code>匹配是固定个数的，可以利用这个来匹配终结条件，例如<pre><code> product [] = 1
 product (x:xs) = x * product xs
</code></pre>
 或<pre><code> product [x] = x
 product (x:xs) = x * product xs
</code></pre>
</li>
<li>as sign(@)<br> 有时候会见到这样的代码<code>ps@(x:xs)</code>，这时候我们可以同时给列表、列表中的第一个元素、列表的剩余部分同时命名。</li>
<li>有办法去pattern matching列表的最后一个元素么<br> 为什么要去这样做呢？我们要注意到haskell中的列表是lazy evaluate的，也常是无尽列表，而无尽列表是不存在最后一个元素的。</li>
<li>integer pattern<br> 这是一个类似数列递推公式的pattern，可以使用<code>n + k</code>这样的形式使用。这时候<code>n</code>是一个变量，而<code>k</code>是一个常数<pre><code> pred :: Int -&gt; Int
 pred (n + 1) = n
 
 fib :: Integer -&gt; Integer 
 fib 0 = 1
 fib 1 = 1
 fib n = fib (n-1) + fib (n-2)
 main = print (fib 5)        
</code></pre>
 函数调用(application)的优先级比<code>+</code>等代数运算的优先级要高，所以同样要用括号括起来</li>
</ol>
<h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>在上一Chapter中通过<code>add</code>的例子讲到Haskell如何通过柯里化让一个函数返回另一个函数，而使用lambda可以更清晰地表现出一个函数究竟是返回的一个值还是另一个函数。例如</p>
<pre><code>const :: a -&gt; b -&gt; a
const x _ = x
</code></pre>
<p>也可以写成柯里形式，接受一个参数，返回一个接受一个参数的函数</p>
<pre><code>const x = \_ -&gt; x
</code></pre>
<p>使用lambda同时还可以声明一个匿名函数，然后避免定义这个只用一次的具名函数。<br>对于多元的lambda表达式</p>
<pre><code>\x -&gt; \y -&gt; f x y
</code></pre>
<p>可以简写为</p>
<pre><code>\x y -&gt; f x y
</code></pre>
<h2 id="section与偏函数"><a href="#section与偏函数" class="headerlink" title="section与偏函数"></a>section与偏函数</h2><p>prefix notation是Haskell独有的特性，即之前(Ch2.6)上在运算符两边加上小括号<code>(op)</code>将其作为柯里函数的用法。因为在Python中要不自己定义一个<code>lambda x,y: x + y</code>要不传一个<code>operator.add</code><br>注意到既然是柯里函数，意味着说我们还可以这样写，这称为section</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; (<span class="number">1</span>+) <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; (+<span class="number">2</span>) <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>而不要写成<code>lambda x: 1 + x</code></p>
<p>作为补充，提及一下。类似于<code>(1+)</code>的写法称为<a href="https://wiki.haskell.org/Partial_application" target="_blank" rel="noopener">偏函数应用</a>(partial function application)。<br>偏函数是对于柯里化来说的，类似于C++中的偏特化，其目的是固定一个多元函数中的某几个函数的值，产生一个新函数。例如对于<code>add</code>函数</p>
<pre><code>add :: Int -&gt; (Int -&gt; Int)
add x y = x + y
</code></pre>
<p>我们可以特化出一个<code>addOne</code>函数</p>
<pre><code>addOne :: Int -&gt; Int
addOne = add 1
</code></pre>
<p>在定义偏函数应用的时候，要注意我们partial的是<strong>application</strong>而不是function。例如偏函数应用也能对下面比较复杂的高阶函数奏效</p>
<pre><code>comp2 :: (a -&gt; b) -&gt; (b -&gt; b -&gt; c) -&gt; (a -&gt; a -&gt; c)
comp2 f g = (\x y -&gt; g (f x) (f y))
</code></pre>
<p>现在我们试图特化<code>g</code>为<code>add</code>，可以记住一条简单的规则偏应用的定义式右部必须出现原函数，例如<code>addOne</code>函数的右部出现了<code>add</code>函数。<br>因此尝试<code>comp2&#39; f = (\x y -&gt; add (f x) (f y))</code>是不对的，它实际上定义了一个新的函数，而正确的偏应用应当为</p>
<pre><code>comp2&#39; f = comp2 f add
</code></pre>
<h1 id="Ch5-List-Comprehensions"><a href="#Ch5-List-Comprehensions" class="headerlink" title="Ch5 List Comprehensions"></a>Ch5 List Comprehensions</h1><p>顾名思义，这章讲的是Haskell的列表生成器</p>
<pre><code>[x + 1 | x &lt;- [1..5]]
</code></pre>
<p>这个最近的<a href="https://ericniebler.github.io/std/wg21/D4128.html" target="_blank" rel="noopener">C++标准/草案中也有类似的range</a><br>可以生成笛卡尔积</p>
<pre><code>&gt; [(x,y) | x &lt;- [1,2,3], y &lt;- [4,5]]
[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
</code></pre>
<p>这类似嵌套的for循环的性质，越往右for的嵌套层数越深</p>
<pre><code>&gt; [(x,y) | y &lt;- [4,5], x &lt;- [1,2,3]]
[(1,4),(2,4),(3,4),(1,5),(2,5),(3,5)]
</code></pre>
<p>同样类似嵌套的for循环，内层for的界可以依赖外层的值</p>
<pre><code>&gt; [(x,y) | x &lt;- [1..3], y &lt;- [x..3]]
</code></pre>
<p>它还可以做</p>
<pre><code>concat :: [[a]] -&gt; [a]
concat xss = [x | xs &lt;- xss, x &lt;- xs]
</code></pre>
<p>这类似于派通(Python，老外奇妙的口音)中的</p>
<pre><code>[item for sublist in [[1,2], [3], [4,5,6]] for item in sublist]
</code></pre>
<p>还可以加上guard</p>
<pre><code>[x | x &lt;- [1..10], even x]
</code></pre>
<p>下面是一个质数暴力筛程序</p>
<pre><code>factors :: Int -&gt; [Int]
factors n = [x | x &lt;- [1..n], n `mod` x == 0]
prime :: Int -&gt; Bool
prime n = factors n == [1,n]
primes :: Int -&gt; [Int]
primes n = [x | x &lt;- [2..n], prime x]   
</code></pre>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>常用函数不解释</p>
<pre><code>zip :: [a] -&gt; [b] -&gt; [(a, b)]
</code></pre>
<p>Haskell中的<code>zip</code>函数同样是不要求两个list长度匹配的，于是可以写出这样的代码</p>
<pre><code>&gt; pairs xs = zip xs (tail xs)
&gt; pairs [1,2,3,4]
[(1,2),(2,3),(3,4)]
</code></pre>
<p><code>zip</code>的反函数是<code>unzip</code></p>
<pre><code>unzip :: [(a, b)] -&gt; ([a], [b])
</code></pre>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p><code>string</code>是Char的list</p>
<h1 id="Ch6-Recursive-Functions"><a href="#Ch6-Recursive-Functions" class="headerlink" title="Ch6 Recursive Functions"></a>Ch6 Recursive Functions</h1><ol>
<li><p>介绍__Why Functional Programming Matters__这本书<br> 为什么lazy和pure的functional programming很重要</p>
</li>
<li><p>证明</p>
<pre><code> product [1..n] = recfac n
</code></pre>
</li>
<li><p>递归的作用</p>
<ol>
<li>容易</li>
<li>自然</li>
<li>能够使用数学方法induction</li>
</ol>
</li>
<li><p>lazy evaluation和purity<br> 这块讲得比较抽象，实际上就是不同的函数有一些相似点可以提炼成一个大操作，这个大操作中包含着若干实现不同的小操作（初始条件，迭代更新规则），由于小操作是不互相影响的(purity)，所以可以只实现提炼出的大操作，然后对于每个函数实现对应的小操作。这些在下一章会有详细说明</p>
</li>
<li><p>多元函数的递归</p>
<pre><code> zip :: [a] -&gt; [b] -&gt; [(a,b)]
 zip [] _ = []
 zip _ [] = []
 zip (x:xs) (y:ys) = (x,y) : zip xs ys
</code></pre>
</li>
<li><p>drop<br> drop需要处理两个初始条件</p>
<pre><code> drop :: Int -&gt; [a] -&gt; [a]
 drop 0 xs = xs
 drop _ [] = []
 drop n (_:xs) = drop (n-1) xs
 
</code></pre>
</li>
<li><p>quick sort<br> 下面是出现在整个课程开头的快速排序</p>
<pre><code> qsort :: Ord a ⇒ [a] -&gt; [a]
 qsort [] = []
 qsort (x:xs) =
     qsort smaller ++ [x] ++ qsort larger
     where
         smaller = [a | a &lt;- xs, a &lt;= x]
         larger = [b | b &lt;- xs, b &gt; x]
</code></pre>
</li>
</ol>
<h1 id="Ch7-Higher-Order-Functions"><a href="#Ch7-Higher-Order-Functions" class="headerlink" title="Ch7 Higher-Order Functions"></a>Ch7 Higher-Order Functions</h1><p>上一章讲了如何使用递归来实现某些函数，这章学习通过高阶函数如<code>map</code>、<code>filter</code>、<code>foldr</code>来实现它们<br>高阶函数(Higher-Order Functions)指的是接受一个函数作为参数，或者返回一个函数的函数（然而Haskell天生自带Currying，所以参数大于等于2就一定是高阶函数了啊）<br>首先介绍一些关于Combinator的书</p>
<h2 id="高阶函数用途"><a href="#高阶函数用途" class="headerlink" title="高阶函数用途"></a>高阶函数用途</h2><ol>
<li>common programming idiom<br> 写出更短小精炼的程序</li>
<li>DSL<br> 可以方便地定义领域特定语言(DSL)，例如一个简单的加法器的语法<pre><code> data expr
     = value
     = add expr expr         
</code></pre>
 可以发现这和我们常用来描述文法的BNF是非常类似的，而下面需要parse的话可以实现一个eval函数<pre><code> eval :: expr -&gt; Int
</code></pre>
 Haskell相比C++方便多了，要是C++的话可能会想着自己撸个逆波兰式或者LL/LR解释器啥的<br> 另外Haskell的模式匹配也减少了大量的代码</li>
<li>algebra properties<br> 高阶函数具有一定的代数性质可以进行宏观变换，而不要担心实现细节，类似于上一章讲到的分为大操作小操作</li>
</ol>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map接受一个函数和一个列表，将这个函数应用到列表中的每个元素中，并返回一个列表</p>
<pre><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>注意不要错写成</p>
<pre><code>map :: a -&gt; b -&gt; [a] -&gt; [b]
</code></pre>
<p>在一些函数式编程语言中还可以见到<code>flatMap</code>这个函数，它和<code>map</code>有本质的不同，它的签名可以写为<code>flatMap :: (a -&gt; [b]) -&gt; [a] -&gt; [b]</code>。当作用在一个<code>[a]</code>数组时，可以理解成它首先生成<code>[[b]]</code>数组，再将这个数组拍平成<code>[b]</code></p>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>可以通过guard或者list comprehension来实现filter</p>
<h2 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h2><p>Haskell或者C++17中的fold expression，类似于python等语言中的<code>reduce</code>函数。这两者的区别在reduce只能处理一个相同类型（fold前），但是fold可以处理两个不同类型（fold前和fold的结果）<br>Haskell中分为<code>foldl</code>和<code>foldr</code>，其中<code>foldr</code>比较常用，将归约到的值作为运算f的右操作数</p>
<pre><code>foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
foldr f v [] = v
foldr f v (x:xs) = f x (foldr f v xs)
</code></pre>
<p>它接受三个参数：</p>
<ol>
<li><code>(a -&gt; b -&gt; b)</code>：一个接受<code>a</code>和<code>b</code>类型参数并返回<code>b</code>类型参数的函数</li>
<li><code>b</code>：归约到的类型</li>
<li><code>t a</code>：这个表示一个<code>t a</code>的类型。这里<code>t</code>表示一个<code>Foldable</code>的类型。<br> 在C++中有叫模板参数的东西，例如<code>std::vector&lt;int&gt;</code>表示一个用<code>int</code>特化的向量表<code>vector</code>。Haskell中的<code>t a</code>类似于这个，其中<code>t</code>对应着类模板<code>vector</code>，<code>a</code>对应着类型<code>int</code>。<br> 因此可以理解成一个叫<code>t</code>的函数，接受一个<strong>类型变量(type variable)</strong><code>a</code>作为参数，产生了一个新的类型<code>t a</code>。这里的<code>t</code>称为type constructor，而<code>a</code>是一个concrete type。<br> 一个concrete type是具有值的，例如<code>Int</code>之类的，它通常是由<code>data</code>声明的；但一个type constructor function必须接受<strong>一个</strong>type parameter才能成为一个concrete type，例如，当<code>t</code>为list时，<code>t a</code>就是<code>[a]</code>，这里<code>[a]</code>是一个语法糖，等价于<code>[] a</code>。type constructor通常是由<code>class</code>声明的并可以由<code>instance</code>提供实现的，例如<code>instance Applicative []</code>。<br>这里注意，这里的<code>t</code><strong>并不一定是容器类型</strong>，例如它不局限于list、tuple这样的东西，所以我们不能局限地认为<code>fmap</code>是“对于某个容器里面的所有元素都进行XX操作”。</li>
<li><code>=&gt;</code>：我们之前见过在<code>=&gt;</code>左边的<code>Num a</code>，这个称为类型约束。而<code>=&gt;</code>右侧的函数签名部分，称为type form。</li>
</ol>
<p>因此这个函数可以理解为</p>
<pre><code>foldr f 当前/初始归约的结果 用来归约的列表  
</code></pre>
<p><code>reduce</code>可以用<code>fold</code>来实现，例如Python中的</p>
<pre><code>print reduce(lambda x, y: x + [y], [1,2,3,4], [])
</code></pre>
<p>可以用<code>foldr</code>实现为</p>
<pre><code>main = print (foldr (\x -&gt; \y -&gt; [x] ++ y) [] [1,2,3,4])
</code></pre>
<p>类似的有<code>foldl</code>函数</p>
<pre><code>foldl :: Foldable t =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</code></pre>
<p>上面的reduce可以用<code>foldl</code>实现为</p>
<pre><code>main = print (foldl (\x -&gt; \y -&gt; x ++ [y]) [] [1,2,3,4])
</code></pre>
<h3 id="foldl和foldr的区别"><a href="#foldl和foldr的区别" class="headerlink" title="foldl和foldr的区别"></a>foldl和foldr的区别</h3><p>从定义上看，这两个函数的区别在第一个参数<code>f</code>上，这实际反映了运算顺序的不同。查看定义</p>
<pre><code>foldlX f acc [] = acc
foldlX f acc (x:xs) = trace (&quot;acc == &quot; ++ show acc) foldlX f acc&#39; xs
    where
    acc&#39; = f acc x

foldrX f acc [] = acc
foldrX f acc (x:xs) = trace (&quot;acc == &quot; ++ show acc) f x (foldrX f acc xs)
</code></pre>
<p>执行结果</p>
<pre><code>&gt; main = print $ foldlX (+) 0 [1..5]
acc == 0
acc == 1
acc == 3
acc == 6
acc == 10
15
&gt; main = print $ foldrX (+) 0 [1..5]
acc == 0
acc == 0
acc == 0
acc == 0
acc == 0
15
</code></pre>
<p>提炼出来<br>    foldl = foldl f(x, acc) xs<br>    foldr = f x foldr(acc, xs)<br>可以发现<code>foldl</code>是从左到右计算的，但<code>foldr</code>是从右到左计算的。由此导致的<code>foldl</code>会产生一个尾递归（右递归），<code>foldr</code>产生一个左递归。由于编译器可以针对尾递归优化，所以<code>foldl</code>可能会快一点。此外，利用strict特性（详见Ch12 strict application）的<code>foldl&#39;</code>能够减少空间。<br>那么<code>foldr</code>的优势在于处理无穷列表的时候，考虑</p>
<pre><code>myAndL = foldl (&amp;&amp;) True 
myAndR = foldr (&amp;&amp;) True 
&gt; myAndL (repeat False)
&gt; myAndR (repeat False)
</code></pre>
<p>那么<code>foldr</code>由于<code>f = (&amp;&amp;)</code>的性质被短路，所以能够返回。但是<code>foldl</code>的<code>f</code>在内部，而<code>foldl</code>本身不具备短路原则，会陷入无限的尾递归</p>
<p>部分内容来自<a href="https://gengzhenglin.wordpress.com/2014/11/02/haskell%E4%B8%ADfoldl%E4%B8%8Efoldr%E7%9A%84%E5%8C%BA%E5%88%AB/" target="_blank" rel="noopener">文章</a>进行说明</p>
<h3 id="使用fold实现函数"><a href="#使用fold实现函数" class="headerlink" title="使用fold实现函数"></a>使用fold实现函数</h3><p>fold是被提炼出的一种“大操作”，利用foldr可以实现很多函数，之前这些函数往往要递归地通过guard、if或者list comprehension来实现</p>
<pre><code>sum = foldr (+) 0
</code></pre>
<p>这是因为</p>
<pre><code>  sum [1,2,3]
= foldr (+) 0 [1,2,3]
= foldr (+) 0 (1:(2:(3:[])))
= 1+(2+(3+0))
</code></pre>
<p>类似地可以定义</p>
<pre><code>product = foldr (*) 1
or = foldr (||) 1
and = foldr (&amp;&amp;) 1
</code></pre>
<p>对于<code>length</code>函数可以如此定义</p>
<pre><code>length = foldr (\_ n -&gt; 1 + n) 0
length = sum . map (\_ -&gt; 1)
</code></pre>
<p>对于<code>reverse</code>函数可以如此定义</p>
<pre><code>reverse = foldr (\x xs -&gt; xs ++ [x]) []
</code></pre>
<p>这是因为</p>
<pre><code>  reverse [1,2,3]
= reverse (1:(2:(3:[])))
= (([] ++ [3]) ++ [2]) ++ [1]
</code></pre>
<p>所以可以看到<code>foldr</code>接受<code>a</code>类型的<code>x</code>和<code>b</code>类型的<code>xs</code>，然后反向地去连接<code>xs</code>和<code>[x]</code>，最后得到的是另一个列表，这和上面的<code>length</code>函数是不一样的<br>特别地，可以重新定义<code>++</code></p>
<pre><code>(++ ys) = foldr (:) ys
</code></pre>
<p>这是因为</p>
<pre><code>(xs ++ ys) = foldr (:) ys xs
</code></pre>
<p>这表示把<code>Foldable</code>类型的<code>xs</code>中的每个元素<code>:</code>到<code>ys</code>的前面，这就相当于</p>
<pre><code>  foldr (:) ys [1,2,3]
= foldr (:) ys (1:(2:(3:[])))
= (1:(2:(3:[ys])))
</code></pre>
<p>继续改写</p>
<pre><code>  (xs ++ ys)
= (++) xs ys -- 这里原版写的是(++) ys xs但是我觉得应该是(++) xs ys
= foldr (:) ys xs
</code></pre>
<p>因此可以得到</p>
<pre><code>  (++) ys = foldr (:) ys
= (++ ys) = foldr (:) ys
</code></pre>
<h3 id="fold的作用"><a href="#fold的作用" class="headerlink" title="fold的作用"></a>fold的作用</h3><ol>
<li>有些递归函数用foldr更容易实现（可以从之前的讨论中看出）</li>
<li>有些函数的性质可以通过foldr的代数性质推导得到，例如fusion规则和banana split规则<ul>
<li>fusion<br>  fusion(composition)是之前讨论过的<code>.</code>运算符，用来实现<strong>复合函数</strong>，其具有类型<pre><code>  (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)     
</code></pre>
</li>
<li>banana split<br>  这个会在后面提及</li>
</ul>
</li>
<li>使用foldr而不是递归，可以方便进行优化</li>
</ol>
<h2 id="unfoldr"><a href="#unfoldr" class="headerlink" title="unfoldr"></a>unfoldr</h2><p><code>unfoldr</code>为<code>foldr</code>的对偶函数，定义为</p>
<pre><code>unfoldr :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]
</code></pre>
<p>一般可以理解为<code>a</code>为生成的list里面的每一项，而<code>b</code>是下次迭代的时候的<code>b</code>，类似于for循环中的更新规则</p>
<p>unfoldr具有性质</p>
<pre><code>unfoldr f&#39; (foldr f z xs) == xs
</code></pre>
<h2 id="scanl"><a href="#scanl" class="headerlink" title="scanl"></a>scanl</h2><p><code>scanl</code>和<code>foldl</code>非常相似，只不过它是“扫描”获得列表，而不是将列表“折叠”起来</p>
<pre><code>(a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; [a]
</code></pre>
<h2 id="更多的高阶函数"><a href="#更多的高阶函数" class="headerlink" title="更多的高阶函数"></a>更多的高阶函数</h2><p>all、any、takeWhile（常常被用来读无尽列表）、dropWhile</p>
<h2 id="fmap"><a href="#fmap" class="headerlink" title="fmap"></a>fmap</h2><p><code>fmap</code>与Functor息息相关，Functor在下章会进行补充。首先比较一下<code>fmap</code>和<code>map</code>的定义</p>
<pre><code>Prelude&gt; &gt; :t fmap
fmap :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
Prelude&gt; &gt; :t  map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p><code>fmap</code>接受一个<code>(a -&gt; b)</code>函数，这个函数负责将一个<code>f a</code>转换为<code>f b</code>。这里注意<code>f</code>是一个type constructor。<br>如果我们把<code>fmap</code>的<code>f</code>替换成<code>[]</code>，便可以发现<code>map</code>实际上是<code>fmap</code>对list即<code>[]</code>的特化。</p>
<pre><code>instance Functor [] where  
    fmap = map  
</code></pre>
<h1 id="Ch8-Functional-Parsers"><a href="#Ch8-Functional-Parsers" class="headerlink" title="Ch8 Functional Parsers"></a>Ch8 Functional Parsers</h1><p>在官网上下载的PPT中第8章是Declaring Types and Classes，但实际上这章在课程中被放到了第10章。本章是Functional Parsers，会讲授重要的概念Monads，于是教授穿了件自己设计的（密集恐惧症）衣服<br>这一章会有点突兀，有比较多的没学过的东西，在我学习的过程中，最让我感到困惑的并不是Monad本身，而是教授讲授时定义的复杂的类型，例如即将看到的<code>IO a</code>和<code>Show a</code>这样的类型，有时这会导致运行教授讲授的代码存在困难，不得不说是课程的一个缺憾。<br>首先要补充一个控制结构，对于下面的guard</p>
<pre><code>f 0 = 18
f 1 = 15
f 2 = 12
f x = 12 - x
</code></pre>
<p>这种写法又称为piece-wise version，因为实际上定义了4个<code>f</code>函数。如果用<code>case</code>，可以写作</p>
<pre><code>f x = case x of 0 -&gt; 18
                1 -&gt; 15
                2 -&gt; 12
                _ -&gt; 12 - x
</code></pre>
<p>课程开始，照例讲了点别的，介绍<em>Functional Portal</em></p>
<h2 id="Parser-Type"><a href="#Parser-Type" class="headerlink" title="Parser Type"></a>Parser Type</h2><p>在本章中，我们要实现一个类型<code>Parser</code>，通过实现这个<code>Parser</code>，我们也就实现了Monad的核心部分。<br>很自然地，在Haskell中，用函数来表示Parser</p>
<pre><code>type Parser = String -&gt; Tree
</code></pre>
<p>但是有时候Parser只处理输入串String的一部分，所以Parser也要返回未使用的String</p>
<pre><code>type Parser = String -&gt; (Tree, String)
</code></pre>
<p>有时候输入串String不能生成语法树Tree，于是Tree并不是一定有的，是一个optional值，这在Haskell中可以用<code>Maybe</code>来表示</p>
<pre><code>data Maybe a = Nothing
             | Just a
</code></pre>
<p><code>Maybe</code>在Haskell中用来处理optional值，它是一个Monad，<code>data</code>语句在第10章会有介绍，<code>Nothing</code>和<code>Just a</code>是<code>Maybe a</code>的两个constructor，它们看起来像为C++中的<code>enum</code>，但实际上更类似于C++中的构造函数。<code>Maybe</code>一个类型可以从<code>Nothing</code>构造，但返回一个非<code>Nothing</code>的值<code>a</code>时就需要返回<code>Just a</code>。<br><code>Nothing</code>很好理解，类似于其他语言中的<code>null</code>、<code>None</code>、<code>nil</code><br>在没学习Ch10 Declaring Types and Classes时，<code>Just</code>是个比较奇怪的概念。首先查看它的定义 </p>
<pre><code>Just :: a -&gt; Maybe a
</code></pre>
<p>从定义中可以看到<code>Just</code>返回的是<code>Maybe a</code>对象，这有点类似于函数重载或者SFINAE的意味，我们可以理解为调用了<code>Maybe</code>不同的构造函数，并且<code>Nothing</code>可以表示另一个构造函数，不过这个构造函数不接受参数罢了。如果我们把<code>data</code>语句当成了<code>enum</code>，这里就不好理解了。<br>教授认为出于方便考虑，并不需要使用<code>Maybe</code>这东西，用一个简单的list就可以了</p>
<pre><code>type Parser = String -&gt; [(Tree, String)]
</code></pre>
<p>因此这个list要不是一个单元素的列表(singleton list)，要不是个空列表<br>最后，Parser并不一定返回一个语法树，所以加上一个泛型</p>
<pre><code>type Parser a = String -&gt; [(a, String)]
</code></pre>
<p>总结一下，现在我们已经知道了list的作用是为了实现optional，tuple的作用是辅助类似于遍历字符串的一个指针。<br>事实上这个<code>Parser</code>是一个Monad雏形。注意如果使用附带的代码Parsing.hs会发现视频隐藏了<code>Parser</code>的一些关键定义，这会导致直接键入并运行视频中的代码可能会出现错误（接下来会看到）。视频中给出上面这样的<code>Parser</code>定义是为了方便理解的考虑，实际上也是实现了一个Monad的type class。</p>
<h3 id="Bottom"><a href="#Bottom" class="headerlink" title="Bottom"></a>Bottom</h3><p>我打算在这里插进来介绍一个<code>_|_</code>，它叫Bottom。<br>当我们在讨论编程语言时，我们常常厌恶null。但实际上null的语义是无法避免的，因为停机问题是没有解的。Haskell中也有Bottom这个东西。</p>
<h2 id="一些简单的语法分析器"><a href="#一些简单的语法分析器" class="headerlink" title="一些简单的语法分析器"></a>一些简单的语法分析器</h2><h3 id="item"><a href="#item" class="headerlink" title="item"></a>item</h3><p>这个Parser在输入为空是fail，否则读取输入的第一个字符，下面根据<code>type Parser a = String -&gt; [(a, String)]</code>来推导item的类型</p>
<pre><code>item :: Parser Char
     :: String -&gt; [(Char, String)]
     :: [Char] -&gt; [(Char, [Char])]
</code></pre>
<p>下面查看item的定义</p>
<pre><code>item = \inp -&gt; case inp of
                    [] -&gt; []
                    (x:xs) -&gt; [(x,xs)]
</code></pre>
<h3 id="failure"><a href="#failure" class="headerlink" title="failure"></a>failure</h3><p>和名字一样，这个语法分析器总是失败</p>
<pre><code>failure :: Parser a
failure = \inp -&gt; []
</code></pre>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>这个语法分析器的定义不太一样了，它返回一个接受任何输入的一个语法分析器，这个语法分析器对于任意输入返回<code>v</code>。</p>
<pre><code>return :: a -&gt; Parser a
return v = \inp -&gt; [(v, inp)]       
</code></pre>
<p>我们分析一下返回类型</p>
<pre><code>   Parser a
:: String -&gt; [(a, String)]
:: [Char] -&gt; [(Char, String)]
</code></pre>
<p>原来返回的是个函数，测试一下</p>
<pre><code>main = print $ (return &quot;123&quot;) &quot;xxx&quot;
</code></pre>
<p>发现结果是<code>&quot;123&quot;</code></p>
<h4 id="return关键字的辨析"><a href="#return关键字的辨析" class="headerlink" title="return关键字的辨析"></a>return关键字的辨析</h4><p>Haskell中的<code>return</code>的和大多数语言中<code>return</code>关键字名字相同，也都经常出现在语句的末尾。但两者的意义却完全不同。Haskell中也不需要什么<code>return</code>，语句自身就是返回值，所以不要把两个混淆。<br>在Haskell的Prelude中定义有类似以上代码实现的<code>return</code>函数。</p>
<pre><code>&gt; :t return
return :: Monad m =&gt; a -&gt; m a
</code></pre>
<p>实际上<code>return</code>是Monad里面的一个非常重要的运算，在后面即将讲到。</p>
<h3 id=""><a href="#" class="headerlink" title="+++"></a>+++</h3><p>这个语法分析器类似于一个选择结构，实际上它是一个存在的运算符<code>&lt;*&gt;</code>的重新实现。它表现得像语法分析器<code>p</code>，如果<code>p</code>能succeed，否则表现得像语法分析器<code>q</code></p>
<pre><code>(+++) :: Parser a -&gt; Parser a -&gt; Parser a
p +++ q = \inp -&gt; case p inp of
                        [] -&gt; parser q inp
                        [(v, out)] -&gt; [(v, out)]                                
</code></pre>
<h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p><code>parse</code>是个很重要的语法分析器，如果实际运行附带代码里面的Parsing.hs，就会发现</p>
<pre><code>print (item &quot;123&quot;)
</code></pre>
<p>是会报错的，正确的方式是运行</p>
<pre><code>print (parse item &quot;123&quot;)
</code></pre>
<p>这类似<code>return</code>的问题，这是因为<code>Parser</code>的定义不同导致的，在现阶段应该使用视频中给出的代码<br>再看一下<code>parse</code>的定义</p>
<pre><code>parse :: Parser a -&gt; String -&gt; [(a, String)]
parse p inp = p inp
</code></pre>
<p>值得注意的是<code>parse</code>函数将这个语法分析器（再次强调根据<code>type Parser</code>定义，<code>Parse</code>实际上也<strong>是一个函数</strong>）<code>p</code>应用(apply)到<code>inp</code>上。它的作用是让代码更清晰</p>
<h2 id="检验上面的语法分析器"><a href="#检验上面的语法分析器" class="headerlink" title="检验上面的语法分析器"></a>检验上面的语法分析器</h2><p>检验上面的语法分析器需要<code>Parser</code>类型的定义。</p>
<ol>
<li>item<pre><code> &gt; parse item &quot;&quot;
 []
 &gt; parse item &quot;abc&quot;
 [(&#39;a&#39;, &quot;bc&quot;)]
</code></pre>
</li>
<li>failure<pre><code> &gt; parse failure &quot;abc&quot;
 []
</code></pre>
</li>
<li>return<pre><code> &gt; parse (return 1) &quot;abc&quot;
 [(1, &quot;abc&quot;)]
</code></pre>
</li>
<li>+++<pre><code> &gt; parse (item +++ return &#39;d&#39;) &quot;abc&quot;
 [(&#39;a&#39;, &quot;bc&quot;)]
 &gt; parse (failure +++ return &#39;d&#39;) &quot;abc&quot;
 [(&#39;d&#39;, &quot;abc&quot;)]
</code></pre>
</li>
</ol>
<h2 id="Sequencing"><a href="#Sequencing" class="headerlink" title="Sequencing"></a>Sequencing</h2><p>到目前为止，我们都是使用<strong>递归</strong>来描述一系列的操作的，借助list comprehension或者高阶函数也可以实现循环操作，借助if、guard或者case实现选择语句。<br>但是顺序操作，这个命令式语言最常见的操作却一直没有办法实现，事实上由于Haskell的lazy特性，其更倾向于是并举的。而Monad正是解决这个问题的</p>
<h3 id="do"><a href="#do" class="headerlink" title="do"></a>do</h3><p>可以用<code>do</code>来表示顺序操作，<code>do</code>能够作用在任意的monadic类型上</p>
<pre><code>p :: Parser (Char, Char)
p = do x &lt;- item
       item
       y &lt;- item
       return (x, y)                
</code></pre>
<p><strong>注意：这段代码需要通过附带的代码Parsing.hs运行，因为Parser类型实际上要实现Monad类型类，才能够使用<code>&gt;&gt;=</code>、<code>&lt;-</code>等运算符</strong><br>如果仅仅使用<code>type</code>来定义</p>
<pre><code>type Parser a = String -&gt; [(a, String)]
</code></pre>
<p>简单地推导下可以发现</p>
<pre><code>:: Parser (Char, Char)
:: [((Char, Char), String)]
</code></pre>
<p>但是在错误信息中发现编译器实际上推导出的<code>(x, y)</code>是</p>
<pre><code>:: [(([(Char, String)], [(Char, String)]), String)]
</code></pre>
<p>同样，在Parsing.hs运行下面的代码可能会报错，因为使用了<code>newtype</code>定义的类型和<code>[(a, String)]</code>是两个完全不一样的类型了，所以要在前面加一个<code>P</code>。可以参考Parsing.hs里面的<code>item</code>和<code>parse</code>函数。</p>
<p>在下面两节将要介绍<code>&gt;&gt;=</code>运算符，这个运算符和<code>do</code>同样可以描述序列化的操作，而序列化是Monad的一种用途。</p>
<h3 id="Select和SelectMany"><a href="#Select和SelectMany" class="headerlink" title="Select和SelectMany"></a>Select和SelectMany</h3><p>在了解<code>&gt;&gt;=</code>前，教授提到了C#中的<code>Select</code>方法和<code>SelectMany</code>方法，其中Monad类似于<code>SelectMany</code>方法，因为Monad可以控制如何返回结果。</p>
<p><a href="/asset/haskell/select_many.txt"></a></p>
<p>可以看到，<code>SelectMany</code>能够将结果“拍平”成一维数组。并且可以多接受一个函数，表示如何返回结果。</p>
<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;="></a>&gt;&gt;=</h3><p>这个操作称为bind，是Monad中最重要的一个运算符，在C#中称为SelectMany，先查看它的定义</p>
<pre><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>【注】实际上在Haskell源码（在安装目录下的doc文件夹）中，该运算符是以如下形式出现的<code>(&gt;&gt;=) :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b</code>。<code>forall</code>关键字来自<a href="https://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types" target="_blank" rel="noopener">Existentially quantified types</a>这个扩展，并且作为默认的选项，这里可以直接忽略。<br>因为<code>Parser</code>是一个<code>Monad</code>，为了直观一点，所以对应到<code>Parser</code>类型</p>
<pre><code>(&gt;&gt;=) :: Parser a -&gt; (a -&gt; Parser b) -&gt; Parser b
</code></pre>
<p>这个运算接受一个参数<code>Parser a</code>，将它给一个函数<code>(a -&gt; Parser b)</code>，随后得到结果<code>Parser b</code>。<br>于是我们产生了几个问题：</p>
<ol>
<li>这看起来就是提供了一个策略，能通过<code>a -&gt; Parser b</code>实现函数<code>m a -&gt; m b</code>能实现的功能，感觉没什么了不起的，为什么不能直接定义一个<code>m a -&gt; m b</code>的函数呢？<br> 首先在<code>m a -&gt; m b</code>的函数里面，Haskell无法从<code>m a</code>类型把<code>a</code>提取出来，这样就不能完成需要直接操作<code>a</code>的运算了。<br> 如果我们把<code>m a</code>想成有副作用的<code>a</code>，那能不能把<code>m a</code>当成<code>a</code>来操作，这样定义了<code>a -&gt; b</code>相当于也定义了<code>m a -&gt; m b</code>呢？答案是也不能的，因为还有一个具有另外含义的Monad，如list, Maybe</li>
<li>这个操作有点类似于前面见到过的复合运算<code>(.)</code>，或者<code>($)</code>，他们之间有什么关系呢？<br> 事实上<code>($)</code>、<code>(&lt;$&gt;)</code>(fmap)、<code>(&lt;*&gt;)</code>(apply)、<code>(&gt;&gt;=)</code>(bind)四个运算符有着相似的性质，在下面的。</li>
<li>为什么要专门拿出来这个操作大书特书呢？<br> 其实这和Haskell需要实现的纯洁性有关。在看完<code>&lt;-</code>的介绍和下章的内容后会有更深的体会。</li>
</ol>
<h3 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h3><p>根据Wikipedia，Monad具有两个操作，第一个是之前看到的**<code>return</code><strong>，另一个是上面的</strong><code>bind</code>**</p>
<ol>
<li>return<br> return操作又称为unit，从一个普通类型<code>a</code>构造一个具有类型<code>M a</code>的monadic value</li>
<li>bind<br> 这个操作接受一个<code>M a</code>的monadic value，将<code>a</code>从<code>M a</code>类型的变量里面拆出，并传给函数<code>(a -&gt; M b)</code>来，输出具有类型<code>M b</code>的另一个值。有点类似linux里面的管道命令。</li>
</ol>
<p>此外，之前看到的<code>failure</code>其实都可以作为Monad的一部分，除此之外还有第四个运算符<code>&gt;&gt;</code>。这个运算符实际上是<code>&gt;&gt;=</code>的一个简化版本</p>
<pre><code>(&gt;&gt;) :: m a -&gt; m b -&gt; m b
</code></pre>
<p>这个操作的意义实际上也是合成两个操作，起到语法糖的功能，例如<code>a &gt;&gt; b</code>实际上等价于<code>a &gt;&gt;= \ _ -&gt; b</code>，也就是对于任意的<code>a</code>返回常量<code>b</code>。<br>其实<code>do</code>操作也可以看做<code>&gt;&gt;</code>的语法糖</p>
<pre><code>do action1
   action2
   action3
</code></pre>
<p>可以写成</p>
<pre><code>action1 &gt;&gt;
action2 &gt;&gt;
action3
</code></pre>
<p>不过由于没有<code>&gt;&gt;=</code>，<code>do</code>中必须通过下面的<code>&lt;-</code>来从Monad中“提取”值</p>
<h3 id="List-Monad和-lt"><a href="#List-Monad和-lt" class="headerlink" title="List Monad和&lt;-"></a>List Monad和&lt;-</h3><p>在list comprehension中出现了<code>&lt;-</code>这个运算符，例如在下面的例子中，<code>&lt;-</code>从<code>[a]</code>中“提取(feed)”了<code>a</code>：</p>
<pre><code>[x | x &lt;- xs]
</code></pre>
<p>但是对于<code>do</code>中的<code>x &lt;- item</code>，<code>item</code>是语法分析器，类型<code>Parser Char</code>，而通过<code>&lt;-</code>得到<code>Char</code>类型，这是为什么？其实这和Monad中的<code>&gt;&gt;=</code>是一个道理。<br>在<code>do</code>语句中，<code>&lt;-</code>运算符称为single assignment operator，或binding operator。这个被用作在monadic computation中提取一个值。准确一点说，<code>&lt;-</code>将Monad内的一个计算结果和一个名字绑定，或者可以说<code>&lt;-</code><strong>类似</strong>于赋值的等号。<br>例如这里的<code>item</code>是一个<code>Parser a</code>，在提取后得到一个<code>a</code>。这有点类似于C#中的装箱拆箱操作，如果把<code>return</code>当做一个“装箱”，那么<code>&lt;-</code>就可以看做一个“拆箱”。但是必须记住的是，<code>Parser</code>或者后面提到的<code>IO</code>这样的Monad，拆箱操作必须只能通过<code>&gt;&gt;=</code>或等价的<code>do</code>语句执行，这样保证了Haskell语言本身的无副作用性。<br>在<code>&gt;&gt;=</code>里面不需要<code>&lt;-</code>，因为“拆箱”操作由被<strong>隐式</strong>地实现。观察<code>&gt;&gt;=</code>的第二个参数<code>a -&gt; Parser b</code>，这个<code>a</code>从第一个参数<code>m a</code>中被<strong>隐式</strong>地提取出来了。而对于<code>do</code>中，我们必须要用<code>&lt;-</code>来显式地提出。</p>
<p>作为补充，提及一下list monad。从上面的讨论中我们可以发现list comprehension和monad中的<code>do</code>语句有着异曲同工之妙。事实上list也是一个monad，我们可以用<code>do</code>来实现list comprehension。</p>
<pre><code>[(i,j) | i &lt;- [1,2], j &lt;- [1..4] ]
</code></pre>
<p>对于上面的list comprehension，我们可以使用<code>do</code>来改写</p>
<pre><code>do i &lt;- [1,2]
   j &lt;- [1..4]
   return (i,j)
</code></pre>
<h3 id="Maybe-Monad"><a href="#Maybe-Monad" class="headerlink" title="Maybe Monad"></a>Maybe Monad</h3><p>之前提及的<code>Maybe</code>也是一个Monad，我们可以给出如下的定义</p>
<pre><code>return :: a -&gt; Maybe a
return x  = Just x

(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
(&gt;&gt;=) m g = case m of
               Nothing -&gt; Nothing
               Just x  -&gt; g x
</code></pre>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>再一次说明，可以看出，这四行首先调用<code>item</code>获得一个<code>x</code>，然后再次调用<code>item</code>，获取并discard掉一个结果，然后再次调用<code>item</code>，获得一个<code>y</code>。最后返回一个tuple<code>(x, y)</code><br>这类似于Linq中的from-select notation</p>
<pre><code>from x in item
from dummy in item
from y in item
select new {x, y}
</code></pre>
<p>最后关于Monad，推荐<a href="http://zhuoqiang.me/what-is-monad.html" target="_blank" rel="noopener">一篇文章</a></p>
<h2 id="Monad与Continuation"><a href="#Monad与Continuation" class="headerlink" title="Monad与Continuation"></a>Monad与Continuation</h2><p>从这里开始是我的一些补充。<br>Monad和CPS有一些类似之处，事实上<a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/the-essence-of-functional-programming.pdf" target="_blank" rel="noopener">这篇文章</a>中提及了两者之间的关系。</p>
<h3 id="Continuation简介"><a href="#Continuation简介" class="headerlink" title="Continuation简介"></a>Continuation简介</h3><p><a href="/2017/07/24/%E7%A5%9E%E5%99%A8Continuation/">单独列了一篇文章</a></p>
<h3 id="Continuation-Monad"><a href="#Continuation-Monad" class="headerlink" title="Continuation Monad"></a>Continuation Monad</h3><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>在上章的<code>fmap</code>部分我们了解了函子(Functor)。<br><code>Functor</code>是一个type class，实际上<code>Functor</code>和<code>fmap</code>是紧密联系的，一个能被mapped over(即能够<code>fmap</code>)的类型即是Functor，我们定义一个<code>Functor</code> <code>f</code></p>
<pre><code>class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
    (&lt;$) :: a -&gt; f b -&gt; f a
    (&lt;$) =  fmap . const
</code></pre>
<p>其中<code>fmap</code>有对应的操作符</p>
<pre><code>(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>这里<code>f a</code>称为**上下文中的值(in context value)**，因为<code>a</code>被<code>f</code>包装了起来。从定义中可以看出，<code>fmap</code>把Functor <code>f a</code>从上下文中的东西拿出来，然后交给一个函数<code>(a -&gt; b)</code>，函数处理完又封装进context<code>f b</code>中。<br>此外，由于我们的函数是柯里函数，并且<code>-&gt;</code>是右结合的，所以<code>fmap</code>还可以理解为</p>
<pre><code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)
</code></pre>
<p>即接受一个<code>(a -&gt; b)</code>类型的函数，并返回一个函数<code>f a -&gt; f b</code>，这个函数接受一个<code>Functor</code> <code>f a</code>并返回一个<code>Functor</code> <code>f b</code>，例如</p>
<pre><code>fmap (*2) :: (Num a, Functor f) =&gt; f a -&gt; f a  
</code></pre>
<h3 id="Maybe-Functor"><a href="#Maybe-Functor" class="headerlink" title="Maybe Functor"></a>Maybe Functor</h3><p>之前看到的<code>Maybe</code>也是一个Functor</p>
<pre><code>instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing  
    
</code></pre>
<h3 id="Function-Functor-gt"><a href="#Function-Functor-gt" class="headerlink" title="Function Functor -&gt;"></a>Function Functor <code>-&gt;</code></h3><p>Function，也是一个Functor。Arrow运算符<code>-&gt;</code>，对，就是用来定义函数的。<code>r -&gt; a</code>可以写成<code>(-&gt;) r a</code>。由于type constructor<strong>能且只能接受一个参数</strong>，所以<code>(-&gt;)</code>不是Functor，但是<code>(-&gt;) r</code>即<code>(r -&gt;)</code>是Functor。<br>既然函数<code>-&gt;</code>是Functor，那就得定义它对应的<code>fmap</code>啊，于是</p>
<pre><code>instance Functor ((-&gt;) r) where  
    fmap f g = (\x -&gt; f (g x))
</code></pre>
<p><code>f (g x)</code>看起来很眼熟，不禁联想到前面的</p>
<pre><code>(f . g) x
:: f (g x)
</code></pre>
<p>我们是不是可以直接给出如下定义？</p>
<pre><code>instance Functor ((-&gt;) r) where  
    fmap = (.)
</code></pre>
<p>于是我们再直接代入一下看看</p>
<pre><code>f    :: (-&gt;) r
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
     :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)
     :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; a)
(.)  :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)
</code></pre>
<p>可以发现这个<code>((-&gt;) r)</code>其实等价于composition<code>(.)</code>。</p>
<h3 id="fmap的性质"><a href="#fmap的性质" class="headerlink" title="fmap的性质"></a>fmap的性质</h3><p><code>fmap</code>具有下面的性质</p>
<pre><code>fmap id = id
fmap (p . q) = (fmap p) . (fmap q)
</code></pre>
<p>第一条看起来很简单，第二条讲的是<code>fmap</code>对<code>.</code>有分配律。<br>对于第二条，我们假设另一个<code>Functor</code> <code>X</code></p>
<pre><code>fmap (f . g) X = (fmap f) . (fmap g) X
</code></pre>
<p>不妨令<code>f :: b -&gt; c</code>，<code>g :: a -&gt; b</code><br>首先看左边</p>
<pre><code>fmap (f . g) X
::  fmap (a -&gt; c) X a -&gt; X c
::  X a -&gt; X c
</code></pre>
<p>再看右边</p>
<pre><code>(fmap f) :: f -&gt; X b -&gt; X c
(fmap g) :: f -&gt; X a -&gt; X b
(fmap f) . (fmap g) X
::  (X b -&gt; X c) . (X a -&gt; X b)
::  X a -&gt; X c
</code></pre>
<p>因此等式成立。在推导的时候需要注意，里面的<code>fmap</code>和<code>.</code>都是函数应用而不是函数定义，带入定义式是不对的。</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Applicative定义如下，这里省略了<code>(*&gt;)</code>和<code>(&lt;*)</code>的默认实现</p>
<pre><code>class Functor f =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
    (*&gt;) :: f a -&gt; f b -&gt; f b
    (&lt;*) :: f a -&gt; f b -&gt; f a
</code></pre>
<p>先看一看这个东西怎么用吧</p>
<pre><code>&gt; [(2*),(5*),(9*)] &lt;*&gt; [1,4,7]
[2,8,14,5,20,35,9,36,63]
</code></pre>
<p>在这个例子里面Applicative(<code>(&lt;*&gt;)</code>)像计算笛卡尔积一样，将一列表的函数应用到另一个列表的整数上，然后列表的长度改变了。<br>首先<code>class Functor f =&gt; Applicative f where</code>，我们知道这里出现在<code>=&gt;</code>前的<code>Functor f</code>是type constraint，所以一个Applicative也是是Functor。这意味着Applicative类型（List、Maybe等）不仅可以当成Functor来用，还具有Functor没有的一些用法。</p>
<pre><code>&gt; (+3) &lt;$&gt; (Just 5)
Just 8
&gt; Just (+3) &lt;*&gt; (Just 5)
Just 8
&gt; Just (+3) &lt;$&gt; (Just 5)
</code></pre>
<p><code>pure</code>可以参照理解成Monad里面的<code>return</code>，相当于我们把一个<code>a</code>打包放到了一个Applicative Functor<code>f a</code>里面。<br><code>&lt;*&gt;</code>的定义就有意思了。<br>首先查看第一个参数<code>f (a -&gt; b)</code>，这是把一个函数作为type parameter给<code>f</code>。从前我们的Functor里面包含的是值，不过这次里面包含着Function，例如本节开头的例子中，<code>f</code>是List，<code>f (a -&gt; b)</code>便是一个List的<code>Num a =&gt; a -&gt; a</code>函数，所以<code>f (a -&gt; b)</code>在这里被称作上下文中的函数(in context function)。如果把这个函数从上下文中拿出来一看，原来就和<code>fmap</code>的第一个函数一样了。<br>第二个参数是一个Functor <code>f a</code>。然后<code>(&lt;*&gt;)</code>做的事情是把Function从Function Functor中“提取”出来，<code>fmap</code>到第二个Functor<code>f a</code>上，这个<code>fmap</code>就和Functor一致了。<br>为了观察具体流程，下面的代码对比实现了<code>Maybe</code>的Functor和Applicative</p>
<pre><code>instance Applicative Maybe where  
    pure = Just  
    Nothing &lt;*&gt; _ = Nothing  
    (Just f) &lt;*&gt; something = fmap f something  
    
instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing 
</code></pre>
<p>首先我们看到<code>(Just f)</code>似乎通过pattern match提取出了<code>f</code>，而<code>Nothing</code>里面并没有任何的函数可以被提取，如果我们第一个参数的类型不是<code>f (a -&gt; b)</code>而直接是<code>a -&gt; b</code>，那我们就不能传入<code>Nothing</code>这样的参数了。可以发现，Applicative的特点是**<code>&lt;*&gt;</code>运算符的两边都可以使Applicative**，而Functor的特点是<code>fmap</code>/<code>&lt;$&gt;</code>只有第二个参数能够是Functor。</p>
<p>Applicative还有一个性质是Sequencing，也就是我们在本章看到的Monad所具有的性质。它的表现是Applicative Style，也就是对于一个<strong>多元</strong>的普通函数，也可以通过<code>&lt;*&gt;</code>来应用到多个带上下文的参数中。</p>
<pre><code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...
fmap f x &lt;*&gt; y &lt;*&gt; ...
f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; ...
</code></pre>
<p>注意到<code>pure f</code>、<code>fmap f x</code>、<code>f &lt;$&gt; x</code>是等价的。例如</p>
<pre><code>&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5  
[8.0,10.0,2.5]  
</code></pre>
<p>在本节开头，我们接触了List Applicative，<code>[(2*),(5*),(9*)] &lt;*&gt; [1,4,7] = [2,8,14,5,20,35,9,36,63]</code>，下面我们看看具体的定义</p>
<pre><code>instance Applicative [] where  
pure x = [x]  
fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]
</code></pre>
<p>查看Applicative的<a href="https://downloads.haskell.org/~ghc/7.0.4/docs/html/libraries/base-4.3.1.0/Control-Applicative.html#t:Applicative" target="_blank" rel="noopener">介绍</a>，还可以发现<code>((-&gt;) a)</code>这个东西也是Applicative的，这个奇怪的东西，我们在Functor中看到过。<br>如下所示，pure的签名实际上是<code>pure :: a -&gt; (r -&gt; a)</code>，</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) a) <span class="keyword">where</span></span></span><br><span class="line">    pure x = (\_ -&gt; x)</span><br><span class="line">    (&lt;*&gt;) f g x = f x (g x)</span><br></pre></td></tr></table></figure>

<p><code>&lt;*&gt;</code>类似于SKI组合子中的S，pure类似于SKI组合子中的I。</p>
<h2 id="Monoid"><a href="#Monoid" class="headerlink" title="Monoid"></a>Monoid</h2><p>幺半群(Monoid)即带有单位元的半群，因此幺半群满足封闭性、结合律、单位元</p>
<pre><code>import Data.Monoid
class Monoid m where  
    mempty :: m  
    mappend :: m -&gt; m -&gt; m  
    mconcat :: [m] -&gt; m  
    mconcat = foldr mappend mempty  
</code></pre>
<h2 id="Monad和Functor以及Applicative"><a href="#Monad和Functor以及Applicative" class="headerlink" title="Monad和Functor以及Applicative"></a>Monad和Functor以及Applicative</h2><p>Monad是一个Applicative，而Applicative是Functor，所以所有的Monad都是Functor(因为Applicative都是Functor)。<br><a href="https://zh.wikibooks.org/zh-hans/Haskell/Applicative%E7%B1%BB%E5%9E%8B%E7%B1%BB" target="_blank" rel="noopener">这三者有着类似的定义，和各自的独特之处</a></p>
<pre><code>class Applicative m =&gt; Monad m where
  (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b
  (&gt;&gt;)   :: m a -&gt; m b -&gt; m b
  return :: a -&gt; m a
  fail   :: String -&gt; m a
</code></pre>
<p>如果把<code>(&gt;&gt;=)</code>的参数掉个个成<code>=&lt;&lt;</code></p>
<pre><code>(=&lt;&lt;) :: Monad m        =&gt; (a -&gt; m b) -&gt; (m a -&gt; m b)
(&lt;*&gt;) :: Applicative m  =&gt; m (a -&gt; b) -&gt; (m a -&gt; m b)
(&lt;$&gt;) :: Functor m      =&gt;   (a -&gt; b) -&gt; (m a -&gt; m b)
</code></pre>
<p>可以发现<code>fmap</code>的返回值都是<code>(m a -&gt; m b)</code>，三者差距在于“定义域”的不同。其中Functor能够接受任意函数，但是<code>(&lt;*&gt;)</code>能接受<code>m (a -&gt; b)</code>（其实这都不一定是个函数），而<code>(&gt;&gt;=)</code>只能接受<code>(a -&gt; m b)</code>。<br>从<code>fmap</code>到<code>(&lt;*&gt;)</code>再到<code>(&gt;&gt;=)</code>, 我们对于值的控制力和计算的灵活性逐渐增加, 但这是以结果性质的弱化为代价的。<br>这里的控制力和灵活性取决于是我们<strong>传入的函数</strong>对<code>m</code>的信息有多少。即使这三个操作符会再接受一个<code>m a</code>值的参数，但<code>m a</code>这个值对其实际的操作者，即<strong>传入的函数</strong>来说是一个黑箱。</p>
<ol>
<li>对于<code>fmap</code>来说，我们传入的<code>(a -&gt; b)</code>一点都接触不到<code>m</code>这个东西，<code>m</code>是List，抑或是Maybe，我们的函数根本不需要去考虑，<code>m a</code>的拆箱和结果的装箱，<code>Functor m</code>已经包办了，你自己是一点主都做不了的。</li>
<li>但是对<code>(&lt;*&gt;)</code>来说，我们的函数和值<code>f a</code>一样都是in context的，因此在函数里面我们是知道“容器类型”<code>m</code>是个啥的。例如我们可以知道<code>(&lt;*&gt;)</code>包装的是列表还是Maybe</li>
<li><code>(&gt;&gt;=)</code>比Applicative更进一步的是，它可以自行制定如何将结果包装成<code>m b</code>类型，而这在Applicative都是由具体的instance来规定的。</li>
</ol>
<h2 id="Derived-Primitive"><a href="#Derived-Primitive" class="headerlink" title="Derived Primitive"></a>Derived Primitive</h2><ol>
<li><p>一个判断一个Char是否满足给定谓词(Predicate)的语法分析器</p>
<pre><code> sat :: (Char -&gt; Bool) -&gt; Parser Char
 sat p = do x &lt;- item
            if p x then return x else failure
</code></pre>
</li>
<li><p>使用sat</p>
<pre><code> digit :: Parser Char
 digit = sat isDigit
 
 many :: Parser a -&gt; Parser [a]
 many p = many1 p +++ return []
 many1 :: Parser a -&gt; Parser [a]
 many1 p = do
             v &lt;- p
             vs &lt;- many p
             return (v:vs)
             
</code></pre>
<p> 还有若干代码，这里先告一段落</p>
</li>
</ol>
<h2 id="Monad的性质"><a href="#Monad的性质" class="headerlink" title="Monad的性质"></a>Monad的性质</h2><blockquote>
<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor.</p>
</blockquote>
<p>幺半群(Monoid)在前面已有介绍<br>自函子(Endofunctor)即一个将范畴映射到自身的函子(Functor)</p>
<h3 id="do-1"><a href="#do-1" class="headerlink" title="do"></a>do</h3><ol>
<li><code>do {e}</code> -&gt; <code>e</code><br> 一个操作用<code>do</code>包裹起来等于它自己</li>
<li><code>do {e; es}</code> -&gt; <code>e &gt;&gt; do{es}</code><br> 这就是前面的<code>&gt;&gt;</code>的语法糖</li>
<li><code>do {let decls; es}</code> -&gt; <code>let decls in do {es}</code><br> 这里面用到了<code>let</code>和<code>let...in</code>两个不同的结构块。</li>
</ol>
<h3 id="gt-gt-1"><a href="#gt-gt-1" class="headerlink" title="&gt;&gt;="></a>&gt;&gt;=</h3><ol>
<li><code>return a &gt;&gt;= f</code> = <code>f a</code><br> 这个性质相当于是将一个普通值<code>a</code>穿上Monad的衣服，传给一个函数<code>f</code>，相当于直接调用这个函数<code>f a</code></li>
<li><code>m &gt;&gt;= return</code> = <code>m</code><br> 这个性质是因为对于一个Monad <code>m</code>，<code>m &gt;&gt;= return</code>动作相当于先通过<code>&gt;&gt;=</code>把衣服脱掉，然后在通过<code>return</code>重新穿上Monad的衣服</li>
<li><code>f &gt;&gt;= (\x -&gt; g x &gt;&gt;= h) ≡ (f &gt;&gt;= g) &gt;&gt;= h</code></li>
</ol>
<h2 id="Monad相关函数操作"><a href="#Monad相关函数操作" class="headerlink" title="Monad相关函数操作"></a>Monad相关函数操作</h2><h3 id="Lifting"><a href="#Lifting" class="headerlink" title="Lifting"></a>Lifting</h3><p><code>fmap</code>是一个lifting操作，lifting操作一般作用于一个函数，并把它变为另一个相关的函数。</p>
<h1 id="Ch9-Interactive-Programs"><a href="#Ch9-Interactive-Programs" class="headerlink" title="Ch9 Interactive Programs"></a>Ch9 Interactive Programs</h1><p>上一章讲了什么是Monad，并了解了一些常见的Monad。通过将Functor和Applicative和Monad比较，能看出Monad使用在纯函数计算上的方便之处。<br>这章进一步讨论了IO Monad，并以此体会Monad是如何帮助<code>IO</code>来封装副作用的。</p>
<p>本章节还介绍了Hangman游戏的实现，在此略过。</p>
<h2 id="交互式操作"><a href="#交互式操作" class="headerlink" title="交互式操作"></a>交互式操作</h2><p><code>IO</code>和上一章见到的<code>Parser</code>一样，都是一个Monad typeclass的实现，它“封印”了IO操作中和副作用相关的部分。<br>我们将只在开始接受所有输入、只在最后返回所有输出的程序称为批处理程序batch program，如果这个程序能够在运行时从键盘等设备获取输入，并将结果写到屏幕上，这样的程序称为交互式程序interactive program。</p>
<p>交互式程序有副作用，并且是顺序操作。因此难点在于Haskell作为纯函数式语言是没有副作用，类似于数学函数和批处理程序。当然，无副作用的好处也是显而易见，我们在pure函数中，我们不需要关注外界的异常，只需要处理返回值即可，减轻了负担。</p>
<p>从代码角度来看，整个IO过程<strong>“投射”</strong>在Haskell代码的部分是纯函数式，无副作用的，而将副作用投射到另一个“里世界”中，Monad成为了这两个世界之间沟通的桥梁。</p>
<p>为了能够描述这样的IO，Haskell借助了Monad。很容易发现Monad带有的Sequencing特性非常适合。</p>
<p>考虑最简单的一个情况，一个纯交互式程序是没有返回值的，对于“没有返回值”，可以将其定义为<code>IO ()</code>，<code>()</code>在先前提到过，称为unit，是一个空的tuple，类似于C++中的<code>void</code>。这样你就可以在不破坏无副作用的情况下到另一个次元做坏事了。下面我们看看具体的一些函数。</p>
<h2 id="常用IO函数"><a href="#常用IO函数" class="headerlink" title="常用IO函数"></a>常用IO函数</h2><h3 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h3><p><code>getChar :: IO Char</code>，从键盘读取一个字符，显示到屏幕上，并作为返回值。</p>
<p>它可能类似C++中的<code>int ::getchar(void)</code>函数，但在Haskell中它的定义并不是一个函数，例如可以写成<code>getChar :: () -&gt; IO Char</code>。教授讲解由于Haskell是lazy的，所以上述的函数形式虽然显得更熟悉一些，但是并没有必要写成这样。</p>
<p>在Scala中，函数就是对象，但在Haskell中，我们可以感受到“对象”就是函数，在下面的章节中，会看到邱奇编码的概念，展示了如何用函数(lambda演算)来表达数组、元组、整数等常见的数据结构。</p>
<p><code>putChar :: Char -&gt; IO ()</code>将一个Char打印在屏幕上，不返回值。<br><code>return :: a -&gt; IO a</code>，接受一个<code>a</code>类型，并返回一个<code>IO a</code>类型。</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h3 id="套接口操作"><a href="#套接口操作" class="headerlink" title="套接口操作"></a>套接口操作</h3><h2 id="IO-Sequencing"><a href="#IO-Sequencing" class="headerlink" title="IO Sequencing"></a>IO Sequencing</h2><p>前面提到<code>do</code>语句可以合并多个IO操作为一个IO操作。考虑下面的一个<code>do</code>语句</p>
<pre><code>a :: IO (Char, Char)
a = do
      x &lt;- getChar
      getChar
      y &lt;- getChar
      return (x, y)
</code></pre>
<p>根据上面的分析，其中<code>x</code>和<code>y</code>是<code>Char</code>类型，<code>return</code>将<code>(x, y)</code>的tuple转变为一个<code>IO tuple</code>类型。这样的<code>do</code>也可以通过<code>&gt;&gt;=</code>来写（在上一章已经了解了怎么用<code>&gt;&gt;</code>来改写<code>do</code>）</p>
<pre><code>getChar &gt;&gt;= \x -&gt;
  getChar &gt;&gt;= \_ -&gt;
    getChar &gt;&gt;= \y -&gt; 
      return (x, y)
          
</code></pre>
<h2 id="Derived-Primitives"><a href="#Derived-Primitives" class="headerlink" title="Derived Primitives"></a>Derived Primitives</h2><p>本章节中顺着演讲者的思路，去定义一些自己的IO函数。<br>可以从<code>getChar</code>定义<code>getLine</code></p>
<pre><code>getLine = do
            x &lt;- getChar
            if x == &#39;\n&#39; then
              return []
            else
              do 
                xs &lt;- getLine
                return (x:xs)
</code></pre>
<p>Haskell中，字符串就是Char的list，下面是和字符串有关的函数</p>
<pre><code>putStr&#39; :: String -&gt; IO ()
putStr&#39; [] = return ()
putStr&#39; (x:xs) = do
                  putChar x
                  putStr&#39; xs

putStrLn :: String -&gt; IO ()
putStrLn xs = do
        putStr xs
        putChar &#39;\n&#39;
        
</code></pre>
<p>同时我们可以使用<code>foldr</code>来定义<code>putStr</code>函数，这里同样用<code>&gt;&gt;=</code>来代替<code>do</code>表示顺序操作</p>
<pre><code>putStr2 :: String -&gt; IO ()
putStr2 = foldr (++++) (return ())
            where
              x ++++ p = putChar x &gt;&gt;= \_ -&gt; p
              
</code></pre>
<p>下面是一个求字符串长度的函数</p>
<pre><code>strlen :: IO ()
strlen = do
          putStr &quot;Enter a string:&quot;
          xs &lt;- getLine
          putStr &quot;Length is&quot;
          putStr $ show $ length xs
          
</code></pre>
<p>可以再次体会到，Haskell程序解决副作用的方法是将副作用放在执行<code>IO ()</code>时了，但是这个语句对于Haskell本身而言，是pure functional的。<br>注意<code>IO</code>对象是不能够被print的</p>
<pre><code>a = do 
  x &lt;- getChar 
  return x
main = print a
</code></pre>
<p>这个代码中<code>a</code>通过<code>return</code>返回了一个<code>IO</code>，因此是有副作用的，如果print能够处理，那副作用就“蔓延到”无副作用的代码里面了。所以可以认为<code>IO</code>这样的Monad是有传染性的。如果要实现这样的操作应该借助于<code>&lt;-</code>运算符</p>
<pre><code>f = do 
  x &lt;- getChar 
  return x

main = do 
        x &lt;- f
        print x
</code></pre>
<p>或者<code>&gt;&gt;=</code>运算符</p>
<pre><code>f = do 
  x &lt;- getChar 
  return x

main = f &gt;&gt;= print
</code></pre>
<h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>IO 操作会产生异常显而易见，因为外界的环境无法预知。pure函数可能产生异常，但只有它涉及IO操作时，异常才会被捕获。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ghci&gt; <span class="number">4</span> `<span class="keyword">div</span>` <span class="number">0</span>  </span><br><span class="line">*** Exception: <span class="built_in">divide</span> <span class="keyword">by</span> <span class="literal">zero</span>  </span><br><span class="line">ghci&gt; head []  </span><br><span class="line">*** Exception: Prelude.head: <span class="literal">empty</span> list</span><br></pre></td></tr></table></figure>

<h1 id="Ch10-Declaring-Types-and-Classes"><a href="#Ch10-Declaring-Types-and-Classes" class="headerlink" title="Ch10 Declaring Types and Classes"></a>Ch10 Declaring Types and Classes</h1><p>观察Monad <code>m a</code>中的<code>m</code>，在这里被用作type constructor，所以<code>m</code>可以是<code>Parer</code>可以是<code>IO</code>，这种higher kinded polymorphic并不是使用type parameter，而是使用一个从type到type的函数(type function)来实现。这种Higher Kinded Types实现的方式是Haskell的一个特别的性质。在Haskell中，我们可以定义具有<code>&gt;&gt;=</code>bind运算，就可以被称作Monad，但是在C#等语言中，没有这样的概念(notion)，有这样的模式(pattern)。</p>
<h2 id="有关type-function"><a href="#有关type-function" class="headerlink" title="有关type function"></a>有关type function</h2><p>我们知道普通的函数，例如<code>a -&gt; b</code>表示从类型<code>a</code><strong>的值</strong>到类型<code>b</code><strong>的值</strong>的一个映射。而type function中，把类型本身当做了“操作数”，即<code>a -&gt; b</code>是类型<code>a</code>到类型<code>b</code>的映射，我们甚至可以把<code>a -&gt; b</code>看做<code>(-&gt;) a b</code>。这两者的概念有点类似type constructor和data constructor的区别。<br>类似于对于普通函数的type(<code>:t</code>)我们可以使用kind(<code>:t</code>)来描述type function。容易理解type的kind是<code>*</code>，而Functor/Monad这些类型类的的kind就是<code>* -&gt; *</code>。有趣的是<code>-&gt;</code>也有kind，即<code>* -&gt; * -&gt; *</code>。</p>
<h2 id="Type-Declarations"><a href="#Type-Declarations" class="headerlink" title="Type Declarations"></a>Type Declarations</h2><p><code>type</code>语句为一个<strong>已有类型</strong>提供别名，类似于C/C++中的<code>typedef</code>或<code>using</code>。</p>
<pre><code>type String = [Char]
</code></pre>
<p><code>type</code>语句可以拥有参数，所以我们可以把它看做类型上的一个函数，可以发现type level和value level上的函数形式上非常相似</p>
<pre><code>type Pair a = (a, a)
pair a = (a, a)
</code></pre>
<p>下面是一个mult函数的定义</p>
<pre><code>mult :: Pair Int -&gt; Int
mult (m, n) = m * n
</code></pre>
<p>很多其他的函数式语言完全模糊了这两者的界限，如Agda、Cayenne这两个类似Haskell的语言，和有关函数式编程本质有关的Coq语言等。还有一个替代的方案叫做lambda cube。介绍Phil Watler（音）的论文。</p>
<p>Type Declaration是可以嵌套的，下面的代码是正确的：</p>
<pre><code>type Pos = (Int, Int)
type Trans = Pos -&gt; Pos
</code></pre>
<p>但是递归是不可以的，显然这会得到一个无尽的定义</p>
<pre><code>type Tree = (Int, [Tree])
</code></pre>
<h2 id="Data-Declarations"><a href="#Data-Declarations" class="headerlink" title="Data Declarations"></a>Data Declarations</h2><p>使用<code>data</code>语句可以定义一个新的类型</p>
<pre><code>data Bool = False | True
</code></pre>
<p>这类似于C#中的抽象类（为什么不是enum哦），或者用来描述上下文无关文法的BNF。</p>
<pre><code>abstract class Bool {}
sealed class True : Bool {}
sealed class False : Bool {}
</code></pre>
<p>这表示我们定义了一个<code>Bool</code>类型，其中<code>True</code>和<code>False</code>是具有一个<code>Bool</code>类型的值的constructor。<code>True</code>和<code>False</code>还可以被称为subtype。在定义类型的时候，type constructor和value/data constructor的名字都应该以<strong>大写字母</strong>开头。<br>由于<code>True</code>不是类型，所以定义函数的时候不能写成</p>
<pre><code>f :: True -&gt; ...
</code></pre>
<p>而只能</p>
<pre><code>f :: Bool -&gt; ...
</code></pre>
<p>然后<code>True</code>等constructor可以用来做pattern matching，这称为deconstructing。这看起来像C++中的downcasting</p>
<pre><code>f True = ...
</code></pre>
<p>使用<code>data</code>定义的类型的值(values)和内置类型的值使用方式是类似的</p>
<pre><code>data Answer = Yes | No | Unknown
answers :: [Answer]
answers = [Yes, No, Unknown]
</code></pre>
<p>注意<code>answers</code>类似于上章遇到的<code>getChar</code>，可以看做一个接受0个参数的函数。<br>在定义type的时候constructor也可以拥有参数（所以上面会理解成抽象类）。如下面的代码所示，我们可以在<code>Shape</code>的定义外部对<code>Circle</code>和<code>Rect</code>进行“特化”。</p>
<pre><code>data Shape = Circle Float
            | Rect Float Float
square :: Float -&gt; Shape
square n = Rect n n
</code></pre>
<p>由于Haskell很难添加一个subtype到已有的type中，例如想要给<code>Shape</code>加上一个<code>Polygon</code>的<code>subtype</code>是不容易的，但是用上面这种“虚函数”的方式确实简单的。这和C#等OOP语言是截然相反的，OOP的语言往往继承是容易的（假设去掉sealed），但是给一个写好的类里面增改一个虚函数确实不容易的。这是一种难以两全其美的问题，有许多论文研究这点。<br>上面的代码中，<code>Circle</code>和<code>Rect</code>被看做类型<code>Shape</code>的<strong>“构造函数”</strong>(constructor functions)。<br>特别注意，<code>Circle</code>和<code>Rect</code>是constructor，但不是类型，他们构造出的是<code>Shape</code>类型。</p>
<pre><code>Circle :: Float -&gt; Shape
Rect :: Float -&gt; Float -&gt; Shape
</code></pre>
<p>constructor functions和普通函数的区别是前者不用<code>=</code>来定义(no defining equations)。</p>
<p>同样地，<code>data</code>语句也可以带参数，例如经典的Maybe：</p>
<pre><code>data Maybe a = Nothing | Just a
</code></pre>
<p>这里教授又讲授了一遍自己prefer list to Maybe的理由，然后其实Maybe和list都是Monad，其实看到这里我还是挺惊讶的。于是不妨推导一下为什么list是Monad：<br>首先介绍一个<code>concat</code>函数，其定义为</p>
<pre><code>concat :: Foldable t =&gt; t [a] -&gt; [a]
</code></pre>
<p>为了理解这个定义，可以把<code>Foldable t</code>看做它的一个特例，也就是<code>[]</code>，那么<code>concat</code>就是将一个二维数组拍平</p>
<pre><code>concat :: [[a]] -&gt; [a]
</code></pre>
<p>而list的<code>&gt;&gt;=</code>运算，即<code>list &gt;&gt;= f</code>可以理解为等价于<code>concat (map f list)</code></p>
<p>特别地，对于仅有一个constructor的、一个field的类型，可以使用<code>newtype</code>替代<code>data</code>关键字</p>
<h2 id="data-value-constructor和type-constructor"><a href="#data-value-constructor和type-constructor" class="headerlink" title="data/value constructor和type constructor"></a>data/value constructor和type constructor</h2><p>作为扩展，解释一下data/value constructor和type constructor之间的联系与区别。这其实在<a href="https://stackoverflow.com/questions/18204308/haskell-type-vs-data-constructor" target="_blank" rel="noopener">stackoverflow</a>上讲得很清楚。两者区别是：</p>
<ol>
<li>data/value constructor可以看做一个返回<strong>值</strong>的函数<br> 例如本章讲的<code>Circle</code>和<code>Rect</code>，它们都能够返回一个<code>Shape</code>类型的<strong>值</strong>。</li>
<li>type constructor可以看做一个返回<strong>类型</strong>的函数<br> 如<code>fmap</code>定义中的<code>f</code>，Monad<code>m a</code>中的<code>m</code>，实际上是产生了一个新的<strong>类型</strong>。这个有点类似于C++中的模板类，不过Haskell在这方面要更加深层次，我们将在最后的多态性专题进行讨论。</li>
</ol>
<p>两者联系<br>以<code>data Tree a = Tip | Node a (Tree a) (Tree a)</code>为例。</p>
<ol>
<li>等式左边的<code>Tree</code>称为type constructor。而<code>Tree a</code>是一个type。</li>
<li>等式右边具有两个data/value constuctor，<a href="https://wiki.haskell.org/Constructor#Type_constructor" target="_blank" rel="noopener">因此这个data type是多态的</a>。</li>
</ol>
<h3 id="instance、type和data语句的区别"><a href="#instance、type和data语句的区别" class="headerlink" title="instance、type和data语句的区别"></a>instance、type和data语句的区别</h3><p><code>instance</code>根据<code>class</code>定义的type class来产生一个<strong>type constructor</strong><br><code>type</code>用来<strong>从</strong>一个type constructor产生一个具体类型concrete type<br><code>data</code>用来<strong>为</strong>一个type constructor提供一系列data/value constructor得到value</p>
<h2 id="Recursive-types"><a href="#Recursive-types" class="headerlink" title="Recursive types"></a>Recursive types</h2><p>使用<code>data</code>语句定义的type可以是递归的。例如我们可以定义一个<a href="https://zh.wikipedia.org/wiki/%E9%82%B1%E5%A5%87%E6%95%B0" target="_blank" rel="noopener">自然数类型（邱奇数）</a></p>
<pre><code>data Nat = Zero | Succ Nat
</code></pre>
<p>这里的<code>Nat</code>是一个新类型，<code>Nat</code>有两个constructor，它们分别具有类型<code>Zero :: Nat</code>和<code>Succ :: Nat -&gt; Nat</code>，由Ch3中学习过的，这里的<code>::</code>表示“具有类型”。<br>于是我们实际可以得到这样的一个无尽序列</p>
<pre><code>Zero
Succ Zero
Succ (Succ Zero)
...
</code></pre>
<p>我们看看能不能输出它</p>
<pre><code>Prelude&gt; (Succ Zero)
&lt;interactive&gt;:15:1: error:
    ? No instance for (Show Nat) arising from a use of ‘print’
    ? In a stmt of an interactive GHCi command: print it
Prelude&gt; print $ (Succ Zero) 
</code></pre>
<p>可以先转换成<code>Int</code></p>
<pre><code>nat2int :: Nat -&gt; Int
nat2int Zero = 0
nat2int (Succ n) = 1 + nat2int n
</code></pre>
<p>然后输出</p>
<pre><code>print $ nat2int (Succ Zero)
</code></pre>
<p>下面实现自然数类型的加法，对于C++来说，这意味着定义<code>operator+</code></p>
<pre><code>add :: Nat -&gt; Nat -&gt; Nat
add m n = int2nat (nat2int m + nat2int n)
</code></pre>
<p>上面是一个很直截了当的做法，先转换成<code>Int</code>，加完后再转回<code>Nat</code>，有没有不需要借助<code>Int</code>的方法呢？</p>
<pre><code>add&#39; :: Nat -&gt; Nat -&gt; Nat
add&#39; m Zero = m
add&#39; m n = (iterate Succ m) !! nat2int n
</code></pre>
<p>首先想到的是<code>add m n</code>等于<code>n</code>次<code>Succ m</code>，不过这种方法还是需要转换，于是有下面的方法</p>
<pre><code>add Zero n = n
add (Succ m) n = Succ (add m n)
</code></pre>
<p>我们把<code>n</code>看做常数，将<code>add</code>转换为一元函数<code>g</code>，<code>Succ</code>类比做<code>+1</code>，这就有点类似数学归纳法的味道：</p>
<pre><code>g (x + 1) = (g x) + 1
</code></pre>
<h3 id="Church-encoding和Scott-encoding"><a href="#Church-encoding和Scott-encoding" class="headerlink" title="Church encoding和Scott encoding"></a>Church encoding和Scott encoding</h3><p>刚才我们看到了邱奇编码的一个常见形式，即邱奇数。邱奇数使用lambda构成的高阶函数来描述自然数。事实上邱奇编码可以用来描述一些很基本的结构，例如布尔值、元组、列表和tagged unions。<br>以邱奇数为例，可以将0表示为<code>\f x.x</code>，1为<code>\f x. f x</code>，2为<code>\f x. f(f x)</code>，因此n可以表示为<code>n F x = ($) f^n x</code>，可以看成一个递归的函数。<br>下面可以借助已有的邱奇数实现加法函数<code>plus(m, n) = m + n</code>，<code>plus = \m n f x. m f(n f x)</code>。这里用到了性质<code>f^(m+n) x = f^m f^n x</code>。</p>
<h2 id="Arithmetic-Expressions"><a href="#Arithmetic-Expressions" class="headerlink" title="Arithmetic Expressions"></a>Arithmetic Expressions</h2><p>下面我们来为代数运算的“AST”实现一套类型系统</p>
<pre><code>data Expr = Val Int | Add Expr Expr | Mul Expr Expr
</code></pre>
<p>注意我们将所有的代数运算定义到一个<code>Expr</code>类型里面，这是一个“比较Haskell”的写法。我们的代数式可以写成下面这样，从计算一个“函数”变成了构造一个<code>Expr</code>“对象”</p>
<pre><code>Add (Val 1) (Mul (Val 2) (Val 3))
</code></pre>
<p>我们使用<code>eval</code>来计算这个<code>Expr</code>，可以写成</p>
<pre><code>eval :: Expr -&gt; Int
eval (Val n) = n
eval (Add x y) = eval x + eval y
eval (Mul x y) = eval x * eval y
</code></pre>
<h2 id="Binary-Tree"><a href="#Binary-Tree" class="headerlink" title="Binary Tree"></a>Binary Tree</h2><p>二叉树由叶子(<code>Leaf</code>)和节点(<code>Node</code>)构成</p>
<pre><code>data Tree = Leaf Int | Node Tree Int Tree
</code></pre>
<p>定义了<code>occur</code>用来查找具有某个值的节点</p>
<h1 id="Ch11-The-Countdown-Problem"><a href="#Ch11-The-Countdown-Problem" class="headerlink" title="Ch11 The Countdown Problem"></a>Ch11 The Countdown Problem</h1><p>这次换了一位讲师</p>
<h2 id="Countdown游戏介绍"><a href="#Countdown游戏介绍" class="headerlink" title="Countdown游戏介绍"></a>Countdown游戏介绍</h2><p>Countdown游戏中使用若干个正整数（每个数最多使用一次），使用四则运算来计算得到一个指定值，其中所有的中间结果也必须是正整数。</p>
<h2 id="Haskell建模"><a href="#Haskell建模" class="headerlink" title="Haskell建模"></a>Haskell建模</h2><p>首先我们把运算定义成一个<code>Op</code>类型</p>
<pre><code>data Op = Add | Sub | Mul | Div
</code></pre>
<p>然后定义一个<code>apply</code>，<code>apply</code>将一个<code>Op</code>作用到它的两个操作数上。</p>
<pre><code>apply :: Op -&gt; Int -&gt; Int -&gt; Int
apply Add x y = x + y
apply Sub x y = x - y
apply Mul x y = x * y
apply Div x y = x `div` y
</code></pre>
<p>由于游戏中有正整数的限制，所以使用<code>valid</code>来判断某运算是否可以执行</p>
<pre><code>valid :: Op -&gt; Int -&gt; Int -&gt; Bool
valid Add _ _ = True
valid Sub x y = x &gt; y
valid Mul _ _ = True
valid Div x y = x `mod` y == 0
</code></pre>
<p>下面定义<code>Expr</code></p>
<pre><code>data Expr = Val Int | App Op Expr Expr
</code></pre>
<p>相比上一章看到的<code>Expr</code>，这里将<code>Add</code>、<code>Mul</code>等constructor合并成了<code>App</code>(application)constructor。例如<code>1 + 2</code>可以写成</p>
<pre><code>App Add (Val 1) (Val 2)
</code></pre>
<p><code>eval</code>函数能够计算一个<code>Expr</code>的值</p>
<pre><code>eval :: Expr -&gt; [Int]
eval (Val n) = [n | n &gt; 0]
eval (App o l r) = [apply o x y | x &lt;- eval l
                                , y &lt;- eval r
                                , valid o x y]
</code></pre>
<p>虽然<code>eval</code>返回的是一个列表，但到最后列表里只会有一个数，除非出现问题列表里一个数都没有。<br>这里<code>eval</code>匹配了<code>Expr</code>的两个data constructor。<br>在第二个pattern matching条件中使用到了Ch5中讲到的list comprehension，特别地，<code>valid o x y</code>称为guard。注意到在<code>eval (App o l r)</code>中，list comprehension右部给出了三个条件，这三个条件只要有一个不满足，这个list就会变成空的。</p>
<h2 id="Brute-force-solution"><a href="#Brute-force-solution" class="headerlink" title="Brute force solution"></a>Brute force solution</h2><p>定义<code>values</code>函数，列出一个表达式中所有用到的数<br>定义<code>exprs</code>函数，得出一组<code>Int</code>能够构造出的所有<code>Expr</code>，这是一个关键的函数</p>
<pre><code>exprs :: [Int] -&gt; [Expr]
exprs [] = []
exprs [n] = [Val n]
exprs ns = [e | (ls,rs) &lt;- split ns
              , l &lt;- exprs ls
              , r &lt;- exprs rs
              , e &lt;- combine l r]
</code></pre>
<p>对于空列表和单元素列表(singleton list)这是显然的。<br>对于多元素<strong>有序</strong>列表，我们进行divide and conquer。可以用<code>split ns</code>将列表<code>ns</code>进行分划，对于长度为<code>l</code>的序列，我们有<code>l - 1</code>中分划方案。然后我们对于每一个分划<code>(ls,rs)</code>，对其左右部分别递归调用<code>exprs</code>。<br>于是定义<code>split</code>函数，列出一个列表所有的分划<br>得到<code>l::Expr</code>和<code>r::Expr</code>，最后将这两个列表分别合并，得到<code>App Add l r</code>等四个结果。<br>于是可以定义<code>combine</code>函数</p>
<pre><code>combine :: Expr -&gt; Expr -&gt; [Expr]
combine l r = [App o l r | o &lt;- [Add,Sub,Mul,Div]]
</code></pre>
<p>其中</p>
<pre><code>perms :: [a] -&gt; [[a]]
perms []     = [[]]
perms (x:xs) = concat (map (interleave x) (perms xs))
</code></pre>
<p>现在我们可以解决这个问题了，我们对于<code>exprs</code>构造出的每个<code>expr</code>，使用<code>eval expr == [n]</code>即可<code>filter</code>出所有可能的结果。注意到我们不一定要用尽给定的数，也不一定这些数就按照从小到大等特定的顺序排列，所以我们需要尝试给出的数的所有子集。<br>于是可以定义<code>choice</code>函数，列出一个列表所有的子集</p>
<pre><code>choices :: [a] -&gt; [[a]]
choices = concat . map perms . subs
</code></pre>
<p>现在我们可以列举出所有的结果了</p>
<pre><code>solutions :: [Int] -&gt; Int -&gt; [Expr]
solutions ns n = [e | ns&#39; &lt;- choices ns
                    , e &lt;- exprs ns&#39;
                    , eval e == [n]]
</code></pre>
<p>此外我们还可以判断某输入能否构成一组解</p>
<pre><code>solution :: Expr -&gt; [Int] -&gt; Int -&gt; Bool
solution e ns n = elem (values e) (choices ns) &amp;&amp; eval e == [n]
</code></pre>
<h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>考虑到valid的计算式时很少的，所以可以通过earlier rejection策略进行剪枝。</p>
<h1 id="Ch12-Lazy-Evaluation"><a href="#Ch12-Lazy-Evaluation" class="headerlink" title="Ch12 Lazy Evaluation"></a>Ch12 Lazy Evaluation</h1><p>lazy evaluation是Haskell的一个独特的性质</p>
<h2 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h2><p>以自增函数<code>inc</code>为例，<code>inc (2*3)</code>有两种求值顺序。第一种是intermost call-by-value，先对<code>2*3</code>求值为<code>6</code>，然后计算<code>inc 6</code>；第二种是outmost call-by-name，先计算<code>inc (2*3) = (2*3) + 1</code>，然后再计算<code>6 + 1</code>。接着和C#中的带副作用的impure运算进行比较，说明的求值顺序不同的影响。</p>
<p>下面是一个Church-Rosser证明的定理，如果a可以归约为b和c，那么一定有一个d，b和c可以归约到d。</p>
<p>下面介绍带lambda的情况，如<code>mult (1+2) (2+3)</code>可以归约为<code>mult 3 (2+3)</code>、<code>(\y -&gt; 3 * y) (2 + 3)</code>、<code>(\y -&gt; 3 * y) 5</code>。这里教授讲了一个lambda只有在被apply的时候，才会对其内部的东西进行计算，也就是no evaluation under lambda。</p>
<p>call-by-value容易造成陷入无限循环，因为它必须做完所有的求值。例如<code>fst (0, inf)</code>，设<code>inf = inf + 1</code>，很显然call-by-value并不能结束(terminte)，而call-by-name能够将<code>inf</code>“短路”掉返回0。此外，我们还可以想到之前的无限列表。<br>call-by-name相比call-by-value效率就会低一点了，它需要稍多一点的步骤。</p>
<h2 id="综合两种求值顺序的优点"><a href="#综合两种求值顺序的优点" class="headerlink" title="综合两种求值顺序的优点"></a>综合两种求值顺序的优点</h2><p>Lazy evaluation通过call-by-name和sharing的方式综合了两者的优点。<br>例如<code>square (1+2)</code>，可以归约为<code>(1+2) * (1+2)</code>，由于这里重复了<code>(1+2)</code>，所以可以使用late binding的原理，进行下面的归约</p>
<pre><code>   square (1+2)
=&gt; let n = (1+2) in n*n
=&gt; let n = 3 in 3*3
=&gt; 6
</code></pre>
<p>lazy evaluation依赖于改变计算先后不影响计算结果</p>
<h2 id="bottom"><a href="#bottom" class="headerlink" title="bottom"></a>bottom</h2><p>下面比较两个函数</p>
<pre><code>filter (&lt;=5) [1..]
takeWhile (&lt;=5) [1..]
</code></pre>
<p>这两个函数有什么区别呢？<br>在GHCI中运行第一个函数，发现lazy evaluation并没有发生，其结果可以表示为</p>
<pre><code>1: (2: (3: (4: (5: _|_))))
</code></pre>
<p>这里的<code>_|_</code>即⊥，称为bottom，在之前的课程中也出现过，表示something that won’t terminate。<br>而第二个函数则能够正常结束</p>
<pre><code>1: (2: (3: (4: (5: []))))
</code></pre>
<h2 id="strict-application"><a href="#strict-application" class="headerlink" title="strict application"></a>strict application</h2><p>可以用<code>($!)</code>，称为strict application运算符来强制计算函数的参数</p>
<pre><code>f $! _|_ = _|_
f $! x = f x
</code></pre>
<p>对于有多个参数的情形，可以按照以下方法</p>
<pre><code>(f $! x) y -- 强制计算 x
(f x) $! y -- 强制计算 y
(f $! x) $! y -- 强制计算 x和y
</code></pre>
<p>有的时候强制计算的eager evaluation反而是更好的，例如</p>
<pre><code>-- lazy
sumWith v [] = v
sumWith v (x:xs) = sumWith (v+x) xs
-- strict
sumWith v [] = v
sumWith v (x:xs) = (sumWith $! (v+x) ) xs
</code></pre>
<p>这两者的计算结果都是6，但是中间过程会有区别。事实上，strict版本会更加节省空间，因为如果我们对lazy版本展开会发现存在以下两步的推导过程</p>
<pre><code>sumwith (((0 + 1) + 2) + 3) []
((0 + 1) + 2) + 3
</code></pre>
<p>所以在每一步计算中，我们都要维护一个逐渐增长的列表。但是如果使用strict版本，我们实际上维护的只有一个累加值。</p>
<h1 id="Ch13-Reasoning-about-programs"><a href="#Ch13-Reasoning-about-programs" class="headerlink" title="Ch13 Reasoning about programs"></a>Ch13 Reasoning about programs</h1><h1 id="总结与专题论述"><a href="#总结与专题论述" class="headerlink" title="总结与专题论述"></a>总结与专题论述</h1><h2 id="Haskell的特性"><a href="#Haskell的特性" class="headerlink" title="Haskell的特性"></a>Haskell的特性</h2><ol>
<li>柯里化和高阶函数（包括section）</li>
<li>惰性求值</li>
<li>模式匹配和guard（包括where）</li>
<li>类型系统和多态（包括泛型、类型类、抽象代数类型(ADT)、higher kinded polymorphic、type defaulting等）<br> 具体特性的部分解释可以查看<a href="https://downloads.haskell.org/~ghc/7.0.1/docs/html/users_guide/type-class-extensions.html" target="_blank" rel="noopener">这个网站</a></li>
<li>Monad（包括ST Monad）</li>
<li>强类型、静态类型</li>
</ol>
<h2 id="有关多态"><a href="#有关多态" class="headerlink" title="有关多态"></a>有关多态</h2><p>多态(polymorphism)在C++/Java等面向对象语言中常指子类多态(Subtype polymorphism)，也就是在继承关系中子类可以修改或者扩展父类中的方法，但此时在包含关系上它也被视作是父类型的对象。例如在C++中调用虚函数时会根据当前<code>this</code>的类型查阅虚函数表从而选择正确的函数，这个多态是在运行期的。在<a href="http://rwh.readthedocs.io/en/latest/chp/2.html" target="_blank" rel="noopener">Real World Haskell</a>一书中指出Haskell虽然不具有子类(subtype)多态，但它有类型多态和参数多态。类型多态是我们之前提过的higher kinded polymorphic（注意<a href="https://www.stephanboyer.com/post/115/higher-rank-and-higher-kinded-types" target="_blank" rel="noopener">区别higher rank polymorphic</a>），比如Haskell中的列表<code>[]</code>就是类型多态的，因为我们常常可以见到如<code>map</code>这样的函数中出现<code>[a]</code>，也就是说我们不关心<code>a</code>到底是什么，这里的<code>[]</code>也被称为一个type constructor。与此同时我们称<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>为参数多态(Parametric polymorphism)，因为<code>map</code>接受的参数可以是符合其signature的任意（<a href="https://wiki.haskell.org/Polymorphism" target="_blank" rel="noopener">unconstrained 的</a>）类型的。Ad-hoc多态强调一个值对应于不同类型时拥有分别的定义。显而易见的，函数重载也被视为一种Ad-hoc多态，一个例子是</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://www.jianshu.com/p/b641cf2908cf</span></span><br><span class="line"><span class="keyword">class</span> BasicEq a <span class="keyword">where</span> </span><br><span class="line">    isEqual :: a -&gt; a -&gt; Bool</span><br><span class="line"></span><br><span class="line"><span class="keyword">instance</span> BasicEq Bool <span class="keyword">where</span> </span><br><span class="line">    isEqual <span class="literal">True</span> <span class="literal">True</span> = <span class="literal">True</span> </span><br><span class="line">    isEqual <span class="literal">False</span> <span class="literal">False</span> = <span class="literal">True</span> </span><br><span class="line">    isEqual _ _ = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>有关Parametric polymorphism、higher kinded polymorphism和higher rank polymorphism的概念我们将在另外一篇文章中进行探讨。</p>
<h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><p>在学习完这本书后，能够对Haskell的关键概念有比较清晰的理解，但是如果需要应用Haskell编程还有一些困难，这时候可以再看看另一本很好的书《Haskell趣学指南》<br>此外，我这个笔记其实有部分的碎碎念，这导致笔记的逻辑可能不太连贯。但是我还是记录下这部分，如果有和我一样在某些地方钻了牛角尖的，至少我这里能给出我的一些见解。</p>
<p>【未完待续】</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">http://learnyouahaskell.com</a></li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Haskell/" rel="tag"># Haskell</a>
          
            <a href="/tags/函数式/" rel="tag"># 函数式</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/02/11/C++-rvalue/" rel="next" title="C++右值">
                <i class="fa fa-chevron-left"></i> C++右值
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/03/02/使用deap实现遗传算法/" rel="prev" title="使用deap实现遗传算法">
                使用deap实现遗传算法 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">193</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">143</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch0"><span class="nav-number">1.</span> <span class="nav-text">Ch0</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#配置Haskell环境"><span class="nav-number">1.1.</span> <span class="nav-text">配置Haskell环境</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch1-Introduction"><span class="nav-number">2.</span> <span class="nav-text">Ch1 Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch2-First-Steps"><span class="nav-number">3.</span> <span class="nav-text">Ch2 First Steps</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#列表处理"><span class="nav-number">3.1.</span> <span class="nav-text">列表处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三种编程语言的比较"><span class="nav-number">3.2.</span> <span class="nav-text">三种编程语言的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数调用"><span class="nav-number">3.3.</span> <span class="nav-text">函数调用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#type-class"><span class="nav-number">3.4.</span> <span class="nav-text">type class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#instance"><span class="nav-number">3.4.1.</span> <span class="nav-text">instance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#composition"><span class="nav-number">3.5.</span> <span class="nav-text">composition</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符和-运算符的比较"><span class="nav-number">3.5.1.</span> <span class="nav-text">.运算符和$运算符的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将函数作为操作符"><span class="nav-number">3.6.</span> <span class="nav-text">将函数作为操作符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#reload"><span class="nav-number">3.7.</span> <span class="nav-text">:reload</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名规则"><span class="nav-number">3.8.</span> <span class="nav-text">命名规则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch3-Types-and-Classes"><span class="nav-number">4.</span> <span class="nav-text">Ch3 Types and Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#表达式的类型"><span class="nav-number">4.1.</span> <span class="nav-text">表达式的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#t或-type"><span class="nav-number">4.2.</span> <span class="nav-text">:t或:type</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Haskell的基本类型"><span class="nav-number">4.3.</span> <span class="nav-text">Haskell的基本类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数的类型"><span class="nav-number">4.4.</span> <span class="nav-text">函数的类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unit"><span class="nav-number">4.5.</span> <span class="nav-text">unit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#柯里化"><span class="nav-number">4.6.</span> <span class="nav-text">柯里化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多态函数"><span class="nav-number">4.7.</span> <span class="nav-text">多态函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typeclass"><span class="nav-number">4.7.1.</span> <span class="nav-text">typeclass</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Existential-Quantification"><span class="nav-number">4.7.2.</span> <span class="nav-text">Existential Quantification</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch4-Defining-Functions"><span class="nav-number">5.</span> <span class="nav-text">Ch4 Defining Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#if"><span class="nav-number">5.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#guarded-equations"><span class="nav-number">5.2.</span> <span class="nav-text">guarded equations</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#偏函数应用与部分函数"><span class="nav-number">5.2.1.</span> <span class="nav-text">偏函数应用与部分函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where语句"><span class="nav-number">5.3.</span> <span class="nav-text">where语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#where的作用域"><span class="nav-number">5.3.1.</span> <span class="nav-text">where的作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where存在的问题"><span class="nav-number">5.3.2.</span> <span class="nav-text">where存在的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#where、let-in与let的区别"><span class="nav-number">5.3.3.</span> <span class="nav-text">where、let in与let的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pattern-matching"><span class="nav-number">5.4.</span> <span class="nav-text">pattern matching</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lazy-evaluation"><span class="nav-number">5.5.</span> <span class="nav-text">lazy evaluation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pattern具有优先级"><span class="nav-number">5.6.</span> <span class="nav-text">pattern具有优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重复的名字不能出现在pattern中"><span class="nav-number">5.7.</span> <span class="nav-text">重复的名字不能出现在pattern中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-pattern和"><span class="nav-number">5.8.</span> <span class="nav-text">list pattern和:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda"><span class="nav-number">5.9.</span> <span class="nav-text">lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#section与偏函数"><span class="nav-number">5.10.</span> <span class="nav-text">section与偏函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch5-List-Comprehensions"><span class="nav-number">6.</span> <span class="nav-text">Ch5 List Comprehensions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#zip"><span class="nav-number">6.1.</span> <span class="nav-text">zip</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string"><span class="nav-number">6.2.</span> <span class="nav-text">string</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch6-Recursive-Functions"><span class="nav-number">7.</span> <span class="nav-text">Ch6 Recursive Functions</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch7-Higher-Order-Functions"><span class="nav-number">8.</span> <span class="nav-text">Ch7 Higher-Order Functions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶函数用途"><span class="nav-number">8.1.</span> <span class="nav-text">高阶函数用途</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map"><span class="nav-number">8.2.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filter"><span class="nav-number">8.3.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fold"><span class="nav-number">8.4.</span> <span class="nav-text">fold</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#foldl和foldr的区别"><span class="nav-number">8.4.1.</span> <span class="nav-text">foldl和foldr的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用fold实现函数"><span class="nav-number">8.4.2.</span> <span class="nav-text">使用fold实现函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fold的作用"><span class="nav-number">8.4.3.</span> <span class="nav-text">fold的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#unfoldr"><span class="nav-number">8.5.</span> <span class="nav-text">unfoldr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#scanl"><span class="nav-number">8.6.</span> <span class="nav-text">scanl</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更多的高阶函数"><span class="nav-number">8.7.</span> <span class="nav-text">更多的高阶函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fmap"><span class="nav-number">8.8.</span> <span class="nav-text">fmap</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch8-Functional-Parsers"><span class="nav-number">9.</span> <span class="nav-text">Ch8 Functional Parsers</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Parser-Type"><span class="nav-number">9.1.</span> <span class="nav-text">Parser Type</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bottom"><span class="nav-number">9.1.1.</span> <span class="nav-text">Bottom</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一些简单的语法分析器"><span class="nav-number">9.2.</span> <span class="nav-text">一些简单的语法分析器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#item"><span class="nav-number">9.2.1.</span> <span class="nav-text">item</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#failure"><span class="nav-number">9.2.2.</span> <span class="nav-text">failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#return"><span class="nav-number">9.2.3.</span> <span class="nav-text">return</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#return关键字的辨析"><span class="nav-number">9.2.3.1.</span> <span class="nav-text">return关键字的辨析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">9.2.4.</span> <span class="nav-text">+++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#parse"><span class="nav-number">9.2.5.</span> <span class="nav-text">parse</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检验上面的语法分析器"><span class="nav-number">9.3.</span> <span class="nav-text">检验上面的语法分析器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequencing"><span class="nav-number">9.4.</span> <span class="nav-text">Sequencing</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#do"><span class="nav-number">9.4.1.</span> <span class="nav-text">do</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Select和SelectMany"><span class="nav-number">9.4.2.</span> <span class="nav-text">Select和SelectMany</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-gt"><span class="nav-number">9.4.3.</span> <span class="nav-text">&gt;&gt;=</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Monad"><span class="nav-number">9.4.4.</span> <span class="nav-text">Monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-Monad和-lt"><span class="nav-number">9.4.5.</span> <span class="nav-text">List Monad和&lt;-</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Maybe-Monad"><span class="nav-number">9.4.6.</span> <span class="nav-text">Maybe Monad</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结论"><span class="nav-number">9.4.7.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad与Continuation"><span class="nav-number">9.5.</span> <span class="nav-text">Monad与Continuation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Continuation简介"><span class="nav-number">9.5.1.</span> <span class="nav-text">Continuation简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Continuation-Monad"><span class="nav-number">9.5.2.</span> <span class="nav-text">Continuation Monad</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functor"><span class="nav-number">9.6.</span> <span class="nav-text">Functor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Maybe-Functor"><span class="nav-number">9.6.1.</span> <span class="nav-text">Maybe Functor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Function-Functor-gt"><span class="nav-number">9.6.2.</span> <span class="nav-text">Function Functor -&gt;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fmap的性质"><span class="nav-number">9.6.3.</span> <span class="nav-text">fmap的性质</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applicative"><span class="nav-number">9.7.</span> <span class="nav-text">Applicative</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monoid"><span class="nav-number">9.8.</span> <span class="nav-text">Monoid</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad和Functor以及Applicative"><span class="nav-number">9.9.</span> <span class="nav-text">Monad和Functor以及Applicative</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Derived-Primitive"><span class="nav-number">9.10.</span> <span class="nav-text">Derived Primitive</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad的性质"><span class="nav-number">9.11.</span> <span class="nav-text">Monad的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#do-1"><span class="nav-number">9.11.1.</span> <span class="nav-text">do</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#gt-gt-1"><span class="nav-number">9.11.2.</span> <span class="nav-text">&gt;&gt;=</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad相关函数操作"><span class="nav-number">9.12.</span> <span class="nav-text">Monad相关函数操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lifting"><span class="nav-number">9.12.1.</span> <span class="nav-text">Lifting</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch9-Interactive-Programs"><span class="nav-number">10.</span> <span class="nav-text">Ch9 Interactive Programs</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#交互式操作"><span class="nav-number">10.1.</span> <span class="nav-text">交互式操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用IO函数"><span class="nav-number">10.2.</span> <span class="nav-text">常用IO函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标准输入输出"><span class="nav-number">10.2.1.</span> <span class="nav-text">标准输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件操作"><span class="nav-number">10.2.2.</span> <span class="nav-text">文件操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接口操作"><span class="nav-number">10.2.3.</span> <span class="nav-text">套接口操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO-Sequencing"><span class="nav-number">10.3.</span> <span class="nav-text">IO Sequencing</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Derived-Primitives"><span class="nav-number">10.4.</span> <span class="nav-text">Derived Primitives</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#随机"><span class="nav-number">10.5.</span> <span class="nav-text">随机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-number">10.6.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch10-Declaring-Types-and-Classes"><span class="nav-number">11.</span> <span class="nav-text">Ch10 Declaring Types and Classes</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#有关type-function"><span class="nav-number">11.1.</span> <span class="nav-text">有关type function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Type-Declarations"><span class="nav-number">11.2.</span> <span class="nav-text">Type Declarations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Data-Declarations"><span class="nav-number">11.3.</span> <span class="nav-text">Data Declarations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#data-value-constructor和type-constructor"><span class="nav-number">11.4.</span> <span class="nav-text">data/value constructor和type constructor</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#instance、type和data语句的区别"><span class="nav-number">11.4.1.</span> <span class="nav-text">instance、type和data语句的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Recursive-types"><span class="nav-number">11.5.</span> <span class="nav-text">Recursive types</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Church-encoding和Scott-encoding"><span class="nav-number">11.5.1.</span> <span class="nav-text">Church encoding和Scott encoding</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Arithmetic-Expressions"><span class="nav-number">11.6.</span> <span class="nav-text">Arithmetic Expressions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree"><span class="nav-number">11.7.</span> <span class="nav-text">Binary Tree</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch11-The-Countdown-Problem"><span class="nav-number">12.</span> <span class="nav-text">Ch11 The Countdown Problem</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Countdown游戏介绍"><span class="nav-number">12.1.</span> <span class="nav-text">Countdown游戏介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Haskell建模"><span class="nav-number">12.2.</span> <span class="nav-text">Haskell建模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Brute-force-solution"><span class="nav-number">12.3.</span> <span class="nav-text">Brute force solution</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剪枝优化"><span class="nav-number">12.4.</span> <span class="nav-text">剪枝优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch12-Lazy-Evaluation"><span class="nav-number">13.</span> <span class="nav-text">Ch12 Lazy Evaluation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#求值顺序"><span class="nav-number">13.1.</span> <span class="nav-text">求值顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#综合两种求值顺序的优点"><span class="nav-number">13.2.</span> <span class="nav-text">综合两种求值顺序的优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bottom"><span class="nav-number">13.3.</span> <span class="nav-text">bottom</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#strict-application"><span class="nav-number">13.4.</span> <span class="nav-text">strict application</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ch13-Reasoning-about-programs"><span class="nav-number">14.</span> <span class="nav-text">Ch13 Reasoning about programs</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结与专题论述"><span class="nav-number">15.</span> <span class="nav-text">总结与专题论述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Haskell的特性"><span class="nav-number">15.1.</span> <span class="nav-text">Haskell的特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#有关多态"><span class="nav-number">15.2.</span> <span class="nav-text">有关多态</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#备注"><span class="nav-number">16.</span> <span class="nav-text">备注</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">17.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2017/02/28/haskell学习笔记/';
          this.page.identifier = '2017/02/28/haskell学习笔记/';
          this.page.title = 'Haskell学习笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

</body>
</html>
