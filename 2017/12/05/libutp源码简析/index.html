<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="网络,UDP,libutp," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="libutp是uTorrent使用的类似TCP的传输层实现。它基于UDP提供可信的、有序的点对点的传输，并具有最少的时延。需要注意的是utp和另一个基于UDP的传输协议QUIC的实现思路和优势并不一样，例如QUIC更强调连接建立的快速性，建立连接时只需要1至2次握手，又如QUIC将TLS整合到协议中，实现了0RTT，而基于HTTP2的协议需要2/3RTT。QUIC还允许在用户层面配置各种拥塞控制算">
<meta name="keywords" content="网络,UDP,libutp">
<meta property="og:type" content="article">
<meta property="og:title" content="libutp源码简析">
<meta property="og:url" content="http://www.calvinneo.com/2017/12/05/libutp源码简析/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="libutp是uTorrent使用的类似TCP的传输层实现。它基于UDP提供可信的、有序的点对点的传输，并具有最少的时延。需要注意的是utp和另一个基于UDP的传输协议QUIC的实现思路和优势并不一样，例如QUIC更强调连接建立的快速性，建立连接时只需要1至2次握手，又如QUIC将TLS整合到协议中，实现了0RTT，而基于HTTP2的协议需要2/3RTT。QUIC还允许在用户层面配置各种拥塞控制算">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-10-15T14:57:06.610Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="libutp源码简析">
<meta name="twitter:description" content="libutp是uTorrent使用的类似TCP的传输层实现。它基于UDP提供可信的、有序的点对点的传输，并具有最少的时延。需要注意的是utp和另一个基于UDP的传输协议QUIC的实现思路和优势并不一样，例如QUIC更强调连接建立的快速性，建立连接时只需要1至2次握手，又如QUIC将TLS整合到协议中，实现了0RTT，而基于HTTP2的协议需要2/3RTT。QUIC还允许在用户层面配置各种拥塞控制算">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2017/12/05/libutp源码简析/"/>





  <title>libutp源码简析 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2017/12/05/libutp源码简析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                libutp源码简析
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-05T12:27:20+08:00">
                2017-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://github.com/bittorrent/libutp" target="_blank" rel="noopener">libutp</a>是uTorrent使用的类似TCP的传输层实现。它基于UDP提供可信的、有序的点对点的传输，并具有最少的时延。需要注意的是utp和另一个基于UDP的传输协议QUIC的<a href="https://zhuanlan.zhihu.com/p/32553477" target="_blank" rel="noopener">实现思路和优势</a>并不一样，例如QUIC更强调连接建立的快速性，建立连接时只需要1至2次握手，又如QUIC将TLS整合到协议中，实现了0RTT，而基于HTTP2的协议需要2/3RTT。QUIC还允许在用户层面配置各种拥塞控制算法。<br>网上有关libutp实现的介绍几乎没有，因此我打算就其源码做一个简单的分析。这里要注意UTP是基于包的而不像TCP是基于流的，虽然它提供的API还是基于流的。这样有一些影响，例如黏包问题的处理、缓冲区的管理（例如可以去掉PUSH标记）、窗口管理、重新分组等方面。</p>
<h1 id="uTP源码简介"><a href="#uTP源码简介" class="headerlink" title="uTP源码简介"></a>uTP源码简介</h1><p><strong>utp.h</strong>以C89的形式提供接口。例如<code>utp_write</code>是以proactive的方式实现的。<br>utp相关的实现大多在<strong>utp_internal.cpp</strong>文件中。<br><strong>utp_packedsockaddr.cpp</strong>中封装了<code>sockaddr_in</code>结构。<br><strong>ucat.c</strong>基于uTP框架构建了一个基础的应用。<br>uTP的设计主要是异步的，应用代码不会阻塞在异步IO操作上，而是指定回调函数并立即返回。<strong>utp_callbacks.cpp</strong>中注册了各种回调函数，utp向外界传输消息都是以这里回调的形式开展的。例如当收到数据包时，<code>ctx-&gt;callbacks[UTP_ON_READ]</code>这个回调函数就会被调用。</p>
<a id="more"></a>

<p>使用回调函数也体现了libutp总体的设计思路：</p>
<ol>
<li>回调函数能够屏蔽掉套接字API的细节<br> 一个可靠通信协议的主要任务是在不可靠的设施上建立可靠的传输通道，至于使用哪一种不可靠的传输方式并不是核心问题。uTP协议的<strong>内部实现</strong>能够与UDP套接字等做到隔离，utp不是继承或者封装了UDP套接字描述符，然后提供一个TCP的鸭子类型。而是完全工作在UDP上层，打包了一些对UDP的操作，方便用户调用。<br> 例如uTP就可以选择不实现<code>sendto</code>等方法，而用户选择使用<code>send</code>还是<code>write</code>还是<code>sendmsg</code>，然后写成回调，uTP只需要在它需要通过UDP发送它构造的数据报时调用这个回调就好了。又例如系统从UDP套接口收到一个消息时，它并不是直接处理，而是调用<code>utp_process_udp</code>函数。对于一个已连接的套接字，这个函数会找到对应的<code>UTPSocket</code>结构，并调用<code>utp_process_incoming</code>函数，该函数是个非常大的函数，里面uTP协议根据自己的报头处理了相关消息之后，调用用户设置的回调函数通知收到了消息。对于连接请求，我们将在下面的被动连接上详细讨论。</li>
<li>回调函数方便实现proactive和reactive风格的API<br>常见的反射式(reactive)异步IO模型包括select、poll、kqueue、Java NIO等，只会通知到某IO设备上产生了IO事件，然后由用户来发起IO请求，例如调用<code>read</code>、<code>recv</code>等。前摄式(proactive)包括IOCP、Boost Asio等，用户主动发送IO请求（即使现在IO设备还没有准备好）并提前向系统注册一个回调函数，当实际的IO事件发生时由系统处理该IO操作，并在<strong>完成后</strong>触发指定的回调函数，因此前摄式能够避免用户将数据从内核取回来的开销。因此前摄式强调的是对未来读取事件的预期，抽象程度要高一点，用户可以利用Proactor的回调构造一条执行顺序链，而Reactor必须手动维护接受的状态。</li>
<li>回调函数能减少处理并发问题的难度</li>
</ol>
<p>鉴于以上的这几点，在分析uTP协议时必须要将<strong>ucat.c</strong>纳入考虑范围，不然很难搞懂原理。</p>
<h1 id="ucat简介"><a href="#ucat简介" class="headerlink" title="ucat简介"></a>ucat简介</h1><p>ucat使用了poll来维护了两个fd，stdin和套接口，并且设置了500ms的超时时间。</p>
<h1 id="uTP重要数据结构"><a href="#uTP重要数据结构" class="headerlink" title="uTP重要数据结构"></a>uTP重要数据结构</h1><h2 id="utp-context"><a href="#utp-context" class="headerlink" title="utp_context"></a>utp_context</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utp.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">struct_utp_context</span> <span class="title">utp_context</span>;</span></span><br><span class="line"><span class="comment">// utp_internal.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_utp_context</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *userdata;</span><br><span class="line">    <span class="keyword">utp_callback_t</span>* callbacks[UTP_ARRAY_SIZE];</span><br><span class="line"></span><br><span class="line">    uint64 current_ms;</span><br><span class="line">    utp_context_stats context_stats;</span><br><span class="line">    UTPSocket *last_utp_socket;</span><br><span class="line">    Array&lt;UTPSocket*&gt; ack_sockets;</span><br><span class="line">    Array&lt;RST_Info&gt; rst_info;</span><br><span class="line">    UTPSocketHT *utp_sockets;</span><br><span class="line">    <span class="keyword">size_t</span> target_delay;</span><br><span class="line">    <span class="keyword">size_t</span> opt_sndbuf;</span><br><span class="line">    <span class="keyword">size_t</span> opt_rcvbuf;</span><br><span class="line">    uint64 last_check;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// utp_api.cpp</span></span><br><span class="line">    struct_utp_context::struct_utp_context()</span><br><span class="line">        : userdata(<span class="literal">NULL</span>), current_ms(<span class="number">0</span>), last_utp_socket(<span class="literal">NULL</span>), log_normal(<span class="literal">false</span>), log_mtu(<span class="literal">false</span>), log_debug(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;context_stats, <span class="number">0</span>, <span class="keyword">sizeof</span>(context_stats));</span><br><span class="line">        <span class="built_in">memset</span>(callbacks, <span class="number">0</span>, <span class="keyword">sizeof</span>(callbacks));</span><br><span class="line">        target_delay = CCONTROL_TARGET;</span><br><span class="line">        utp_sockets = <span class="keyword">new</span> UTPSocketHT;</span><br><span class="line"></span><br><span class="line">        callbacks[UTP_GET_UDP_MTU]      = &amp;utp_default_get_udp_mtu;</span><br><span class="line">        callbacks[UTP_GET_UDP_OVERHEAD] = &amp;utp_default_get_udp_overhead;</span><br><span class="line">        callbacks[UTP_GET_MILLISECONDS] = &amp;utp_default_get_milliseconds;</span><br><span class="line">        callbacks[UTP_GET_MICROSECONDS] = &amp;utp_default_get_microseconds;</span><br><span class="line">        callbacks[UTP_GET_RANDOM]       = &amp;utp_default_get_random;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 MB of receive buffer (i.e. max bandwidth delay product)</span></span><br><span class="line">        <span class="comment">// means that from  a peer with 200 ms RTT, we cannot receive</span></span><br><span class="line">        <span class="comment">// faster than 5 MB/s</span></span><br><span class="line">        <span class="comment">// from a peer with 10 ms RTT, we cannot receive faster than</span></span><br><span class="line">        <span class="comment">// 100 MB/s. This is assumed to be good enough, since bandwidth</span></span><br><span class="line">        <span class="comment">// often is proportional to RTT anyway</span></span><br><span class="line">        <span class="comment">// when setting a download rate limit, all sockets should have</span></span><br><span class="line">        <span class="comment">// their receive buffer set much lower, to say 60 kiB or so</span></span><br><span class="line">        opt_rcvbuf = opt_sndbuf = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">        last_check = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~struct_utp_context()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;utp_sockets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, utp_socket *socket, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">log_unchecked</span><span class="params">(utp_socket *socket, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">would_log</span><span class="params">(<span class="keyword">int</span> level)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> log_normal:<span class="number">1</span>;  <span class="comment">// log normal events?</span></span><br><span class="line">    <span class="keyword">bool</span> log_mtu:<span class="number">1</span>;     <span class="comment">// log MTU related events?</span></span><br><span class="line">    <span class="keyword">bool</span> log_debug:<span class="number">1</span>;   <span class="comment">// log debugging events? (Must also compile with UTP_DEBUG_LOGGING defined)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="utp-context的成员"><a href="#utp-context的成员" class="headerlink" title="utp_context的成员"></a>utp_context的成员</h3><ol>
<li><p><code>utp_sockets</code><br> <code>utp_sockets</code>指向一个<code>UTPSocketHT : utpHashTable&lt;UTPSocketKey, UTPSocketKeyData&gt;</code>哈希表。这个哈希表维护了所有的套接字：</p>
<ul>
<li>在<code>utp_sockets</code>析构时调用<code>UTP_FreeAll</code>释放所有的套接字。</li>
<li>当UDP包被接受时，会调用<code>utp_process_udp</code>这个处理程序。此时我们仅能获得对应的套接字地址<code>const struct sockaddr *</code>，因此需要能够通过这个指针找到对应的套接字。</li>
</ul>
<p> <code>UTPSocketHT</code>中的键<code>UTPSocketKey</code>和值<code>UTPSocketKeyData</code>的构造如下：    </p>
<ul>
<li><p>键<code>UTPSocketKey</code>中存放了对应<code>UTPSocket</code>中的<code>PackedSockAddr addr</code>以及<code>recv_id</code>字段。<br>  <code>PackedSockAddr addr</code>字段是在<code>utp_initialize_socket</code>设置的，表示指向的目标地址。<br>  <code>recv_id</code>对应着套接字里面的<code>conn_id_recv</code>字段，是在<code>utp_initialize_socket</code>中随机生成的。这里的<code>recv_id</code>的主要功能是作为ATP协议中“host端的端口号”来使用。查看相关代码我们可以发现<code>conn_id_send</code>始终比<code>conn_id_recv</code>要大1。</p>
  <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// utp_process_udp</span><br><span class="line">utp_initialize_socket(conn, to, tolen, <span class="literal">false</span>, id, id+<span class="number">1</span>, id);</span><br><span class="line">// <span class="built_in">void</span> utp_initialize_socket(utp_socket *conn, <span class="keyword">const</span> struct sockaddr *<span class="keyword">addr</span>, socklen_t addrlen, <span class="built_in">bool</span> need_seed_gen, <span class="built_in">uint32</span> conn_seed, <span class="built_in">uint32</span> conn_id_recv, <span class="built_in">uint32</span> conn_id_send)&#123;</span><br><span class="line">// ...</span><br><span class="line">conn_id_recv += conn_seed;</span><br><span class="line">conn_id_send += conn_seed;</span><br></pre></td></tr></table></figure>

<p>  下面讨论了几个重要的问题</p>
<ul>
<li>为什么我们要使用id而不直接使用四元组呢？<br>  使用id能够方便地实现以下的机制（虽然libutp并不一定实现了）<ol>
<li>使用三次握手和四次挥手的很高创建成本很高，使用ID能够复用已经创建好的连接。当然这样的复用可能带来<strong>队头阻塞</strong>问题，需要小心处理。</li>
<li>将<strong>连接</strong>概念独立于四元组概念，方便隔离底层，从而实现连接迁移。QUIC实现了这个特性。</li>
</ol>
</li>
<li>为什么要有两个id呢？<br>  这是因为在同一个UDP port上会存在多个uTP连接，因此我们需要增设一个ID字段来区分这些连接。对于每一个套接口，uTP选择它的发送和接受都设置一个ID。当<code>utp_process_udp</code>接受到UDP包的时候，他获得的是一个<code>sockaddr</code>地址，所以需要找到对应的<code>UTPSocket</code>套接字，当套接字不存在时，需要发送RST包。当套接字关闭时，需要它来维护2MSL的等待时间，实际上由于UDP的<code>UTPSocketKey</code>包含了<code>recv_id</code>，所以2MSL是不必要的，在<code>UTPSocket::check_timeouts</code>代码中看到只等到<code>rto_timeout</code>就行。</li>
<li>为什么选择<code>conn_id_recv</code>而不是<code>conn_id_send</code>来作为哈希值呢？<br>  这是因为当数据报到达时，要通过里面的<code>recv_id</code>找到具有特定<code>conn_id_recv</code>的套接字。</li>
</ul>
</li>
<li><p>值<code>UTPSocketKeyData</code>中主要持有了对应的<code>UTPSocket *</code>的指针。</p>
</li>
</ul>
</li>
<li><p><code>opt_sndbuf</code>和<code>opt_rcvbuf</code><br> 这两个<code>size_t</code>表示发送缓冲区和接收缓冲区的默认大小。缓冲区的大小与窗口大小形成协同。在创建套接字时，套接字的<code>opt_sndbuf</code>和<code>opt_rcvbuf</code>会“继承自”对应的context。</p>
</li>
<li><p><code>target_delay</code>单位为微秒，初始值为<code>CCONTROL_TARGET = 100 * 1000</code>。</p>
</li>
<li><p><code>current_ms</code>的作用是用来保存当前时间，这样可以避免多次调用获取时间函数的开销。</p>
</li>
<li><p><code>context_stats</code>是一个<code>utp_context_stats</code>类型的结构，用来统计不同大小的uTP包的数量。</p>
</li>
<li><p><code>ack_sockets</code>与schedule_ack机制有关，详见超时重传部分。</p>
</li>
<li><p><code>rst_info</code>维护了<code>RST_INFO_LIMIT</code>个reset信息，详见连接重置部分。</p>
</li>
</ol>
<h3 id="utp-context的用途"><a href="#utp-context的用途" class="headerlink" title="utp_context的用途"></a>utp_context的用途</h3><ol>
<li>方便集中管理的UTP套接口<code>UTPSocket</code><br> 从上面的结构中看到所有的<code>UTPSocket</code>被放到一个哈希表里面。当<code>UTPSocket</code>销毁时，要将哈希表中对应的<code>&lt;UTPSocketKey, UTPSocketKeyData&gt;</code>键值对删掉，在<code>utp_initialize_socket</code>函数中要往context里面注册自己，这些操作实际上都是为了方便集中管理套接字。<br> 以<code>utp_check_timeouts</code>函数为例，这个函数作为每次“时钟中断”的入口，接受的是一个<code>utp_context</code>而不是一个<code>UTPSocket</code>，context里面对所有的<code>UTPSocket</code>调用了<code>check_timeouts</code>，这样避免了为每一个套接字维护一个时钟信号的开销。</li>
<li>方便实现UTP服务<br> libutp是工作在用户态的，所以并不能向外提供系统调用，因此每一个进程会维护一个utp_context。</li>
</ol>
<h2 id="utp-socket"><a href="#utp-socket" class="headerlink" title="utp_socket"></a>utp_socket</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utp.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">UTPSocket</span> <span class="title">utp_socket</span>;</span></span><br><span class="line"><span class="comment">// utp_internal.cpp</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UTPSocket</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>UTPSocket</code>类型用来维护一个套接字的上下文，里面东西比较多，将在下面展开讨论。</p>
<h2 id="OutgoingPacket"><a href="#OutgoingPacket" class="headerlink" title="OutgoingPacket"></a>OutgoingPacket</h2><p>对于一个（将要）被发出去的包，有一个<code>OutgoingPacket</code>与其对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutgoingPacket</span>&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> length; <span class="comment">// 总长</span></span><br><span class="line">    <span class="keyword">size_t</span> payload; <span class="comment">// 有效载荷</span></span><br><span class="line">    <span class="keyword">uint64_t</span> time_sent; <span class="comment">// microseconds</span></span><br><span class="line">    <span class="keyword">uint32_t</span> transmissions; <span class="comment">// 总传输次数</span></span><br><span class="line">    <span class="keyword">bool</span> need_resend;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的<code>data</code>是个VLA（这里勘误一下，VLA是另外一个C99特性，实际上这里是一个Flex Array），实际上是包头+数据包的全部内容。注意到最好不要将包头和数据包分开存放，不然又要多一次复制的开销。</p>
<h2 id="PacketFormatV1-PacketFormatAckV1"><a href="#PacketFormatV1-PacketFormatAckV1" class="headerlink" title="PacketFormatV1/PacketFormatAckV1"></a>PacketFormatV1/PacketFormatAckV1</h2><p>首先查看基础的<code>PacketFormatV1</code>，这是一个uTP常规数据报的报头。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utp_internal.cpp</span></span><br><span class="line"><span class="keyword">struct</span> PACKED_ATTRIBUTE PacketFormatV1 &#123;</span><br><span class="line">    <span class="comment">// packet_type (4 high bits)</span></span><br><span class="line">    <span class="comment">// protocol version (4 low bits)</span></span><br><span class="line">    <span class="keyword">byte</span> ver_type;</span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">version</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ver_type &amp; <span class="number">0xf</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">byte</span> <span class="title">type</span>(<span class="params"></span>) <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> ver_type &gt;&gt; <span class="number">4</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_version</span>(<span class="params"><span class="keyword">byte</span> v</span>) </span>&#123; ver_type = (ver_type &amp; <span class="number">0xf0</span>) | (v &amp; <span class="number">0xf</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_type</span>(<span class="params"><span class="keyword">byte</span> t</span>) </span>&#123; ver_type = (ver_type &amp; <span class="number">0xf</span>) | (t &lt;&lt; <span class="number">4</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type of the first extension header</span></span><br><span class="line">    <span class="keyword">byte</span> ext;</span><br><span class="line">    <span class="comment">// connection ID</span></span><br><span class="line">    uint16_big connid;</span><br><span class="line">    uint32_big tv_usec;</span><br><span class="line">    uint32_big reply_micro;</span><br><span class="line">    <span class="comment">// receive window size in bytes</span></span><br><span class="line">    uint32_big windowsize;</span><br><span class="line">    <span class="comment">// Sequence number</span></span><br><span class="line">    uint16_big seq_nr;</span><br><span class="line">    <span class="comment">// Acknowledgment number</span></span><br><span class="line">    uint16_big ack_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>ver_type</code><br> <code>ver_type</code>标志了数据报的类型，这个类似于压缩了后的TCP报头中的flags字段，节约了一些空间，并且更加直观。包含下面的5种。</p>
 <figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    ST_DATA = <span class="number">0</span>,        <span class="comment">// Data packet.</span></span><br><span class="line">    ST_FIN = <span class="number">1</span>,         <span class="comment">// Finalize the connection. This is the last packet.</span></span><br><span class="line">    ST_STATE = <span class="number">2</span>,       <span class="comment">// State packet. Used to transmit an ACK with no data.</span></span><br><span class="line">    ST_RESET = <span class="number">3</span>,       <span class="comment">// Terminate connection forcefully.</span></span><br><span class="line">    ST_SYN = <span class="number">4</span>,         <span class="comment">// Connect SYN</span></span><br><span class="line">    ST_NUM_STATES,      // used for bounds checking</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 这里<code>ST_STATE</code>即一个不带数据的探查包，因此并不会增加<code>seq_nr</code>。</p>
</li>
<li><p><code>ext</code><br> 这个表示扩展号，默认是0，设为1时表示使用了EACK的扩展，对应着扩展后的<code>PacketFormatAckV1</code>类型的数据包。</p>
</li>
<li><p><code>connid</code><br> <code>connid</code>的用途已在前面的<code>utp_context</code>进行了论述。</p>
</li>
<li><p><code>tv_usec</code><br> <code>tv_usec</code>是一个时间戳，表示数据包的发送时间，在<code>send_data</code>中被设置。我们看到相比TCP则保守地用了TCP Timestamps Option这个选项，UTP中强制将其整合了进来。其实时间戳的作用是非常大的，例如借助于时间戳可以更精确地计算出RTT。否则我们只能对非重传的数据包进行采样。时间戳还能方便我们对高带宽下序号迅速耗尽进行PAWS(Protect Againest Wrapped Sequence numbers)防范，不过我检查下代码发现UTP里面并没有PAWS的机制（详见后面收包的部分）。</p>
</li>
<li><p><code>reply_micro</code><br> <code>reply_micro</code>在<code>utp_process_incoming</code>中被设置，当A发送数据包给B时，B提取收到数据包中的<code>tv_usec</code>字段并和自己的本地时间作差，得到更新的<code>reply_micro</code>。这个值会随着下一个数据包被传送给对端（<code>send_data</code>函数）。</p>
</li>
</ol>
<p>这里再提一下<code>PACKED_ATTRIBUTE</code>这个属性，在<strong>utp_internal.cpp</strong>中已经使用了<code>#pragma pack</code>，这里是为了双重保险。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utp_internal.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (defined(__SVR4) &amp;&amp; defined(__sun))</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> pack(push,1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// utp_types.h</span></span><br><span class="line"><span class="comment">// Allow libutp consumers or prerequisites to override PACKED_ATTRIBUTE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PACKED_ATTRIBUTE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined BROKEN_GCC_STRUCTURE_PACKING &amp;&amp; defined __GNUC__</span></span><br><span class="line">    <span class="comment">// Used for gcc tool chains accepting but not supporting pragma pack</span></span><br><span class="line">    <span class="comment">// See http://gcc.gnu.org/onlinedocs/gcc/Type-Attributes.html</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PACKED_ATTRIBUTE __attribute__((__packed__))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> PACKED_ATTRIBUTE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// defined BROKEN_GCC_STRUCTURE_PACKING &amp;&amp; defined __GNUC__</span></span></span><br></pre></td></tr></table></figure>

<p><code>PacketFormatAckV1</code>这个包表示当这个包是EACK包时的附加数据，EACK包是类似于SACK的一种机制，用于选择性确认。在<code>UTPSocket::send_ack</code>函数中能看到EACK将<code>acr_nr</code>前最多32个报文的接受情况按位放到长度为4的字节数组里面，这是一个非常巧妙的方法。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct PACKED_ATTRIBUTE PacketFormatAckV1 &#123;</span><br><span class="line">    PacketFormatV1 pf<span class="comment">;</span></span><br><span class="line">    <span class="keyword">byte </span><span class="keyword">ext_next;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">byte </span><span class="keyword">ext_len;</span></span><br><span class="line"><span class="keyword"> </span>   <span class="keyword">byte </span>acks[<span class="number">4</span>]<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<h2 id="SizableCircularBuffer"><a href="#SizableCircularBuffer" class="headerlink" title="SizableCircularBuffer"></a>SizableCircularBuffer</h2><p>这是一个环形缓冲区，值得注意的是这个缓冲区并不是线程安全的，不过libutp的接口不是线程安全的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SizableCircularBuffer</span> &#123;</span></span><br><span class="line">    <span class="comment">// This is the mask. Since it's always a power of 2, adding 1 to this value will return the size.</span></span><br><span class="line">    <span class="keyword">size_t</span> mask;</span><br><span class="line">    <span class="comment">// This is the elements that the circular buffer points to</span></span><br><span class="line">    <span class="keyword">void</span> **elements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> *<span class="title">get</span><span class="params">(<span class="keyword">size_t</span> i)</span> <span class="keyword">const</span> </span>&#123; assert(elements); <span class="keyword">return</span> elements ? elements[i &amp; mask] : <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">size_t</span> i, <span class="keyword">void</span> *data)</span> </span>&#123; assert(elements); elements[i&amp;mask] = data; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">size_t</span> item, <span class="keyword">size_t</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">// Figure out the new size.</span></span><br><span class="line">        <span class="keyword">size_t</span> size = mask + <span class="number">1</span>; <span class="keyword">do</span> size *= <span class="number">2</span>; <span class="keyword">while</span> (index &gt;= size);</span><br><span class="line">        <span class="comment">// Allocate the new buffer</span></span><br><span class="line">        <span class="keyword">void</span> **buf = (<span class="keyword">void</span>**)<span class="built_in">calloc</span>(size, <span class="keyword">sizeof</span>(<span class="keyword">void</span>*));</span><br><span class="line">        size--;</span><br><span class="line">        <span class="comment">// Copy elements from the old buffer to the new buffer</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt;= mask; i++) &#123;</span><br><span class="line">            buf[(item - index + i) &amp; size] = get(item - index + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Swap to the newly allocated buffer</span></span><br><span class="line">        mask = size; <span class="built_in">free</span>(elements); elements = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ensure_size</span><span class="params">(<span class="keyword">size_t</span> item, <span class="keyword">size_t</span> index)</span> </span>&#123; <span class="keyword">if</span> (index &gt; mask) grow(item, index); &#125;</span><br><span class="line">    <span class="keyword">size_t</span> size() &#123; <span class="keyword">return</span> mask + <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>环形缓冲区的大小<code>size</code>始终是2的整数幂，这里的<code>mask</code>等于<code>size - 1</code>，因此全部为1。<code>mask</code>起到类似取模的作用。<br>这里的<code>ensure_size</code>和<code>grow</code>的参数有点奇怪，其实查看调用情况可以发现<code>item</code>表示要插入的元素的编号，如<code>seq_nr</code>；而<code>index</code>表示当前队列中元素的个数，如<code>cur_window_packets</code>，这样队列就不会出现假溢出的现象。如果说队列中元素比容量<code>size = mask + 1</code>要多了，那么就要扩展队列。由于扩展队列变了模数，不同余了，所以要按照模前的数<code>(item - index + i)</code>进行复制。</p>
<h2 id="环形缓冲区的增长"><a href="#环形缓冲区的增长" class="headerlink" title="环形缓冲区的增长"></a>环形缓冲区的增长</h2><p><code>grow</code>需要提供<code>item</code>和<code>index</code>，两个变量可以分别理解为缓冲区中最旧的序号和最新的序号，其中<code>item - index</code>表示最老的未确认的<code>ATPPacket</code>的序号。<br>对于缓冲区中的序号$seq$，有$seq , mod , m1 = x$，当mask从$m1$增长到$m2$时，需要求出在$seq$未知的情况下求出$seq , mod , m2 = y$。<br>其实有个简单的开销较大的办法，就是用一个<code>std::pair</code>把原始的序号计算出来。</p>
<h1 id="套接字的连接关闭与读写操作"><a href="#套接字的连接关闭与读写操作" class="headerlink" title="套接字的连接关闭与读写操作"></a>套接字的连接关闭与读写操作</h1><h2 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h2><p><code>utp_create_socket</code>用来创建一个套接字，在创建套接字时并不向context进行注册，这也是因为目前已有信息无法计算出哈希值的缘故。<br><code>state = CS_UNINITIALIZED</code></p>
<h2 id="定位套接字"><a href="#定位套接字" class="headerlink" title="定位套接字"></a>定位套接字</h2><p>在uTP中，当我们收到一个UDP数据包时会调用<code>utp_process_udp</code>函数通告context，context会根据端口和报头来定位到具体套接字。</p>
<h2 id="主动连接"><a href="#主动连接" class="headerlink" title="主动连接"></a>主动连接</h2><p>实现在函数<code>utp_connect</code>内。</p>
<ol>
<li>首先调用<code>utp_initialize_socket</code><br> <code>utp_initialize_socket</code>的作用初始化套接字，这里的操作包括设置dest端的地址/端口，初始化<code>conn_id_recv</code>和<code>conn_id_send</code>，初始化套接字的部分字段。向context注册自己。<br> 在初始化之后，套接字具有状态<code>state = CS_IDLE</code></li>
<li>然后调用<code>UTPSocket::send_packet</code><br> 这个函数详见下面</li>
</ol>
<h2 id="被动连接"><a href="#被动连接" class="headerlink" title="被动连接"></a>被动连接</h2><p>uTP对被动连接的处理在<code>utp_process_udp</code>函数中。首先context会判断是否接受连接，条件如下：</p>
<ol>
<li>是否设置了<code>UTP_ON_ACCEPT</code>回调</li>
<li>是否已存在该连接</li>
<li>context中保持的连接数是否已超过3000<br> 可以看出，uTP对连接的限制还是比较放松的，在TCP协议中还会对在连接队列中（三次握手尚未完成）的套接口有限制，即<code>listen</code>的<code>backlog</code>参数。事实上协议实现会分别维护连接中的队列<code>so_q0</code>和已连接的队列<code>so_q</code>，并保持一个<code>so_head</code>指向accept套接字指针。</li>
<li>来自防火墙回调<code>utp_call_on_firewall</code>的反馈</li>
</ol>
<h2 id="发包操作"><a href="#发包操作" class="headerlink" title="发包操作"></a>发包操作</h2><p><code>UTPSocket::send_packet</code>是主要的发包函数</p>
<ol>
<li><code>UTPSocket::send_packet</code>、<code>UTPSocket::send_ack</code>、<code>send_rst</code><br> <code>send_packet</code>函数用来发送构造好的<code>OutgoingPacket::data</code>。<br> <code>send_ack</code>会就地构造一个ACK包，然后调用<code>send_data</code>发送。<br> <code>send_rst</code>直接调用更基础的<code>send_to_addr</code>发送RST包。</li>
<li><code>UTPSocket::send_data</code><br> 这个函数的存在主要是处理一些<code>UTPSocket::send_packet</code>和<code>UTPSocket::send_ack</code>的共同部分</li>
<li><code>send_to_addr</code><br> 这个函数位于调用链的最下端，调用了注册的callback函数来发送数据包，同时调用<code>utp_register_sent_packet</code>像<code>utp_context::context_stats</code>报告了发送长度用来统计。这个统计信息可以被API函数<code>utp_get_context_stats</code>取得，以供用户分析。</li>
</ol>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><h3 id="utp-write"><a href="#utp-write" class="headerlink" title="utp_write"></a>utp_write</h3><p><code>utp_write</code>被作为<code>utp_writev</code>的一个特例来处理。</p>
<h3 id="utp-writev"><a href="#utp-writev" class="headerlink" title="utp_writev"></a>utp_writev</h3><p>同UNIX套接口函数<code>writev</code>一样，<code>utp_writev</code>接受一个指向<code>iovec</code>数组的指针<code>iovec_input</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *iov_base;</span><br><span class="line">    <span class="keyword">size_t</span> iov_len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>utp_writev</code>按照<code>iovec_input[0 .. num_iovecs-1]</code>的顺序从缓冲区发送数据，并返回成功发送的总字节数。<br><code>utp_writev</code>主要做一些检查，如<code>num_iovecs</code>是否超过了<code>UTP_IOV_MAX</code>。然后将<code>iovec_input</code>复制到自己的一块缓存<code>iovec</code>里面（为啥呢），计算所有<code>iovec</code>的大小的总和到<code>bytes</code>。我们实际发送的数据量<code>num_to_send</code>为<code>bytes</code>和连接最多允许的数据包大小<code>packet_size</code>（由MTU决定）两者的最小值。当<code>bytes</code>过大时，就需要分批发送，如下面的代码所示。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">size_t packet_size = conn-&gt;get_packet_size()<span class="comment">;</span></span><br><span class="line">size_t num_to_send = min&lt;size_t&gt;(<span class="keyword">bytes, </span>packet_size)<span class="comment">;</span></span><br><span class="line">while (!conn-&gt;is_full(num_to_send)) &#123;</span><br><span class="line">    <span class="keyword">bytes </span>-= num_to_send<span class="comment">;</span></span><br><span class="line">    sent  += num_to_send<span class="comment">;</span></span><br><span class="line">    conn-&gt;write_outgoing_packet(num_to_send, ST_DATA, iovec, num_iovecs)<span class="comment">;</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>is_full</code>由窗口决定。<br><code>utp_writev</code>下面会调用<code>write_outgoing_packet(size_t payload, uint flags, struct utp_iovec *iovec, size_t num_iovecs)</code>。我们知道<code>OutgoingPacket</code>用来描述一个数据包的上下文，在第一次握手时由于没有数据需要传输，所以直接调用的<code>utp_send_packet</code>，相当于只发送了一个包头。而对于<code>utp_writev</code>来说，需要在包头后面加上数据。<br>下面的代码将每个<code>iov[i]</code>中的<code>iov_base</code>复制到。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; num_iovecs &amp;&amp; needed; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iovec[i].iov_len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">    size_t <span class="built_in">num</span> = min&lt;size_t&gt;(needed, iovec[i].iov_len);</span><br><span class="line">    memcpy(p, iovec[i].iov_base, <span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">    p += <span class="built_in">num</span>;</span><br><span class="line"></span><br><span class="line">    iovec[i].iov_len -= <span class="built_in">num</span>;</span><br><span class="line">    iovec[i].iov_base = (byte*)iovec[i].iov_base + <span class="built_in">num</span>; <span class="comment">// iovec[i].iov_base += num, but without void* pointers</span></span><br><span class="line">    needed -= <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="write-outgoing-packet"><a href="#write-outgoing-packet" class="headerlink" title="write_outgoing_packet"></a>write_outgoing_packet</h3><p><code>write_outgoing_packet</code>接受一个<code>utp_iovec</code>数组，然后组织数据包结构，并将其放入发送缓存。注意<code>write_outgoing_packet</code>函数并不会直接调用<code>send_packet</code>发送数据包。<br><code>write_outgoing_packet</code>主要是一个大循环</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    payload -= added;</span><br><span class="line">&#125; <span class="keyword">while</span> <span class="comment">(payload)</span>;</span><br><span class="line">flush_packets<span class="comment">()</span>;</span><br></pre></td></tr></table></figure>

<p>首先<code>write_outgoing_packet</code>在发送缓冲区中取出前一个<code>seq_nr - 1</code>序号的<code>pkt</code>，试图重用它。注意到如果窗口小于等于0，那么实际的<code>pkt</code>就是<code>NULL</code>，这是为了保证当窗口小于等于0时，不会再往当前的<code>pkt</code>里面放东西了，否则<code>pkt</code>的容量超过窗口导致被缓存。相反的，我们重新开一个包放超出窗口的数据，这样只有这个新开的包会被缓存。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(cur_window_packets &gt; 0)</span> &#123;</span><br><span class="line">    pkt = <span class="comment">(OutgoingPacket*)</span>outbuf.get<span class="comment">(seq_nr - 1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码的上半部分，当数据包<code>pkt</code>尚未满载，并且尚未发送时，在本次循环中会重新使用它，在它的后面续上<code>added</code>长度的空间，供添加数据使用。<code>sizeof(OutgoingPacket) - 1</code>是减去VLA的一个字节。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if there's any room left in the last packet in the window</span></span><br><span class="line"><span class="comment">// and it hasn't been sent yet, fill that frame first</span></span><br><span class="line"><span class="function"><span class="title">if</span> (payload &amp;&amp; pkt &amp;&amp; !pkt-&gt;</span><span class="function"><span class="title">transmissions</span> &amp;&amp; pkt-&gt;</span>payload &lt; packet_size) &#123;</span><br><span class="line">    <span class="comment">// Use the previous unsent packet</span></span><br><span class="line">    <span class="function"><span class="title">added</span> = min(payload + pkt-&gt;</span><span class="function"><span class="title">payload</span>, max&lt;size_t&gt;(packet_size, pkt-&gt;</span><span class="function"><span class="title">payload</span>)) - pkt-&gt;</span>payload;</span><br><span class="line">    <span class="function"><span class="title">pkt</span> = (OutgoingPacket*)realloc(pkt, (sizeof(OutgoingPacket) - 1) + header_size + pkt-&gt;</span>payload + added);</span><br><span class="line">    outbuf.put(seq_nr - <span class="number">1</span>, pkt);</span><br><span class="line">    append = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="title">assert</span>(!pkt-&gt;</span>need_resend);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Create the packet to send.</span></span><br><span class="line">    added = payload;</span><br><span class="line">    pkt = (OutgoingPacket*)malloc((sizeof(OutgoingPacket) - <span class="number">1</span>) + header_size + added);</span><br><span class="line">    <span class="function"><span class="title">pkt</span>-&gt;</span>payload = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">pkt</span>-&gt;</span>transmissions = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="title">pkt</span>-&gt;</span>need_resend = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码紧接着上面，为<code>pkt</code>添加<code>added</code>长度的数据</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (added) &#123;</span><br><span class="line">    <span class="keyword">assert</span>(flags == ST_DATA);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fill it with data from the upper layer.</span></span><br><span class="line">    unsigned char *p = pkt-&gt;data + header_size + pkt-&gt;payload;</span><br><span class="line">    size_t needed = added;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; num_iovecs &amp;&amp; needed; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iovec[i].iov_len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        size_t <span class="built_in">num</span> = min&lt;size_t&gt;(needed, iovec[i].iov_len);</span><br><span class="line">        memcpy(p, iovec[i].iov_base, <span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">        p += <span class="built_in">num</span>;</span><br><span class="line"></span><br><span class="line">        iovec[i].iov_len -= <span class="built_in">num</span>;</span><br><span class="line">        iovec[i].iov_base = (byte*)iovec[i].iov_base + <span class="built_in">num</span>; <span class="comment">// iovec[i].iov_base += num, but without void* pointers</span></span><br><span class="line">        needed -= <span class="built_in">num</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">assert</span>(needed == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>append</code>表示是否是一个需要被加入缓冲区的新数据包，在上面的<code>if</code>块中被设置</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (append) &#123;</span><br><span class="line">    <span class="comment">// Remember the message in the outgoing queue.</span></span><br><span class="line">    outbuf.ensure_size(seq_nr, cur_window_packets);</span><br><span class="line">    outbuf.put(seq_nr, pkt);</span><br><span class="line">    <span class="function"><span class="title">p1</span>-&gt;</span>seq_nr = seq_nr;</span><br><span class="line">    seq_nr++;</span><br><span class="line">    cur_window_packets++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来<code>write_outgoing_packet</code>调用<code>flush_packets</code>来刷新缓冲区</p>
<h3 id="flush-packets"><a href="#flush-packets" class="headerlink" title="flush_packets"></a>flush_packets</h3><p><code>flush_packets</code>函数在发包时和重传计时器超时时被调用。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> UTPSocket::flush_packets()</span><br><span class="line">&#123;</span><br><span class="line">    size_t packet_size = get_packet_size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send packets that are waiting on the pacer to be sent</span></span><br><span class="line">    <span class="comment">// i has to be an unsigned 16 bit counter to wrap correctly</span></span><br><span class="line">    <span class="comment">// signed types are not guaranteed to wrap the way you expect</span></span><br><span class="line">    <span class="keyword">for</span> (uint16 i = seq_nr - cur_window_packets; i != seq_nr; ++i) &#123;</span><br><span class="line">        OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(i);</span><br><span class="line">        <span class="keyword">if</span> (pkt == <span class="number">0</span> || (pkt-&gt;transmissions &gt; <span class="number">0</span> &amp;&amp; pkt-&gt;need_resend == <span class="literal">false</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// have we run out of quota?</span></span><br><span class="line">        <span class="keyword">if</span> (is_full()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Nagle check</span></span><br><span class="line">        <span class="comment">// don't send the last packet if we have one packet in-flight</span></span><br><span class="line">        <span class="comment">// and the current packet is still smaller than packet_size.</span></span><br><span class="line">        <span class="keyword">if</span> (i != ((seq_nr - <span class="number">1</span>) &amp; ACK_NR_MASK) ||</span><br><span class="line">            cur_window_packets == <span class="number">1</span> ||</span><br><span class="line">            pkt-&gt;payload &gt;= packet_size) &#123;</span><br><span class="line">            send_packet(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>在<strong>ucat.c</strong>中，当context收到UDP包之后会交给对应socket的<code>udp_process_incoming</code>函数进行处理，这个函数中涉及和uTP实现可靠传输有关的很多内容，因此与之相关的内容将放在下面的章节中进行讨论，本节主要讨论uTP处理出数据并返回上层的相关内容。<br>首先我们看到<code>udp_process_incoming</code>调用了<code>utp_register_recv_packet</code>，这是一个统计用的函数，我们可以不做考虑。</p>
<h2 id="主动关闭"><a href="#主动关闭" class="headerlink" title="主动关闭"></a>主动关闭</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void utp_close(UTPSocket *conn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(conn-&gt;state) &#123;</span><br><span class="line">    <span class="keyword">case</span> CS_CONNECTED:</span><br><span class="line">    <span class="keyword">case</span> CS_CONNECTED_FULL:</span><br><span class="line">        conn-&gt;state = CS_FIN_SENT;</span><br><span class="line">        conn-&gt;write_outgoing_packet(<span class="number">0</span>, ST_FIN, <span class="keyword">NULL</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> CS_SYN_SENT:</span><br><span class="line">        conn-&gt;rto_timeout = utp_call_get_milliseconds(conn-&gt;ctx, conn) + min&lt;<span class="keyword">uint</span>&gt;(conn-&gt;rto * <span class="number">2</span>, <span class="number">60</span>);</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">case</span> CS_GOT_FIN:</span><br><span class="line">        conn-&gt;state = CS_DESTROY_DELAY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CS_SYN_RECV:</span><br><span class="line">        <span class="comment">// fall through</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        conn-&gt;state = CS_DESTROY;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="超时重传与可靠传输"><a href="#超时重传与可靠传输" class="headerlink" title="超时重传与可靠传输"></a>超时重传与可靠传输</h1><p>引起发送方超时重传的原因有大致三种：</p>
<ol>
<li>分组丢失。这里指报文并没有顺利到达接收方，因此需要发送发进行重传。</li>
<li>确认丢失。这里报文顺利传送到接收方，但接收方返回的ACK报文丢失了。这种情况下发送方很可能会在超时之后重新发送该分组，而接收方应该选择丢弃并重新确认。</li>
<li>经受延迟。这里报文和ACK都顺利传送，但整个过程耗时超过了Timeout，这时发送方也会进行重传。</li>
</ol>
<p>对于发送出去的每个数据包设置一个定时器，等定时器超时之后触发回调进行重传是开销很大的。实际上可以维护一个超时重传计时器，当对方有数据包过来时就重置这个计时器，否则当计时器超时时，就重传发送队列中的所有数据包。</p>
<h2 id="发送ACK"><a href="#发送ACK" class="headerlink" title="发送ACK"></a>发送ACK</h2><p>当对方封包过来时，需要根据其序号更新自己的确认号，并进行相关处理，如发送ACK、处理乱序包等。这是一个复杂的流程，本部分介绍如何向对方发送一个ACK。而在此之前的例如接受封包，更新自己的<code>ack_nr</code>则在下面的数据包接收（确认部分）进行介绍。</p>
<h3 id="延迟确认"><a href="#延迟确认" class="headerlink" title="延迟确认"></a>延迟确认</h3><p>uTP使用了schedule_ack的机制来实现<a href="/2017/12/05/tcp-window/">Delayed ACK</a>特性。首先使用<code>UTPSocket::schedule_ack</code>向context注册socket自己，表示请不要立即发送一个空的ACK包，而是尝试将ACK放到带用户数据的包里面。当计时器超时时，<code>utp_issue_deferred_acks</code>函数会被调用（在<strong>ucat.c</strong>里面）。这个函数调用<code>ack_sockets</code>里面所有注册了的socket的<code>send_ack()</code>方法，发送ACK包。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span> (size_t i = 0; i &lt; ctx-&gt;</span>ack_sockets.GetCount(); i++) &#123;</span><br><span class="line">    UTPS<span class="function"><span class="title">ocket</span> *conn = ctx-&gt;</span>ack_sockets[i];</span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span>send_ack();</span><br><span class="line">    i--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当新的ACK能够随着带用户数据的包一同发送时，就能免于发送一个空ACK包的开销。这时候会调用<code>removeSocketFromAckList</code>函数将这个socket从<code>ack_sockets</code>列表中删除。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void removeSocketFromAckList(UTPSocket *conn)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span> (conn-&gt;</span>ida &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        UTPS<span class="function"><span class="title">ocket</span> *last = conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">ack_sockets</span>[conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>ack_sockets.GetCount() - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">assert</span>(last-&gt;</span><span class="function"><span class="title">ida</span> &lt; (int)(conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>ack_sockets.GetCount()));</span><br><span class="line">        <span class="function"><span class="title">assert</span>(conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">ack_sockets</span>[last-&gt;</span>ida] == last);</span><br><span class="line">        <span class="function"><span class="title">last</span>-&gt;</span><span class="function"><span class="title">ida</span> = conn-&gt;</span>ida;</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">ack_sockets</span>[conn-&gt;</span>ida] = last;</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span>ida = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Decrease the count</span></span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">ack_sockets</span>.SetCount(conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span>ack_sockets.GetCount() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数会将需要移除的指针和队尾指针互换，并弹出队尾。<br>需要注意的是延迟确认存在很多特殊情况：</p>
<ol>
<li>保活心跳包立即发送</li>
<li>SYN和FIN等关键包立即发送</li>
<li>当窗口变为0立即发送，因为窗口为0表示一段时间内不能向对方发送数据了</li>
</ol>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>从具体实现上看，libutp在<code>void UTPSocket::ack_packet(uint16 seq)</code>函数里面处理对方发过来的ACK，在<code>void UTPSocket::send_ack(bool synack)</code>里面向对方发送自己对对方的ACK。<br><code>ack_packet</code>函数有3个返回值，返回0表示正常ACK，返回1表示这个包已经被ACK过了，返回2表示这个包还没有被发送。</p>
<h2 id="数据包接收（确认部分）"><a href="#数据包接收（确认部分）" class="headerlink" title="数据包接收（确认部分）"></a>数据包接收（确认部分）</h2><p>TCP协议中使用的是后退N重传(Go-Back-N)协议，即从第一个未确认的包开始全部传送。TCP用ACK号表示<strong>小于</strong>ACK号的所有字节都已经被接受到。例如A发送了1/2/3/4四个数据包，如果截止到A的RTO超时，B只接受到了1/3，那么它只能ACK到1。这时候A就必须重传2/3/4三个数据包，但其实3是可以不重传的。此时在传输过程中发生了乱序，这里数据包3号早于数据包2号到达了。<br>uTP使用<code>reorder_count</code>记录数据包乱序抵达的情况。我们查看在<code>utp_process_incoming</code>中有关处理对方序号的部分</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seqnr is the number of packets past the expected packet this is. ack_nr is the last acked, seq_nr is the current. Subtracring 1 makes 0 mean "this is the next expected packet".</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint</span> seqnr = (pk_seq_nr - conn-&gt;ack_nr - <span class="number">1</span>) &amp; SEQ_NR_MASK;</span><br></pre></td></tr></table></figure>

<p>这里的<code>pk_seq_nr</code>指的是数据包包头中的<code>seq_nr</code>字段，而<code>conn-&gt;ack_nr</code>表示我们最后确认的序号，因此<code>seqnr</code>为0时表示这个包是序号紧接着的数据包。注意这个是能够正确处理溢出的情况的。<br>接下来跳过若干行，在<code>utp_process_incoming</code>函数的最后，对当前的数据包进行确认工作，并调用<code>utp_call_on_read</code>回调。查看代码，这里对<code>seqnr</code>是否为0，也就是是否为乱序包展开了讨论，首先查看不是乱序包的情况，我们直接在代码中进行注释</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (seqnr == <span class="number">0</span>) &#123;</span><br><span class="line">    size_t count = packet_end - <span class="keyword">data</span>;</span><br><span class="line">    <span class="function"><span class="title">if</span> (count &gt; 0 &amp;&amp; conn-&gt;</span>state != CS_FIN_SENT) &#123;</span><br><span class="line">        <span class="comment">// Post bytes to the upper layer</span></span><br><span class="line">        <span class="function"><span class="title">utp_call_on_read</span>(conn-&gt;</span>ctx, conn, <span class="keyword">data</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span>ack_nr++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the next packet has been received too, but waiting in the reorder buffer.</span></span><br><span class="line">    <span class="comment">// 这里检查是否可以释放缓存着的乱序包，例如seqnr==1的包可能已经到达，但由于当前seqnr==0的包还未到达，所以无法确认，只能缓存着</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">if</span> (conn-&gt;</span><span class="function"><span class="title">got_fin</span> &amp;&amp; conn-&gt;</span><span class="function"><span class="title">eof_pkt</span> == conn-&gt;</span>ack_nr) &#123;</span><br><span class="line">            <span class="function"><span class="title">if</span> (conn-&gt;</span>state != CS_FIN_SENT) &#123;</span><br><span class="line">                <span class="function"><span class="title">conn</span>-&gt;</span>state = CS_GOT_FIN;</span><br><span class="line">                <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">rto_timeout</span> = conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">current_ms</span> + min&lt;uint&gt;(conn-&gt;</span>rto * <span class="number">3</span>, <span class="number">60</span>);</span><br><span class="line">                <span class="function"><span class="title">utp_call_on_state_change</span>(conn-&gt;</span>ctx, conn, UTP_STATE_EOF);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if the other end wants to close, ack</span></span><br><span class="line">            <span class="function"><span class="title">conn</span>-&gt;</span>send_ack();</span><br><span class="line">            <span class="comment">// reorder_count is not necessarily 0 at this point. even though it is most of the time, the other end may have sent packets with higher sequence numbers than what later end up being eof_pkt since we have received all packets up to eof_pkt just ignore the ones after it.</span></span><br><span class="line">            <span class="function"><span class="title">conn</span>-&gt;</span>reorder_count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当已经没有乱序包了，就直接退出循环。这里和后面的assert联动</span></span><br><span class="line">        <span class="comment">// Quick get-out in case there is nothing to reorder</span></span><br><span class="line">        <span class="function"><span class="title">if</span> (conn-&gt;</span>reorder_count == <span class="number">0</span>)</span><br><span class="line">            break;</span><br><span class="line">        <span class="comment">// Check if there are additional buffers in the reorder buffers</span></span><br><span class="line">        <span class="comment">// that need delivery.</span></span><br><span class="line">        <span class="function"><span class="title">byte</span> *p = (byte*)conn-&gt;</span><span class="function"><span class="title">inbuf</span>.get(conn-&gt;</span>ack_nr+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (p == NULL)</span><br><span class="line">            break;</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">inbuf</span>.put(conn-&gt;</span>ack_nr+<span class="number">1</span>, NULL);</span><br><span class="line">        count = *(uint*)p;</span><br><span class="line">        <span class="function"><span class="title">if</span> (count &gt; 0 &amp;&amp; conn-&gt;</span>state != CS_FIN_SENT) &#123;</span><br><span class="line">            <span class="comment">// Pass the bytes to the upper layer</span></span><br><span class="line">            <span class="function"><span class="title">utp_call_on_read</span>(conn-&gt;</span>ctx, conn, p + sizeof(uint), count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span>ack_nr++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Free the element from the reorder buffer</span></span><br><span class="line">        free(p);</span><br><span class="line">        <span class="function"><span class="title">assert</span>(conn-&gt;</span>reorder_count &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span>reorder_count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向context注册一个延迟确认</span></span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span>schedule_ack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面查看是乱序包的情况</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if we have received a FIN packet, and the EOF-sequence number is lower than the sequence number of the packet we just received something is wrong.</span></span><br><span class="line"><span class="function"><span class="title">if</span> (conn-&gt;</span><span class="function"><span class="title">got_fin</span> &amp;&amp; pk_seq_nr &gt; conn-&gt;</span>eof_pkt) &#123;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这里接受到一个序号距离ack_nr偏移非常严重的包，选择直接丢弃。注意到这里实际上也处理了一个序号在pk_seq_nr前的包的情况</span></span><br><span class="line"><span class="comment">// if the sequence number is entirely off the expected one, just drop it. We can't allocate buffer space in the inbuf entirely based on untrusted input</span></span><br><span class="line"><span class="keyword">if</span> (seqnr &gt; <span class="number">0</span>x3ff) &#123;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// we need to grow the circle buffer before we check if the packet is already in here, so that  we don't end up looking at an older packet (since the indices wraps around).</span></span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span>inbuf.ensure_size(pk_seq_nr + <span class="number">1</span>, seqnr + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个提前抵达的包同样可能已经被处理过</span></span><br><span class="line"><span class="comment">// Has this packet already been received? (i.e. a duplicate)  If that is the case, just discard it.</span></span><br><span class="line"><span class="function"><span class="title">if</span> (conn-&gt;</span>inbuf.get(pk_seq_nr) != NULL) &#123;</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allocate memory to fit the packet that needs to re-ordered</span></span><br><span class="line">byte *mem = (byte*)malloc((packet_end - <span class="keyword">data</span>) + sizeof(uint));</span><br><span class="line">*(uint*)mem = (uint)(packet_end - <span class="keyword">data</span>);</span><br><span class="line">memcpy(mem + sizeof(uint), <span class="keyword">data</span>, packet_end - <span class="keyword">data</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Insert into reorder buffer and increment the count of # of packets to be reordered. we add one to seqnr in order to leave the last entry empty, that way the assert in send_ack is valid. we have to add one to seqnr too, in order to make the circular buffer grow around the correct point (which is conn-&gt;ack_nr + 1).</span></span><br><span class="line"><span class="function"><span class="title">assert</span>(conn-&gt;</span>inbuf.get(pk_seq_nr) == NULL);</span><br><span class="line"><span class="function"><span class="title">assert</span>((pk_seq_nr &amp; conn-&gt;</span><span class="function"><span class="title">inbuf</span>.mask) != ((conn-&gt;</span><span class="function"><span class="title">ack_nr</span>+1) &amp; conn-&gt;</span>inbuf.mask));</span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span>inbuf.put(pk_seq_nr, mem);</span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span>reorder_count++;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> UTP_DEBUG_LOGGING</span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span><span class="built_in">log</span>(UTP_LOG_DEBUG, <span class="string">"0x%08x: Got out of order data reorder_count:%u len:%u (rb:%u)"</span>,</span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">reorder_count</span>, (uint)(packet_end - <span class="keyword">data</span>), (uint)utp_call_get_read_buffer_size(conn-&gt;</span>ctx, conn));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向context注册一个延迟确认</span></span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span>schedule_ack();</span><br></pre></td></tr></table></figure>

<h2 id="RTT与RTO的计算"><a href="#RTT与RTO的计算" class="headerlink" title="RTT与RTO的计算"></a>RTT与RTO的计算</h2><p>RTT(Round-Trip Time)即往返时间。受到链路的传播时间、终端系统的处理时间、路由器缓存与处理时间的影响。如果我们使用发送时间戳TS和收到ACK的时间戳TR来计算$RTT = TR - TS$，那么这个值是偏大的，因为它包含了链路中的来回时间，但是也包含了对端在收到数据包之后到发送ACK包之间的包括缓存、处理的时间（称为ack delay）。因此一个较好的RTT计算方式应该是$RTT = TR - TS - ACKDELAY$<br>RTO(Retransmission TimeOut)，超时重传时间，与RTT有关。RFC793中使用低通过滤器对RTT进行平滑，然后再乘上一个因子$\beta$得到初次重传RTO。此外在往返时间变化起伏较大是，还要根据均值和方差计算RTO。RTO随着重传次数是按照指数增长的，即第二次超时则重传时间变为2倍的RTO。在新的RFC2988/6298中又更新了相关的算法，在此不详述。</p>
<p>uTP中RTT和初始RTO的计算实现在<code>ack_packet</code>函数里面。<code>ack_packet</code>是作用在发送队列上的，当数据包没有被重传的时候，使用当前时间减去它的发送时间来计算出<code>ertt</code>，然后计算出<code>rtt</code>和<code>rto</code>。而<code>rto_timeout</code>指的是超时的时刻，初始化时有<code>rto_timeout = ctx-&gt;current_ms + retransmit_timeout</code>。当<code>ctx-&gt;current_ms - rto_timeout</code>时则超时条件触发。下面是<code>ack_packet</code>中具体的代码。注意我们只对没有重传的包计算RTT，这是因为如果数据包经历了重传，并且我们收到了来自对端的ACK，我们无法知道这个ACK是对原始包还是被重传包的响应。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们只对没有重传的包计算RTT</span></span><br><span class="line"><span class="keyword">if</span> (pkt-&gt;transmissions == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// Estimate the round trip time.</span></span><br><span class="line">    <span class="keyword">const</span> uint32 ertt = (uint32)((utp_call_get_microseconds(this-&gt;ctx, this) - pkt-&gt;time_sent) / <span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">if</span> (rtt == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// First round trip time sample</span></span><br><span class="line">        rtt = ertt;</span><br><span class="line">        rtt_var = ertt / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// sanity check. rtt should never be more than 6 seconds</span></span><br><span class="line"><span class="comment">//          assert(rtt &lt; 6000);</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Compute new round trip times</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> delta = (<span class="keyword">int</span>)rtt - ertt;</span><br><span class="line">        rtt_var = rtt_var + (<span class="keyword">int</span>)(abs(delta) - rtt_var) / <span class="number">4</span>;</span><br><span class="line">        rtt = rtt - rtt/<span class="number">8</span> + ertt/<span class="number">8</span>;</span><br><span class="line">        <span class="comment">// sanity check. rtt should never be more than 6 seconds</span></span><br><span class="line"><span class="comment">//          assert(rtt &lt; 6000);</span></span><br><span class="line">        rtt_hist.add_sample(ertt, ctx-&gt;current_ms);</span><br><span class="line">    &#125;</span><br><span class="line">    rto = max&lt;<span class="keyword">uint</span>&gt;(rtt + rtt_var * <span class="number">4</span>, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">retransmit_timeout = rto;</span><br><span class="line">rto_timeout = ctx-&gt;current_ms + rto;</span><br></pre></td></tr></table></figure>

<h3 id="QUIC的解决方案"><a href="#QUIC的解决方案" class="headerlink" title="QUIC的解决方案"></a>QUIC的解决方案</h3><p>QUIC协议的一个非常不同的地方在于它虽然也是按照Packet编号的，称为Packet Number。但是它的编号是严格递增的。这么做也是为了解决TCP中存在的重传歧义问题，但显而易见我们无法维护有序性了，因此对于承载的流数据，QUIC提供了stream offset来维护其顺序和可靠性。</p>
<h2 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h2><p>TCP的实现超时重传一般是设置一个超时重传定时器<code>icsk-&gt;icsk_retransmit_timer</code>，通过<code>inet_csk_init_xmit_timers</code>来注册。常用的超时方式有使用alarm信号、使用select、设置<code>SO_RCVTIMEO</code>和<code>SO_SNDTIMEO</code>字段、使用Linux提供的定时器（<code>setitimer</code>等）。但是在uTP的实现里面我并没有发现使用上面定时器的痕迹，这个定时器在哪里呢？我们首先找到uTP的超时重传实现，在<code>void UTPSocket::check_timeouts</code>函数里，而这个函数只被<code>utp_check_timeouts</code>调用。<code>utp_check_timeouts</code>是作为uTP的API函数，在应用程序<strong>ucat.c</strong>中，每次<code>network_loop</code>中的<code>poll</code>函数超时时，<code>utp_check_timeouts</code>就被调用。其实libutp框架更类似于一个个中断处理程序，而不是一个服务，它需要来自外部的信号才能驱动。<br>下面我们来查看<code>UTPSocket::check_timeouts</code>这个方法。这个方法中出发了对坚持定时器<code>zerowindow_time</code>、重传定时器<code>rto_timeout</code>、保活定时器<code>last_sent_packet</code>和时间等待定时器<code>rto_timeout</code>（这里复用了）。<br>首先查看最基本的重传定时器</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> CS_SYN_SENT:</span><br><span class="line"><span class="keyword">case</span> CS_SYN_RECV:</span><br><span class="line"><span class="keyword">case</span> CS_CONNECTED_FULL:</span><br><span class="line"><span class="keyword">case</span> CS_CONNECTED:</span><br><span class="line"><span class="keyword">case</span> CS_FIN_SENT: &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)(ctx-&gt;current_ms - rto_timeout) &gt;= <span class="number">0</span> &amp;&amp; rto_timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里删去了处理mtu探测的部分内容，移到专门的章节</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里删除了一段被注释了的重传次数大于4就重新计算rtt的策略</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Increase RTO</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">uint</span> new_timeout = ignore_loss ? retransmit_timeout : retransmit_timeout * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里防范恶意连接的情况，当第三次握手超时时就直接关闭连接</span></span><br><span class="line">        <span class="keyword">if</span> (state == CS_SYN_RECV) &#123;</span><br><span class="line">            state = CS_DESTROY;</span><br><span class="line">            utp_call_on_error(ctx, this, UTP_ETIMEDOUT);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里删去了处理连接超时的部分内容，移到专门章节</span></span><br><span class="line"></span><br><span class="line">        retransmit_timeout = new_timeout;</span><br><span class="line">        rto_timeout = ctx-&gt;current_ms + new_timeout;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!ignore_loss) &#123;</span><br><span class="line">            <span class="comment">// 此时连接超时，ignore_loss只有当执行mtu探测任务时才为true</span></span><br><span class="line">            duplicate_ack = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> packet_size = get_packet_size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((cur_window_packets == <span class="number">0</span>) &amp;&amp; ((<span class="keyword">int</span>)max_window &gt; packet_size)) &#123;</span><br><span class="line">                <span class="comment">// 这时连接处于闲置状态，并不急切需要重置拥塞窗口</span></span><br><span class="line">                max_window = max(max_window * <span class="number">2</span> / <span class="number">3</span>, size_t(packet_size));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 此时延迟非常大，因此将拥塞窗口缩小到1个数据包，并开始慢启动算法</span></span><br><span class="line">                max_window = packet_size;</span><br><span class="line">                slow_start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这个时候使用后退N协议全部重传</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_window_packets; ++i) &#123;</span><br><span class="line">            OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(seq_nr - i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (pkt == <span class="number">0</span> || pkt-&gt;transmissions == <span class="number">0</span> || pkt-&gt;need_resend) <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// uTP使用`need_resend`来描述一个包是否需要被重传。</span></span><br><span class="line">            pkt-&gt;need_resend = <span class="keyword">true</span>;</span><br><span class="line">            assert(cur_window &gt;= pkt-&gt;payload);</span><br><span class="line">            cur_window -= pkt-&gt;payload;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur_window_packets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retransmit_count++;</span><br><span class="line">            fast_timeout = <span class="keyword">true</span>;</span><br><span class="line">            timeout_seq_nr = seq_nr;</span><br><span class="line"></span><br><span class="line">            OutgoingPacket *pkt = (OutgoingPacket*)outbuf.get(seq_nr - cur_window_packets);</span><br><span class="line">            assert(pkt);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Re-send the packet.</span></span><br><span class="line">            send_packet(pkt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mark the socket as writable. If the cwnd has grown, or if the number of</span></span><br><span class="line">    <span class="comment">// bytes in-flight is lower than cwnd, we need to make the socket writable again</span></span><br><span class="line">    <span class="comment">// in case it isn't</span></span><br><span class="line">    <span class="keyword">if</span> (state == CS_CONNECTED_FULL &amp;&amp; !is_full()) &#123;</span><br><span class="line">        state = CS_CONNECTED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#if UTP_DEBUG_LOGGING</span></span><br><span class="line">        log(UTP_LOG_DEBUG, <span class="string">"Socket writable. max_window:%u cur_window:%u packet_size:%u"</span>,</span><br><span class="line">            (<span class="keyword">uint</span>)max_window, (<span class="keyword">uint</span>)cur_window, (<span class="keyword">uint</span>)get_packet_size());</span><br><span class="line">        <span class="comment">#endif</span></span><br><span class="line">        utp_call_on_state_change(this-&gt;ctx, this, UTP_STATE_WRITABLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state &gt;= CS_CONNECTED &amp;&amp; state &lt; CS_GOT_FIN) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">int</span>)(ctx-&gt;current_ms - last_sent_packet) &gt;= KEEPALIVE_INTERVAL) &#123;</span><br><span class="line">            send_keep_alive();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>注意这里对于一个socket而不是一个数据包维护一个<code>retransmit_count</code>。<br>下面查看时间等待定时器，这里并不需要等2MSL的时间，而是3*RTO和60之间的较小值。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check_timeouts</span></span><br><span class="line">case CS_GOT_FIN:</span><br><span class="line">case CS_DESTROY_DELAY:</span><br><span class="line">    <span class="function"><span class="title">if</span> ((int)(ctx-&gt;</span>current_ms - rto_timeout) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        state = (state == CS_DESTROY_DELAY) ? CS_DESTROY : CS_RESET;</span><br><span class="line">        <span class="keyword">if</span> (cur_window_packets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            utp_call_on_error(ctx, this, UTP_ECONNRESET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// utp_process_incoming</span></span><br><span class="line"><span class="function"><span class="title">if</span> (conn-&gt;</span>state != CS_FIN_SENT) &#123;</span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span>state = CS_GOT_FIN;</span><br><span class="line">    <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">rto_timeout</span> = conn-&gt;</span><span class="function"><span class="title">ctx</span>-&gt;</span><span class="function"><span class="title">current_ms</span> + min&lt;uint&gt;(conn-&gt;</span>rto * <span class="number">3</span>, <span class="number">60</span>);</span><br><span class="line">    <span class="function"><span class="title">utp_call_on_state_change</span>(conn-&gt;</span>ctx, conn, UTP_STATE_EOF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fast-retransmit"><a href="#Fast-retransmit" class="headerlink" title="Fast retransmit"></a>Fast retransmit</h2><p>Fast retransmit虽然也是超时重传行为，但实际上是拥塞避免算法中的一部分。因此将在拥塞控制部分论述。</p>
<h2 id="Selective-Acknowledgment"><a href="#Selective-Acknowledgment" class="headerlink" title="Selective Acknowledgment"></a>Selective Acknowledgment</h2><p>在TCP协议中使用SACK选项进行选择确认，使用若干组<code>[start, end)</code>来表示已经接受到数据的区间。SACK能够有效减少重传数据包的数量，对于带宽紧张的网络十分有用。不过需要注意恶意使用SACK对CPU资源造成的损害。<br>在先前的数据包头构造部分已经提到了UTP的EACK机制，这是一个非常巧妙的方案，即用一个32位的比特串来表示从<code>ack_nr + 2</code>开始的32个未确认的包中有哪些是已经收到了在缓存里的，这里不从<code>ack_nr + 1</code>开始是因为我们可以默认这个包丢了，不然的话<code>ack_nr</code>就至少会到<code>ack_nr + 1</code>的值了。有关SACK的代码在<code>UTPSocket::send_ack</code>方法里面。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">if (reorder_count != <span class="number">0</span> &amp;&amp; <span class="section">state</span> &lt; CS_GOT_FIN) &#123;</span><br><span class="line">    <span class="comment">// if reorder count &gt; 0, send an EACK. reorder count should always be 0 for synacks, so this should not be as synack</span></span><br><span class="line">    assert(!synack);</span><br><span class="line">    pfa.pf.ext = <span class="number">1</span>;</span><br><span class="line">    pfa.ext_next = <span class="number">0</span>;</span><br><span class="line">    pfa.ext_len = <span class="number">4</span>;</span><br><span class="line">    uint m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reorder count should only be non-zero if the packet ack_nr + 1 has not yet been received</span></span><br><span class="line">    assert(inbuf.get(ack_nr + <span class="number">1</span>) == NULL);</span><br><span class="line">    size_t window = min&lt;size_t&gt;(<span class="number">14</span>+<span class="number">16</span>, inbuf.size());</span><br><span class="line">    <span class="comment">// Generate bit mask of segments received.</span></span><br><span class="line">    for (size_t i = <span class="number">0</span>; i &lt; window; i++) &#123;</span><br><span class="line">        if (inbuf.get(ack_nr + i + <span class="number">2</span>) != NULL) &#123;</span><br><span class="line">            m |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pfa.acks[<span class="number">0</span>] = (byte)m;</span><br><span class="line">    pfa.acks[<span class="number">1</span>] = (byte)(m &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    pfa.acks[<span class="number">2</span>] = (byte)(m &gt;&gt; <span class="number">16</span>);</span><br><span class="line">    pfa.acks[<span class="number">3</span>] = (byte)(m &gt;&gt; <span class="number">24</span>);</span><br><span class="line">    len += <span class="number">4</span> + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们看到条件是<code>reorder_count != 0 &amp;&amp; state &lt; CS_GOT_FIN</code>，这表明在非连接建立/关闭时，当出现数据包乱序抵达时，启动EACK机制。<br>ESAK是不允许Reneging的，</p>
<h1 id="连接的异常终止"><a href="#连接的异常终止" class="headerlink" title="连接的异常终止"></a>连接的异常终止</h1><h2 id="重传失败"><a href="#重传失败" class="headerlink" title="重传失败"></a>重传失败</h2><p>在Linux中使用<code>tcp_retries1 = 3</code>和<code>tcp_retries2 = 15</code>（计算得到的一个时间戳）来限定普通包的重传次数。<br>特别地，在握手时设有专门的<code>tcp_syn_retries</code>，这是由于对于连接建立时的重传需要精心设计以防止可能的SYN Flood攻击。<br>在UTP中的重传失败机制比较简单。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (retransmit_count &gt;= <span class="number">4</span> || (<span class="keyword">state</span> == CS_SYN_SENT &amp;&amp; retransmit_count &gt;= <span class="number">2</span>)) &#123;</span><br><span class="line">    // <span class="number">4</span> consecutive transmissions have timed <span class="keyword">out</span>. Kill it. If we</span><br><span class="line">    // haven't even connected yet, give up after only <span class="number">2</span> consecutive</span><br><span class="line">    // failed transmissions.</span><br><span class="line">    if (<span class="keyword">state</span> == CS_FIN_SENT)</span><br><span class="line">        <span class="keyword">state</span> = CS_DESTROY;</span><br><span class="line">    else</span><br><span class="line">        <span class="keyword">state</span> = CS_RESET;</span><br><span class="line">    utp_call_on_error(ctx, this, UTP_ETIMEDOUT);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="连接重置"><a href="#连接重置" class="headerlink" title="连接重置"></a>连接重置</h2><h2 id="保活定时器"><a href="#保活定时器" class="headerlink" title="保活定时器"></a>保活定时器</h2><p>从TCP对长连接的管理上来讲，服务器通常会对其的对端启用保活定时器，以避免在对端意外崩溃下连接的浪费。我们看到TCP是非常珍惜服务器端的连接资源的，这还体现在TCP往往鼓励客户端主动关闭，从而让客户端而不是服务端等待2MSL。TCP规定当给定的连接在两个小时之内无任何动作，则服务器向对端发送探测包。根据客户端的状态会分为四种情况：1. 当客户端和网络都正常时，那么服务器能够得到正常响应，于是复位保活定时器。2. 当客户主机崩溃（关闭或重启中）时，客户端没有响应，服务器会等待10次75秒的超时，直到关闭连接。3. 当客户主机从崩溃中恢复后，服务器将受到来自客户端的RESET。4. 当客户端正常运行，但网络异常，类似网络分区状况，这种情况类似2。<br>在libutp中设定了一个<code>KEEPALIVE_INTERVAL 29000</code>的阈值，表示29秒后会启动保活探测，它同时指出这个阈值来自对很多家庭NAT设备的计量。保活探测很简单，就是发送一个重复的ACK。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UTPSocket::send_keep_alive()</span><br><span class="line">&#123;</span><br><span class="line">    ack_nr--;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> UTP_DEBUG_LOGGING</span></span><br><span class="line">    <span class="built_in">log</span>(UTP_LOG_DEBUG, <span class="string">"Sending KeepAlive ACK %u [%u]"</span>, ack_nr, conn_id_send);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    send_ack();</span><br><span class="line">    ack_nr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="流量控制和拥塞控制"><a href="#流量控制和拥塞控制" class="headerlink" title="流量控制和拥塞控制"></a>流量控制和拥塞控制</h1><h2 id="TCP的流量控制以及拥塞控制算法"><a href="#TCP的流量控制以及拥塞控制算法" class="headerlink" title="TCP的流量控制以及拥塞控制算法"></a>TCP的流量控制以及拥塞控制算法</h2><p><a href="/2017/12/05/tcp-window/">被迁移到这一篇文章中</a></p>
<h2 id="uTP拥塞控制概述"><a href="#uTP拥塞控制概述" class="headerlink" title="uTP拥塞控制概述"></a>uTP拥塞控制概述</h2><p>uTP拥塞控制选择了丢包率和单向缓冲时延(one way buffer delay)进行度量。我们注意到在链路中存在一些设备能够缓存几秒钟内通过的数据，但uTP希望实现0字节的发送缓存。在实践中uTP的目标延迟在100ms，即当套接字侦测到自己发送数据包经受了100ms以上的延迟时，它就会调整拥塞窗口。下面我们查看相关逻辑的实现。<br>在uTP报文头部我们可以看到<code>tv_usec</code>和<code>reply_micro</code>，通过这两个值uTP可以维护一个两分钟内的最小延迟值<code>delay_base</code>，我们将它作为两个服务器之间的延迟的基线，如果我们的实际延迟超过基线100ms，那么就认为网络发生了拥塞。<code>delay_base</code>在<code>DelayHist::add_sample</code>中更新，<code>DelayHist</code>使用数组<code>cur_delay_hist</code>维护所有delay值相对于<code>delay_base</code>的偏移。我们将在下面的时间测量部分继续讨论<code>DelayHist</code>的相关实现。<br>在<code>UTPSocket::apply_ccontrol</code>中，首先取<code>our_delay</code>用<code>DelayHist::get_value()</code>获得的所有<code>cur_delay_hist</code>的最小值，注意由于没有样本时返回<code>UINT_MAX</code>，所以此时<code>our_delay</code>取RTT。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DelayHist::get_value()</span></span><br><span class="line">uint<span class="number">32</span> get<span class="number">_</span><span class="keyword">value</span>()</span><br><span class="line">&#123;</span><br><span class="line">    uint<span class="number">32</span> <span class="keyword">value</span> = UINT<span class="number">_M</span>AX;</span><br><span class="line">    <span class="keyword">for</span> (size<span class="number">_</span>t i = <span class="number">0</span>; i &lt; CUR<span class="number">_</span>DELAY<span class="number">_</span>SIZE; i++) &#123;</span><br><span class="line">        <span class="keyword">value</span> = min&lt;uint<span class="number">32</span>&gt;(cur<span class="number">_</span>delay<span class="number">_</span>hist[i], <span class="keyword">value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// value could be UINT_MAX if we have no samples yet...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在套接字中定义一个<code>target_delay</code>默认为100000微秒即100毫秒，我们希望每个套接字发送端的延时不超过100ms。</p>
<h2 id="uTP的窗口"><a href="#uTP的窗口" class="headerlink" title="uTP的窗口"></a>uTP的窗口</h2><p>libutp定义了一些有关窗口的变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the number of packets in the send queue. Packets that haven't</span></span><br><span class="line"><span class="comment">// yet been sent count as well as packets marked as needing resend</span></span><br><span class="line"><span class="comment">// the oldest un-acked packet in the send queue is seq_nr - cur_window_packets</span></span><br><span class="line">uint16 cur_window_packets;</span><br><span class="line"></span><br><span class="line"><span class="comment">// how much of the window is used, number of bytes in-flight</span></span><br><span class="line"><span class="comment">// packets that have not yet been sent do not count, packets</span></span><br><span class="line"><span class="comment">// that are marked as needing to be re-sent (due to a timeout)</span></span><br><span class="line"><span class="comment">// don't count either</span></span><br><span class="line"><span class="keyword">size_t</span> cur_window;</span><br><span class="line"><span class="comment">// maximum window size, in bytes</span></span><br><span class="line"><span class="keyword">size_t</span> max_window;</span><br><span class="line"></span><br><span class="line"><span class="comment">// max receive window for other end, in bytes</span></span><br><span class="line"><span class="keyword">size_t</span> max_window_user;</span><br></pre></td></tr></table></figure>

<p>其中<code>cur_window_packets</code>表示数据包的窗口，包含所有在发送队列的数据包，无论是否已经被发送，或者是否需要重传。因此最旧的未被对方确认的序号是<code>seq_nr - cur_window_packets</code>。UTP对<code>cur_window_packets</code>的限制是一定要小于<code>OUTGOING_BUFFER_MAX_SIZE</code><br><code>cur_window</code>就是按字节算的通常意义上的窗口，在计算时不包含需要重传的包。<code>max_window</code>表示最大的窗口，它和<code>max_window_user</code>不同的是<code>max_window</code>还包含了拥塞窗口，而<code>max_window_user</code>来自对方，表示对方缓冲区的大小。<br>下面的<code>is_full</code>判断从<code>cur_window_packets</code>和<code>cur_window</code>角度窗口是否饱和。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">bool UTPSocket<span class="type">::is_full</span>(int <span class="built_in">bytes</span>)</span><br><span class="line">&#123;</span><br><span class="line">    size_t packet_size = get_packet_size();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bytes</span> &lt; <span class="number">0</span>) <span class="built_in">bytes</span> = packet_size;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">bytes</span> &gt; (int)packet_size) <span class="built_in">bytes</span> = (int)packet_size;</span><br><span class="line">    size_t max_send = <span class="keyword">min</span>(max_window, opt_sndbuf, max_window_user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// subtract one to save space for the FIN packet</span></span><br><span class="line">    <span class="keyword">if</span> (cur_window_packets &gt;= OUTGOING_BUFFER_MAX_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        last_maxed_out_window = ctx-&gt;current_ms;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur_window + <span class="built_in">bytes</span> &gt; max_send) &#123;</span><br><span class="line">        last_maxed_out_window = ctx-&gt;current_ms;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Fast-retransmit-1"><a href="#Fast-retransmit-1" class="headerlink" title="Fast retransmit"></a>Fast retransmit</h2><p>当发送方连续收到3次相同的ACK，那么就重传可能被丢了的包。这里为什么是至少收到3次而不是2次是因为丢包情况下发送方<a href="https://www.zhihu.com/question/21789252" target="_blank" rel="noopener">至少会收到三次重复的ACK</a>。从实现上看，有的快速重传选择只重传最初被丢的包，有的选择重传所有被丢的包。uTP使用<code>duplicate_ack</code>来记录收到重复ACK的次数。在<code>utp_process_incoming</code>函数中对<code>duplicate_ack</code>进行更新</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span> (conn-&gt;</span>cur_window_packets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 当ack_nr等于最后被对方确认的序号时，这里`conn-&gt;seq_nr - conn-&gt;cur_window_packets`等于第一个没被对方确认的包</span></span><br><span class="line">    <span class="function"><span class="title">if</span> (pk_ack_nr == ((conn-&gt;</span><span class="function"><span class="title">seq_nr</span> - conn-&gt;</span>cur_window_packets - <span class="number">1</span>) &amp; ACK_NR_MASK)</span><br><span class="line">        <span class="comment">// 这里作者强调了当数据包带上了用户数据后，就不应该算入重复ACK中，这和BSD4.4 TCP实现是一致的</span></span><br><span class="line">        &amp;&amp; pk_flags == ST_STATE) &#123;</span><br><span class="line">        ++<span class="function"><span class="title">conn</span>-&gt;</span>duplicate_ack;</span><br><span class="line">        <span class="function"><span class="title">if</span> (conn-&gt;</span><span class="function"><span class="title">duplicate_ack</span> == DUPLICATE_ACKS_BEFORE_RESEND &amp;&amp; conn-&gt;</span>mtu_probe_seq) &#123;</span><br><span class="line">            <span class="comment">// It's likely that the probe was rejected due to its size, but we haven't got an ICMP report back yet</span></span><br><span class="line">            <span class="function"><span class="title">if</span> (pk_ack_nr == ((conn-&gt;</span>mtu_probe_seq - <span class="number">1</span>) &amp; ACK_NR_MASK)) &#123;</span><br><span class="line">                <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">mtu_ceiling</span> = conn-&gt;</span>mtu_probe_size - <span class="number">1</span>;</span><br><span class="line">                <span class="function"><span class="title">conn</span>-&gt;</span>mtu_search_update();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// A non-probe was blocked before our probe. Can't conclude much, send a new probe</span></span><br><span class="line">                <span class="function"><span class="title">conn</span>-&gt;</span><span class="function"><span class="title">mtu_probe_seq</span> = conn-&gt;</span>mtu_probe_size = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="function"><span class="title">conn</span>-&gt;</span>duplicate_ack = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> if duplicate_ack == DUPLICATE_ACK_BEFORE_RESEND and fast_resend_seq_nr &lt;= ack_nr + 1, resend ack_nr + 1 also call maybe_decay_win()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="报文分段"><a href="#报文分段" class="headerlink" title="报文分段"></a>报文分段</h1><p>MTU(Maximum Transmission Unit)，最大传输单元。通常地，以太网的MTU是1500，而IP是65535（包括头部），Internet的标准MTU是576。所以对于较大的IP包，如果在以太网上传输就需要进行分片。而TCP协议提供了MSS选项用来在建立连接时写上MSS大小，也就是TCP的最大的分段大小，超过这个MSS的数据就需要进行分段传输。MSS的协商在前两次的SYN握手时处理。<br>而UDP是不带有分片功能的，所以对于较大的数据包是采用IP进行分片的。这其中带来一些问题，IP分片后只有第一个分片带有UDP头部，因此只要有一个IP数据报传输失败，那么整个UDP报文就无法交付（校验和和长度都通不过）。而IP协议本身并没有重传功能，且分片可能发生在链路上的任一路由器上，实际上根本无法知道原数据包是怎么被分片的。因此如果在UDP上层的实现要求重传（UDP本身不带重传），必须整个UDP数据报全部重传。所以说我们重新考虑UDP协议就会发现它头部的2字节的长度显得很不必要，因为根本不会发这么长的数据报。事实上按照TCP的按字节编码省掉一个长度字段也是方便的。因此我们基于UDP实现的传输层协议首先要做的就是避免IP层为我们分片，这样就能保证每个IP数据报中都要带有UDP头和我们的协议头，是个完整的传输层协议包。这就意味着我们需要让我们的基于UDP的协议的<code>MSS + HEAD + UDP_HEAD + IP_HEAD</code>小于可能的链路层的MTU。</p>
<h2 id="MTU探测"><a href="#MTU探测" class="headerlink" title="MTU探测"></a>MTU探测</h2><p>UTP通过截取ICMP Type3 Code4(fragmentation needed)来获得分片情况，即在IP首部设置了不可分片标志，但如果UDP报文达到MTU上限则会丢弃该IP报，返回ICMP不可达差错。UTP通过这个机制使用二分法来找到一个合适的MTU。<br>在<code>UTPSocket::mtu_reset</code>函数中，预置了MTU搜寻空间为<code>[576, udp_mtu]</code>，也就是default IP maximum datagem size。不过由于以太网的流行，所以将576作为下限，此时对应于TCP的MSS为536。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> UTPSocket::mtu_reset()</span><br><span class="line">&#123;</span><br><span class="line">    mtu_ceiling = get_udp_mtu();</span><br><span class="line">    mtu_floor = <span class="number">576</span>;</span><br><span class="line">    mtu_discover_time = utp_call_get_milliseconds(<span class="keyword">this</span>-&gt;ctx, <span class="keyword">this</span>) + <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="时间测量"><a href="#时间测量" class="headerlink" title="时间测量"></a>时间测量</h1><p>本章将详细讨论在前面拥塞控制等章节遇到的各类延迟的计算。</p>
<h2 id="延迟测量"><a href="#延迟测量" class="headerlink" title="延迟测量"></a>延迟测量</h2><p>在数据报报头的<code>tv_usec</code>和<code>reply_micro</code>两个字段用来测量延迟。<br>发送端S设置<code>tv_usec</code>表示发送时间S1</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send_data</span></span><br><span class="line">uint64 <span class="built_in">time</span> = utp_call_get_microseconds(ctx, this);</span><br><span class="line"><span class="function"><span class="title">b1</span>-&gt;</span>tv_usec = (uint32)<span class="built_in">time</span>;</span><br></pre></td></tr></table></figure>

<p>接收端R计算<code>reply_micro</code>表示接受时间R1与发送时间S1的差，粗略地估计了从S到R的经历的时间。注意由于两个主机的时钟不一定一致，所以这个值不精确。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utp_process_incoming</span></span><br><span class="line"><span class="function"><span class="title">uint64</span> p = pf1-&gt;</span>tv_usec;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get delay in both directions</span></span><br><span class="line"><span class="comment">// record the delay to report back</span></span><br><span class="line">const uint32 their_delay = (uint32)(p == <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">time</span> - p);</span><br><span class="line"><span class="function"><span class="title">conn</span>-&gt;</span>reply_micro = their_delay;</span><br></pre></td></tr></table></figure>

<p>为了消除误差，UTP借助了NTP授时协议的机制。这里需要假设S与R之间的网络状况是对等的（这是一个很强的假设），即从S到R的速度不至于显著慢或快于从R到S的速度。这时候从R往S端发送一个回复的数据包，记录下这次的发送时间R2和接收时间S2。可以计算得到仅由网络原因造成的延时为$(S2 - S1) - (R2 - R1)$，还能得到S和R两个主机之间的时间差是$\frac{(R1 - S1) + (R2 - S2)}{2}$。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// send_data</span></span><br><span class="line"><span class="function"><span class="title">b1</span>-&gt;</span>reply_micro = reply_micro;</span><br></pre></td></tr></table></figure>

<h2 id="DelayHist类型"><a href="#DelayHist类型" class="headerlink" title="DelayHist类型"></a>DelayHist类型</h2><p><code>DelayHist</code>记录了时间的延迟，具有以下的方法</p>
<ol>
<li><code>shift</code><br> 用来将所有的<code>delay_base_hist</code>向右偏移一段时间长度</li>
</ol>
<h2 id="clock-drift问题"><a href="#clock-drift问题" class="headerlink" title="clock drift问题"></a>clock drift问题</h2><p>由于UTP被用来实现一些BT下载软件，这个机制是UTP用来防止用户故意调慢时钟从而霸占带宽设计的，并且不会产生误报(False positive)。</p>
<h1 id="uTP数据包统计"><a href="#uTP数据包统计" class="headerlink" title="uTP数据包统计"></a>uTP数据包统计</h1><p>在<code>utp_context_stats</code>和<code>utp_context_stats</code>中进行context和socket级别的统计。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returned by utp_get_context_stats()</span></span><br><span class="line">typedef <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">uint32</span> _nraw_recv[<span class="number">5</span>];   <span class="comment">// total packets recieved less than 300/600/1200/MTU bytes fpr all connections (context-wide)</span></span><br><span class="line">    <span class="keyword">uint32</span> _nraw_send[<span class="number">5</span>];   <span class="comment">// total packets sent     less than 300/600/1200/MTU bytes for all connections (context-wide)</span></span><br><span class="line">&#125; utp_context_stats;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returned by utp_get_stats()</span></span><br><span class="line">typedef <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">uint64</span> nbytes_recv; <span class="comment">// total bytes received</span></span><br><span class="line">    <span class="keyword">uint64</span> nbytes_xmit; <span class="comment">// total bytes transmitted</span></span><br><span class="line">    <span class="keyword">uint32</span> rexmit;      <span class="comment">// retransmit counter</span></span><br><span class="line">    <span class="keyword">uint32</span> fastrexmit;  <span class="comment">// fast retransmit counter</span></span><br><span class="line">    <span class="keyword">uint32</span> nxmit;       <span class="comment">// transmit counter</span></span><br><span class="line">    <span class="keyword">uint32</span> nrecv;       <span class="comment">// receive counter (total)</span></span><br><span class="line">    <span class="keyword">uint32</span> nduprecv;    <span class="comment">// duplicate receive counter</span></span><br><span class="line">    <span class="keyword">uint32</span> mtu_guess;   <span class="comment">// Best guess at MTU</span></span><br><span class="line">&#125; utp_socket_stats;</span><br></pre></td></tr></table></figure>

<p>此外在<code>utp_context</code>中也维护了<code>rst_info</code>等信息。</p>
<h1 id="序号溢出问题"><a href="#序号溢出问题" class="headerlink" title="序号溢出问题"></a>序号溢出问题</h1><p>TCP中使用了32位的序号，并且具有PAWS机制防止在大带宽的情况下序号被迅速耗尽后产生回绕。如前文所展示的，在uTP的实现中利用了无符号整数的溢出来避免回绕时序号变为0的问题。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">compare</span> <span class="keyword">if</span> <span class="built_in">lhs</span> <span class="built_in">is</span> less than <span class="built_in">rhs</span>, taking wrapping</span><br><span class="line">// into account. <span class="keyword">if</span> <span class="built_in">lhs</span> <span class="built_in">is</span> <span class="built_in">close</span> to UINT_MAX <span class="keyword">and</span> <span class="built_in">rhs</span></span><br><span class="line">// <span class="built_in">is</span> <span class="built_in">close</span> to <span class="number">0</span>, <span class="built_in">lhs</span> <span class="built_in">is</span> assumed to have wrapped <span class="keyword">and</span></span><br><span class="line">// considered smaller</span><br><span class="line">bool wrapping_compare_less(uint32 <span class="built_in">lhs</span>, uint32 <span class="built_in">rhs</span>, uint32 mask)</span><br><span class="line">&#123;</span><br><span class="line">    // distance walking from <span class="built_in">lhs</span> to <span class="built_in">rhs</span>, downwards</span><br><span class="line">    const uint32 dist_down = (<span class="built_in">lhs</span> - <span class="built_in">rhs</span>) &amp; mask;</span><br><span class="line">    // distance walking from <span class="built_in">lhs</span> to <span class="built_in">rhs</span>, upwards</span><br><span class="line">    const uint32 dist_up = (<span class="built_in">rhs</span> - <span class="built_in">lhs</span>) &amp; mask;</span><br><span class="line"></span><br><span class="line">    // <span class="keyword">if</span> the distance walking up <span class="built_in">is</span> shorter, <span class="built_in">lhs</span></span><br><span class="line">    // <span class="built_in">is</span> less than <span class="built_in">rhs</span>. If the distance walking down</span><br><span class="line">    // <span class="built_in">is</span> shorter, <span class="keyword">then</span> <span class="built_in">rhs</span> <span class="built_in">is</span> less than <span class="built_in">lhs</span></span><br><span class="line">    <span class="built_in">return</span> dist_up &lt; dist_down;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/网络/" rel="tag"># 网络</a>
          
            <a href="/tags/UDP/" rel="tag"># UDP</a>
          
            <a href="/tags/libutp/" rel="tag"># libutp</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/05/tcp-window/" rel="next" title="TCP的流量控制和拥塞控制">
                <i class="fa fa-chevron-left"></i> TCP的流量控制和拥塞控制
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/28/Concurrency-Programming-Compare/" rel="prev" title="并发编程重要概念及比较">
                并发编程重要概念及比较 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">175</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">162</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#uTP源码简介"><span class="nav-number">1.</span> <span class="nav-text">uTP源码简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ucat简介"><span class="nav-number">2.</span> <span class="nav-text">ucat简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uTP重要数据结构"><span class="nav-number">3.</span> <span class="nav-text">uTP重要数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#utp-context"><span class="nav-number">3.1.</span> <span class="nav-text">utp_context</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#utp-context的成员"><span class="nav-number">3.1.1.</span> <span class="nav-text">utp_context的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#utp-context的用途"><span class="nav-number">3.1.2.</span> <span class="nav-text">utp_context的用途</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#utp-socket"><span class="nav-number">3.2.</span> <span class="nav-text">utp_socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OutgoingPacket"><span class="nav-number">3.3.</span> <span class="nav-text">OutgoingPacket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PacketFormatV1-PacketFormatAckV1"><span class="nav-number">3.4.</span> <span class="nav-text">PacketFormatV1/PacketFormatAckV1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SizableCircularBuffer"><span class="nav-number">3.5.</span> <span class="nav-text">SizableCircularBuffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环形缓冲区的增长"><span class="nav-number">3.6.</span> <span class="nav-text">环形缓冲区的增长</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#套接字的连接关闭与读写操作"><span class="nav-number">4.</span> <span class="nav-text">套接字的连接关闭与读写操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#创建套接字"><span class="nav-number">4.1.</span> <span class="nav-text">创建套接字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定位套接字"><span class="nav-number">4.2.</span> <span class="nav-text">定位套接字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主动连接"><span class="nav-number">4.3.</span> <span class="nav-text">主动连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#被动连接"><span class="nav-number">4.4.</span> <span class="nav-text">被动连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#发包操作"><span class="nav-number">4.5.</span> <span class="nav-text">发包操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写操作"><span class="nav-number">4.6.</span> <span class="nav-text">写操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#utp-write"><span class="nav-number">4.6.1.</span> <span class="nav-text">utp_write</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#utp-writev"><span class="nav-number">4.6.2.</span> <span class="nav-text">utp_writev</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#write-outgoing-packet"><span class="nav-number">4.6.3.</span> <span class="nav-text">write_outgoing_packet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flush-packets"><span class="nav-number">4.6.4.</span> <span class="nav-text">flush_packets</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读操作"><span class="nav-number">4.7.</span> <span class="nav-text">读操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主动关闭"><span class="nav-number">4.8.</span> <span class="nav-text">主动关闭</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#超时重传与可靠传输"><span class="nav-number">5.</span> <span class="nav-text">超时重传与可靠传输</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#发送ACK"><span class="nav-number">5.1.</span> <span class="nav-text">发送ACK</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟确认"><span class="nav-number">5.1.1.</span> <span class="nav-text">延迟确认</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#具体实现"><span class="nav-number">5.1.2.</span> <span class="nav-text">具体实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据包接收（确认部分）"><span class="nav-number">5.2.</span> <span class="nav-text">数据包接收（确认部分）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTT与RTO的计算"><span class="nav-number">5.3.</span> <span class="nav-text">RTT与RTO的计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#QUIC的解决方案"><span class="nav-number">5.3.1.</span> <span class="nav-text">QUIC的解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#超时重传"><span class="nav-number">5.4.</span> <span class="nav-text">超时重传</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fast-retransmit"><span class="nav-number">5.5.</span> <span class="nav-text">Fast retransmit</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selective-Acknowledgment"><span class="nav-number">5.6.</span> <span class="nav-text">Selective Acknowledgment</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#连接的异常终止"><span class="nav-number">6.</span> <span class="nav-text">连接的异常终止</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重传失败"><span class="nav-number">6.1.</span> <span class="nav-text">重传失败</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接重置"><span class="nav-number">6.2.</span> <span class="nav-text">连接重置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保活定时器"><span class="nav-number">6.3.</span> <span class="nav-text">保活定时器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#流量控制和拥塞控制"><span class="nav-number">7.</span> <span class="nav-text">流量控制和拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP的流量控制以及拥塞控制算法"><span class="nav-number">7.1.</span> <span class="nav-text">TCP的流量控制以及拥塞控制算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uTP拥塞控制概述"><span class="nav-number">7.2.</span> <span class="nav-text">uTP拥塞控制概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uTP的窗口"><span class="nav-number">7.3.</span> <span class="nav-text">uTP的窗口</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fast-retransmit-1"><span class="nav-number">7.4.</span> <span class="nav-text">Fast retransmit</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#报文分段"><span class="nav-number">8.</span> <span class="nav-text">报文分段</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#MTU探测"><span class="nav-number">8.1.</span> <span class="nav-text">MTU探测</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#时间测量"><span class="nav-number">9.</span> <span class="nav-text">时间测量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#延迟测量"><span class="nav-number">9.1.</span> <span class="nav-text">延迟测量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DelayHist类型"><span class="nav-number">9.2.</span> <span class="nav-text">DelayHist类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clock-drift问题"><span class="nav-number">9.3.</span> <span class="nav-text">clock drift问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#uTP数据包统计"><span class="nav-number">10.</span> <span class="nav-text">uTP数据包统计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#序号溢出问题"><span class="nav-number">11.</span> <span class="nav-text">序号溢出问题</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2017/12/05/libutp源码简析/';
          this.page.identifier = '2017/12/05/libutp源码简析/';
          this.page.title = 'libutp源码简析';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
