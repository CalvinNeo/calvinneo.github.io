<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C++,fortran,编译原理,编译器," />





  <link rel="alternate" href="/atom.xml" title="Calvin's Marbles" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++14的工具，其中涉及到使用C++为Fortran实现一个数组库。总的来讲，Fortran90的有些语言特性在编写和编译上都让人不是很舒服。比如没有头文件和前置声明，这导致了许多额外的代码和解析工作，比如INTERFACE块因此而生（但其实也是一个比较好的解决方案，和前置声明也差不多）。又比如Fortr">
<meta name="keywords" content="C++,fortran,编译原理,编译器">
<meta property="og:type" content="article">
<meta property="og:title" content="Fortran数组的C++实现">
<meta property="og:url" content="http://www.calvinneo.com/2017/01/18/Fortran数组的C++实现/index.html">
<meta property="og:site_name" content="Calvin&#39;s Marbles">
<meta property="og:description" content="最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++14的工具，其中涉及到使用C++为Fortran实现一个数组库。总的来讲，Fortran90的有些语言特性在编写和编译上都让人不是很舒服。比如没有头文件和前置声明，这导致了许多额外的代码和解析工作，比如INTERFACE块因此而生（但其实也是一个比较好的解决方案，和前置声明也差不多）。又比如Fortr">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2023-05-21T05:08:07.224Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fortran数组的C++实现">
<meta name="twitter:description" content="最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++14的工具，其中涉及到使用C++为Fortran实现一个数组库。总的来讲，Fortran90的有些语言特性在编写和编译上都让人不是很舒服。比如没有头文件和前置声明，这导致了许多额外的代码和解析工作，比如INTERFACE块因此而生（但其实也是一个比较好的解决方案，和前置声明也差不多）。又比如Fortr">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.calvinneo.com/2017/01/18/Fortran数组的C++实现/"/>





  <title>Fortran数组的C++实现 | Calvin's Marbles</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Calvin's Marbles</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://www.calvinneo.com/2017/01/18/Fortran数组的C++实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Calvin Neo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Calvin's Marbles">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Fortran数组的C++实现
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-18T16:01:21+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>最近在写CFortranTranslator，一个从Fortran77/Fortran90到C++14的工具，其中涉及到使用C++为Fortran实现一个数组库。<br>总的来讲，Fortran90的有些语言特性在编写和编译上都让人不是很舒服。比如没有头文件和前置声明，这导致了许多额外的代码和解析工作，比如<code>INTERFACE</code>块因此而生（但其实也是一个比较好的解决方案，和前置声明也差不多）。又比如Fortran兼容老标准的问题，这个写C++的同学也应该深有同感，C++为了保持和C的linkage做了不少擦屁股的事情，像什么POD、函数指针/函数对象啥的。Fortran老标准中允许隐式声明变量，而且可以通过名字推断变量的类型，而且由于<code>COMMON</code>块的存在还要兼容一些奇妙的用法。这使得处理变量声明的工作要延迟到处理函数体时。Fortran90还可以直接根据Attribute specification statements给变量加属性(ISO/IEC 1539 : 1991 ch5.2)，加上隐式声明的情况，实际上类似于<code>INTENT</code>、<code>PARAMETER</code>、<code>DIMENSION</code>这样的语句需要考虑是生成一段新变量声明还是修改老声明，这同样会延迟处理变量声明的工作，还会要求建立符号表。此外各种impied-do结构，虽然可以完全展开成for循环，但是为了保持Fortran源语句的抽象，最好还是做成一个表达式。还有Fortran77里面的nonblock DO construct非常恶心，从语法上完全无法解析了，最偷懒的办法就是先用start condition给flex开洞，再<code>#define YYLEX</code>给bison开洞。不过后来token级的continuation迫使我直接手写词法分析了，果然偷懒还是要不得的。<br>此外Fortran的传参机制也很特别，类似于宏的形式，基于引用，具体类型和限定要在函数体中才能看到。为了能够兼容语义，我全部使用了右值作为参数限定<br>关于C++元编程的部分可以参考<a href="/2016/12/22/C++-meta-programming/">C++模板编程</a>这篇文章中，关于使用flex/bison进行语法分析的部分我放到了<a href="/2016/07/29/flex%E5%92%8Cbison%E4%BD%BF%E7%94%A8/">flex和bison使用</a>，其他的部分放在这里。</p>
<a id="more"></a>
<h1 id="Fortran数组简介"><a href="#Fortran数组简介" class="headerlink" title="Fortran数组简介"></a>Fortran数组简介</h1><p>Fortran语言的实现常常要比C快，其中数组是功不可没的。<br>在C语言中，数组常常会被decay成指针来处理，而这会在优化时造成pointer aliasing的问题。<br>一方面C/C++编译器遵循strict aliasing规则，即不同类型的指针绝不会指向同一块内存。具体的说下面的情况被视为相同类型：</p>
<ol>
<li>被signed/unsigned/const/volatile所修饰 </li>
<li>被一个聚合或联合所包含</li>
<li>继承自一个基类</li>
<li>类型<code>char*</code>和<code>void**</code>可以alias任何其他类型<br>这样当你写出这样的神奇代码的时候，编译器至少能有个warning<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    *b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f((<span class="keyword">float</span>*)&amp;a));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>在另一方面，我们还是无法容易得知道两个相同类型的指针是否alias，即指向同一块内存。这时候Pointer aliasing的问题会阻碍编译器进行优化，虽然restrict关键字可以一定程度上减少这个问题。Fortran数组就彻底没有这样的烦恼。</p>
<h1 id="for1array-lt-typename-T-gt"><a href="#for1array-lt-typename-T-gt" class="headerlink" title="for1array&lt;typename T&gt;"></a>for1array&lt;typename T&gt;</h1><p>一开始的想法是实现一个<code>for1array&lt;T&gt;</code>，一个一维的数组。可以理解为对C++原生数组的一个包装，使得数组能够自定义上下界，和列优先的存储模式。事实上这种嵌套(nested)数组在实现Fortran的内在函数时存在相当大的麻烦。<br>例如将初始化序列按列映射到一个嵌套的数组<code>for1array&lt;for1array&lt;...for1array&lt;T&gt;...&gt;&gt; farr</code>中，如果通过通常的递归来做，那么就要自结构最里面从内而外<code>for1array&lt;T&gt;</code>进行递归创建这个数组，但这难于实现。一个可能的解决方案对于嵌套的<code>for1array</code>数组按照通常一样从外到内进行递归遍历，而计算<code>farr[a1][a2]...[an]</code>时对应的一维序列中的位置。对于<code>farr</code>数组中的第k层的指针增加1，实际上相当于一维序列中向后移动<code>size[1] * size[2] * ... size[k-1]</code>，其中<code>size[i]</code>为<code>farr</code>中第i层的大小。<br>但是对于<code>transpose</code>这样的函数使用嵌套数组实现的代价就相当大了，特别地，Fortran90标准对转置秩大于2的数组并没有规定行为：</p>
<blockquote>
<p>13.13.109 TRANSPOSE (MATRIX)<br>Description. Transpose an array of rank two.<br>Class. Transformational function.<br>Argument. MATRIX may be of any type and must have rank two.</p>
</blockquote>
<p>因此实际上对于一个N维/秩数组$X$，假设第$i$维的取值范围是$[0, n_i]$，定义转置$X^T$，满足$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$。</p>
<h1 id="farray-lt-typename-T-int-D-gt"><a href="#farray-lt-typename-T-int-D-gt" class="headerlink" title="farray&lt;typename T, int D&gt;"></a>farray&lt;typename T, int D&gt;</h1><p>Fortran90标准中数组的维数，上下界都是确定的，称为显式形状数组(explicit-shape)。此外，除了动态数组(deferred-shape)，即使出现的可调数组(automatic explicit-shape)（类似于C99中的Flex Array）、假定形状数组(assumed-shape)（仅给出维/秩数）和假定大小数组(assumed-size)（最后一维的上下界是不定的）也是作为哑元（形参的）。Fortran77标准更是使用完全静态环境(fully static environment)的运行时（《编译原理及实践》§7），因此都不支持递归调用。因此Fortran多维数组并不需要锯齿数组，也不需要实现类似动态表的自扩，所以内部可以通过一个一维的线性表data来保存数据。相对于C的数组而言，Fortran中数组是按照列优先顺序(column-major order)存储的。在实现数组时，应当考虑空间局部性的问题，将同列的元素尽可能一同存储（注意C++是行优先顺序）。在Fortran数组的内部实现中如果出现嵌套循环、递归，也应当保证内层循环/递归处理同一列，对于多维数组则是遍历最左边下标。</p>
<h2 id="编译期维护数组各维度上下界的尝试"><a href="#编译期维护数组各维度上下界的尝试" class="headerlink" title="编译期维护数组各维度上下界的尝试"></a>编译期维护数组各维度上下界的尝试</h2><p>因为要尽可能保证和源代码一致性，所以不能将上界统一改为0开始，在设计时需要使用在对象中维护每一维的上下界。于是自然想到是否可以在编译期进行上下界的相关计算，一个很挫的思路是将每一维的上下界放入模板参数里面，然后通过parameter unpack提取出来。另外还有想法是借助constexpr而不是模板，例如<a href="http://stackoverflow.com/questions/27083755/copy-array-in-constexpr-constructor" target="_blank" rel="noopener">使用constexpr构造函数</a>（注意目前使用的<a href="https://msdn.microsoft.com/en-us/library/hh567368.aspx" target="_blank" rel="noopener">MSVC2015</a>无法编译，原因是尚不支持<a href="https://isocpp.org/wiki/faq/cpp14-language#extended-constexpr" target="_blank" rel="noopener">Extended Constexpr</a>）。但事实上即使能编译，<code>constexpr</code>也不是一个强制性声明，编译器仍然可以选择将其放到运行期完成。其实<code>constexpr</code>也被用来“糊弄”编译器。<br><a href="http://stackoverflow.com/questions/37602057/why-isnt-a-for-loop-a-compile-time-expression" target="_blank" rel="noopener">StackOverflow上的这篇回答</a>解释了这样做的原因。回答列举了一个希望使用<code>for</code>遍历<code>std::tuple</code>的例子，我们知道C++是静态类型的且<code>std::tuple</code>的参数包中可能包含不同类型，所以<code>for (const auto &amp; x : my_tuple)</code>这样的做法就是在和C++标准过不去；但使用一个index来“遍历”<code>std::tuple</code>中的元素也是不行的，例如<code>for (constexpr i = 0; i &lt; 10; ++i)</code>，程序员完全可以将这个<code>i</code>作为<code>std::get</code>的非类型模板参数来构造出可能属于不同类型的变量。<br>通过答主的这个例子可以知道一个constexpr的for对当前的C++来说是不切实际的，事实上我们可以采用一些方法可以实现编译期的循环结构，比如变循环为递归，把index放到模板参数里面。对于C++14，可以借助于<code>index_sequence</code>来<a href="http://blog.jobbole.com/112106/?utm_source=blog.jobbole.com&utm_medium=relatedPosts" target="_blank" rel="noopener">辅助进行包展开</a>，对于C++17可以去<a href="http://en.cppreference.com/w/cpp/language/fold" target="_blank" rel="noopener">fold</a>一个<code>index_sequence</code>。</p>
<h2 id="实现transpose"><a href="#实现transpose" class="headerlink" title="实现transpose"></a>实现transpose</h2><p>现在实现<code>transpose</code>函数，<code>transpose</code>函数主要是通过变换$n_i$和对应的一维序列，满足上面式子。<br>对于原矩阵$X[a_1][a_2]…[a_n]$，可以映射到$X$对应的一维序列的第$\sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$项，令$\prod_{N + 1}^{N}{} = 1  $；<br>对于转置后的矩阵$X^T[b_1][b_2]…[b_n]$，令其每一维大小为$n’_i $，可得$n’_i = n_{N + 1 - i}$，可以映射到$X^T$对应的一维序列的第$\sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$项，其中令$\prod_{1}^{0}{} = 1 $。<br>根据$X[a_1][a_2]…[a_n]$ = $X^T[a_n][a_{n-1}]…[a_1]$，带入$b_i = a_{N + 1 - i}$，可以得到映射规则$X: \sum_{i=1}^{N}{(a_i \times \prod_{j = i + 1}}^{N}{n_j})$ $\Rightarrow$ $X^T: \sum_{i=1}^{N}{(b_i \times \prod_{j = i + 1}}^{N}{n’_j})$ = $\sum_{i=1}^{N}{(a_{N + 1 - i} \times \prod_{j = i + 1}}^{N}{n_{N + 1 - j}})$。<br>以上是对于C-style的数组讨论的，对于Fortran-style的数组，将$\Sigma$的上下界改成$0 .. i - 1$<br>此外，对于<a href="http://www.cnblogs.com/illuminator/archive/2013/04/22/3036061.html" target="_blank" rel="noopener">2维非方阵矩阵转置有$O(1)$空间的方法</a>，主要是按照序号从小到大遍历矩阵中的每个元素，希望能够找到以它开始的环。容易看出一个环没有被遍历过当前仅当当前序号是环中最小的序号。</p>
<h2 id="slice数组片段"><a href="#slice数组片段" class="headerlink" title="slice数组片段"></a>slice数组片段</h2><p>fortran中的slice是by reference的，对slice的修改也是对原数组的修改，于是要实现一个<code>forslice</code>函数，其返回的slice应当是数组片段的引用。对于这种情况，首先可以考虑使用<code>std::vector&lt;std::shared_ptr&lt;T&gt;&gt; data</code>来实现内部的线性表data，但是这样会产生不必要的空间开销。因为虽然每一个slice是不一样的，没办法对<code>std::shared_ptr&lt;std::vector&lt;T&gt;&gt; data</code>，但是每个slice的data部分是作为一个整体的。所以还是使用的裸指针RAII，对于从<code>forslice</code>函数构造的<code>farray&lt;T&gt;</code>，在构造时加一个tag，析构时不释放指针即可，类似view的行为。考虑到Fortran77标准本身的完全静态环境（Fortran90可能是基于栈的），所以不会出现悬挂指针导致的AV错误。<br>此外fortran中还允许使用<code>(/ /)</code>这样的Delimiters来具体指定位置组成数组片段，例如<code>A((/1,2/))</code>表示选取A中的第1和第2个元素。要实现这个功能只需要给<code>slice_info</code>做一些修改，加一个迭代器即可，考虑到这个功能并不常用，所以并没有实现。</p>
<h2 id="数组的秩"><a href="#数组的秩" class="headerlink" title="数组的秩"></a>数组的秩</h2><p>此外fortran中有使用到数组的秩作为参数（通常参数名为dim）的函数，要注意秩是从1开始计算的。</p>
<h1 id="farray-lt-typename-T-gt"><a href="#farray-lt-typename-T-gt" class="headerlink" title="farray&lt;typename T&gt;"></a>farray&lt;typename T&gt;</h1><p>fortran有一个slice操作，它返回的维数是不固定的，例如<code>a(:, 1, 1:2)</code>返回一个2维的数组，但是<code>a(:, 1, 1:1)</code>返回一个三维的数组，虽然这两个数组所承载的数据是一样的。这给实现带来了困难，因为返回类型是根据<code>slice_info</code>的初始化列表来决定的，为了追求语法尽可能简单，贴近fortran源码，对<code>slice_info</code>这样的工具类模板开洞是不太好的，因此决定将维数参数也移出模板参数。<br>因此将<code>farray&lt;T&gt;</code>的数据分成两块，第一块是有关形状的元数据，通过<code>reset_array</code>来设置；另一块是数据本身，通过<code>reset_value</code>来设置。在数组声明（构造函数）时，可以确定数组形状，可以顺带赋值；在数组（<code>operator=</code>）赋值时只能赋值，<strong>而不使用目标右值的形状</strong>。<br>再一次说明，这样带来了额外的空间开销<code>lb</code>用来存储上界，<code>sz</code>用来存储大小。由于fortran数组是按列存储，越往后的下边周期越长，因此预先计算<code>delta</code>也就是第<code>d</code>维是<code>i</code>时数组的长度，用来辅助运算。可以看到是把整个数组的运算都放到了运行期，而这些东西完全是编译器决定的。显然我们可以在把fortran编译到C++的阶段处理这些东西，但是要不这让生成的代码因为带上这些附加的数据显得非常难看，要不就会损失掉fortran原来的语义，例如将fortran的数组整合成上界始终是<code>0</code>，按行存储的数组。所以唯一的办法是利用元编程，让C++编译器在模板阶段处理这些东西。</p>
<h1 id="fortran数组的内在函数"><a href="#fortran数组的内在函数" class="headerlink" title="fortran数组的内在函数"></a>fortran数组的内在函数</h1><h2 id="处理dim参数"><a href="#处理dim参数" class="headerlink" title="处理dim参数"></a>处理dim参数</h2><p><code>minloc</code>、<code>maxloc</code>、<code>all</code>、<code>any</code>等函数可以传<code>dim</code>参数。这个<code>dim</code>参数实际上就是数组的秩(rank)。fortran中数组的秩类似于C++中数组的维数(dimension)，但是秩是从1开始算的（可是参数叫dim呢）。<br>在fortran90标准中并没有签名为<code>RESULT = MAXLOC(ARRAY, DIM [, MASK]) </code>，从<a href="https://gcc.gnu.org/onlinedocs/gfortran/MAXLOC.html#MAXLOC" target="_blank" rel="noopener">gfortran的文档中</a>了解到这个函数时从95标准后新增加的。在实现这个函数的时候产生了困惑，对于高维数组，这个<code>maxloc</code>函数到底返回什么呢？gfortran文档中只给出：</p>
<blockquote>
<p>if the DIM argument is supplied, determines the locations of the maximum element along each row of the array in the DIM direction.<br>If DIM is present, the result is an array with a rank one less than the rank of ARRAY, and a size corresponding to the size of ARRAY with the DIM dimension removed.</p>
</blockquote>
<p>后来我在<a href="http://www.lahey.com/docs/lfprohelp/F95ARMAXLOCFn.htm" target="_blank" rel="noopener">这里</a>找到了一个例程：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span> :: i6(<span class="number">6</span>) = (/-<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">19</span>,<span class="number">1</span>/)</span><br><span class="line"><span class="keyword">integer</span> :: i23(<span class="number">2</span>,<span class="number">3</span>) = <span class="built_in">reshape</span>((/-<span class="number">14</span>,<span class="number">3</span>,<span class="number">0</span>,-<span class="number">2</span>,<span class="number">19</span>,<span class="number">1</span>/),<span class="built_in">shape</span>(i23))</span><br><span class="line"><span class="built_in">write</span>(*,<span class="string">'(2i4)'</span>) i23         <span class="comment">! writes -14   3</span></span><br><span class="line">							<span class="comment">!          0  -2</span></span><br><span class="line">							<span class="comment">!         19   1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="built_in">maxloc</span>(i6)        <span class="comment">! writes 5</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="built_in">maxloc</span>(i23)       <span class="comment">! writes 1  3</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="built_in">maxloc</span>(i23,<span class="built_in">dim</span>=<span class="number">1</span>) <span class="comment">! writes 2  1  1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="built_in">maxloc</span>(i23,<span class="built_in">dim</span>=<span class="number">2</span>) <span class="comment">! writes 3  1</span></span><br><span class="line"><span class="built_in">write</span>(*,*) <span class="built_in">maxloc</span>(i23,<span class="built_in">dim</span>=<span class="number">1</span>,mask=(i23 &lt; <span class="number">10</span>))</span><br><span class="line">							<span class="comment">! writes 2  1  2</span></span><br></pre></td></tr></table></figure>

<p><code>maxloc(a, dim=1)</code>这个函数返回的是<code>[lb[dim], sz[dim]]</code>构成的<code>dim-1</code>维数组，令剩下来的维数取遍所有组合，对于每一种取组合，给出取得最大值时候对应原数组第dim维的下标，即$ \underset{i_{dim}}{\arg\min}(b(i_{dim})),  \forall b = a(i_1, …, i_{dim - 1}, :, i_{dim + 1}, …, i_n)$<br>这个例子中，列是第一维，行是第二维。<br>于是对于此类函数可以抽象成<code>reduce</code>函数，对于不带<code>dim</code>参数的重载版本，这是对于原数列的<code>reduce</code>操作；对于带<code>dim</code>的版本，这是对于一个<code>rank-1</code>的数组中的每个元素（是一个一维数组）进行reduce操作。</p>
<h2 id="处理mask参数"><a href="#处理mask参数" class="headerlink" title="处理mask参数"></a>处理mask参数</h2><p><code>minloc</code>、<code>maxloc</code>、<code>all</code>、<code>any</code>等函数还可以传<code>mask</code>参数。这个参数是一个逻辑表达式，实际上类似于一个谓词，并且这个谓词需要<a href="http://www.personal.psu.edu/jhm/f90/lectures/19.html" target="_blank" rel="noopener">使用当前作用域内的变量</a>。至此为止用实现一个<code>[&amp;](){/* expressions directly translated from fortran */}</code>的lambda表达式即可。比较麻烦的是这lambda的函数体内部直接使用数组名，而谓词是作用于数组的元素上的。并且在整个函数调用的可见范围内，无法判断lambda函数体中的变量究竟是数组还是标量，例如下面的情况：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>,<span class="keyword">dimension</span>(<span class="number">8</span>)::N1, N2</span><br><span class="line"><span class="keyword">integer</span>::N3</span><br><span class="line"><span class="built_in">print</span> *, <span class="built_in">maxval</span>(N2, mask = N1 &lt; <span class="number">5</span>) <span class="comment">! N1 is array</span></span><br><span class="line"><span class="built_in">print</span> *, <span class="built_in">maxval</span>(N2, mask = N3 &lt; <span class="number">5</span>) <span class="comment">! N3 is scalar</span></span><br></pre></td></tr></table></figure>

<p>由于编译器实际上并没有建立符号表，在处理<code>maxval(N2, mask = N1 &lt; 5)</code>这个调用时并不能知道N1，N2，N3的类型与定义位置。所以也就无法将数组改为对应的元素形式了。<br>有两种方法解决这个问题：<br>第一种，将这个谓词作为表达式来计算，最后返回一个布尔值数组。这需要重载运算符和fortran的内在函数。<br>第二种，是实现一个模板函数<code>formap(F f, T x)</code>和重载版本<code>formap(F f, farray&lt;T&gt; x)</code>，然后对于所有的变量<code>x</code>，用<code>formap(predicate, x)</code>包一下就好了</p>
<h1 id="fortran数组中的运算符重载"><a href="#fortran数组中的运算符重载" class="headerlink" title="fortran数组中的运算符重载"></a>fortran数组中的运算符重载</h1><p>fortran中数组可以对同样长度的数组和标量进行算术运算和比较运算等，所以需要实现一系列重载函数</p>
<h1 id="数组声明"><a href="#数组声明" class="headerlink" title="数组声明"></a>数组声明</h1><p>数组声明注意点比较多。首先给出fortran中声明(declare)和定义(define)的区别</p>
<blockquote>
<p>The term <strong>declaration</strong> refers to the specification of <strong>attributes</strong> for various program entities. Often this involves<br>specifying the <strong>data type</strong> of a named data object or specifying the <strong>shape</strong> of a named array object.<br>The term <strong>definition</strong> is used in two ways. First, when a data object is <strong>given a valid value</strong> during program<br>execution, it is said to become defined. This is often accomplished by execution of an <strong>assignment statement</strong> or<br><strong>input statement</strong>. Under certain circumstances, a variable does not have a predictable value and is said to be<br><strong>undefined</strong>. Section 14 describes the ways in which variables may become defined and undefined. The second<br>use of the term definition refers to the declaration of derived types and procedures.</p>
</blockquote>
<p>简而言之，声明(declaration)，指的是设置变量的type或者attribute，而定义(definition)是给变量初始化。</p>
<p>下面考虑数组的声明方式。首先fortran77中可以使用下面的方式声明</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REAL</span>        A(<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>)             <span class="comment">! 类型说明（常用）</span></span><br><span class="line"><span class="keyword">DIMENSION</span>   A(<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>)             <span class="comment">! DIMENSI0N语句（常用）</span></span><br><span class="line"><span class="comment">! COMMON</span></span><br></pre></td></tr></table></figure>

<p>fortran90中可以使用下面的方式声明</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REAL</span>，<span class="keyword">DIMENSION</span>(<span class="number">2</span>,<span class="number">5</span>):: D          <span class="comment">! 类型说明中的DIMENSION属性（最常用）</span></span><br><span class="line"><span class="keyword">REAL</span>，<span class="keyword">ALLOCATABLE</span>::    E(:,:,:)   <span class="comment">! 类型说明中的ALLOCATABLE属性</span></span><br><span class="line"><span class="keyword">REAL</span>，<span class="keyword">POINTER</span>::        F(:,:)     <span class="comment">! 类型说明中的POINTER属性</span></span><br><span class="line"><span class="keyword">POINTER</span>     C(:,:,:)              <span class="comment">! POINTER语句</span></span><br><span class="line"><span class="keyword">ALLOCATABLE</span> B(:,:)                <span class="comment">! ALLOCATABLE语句</span></span><br></pre></td></tr></table></figure>

<p>根据fortran90标准section5</p>
<blockquote>
<p>R501 type-declaration-stmt is type-spec [ [ , attr-spec ] … :: ] entity-decl-list<br>entity-decl is object-name [ ( array-spec ) ]  [ * char-length ] [ = initialization-expr ]<br>    or function-name] [ * char-length ]</p>
</blockquote>
<p>其中array-spec就是<code>dimension()</code>语句括号中的东西，表示数组的形状。<br>注意：</p>
<ol>
<li>声明中并不一定要出现double colon separator<code>::</code>，但是当有初始化语句initialization-expr时，必须要有这个分隔符<br>这在语法分析时可能出现语义冲突导致二义性文法，原因是<code>integer</code>、<code>real</code>等既可以作为类型限定符，也可以作为函数名，所以实际上要去掉<code>callable_head</code>规则，将它统一合并入<code>callable</code>规则</li>
<li>char-length仅允许给字符串指定长度，由于实现上使用的是<code>std::string</code>，所以可以直接去掉这个，我们只需要对变量声明中出现的<code>*</code>号进行特判处理即可。</li>
</ol>
<p>考虑到可以通过<code>REAL R(10) = (/1,2,3,4,5,6,7,8,9,0/)</code>声明数组，所以不能在扫描完<code>type-spec</code>和<code>attr-spec</code>就确定类型，而要根据每一个<code>entity-decl</code>后面是否出现<code>( array-spec )</code>来决定。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">integer</span>::Z</span><br><span class="line"><span class="keyword">dimension</span>:: Z(<span class="number">10</span>)</span><br><span class="line"><span class="comment">! dimension(10)::Z 注意这样的语句是不行的</span></span><br></pre></td></tr></table></figure>

<p>这样的说明也是允许的，考虑到fortran还有隐式声明，事实上第一行还可以直接去掉。所以说即使整个声明语句读下来，仍然不能决定具体的类型是什么：</p>
<blockquote>
<p>5.1.2.4 DIMENSION attribute<br>The DIMENSION attribute specifies that entities whose names are <strong>declared</strong> in this statement are arrays. The<br>rank or the rank and shape are specified by the array-spec, if there is one, in the entity-decl, or by the array-spec<br>in the DIMENSION attribute otherwise. An array-spec in an entity-decl specifies either the rank or the rank and<br>shape for a single array and overrides the array-spec in the DIMENSION attribute. If the DIMENSION attribute<br>is omitted, an array-spec must be specified in the entity-decl to declare an array in this statement.<br>为了解决这个问题，变量的声明必须要在整个变量声明语句块结束之后才能确定（fortran的命令语句必须在所有声明语句后面）。所以只有在<code>program</code>或者<code>function_decl</code>规则中才能对其中的<code>suite</code>规则中的变量名生成定义和初始化语句。<br>这里还要注意一点，变量的隐式声明和隐式类型(implicit type indicated by the first letter)还不一样，后者指的是在声明变量的时候不指出变量的类型，这时候根据变量名的第一个字母来决定是实型还是整型。当然隐式声明和隐式类型是可以同时存在的。</p>
</blockquote>
<h1 id="数组初始化和赋值"><a href="#数组初始化和赋值" class="headerlink" title="数组初始化和赋值"></a>数组初始化和赋值</h1><h2 id="使用数组构造器"><a href="#使用数组构造器" class="headerlink" title="使用数组构造器"></a>使用数组构造器</h2><p>Fortran中的数组构造器(array constructor)我认为是一个很方便实用的功能，根据Fortran90标准，数组构造器使用下面的语法</p>
<blockquote>
<p>array-constructor is (/ ac-value-list /)<br>R432 ac-value is expr or ac-implied-do<br>R433 ac-implied-do is ( ac-value-list , ac-implied-do-control )<br>R434 ac-implied-do-control is ac-do-variable = scalar-int-expr , scalar-int-expr [ , scalar-int-expr ]<br>R435 ac-do-variable is scalar-int-variable</p>
</blockquote>
<p>数组构造器始终是一个<strong>一维</strong>的数组，不能使用数组构造器直接初始化高维数组，而应该使用<code>reshape</code>函数。又注意数组构造器在赋值和构造时都可能用到，所以比较方便的方法是对<code>(/ /)</code>直接生成一维的<code>farray</code><strong>实体</strong>而不是将它直接生成代码到构造函数中作为一个brace-init-list的参数：</p>
<blockquote>
<p>An array constructor is defined as a sequence of specified scalar values and is interpreted as a rank-one array<br>whose element values are those specified in the sequence.</p>
</blockquote>
<p>因为<code>farray</code>的构造函数用来确定数组的形状（顺带赋值是可选的），而赋值放到<code>farray&lt;T&gt;::operator=</code>去做。在实现时因为<code>farray&lt;T&gt;::operator=</code>仅仅是复制内部的线性表data，并不改变形状，可以在不同维数之间给数组赋值。</p>
<h2 id="implied-do"><a href="#implied-do" class="headerlink" title="implied-do"></a>implied-do</h2><p>在上面的定义中<code>ac-implied-do</code>是个特别有意思的东西，与之类似的还有<code>io-implied-do</code>（用于<code>read</code>等io语句）和<code>data-implied-do</code>（用于<code>data</code>语句），称为隐式Do循环(Implied Do Loop)。<br>标准中对循环的特性做出了这样的规定</p>
<blockquote>
<p>If an ac-value is an ac-implied-do, it is expanded to form an ac-value sequence under the control of the ac-do-variable, as in the DO construct (8.1.4.4).</p>
</blockquote>
<p>以<code>ac-implied-do</code>举例，隐式Do循环的的语法通常为</p>
<pre><code>ac-value ::= expr | ac-implied-do
ac-implied-do ::= ( ac-value-list , scalar-int-expr , scalar-int-expr [ , scalar-int-expr ] )
</code></pre>
<p>在转换中为了保留隐式DO循环的结构，所以我们尽可能避免将这个Implied Do展开为C++中的for循环语句。<br>第一个思路是把整个嵌套的Implied Do深度优先到底，得到最里面的表达式放入一个<code>[&amp;](int do_variable1, int do_variable2, ...){...}</code>里面，然后借助于farray里面的map函数喂给这个lambda块各层do-variable的值。不过由于<code>ac-value-list</code>可能包含不止一个表达式，所以这个方法实际上麻烦。<br>于是有了第二个思路，就是按部就班一层一层处理。但这种方法仍然是要在Implied Do的上下文中处理，因为内层Do的循环过程需要依赖于外层Do对应的do-variable的当前取值。</p>
<h2 id="使用DATA"><a href="#使用DATA" class="headerlink" title="使用DATA"></a>使用DATA</h2><p>data语句可以用来初始化数组，<a href="http://www.personal.psu.edu/jhm/f90/lectures/19.html" target="_blank" rel="noopener">可以采用下面的语法</a></p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> a1/<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>/, a2/<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>/</span><br><span class="line"><span class="keyword">data</span> b/<span class="number">3</span>*<span class="number">1.</span>,<span class="number">4</span>*<span class="number">2.</span>,<span class="number">3</span>*<span class="number">3.</span>/</span><br><span class="line"><span class="keyword">data</span> c(<span class="number">1</span>),c(<span class="number">2</span>),c(<span class="number">3</span>),c(<span class="number">4</span>)/<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>/</span><br><span class="line"><span class="keyword">data</span> (d(j),j=<span class="number">1</span>,<span class="number">4</span>)/<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>/</span><br></pre></td></tr></table></figure>

<p>其中值得注意的是第二条语句中的<code>*</code>并不是二元算术运算符，而是表示该元素的重复次数</p>
<h2 id="使用WHERE"><a href="#使用WHERE" class="headerlink" title="使用WHERE"></a>使用WHERE</h2><h1 id="生成AST"><a href="#生成AST" class="headerlink" title="生成AST"></a>生成AST</h1><div style="display:none">
会碰到这样的问题，例如翻译上面的数组生成器，可以生成一个`NT_ARRAYBUILDER`节点，所以`NT_ARRAYBUILDER`也是一个`NT_EXPRESSION`节点，而数组生成器是可以出现的等号右边构成表达式，于是也可以作为赋值式归约成`NT_EXPRESSION`节点。所以问题存在于直接将`NT_ARRAYBUILDER`立即归约成表达式`NT_EXPRESSION`节点还是当`NT_ARRAYBUILDER`和新的串构成例如赋值式时再归约成表达式。
对于第一种方法，会在AST的深度方向产生较多的**不确定深度**的节点，例如在`NT_FUNCTION_ARRAY`会被归约成`NT_EXPRESSION`。出现这种问题主要是我在列表方面有点偷懒，只设置了一个`paramtable`，一般非终结符必须要归约成`NT_EXPRESSION`才行，此外，只要列表中含有slice，所有元素都被promote成slice；进一步地，只要列表中含有键值对，所有的元素都被promote成键值对。如果修改语法，可能也要修改语义处理程序。其次是因为对于所有的运算符（除了赋值），我都将其设置为一个`NT_EXPRESSION`节点
对于第二种方法，容易在单独使用`NT_ARRAYBUILDER`的时候出现问题，例如使用`if(X == NT_EXPRESSION)`筛选`NT_EXPRESSION`节点时会因为`NT_ARRAYBUILDER != NT_EXPRESSION`造成被误筛掉
</div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Fortran数组相对于C++数组还是有很大的不同的，正因为如此，Fortran数组具有比C++要稍好的（数值计算）性能（如果能够正确使用的话）。例如Fortran的数组模型非常适合编译器针对处理器做矢量优化，而到了C++中数组往往会退化成一个指针，这可能会妨碍编译器了解内存布局，从而进行优化。此外就指针本身，Fortran也没有C++的Pointer Alias的开销。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div></div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/img/fkm/wxfk.jpg" alt="Calvin Neo WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/img/fkm/zfbfk.jpg" alt="Calvin Neo Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C++</a>
          
            <a href="/tags/fortran/" rel="tag"># fortran</a>
          
            <a href="/tags/编译原理/" rel="tag"># 编译原理</a>
          
            <a href="/tags/编译器/" rel="tag"># 编译器</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/02/C++static-usage/" rel="next" title="C++中static关键字的用法">
                <i class="fa fa-chevron-left"></i> C++中static关键字的用法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/01/27/C++中编译器优化导致的一个问题/" rel="prev" title="C++中编译器优化导致的一个问题">
                C++中编译器优化导致的一个问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/favicon.jpg"
               alt="Calvin Neo" />
          <p class="site-author-name" itemprop="name">Calvin Neo</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">199</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">143</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CalvinNeo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/CalvinNeo0" target="_blank" title="Twitter">
                  
                    <i class="fa fa-fw fa-twitter"></i>
                  
                  Twitter
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/1568200035" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://xqq.im/" title="xqq" target="_blank">xqq</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://www.lovelywen.com/" title="wenwen" target="_blank">wenwen</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://smlight.github.io/blog/" title="zyyyyy" target="_blank">zyyyyy</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Fortran数组简介"><span class="nav-number">1.</span> <span class="nav-text">Fortran数组简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#for1array-lt-typename-T-gt"><span class="nav-number">2.</span> <span class="nav-text">for1array&lt;typename T&gt;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#farray-lt-typename-T-int-D-gt"><span class="nav-number">3.</span> <span class="nav-text">farray&lt;typename T, int D&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译期维护数组各维度上下界的尝试"><span class="nav-number">3.1.</span> <span class="nav-text">编译期维护数组各维度上下界的尝试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实现transpose"><span class="nav-number">3.2.</span> <span class="nav-text">实现transpose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slice数组片段"><span class="nav-number">3.3.</span> <span class="nav-text">slice数组片段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组的秩"><span class="nav-number">3.4.</span> <span class="nav-text">数组的秩</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#farray-lt-typename-T-gt"><span class="nav-number">4.</span> <span class="nav-text">farray&lt;typename T&gt;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fortran数组的内在函数"><span class="nav-number">5.</span> <span class="nav-text">fortran数组的内在函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理dim参数"><span class="nav-number">5.1.</span> <span class="nav-text">处理dim参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#处理mask参数"><span class="nav-number">5.2.</span> <span class="nav-text">处理mask参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#fortran数组中的运算符重载"><span class="nav-number">6.</span> <span class="nav-text">fortran数组中的运算符重载</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组声明"><span class="nav-number">7.</span> <span class="nav-text">数组声明</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数组初始化和赋值"><span class="nav-number">8.</span> <span class="nav-text">数组初始化和赋值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用数组构造器"><span class="nav-number">8.1.</span> <span class="nav-text">使用数组构造器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#implied-do"><span class="nav-number">8.2.</span> <span class="nav-text">implied-do</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用DATA"><span class="nav-number">8.3.</span> <span class="nav-text">使用DATA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用WHERE"><span class="nav-number">8.4.</span> <span class="nav-text">使用WHERE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#生成AST"><span class="nav-number">9.</span> <span class="nav-text">生成AST</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">10.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Calvin Neo</span>
  <span> &nbsp; Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a></span>
</div>
<div>
  <span><a href="/about/yytl/">版权声明</a></span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse 
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://www.calvinneo.com/2017/01/18/Fortran数组的C++实现/';
          this.page.identifier = '2017/01/18/Fortran数组的C++实现/';
          this.page.title = 'Fortran数组的C++实现';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://calvinneo.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      $('#local-search-input').focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
